- en: Chapter 5. Using AirPlay and Core Image
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 使用 AirPlay 和 Core Image
- en: Starting with the release of iOS 4.2, developers could use AirPlay to stream
    videos, audios, and photos to an Apple TV capable device. In iOS 5, it is now
    even easier to wirelessly mirror everything, automatically, on your iPad 2 to
    an HDTV through Apple TV.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从iOS 4.2的发布开始，开发者可以使用AirPlay将视频、音频和照片流式传输到支持Apple TV的设备。在iOS 5中，现在甚至更容易通过Apple
    TV自动无线镜像iPad 2上的所有内容到HDTV。
- en: With the additional set of APIs that come as a part of iOS 5, applications which
    are built using the AV Foundation framework now support encrypted audio and video
    streams, which are delivered through HTTP Live Streaming, and can also display
    different content on each of the HDTV and the iPad 2 screens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着iOS 5中提供的附加API集，使用AV Foundation框架构建的应用程序现在支持加密的音频和视频流，这些流通过HTTP Live Streaming传输，并且可以在每个HDTV和iPad
    2屏幕上显示不同的内容。
- en: The Core Image framework is a hardware-accelerated framework that provides an
    easy way to enhance photos and videos. This enables you to create amazing effects
    in your camera and image editing applications. **Core Image** provides several
    built-in filters, such as color effects, distortions, and transitions. It also
    includes advanced features, such as auto-enhance, red-eye reduction, and facial
    recognition.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Core Image 框架是一个硬件加速框架，它提供了一种简单的方式来增强照片和视频。这使得你可以在相机和图像编辑应用程序中创建惊人的效果。**Core
    Image** 提供了几个内置的过滤器，如色彩效果、扭曲和过渡。它还包括高级功能，如自动增强、红眼减少和面部识别。
- en: In this chapter, we will be taking a closer look into what each of these frameworks
    are, and how to go about implementing these within our applications. We will take
    a look at how to incorporate AirPlay within our applications, and have this information
    directed to another output device using Apple TV. We will also be taking a look
    into the Core Image framework, and how to use the various filter effects using
    the `CIImage` class.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解这些框架是什么，以及如何在我们的应用程序中实现它们。我们将查看如何在我们的应用程序中集成AirPlay，并使用Apple TV将信息导向另一个输出设备。我们还将查看Core
    Image框架，以及如何使用`CIImage`类使用各种过滤器效果。
- en: 'In this chapter, we will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about the AirPlay and Core Image frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 AirPlay 和 Core Image 框架
- en: Create a simple AirPlay and Core Image application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的AirPlay和Core Image应用程序
- en: Learn how to output application content to an Apple TV device
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将应用程序内容输出到Apple TV设备
- en: Take a look at how to apply various filter effects for distortions, transitions,
    and color effects, using the `CIImage` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看如何使用 `CIImage` 类应用各种过滤器效果，用于扭曲、过渡和色彩效果
- en: We have some fantastic stuff to cover in this chapter. So, let's get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨一些精彩的内容。那么，让我们开始吧。
- en: Understanding the AirPlay framework
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 AirPlay 框架
- en: The AirPlay framework is an updated framework that lets you stream audio and
    video content from any iOS-based device to any Airplay-enabled device that is
    capable of playing audio and video, such as television sets and audio systems.
    Starting with iOS 5, developers now have the flexibility to incorporate Airplay
    content into their applications, and have this information presented out to a
    nearby Apple TV 2 receiver.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: AirPlay框架是一个更新的框架，允许您从任何基于iOS的设备流式传输音频和视频内容到任何支持Airplay的设备，这些设备能够播放音频和视频，例如电视和音频系统。从iOS
    5开始，开发者现在可以灵活地将Airplay内容集成到他们的应用程序中，并将这些信息输出到附近的Apple TV 2接收器。
- en: In this section, we will take a look at how to create a simple application to
    playback video content on an iOS device, and then take a look at the steps involved
    to output this to an Apple TV 2 device.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看如何创建一个简单的应用程序，在iOS设备上播放视频内容，然后查看将此内容输出到Apple TV 2设备所需的步骤。
- en: Creating a simple AirPlay application
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的AirPlay应用程序
- en: Playing videos is one of the most common tasks that can be done on any iOS device,
    all videos must be played and displayed in full-screen. Before we can play any
    videos, we need to add the Media Player framework into our application project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 播放视频是任何iOS设备上最常见的一项任务，所有视频都必须全屏播放和显示。在我们能够播放任何视频之前，我们需要将媒体播放器框架添加到我们的应用程序项目中。
- en: Before we can proceed, we first need to create our `AirPlayExample` project.
    To refresh your memory on how to go about creating a new project, you can refer
    to the section that we covered in [Chapter 1](ch01.html "Chapter 1. What's New
    in iOS5"), *What's New in iOS5*, under the section named *Creating the MyEmailApp
    application*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们首先需要创建我们的`AirPlayExample`项目。为了回忆如何创建新项目，你可以参考我们在[第1章](ch01.html "第1章。iOS5的新特性")中覆盖的章节，名为*Creating
    the MyEmailApp application*下的*What's New in iOS5*。
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/Xcode4/Applications`文件夹中启动Xcode。
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Create a new Xcode project**，或**File | New Project**。
- en: Select the **Single View Application** template from the list of available templates.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用模板列表中选择**Single View Application**模板。
- en: Select **iPhone** from under the **Device Family** drop-down.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Device Family**下拉菜单中选择**iPhone**。
- en: Click on the **Next** button to proceed to the next step in the wizard.![Creating
    a simple AirPlay application](img/2267EXP_05_01.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Next**按钮继续到向导的下一步。![创建一个简单的AirPlay应用](img/2267EXP_05_01.jpg)
- en: Enter in `AirPlayExample` as the name for your project, and then click on the
    **Next** button to proceed to the next step of the wizard.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称输入为`AirPlayExample`，然后点击**Next**按钮继续到向导的下一步。
- en: Specify the location where you would like to save your project.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定你想要保存项目的位置。
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Save**按钮继续并显示Xcode工作区环境。
- en: 'Now that we have created our `AirPlayExample` project, we now need to add an
    important framework to our project to enable our application with the ability
    to play movie files. To add the Media Player framework to your project, select
    the **Project Navigator Group**, and then follow these simple steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`AirPlayExample`项目，我们需要向项目中添加一个重要的框架，以使我们的应用具有播放电影文件的能力。要将媒体播放器框架添加到你的项目中，选择**Project
    Navigator Group**，然后按照以下简单步骤操作：
- en: Click and select your project from the **Project Navigator**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并从**Project Navigator**中选择你的项目。
- en: Then select your project target from under the **TARGETS** group.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从**TARGETS**组下选择你的项目目标。
- en: Select the **Build Phases** tab.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Build Phases**标签。
- en: Expand the **Link binary with Libraries disclosure** triangle.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**Link binary with Libraries**三角符号。
- en: Finally, use the **+** to add the library you want.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用**+**来添加你想要的库。
- en: Select the **MediaPlayer.framework** from the list of available frameworks.
    You can also search if you can't find the framework you are after, from within
    the list.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用框架列表中选择**MediaPlayer.framework**。如果你在列表中找不到所需的框架，也可以进行搜索。
- en: 'If you are still confused how to go about adding the frameworks, follow this
    screenshot, which highlights the areas that you need to select (surrounded by
    a red rectangle):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不清楚如何添加框架，可以参考以下截图，它突出显示了你需要选择的部分（被红色矩形包围）：
- en: '![Creating a simple AirPlay application](img/2267EXP_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的AirPlay应用](img/2267EXP_05_02.jpg)'
- en: 'Now that you have added the `MediaPlayer.framework` into your project, we need
    to start building our user interface that will be responsible for playing the
    movie:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将`MediaPlayer.framework`添加到你的项目中，我们需要开始构建我们的用户界面，该界面将负责播放电影：
- en: From the Project Navigator, select and open the **ViewController.xib** file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Project Navigator中选择并打开**ViewController.xib**文件。
- en: From the **Object Library**, select and drag a (`UIButton`) Round Rect Button
    control, and add this to our view.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Object Library**中选择并拖动一个圆角矩形按钮（`UIButton`）控件，并将其添加到我们的视图中。
- en: Resize accordingly, then modify the **Object Attributes** section of the Round
    Rect Button, and set its title to `Play Movie`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要调整大小，然后修改圆角矩形按钮的**Object Attributes**部分，并将其标题设置为`Play Movie`。
- en: 'We don''t need to add a stop button, as we will be adding an event that will
    handle this for us when the movie has finished playing. If you have followed the
    steps correctly, your view should look something like that shown in the following
    screenshot. If it doesn''t look quite the same as mine, feel free to adjust yours:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要添加停止按钮，因为我们将在电影播放完毕时添加一个事件来处理它。如果你正确地遵循了步骤，你的视图应该看起来像以下截图所示。如果它看起来和我的一样，请随意调整你的：
- en: '![Creating a simple AirPlay application](img/2267EXP_05_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的AirPlay应用](img/2267EXP_05_03.jpg)'
- en: 'As you can see, our form doesn''t do much at this stage, and if you were to
    run this application in the simulator, you would see the controls as placed out
    on your screen. The following steps will show you how to connect your buttons
    up to action events which will each perform the task of playing the video. So
    let''s get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的表单在这个阶段并没有做什么，如果您在模拟器中运行此应用程序，您会看到控件放置在您的屏幕上。以下步骤将向您展示如何将按钮连接到操作事件，每个事件将执行播放视频的任务。所以让我们开始吧：
- en: 'Open the `ViewController.h` interface file, and create the following highlighted
    entries as shown in the code snippet:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewController.h` 接口文件，并创建以下突出显示的条目，如代码片段所示：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to create an action event. Select the **Play Movie** button, and hold
    down the Control key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple AirPlay application](img/2267EXP_05_04.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个操作事件。选择 **播放电影** 按钮，并按住Control键，将其拖入以下截图所示的 `ViewController.m` 实现文件类中：![创建一个简单的AirPlay应用程序](img/2267EXP_05_04.jpg)
- en: Specify a name for the action that you want to create. Enter in `playMovie`
    as the name of the action.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您要创建的操作指定一个名称。输入 `playMovie` 作为操作的名称。
- en: Set the type of event to be **Touch Up Inside**.![Creating a simple AirPlay
    application](img/2267EXP_05_05.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置事件类型为 **Touch Up Inside**。![创建一个简单的AirPlay应用程序](img/2267EXP_05_05.jpg)
- en: Click on the **Connect** button to have Xcode create the event.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **连接** 按钮让Xcode创建事件。
- en: 'We now need to add the code to our `playMovie` function which will handle playing
    our sample movie file. Enter in the following code snippet for this function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要向 `playMovie` 函数中添加代码，该函数将处理播放我们的示例电影文件。为此函数输入以下代码片段：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have just declared a variable (NSString) `filePath` which will contain the
    file path to our movie file. Next, we create a (NSURL) `fileUrl` that converts
    our file path to an object, which is what the `MPMoviePlayerController` needs
    when it is being initialized. We then add the `MPMoviePlayerController` view to
    our custom view controller, so that it will appear on the screen. We specify that
    we want to display this full screen, and finally we tell the `moviePlayerController`
    to commence playback.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚声明了一个变量（NSString）`filePath`，它将包含电影文件的文件路径。接下来，我们创建一个（NSURL）`fileUrl`，将文件路径转换为对象，这是
    `MPMoviePlayerController` 在初始化时所需的。然后我们将 `MPMoviePlayerController` 视图添加到我们的自定义视图控制器中，以便它在屏幕上显示。我们指定要全屏显示，最后我们告诉
    `moviePlayerController` 开始播放。
- en: Since we have allocated memory to our `moviePlayerController` object, at this
    stage we haven't released it yet, this being due to not knowing when the movie
    playback will actually finish.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为 `moviePlayerController` 对象分配了内存，在这个阶段我们还没有释放它，这主要是因为我们不知道电影播放何时实际上会完成。
- en: Fortunately, the `MPMoviePlayerController` object comes pre-built with methods
    to handle this scenario, and will dispatch a notification method called `MPMoviePlayerPlaybackDidFinishNotification`
    to the `NSNotificationCenter` when the movie playback completes, as shown in the
    highlighted code in the previous snippet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`MPMoviePlayerController` 对象预先构建了处理此场景的方法，并在电影播放完成后向 `NSNotificationCenter`
    发送一个名为 `MPMoviePlayerPlaybackDidFinishNotification` 的通知方法，如前一个代码片段中突出显示的代码所示。
- en: 'When we playback video content within our iPhone applications, you will sometimes
    need to modify the `scalingMode` property of the `MPMoviePlayerController` object.
    By setting this property, it will determine how the movie image adapts to fill
    the playback size that you have defined. The following scaling modes currently
    exist, and are displayed here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在iPhone应用程序中播放视频内容时，有时需要修改 `MPMoviePlayerController` 对象的 `scalingMode` 属性。通过设置此属性，它将确定电影图像如何适应填充您定义的播放大小。以下是目前存在的缩放模式，并在此处显示：
- en: '`MPMovieScalingModeNone`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMovieScalingModeNone`'
- en: '`MPMovieScalingModeAspectFit`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMovieScalingModeAspectFit`'
- en: '`MPMovieScalingModeAspectFill`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMovieScalingModeAspectFill`'
- en: '`MPMovieScalingModeFill`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMovieScalingModeFill`'
- en: The two main common scaling modes used are the `MPMovieScalingModeAspectFill`
    and `MPMovieScalingModeFill`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要的常用缩放模式是 `MPMovieScalingModeAspectFill` 和 `MPMovieScalingModeFill`。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the comparison between the different scaling modes,
    refer to the *MPMoviePlayerController Class Reference* at the following location
    `http://developer.apple.com/library/ios/#documentation/mediaplayer/reference/MPMoviePlayerController_Class/Reference/Reference.html#//apple_ref/doc/c_ref/MPMoviePlayerController`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不同缩放模式之间的比较的更多信息，请参阅以下位置的*MPMoviePlayerController类参考* `http://developer.apple.com/library/ios/#documentation/mediaplayer/reference/MPMoviePlayerController_Class/Reference/Reference.html#//apple_ref/doc/c_ref/MPMoviePlayerController`。
- en: 'In order to implement this property in your application, insert the following
    line of code just before the `[moviePlayerController play]` statement:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的应用程序中实现此属性，请在`[moviePlayerController play]`语句之前插入以下行代码：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you run your application, you will notice that the video fills the entire
    available space. Next, we need to create the `moviePlaybackComplete:` method that
    will be responsible for releasing our `moviePlayerController` object, as shown
    in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您会注意到视频占据了整个可用空间。接下来，我们需要创建`moviePlaybackComplete:`方法，它将负责释放我们的`moviePlayerController`对象，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code snippet, we passed an object to the notification method. This is
    whatever we have passed in the previous code snippet, due to the `moviePlayerController`
    object. We start by retrieving the object using the `[notification object]` statement,
    and then referencing it with the new `MPMoviePlayerController` pointer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们将一个对象传递给了通知方法。这 whatever我们在之前的代码片段中传递的内容，由于`moviePlayerController`对象。我们首先使用`[notification
    object]`语句检索对象，然后使用新的`MPMoviePlayerController`指针引用它。
- en: We then send a message back to the `NSNotificationCenter` method that removes
    the observer we previously registered within our `playMovie` function. We finally
    proceed with cleaning up our custom view controller from our display, and then
    release the memory we previously allocated to our `moviePlayerController` object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向`NSNotificationCenter`方法发送消息，移除我们在`playMovie`函数中之前注册的观察者。我们最后继续清理我们的自定义视图控制器，并释放之前分配给`moviePlayerController`对象的内存。
- en: 'The following screenshot shows our `AirPlayExample` application running within
    the iOS simulator with movie playback set up to be viewed in landscape mode; support
    is available to display this in portrait mode:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的`AirPlayExample`应用程序在iOS模拟器中运行，电影播放设置为横幅模式进行查看；支持在竖幅模式下显示此内容：
- en: '![Creating a simple AirPlay application](img/2267EXP_05_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的AirPlay应用程序](img/2267EXP_05_06.jpg)'
- en: In this section, we learned about the `MediaPlayer` framework, and how we can
    use this within our applications to give us the ability to play audio and video.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了`MediaPlayer`框架，以及我们如何在应用程序中使用它来获得播放音频和视频的能力。
- en: As you can see, by using the Media Player framework and the `MPMoviePlayerController`
    class, you can incorporate movie playback within your iOS applications. In the
    next section, we will look at steps involved in modifying our application, so
    that this can be displayed on a TV screen using Apple TV. We learned about the
    various scaling modes for video playback and how to implement these.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过使用媒体播放器框架和`MPMoviePlayerController`类，您可以将电影播放功能集成到您的iOS应用程序中。在下一节中，我们将探讨修改应用程序的步骤，以便使用Apple
    TV在电视屏幕上显示。我们学习了视频播放的各种缩放模式以及如何实现这些模式。
- en: Using AirPlay to present application content to Apple TV
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AirPlay将应用程序内容呈现到Apple TV
- en: Starting with iOS 4.3, Apple decided to provide its developers with one of the
    most impressive frameworks ever imagined, which would allow developers to integrate
    AirPlay features into their applications. With just a few lines of code, any iOS
    application can be modified to have the ability to stream video directly out to
    an Apple TV device.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从iOS 4.3版本开始，苹果公司决定向其开发者提供迄今为止最令人印象深刻的框架之一，这将允许开发者将AirPlay功能集成到他们的应用程序中。只需几行代码，任何iOS应用程序都可以修改为具有直接将视频流式传输到Apple
    TV设备的能力。
- en: To enable AirPlay functionality, we will need to enable a special property on
    our `MPMoviePlayerController` object, by setting the `allowsAirPlay` property
    to `YES`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用AirPlay功能，我们需要在`MPMoviePlayerController`对象上启用一个特殊属性，通过将`allowsAirPlay`属性设置为`YES`。
- en: 'To enable AirPlay functionality within your application, follow these simple
    steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用程序中启用AirPlay功能，请按照以下简单步骤操作：
- en: 'Open the `ViewController.m` implementation file that is located within the
    `AirPlayExample` folder, and locate the following statement within the `playMovie`
    function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`AirPlayExample`文件夹内的`ViewController.m`实现文件，并在`playMovie`函数中找到以下语句：
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, add the following code snippet:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码片段：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code snippet, we use the `.respondsToSelector:` method of the `MPMoviePlayerController`
    object to cater for older iOS devices that don't support the `allowsAirPlay` property.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们使用`MPMoviePlayerController`对象的`.respondsToSelector:`方法来适应不支持`allowsAirPlay`属性的较旧iOS设备。
- en: If we don't do this, it will cause a run-time error exception to occur which
    will crash your application. In order to offer AirPlay only to those devices that
    support it, we need to place a conditional statement around the statement which
    will check to see if the `MPMoviePlayerController` object supports the `allowsAirPlay`
    option.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们不这样做，它将导致运行时错误异常发生，这将导致您的应用程序崩溃。为了仅向支持AirPlay的设备提供AirPlay，我们需要在检查`MPMoviePlayerController`对象是否支持`allowsAirPlay`选项的语句周围放置一个条件语句。
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When this is set, it will cause an additional icon to appear within the movie
    player controller pane. You have no control, programmatically, over this icon
    placement.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当此设置被激活时，它将在电影播放器控制器面板中引起一个额外图标的显示。您无法通过编程方式控制此图标的位置。
- en: Finally, build and run your application, and click on the **Play Movie** button.
    The following screenshot shows what this icon looks like when AirPlay has been
    enabled:![Using AirPlay to present application content to Apple TV](img/2267EXP_05_07.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建并运行您的应用程序，然后点击**播放电影**按钮。以下截图显示了启用AirPlay时此图标的外观：![使用AirPlay将应用程序内容呈现到Apple
    TV](img/2267EXP_05_07.jpg)
- en: When the AirPlay icon has been pressed, you will be presented with a pop-up
    list of detected output device options to choose from.![Using AirPlay to present
    application content to Apple TV](img/2267EXP_05_08.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下AirPlay图标时，您将看到一个弹出列表，其中包含可选择的检测到的输出设备选项。![使用AirPlay将应用程序内容呈现到Apple TV](img/2267EXP_05_08.jpg)
- en: If you choose the **Apple TV** option as shown in this screenshot, the output
    on your iOS device will disappear, and you will be notified that the video is
    being played on the Apple TV device. This is shown in the following screenshot:![Using
    AirPlay to present application content to Apple TV](img/2267EXP_05_09.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您选择如截图所示的**Apple TV**选项，您的iOS设备上的输出将消失，并且您将收到通知，视频正在Apple TV设备上播放。这如图下所示：![使用AirPlay将应用程序内容呈现到Apple
    TV](img/2267EXP_05_09.jpg)
- en: 'Finally, you will see your video being displayed on an Apple TV device, as
    shown in the following screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您将在Apple TV设备上看到您的视频正在播放，如图下所示：
- en: '![Using AirPlay to present application content to Apple TV](img/2267EXP_05_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用AirPlay将应用程序内容呈现到Apple TV](img/2267EXP_05_10.jpg)'
- en: As you can see, by following a few simple steps, you can easily incorporate
    the functionality needed to turn your existing applications into Airplay-aware
    applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过遵循几个简单的步骤，您可以轻松地将现有应用程序的功能集成到Airplay感知应用程序中。
- en: 'In the following list, you will find a few considerations to keep in mind when
    implementing AirPlay into your projects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，您将找到在将AirPlay集成到您的项目中时需要考虑的一些事项：
- en: Apple has only made this feature available on its most recent devices with the
    AirPlay 4.3 SDK. So, there is no AirPlay support for iPhone 3G devices.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果公司仅在其最新的设备上提供了AirPlay 4.3 SDK的此功能。因此，iPhone 3G设备没有AirPlay支持。
- en: When launching an AirPlay-enabled application, you will need to ensure that
    both your iOS device and your Apple TV software are running the same version of
    the OS, otherwise you could run into some problems.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启动AirPlay启用应用程序时，您需要确保您的iOS设备和Apple TV软件运行的是同一版本的操作系统，否则您可能会遇到一些问题。
- en: In order for iOS devices to find other Apple AirPlay-enabled devices, you will
    need to ensure that you are on the same Wi-Fi network that your AirPlay devices
    are connected to.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让iOS设备找到其他Apple AirPlay启用设备，您需要确保您连接的是与您的AirPlay设备相同的Wi-Fi网络。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the AirPlay framework, you can refer the following
    Apple Developer website: [http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Articles/iOS4_3.html#//apple_ref/doc/uid/TP40010567-SW1](http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Articles/iOS4_3.html#//apple_ref/doc/uid/TP40010567-SW1).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 AirPlay 框架的信息，您可以参考以下 Apple 开发者网站：[http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Articles/iOS4_3.html#//apple_ref/doc/uid/TP40010567-SW1](http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Articles/iOS4_3.html#//apple_ref/doc/uid/TP40010567-SW1).
- en: Understanding the Core Image framework
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Core Image 框架
- en: The Core Image framework is an extensible image processing technology architecture
    that has been built into Mac OS X v10.4 and iOS 5.0\. This framework leverages
    the programmable graphics hardware to provide near real-time, pixel-accurate image
    processing of graphics, as well as video processing. The Core Image comes with
    over 100 built-in filters that are ready-to-use by filter clients who want to
    support image processing in their application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Core Image 框架是一个可扩展的图像处理技术架构，它已集成到 Mac OS X v10.4 和 iOS 5.0 中。此框架利用可编程图形硬件提供近似实时的、像素级准确的图像处理，以及视频处理。Core
    Image 随带超过 100 个内置过滤器，供希望在其应用程序中支持图像处理的过滤器客户端使用。
- en: The Core Image filter reference describes these filters; the list of built-in
    filters can change, so for that reason, Core Image provides you with the methods
    that let you query the system for these available filters. You can also load filters
    that third-party developers package as image units. The Core Image **Application
    Programming Interface** (**API**) is part of the **Quartz Core framework** (**QuartzCore.framework**),
    and provides access to built-in image filters for both video and still images,
    and provides support for creating custom filters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Core Image 过滤器参考描述了这些过滤器；内置过滤器的列表可能会更改，因此出于这个原因，Core Image 提供了让您查询系统以获取这些可用过滤器的功能。您还可以加载第三方开发者打包为图像单元的过滤器。Core
    Image **应用程序编程接口**（**API**）是 **Quartz Core 框架**（**QuartzCore.framework**）的一部分，它提供了对内置图像过滤器（包括视频和静态图像）的访问，并支持创建自定义过滤器。
- en: 'You can use the Core Image from the Cocoa and Carbon frameworks by linking
    to Core Image framework. By using the Core Image framework, you can perform the
    following types of operations, by using filters that are bundled in Core Image
    or that you or another developer create:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过链接到 Core Image 框架来使用 Cocoa 和 Carbon 框架中的 Core Image。通过使用 Core Image 框架，您可以使用
    Core Image 中捆绑的过滤器或您或另一位开发者创建的过滤器执行以下类型的操作：
- en: Crop images and correct color, such as perform white point adjustment
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪图像并校正颜色，例如执行白点调整
- en: Apply color effects, such as sepia tone
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用颜色效果，例如棕褐色
- en: Blur or sharpen images
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊或锐化图像
- en: Composite images and warp or transform the geometry of an image
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成图像并扭曲或变换图像的几何形状
- en: Generate color, checkerboard patterns, Gaussian gradients, and other pattern
    images
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成颜色、棋盘图案、高斯渐变和其他图案图像
- en: Add transition effects to images or video
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向图像或视频添加过渡效果
- en: Provide real-time color adjustment on video
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视频上提供实时颜色调整
- en: 'The following screenshot provides you with a general idea of where Core Image
    fits with other graphics technologies in Mac OS X:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图向您展示了 Core Image 在 Mac OS X 中与其他图形技术的关系：
- en: '![Understanding the Core Image framework](img/2267EXP_05_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Core Image 框架](img/2267EXP_05_11.jpg)'
- en: As you can see, the **Core Image** framework has been integrated with these
    technologies, allowing you to use them together to achieve a wide range of results.
    You can use Core Image to process images created in Quartz 2D (Core Graphics)
    and textures created in OpenGL. You can also apply Core Image filters to videos
    played using Core Video.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**Core Image** 框架已与这些技术集成，允许您将它们一起使用以实现广泛的结果。您可以使用 Core Image 处理在 Quartz
    2D（Core Graphics）中创建的图像以及在 OpenGL 中创建的纹理。您还可以将 Core Image 过滤器应用于使用 Core Video
    播放的视频。
- en: The Core Image comes with over 100 built-in filters ready-to-use by filter clients
    who want to support image processing in their application. The Core Image filter
    reference describes these filters; the list of built-in filters can change, so
    for that reason, Core Image provides you with the methods that let you query the
    system for these available filters. You can also load filters that third-party
    developers package as image units.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Core Image 随带超过 100 个内置过滤器，供希望在其应用程序中支持图像处理的过滤器客户端使用。Core Image 过滤器参考描述了这些过滤器；内置过滤器的列表可能会更改，因此
    Core Image 提供了让您查询系统以获取这些可用过滤器的功能。您还可以加载第三方开发者打包为图像单元的过滤器。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: For more information on the built-in filters that are available in the Core
    Image API, refer to the *Mac OS X Developer Library* at:[http://developer.apple.com/library/mac/#documentation/graphicsimaging/reference/CoreImageFilterReference/Reference/reference.html](http://developer.apple.com/library/mac/#documentation/graphicsimaging/reference/CoreImageFilterReference/Reference/reference.html).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Core Image API 中可用的内置过滤器更多信息，请参考 [Mac OS X 开发者库](http://developer.apple.com/library/mac/#documentation/graphicsimaging/reference/CoreImageFilterReference/Reference/reference.html)。
- en: The following code snippet displays a list of the available built-in Core Image
    filters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了可用内置 Core Image 过滤器的列表。
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following table displays a list of available core image filters when this
    code is executed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了当执行此代码时可用核心图像过滤器列表：
- en: '| Core image filter name | Core image filter name |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 核心图像过滤器名称 | 核心图像过滤器名称 |'
- en: '| `CIAdditionCompositing` | `CIAffineTransform` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `CIAdditionCompositing` | `CIAffineTransform` |'
- en: '| `CICheckerboardGenerator` | `CIColorBlendMode` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `CICheckerboardGenerator` | `CIColorBlendMode` |'
- en: '| `CIColorBurnBlendMode` | `CIColorControls` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `CIColorBurnBlendMode` | `CIColorControls` |'
- en: '| `CIColorCube` | `CIColorDodgeBlendMode` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `CIColorCube` | `CIColorDodgeBlendMode` |'
- en: '| `CIColorInvert` | `CIColorMatrix` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `CIColorInvert` | `CIColorMatrix` |'
- en: '| `CIColorMonochrome` | `CIConstantColorGenerator` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `CIColorMonochrome` | `CIConstantColorGenerator` |'
- en: '| `CICrop` | `CIDarkenBlendMode` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `CICrop` | `CIDarkenBlendMode` |'
- en: '| `CIDifferenceBlendMode` | `CIExclusionBlendMode` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `CIDifferenceBlendMode` | `CIExclusionBlendMode` |'
- en: '| `CIExposureAdjust` | `CIFalseColor` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `CIExposureAdjust` | `CIFalseColor` |'
- en: '| `CIGammaAdjust` | `CIGaussianGradient` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `CIGammaAdjust` | `CIGaussianGradient` |'
- en: '| `CIHardLightBlendMode` | `CIHighlightShadowAdjust` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `CIHardLightBlendMode` | `CIHighlightShadowAdjust` |'
- en: '| `CIHueAdjust` | `CIHueBlendMode` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `CIHueAdjust` | `CIHueBlendMode` |'
- en: '| `CILightenBlendMode` | `CILinearGradient` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `CILightenBlendMode` | `CILinearGradient` |'
- en: '| `CILuminosityBlendMode` | `CIMaximumCompositing` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `CILuminosityBlendMode` | `CIMaximumCompositing` |'
- en: '| `CIMinimumCompositing` | `CIMultiplyBlendMode` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `CIMinimumCompositing` | `CIMultiplyBlendMode` |'
- en: '| `CIMultiplyCompositing` | `CIOverlayBlendMode` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `CIMultiplyCompositing` | `CIOverlayBlendMode` |'
- en: '| `CIRadialGradient` | `CISaturationBlendMode` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `CIRadialGradient` | `CISaturationBlendMode` |'
- en: '| `CIScreenBlendMode` | `CISepiaTone` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `CIScreenBlendMode` | `CISepiaTone` |'
- en: '| `CISoftLightBlendMode` | `CISourceAtopCompositing` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `CISoftLightBlendMode` | `CISourceAtopCompositing` |'
- en: '| `CISourceInCompositing` | `CISourceOutCompositing` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `CISourceInCompositing` | `CISourceOutCompositing` |'
- en: '| `CISourceOverCompositing` | `CIStraightenFilter` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `CISourceOverCompositing` | `CIStraightenFilter` |'
- en: '| `CIStripesGenerator` | `CITemperatureAndTint` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `CIStripesGenerator` | `CITemperatureAndTint` |'
- en: '| `CIToneCurve` | `CIVibrance` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `CIToneCurve` | `CIVibrance` |'
- en: '| `CIVignette` | `CIWhitePointAdjust` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `CIVignette` | `CIWhitePointAdjust` |'
- en: The list displayed contains filters pertaining to both Mac OS X and iOS 5 operating
    systems, so it would be advisable to refer to the Core Image filter reference
    documentation to determine which filter applies to what technology.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的列表包含适用于 Mac OS X 和 iOS 5 操作系统的过滤器，因此建议您参考 Core Image 过滤器参考文档以确定哪些过滤器适用于哪些技术。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'For more information on the Core Image framework and Core Image filter reference
    documentation, you can obtain these from the Apple Developer website at: [http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html](http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Core Image 框架和 Core Image 过滤器参考文档的更多信息，您可以在 Apple 开发者网站上获取：[http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html](http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html)。
- en: Creating a simple Core Image application
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的 Core Image 应用程序
- en: Apple provides more than 100 image-processing filters with Core Image, so it's
    easy for you to enable support for image processing within your application, using
    these built-in features. Image processing involves applying an effect to a photo
    to either flip or rotate an image, enhance the sharpness of an image, or even
    red eye from family photographs. Before we can do this, we need to include the
    Core Image framework as part of our application project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Apple提供了超过100个Core Image图像处理过滤器，因此你很容易在你的应用程序中启用对图像处理的支持，使用这些内置功能。图像处理包括对照片应用效果以翻转或旋转图像，增强图像的清晰度，甚至从家庭照片中去除红眼。在我们能够做到这一点之前，我们需要将Core
    Image框架作为我们应用程序项目的一部分包含进来。
- en: Before we can proceed, we first need to create our `CIFilterEffectsproject`.
    To refresh your memory, you can refer to the section that we covered in [Chapter
    1](ch01.html "Chapter 1. What's New in iOS5"), *What's New in iOS5*, under the
    section *Creating the MyEmailApp application*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们首先需要创建我们的`CIFilterEffectsproject`。为了刷新你的记忆，你可以参考我们在[第1章](ch01.html
    "第1章。iOS5的新特性")中覆盖的部分，即*iOS5的新特性*下的*创建MyEmailApp应用程序*部分。
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/Xcode4/Applications`文件夹中启动Xcode。
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建一个新的Xcode项目**，或者**文件 | 新项目**。
- en: Select the **Single View Application** template from the list of available templates.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用模板列表中选择**单视图应用程序**模板。
- en: Select **iPhone** from under the **Device Family** drop-down.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**设备家族**下拉菜单中选择**iPhone**。
- en: Click on the **Next** button to proceed to the next step in the wizard.![Creating
    a simple Core Image application](img/2267EXP_05_12.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**按钮，进入向导的下一步。
- en: Enter in `CIFilterEffects` as the name for your project, and then click on the
    **Next** button to proceed to the next step of the wizard.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称输入为`CIFilterEffects`，然后点击**下一步**按钮继续向导的下一步。
- en: Specify the location where you would like to save your project.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定你想要保存项目的位置。
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮继续，并显示Xcode工作区环境。
- en: 'Now that we have created our `CIFilterEffects` project, we now need to add
    an important framework to our project that will enable us to apply a number of
    different image effects. To add the Core Image framework to your project, select
    the **Project Navigator Group**, and then follow these simple steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`CIFilterEffects`项目，我们现在需要向项目中添加一个重要的框架，这将使我们能够应用多种不同的图像效果。要将Core Image框架添加到你的项目中，选择**项目导航器组**，然后按照以下简单步骤操作：
- en: Click and select your project from the **Project Navigator**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并从**项目导航器**中选择你的项目。
- en: Then select your project target from under the **TARGETS** group.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在**TARGETS**组下选择你的项目目标。
- en: 3 Select the **Build Phases** tab.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 选择**构建阶段**标签。
- en: Expand the **Link binary with Libraries** disclosure triangle.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开链接二进制与库的展开三角形。
- en: Use the **+** to add the library you want.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+**添加你想要的库。
- en: Select the **CoreImage.framework** from the list of available frameworks. You
    can also search if you can't find the framework you are after, from within the
    list.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用框架列表中选择**CoreImage.framework**。如果你在列表中找不到你想要的框架，也可以进行搜索。
- en: 'If you are still confused as to how to go about adding the frameworks, take
    a look at this screenshot, which highlights the areas that you need to select
    (surrounded by a red rectangle):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不清楚如何添加框架，请查看这个截图，它突出显示了你需要选择的部分（被红色矩形包围）：
- en: '![Creating a simple Core Image application](img/2267EXP_05_13.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的Core Image应用程序](img/2267EXP_05_13.jpg)'
- en: 'Now that you have added the **CoreImage.framework** into your project, we need
    to start building our user interface, which will be responsible for allowing the
    ability to choose an image and apply the filter effects:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将**CoreImage.framework**添加到你的项目中，我们需要开始构建我们的用户界面，它将负责允许选择图像并应用过滤器效果：
- en: From the Project Navigator, select and open the **ViewController.xib** file.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目导航器中，选择并打开**ViewController.xib**文件。
- en: From the **Object Library**, select and drag the (`UIImageView`) image view
    control to our view.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**对象库**中，选择并拖动一个（`UIImageView`）图像视图控件到我们的视图中。
- en: Resize this control accordingly, so that it takes up the area of the screen.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要调整这个控件的大小，使其占据屏幕的整个区域。
- en: From the **Object Library**, select and drag a (`UIButton`) Round Rect Button
    control to our view.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**对象库**中，选择并拖动一个（`UIButton`）圆形矩形按钮控件到我们的视图中。
- en: Resize accordingly and then modify the **Object** Attributes section of the
    Round Rect Button, and set its title to `Choose Image`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要调整大小，然后修改圆角矩形按钮的 **对象** 属性部分，并将其标题设置为 `Choose Image`。
- en: Next, from the **Object Library**, select-and-drag a (`UIButton`) Round Rect
    Button control to our view to the right of the **Choose Image** button.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 **对象库** 中选择并拖动一个 (`UIButton`) 圆角矩形按钮控件到 **Choose Image** 按钮右侧的视图中。
- en: Resize accordingly, then modify the **Object Attributes** section of the Round
    Rect Button, and set its title to `Filter Effects`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要调整大小，然后修改圆角矩形按钮的 **对象属性** 部分，并将其标题设置为 `Filter Effects`。
- en: If you have followed the steps correctly, your view should look like something
    shown in the following screenshot. If it doesn't look quite the same as mine,
    feel free to adjust yours.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地遵循了步骤，你的视图应该看起来像以下截图所示。如果它看起来不太像我的一样，请随意调整你的。
- en: '![Creating a simple Core Image application](img/2267EXP_05_14.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的 Core Image 应用程序](img/2267EXP_05_14.jpg)'
- en: 'As you can see, our form doesn''t do much at this stage, and if you were to
    run this application on the simulator, you would see the controls as placed out
    on your screen. The following steps will show you how to connect your buttons
    up to action events that will each perform the task of choosing an image, and
    apply the filter effects. So let''s get started:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的表单在这个阶段并没有做什么，如果您在模拟器上运行此应用程序，您将看到控件放置在您的屏幕上。以下步骤将向您展示如何将按钮连接到动作事件，每个事件都将执行选择图片并应用滤镜效果的任务。那么，让我们开始吧：
- en: 'Open the `ViewController.h` interface file, and create the following highlighted
    entries as shown in the following code snippet:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewController.h` 接口文件，并按照以下代码片段创建以下突出显示的条目：
- en: '[PRE7]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to create an action event. Select the **Choose Image** button, and hold
    down the *Ctrl* key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple Core Image
    application](img/2267EXP_05_15.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个动作事件。选择 **选择图片** 按钮，并按住 *Ctrl* 键将其拖动到 `ViewController.m` 实现文件类中，如图所示：![创建一个简单的
    Core Image 应用程序](img/2267EXP_05_15.jpg)
- en: Specify a name for the action that you want to create. Enter in `getImage` as
    the name of the action.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为要创建的动作指定一个名称。输入 `getImage` 作为动作的名称。
- en: Set the type of event to be **Touch Up Inside:**![Creating a simple Core Image
    application](img/2267EXP_05_16.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件类型设置为 **触摸内部释放**：![创建一个简单的 Core Image 应用程序](img/2267EXP_05_16.jpg)
- en: Click on the **Connect** button to have Xcode create the event.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **连接** 按钮让 Xcode 创建事件。
- en: We need to create an action event. Select the **Filter Effects** button, and
    hold down the *Ctrl* key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple Core Image
    application](img/2267EXP_05_17.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个动作事件。选择 **Filter Effects** 按钮，并按住 *Ctrl* 键将其拖动到 `ViewController.m` 实现文件类中，如图所示：![创建一个简单的
    Core Image 应用程序](img/2267EXP_05_17.jpg)
- en: Specify a name for the action that you want to create. Enter in `getFilterEffects`
    as the name of the action.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为要创建的动作指定一个名称。输入 `getFilterEffects` 作为动作的名称。
- en: Set the type of event to be **Touch Up Inside:**![Creating a simple Core Image
    application](img/2267EXP_05_18.jpg)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件类型设置为 **触摸内部释放**：![创建一个简单的 Core Image 应用程序](img/2267EXP_05_18.jpg)
- en: Click on the **Connect** button to have Xcode create the event.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **连接** 按钮让 Xcode 创建事件。
- en: Now that we have connected up our action events, we now need to synthesize our
    user-interface controls so that we can access these within our view controller.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了我们的动作事件，我们现在需要合成我们的用户界面控件，以便我们可以在视图中访问它们。
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, and add the following highlighted statement underneath the `@implementation`
    statement.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `CIFilterEffects` 文件夹中的 `ViewController.m` 实现文件，并在 `@implementation` 语句下方添加以下突出显示的语句。
- en: '[PRE8]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code snippet, we are making our implementation file aware of the controls
    that are located on our user interface form. If these are not declared, we will
    receive warning messages, which could potentially cause your program to produce
    some weird results, or may even crash your application on the iOS device.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们让实现文件了解位于我们用户界面表单上的控件。如果没有声明，我们将收到警告消息，这可能会使程序产生一些奇怪的结果，甚至可能在 iOS
    设备上导致应用程序崩溃。
- en: 'Next, we need to add the code into our `getImage` function that will enable
    us to select an image from the Photo library, and have this displayed into our
    `UIViewImage` control. Enter the following code snippet for this function:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将代码添加到我们的`getImage`函数中，这将使我们能够从照片库中选择一个图像，并将其显示到我们的`UIViewImage`控件中。为此函数输入以下代码片段：
- en: '[PRE9]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code snippet creates an instance of the UIImagePickerController that will
    enable us to choose a photo image from the iOS devices photo album. We then modify
    and initialize the sourceType property of the picker control, and tell it to use
    the UIImagePickerControllerSourceTypeSavedPhotosAlbum constant. The final statement
    displays the photo album, and allows you to select an image.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码片段创建了一个`UIImagePickerController`实例，这将使我们能够从iOS设备的相册中选择照片图像。然后，我们修改并初始化选择器控件的`sourceType`属性，并告诉它使用`UIImagePickerControllerSourceTypeSavedPhotosAlbum`常量。最后的语句显示相册，并允许你选择一个图像。
- en: We then declare another method, `imagePickerController:(UIImagePickerController
    *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info`, that gets called
    after the image is chosen. The picker is then closed, and the image is then displayed
    into the `UIImageView` control, which we placed on our user interface. The `UIImagePickerController`
    class adopts the `UIImagePickerControllerDelegate` and the `UINavigationControllerDelegate`
    protocols.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明另一个方法，`imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary
    *)info`，该方法在图像选择后会被调用。选择器随后关闭，并将图像显示到我们放置在用户界面上的`UIImageView`控件中。`UIImagePickerController`类采用了`UIImagePickerControllerDelegate`和`UINavigationControllerDelegate`协议。
- en: Next, we need to add the code into our `getFilterEffects` function that will
    enable us to choose a filter effect from a list of options, and have this applied
    to our loaded image within the `imageView` control.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将代码添加到我们的`getFilterEffects`函数中，这将使我们能够从一系列选项中选择一个滤镜效果，并将其应用到`imageView`控件中的加载图像上。
- en: 'Enter in the following code snippet for this function:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此函数中输入以下代码片段：
- en: '[PRE10]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code snippet declares, creates, and initializes an `actionSheet` variable
    that sets up a list of filter options that can be chosen from, and then applied
    to an image. It is worth mentioning that the `UIActionSheet` class adopts the
    protocol `UIActionSheetDelegate`. The following screenshot shows you how these
    options will look when they are displayed:![Creating a simple Core Image application](img/2267EXP_05_19.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码片段声明、创建并初始化了一个`actionSheet`变量，该变量设置了一个可以选择并应用于图像的滤镜选项列表。值得一提的是，`UIActionSheet`类采用了`UIActionSheetDelegate`协议。以下截图显示了这些选项在显示时的样子：![创建一个简单的Core
    Image应用程序](img/2267EXP_05_19.jpg)
- en: Next, we need to create the `actionSheet` function that will handle and apply
    the required filter type to the image, based on the button index chosen within
    the list.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`actionSheet`函数，该函数将根据列表中选择的按钮索引处理并应用所需的滤镜类型到图像上。
- en: 'Enter in the following code snippet for this function:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此函数输入以下代码片段：
- en: '[PRE11]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code snippet will be used to determine what button has been selected from
    the action sheet options panel. This is derived by the `buttonIndex` property
    that is passed into this function. In the next section, we will look at how to
    apply these image effects, based on what has been chosen from within the list.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码片段将用于确定从动作表选项面板中选择了哪个按钮。这是通过传递到该函数的`buttonIndex`属性推导出来的。在下一节中，我们将探讨如何根据列表中的选择应用这些图像效果。
- en: Learn how to apply image filter effects using the CIImage class
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习如何使用CIImage类应用图像滤镜效果
- en: The Core Image class is used when you want to apply effects to images. These
    can be when you want to pixelate an image, or to handle red eye removal from your
    images. You can use the `CIImage` objects in conjunction with other Core Image
    classes, such as the `CIFilter, CIContent, CIVector`, and `CIColor` classes. In
    order to take advantage of the built-in Core Image filters when processing images,
    you can create `CIImage` objects with data supplied from a variety of sources,
    including Quartz 2D images and Core Video image buffers, using the `CVImageBufferRef`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想对图像应用效果时，会使用`Core Image`类。这可能是当你想要像素化一个图像，或者处理图像中的红眼时。你可以使用`CIImage`对象与其它`Core
    Image`类一起使用，例如`CIFilter`、`CIContent`、`CIVector`和`CIColor`类。为了在处理图像时利用内置的`Core
    Image`滤镜，你可以使用`CVImageBufferRef`从多种数据源创建`CIImage`对象，包括Quartz 2D图像和Core Video图像缓冲区。
- en: 'The `CIImage` object has image data associated with it, but it is not an image.
    A `CIImage` object has all the information necessary to produce an image, but
    Core Image doesn''t actually render an image until it is told to do so. This method
    allows Core Image to operate as efficiently as possible. When using the `CIImage`
    class, this contains a number of parameters, which are explained in the following
    table:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIImage` 对象与其相关联的是图像数据，但它本身并不是一个图像。一个 `CIImage` 对象包含了生成图像所需的所有信息，但 Core Image
    不会实际渲染图像，直到被指示这样做。此方法允许 Core Image 以尽可能高效的方式运行。当使用 `CIImage` 类时，它包含多个参数，这些参数在以下表格中进行了说明：'
- en: '| **CIImage class parameters** | **Description** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **CIImage 类参数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Filter Category | This specifies the type of effect (blur, distortion, generator,
    and so forth) or its intended use (still images, video, non-square pixels, and
    so on). A filter can be a member of more than one category. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器类别 | 这指定了效果类型（模糊、扭曲、生成等）或其预期用途（静态图像、视频、非正方形像素等）。一个过滤器可以属于多个类别之一。|'
- en: '| Display Name | This is the name that should be shown in the user interface
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 显示名称 | 这是应在用户界面中显示的名称 |'
- en: '| Filter Name | This is the name you use to access the filter programmatically.
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器名称 | 这是用于程序访问过滤器的名称。|'
- en: '| Input Parameters | These can contain one or more input parameters that let
    you control how processing is done. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 输入参数 | 这些可以包含一个或多个输入参数，让你可以控制处理方式。|'
- en: '| Attribute Class | Every input parameter that you create contains an attribute
    class that specifies its data type, such as NSNumber. An input parameter can optionally
    have other attributes, such as its default value, the allowable minimum and maximum
    values, the display name for the parameter, and any other attributes that are
    described in CIFilter. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 属性类 | 你创建的每个输入参数都包含一个属性类，用于指定其数据类型，例如 NSNumber。输入参数可以可选地具有其他属性，例如其默认值、允许的最小和最大值、参数的显示名称以及
    CIFilter 中描述的任何其他属性。|'
- en: 'If you take, for instance, the color monochrome filter, this contains three
    input parameters: the image to process, a monochrome color, and the color intensity.
    You supply the image and have the option to set a color and color intensity.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你选择单色颜色过滤器，它包含三个输入参数：要处理的图像、单色颜色和颜色强度。你提供图像，并可以选择设置颜色和颜色强度。
- en: Most filters, including the color monochrome filter, have default values for
    each non-image input parameter. Core Image uses the default values to process
    your image, if you choose not to supply your own values for the input parameters.
    Filter attributes are stored as key-value pairs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数过滤器，包括单色颜色过滤器，为每个非图像输入参数都有默认值。如果你选择不提供自己的输入参数值，Core Image 将使用默认值来处理你的图像。过滤器属性存储为键值对。
- en: 'The **key** is a constant that identifies the attribute, and the **value**
    is the setting associated with the key. Core Image attribute values are typically
    one of the following data types:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**键**是一个标识属性的常量，**值**是与键关联的设置。Core Image 属性值通常是以下数据类型之一：'
- en: '**Strings:** These are used for things, such as display names.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：这些用于诸如显示名称之类的用途。'
- en: '**Floating-point numbers:** They are used to specify scalar values, such as
    intensity levels and radii.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**：它们用于指定标量值，例如强度级别和半径。'
- en: '**Vectors:** They can have two, three, or four elements, each of which is a
    floating-point number. These are used to specify positions, areas, and color values.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量**：它们可以有两个、三个或四个元素，每个元素都是一个浮点数。这些用于指定位置、区域和颜色值。'
- en: '**Colors:** They specify color values and a color space to interpret the values
    in.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：它们指定颜色值和颜色空间，以解释这些值。'
- en: '**Images:** They are lightweight objects that specify images.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：它们是轻量级对象，用于指定图像。'
- en: '**Transforms:** They specify an affine transformation to apply to an `image.CIContext`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变换**：它们指定应用于 `image.CIContext` 的仿射变换。'
- en: In the next section, we will take a look at how we can use some of these techniques
    when applying the various types of color effects to our `CIFilterEffects` application,
    when a filter type has been selected from our action sheet list of options.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在将各种类型的颜色效果应用到我们的 `CIFilterEffects` 应用程序时使用一些这些技术，当从我们的操作表选项列表中选择了一个过滤器类型时。
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, locate the `- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex`,
    and add the following code statement after the function declaration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `CIFilterEffects` 文件夹中的 `ViewController.m` 实现文件，找到 `- (void)actionSheet:(UIActionSheet
    *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex`，并在函数声明之后添加以下代码语句。
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code snippet, we declare a `CIContext` variable context. This variable
    will be used for rendering the image object `cImage` to the view. We then declare
    a cImage variable object of type `CIImage`, which contains a pointer to the image
    within our `imageView`. Finally, we then declare a `CIImage result` variable that
    will be used to apply the image filter changes, and then output this modified
    image to the `imageView` control.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们声明了一个名为 `context` 的 `CIContext` 变量。这个变量将用于将图像对象 `cImage` 渲染到视图中。然后，我们声明了一个
    `cImage` 变量对象，其类型为 `CIImage`，包含指向 `imageView` 中图像的指针。最后，我们声明了一个 `CIImage result`
    变量，用于应用图像过滤器更改，并将修改后的图像输出到 `imageView` 控件。
- en: Color effects
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色效果
- en: In this section, we will look at applying each of the options displayed within
    our action sheet pop-up to our image of the Apple logo, which we have chosen from
    our iOS Photo library.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看将操作表弹出窗口中显示的每个选项应用到我们选择的苹果标志图像上，该图像来自我们的 iOS 照片库。
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `CIFilterEffects` 文件夹中的 `ViewController.m` 实现文件。
- en: 'Next, locate the `- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex`,
    and add the following code statement after the variable declarations that we applied
    in the previous code snippet:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定位到 `- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex`，并在之前代码片段中应用的变量声明之后添加以下代码语句：
- en: '[PRE13]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code snippet, we start by declaring a `CIFilter` variable called `hueAdjust`.
    This will be used to denote the type of filter that we want to apply to our image.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先声明了一个名为 `hueAdjust` 的 `CIFilter` 变量。这个变量将用来表示我们想要应用到图像上的过滤器类型。
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将变量 `cImage` 的类型 `CIImage` 指向我们 `UIImageView` 控件中选择的图像，并将其分配给 `inputImage`。
- en: Next, we assign the level of hue to apply to the image, by setting the value
    of the `inputAngle` property. Once we have done all of this, we then apply the
    `hue Adjustment` to the image, and return this to our `UIImage` result, based
    on the `outputImage` property, and then output this back to our `UIImageView`
    control.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过设置 `inputAngle` 属性的值来指定应用到图像上的色调级别。完成这些操作后，我们将对图像应用 `hue Adjustment`，并将结果返回到我们的
    `UIImage` 结果中，基于 `outputImage` 属性，然后将这个结果输出到我们的 `UIImageView` 控件。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When setting the values of the `inputAngle` property, these have a starting
    range from a minimum value of `-3.14` to a maximum value of `3.14`. There is also
    a default value of `0.00`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置 `inputAngle` 属性的值时，这些值从最小值 `-3.14` 到最大值 `3.14` 有一个起始范围。还有一个默认值 `0.00`。
- en: 'The following screenshot displays the image output with the Hue Saturation
    applied. You will notice that it changes the overall hue or tint of the source
    pixels:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用了色调饱和度的图像输出。你会注意到它改变了源像素的整体色调或色调：
- en: '![Color effects](img/2267EXP_05_20.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![颜色效果](img/2267EXP_05_20.jpg)'
- en: Next, we will take a look at the **Vibrance** option and see what happens when
    this Core Image filter has been chosen from the list of options within our action
    sheet.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 **Vibrance** 选项，并看看当我们在操作表中的选项列表中选择这个 Core Image 过滤器时会发生什么。
- en: 'Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following code statement underneath the
    previous code block that we applied in the previous code snippet:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `CIFilterEffects` 文件夹中的 `ViewController.m` 实现文件，并在之前代码片段中应用的下一段代码块下方添加以下代码语句：
- en: '[PRE14]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code snippet, we start by declaring a `CIFilter` variable called `vibrance`.
    This will be used to denote the type of filter we want to apply to our image.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先声明了一个名为 `vibrance` 的 `CIFilter` 变量。这个变量将用来表示我们想要应用到图像上的过滤器类型。
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`. Finally, we assign the level of saturation to apply to the image,
    by setting the value of the `inputAmount` property.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将变量 `cImage` 的类型设置为 `CIImage`，它指向我们 `UIImageView` 控件中选择的照片，并将其分配给 `inputImage`。最后，我们通过设置
    `inputAmount` 属性的值来分配应用到图像的饱和度级别。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When setting the values of the `inputAmount` property, these have a starting
    range from a minimum value of `-1.00` to a maximum value of `1.00`. There is also
    a default value of `0.00`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `inputAmount` 属性的值时，这些值从最小值 `-1.00` 到最大值 `1.00` 有一个起始范围。还有一个默认值 `0.00`。
- en: 'The following screenshot displays the image output with the Vibrance saturation
    applied. You will notice that it reduces the image colors, while keeping a good
    balance of skin tones:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了应用了 Vibrance 饱和度的图像输出。您会注意到它减少了图像颜色，同时保持了良好的肤色平衡：
- en: '![Color effects](img/2267EXP_05_21.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Color effects](img/2267EXP_05_21.jpg)'
- en: Next, we will take a look at the **Color Invert** option and see what happens
    when this Core Image filter has been chosen from the list of options within our
    actionsheet.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 **Color Invert** 选项，并观察当我们在 actionsheet 的选项列表中选择此 Core Image 过滤器时会发生什么。
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, and add the following code statement underneath the previous code block
    that we applied in the previous code snippet.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `CIFilterEffects` 文件夹中的 `ViewController.m` 实现文件，并在之前代码片段中应用的下一段代码块下方添加以下代码语句。
- en: '[PRE15]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code snippet, we start by declaring a `CIFilter` variable called `invert`.
    This will be used to denote the type of filter we want to apply to our image.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们首先声明一个名为 `invert` 的 `CIFilter` 变量。这将用于表示我们想要应用到图像上的过滤器的类型。
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将变量 `cImage` 的类型设置为 `CIImage`，它指向我们 `UIImageView` 控件中选择的照片，并将其分配给 `inputImage`。
- en: 'The following screenshot displays the image output with the Color Invert filter
    applied. You will notice that the image colors have been inverted to show more
    of a negative image:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了应用了 Color Invert 过滤器的图像输出。您会注意到图像颜色已被反转，以显示更多负图像：
- en: '![Color effects](img/2267EXP_05_22.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Color effects](img/2267EXP_05_22.jpg)'
- en: Next, we will take a look at the **Straighten Filter** option and see what happens
    when this Core Image filter has been chosen from the list of options within our
    actionsheet.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 **Straighten Filter** 选项，并观察当我们在 actionsheet 的选项列表中选择此 Core Image
    过滤器时会发生什么。
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, and add the following code statement underneath the previous code block
    that we applied in the previous code snippet.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `CIFilterEffects` 文件夹中的 `ViewController.m` 实现文件，并在之前代码片段中应用的下一段代码块下方添加以下代码语句。
- en: '[PRE16]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code snippet, we start by declaring a CIFilter variable called straightenFilter.
    This will be used to denote the type of filter we want to apply to our image.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们首先声明一个名为 straightenFilter 的 CIFilter 变量。这将用于表示我们想要应用到图像上的过滤器的类型。
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`. Finally, we assign the angle level rotation to apply to the image,
    by setting the value of the `inputAngle` property.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将变量 `cImage` 的类型设置为 `CIImage`，它指向我们 `UIImageView` 控件中选择的照片，并将其分配给 `inputImage`。最后，我们通过设置
    `inputAngle` 属性的值来分配应用到图像的角度级别旋转。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When setting the values of the `inputAngle` property, these have a starting
    range from a minimum value of -3.14 to a maximum value of `3.14`. There is also
    a default value of `0.00`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `inputAngle` 属性的值时，这些值从最小值 -3.14 到最大值 `3.14` 有一个起始范围。还有一个默认值 `0.00`。
- en: 'The following screenshot displays the image output with the Straighten filter
    applied. You will notice that it rotates the source image by the specified angle
    in radians. The image is then scaled and cropped, so that the rotated image fits
    within the view:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下截图显示了应用了 Straighten 过滤器的图像输出。您会注意到它将源图像按指定的弧度旋转。然后图像被缩放并裁剪，以便旋转后的图像适合视图：
- en: '![Color effects](img/2267EXP_05_23.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Color effects](img/2267EXP_05_23.jpg)'
- en: Next, we need to add the code that will be used to output the updated image
    once this has been applied based on our Core Image filters.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加代码，用于在应用基于我们的核心图像滤镜后输出更新后的图像。
- en: 'Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following code statement underneath the
    previous code block that we applied in the previous code snippet:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`CIFilterEffects`文件夹中的`ViewController.m`实现文件，并在之前代码片段中应用的上一个代码块下方添加以下代码语句：
- en: '[PRE17]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code snippet, we start by checking to ensure that we are not processing
    our **Close** and **Cancel** buttons, as those buttons do not apply the core image
    filters to the image. This is a general way of safeguarding our application to
    prevent it from crashing.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们首先检查确保我们不是在处理我们的**关闭**和**取消**按钮，因为这些按钮不会将核心图像过滤器应用于图像。这是一种保护我们应用程序的通用方法，以防止它崩溃。
- en: Next, we use the `imageWithCGImage` method to create and return an image object
    representing the specified Quartz image, then displaying this image back to our
    `UIImageView imageView`> control, and setting it to be displayed to the width
    and height of the image view.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们使用`imageWithCGImage`方法创建并返回一个表示指定Quartz图像的图像对象，然后将此图像显示回我们的`UIImageView
    imageView`控件，并设置其显示为图像视图的宽度和高度。
- en: In the next section, we will take a look at how we can apply transition effects
    to an image while making use of the Quartz Core framework.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何利用Quartz Core框架将转换效果应用于图像。
- en: Transitions
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: '**Transitions** are typically used to apply some sort of effect to an image.
    These effects are rendered over time and require that you set up a timer event.
    In this section, we will be adding some code to our `CIFilterEffects` example
    application to show one of the easiest ways in which we can apply a water ripple
    effect to an image.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换**通常用于将某种效果应用于图像。这些效果随时间渲染，需要你设置一个计时器事件。在本节中，我们将向我们的`CIFilterEffects`示例应用程序添加一些代码，以展示我们可以将水波纹效果应用于图像的最简单方法之一。'
- en: Fortunately, you don't need to worry as there is already a ripple effect component
    that comes part of the QuartzCore framework, and this will take advantage of the
    graphics hardware acceleration when rendering this effect.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不必担心，因为QuartzCore框架中已经包含了一个涟漪效果组件，这将在渲染此效果时利用图形硬件加速。
- en: In order for us to start using transitions within our application, we will need
    to add an important framework to our project that will enable us to apply a number
    of different image effects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们应用程序中使用转换，我们需要向项目中添加一个重要的框架，这将使我们能够应用多种不同的图像效果。
- en: 'To add the QuartzCore framework to your project, select the **Project Navigator
    Group**, and then follow these simple steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要将QuartzCore框架添加到你的项目中，请选择**项目导航器组**，然后按照以下简单步骤操作：
- en: Click and select your project from the **Project Navigator**.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并从**项目导航器**中选择你的项目。
- en: Then select your project target from under the **TARGETS** group.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从**TARGETS**组下选择你的项目目标。
- en: Select the **Build Phases** tab.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**构建阶段**选项卡。
- en: Expand the **Link binary with Libraries** disclosure triangle.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开显示**链接二进制与库**的展开三角形。
- en: Finally, use the **+** to add the library you want.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用**+**来添加你想要的库。
- en: Select the **QuartzCore.framework** from the list of available frameworks. You
    can also search if you can't find the framework you are after, from within the
    list.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的框架列表中选择**QuartzCore.framework**。如果你找不到你想要的框架，也可以在列表中进行搜索。
- en: 'If you are still confused how to go about adding the frameworks, take a look
    at this screenshot, which highlights the areas that you need to select (surrounded
    by a rectangle):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不清楚如何添加框架，可以查看这张截图，它突出显示了你需要选择的区域（被矩形包围）：
- en: '![Transitions](img/2267EXP_05_24.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![转换](img/2267EXP_05_24.jpg)'
- en: Now that we have added the `QuartzCore.framework` into your project, we can
    start to add the necessary code to our example project, to apply a water rippling
    effect.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`QuartzCore.framework`添加到你的项目中，我们可以开始向示例项目添加必要的代码，以应用水波纹效果。
- en: 'Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following code statement underneath the
    Straighten filter code block:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`CIFilterEffects`文件夹中的`ViewController.m`实现文件，并在直通滤波器代码块下方添加以下代码语句：
- en: '[PRE18]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this code snippet, we start by declaring a variable called `animation` that
    will be responsible for handling the transition animations for our `UIView` layer.
    In the next step, we specify the duration of our ripple effect that will be used
    to define how long, in seconds, a single iteration of an animation will take to
    display.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先声明了一个名为 `animation` 的变量，该变量将负责处理我们 `UIView` 层的过渡动画。在下一步中，我们指定了涟漪效果的持续时间，这将用来定义动画的单次迭代显示需要多长时间，以秒为单位。
- en: Next, we set up a timing function. This will be used to specify `UIViewAnimationCurveEaseInOut`
    as the type of animation that we want to use. This causes the animation to start
    off slowly, then accelerate through the middle of its duration, and then begin
    to slow-down towards the end of its iteration.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们设置了一个计时函数。这将用于指定 `UIViewAnimationCurveEaseInOut` 作为我们想要使用的动画类型。这会导致动画开始时速度较慢，然后在中期加速，最后在迭代的末尾开始减速。
- en: 'This is the default curve for most animations. In the next step, we specify
    that the type of animation we want to use is the `rippleEffect` transition effect.
    Finally, we then apply the animation effect to our view. The following screenshot
    displays the output with the water rippling effect applied. You will notice how
    it curves from the inside out, more like a vacuum effect:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是大多数动画的默认曲线。在下一步中，我们指定我们想要使用的动画类型是 `rippleEffect` 过渡效果。最后，我们将动画效果应用到我们的视图中。以下截图显示了应用了水波纹效果的输出。您会注意到它从内部向外弯曲，更像是真空效果：
- en: '![Transitions](img/2267EXP_05_25.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![过渡](img/2267EXP_05_25.jpg)'
- en: As you can see, by using both the Core Image and QuartzCore frameworks, you
    can create some fantastic visual effects within your applications, and bring them
    to life.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过使用 Core Image 和 QuartzCore 框架，您可以在应用程序中创建一些令人惊叹的视觉效果，并使它们栩栩如生。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on Core Image and the QuartzCore frameworks, please refer
    to the following link: [http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html](http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Core Image 和 QuartzCore 框架的更多信息，请参阅以下链接：[http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html](http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html)。
- en: 'For more information on the Core Image filters, please refer to the following
    link: [http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html](http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Core Image 过滤器的更多信息，请参阅以下链接：[http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html](http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html)。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the AirPlay and Core Image frameworks, and
    looked at how we can implement these into our applications to output them to an
    external device, such as Apple TV.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 AirPlay 和 Core Image 框架，并探讨了如何将这些框架集成到我们的应用程序中，以便将输出输出到外部设备，例如 Apple
    TV。
- en: We then learned about the Core Image filters class, and how we can apply the
    different image filter effects to enhance images through the different built-in
    filters, such as color effects. We then familiarized ourselves with the QuartzCore
    framework, and looked at how we can use this framework, using the built-in filters
    for distortions and transition effects, to apply a water ripple effect to an image.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了 Core Image 过滤器类，以及我们如何通过不同的内置过滤器（如颜色效果）应用不同的图像过滤效果来增强图像。然后，我们熟悉了 QuartzCore
    框架，并探讨了如何使用该框架，使用内置的扭曲和过渡效果过滤器，将水波纹效果应用到图像上。
- en: In the next chapter, we will learn about the improvements that have been made
    to the Xcode development tools, and take a look at **Automatic Reference Counting**
    (ARC). This is the latest addition to the LLVM compiler. We will also be taking
    a look at improvements made to Interface Builder, the iOS Location simulator,
    and the set of debugging tools for OpenGL ES.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习对 Xcode 开发工具所做的改进，并查看 **自动引用计数** (ARC)。这是 LLVM 编译器的最新功能。我们还将查看对 Interface
    Builder、iOS 位置模拟器和 OpenGL ES 调试工具集的改进。
