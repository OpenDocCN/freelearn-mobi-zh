- en: Chapter 5. Using AirPlay and Core Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with the release of iOS 4.2, developers could use AirPlay to stream
    videos, audios, and photos to an Apple TV capable device. In iOS 5, it is now
    even easier to wirelessly mirror everything, automatically, on your iPad 2 to
    an HDTV through Apple TV.
  prefs: []
  type: TYPE_NORMAL
- en: With the additional set of APIs that come as a part of iOS 5, applications which
    are built using the AV Foundation framework now support encrypted audio and video
    streams, which are delivered through HTTP Live Streaming, and can also display
    different content on each of the HDTV and the iPad 2 screens.
  prefs: []
  type: TYPE_NORMAL
- en: The Core Image framework is a hardware-accelerated framework that provides an
    easy way to enhance photos and videos. This enables you to create amazing effects
    in your camera and image editing applications. **Core Image** provides several
    built-in filters, such as color effects, distortions, and transitions. It also
    includes advanced features, such as auto-enhance, red-eye reduction, and facial
    recognition.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be taking a closer look into what each of these frameworks
    are, and how to go about implementing these within our applications. We will take
    a look at how to incorporate AirPlay within our applications, and have this information
    directed to another output device using Apple TV. We will also be taking a look
    into the Core Image framework, and how to use the various filter effects using
    the `CIImage` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the AirPlay and Core Image frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple AirPlay and Core Image application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to output application content to an Apple TV device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at how to apply various filter effects for distortions, transitions,
    and color effects, using the `CIImage` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have some fantastic stuff to cover in this chapter. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the AirPlay framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AirPlay framework is an updated framework that lets you stream audio and
    video content from any iOS-based device to any Airplay-enabled device that is
    capable of playing audio and video, such as television sets and audio systems.
    Starting with iOS 5, developers now have the flexibility to incorporate Airplay
    content into their applications, and have this information presented out to a
    nearby Apple TV 2 receiver.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a look at how to create a simple application to
    playback video content on an iOS device, and then take a look at the steps involved
    to output this to an Apple TV 2 device.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple AirPlay application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playing videos is one of the most common tasks that can be done on any iOS device,
    all videos must be played and displayed in full-screen. Before we can play any
    videos, we need to add the Media Player framework into our application project.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can proceed, we first need to create our `AirPlayExample` project.
    To refresh your memory on how to go about creating a new project, you can refer
    to the section that we covered in [Chapter 1](ch01.html "Chapter 1. What's New
    in iOS5"), *What's New in iOS5*, under the section named *Creating the MyEmailApp
    application*.
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Single View Application** template from the list of available templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **iPhone** from under the **Device Family** drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.![Creating
    a simple AirPlay application](img/2267EXP_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in `AirPlayExample` as the name for your project, and then click on the
    **Next** button to proceed to the next step of the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the location where you would like to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have created our `AirPlayExample` project, we now need to add an
    important framework to our project to enable our application with the ability
    to play movie files. To add the Media Player framework to your project, select
    the **Project Navigator Group**, and then follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click and select your project from the **Project Navigator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select your project target from under the **TARGETS** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Build Phases** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Link binary with Libraries disclosure** triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, use the **+** to add the library you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MediaPlayer.framework** from the list of available frameworks.
    You can also search if you can't find the framework you are after, from within
    the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are still confused how to go about adding the frameworks, follow this
    screenshot, which highlights the areas that you need to select (surrounded by
    a red rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple AirPlay application](img/2267EXP_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you have added the `MediaPlayer.framework` into your project, we need
    to start building our user interface that will be responsible for playing the
    movie:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Project Navigator, select and open the **ViewController.xib** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Object Library**, select and drag a (`UIButton`) Round Rect Button
    control, and add this to our view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize accordingly, then modify the **Object Attributes** section of the Round
    Rect Button, and set its title to `Play Movie`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We don''t need to add a stop button, as we will be adding an event that will
    handle this for us when the movie has finished playing. If you have followed the
    steps correctly, your view should look something like that shown in the following
    screenshot. If it doesn''t look quite the same as mine, feel free to adjust yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple AirPlay application](img/2267EXP_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our form doesn''t do much at this stage, and if you were to
    run this application in the simulator, you would see the controls as placed out
    on your screen. The following steps will show you how to connect your buttons
    up to action events which will each perform the task of playing the video. So
    let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.h` interface file, and create the following highlighted
    entries as shown in the code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to create an action event. Select the **Play Movie** button, and hold
    down the Control key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple AirPlay application](img/2267EXP_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a name for the action that you want to create. Enter in `playMovie`
    as the name of the action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the type of event to be **Touch Up Inside**.![Creating a simple AirPlay
    application](img/2267EXP_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Connect** button to have Xcode create the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to add the code to our `playMovie` function which will handle playing
    our sample movie file. Enter in the following code snippet for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just declared a variable (NSString) `filePath` which will contain the
    file path to our movie file. Next, we create a (NSURL) `fileUrl` that converts
    our file path to an object, which is what the `MPMoviePlayerController` needs
    when it is being initialized. We then add the `MPMoviePlayerController` view to
    our custom view controller, so that it will appear on the screen. We specify that
    we want to display this full screen, and finally we tell the `moviePlayerController`
    to commence playback.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have allocated memory to our `moviePlayerController` object, at this
    stage we haven't released it yet, this being due to not knowing when the movie
    playback will actually finish.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `MPMoviePlayerController` object comes pre-built with methods
    to handle this scenario, and will dispatch a notification method called `MPMoviePlayerPlaybackDidFinishNotification`
    to the `NSNotificationCenter` when the movie playback completes, as shown in the
    highlighted code in the previous snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we playback video content within our iPhone applications, you will sometimes
    need to modify the `scalingMode` property of the `MPMoviePlayerController` object.
    By setting this property, it will determine how the movie image adapts to fill
    the playback size that you have defined. The following scaling modes currently
    exist, and are displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MPMovieScalingModeNone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MPMovieScalingModeAspectFit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MPMovieScalingModeAspectFill`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MPMovieScalingModeFill`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two main common scaling modes used are the `MPMovieScalingModeAspectFill`
    and `MPMovieScalingModeFill`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the comparison between the different scaling modes,
    refer to the *MPMoviePlayerController Class Reference* at the following location
    `http://developer.apple.com/library/ios/#documentation/mediaplayer/reference/MPMoviePlayerController_Class/Reference/Reference.html#//apple_ref/doc/c_ref/MPMoviePlayerController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this property in your application, insert the following
    line of code just before the `[moviePlayerController play]` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run your application, you will notice that the video fills the entire
    available space. Next, we need to create the `moviePlaybackComplete:` method that
    will be responsible for releasing our `moviePlayerController` object, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we passed an object to the notification method. This is
    whatever we have passed in the previous code snippet, due to the `moviePlayerController`
    object. We start by retrieving the object using the `[notification object]` statement,
    and then referencing it with the new `MPMoviePlayerController` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: We then send a message back to the `NSNotificationCenter` method that removes
    the observer we previously registered within our `playMovie` function. We finally
    proceed with cleaning up our custom view controller from our display, and then
    release the memory we previously allocated to our `moviePlayerController` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our `AirPlayExample` application running within
    the iOS simulator with movie playback set up to be viewed in landscape mode; support
    is available to display this in portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple AirPlay application](img/2267EXP_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we learned about the `MediaPlayer` framework, and how we can
    use this within our applications to give us the ability to play audio and video.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, by using the Media Player framework and the `MPMoviePlayerController`
    class, you can incorporate movie playback within your iOS applications. In the
    next section, we will look at steps involved in modifying our application, so
    that this can be displayed on a TV screen using Apple TV. We learned about the
    various scaling modes for video playback and how to implement these.
  prefs: []
  type: TYPE_NORMAL
- en: Using AirPlay to present application content to Apple TV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with iOS 4.3, Apple decided to provide its developers with one of the
    most impressive frameworks ever imagined, which would allow developers to integrate
    AirPlay features into their applications. With just a few lines of code, any iOS
    application can be modified to have the ability to stream video directly out to
    an Apple TV device.
  prefs: []
  type: TYPE_NORMAL
- en: To enable AirPlay functionality, we will need to enable a special property on
    our `MPMoviePlayerController` object, by setting the `allowsAirPlay` property
    to `YES`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable AirPlay functionality within your application, follow these simple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.m` implementation file that is located within the
    `AirPlayExample` folder, and locate the following statement within the `playMovie`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we use the `.respondsToSelector:` method of the `MPMoviePlayerController`
    object to cater for older iOS devices that don't support the `allowsAirPlay` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we don't do this, it will cause a run-time error exception to occur which
    will crash your application. In order to offer AirPlay only to those devices that
    support it, we need to place a conditional statement around the statement which
    will check to see if the `MPMoviePlayerController` object supports the `allowsAirPlay`
    option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When this is set, it will cause an additional icon to appear within the movie
    player controller pane. You have no control, programmatically, over this icon
    placement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, build and run your application, and click on the **Play Movie** button.
    The following screenshot shows what this icon looks like when AirPlay has been
    enabled:![Using AirPlay to present application content to Apple TV](img/2267EXP_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the AirPlay icon has been pressed, you will be presented with a pop-up
    list of detected output device options to choose from.![Using AirPlay to present
    application content to Apple TV](img/2267EXP_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you choose the **Apple TV** option as shown in this screenshot, the output
    on your iOS device will disappear, and you will be notified that the video is
    being played on the Apple TV device. This is shown in the following screenshot:![Using
    AirPlay to present application content to Apple TV](img/2267EXP_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you will see your video being displayed on an Apple TV device, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Using AirPlay to present application content to Apple TV](img/2267EXP_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, by following a few simple steps, you can easily incorporate
    the functionality needed to turn your existing applications into Airplay-aware
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following list, you will find a few considerations to keep in mind when
    implementing AirPlay into your projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Apple has only made this feature available on its most recent devices with the
    AirPlay 4.3 SDK. So, there is no AirPlay support for iPhone 3G devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When launching an AirPlay-enabled application, you will need to ensure that
    both your iOS device and your Apple TV software are running the same version of
    the OS, otherwise you could run into some problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for iOS devices to find other Apple AirPlay-enabled devices, you will
    need to ensure that you are on the same Wi-Fi network that your AirPlay devices
    are connected to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about the AirPlay framework, you can refer the following
    Apple Developer website: [http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Articles/iOS4_3.html#//apple_ref/doc/uid/TP40010567-SW1](http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniPhoneOS/Articles/iOS4_3.html#//apple_ref/doc/uid/TP40010567-SW1).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Core Image framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Core Image framework is an extensible image processing technology architecture
    that has been built into Mac OS X v10.4 and iOS 5.0\. This framework leverages
    the programmable graphics hardware to provide near real-time, pixel-accurate image
    processing of graphics, as well as video processing. The Core Image comes with
    over 100 built-in filters that are ready-to-use by filter clients who want to
    support image processing in their application.
  prefs: []
  type: TYPE_NORMAL
- en: The Core Image filter reference describes these filters; the list of built-in
    filters can change, so for that reason, Core Image provides you with the methods
    that let you query the system for these available filters. You can also load filters
    that third-party developers package as image units. The Core Image **Application
    Programming Interface** (**API**) is part of the **Quartz Core framework** (**QuartzCore.framework**),
    and provides access to built-in image filters for both video and still images,
    and provides support for creating custom filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the Core Image from the Cocoa and Carbon frameworks by linking
    to Core Image framework. By using the Core Image framework, you can perform the
    following types of operations, by using filters that are bundled in Core Image
    or that you or another developer create:'
  prefs: []
  type: TYPE_NORMAL
- en: Crop images and correct color, such as perform white point adjustment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply color effects, such as sepia tone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blur or sharpen images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite images and warp or transform the geometry of an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate color, checkerboard patterns, Gaussian gradients, and other pattern
    images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add transition effects to images or video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide real-time color adjustment on video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot provides you with a general idea of where Core Image
    fits with other graphics technologies in Mac OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Core Image framework](img/2267EXP_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the **Core Image** framework has been integrated with these
    technologies, allowing you to use them together to achieve a wide range of results.
    You can use Core Image to process images created in Quartz 2D (Core Graphics)
    and textures created in OpenGL. You can also apply Core Image filters to videos
    played using Core Video.
  prefs: []
  type: TYPE_NORMAL
- en: The Core Image comes with over 100 built-in filters ready-to-use by filter clients
    who want to support image processing in their application. The Core Image filter
    reference describes these filters; the list of built-in filters can change, so
    for that reason, Core Image provides you with the methods that let you query the
    system for these available filters. You can also load filters that third-party
    developers package as image units.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the built-in filters that are available in the Core
    Image API, refer to the *Mac OS X Developer Library* at:[http://developer.apple.com/library/mac/#documentation/graphicsimaging/reference/CoreImageFilterReference/Reference/reference.html](http://developer.apple.com/library/mac/#documentation/graphicsimaging/reference/CoreImageFilterReference/Reference/reference.html).
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet displays a list of the available built-in Core Image
    filters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table displays a list of available core image filters when this
    code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Core image filter name | Core image filter name |'
  prefs: []
  type: TYPE_TB
- en: '| `CIAdditionCompositing` | `CIAffineTransform` |'
  prefs: []
  type: TYPE_TB
- en: '| `CICheckerboardGenerator` | `CIColorBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIColorBurnBlendMode` | `CIColorControls` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIColorCube` | `CIColorDodgeBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIColorInvert` | `CIColorMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIColorMonochrome` | `CIConstantColorGenerator` |'
  prefs: []
  type: TYPE_TB
- en: '| `CICrop` | `CIDarkenBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIDifferenceBlendMode` | `CIExclusionBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIExposureAdjust` | `CIFalseColor` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIGammaAdjust` | `CIGaussianGradient` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIHardLightBlendMode` | `CIHighlightShadowAdjust` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIHueAdjust` | `CIHueBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CILightenBlendMode` | `CILinearGradient` |'
  prefs: []
  type: TYPE_TB
- en: '| `CILuminosityBlendMode` | `CIMaximumCompositing` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIMinimumCompositing` | `CIMultiplyBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIMultiplyCompositing` | `CIOverlayBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIRadialGradient` | `CISaturationBlendMode` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIScreenBlendMode` | `CISepiaTone` |'
  prefs: []
  type: TYPE_TB
- en: '| `CISoftLightBlendMode` | `CISourceAtopCompositing` |'
  prefs: []
  type: TYPE_TB
- en: '| `CISourceInCompositing` | `CISourceOutCompositing` |'
  prefs: []
  type: TYPE_TB
- en: '| `CISourceOverCompositing` | `CIStraightenFilter` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIStripesGenerator` | `CITemperatureAndTint` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIToneCurve` | `CIVibrance` |'
  prefs: []
  type: TYPE_TB
- en: '| `CIVignette` | `CIWhitePointAdjust` |'
  prefs: []
  type: TYPE_TB
- en: The list displayed contains filters pertaining to both Mac OS X and iOS 5 operating
    systems, so it would be advisable to refer to the Core Image filter reference
    documentation to determine which filter applies to what technology.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the Core Image framework and Core Image filter reference
    documentation, you can obtain these from the Apple Developer website at: [http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html](http://developer.apple.com/library/ios/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Core Image application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apple provides more than 100 image-processing filters with Core Image, so it's
    easy for you to enable support for image processing within your application, using
    these built-in features. Image processing involves applying an effect to a photo
    to either flip or rotate an image, enhance the sharpness of an image, or even
    red eye from family photographs. Before we can do this, we need to include the
    Core Image framework as part of our application project.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can proceed, we first need to create our `CIFilterEffectsproject`.
    To refresh your memory, you can refer to the section that we covered in [Chapter
    1](ch01.html "Chapter 1. What's New in iOS5"), *What's New in iOS5*, under the
    section *Creating the MyEmailApp application*.
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode from the `/Xcode4/Applications` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Create a new Xcode project**, or **File | New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Single View Application** template from the list of available templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **iPhone** from under the **Device Family** drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.![Creating
    a simple Core Image application](img/2267EXP_05_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in `CIFilterEffects` as the name for your project, and then click on the
    **Next** button to proceed to the next step of the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the location where you would like to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button to continue and display the Xcode workspace environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have created our `CIFilterEffects` project, we now need to add
    an important framework to our project that will enable us to apply a number of
    different image effects. To add the Core Image framework to your project, select
    the **Project Navigator Group**, and then follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click and select your project from the **Project Navigator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select your project target from under the **TARGETS** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3 Select the **Build Phases** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Link binary with Libraries** disclosure triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **+** to add the library you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **CoreImage.framework** from the list of available frameworks. You
    can also search if you can't find the framework you are after, from within the
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are still confused as to how to go about adding the frameworks, take
    a look at this screenshot, which highlights the areas that you need to select
    (surrounded by a red rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple Core Image application](img/2267EXP_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you have added the **CoreImage.framework** into your project, we need
    to start building our user interface, which will be responsible for allowing the
    ability to choose an image and apply the filter effects:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Project Navigator, select and open the **ViewController.xib** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Object Library**, select and drag the (`UIImageView`) image view
    control to our view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize this control accordingly, so that it takes up the area of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Object Library**, select and drag a (`UIButton`) Round Rect Button
    control to our view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize accordingly and then modify the **Object** Attributes section of the
    Round Rect Button, and set its title to `Choose Image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, from the **Object Library**, select-and-drag a (`UIButton`) Round Rect
    Button control to our view to the right of the **Choose Image** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize accordingly, then modify the **Object Attributes** section of the Round
    Rect Button, and set its title to `Filter Effects`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have followed the steps correctly, your view should look like something
    shown in the following screenshot. If it doesn't look quite the same as mine,
    feel free to adjust yours.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple Core Image application](img/2267EXP_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our form doesn''t do much at this stage, and if you were to
    run this application on the simulator, you would see the controls as placed out
    on your screen. The following steps will show you how to connect your buttons
    up to action events that will each perform the task of choosing an image, and
    apply the filter effects. So let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.h` interface file, and create the following highlighted
    entries as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to create an action event. Select the **Choose Image** button, and hold
    down the *Ctrl* key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple Core Image
    application](img/2267EXP_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a name for the action that you want to create. Enter in `getImage` as
    the name of the action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the type of event to be **Touch Up Inside:**![Creating a simple Core Image
    application](img/2267EXP_05_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Connect** button to have Xcode create the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create an action event. Select the **Filter Effects** button, and
    hold down the *Ctrl* key while you drag this into the `ViewController.m` implementation
    file class, as shown in the following screenshot:![Creating a simple Core Image
    application](img/2267EXP_05_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a name for the action that you want to create. Enter in `getFilterEffects`
    as the name of the action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the type of event to be **Touch Up Inside:**![Creating a simple Core Image
    application](img/2267EXP_05_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Connect** button to have Xcode create the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have connected up our action events, we now need to synthesize our
    user-interface controls so that we can access these within our view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, and add the following highlighted statement underneath the `@implementation`
    statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we are making our implementation file aware of the controls
    that are located on our user interface form. If these are not declared, we will
    receive warning messages, which could potentially cause your program to produce
    some weird results, or may even crash your application on the iOS device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add the code into our `getImage` function that will enable
    us to select an image from the Photo library, and have this displayed into our
    `UIViewImage` control. Enter the following code snippet for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code snippet creates an instance of the UIImagePickerController that will
    enable us to choose a photo image from the iOS devices photo album. We then modify
    and initialize the sourceType property of the picker control, and tell it to use
    the UIImagePickerControllerSourceTypeSavedPhotosAlbum constant. The final statement
    displays the photo album, and allows you to select an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then declare another method, `imagePickerController:(UIImagePickerController
    *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info`, that gets called
    after the image is chosen. The picker is then closed, and the image is then displayed
    into the `UIImageView` control, which we placed on our user interface. The `UIImagePickerController`
    class adopts the `UIImagePickerControllerDelegate` and the `UINavigationControllerDelegate`
    protocols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to add the code into our `getFilterEffects` function that will
    enable us to choose a filter effect from a list of options, and have this applied
    to our loaded image within the `imageView` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter in the following code snippet for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code snippet declares, creates, and initializes an `actionSheet` variable
    that sets up a list of filter options that can be chosen from, and then applied
    to an image. It is worth mentioning that the `UIActionSheet` class adopts the
    protocol `UIActionSheetDelegate`. The following screenshot shows you how these
    options will look when they are displayed:![Creating a simple Core Image application](img/2267EXP_05_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create the `actionSheet` function that will handle and apply
    the required filter type to the image, based on the button index chosen within
    the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter in the following code snippet for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code snippet will be used to determine what button has been selected from
    the action sheet options panel. This is derived by the `buttonIndex` property
    that is passed into this function. In the next section, we will look at how to
    apply these image effects, based on what has been chosen from within the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn how to apply image filter effects using the CIImage class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Core Image class is used when you want to apply effects to images. These
    can be when you want to pixelate an image, or to handle red eye removal from your
    images. You can use the `CIImage` objects in conjunction with other Core Image
    classes, such as the `CIFilter, CIContent, CIVector`, and `CIColor` classes. In
    order to take advantage of the built-in Core Image filters when processing images,
    you can create `CIImage` objects with data supplied from a variety of sources,
    including Quartz 2D images and Core Video image buffers, using the `CVImageBufferRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CIImage` object has image data associated with it, but it is not an image.
    A `CIImage` object has all the information necessary to produce an image, but
    Core Image doesn''t actually render an image until it is told to do so. This method
    allows Core Image to operate as efficiently as possible. When using the `CIImage`
    class, this contains a number of parameters, which are explained in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CIImage class parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Filter Category | This specifies the type of effect (blur, distortion, generator,
    and so forth) or its intended use (still images, video, non-square pixels, and
    so on). A filter can be a member of more than one category. |'
  prefs: []
  type: TYPE_TB
- en: '| Display Name | This is the name that should be shown in the user interface
    |'
  prefs: []
  type: TYPE_TB
- en: '| Filter Name | This is the name you use to access the filter programmatically.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Input Parameters | These can contain one or more input parameters that let
    you control how processing is done. |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute Class | Every input parameter that you create contains an attribute
    class that specifies its data type, such as NSNumber. An input parameter can optionally
    have other attributes, such as its default value, the allowable minimum and maximum
    values, the display name for the parameter, and any other attributes that are
    described in CIFilter. |'
  prefs: []
  type: TYPE_TB
- en: 'If you take, for instance, the color monochrome filter, this contains three
    input parameters: the image to process, a monochrome color, and the color intensity.
    You supply the image and have the option to set a color and color intensity.'
  prefs: []
  type: TYPE_NORMAL
- en: Most filters, including the color monochrome filter, have default values for
    each non-image input parameter. Core Image uses the default values to process
    your image, if you choose not to supply your own values for the input parameters.
    Filter attributes are stored as key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **key** is a constant that identifies the attribute, and the **value**
    is the setting associated with the key. Core Image attribute values are typically
    one of the following data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings:** These are used for things, such as display names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating-point numbers:** They are used to specify scalar values, such as
    intensity levels and radii.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vectors:** They can have two, three, or four elements, each of which is a
    floating-point number. These are used to specify positions, areas, and color values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Colors:** They specify color values and a color space to interpret the values
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images:** They are lightweight objects that specify images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transforms:** They specify an affine transformation to apply to an `image.CIContext`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how we can use some of these techniques
    when applying the various types of color effects to our `CIFilterEffects` application,
    when a filter type has been selected from our action sheet list of options.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, locate the `- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex`,
    and add the following code statement after the function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we declare a `CIContext` variable context. This variable
    will be used for rendering the image object `cImage` to the view. We then declare
    a cImage variable object of type `CIImage`, which contains a pointer to the image
    within our `imageView`. Finally, we then declare a `CIImage result` variable that
    will be used to apply the image filter changes, and then output this modified
    image to the `imageView` control.
  prefs: []
  type: TYPE_NORMAL
- en: Color effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will look at applying each of the options displayed within
    our action sheet pop-up to our image of the Apple logo, which we have chosen from
    our iOS Photo library.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, locate the `- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex`,
    and add the following code statement after the variable declarations that we applied
    in the previous code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we start by declaring a `CIFilter` variable called `hueAdjust`.
    This will be used to denote the type of filter that we want to apply to our image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we assign the level of hue to apply to the image, by setting the value
    of the `inputAngle` property. Once we have done all of this, we then apply the
    `hue Adjustment` to the image, and return this to our `UIImage` result, based
    on the `outputImage` property, and then output this back to our `UIImageView`
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When setting the values of the `inputAngle` property, these have a starting
    range from a minimum value of `-3.14` to a maximum value of `3.14`. There is also
    a default value of `0.00`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the image output with the Hue Saturation
    applied. You will notice that it changes the overall hue or tint of the source
    pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color effects](img/2267EXP_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will take a look at the **Vibrance** option and see what happens when
    this Core Image filter has been chosen from the list of options within our action
    sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following code statement underneath the
    previous code block that we applied in the previous code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we start by declaring a `CIFilter` variable called `vibrance`.
    This will be used to denote the type of filter we want to apply to our image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`. Finally, we assign the level of saturation to apply to the image,
    by setting the value of the `inputAmount` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When setting the values of the `inputAmount` property, these have a starting
    range from a minimum value of `-1.00` to a maximum value of `1.00`. There is also
    a default value of `0.00`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the image output with the Vibrance saturation
    applied. You will notice that it reduces the image colors, while keeping a good
    balance of skin tones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Color effects](img/2267EXP_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will take a look at the **Color Invert** option and see what happens
    when this Core Image filter has been chosen from the list of options within our
    actionsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, and add the following code statement underneath the previous code block
    that we applied in the previous code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we start by declaring a `CIFilter` variable called `invert`.
    This will be used to denote the type of filter we want to apply to our image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot displays the image output with the Color Invert filter
    applied. You will notice that the image colors have been inverted to show more
    of a negative image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Color effects](img/2267EXP_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will take a look at the **Straighten Filter** option and see what happens
    when this Core Image filter has been chosen from the list of options within our
    actionsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ViewController.m` implementation file that is located within the `CIFilterEffects`
    folder, and add the following code statement underneath the previous code block
    that we applied in the previous code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we start by declaring a CIFilter variable called straightenFilter.
    This will be used to denote the type of filter we want to apply to our image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, we assign the variable `cImage` of type `CIImage`, which points
    to the chosen image within our `UIImageView` control, and assign this to be the
    `inputImage`. Finally, we assign the angle level rotation to apply to the image,
    by setting the value of the `inputAngle` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When setting the values of the `inputAngle` property, these have a starting
    range from a minimum value of -3.14 to a maximum value of `3.14`. There is also
    a default value of `0.00`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the image output with the Straighten filter
    applied. You will notice that it rotates the source image by the specified angle
    in radians. The image is then scaled and cropped, so that the rotated image fits
    within the view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Color effects](img/2267EXP_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we need to add the code that will be used to output the updated image
    once this has been applied based on our Core Image filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following code statement underneath the
    previous code block that we applied in the previous code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we start by checking to ensure that we are not processing
    our **Close** and **Cancel** buttons, as those buttons do not apply the core image
    filters to the image. This is a general way of safeguarding our application to
    prevent it from crashing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use the `imageWithCGImage` method to create and return an image object
    representing the specified Quartz image, then displaying this image back to our
    `UIImageView imageView`> control, and setting it to be displayed to the width
    and height of the image view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how we can apply transition effects
    to an image while making use of the Quartz Core framework.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Transitions** are typically used to apply some sort of effect to an image.
    These effects are rendered over time and require that you set up a timer event.
    In this section, we will be adding some code to our `CIFilterEffects` example
    application to show one of the easiest ways in which we can apply a water ripple
    effect to an image.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you don't need to worry as there is already a ripple effect component
    that comes part of the QuartzCore framework, and this will take advantage of the
    graphics hardware acceleration when rendering this effect.
  prefs: []
  type: TYPE_NORMAL
- en: In order for us to start using transitions within our application, we will need
    to add an important framework to our project that will enable us to apply a number
    of different image effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the QuartzCore framework to your project, select the **Project Navigator
    Group**, and then follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click and select your project from the **Project Navigator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select your project target from under the **TARGETS** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Build Phases** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Link binary with Libraries** disclosure triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, use the **+** to add the library you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **QuartzCore.framework** from the list of available frameworks. You
    can also search if you can't find the framework you are after, from within the
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are still confused how to go about adding the frameworks, take a look
    at this screenshot, which highlights the areas that you need to select (surrounded
    by a rectangle):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transitions](img/2267EXP_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have added the `QuartzCore.framework` into your project, we can
    start to add the necessary code to our example project, to apply a water rippling
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.m` implementation file that is located within the
    `CIFilterEffects` folder, and add the following code statement underneath the
    Straighten filter code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we start by declaring a variable called `animation` that
    will be responsible for handling the transition animations for our `UIView` layer.
    In the next step, we specify the duration of our ripple effect that will be used
    to define how long, in seconds, a single iteration of an animation will take to
    display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we set up a timing function. This will be used to specify `UIViewAnimationCurveEaseInOut`
    as the type of animation that we want to use. This causes the animation to start
    off slowly, then accelerate through the middle of its duration, and then begin
    to slow-down towards the end of its iteration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is the default curve for most animations. In the next step, we specify
    that the type of animation we want to use is the `rippleEffect` transition effect.
    Finally, we then apply the animation effect to our view. The following screenshot
    displays the output with the water rippling effect applied. You will notice how
    it curves from the inside out, more like a vacuum effect:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Transitions](img/2267EXP_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, by using both the Core Image and QuartzCore frameworks, you
    can create some fantastic visual effects within your applications, and bring them
    to life.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Core Image and the QuartzCore frameworks, please refer
    to the following link: [http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html](http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the Core Image filters, please refer to the following
    link: [http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html](http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the AirPlay and Core Image frameworks, and
    looked at how we can implement these into our applications to output them to an
    external device, such as Apple TV.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned about the Core Image filters class, and how we can apply the
    different image filter effects to enhance images through the different built-in
    filters, such as color effects. We then familiarized ourselves with the QuartzCore
    framework, and looked at how we can use this framework, using the built-in filters
    for distortions and transition effects, to apply a water ripple effect to an image.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the improvements that have been made
    to the Xcode development tools, and take a look at **Automatic Reference Counting**
    (ARC). This is the latest addition to the LLVM compiler. We will also be taking
    a look at improvements made to Interface Builder, the iOS Location simulator,
    and the set of debugging tools for OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
