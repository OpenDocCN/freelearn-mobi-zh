<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functional Programming with Kotlin and RxKotlin</h1>
                </header>
            
            <article>
                
<p>Functional programming paradigms are slightly different than that of <strong>Object-oriented programming</strong> (<strong>OOP</strong>). It focuses on the use of declarative and expressive programs and immutable data rather than on statements. The definition of functional programming says <em>functional programming is a programming system that relies on structuring the program as the evaluation of mathematical functions with immutable data, and it avoids state-change</em>. It is a declarative programming paradigm that suggests use of small, reusable declarative functions.</p>
<p>We have seen the definition of functional programming; now, don't you want to delve into its definition and see what it exactly means? Do all languages support functional programming? If not, then which languages does and what about Kotlin? What exactly does reactive programming have to do with functional programming? And, finally, what do we need to learn, for functional programming?</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Getting started with functional programming</li>
<li>Relationship of <span>functional programming</span> with reactive programming</li>
<li>The path breaking feature of Kotlin–coroutines</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing functional programming</h1>
                </header>
            
            <article>
                
<p>So, functional programming wants you to distribute your programming logic into small pieces of reusable declarative small and pure functions. Distributing your logic into small pieces of code will make the code modular and non-complex, thus you will be able to refactor/change any module/part of the code at any given point without any effects to other modules.</p>
<p>Functional programming requires some interfaces and support from the language, thus we can't say any language is functional unless it gives some sort of support to implement functional programming. However, functional programming isn't something new; it is actually quite an old concept and has several languages supporting it. We call those languages functional programming languages, and the following is a list of some of the most popular functional programming languages:</p>
<ul>
<li>Lisp</li>
<li>Clojure</li>
<li>Wolfram</li>
<li>Erlang</li>
<li>OCaml</li>
<li>Haskell</li>
<li>Scala</li>
<li>F#</li>
</ul>
<p>Lisp and Haskell are some of the oldest languages and are still used today in academia and industry. While talking about Kotlin, it has excellent support for functional programming from its first stable release in contrast to Java, which doesn't have any support for functional programming before Java 8. You can use Kotlin in both object-oriented and functional-programming style or even in a mix of two, which is really a great benefit for us. With a first-class support for features, such as higher-order functions, function types, and lambdas, Kotlin is a great choice if you're doing or exploring functional programming.</p>
<p>The concept of <strong>functional reactive programming</strong> (<strong>FRP</strong>) is actually a product of mixing reactive programming with functional programming. The main objective of writing functional programming is to implement modular programming; this modular programming is really helpful, or sometimes a necessity to implement reactive programming or rather to implement the four principles of the Reactive Manifesto.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fundamentals of functional programming</h1>
                </header>
            
            <article>
                
<p>Functional programming consists of few new concepts such as lambdas, pure functions, high-order functions, function types, and inline functions, which we will be learning. Quite interesting, isn't it?</p>
<div class="packt_infobox">Note that, although in many programmers word, pure functions and lambdas are the same, they are actually not. In the following part of this chapter, we will learn more about them.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda expressions</h1>
                </header>
            
            <article>
                
<p>Lambda or lambda expressions generally mean <em>anonymous functions</em>, that is, functions without names. You can also say a lambda expression is a function, but not every function is a lambda expression. Not every programming language provides support for lambda expressions, for instance, Java didn't have it until Java 8. The implementations of lambda expressions are also different in respect to languages. Kotlin has good support for lambda expressions and implementing them in Kotlin is quite easy and natural. Let's now take a look at how lambda expressions work in Kotlin:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val sum = { x: Int, y: Int -&gt; x + y } // (1) 
      println("Sum ${sum(12,14)}")// (2) 
      val anonymousMult = {x: Int -&gt; (Random().nextInt(15)+1) * x}<br/>      // (3) 
      println("random output ${anonymousMult(2)}")// (4) 
    } </pre>
<p>In the preceding program, in comment <kbd>(1)</kbd>, we declare a lambda expression that will add two numbers and return the <kbd>sum</kbd> as result; in comment <kbd>(2)</kbd>, we call that function and print it; in comment <kbd>(3)</kbd>, we declare another lambda that will multiply a random number bound to <kbd>15</kbd> with the value <kbd>x</kbd> passed to it and return the result; in comment <kbd>(4)</kbd>, we, again, print it. Both the lambda expressions are actually functions, but without any function name; thus they are also referred to as an anonymous function. If you compare with Java, Java has a feature of anonymous class, but included lambda/anonymous functions only after Java 8.</p>
<p>If you are curious about the output, then refer to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="95" width="417" src="assets/89439c0a-af28-49ca-873c-7d67b118c364.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pure function</h1>
                </header>
            
            <article>
                
<p>The definition of pure function says that <em>if the return value of a function is completely dependent on its arguments/parameters, then this function may be referred to as a pure function</em>. So, if we declare a function as <kbd>fun func1(x:Int):Int</kbd>, then its return value will be strictly dependent on its argument <kbd>x</kbd>; say, if you call <kbd>func1</kbd> with a value of <kbd>3</kbd> twice, then, for both the times, its return value will be the same. A pure function can be a lambda or a named function as well. In the previous example, the first lambda expression was a pure function but not the second one, as for the second one, its return value can be different at different times with the same value passed to it. Let's look at the following example to understand it better:</p>
<pre>    fun square(n:Int):Int {//(1) 
      return n*n 
    } 
 
    fun main(args: Array&lt;String&gt;) { 
      println("named pure func square = ${square(3)}") 
      val qube = {n:Int -&gt; n*n*n}//(2) 
      println("lambda pure func qube = ${qube(3)}") 
    } </pre>
<p>Both the functions, <kbd>(1)</kbd> and <kbd>(2)</kbd>, here are pure functions–one is named, while the other is lambda. If you pass the value <kbd>3</kbd> to any of the functions <kbd>n</kbd> times, their return value will be the same for each time. Pure functions don't have side effects.</p>
<div class="packt_infobox"><strong>Side effects</strong>: A function or expression is said to have a side effect if it modifies some state outside its scope or has an observable interaction with its calling functions or the outside world besides returning a value.<br/>
Source–Wikipedia <span class="URLPACKT"><a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">https://en.wikipedia.org/wiki/Side_effect_(computer_science)</a>.</span></div>
<p>It is to note that, as we said earlier, pure functions have nothing to do with lambda expressions, their definitions are completely different.</p>
<p>The following is the output:</p>
<pre><strong>named pure func square = 9
lambda pure func qube = 27</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">High-order functions</h1>
                </header>
            
            <article>
                
<p>Those functions that take another function as an argument or return a function as result are called <strong>high-order functions</strong>. Consider the following example to understand it better:</p>
<pre>    fun highOrderFunc(a:Int, validityCheckFunc:(a:Int)-&gt;Boolean) {//(1) 
      if(validityCheckFunc(a)) {//(2) 
        println("a $a is Valid") 
      } else { 
        println("a $a is Invalid") 
      } 
    } 
 
    fun main(args: Array&lt;String&gt;) { 
      highOrderFun(12,{ a:Int -&gt; a.isEven()})//(3) 
      highOrderFunc(19,{ a:Int -&gt; a.isEven()}) 
    } </pre>
<p>In this program, we've declared a <kbd>highOrderFunc</kbd> function, which will take an <kbd>Int</kbd> and a <kbd>validityCheckFunc<span class="packt_screen">(Int)</span></kbd> function. We are calling the <kbd>validityCheckFunc</kbd> function inside the <kbd>highOrderFunc</kbd> function, to check whether the value was valid or not. However, we are defining the <kbd>validityCheckFunc</kbd> function at runtime, while we are calling the <kbd>highOrderFunc</kbd> function inside the <kbd>main</kbd> function.</p>
<div class="packt_infobox">Note that the <kbd>isEven</kbd> function in this program is an extension function that has been defined inside the <kbd>project</kbd> files you got with the book.</div>
<p>Here is the output:</p>
<pre><strong>a 12 is Valid 
a 19 is Invalid</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inline functions</h1>
                </header>
            
            <article>
                
<p>While functions are a great way to write modular code, it may sometimes increase program execution time and reduce memory optimization due to function stack maintenance and overhead. Inline functions are a great way to avoid those hurdles in functional programming. For example, see the following code snippet:</p>
<pre>    fun doSomeStuff(a:Int = 0) = a+(a*a) 
 
    fun main(args: Array&lt;String&gt;) { 
      for (i in 1..10) { 
        println("$i Output ${doSomeStuff(i)}") 
      } 
    } </pre>
<p>Let's recite the definition of inline function; it says that <em>inline functions are an enhancement feature to improve the performance and memory optimization of a program</em>. Functions can be instructed to the compiler to make them inline so that the compiler can replace those function definitions wherever those are being called. Compiler replaces the definition of inline functions at compile time instead of referring function definition at runtime; thus, no extra memory is needed for a function call, stack maintenance, and more, and getting the benefits of functions as well.</p>
<p>The preceding program declares a function that adds two numbers and returns the result, and we will call the function in the loop. Instead of declaring a function for this, we can write the addition code right in the place where we will call the function, but declaring a function gives us freedom to modify the addition logic anytime without any effect on the remaining code, for example, if we want to modify the addition with multiplication or something else. If we declare a function as inline, then the code inside that function will replace all the function calls, thus improving performance while keeping our freedom intact. Consider the following code snippet as an example:</p>
<pre>    inline fun doSomeStuff(a:Int = 0) = a+(a*a) 
 
    fun main(args: Array&lt;String&gt;) { 
      for (i in 1..10) { 
        println("$i Output ${doSomeStuff(i)}") 
      } 
    } </pre>
<p>Here is the output of the program:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="222" width="386" src="assets/c9bc3123-9667-4acf-a4ff-d8ec701d34d0.jpg"/></div>
<p>There is one more feature Kotlin provides with inline functions–if you declare a high-order function as <kbd>inline</kbd>, then the <kbd>inline</kbd> keyword affects both the function itself and the lambda passed to it. Let's modify the high-order function code with <kbd>inline</kbd>:</p>
<pre>    inline fun highOrderFuncInline(a:Int, validityCheckFunc:(a:Int)- <br/>    &gt;Boolean) { 
      if(validityCheckFunc(a)) { 
         println("a $a is Valid") 
      } else { 
        println("a $a is Invalid") 
      } 
     } 
 
    fun main(args: Array&lt;String&gt;) { 
      highOrderFuncInline(12,{ a:Int -&gt; a.isEven()}) 
      highOrderFuncInline(19,{ a:Int -&gt; a.isEven()}) 
    } </pre>
<p>The compiler will replace all calls to <kbd>validityCheckFunc</kbd> with its lambda, as it would do with <kbd>highOrderFuncInline</kbd> with its definition. As you can see, there's not much modification of the code, just a small change of adding <kbd>inline</kbd> before a function declaration can improve performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying functional programming to the ReactiveCalculator class</h1>
                </header>
            
            <article>
                
<p>So, now, after trying to understand the <kbd>ReactiveCalculator</kbd> class from the previous chapter, we will try to optimize the code as well. Let's first take a look at the <kbd>init</kbd> block of the <kbd>ReactiveCalculator</kbd> class:</p>
<pre>    init{ 
      nums = Pair(a,b) 
 
      subjectAdd.map({ it.first+it.second }).subscribe({println<br/>      ("Add = $it")} )//1 
      subjectSub.map({ it.first-it.second }).subscribe({println<br/>      ("Substract = $it")} ) 
      subjectMult.map({ it.first*it.second }).subscribe<br/>      ({println("Multiply = $it")} ) 
      subjectDiv.map({ it.first/(it.second*1.0) }).subscribe<br/>      ({println("Divide = $it")} ) 
 
      subjectCalc.subscribe({ 
        with(it) { 
          calculateAddition() 
          calculateSubstraction() 
          calculateMultiplication() 
          calculateDivision() 
        } 
      }) 
 
      subjectCalc.onNext(this) 
     } </pre>
<p>So, now, with the knowledge of functional programming, we can easily say that the <kbd>map</kbd> and <kbd>subscribe</kbd> methods are high-order functions that take function as parameter. However, do you really think that many <kbd>subject</kbd> and subscriber are required? Shouldn't subscriber on the class be sufficient to accomplish the job itself? Let's try to modify and optimize the following piece of code:</p>
<pre>    class ReactiveCalculator(a:Int, b:Int) { 
      val subjectCalc: io.reactivex.subjects.Subject<br/>      &lt;ReactiveCalculator&gt;   = <br/>      io.reactivex.subjects.PublishSubject.create() 
 
      var nums:Pair&lt;Int,Int&gt; = Pair(0,0) 
 
      init{ 
        nums = Pair(a,b) 

        subjectCalc.subscribe({ 
          with(it) { 
            calculateAddition() 
            calculateSubstraction() 
            calculateMultiplication() 
            calculateDivision() 
          } 
        }) 
 
        subjectCalc.onNext(this) 
       } 
 
       inline fun calculateAddition():Int { 
         val result = nums.first + nums.second 
         println("Add = $result") 
         return result 
       } 
 
       inline fun calculateSubstraction():Int { 
         val result = nums.first - nums.second 
         println("Substract = $result") 
         return result 
       } 
 
      inline fun calculateMultiplication():Int { 
        val result = nums.first * nums.second 
        println("Multiply = $result") 
        return result 
      } 
 
      inline fun calculateDivision():Double { 
        val result = (nums.first*1.0) / (nums.second*1.0) 
        println("Multiply = $result") 
        return result 
      } 
 
      inline fun modifyNumbers (a:Int = nums.first, b: <br/>      Int = nums.second) { 
        nums = Pair(a,b) 
        subjectCalc.onNext(this) 
      } 
 
      fun handleInput(inputLine:String?) { 
        if(!inputLine.equals("exit")) { 
            val pattern: java.util.regex.Pattern =<br/>            java.util.regex.Pattern.compile<br/>            ("([a|b])(?:\\s)?=(?:\\s)?(\\d*)"); 
 
            var a: Int? = null 
            var b: Int? = null 
 
            val matcher: java.util.regex.Matcher = <br/>            pattern.matcher(inputLine) 
 
            if (matcher.matches() &amp;&amp; matcher.group(1) != null &amp;&amp;  <br/>            matcher.group(2) != null) { 
                if(matcher.group(1).toLowerCase().equals("a")){ 
                    a = matcher.group(2).toInt() 
                } else if(matcher.group(1).toLowerCase().equals("b")){ 
                    b = matcher.group(2).toInt() 
                } 
            } 
 
            when { 
                a != null &amp;&amp; b != null -&gt; modifyNumbers(a, b) 
                a != null -&gt; modifyNumbers(a = a) 
                b != null -&gt; modifyNumbers(b = b) 
                else -&gt; println("Invalid Input") 
 
            } 
         } 
      } 
 
    } </pre>
<p>So, we have removed all other <kbd>subscriber</kbd> and are doing the job with only one. And here's the output:</p>
<pre><strong>Initial Output with a = 15, b = 10</strong>
<strong>Add = 25</strong>
<strong>Substract = 5</strong>
<strong>Multiply = 150</strong>
<strong>Multiply = 1.5</strong>
<strong>Enter a = &lt;number&gt; or b = &lt;number&gt; in separate lines</strong>
<strong>exit to exit the program</strong>
<strong>a = 6</strong>
<strong>Add = 16</strong>
<strong>Substract = -4</strong>
<strong>Multiply = 60</strong>
<strong>Multiply = 0.6</strong>
<strong>b=4</strong>
<strong>Add = 10</strong>
<strong>Substract = 2</strong>
<strong>Multiply = 24</strong>
<strong>Multiply = 1.5</strong>
<strong>exit</strong>
  </pre>
<p>We subscribe to the class object itself; so, whenever its variables get changed, we get notified, and we perform all the tasks right there in the <kbd>subscribe</kbd> method. Moreover, as we have made the functions inline, they'll also help in the optimization of performance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coroutines</h1>
                </header>
            
            <article>
                
<p>Path breaking and, probably, the most exciting feature in Kotlin are coroutines. They are a new way to write asynchronous, non-blocking code somewhere like the threads, but way more simple, efficient, and lightweight. Coroutines were added in Kotlin 1.1 and are still experimental, so think before using it in production.</p>
<p>In the later chapters of this book, you'll learn about Schedulers in RxKotlin, which encapsulates the complexities of threading, but you can use it only in RxKotlin chain, while you can use coroutines anywhere and everywhere. That is indeed a path-breaking feature of Kotlin. They provide a great abstraction on threads, making context changes and concurrency easier.</p>
<p>Keep in mind that RxKotlin does not use coroutines yet; the reason is quite simple–both coroutines and Schedulers in RxKotlin share nearly the same internal architecture; while coroutines are new, Schedulers have been there for a long time with RxJava, RxJs, RxSwift, and more.</p>
<p>Coroutines are the best fit for developers to implement concurrency when they're not using/can't use RxKotlin Schedulers.</p>
<p>So, let's start by adding it to our project. If you are using Gradle, follow these steps (<kbd>apply plugin</kbd> could be <kbd>'kotlin'</kbd> or <kbd>'kotlin-android'</kbd>, depending on whether you use it for JVM or Android):</p>
<pre>    apply plugin: 'kotlin' 
 
    kotlin { 
      experimental { 
        coroutines 'enable' 
      } 
    } </pre>
<p>And then, we have to add the following dependency:</p>
<pre>    repositories { 
      ... 
      jcenter() 
    } 
    dependencies { 
      ... 
      compile "org.jetbrains.kotlinx:kotlinx-coroutines-core:0.16" 
    } </pre>
<p>If you are using Maven, then add the following code block in the <kbd>pom.xml</kbd> file:</p>
<pre>    &lt;plugin&gt; 
      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; 
      &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; 
      ... 
      &lt;configuration&gt; 
        &lt;args&gt; 
            &lt;arg&gt;-Xcoroutines=enable&lt;/arg&gt; 
        &lt;/args&gt; 
      &lt;/configuration&gt; 
    &lt;/plugin&gt; 
    &lt;repositories&gt; 
      ... 
      &lt;repository&gt; 
        &lt;id&gt;central&lt;/id&gt; 
        &lt;url&gt;http://jcenter.bintray.com&lt;/url&gt; 
      &lt;/repository&gt; 
    &lt;/repositories&gt; 
    &lt;dependencies&gt; 
      ... 
      &lt;dependency&gt; 
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; 
        &lt;artifactId&gt;kotlinx-coroutines-core&lt;/artifactId&gt; 
        &lt;version&gt;0.16&lt;/version&gt; 
      &lt;/dependency&gt; 
    &lt;/dependencies&gt; </pre>
<div class="packt_infobox">Apache Maven is a software project management and comprehension tool. Based on the concept of a <strong>Project Object Model</strong> (<strong>POM</strong>), Maven can manage a project's build, reporting, and documentation from a central piece of information. Please refer to the following URL for more information–<span class="URLPACKT"><a href="https://maven.apache.org/">https://maven.apache.org/</a>.</span></div>
<p>So, what exactly is a coroutine? While developing applications, we often come into situations where we need to perform long running or time taking operations, such as network call, database operations, or some complex computations. The only option in Java is to use a thread to handle such situations, which is very complex itself. Whenever we face those situations, we feel the need for a simple yet powerful API to handle such cases. Developers from the .NET domain, especially those who used C# before, are familiar with the <kbd>async</kbd>/<kbd>await</kbd> operators; this is somehow the closest to Kotlin coroutines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with coroutines</h1>
                </header>
            
            <article>
                
<p>So, let's take the following example into consideration:</p>
<pre>    suspend fun longRunningTsk():Long {//(1) 
      val time = measureTimeMillis {//(2) 
        println("Please wait") 
        delay(2,TimeUnit.SECONDS)//(3) 
        println("Delay Over") 
      } 
      return time 
    } 
 
    fun main(args: Array&lt;String&gt;) { 
      runBlocking {//(4) 
        val exeTime = longRunningTsk()//(5) 
        println("Execution Time is $exeTime") 
      } 
    } </pre>
<p>We will inspect through the code, but let's first see the output:</p>
<pre><strong>Please wait 
Delay Over 
Execution Time is 2018</strong> </pre>
<p>So, now, let's understand the code. On comment <kbd>(1)</kbd>, while declaring the function, we mark the function with the <kbd>suspend</kbd> keyword, which is used to mark a function as suspending, that is, while executing the function the program should wait for its result; therefore, execution of suspending a function in main thread is not allowed (giving you a clear barrier between main thread and suspending functions). On comment <kbd>(2)</kbd>, we started a block with <kbd>measureTimeMillis</kbd> and assigned its value to the (<kbd>val</kbd>) <kbd>time</kbd> variable. The job of <kbd>measureInMillis</kbd> is quite simple–it executes the block passed to it while measuring its execution time, and returns the same. We will use the <kbd>delay</kbd> function on comment <kbd>(3)</kbd> to intentionally delay the program execution by <kbd>2</kbd> seconds. The <kbd>runBlocking</kbd> block in the <kbd>main</kbd> function on comment <kbd>(4)</kbd> makes the program wait until the called <kbd>longRunningTsk</kbd> function on comment <kbd>(5)</kbd> completes. So, this was a quite simple example; however, we are making the main thread wait here. Sometimes, you will not want this; instead, you will want to do asynchronous operations. So, let's try to achieve this as well:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val time = async(CommonPool) { longRunningTsk() }//(1) 
      println("Print after async ") 
      runBlocking { println("printing time ${time.await()}") }//(2) 
    } </pre>
<p>Here, we kept <kbd>longRunningTsk</kbd> same, just modified the <kbd>main</kbd> function. On comment <kbd>(1)</kbd>, we assigned the <kbd>time</kbd> variable to the value of <kbd>longRunningTsk</kbd> inside the <kbd>async</kbd> block. The <kbd>async</kbd> block is quite interesting; it executes the code inside its block asynchronously on the coroutine context passed to it.</p>
<div class="packt_infobox">There are basically three types of coroutine contexts. <kbd>Unconfined</kbd> means it'll run on the main thread, <kbd>CommonPool</kbd> runs on the common thread pool, or you can create a new coroutine context as well.</div>
<p>On comment <kbd>(2)</kbd> we run a blocking code that will make the <kbd>main</kbd> function wait until the value of the <kbd>time</kbd> variable is available; the <kbd>await</kbd> function helps us accomplish this task–it tells the <kbd>runBlocking</kbd> block to wait until the <kbd>async</kbd> block completes execution to make the value of <kbd>time</kbd> available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building sequences</h1>
                </header>
            
            <article>
                
<p>As I mentioned earlier, Kotlin coroutines are something more than threads in Java and <kbd>async</kbd>/<kbd>await</kbd> in C#. Here is a feature that, after learning, you will be pissed that it was not there while you were learning to code. To add icing on the cake, this feature is application level, it is even shipped with <kbd>kotlin-stdlib</kbd>, so you can use it right there without doing anything or even using coroutines explicitly.</p>
<p>Before learning what I am talking about, let's do some old school code, say the fibonacci series? Consider the following piece of code as an example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      var a = 0 
      var b = 1 
      print("$a, ") 
      print("$b, ") 
 
      for(i in 2..9) { 
        val c = a+b 
        print("$c, ") 
        a=b 
        b=c 
      } 
    } </pre>
<p>So, this is the old-school fibonacci series program in Kotlin. This code becomes more problematic when you plan to take the user input for how many numbers to print. What if I say Kotlin has a <kbd>buildSequence</kbd> function that can do this task for you, that too pretty naturally and in a simpler way? So, let's modify the code now:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val fibonacciSeries = buildSequence {//(1) 
        var a = 0 
        var b = 1 
        yield(a)//(2) 
        yield(b) 
 
        while (true) { 
            val c = a+b 
            yield(c)//(3) 
            a=b 
            b=c 
        } 
     } 
 
     println(fibonacciSeries.take(10) join "," )//(4) 
 
    } </pre>
<p>The following is the output for both the programs:</p>
<pre><strong>0, 1, 1, 2, 3, 5, 8, 13, 21, 34</strong> </pre>
<p>Now, let's understand the program. On comment <kbd>(1)</kbd>, we declare <kbd>val fibonacciSeries</kbd> to be filled up by the <kbd>buildSequence</kbd> block. Whenever we have computed some value to output to the sequence/series, we will yield that value (in comment <kbd>2</kbd> and <kbd>3</kbd>). On comment <kbd>4</kbd>, we call <kbd>fibonacciSeries</kbd> to compute up to the <kbd>10</kbd><sup>th</sup> variable and join elements of the sequence with a comma (<kbd>,</kbd>).</p>
<p>So, you learned coroutine; now, let's implement it into our program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ReactiveCalculator class with coroutines</h1>
                </header>
            
            <article>
                
<p>So far, in the <kbd>ReactiveCalculator</kbd> program, we were performing everything on the same thread; don't you think we should rather do the things asynchronously? So, let's do it:</p>
<pre>    class ReactiveCalculator(a:Int, b:Int) { 
      val subjectCalc:<br/>      io.reactivex.subjects.Subject&lt;ReactiveCalculator&gt; =<br/>      io.reactivex.subjects.PublishSubject.create() 
 
      var nums:Pair&lt;Int,Int&gt; = Pair(0,0) 
 
      init{ 
        nums = Pair(a,b) 
 
        subjectCalc.subscribe({ 
            with(it) { 
                calculateAddition() 
                calculateSubstraction() 
                calculateMultiplication() 
                calculateDivision() 
            } 
        }) 
 
        subjectCalc.onNext(this) 
      } 
 
      inline fun calculateAddition():Int { 
        val result = nums.first + nums.second 
        println("Add = $result") 
        return result 
      } 
 
      inline fun calculateSubstraction():Int { 
        val result = nums.first - nums.second 
        println("Substract = $result") 
        return result 
      } 
 
      inline fun calculateMultiplication():Int { 
        val result = nums.first * nums.second 
        println("Multiply = $result") 
        return result 
     } 
 
     inline fun calculateDivision():Double { 
        val result = (nums.first*1.0) / (nums.second*1.0) 
        println("Division = $result") 
        return result 
     } 
 
     inline fun modifyNumbers (a:Int = nums.first, b: <br/>     Int = nums.second) { 
        nums = Pair(a,b) 
        subjectCalc.onNext(this) 
 
     } 
 
     suspend fun handleInput(inputLine:String?) {//1 
        if(!inputLine.equals("exit")) { 
            val pattern: java.util.regex.Pattern =  <br/>            java.util.regex.Pattern.compile<br/>            ("([a|b])(?:\\s)?=(?:\\s)?(\\d*)"); 
 
            var a: Int? = null 
            var b: Int? = null 
 
            val matcher: java.util.regex.Matcher =<br/>            pattern.matcher(inputLine) 
 
            if (matcher.matches() &amp;&amp; matcher.group(1) != null &amp;&amp;<br/>            matcher.group(2) != null) { 
                if(matcher.group(1).toLowerCase().equals("a")){ 
                    a = matcher.group(2).toInt() 
                } else if(matcher.group(1).toLowerCase().equals("b")){ 
                    b = matcher.group(2).toInt() 
                } 
            } 
 
            when { 
                a != null &amp;&amp; b != null -&gt; modifyNumbers(a, b) 
                a != null -&gt; modifyNumbers(a = a) 
                b != null -&gt; modifyNumbers(b = b) 
                else -&gt; println("Invalid Input") 
 
            } 
         } 
       } 
 
    } 
 
    fun main(args: Array&lt;String&gt;) { 
    println("Initial Out put with a = 15, b = 10") 
    var calculator: ReactiveCalculator = ReactiveCalculator(15, 10) 
 
    println("Enter a = &lt;number&gt; or b = &lt;number&gt; in separate lines\nexit<br/>    to exit the program") 
    var line:String? 
    do { 
        line = readLine(); 
        async(CommonPool) {//2 
            calculator.handleInput(line) 
        } 
    } while (line!= null &amp;&amp; !line.toLowerCase().contains("exit")) 
   } </pre>
<p>On comment <kbd>(1)</kbd>, we will declare the <kbd>handleInput</kbd> function as suspending, which tells the JVM that this function is supposed to take longer, and the execution of the context calling this function should wait for it to complete. As I already mentioned earlier, suspending functions cannot be called in the main context; so, on comment <kbd>(2)</kbd>, we created an <kbd>async</kbd> block to call the function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional programming – monads</h1>
                </header>
            
            <article>
                
<p>Functional programming is incomplete without monads. If you are into functional programming, then you know it very well; otherwise, you are hearing it for the first time. So, what is a monad? Let's learn about it. The concept of monad is quite abstract; the definition says <em>monad is a structure that creates a new type by encapsulating a value and adding some extra functionalities to it</em>. So, let's start by using a monad; take a look at the following program:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val maybeValue: Maybe&lt;Int&gt; = Maybe.just(14)//1 
      maybeValue.subscribeBy(//2 
        onComplete = {println("Completed Empty")}, 
        onError = {println("Error $it")}, 
        onSuccess = { println("Completed with value $it")} 
      ) 
      val maybeEmpty:Maybe&lt;Int&gt; = Maybe.empty()//3 
      maybeEmpty.subscribeBy( 
        onComplete = {println("Completed Empty")}, 
        onError = {println("Error $it")}, 
        onSuccess = { println("Completed with value $it")} 
      ) 
    } </pre>
<p>Here, <kbd>Maybe</kbd> is a monad that encapsulates an <kbd>Int</kbd> value with some added functionalities. The <kbd>Maybe</kbd> monad says it may or may not contain a value, and it completes with or without a value or with an error. So, if there's an error, then it would obviously call <kbd>onError</kbd>; if there are no errors, and if it has a value, it will call <kbd>onSuccess</kbd> with the value; and, if it doesn't have a value and no error as well, it will call <kbd>onComplete</kbd>. The thing to note is that all three methods here, <kbd>onError</kbd>, <kbd>onComplete</kbd>, and <kbd>onSuccess</kbd>, are terminal methods, meaning either one of these three will get called by a <kbd>Maybe</kbd> monad, and others will never be called.</p>
<p>Let's go through the program to understand the monads better. On comment <kbd>(1)</kbd>, we will declare a <kbd>Maybe</kbd> monad and assign a value of <kbd>14</kbd> to it. On comment <kbd>(2)</kbd>, we will subscribe to the monad. On comment <kbd>(3)</kbd>, we will again declare a <kbd>Maybe</kbd> monad, this time with an empty value. The subscription takes three lambdas as parameter–when the monad contains a value, <kbd>onSuccess</kbd> gets called; when it doesn't contain any value, <kbd>onComplete</kbd> gets called; and if any error occurs, then <kbd>onError</kbd> gets called. Let's see the output now:</p>
<pre><strong>Completed with value 14 
Completed Empty</strong> </pre>
<p>So, as we can see, for <kbd>maybeValue</kbd>, <kbd>onSuccess</kbd> gets called, but for <kbd>maybeEmpty</kbd> , the <kbd>onComplete</kbd> method gets called.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single monad</h1>
                </header>
            
            <article>
                
<p><kbd>Maybe</kbd> is just another type of monad, there are a lot more; we will cover a few of the most important ones in later chapters, and combine them with reactive programming as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about functional programming. If you grasped the concept of functional programming well enough, the puzzles for reactive programming will automatically get solved for you. We also learned the meaning of functional reactive programming.</p>
<p>By learning functional programming, we also got a clear idea on the constraints from the previous chapter.</p>
<p>We also got our hands on the introduction to coroutines, which is a path breaking new feature of the Kotlin language.</p>
<p>We have modified our <kbd>ReactiveCalculator</kbd> class with coroutine and a few new concepts of functional programming and optimized it.</p>


            </article>

            
        </section>
    </body></html>