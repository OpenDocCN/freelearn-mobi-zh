- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services, WorkManager, and Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to the concepts of managing long-running tasks
    in the background of an app. By the end of this chapter, you will be able to trigger
    a background task, create a notification for the user when a background task is
    complete, and launch an application from a notification. This chapter will give
    you a solid understanding of how to manage background tasks and keep the user
    informed about the progress of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to request permissions from the user
    and use Google’s Maps API. With that knowledge, we obtained the user’s location
    and allowed them to deploy an agent on a local map. In this chapter, we will learn
    how to track a long-running process and report its progress to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We will build an example app where we will assume that **Secret Cat Agents**
    (**SCAs**) get deployed in a record time of 15 seconds. When a cat successfully
    deploys, we will notify the user and let them launch the app, presenting them
    with a successful deployment message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will go with 15 seconds because that way, we will avoid having to wait for
    very long before our background task completes.
  prefs: []
  type: TYPE_NORMAL
- en: Ongoing background tasks are quite common in the mobile world. Background tasks
    run even when an application is not active. Examples of long-running background
    tasks include the downloading of files, resource clean-up jobs, playing music,
    and tracking the user’s location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, Google offered Android developers multiple ways of executing
    such tasks: `Services`, `JobScheduler`, and Firebase’s `JobDispatcher` and `AlarmManager`.
    With the fragmentation that existed in the Android world, it was quite a mess
    to cope with. Luckily for us, since March 2019, we have had a better (more stable)
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of `WorkManager`, Google has abstracted the logic of choosing
    a background executing mechanism based on the API version away for us. We still
    use a foreground service, which is a special kind of service, for certain tasks
    that should be known to the user while running, such as playing music or tracking
    the user’s location in a running app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Services** are application components designed to run in the background,
    even when an app is not running. Except for foreground services, which are tied
    to a notification, services have no user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, take a quick step back. We have mentioned services, and we
    will be focusing on foreground services, but we haven’t quite explained what services
    are. Services are application components designed to run in the background, even
    when an app is not running.
  prefs: []
  type: TYPE_NORMAL
- en: Services have no user interface, with foreground services being the exception.
    It is important to note that services run on the main thread of their hosting
    process. This means that their operations can block the app. It is up to us to
    start a separate thread from within a service to avoid that.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started and look at the implementation of the multiple approaches
    available in Android for managing a background task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a background task using `WorkManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background operations noticeable to the user – using a Foreground Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/i8IRQ](https://packt.link/i8IRQ)
  prefs: []
  type: TYPE_NORMAL
- en: Starting a background task using WorkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first question we will address here is should we opt for `WorkManager` or
    a foreground service? To answer that, a good rule of thumb is to ask whether you
    need the action to be tracked by the user in real time.
  prefs: []
  type: TYPE_NORMAL
- en: If the answer is yes (for example, if you have a task such as responding to
    the user’s location or playing music in the background), then you should use a
    foreground service with its attached notification to give the user a real-time
    indication of state. When the background task can be delayed or does not require
    user interaction (for example, downloading a large file), use `WorkManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version `2.3.0-alpha02` of `WorkManager`, you can launch a foreground
    service via the `WorkManager` singleton by calling `setForegroundAsync(ForegroundInfo)`.
    Our control over that foreground service is quite limited. It does allow you to
    attach a (predefined) notification to the work, which is why it is worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: In our example app, we will track the SCAs’ preparation for deployment. Before
    an agent can head out, they need to stretch, groom their fur, visit the litter
    box, and suit up. Each one of these tasks takes some time. Because you can’t rush
    a cat, the agent will finish each step in its own time. All we can do is wait
    (and let the user know when the task is done). `WorkManager` is perfect for such
    a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `WorkManager`, we need to familiarize ourselves with its four main classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkManager`: This receives work and enqueues it based on provided arguments
    and constraints (such as internet connectivity and the device charging).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Worker`: This is a wrapper around the work that needs doing. It has one function,
    `doWork()`, which we override to implement the background work code. The `doWork()`
    function will be executed in a background thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkRequest`: This class binds a `Worker` class to arguments and constraints.
    There are two types of `WorkRequest`: `OneTimeWorkRequest`, which runs the work
    once, and `PeriodicWorkRequest`, which can be used to schedule work to run at
    a fixed interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListenableWorker.Result`: You probably guessed it, but this is the class holding
    the result of the executed work. The result can be one of `Success`, `Failure`,
    or `Retry`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than these four classes, we also have the `Data` class, which holds data
    passed to and from the worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get back to our example. We want to define four tasks that need to occur
    in sequential order: the cat needs to stretch, then it needs to groom its fur,
    then visit the litter box, and, finally, it needs to suit up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start using `WorkManager`, we have to first include its dependency
    in our app `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With `WorkManager` included in our project, we’ll go ahead and create our workers.
    The first worker will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start by extending `Worker` and overriding its `doWork()` function. We then
    read the SCA ID from the input data. Then, because we have no real sensors to
    track the progress of the cat stretching, we fake our wait by introducing a 3-second
    (3,000 milliseconds) `Thread.sleep(Long)` call. Finally, we construct an output
    `data` class with the ID we received in our input and return it with the successful
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve created workers for all our tasks (`CatStretchingWorker`, `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`), similarly to how we created
    the first one, we can call `WorkManager` to chain them. Let’s also assume we can’t
    tell the progress of the agent unless we’re connected to the internet. Our call
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first construct a `Constraints` instance declaring
    we need to be connected to the internet for the work to execute. We then define
    our input data, setting it to the SCA ID. Next, we bind the constraints and input
    data to our `Worker` class by constructing `OneTimeWorkRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: The construction of the other `WorkRequest` instances has been left out, but
    they are almost identical to the one shown here. We can now chain all the requests
    and enqueue them in the `WorkManager` class. You can enqueue a single `WorkRequest`
    instance by passing it directly to the `WorkManager` `enqueue()` function, or
    you can have multiple `WorkRequest` instances run in parallel by passing them
    all to the `WorkManager` `enqueue()` function as a list.
  prefs: []
  type: TYPE_NORMAL
- en: Our tasks will be executed by `WorkManager` when the constraints are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Request` instance has a unique identifier. `WorkManager` exposes a `LiveData`
    property for each request, allowing us to track the progress of its work by passing
    its unique identifier, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The state of work can be `BLOCKED` (there is a chain of requests, and this one
    is not next in the chain), `ENQUEUED` (there is a chain of requests, and this
    work is next), `RUNNING` (the work in `doWork()` is executing), and `SUCCEEDED`.
    Work can also be canceled, leading to a `CANCELLED` state, or it can fail, leading
    to a `FAILED` state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there’s `Result.retry`. Returning this result tells the `WorkManager`
    class to enqueue the work again. The policy governing when to run the work again
    is defined by a `backoff` criteria set on `WorkRequest` `Builder`. The default
    `backoff` policy is exponential, but we can set it to be linear instead. We can
    also define the initial `backoff` time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put the knowledge gained so far into practice in the following exercise.
    In this section, we will track our SCA from the moment we fire off the command
    to deploy it to the field to the moment it arrives at its destination.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.01 – executing background work with the WorkManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this first exercise, we will track the SCA as it prepares to head out by
    enqueuing the chained `WorkRequest` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new `Empty Activity` project (**File** | **New** | **New
    Project** | **Empty Activity**). Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your application `Cat` `Agent Tracker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your package name is `com.example.catagenttracker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the save location to where you want to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave everything else at its default values and click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you are on the Android view in your **Project** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your app’s `build.gradle` file. In the `dependencies` block, add the `WorkManager`
    dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow you to use `WorkManager` and its dependencies in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package under your app package (right-click on `com.example.catagenttracker`,
    then `com.example.catagenttracker.worker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class under `com.example.catagenttracker.worker` named `CatStretchingWorker`
    (right-click on `worker`, then **New** | **New** **Kotlin File/Class**). Under
    **Kind**, choose **Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To define a `Worker` instance that will sleep for `3` seconds, update the new
    class like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will add the required dependencies for a `Worker` implementation and then
    extend the `Worker` class. To implement the actual work, you will override `doWork():
    Result`, making it read the Cat Agent ID from the input, sleep for `3` seconds
    (`3,000` milliseconds), construct an output data instance with the Cat Agent ID,
    and pass it via a `Result.success` value.'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *steps 9* and *10* to create three more identical workers named `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `MainActivity`. Right before the end of the class, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This helper function constructs an input `Data` instance for you with the Cat
    Agent ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the `onCreate(Bundle?)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line added defines a network constraint. It tells the `WorkManager`
    class to wait for an internet connection before executing work. Then, you define
    your Cat Agent ID. Finally, you define four requests, passing in your `Worker`
    classes, the network constraints, and the Cat Agent ID in the form of input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the class, define your `WorkManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a chained `enqueue` request right below the code you just added, still
    within the `onCreate` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your `WorkRequests` are now enqueued to be executed in sequence when their constraints
    are met and the `WorkManager` class is ready to execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a function to show a toast with a provided message. It should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To track the progress of the enqueued `WorkRequest` instances, add the following
    after the `enqueue` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code observes a `WorkInfo` observable provided by the `WorkManager`
    class for each `WorkRequest`. When each request is finished, a toast is shown
    with a relevant message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Toasts showing in order](img/B19411_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Toasts showing in order
  prefs: []
  type: TYPE_NORMAL
- en: You should now see a simple `Hello World!` screen. However, if you wait a few
    seconds, you will start seeing toasts informing you of the progress of your SCA
    preparing to deploy to the field. You will notice that the toasts follow the order
    in which you enqueued the requests and execute their delays sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Background operations noticeable to the user – using a Foreground Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our SCA all suited up, they are now ready to get to the assigned destination.
    To track the SCA, we will periodically poll the location of the SCA using a Foreground
    Service and update the sticky notification (a notification that cannot be dismissed
    by the user) attached to that service with the new location.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we will fake the location. Following what you learned
    in [*Chapter 7*](B19411_07.xhtml#_idTextAnchor421), *Android Permissions and Google
    Maps*, you could later replace this implementation with a real one that uses a
    map.
  prefs: []
  type: TYPE_NORMAL
- en: Foreground services are another way of performing background operations. The
    name may be a bit counterintuitive. It is meant to differentiate these services
    from the base Android (background) services. The former are tied to a notification,
    while the latter run in the background with no user-facing representation built
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference between foreground services and background services
    is that the latter are candidates for termination when the system is low on memory,
    while the former are not.
  prefs: []
  type: TYPE_NORMAL
- en: As of Android 9 (Pie, or API level 28), we have to request the `FOREGROUND_SERVICE`
    permission to use foreground services. Since it is a normal permission, it will
    be granted to our app automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can launch a foreground service, we must first create one. A foreground
    service is a subclass of the Android abstract `Service` class. If we do not intend
    to bind to the service, and in our example, we do not, we can simply override
    `onBind(Intent)` so that it returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, binding is one of the ways for interested clients to communicate
    with a service. We will not focus on this approach in this book, as there are
    other, easier approaches, as you will discover.
  prefs: []
  type: TYPE_NORMAL
- en: A Foreground Service must be tied to a notification. On Android 8 (Oreo, or
    API level 26) and above, if a Foreground Service is not tied to one within the
    **Application Not Responding** (**ANR**) time window (around five seconds), the
    service is stopped, and the app is declared as not responding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this requirement, it is best if we tie the service to a notification
    as soon as we can. The best place to do that would be in the `onCreate()` function
    of the service. A quick implementation would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break this down.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining the channel ID. This is only required for Android Oreo
    or above and is ignored in earlier versions of Android. In Android Oreo, Google
    introduced the concept of channels. Channels are used to group notifications and
    allow users to filter out unwanted notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define `pendingIntent`. This will be the `Intent` launched if the user
    taps on the notification. In this example, the main activity would be launched.
    It is constructed by wrapping an `Intent` activity launching in a `PendingIntent`.
    The request code is set to `0` because this example doesn’t expect a result, so
    the code will not be used.
  prefs: []
  type: TYPE_NORMAL
- en: The flag is set to `0` for APIs older than S (31). Otherwise, it is set to the
    recommended `PendingIntent.FLAG_IMMUTABLE`, which means that additional arguments
    passed to the `Intent` on send will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the channel ID and `pendingIntent`, we can construct our notification.
    We use `NotificationCompat`, which takes away some of the boilerplate around supporting
    older API levels. We pass in the context and the channel ID. We define the title,
    text, small icon, `Intent`, and ticker message and build the notification to complete
    the builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To start a service in the foreground, attaching the notification to it, we
    call it the `startForeground(Int, Notification)` function, passing in a notification
    ID (any unique `int` value to identify this service, which must not be 0) and
    a notification, which must have its priority set to `PRIORITY_LOW` or higher.
    In our case, we have not specified the priority, which sets it to `PRIORITY_DEFAULT`:'
  prefs: []
  type: TYPE_NORMAL
- en: If launched, our service will now show a sticky notification. Clicking on the
    notification would launch our main activity.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our service doesn’t perform any operations aside from showing a notification.
    To add some functionality to it, we need to override `onStartCommand(Intent?,
    Int, Int)`. This function gets called when the service is launched via an Intent.
  prefs: []
  type: TYPE_NORMAL
- en: This also gives us the opportunity to read any extra data passed via that Intent.
    It also provides us with flags (which may be set to `START_FLAG_REDELIVERY` or
    `START_FLAG_RETRY`) and a unique request ID. We will get to reading the extra
    data later in this chapter. You don’t need to worry about the flags or the request
    ID in a simple implementation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that `onStartCommand(Intent?, Int, Int)` gets called
    on the UI thread, so don’t perform any long-running operations here, or your app
    will freeze, giving the user a poor experience. Instead, we could create a new
    handler using a new `HandlerThread` (a thread with a looper, a class used to run
    a message loop for a thread) and post our work to it.
  prefs: []
  type: TYPE_NORMAL
- en: This means we’ll have an infinite loop running, waiting for us to post to it
    via a `Handler`. When we receive a `start` command, we can post the work we want
    to be done to it. That work will then be executed on that thread.
  prefs: []
  type: TYPE_NORMAL
- en: When our long-running work is done, there are a few things we may want to happen.
    First, we may want to inform whoever is interested (our main activity, if it is
    running, for example) that we are done. Then, we probably want to stop running
    in the foreground. Lastly, if we do not expect to require the service again, we
    could stop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An app has several ways to communicate with a service: binding, using broadcast
    receivers, using a bus architecture, or using a result receiver, to name just
    a few. For our example, we will use Google’s `LiveData`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, it is worth touching on broadcast receivers. Broadcast receivers
    allow our app to send and receive messages using a pattern much like the *publish-subscribe*
    *design pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: The system broadcasts events such as the device booting up or charging having
    started. Our services can broadcast status updates as well. For example, they
    can broadcast a long calculation result on completion. If our app registers to
    receive a certain message, the system will inform it when that message is broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: This used to be a common way to communicate with services, but the `LocalBroadcastManager`
    class is now deprecated as it was an application-wide event bus that encouraged
    anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, broadcast receivers are still useful for system-wide events.
    We first define a class overriding the `BroadcastReceiver` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When an event is received by `ToastBroadcastReceiver`, it will show a toast
    showing the action and URI of the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can register our receiver via the `Manifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Specifying `android:exported="true"` tells the system that this receiver can
    receive messages from outside of the application. The action defines the message
    we are interested in. We can specify multiple actions. In this example, we listen
    for when the device starts charging. Keep in mind that setting this value to `true`
    allows other apps, including malicious ones, to activate this receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also register for messages in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding this code to an activity or in our custom application class would register
    a new instance of our receiver as well. This receiver will live so long as the
    context (activity or application) is valid. So, correspondingly, if the activity
    or application is destroyed, our receiver will be freed to be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to our implementation. `LiveData` already comes bundled with `androidx.appcompat`,
    saving us the trouble of having to manually include it in our project. We can
    define a `LiveData` instance in the companion object of the service, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we hide the `MutableLiveData` instance behind a `LiveData` interface.
    This is so that consumers can only read the data. We can now use the `mutableWorkCompletion`
    instance to report completion by assigning it a value. However, we must remember
    that values can only be assigned to the `LiveData` instances on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: This means once our work is done, we must switch back to the main thread. We
    can easily achieve that—all we need is a new handler with the main `Looper` (obtained
    by calling `Looper.getMainLooper()`), to which we can post our update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our service is ready to do some work, we can finally launch it. Before
    we do, we must make sure we added the service to our `AndroidManifest.xml` file
    within the `<application></application>` block, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch the service we just added to our manifest, we create `Intent`, passing
    in any extra data required, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, we call `ContextCompat.startForegroundService(Context, Intent)` to fire
    off `Intent` and launch the service.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.02 – tracking your SCA’s work with a Foreground Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first exercise, you tracked the SCA as it was preparing to head out using
    the `WorkManager` class and multiple Worker instances showing toasts. In this
    exercise, you will track the SCA as it deploys to the field and moves toward the
    assigned target by showing a sticky notification counting down the time to arrival
    at the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'This notification will be driven by a Foreground Service, which will present
    and continuously update it. Clicking the notification at any time will launch
    your main activity if it’s not already running and will always bring it to the
    foreground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `WorkManager` dependency to your app’s `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new class called `RouteTrackingService`, extending the abstract `Service`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will not rely on binding in this exercise, so it is safe to simply return
    `null` in the `onBind(Intent)` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the newly created service, define some constants that you will later need,
    as well as the `LiveData` instance used to observe progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NOTIFICATION_ID` has to be a unique identifier for the notification owned
    by this service and must not be `0`. Now, `EXTRA_SECRET_CAT_AGENT_ID` is the constant
    you will use to pass data to the service. `mutableTrackingCompletion` is private
    and is used to allow you to post completion updates internally via `LiveData`
    without exposing the mutability outside of the service. `trackingCompletion` is
    then used to expose the `LiveData` instance for observation in an immutable fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function to your `RouteTrackingService` class to provide `PendingIntent`
    to your sticky notification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will launch `MainActivity` whenever the user clicks on `Notification`.
    You call `PendingIntent.getActivity()`, passing a context, no request code (`0`),
    `Intent` that will launch `MainActivity`, and the `FLAG_IMMUTABLE` flag if available,
    otherwise no flags (`0`) to it. You get back a `PendingIntent`, which will launch
    that activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another function to create `NotificationChannel` on devices running Android
    Oreo or newer, and return a channel ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You start by checking the Android version. You only need to create a channel
    if it’s Android O or later. Otherwise, you can return an empty string. For Android
    O, you define the channel ID. This needs to be unique for a package. Next, you
    define a channel name that will be visible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: This can (and should) be localized. We skipped that part for the sake of simplicity.
    A `NotificationChannel` instance is then created with the importance set to `IMPORTANCE_DEFAULT`.
    The importance dictates how disruptive the notifications posted to this channel
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, a channel is created using `Notification Service` with the data provided
    in the `NotificationChannel` instance. The function returns the channel ID so
    that it can be used to construct the `Notification`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function to provide you with `Notification.Builder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function takes the `pendingIntent` and `channelId` instances generated
    from the functions you created earlier and constructs a `NotificationCompat.Builder`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The builder lets you define a title (the first row), text (the second row),
    a small icon (size differs based on the device) to use, the `Intent` to be triggered
    when the user clicks on **Notification**, and a ticker (used for accessibility;
    before Android Lollipop, this showed before the notification was presented).
  prefs: []
  type: TYPE_NORMAL
- en: Setting the notification to ongoing prevents users from dismissing them. This
    also prevents Android from muting the notification due to frequent updates.
  prefs: []
  type: TYPE_NORMAL
- en: You can set other properties, too. Explore the `NotificationCompat.Builder`
    class. In a real project, remember to use string resources from `strings.xml`
    rather than hardcoded strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following code to introduce a function to start the foreground
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You first get `PendingIntent` using the `getPendingIntent` function you introduced
    earlier. Then, depending on the API level of the device, you create a notification
    channel and get its ID or set an empty ID.
  prefs: []
  type: TYPE_NORMAL
- en: You pass `pendingIntent` and `channelId` to the function that constructs a `NotificationCompat.Builder`
    and start the service as a Foreground Service, providing it with `NOTIFICATION_ID`
    and a notification built using the builder. The function returns `NotificationCompat.Builder`,
    to be used later to update the notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define two fields in your service—one to hold a reusable `NotificationCompat.Builder`
    class, and another to hold a reference to `Handler`, which you will later use
    to post work in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, override `onCreate()` to start the service as a foreground service and
    keep a reference of the `Notification.Builder`, and create `serviceHandler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that to create the `Handler` instance, you must first initialize and start
    `HandlerThread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a call that tracks your deployed SCA as it approaches its designated
    destination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will first obtain a reference to the `NotificationManager`. Then, it will
    count down from `10` to `0`, sleeping for 1 second between updates and then updating
    the notification with the remaining time. Note we set the notification to be silent.
    This avoids the notification playing a sound every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function to notify observers of completion on the main thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By posting on a handler using the main `Looper`, you make sure that updates
    occur on the main (UI) app thread. When setting the value to the agent ID, you
    are notifying all observers that that agent ID has reached its destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override `onStartCommand(Intent?, Int, Int)` like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You first delegate the call to `super`, which internally calls `onStart()` and
    returns a backward-compatible state you could return. You store this returned
    value. Next, you obtain the SCA ID from the extras passed via the `Intent`. This
    service will not work without an agent ID, so you throw an exception if one is
    not provided.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you switch to the background thread defined in `onCreate` to track the
    agent to its destination in a blocking way. When tracking is done, you notify
    observers that the task is complete, stop the foreground service (removing the
    notification by passing `true`), and stop the service itself, as you don’t expect
    to require it again soon. You then return the earlier stored return value from
    `super`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `AndroidManifest.xml` file to request the necessary permissions
    and introduce the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we declare that our app requires the `FOREGROUND_SERVICE` permission.
    Unless we do so, the system will block our app from using foreground services.
    We also request the `POST_NOTIFICATIONS` permission, without which we cannot present
    notifications on SDK 33+. Next, we declare the service. Setting `android:enabled="true"`
    tells the system it can instantiate the service.
  prefs: []
  type: TYPE_NORMAL
- en: The default is `"true"`, so this is optional. Defining the service with `android:exported="true"`
    tells the system that other applications can start the service. In our case, we
    don’t need this extra functionality, but we have added it just so that you are
    aware of this capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to your `MainActivity`. Introduce a function to launch `RouteTrackingService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function first observes the `trackingCompletion` `LiveData` for completion
    updates, showing a result on completion. Then, it defines an `Intent` for launching
    the service, setting the SCA ID as an extra parameter for that `Intent`. It then
    launches the service as a foreground service using `ContextCompat`, which hides
    away compatibility-related logic for you.
  prefs: []
  type: TYPE_NORMAL
- en: Now, extract the logic from `onCreate()` (everything that comes after the `setContentView`
    call) to a private function named `dispatchCat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `dispatchCat` to start tracking the SCA as soon as it is suited up and
    ready to go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new private function called `ensurePermissionGrantedAndDispatchCat`.
    In this function, make sure you have the `POST_NOTIFICATIONS` permission. Request
    it if you don’t. Refer to [*Chapter 7*](B19411_07.xhtml#_idTextAnchor421), *Android
    Permissions and Google Maps*, for the implementation details. If or when you have
    the permission, call `dispatchCat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Launch the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The notification counting down](img/B19411_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The notification counting down
  prefs: []
  type: TYPE_NORMAL
- en: After the notifications informing you of the SCA’s preparation steps, you should
    see a notification in your status bar. That notification should then count down
    from 10 to 0, disappear, and be replaced by a toast informing you that the agent
    arrived at its destination. Seeing that last toast tells you that you managed
    to communicate the SCA ID to the service as well as get it back on completion
    of the background task.
  prefs: []
  type: TYPE_NORMAL
- en: With all the knowledge gained from this chapter, let’s complete the following
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 8.01 – reminder to drink water
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The average human loses about 2,500 **milliliters** (**ml**) of water per day.
    To stay healthy, we need to consume as much water as we lose. However, due to
    the busy nature of modern life, a lot of us forget to stay hydrated regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See [https://packt.link/90nbQ](https://packt.link/90nbQ) for more information
    on this.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you wanted to develop an app that keeps track of your water loss (statistically)
    and gives you a constant update on your fluid balance. Starting from a balanced
    state, the app would gradually decrease the user’s tracked water level. The user
    could tell the app when they drank a glass of water, and it would update the water
    level accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The continuous updating of the water level will leverage your knowledge of running
    a background task, and you will also utilize your knowledge of communicating with
    a service to update a balance in response to user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty activity project and name your app `My` `Water Tracker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the foreground service and post notifications permissions to your `AndriodManifest.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable in your service to track the water level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define constants for a notification ID and for an extra `Intent` data key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the creation of the notification from the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add functions to request the notification permissions (if required), start the
    Foreground Service and update the water level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the water level to decrease by 0.144 ml every 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the addition of fluids from outside the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the service cleans up callbacks and messages when destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the service in the `Manifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the service from `MainActivity` when the activity is created, after the
    notification permission is granted, if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to the main activity layout with a **Drank a Glass of** **Water**
    label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user clicks the button, notify the service that it needs to increment
    the water level by 250 ml.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to execute long-running background tasks using
    `WorkManager` and foreground services. We discussed how to communicate progress
    to the user, and how to get the user back into an app once a task is finished
    executing. All the topics covered in this chapter are quite broad, and you could
    explore communicating with services, building notifications, and using the `WorkManager`
    class further.
  prefs: []
  type: TYPE_NORMAL
- en: For most common scenarios, you now have the tools you need. Common use cases
    include background downloads, the background cleaning up of cached assets, playing
    media while the app is not running in the foreground, and, combined with the knowledge
    we gained from [*Chapter 7*](B19411_07.xhtml#_idTextAnchor421), *Android Permissions
    and Google Maps*, tracking the user’s location over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into making our apps more robust and maintainable
    by writing unit and integration tests. This is particularly helpful when the code
    you write runs in the background, and it is not immediately evident when something
    goes wrong.
  prefs: []
  type: TYPE_NORMAL
