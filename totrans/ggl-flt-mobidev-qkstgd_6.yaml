- en: Using a Platform to Power Flutter Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the use of Flutter, you can build for both Android as well as iOS. It uses
    the Dart programming language to do so. However, Dart does not compile to Android's
    Dalvik bytecode or Objective C bindings on iOS. This indicates that Dart code,
    by default, does not have direct access to platform-specific APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few sets of examples where deeper integration with the host environment
    might be needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications using camera capabilities and geo-tagging features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading device information, such as an OS version and device specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading folders and files from the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing notifications to the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing information with other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location tracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using persisted preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list continues as per the support provided by the environment. Using Flutter,
    enabling the calling of platform-specific APIs, which are available in Java/Kotlin
    code on Android, Objective C, or Swift on iOS, is not a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to include packages, followed by learning
    how to make platform-specific calls. We will learn about how to publish our own
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Flutter packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using platform channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and publishing your own plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Flutter packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flutter's package website lists many packages that help us develop applications
    faster by avoiding the need for developing some features from scratch. These packages
    are either contributed to by the Flutter team or by developers across the globe
    who contribute to the Flutter and Dart ecosystems. You can either use the existing packages
    by visiting the publishing site ([https://pub.dartlang.org/](https://pub.dartlang.org/)[https://pub.dartlang.org/](https://pub.dartlang.org/)),
    or you can develop and publish your own packages. We will learn about building
    our own packages in the *Building your own packages* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for the package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit the publishing site to search for the packages you want to use in your
    app. The home page displays some of the popular packages that are used by developers.
    You can search by keyword to display the results. You may want to look at the
    weighted score before you opt to choose a plugin. Searching for either `email:@dartlang.org`
    or `email:flutter-dev@googlegroups.com` will give the results of the official
    Flutter packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a066a6e-6a1e-4f4d-b340-f7329bddc936.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on any of the result items will open the extended preview for the
    package. In this case, we are using the url_launcher package, which is an official
    Dart package that was developed by the Flutter team. This plugin is used for launching
    a URL on a mobile platform such as Android and iOS-supporting web, phone, SMS,
    and email schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22b672b7-c6e0-4aa6-a533-67688df7d9a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on any of the packages, you will see the name of the plugin,
    along with its latest version and its published date. Following that, you will
    find five tab options, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md`: Detailed information about the plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHANGELOG.md`: Information on the Changelog versions of this plugin with details
    of each plugin version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Example`: Demonstrates how to use the plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Installing`: Shows the steps to follow to set up the plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Versions`: Shows the different versions of the plugin, along with the following
    options: `Version` name ( such as 5.0.1*),* `Uploaded` date (such as Feb 8, 2019),
    `Documentation`, and `Archive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flutter plugin for launching a URL on Android and iOS supports web, phone,
    SMS, and email schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a package dependency to an app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have decided on the package you want to use, you have to make the
    program depend on it. In this case, we are using the `url_launcher 5.0.1` package:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `pubspec.yaml` file located inside your `app` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check out the Installing tab on the package''s page, and where you will have
    the option of adding dependencies. In this example, we are adding `url_launcher:
    ^5.0.1` under dependencies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, from the Terminal, run the following command, which will install packages
    from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using an editor such as Android Studio/IntelliJ, click Packages
    get on the top of `pubspec.yaml`. In the case of VS code, click **Get Packages** at
    the top of `Pubspec**.**yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ac349c1-8717-4282-9fe6-4b3a9b49545a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to add the correspondent `import` snippet to your Dart code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you want to upgrade to a new version of the package, use the Packages upgrade
    option. It could be used in the case where there are new features available in
    that package you wish to include in the project. In the case of IntelliJ, the
    option to choose is Upgrade dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to specify package dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to specify package dependencies. As we discussed earlier, the
    package is added to `pubspec.yaml` using the shorthand form `plugin1:`. This means
    **`plugin1:any_version`. **As a developer, you can always look at `CHANGELOG.md`
    or the recent version of the package''s name to add the correct value. To ensure
    an app does not break, it is essential to specify a version, which can be done
    in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify the version using range constraints, as follows, in which you specify
    the minimum and maximum versions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Range constraints using `Carat Syntax`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding the code to the file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the packages give insights on how to include the package components
    into the code. The package''s Example tab has more information about the code''s
    execution. In our example, we are using one gradient button to open the URL specified
    in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code allows users to simply click on the button and open the Flutter
    Dev official website. As you may have noticed, we use the `RaisedButton` widget
    and specify the child property, which allows us to provide gradient to the button.
    The `_initiateURL()` method has a launch function that accepts the URL defined
    and acts to parse the specified URL. It also delegates the handling to the underlying
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce0f917b-a2bf-4812-a7c9-06356f3c1b63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have successfully executed the code and clicked on the button, Open
    Flutter Website will open the URL specified in the parameter URL. You will see
    the result on the screen on the phone''s default browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b254ffb-7c7c-449f-b205-8ee9dc8d353a.png)'
  prefs: []
  type: TYPE_IMG
- en: Using platform channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the start of the chapter, Flutter is a cross-platform framework,
    and in order to get access to native APIs, you have to get access to native platform
    functions. In the case of Flutter, it does this by creating a platform channel
    to the native platform. Using these platform channels, the developers can call
    the native functions such as device information, files and folder access, sensor
    access, camera, shared preferences, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, platform channels can be simply imagined
    to be a communicating mechanism between your Dart code in Flutter and the platform-specific
    code of your host app. This ensures that the host services are invoked by Flutter''s
    Dart code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8590f163-d1d7-428e-9d6a-6915d4b8edcc.png)'
  prefs: []
  type: TYPE_IMG
- en: At this point, it is worth noting that you have to set a platform channel for
    each platform. In the case of Android, they are called `MethodChannels` and in
    iOS, they are known as `FlutterMethodChannels`**. **
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is important to know the platform data type support and codecs.
    The standard platform channels adopt a standard message codec that supports efficient
    binary serialization. They are JSON-lookalike. When you send values to and from
    them, the serialization and deserialization happen automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flutter team at Google has listed (source: [https://flutter.dev/docs/development/platform-integration/platform-channels](https://flutter.dev/docs/development/platform-integration/platform-channels))
    the following table, which shows how Dart values are received on the host platform
    side, and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dart** | **Android** | **                                           iOS**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `null` |                       `nil` (NSNull when nested) |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `java.lang.Boolean` | `NSNumber numberWithBool:` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `java.lang.Integer` | `NSNumber numberWithInt:` |'
  prefs: []
  type: TYPE_TB
- en: '| `int`, `if 32 bits`, `not enough` | `java.lang.Long` | `NSNumber numberWithLong:`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `java.lang.Double` | `NSNumber numberWithDouble:` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `java.lang.String` | `NSString` |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint8List` | `byte[]` | `FlutterStandardTypedData typedDataWithBytes:` |'
  prefs: []
  type: TYPE_TB
- en: '| `Int32List` | `int[]` | `FlutterStandardTypedData typedDataWithInt32:` |'
  prefs: []
  type: TYPE_TB
- en: '| `Int64List` | `long[]` | `FlutterStandardTypedData typedDataWithInt64:` |'
  prefs: []
  type: TYPE_TB
- en: '| `Float64List` | `double[]` | `FlutterStandardTypedData typedDataWithFloat64:`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | `java.util.ArrayList` | `NSArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` | `java.util.HashMap` | `NSDictionary` |'
  prefs: []
  type: TYPE_TB
- en: In the following example, we will learn how to use platform channel in Android
    to calculate the battery percentage of an Android phone using the Android `BatteryManager`
    API**.** You canread more about the API here: [https://developer.android.com/reference/android/os/BatteryManager](https://developer.android.com/reference/android/os/BatteryManager)
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Flutter project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please create a new Flutter project. Ensure that the Android SDK path has been
    set up properly and included in the project settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Flutter platform client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For understanding the battery level, Android code be written and then passed
    on to the Dart code. The applications' state class holds the current state of
    the app, and we need to extend it to ensure the current battery state is captured.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we will use `MethodChannel` as the channel comprising of a
    single platform method that will return the battery level of the Android phone.
    The client and the host side communicate by a unique channel name passed in the
    channel constructor. In our case, we have named it `call.flutter.io/battery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to invoke a method on the method channel, and we will use
    the returned result (the battery level) to update the value inside `setState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, replace the build method to have a `Button` to have the action, `onPressed`**, **of
    which the result of the battery level would be shown as a `Text` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `Main.Dart` code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will make changes to the Android code.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to MainActivity.Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigate to the Android folder inside your project, and locate the `MainActivity.java`
    file in the Java folder in the project view. Next, inside the `onCreate` method
    in this file, we create a `MethodChannel` and a set a `MethodCallHandler` inside.
    Note that the channel name used should be the same on the Flutter client side,
    as in our case: `call.flutter.io/battery`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `String` to hold the channel name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, add the `MethodChannel` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we have to write the Android `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To use `BatteryManager`, the minimum API is 21, and hence we use `VERSION_CODES.LOLLIPOP`**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final step is to complete the `onMethodCall` method added earlier. Using
    a single platform method, `getbatteryLevel`**, **you can simply call the Android
    code written in the previous step, and revert back the response, both in success
    as well as error cases using the response argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the complete Android code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the code successfully, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66fd0f98-e554-41e4-82c4-ba4f2d31335d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When clicking on the button, the Battery Level of the phone will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6825914f-1ef9-4a0c-b04c-387782731345.png)'
  prefs: []
  type: TYPE_IMG
- en: Building and publishing your own plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plugins play an important role in the Flutter ecosystem. Google developers
    and open source contributors have contributed to several published plugins. We
    have seen in the [Chapter 5](c29724b0-6438-41da-9d91-64881a6be71e.xhtml), *Widening
    our Flutter Horizons*, show to include the plugins in the code. When building
    a plugin, here are some of the tips to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Check for existing plugin availability**: See whether there are existing
    plugins available that function the same/similar way, before you code from fresh.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Think Dart**:Since Flutter code is written in Dart, it''s ideal if the major
    logic is crafted in Dart, which not only makes it easy to navigate but also processing
    the code is easier, across the platform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Avoid a building platform-specific plugin that is only supports**: The developer
    might be tempted to start building a plugin including every feature they might
    desire, but thinking solo-platform might not be such a good idea. Not only will
    it confuse the users about its use cases on a specific platform, it will also
    make the app behave in an unexpected way.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Avoid building platform-specific API methods**:As a developer, you might
    be tempted to build a platform-specific method, but this can go into overkill.
    Try including the platform-specific logic to the plugin itself.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build for features**:Ensure that the plugin you are planning to build has
    a specific use case providing features, rather than just calling existing APIs.
    There is nothing wrong with using an existing native library, but the problem
    arises when these APIs don''t work as expected across different platforms. Focusing
    on features more than on API could help you build better plugins.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Detail out the features and installation properly**:When your plugin is published,
    support the community by giving out more details about the plugin''s features
    and how they seamlessly include this plugin into their code. The visibility of
    the plugin matters, as if the community loves the plugin, they will rate the plugin
    higher, thus increasing the visibility. Use examples so that there are no problems
    regarding including your plugin.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To publish your own plugin, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no errors in the execution, you can execute the following command
    to publish the plugin and your plugin will be live in a few minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of the chapter, we learned how to include packages in the Flutter
    code, followed by how to include platform-specific channels to support Flutter
    code. We also used the `BatteryManager` API to understand the battery state of
    the Android phone. In the last section, we covered some of the best tips to consider
    you build your our own plugin, followed by how to publish your own plugin.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how to use **Firebase** with Flutter.
  prefs: []
  type: TYPE_NORMAL
