- en: Using a Platform to Power Flutter Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台为Flutter应用提供动力
- en: With the use of Flutter, you can build for both Android as well as iOS. It uses
    the Dart programming language to do so. However, Dart does not compile to Android's
    Dalvik bytecode or Objective C bindings on iOS. This indicates that Dart code,
    by default, does not have direct access to platform-specific APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flutter，您可以同时为Android和iOS构建应用。它使用Dart编程语言来完成这一任务。然而，Dart不会编译成Android的Dalvik字节码或iOS上的Objective
    C绑定。这表明Dart代码默认情况下没有直接访问平台特定API的能力。
- en: 'Here are a few sets of examples where deeper integration with the host environment
    might be needed:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几组示例中，可能需要与宿主环境进行更深入的集成：
- en: Applications using camera capabilities and geo-tagging features
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相机功能和地理标记功能的应用
- en: Reading device information, such as an OS version and device specifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取设备信息，例如操作系统版本和设备规格
- en: Reading folders and files from the device
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备读取文件夹和文件
- en: Pushing notifications to the app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用推送通知
- en: Sharing information with other applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他应用共享信息
- en: Location tracking
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置跟踪
- en: Using sensors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传感器
- en: Using persisted preferences
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用持久化首选项
- en: The list continues as per the support provided by the environment. Using Flutter,
    enabling the calling of platform-specific APIs, which are available in Java/Kotlin
    code on Android, Objective C, or Swift on iOS, is not a difficult task.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据环境提供的支持，列表将继续。使用Flutter，启用调用平台特定API的功能，这些API在Android上的Java/Kotlin代码、iOS上的Objective
    C或Swift中可用，并不是一个困难的任务。
- en: In this chapter, we will learn how to include packages, followed by learning
    how to make platform-specific calls. We will learn about how to publish our own
    plugins.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何包含包，然后学习如何进行平台特定的调用。我们将学习如何发布我们自己的插件。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: Using Flutter packages
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flutter包
- en: Using platform channels
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台通道
- en: Building and publishing your own plugin
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和发布您自己的插件
- en: Using Flutter packages
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flutter包
- en: Flutter's package website lists many packages that help us develop applications
    faster by avoiding the need for developing some features from scratch. These packages
    are either contributed to by the Flutter team or by developers across the globe
    who contribute to the Flutter and Dart ecosystems. You can either use the existing packages
    by visiting the publishing site ([https://pub.dartlang.org/](https://pub.dartlang.org/)[https://pub.dartlang.org/](https://pub.dartlang.org/)),
    or you can develop and publish your own packages. We will learn about building
    our own packages in the *Building your own packages* section of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter的包网站列出了许多帮助我们快速开发应用的包，这些包避免了从头开始开发某些功能的需求。这些包要么是由Flutter团队贡献的，要么是由全球的开发者贡献给Flutter和Dart生态系统的。您可以通过访问发布网站（[https://pub.dartlang.org/](https://pub.dartlang.org/)）使用现有的包，或者您可以开发和发布自己的包。我们将在本章的“构建自己的包”部分学习如何构建自己的包。
- en: Searching for the package
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索包
- en: 'Visit the publishing site to search for the packages you want to use in your
    app. The home page displays some of the popular packages that are used by developers.
    You can search by keyword to display the results. You may want to look at the
    weighted score before you opt to choose a plugin. Searching for either `email:@dartlang.org`
    or `email:flutter-dev@googlegroups.com` will give the results of the official
    Flutter packages:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 访问发布网站以搜索您在应用中想要使用的包。主页显示了一些开发者使用的流行包。您可以通过关键词搜索来显示结果。在选择插件之前，您可能想查看加权分数。搜索`email:@dartlang.org`或`email:flutter-dev@googlegroups.com`将给出官方Flutter包的结果：
- en: '![](img/4a066a6e-6a1e-4f4d-b340-f7329bddc936.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a066a6e-6a1e-4f4d-b340-f7329bddc936.png)'
- en: 'Clicking on any of the result items will open the extended preview for the
    package. In this case, we are using the url_launcher package, which is an official
    Dart package that was developed by the Flutter team. This plugin is used for launching
    a URL on a mobile platform such as Android and iOS-supporting web, phone, SMS,
    and email schemes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何结果项将打开包的扩展预览。在这种情况下，我们使用的是url_launcher包，这是一个由Flutter团队开发的官方Dart包。此插件用于在移动平台上启动URL，如支持Android和iOS的Web、电话、短信和电子邮件方案：
- en: '![](img/22b672b7-c6e0-4aa6-a533-67688df7d9a5.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22b672b7-c6e0-4aa6-a533-67688df7d9a5.png)'
- en: 'When you click on any of the packages, you will see the name of the plugin,
    along with its latest version and its published date. Following that, you will
    find five tab options, namely the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击任何一个包时，你会看到插件的名称，以及它的最新版本和发布日期。随后，你会找到五个标签选项，具体如下：
- en: '`README.md`: Detailed information about the plugin'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：关于插件的详细信息'
- en: '`CHANGELOG.md`: Information on the Changelog versions of this plugin with details
    of each plugin version'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANGELOG.md`：关于此插件Changelog版本的信息，包括每个插件的详细信息'
- en: '`Example`: Demonstrates how to use the plugin'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Example`：演示如何使用插件'
- en: '`Installing`: Shows the steps to follow to set up the plugin'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`安装`：显示设置插件的步骤'
- en: '`Versions`: Shows the different versions of the plugin, along with the following
    options: `Version` name ( such as 5.0.1*),* `Uploaded` date (such as Feb 8, 2019),
    `Documentation`, and `Archive`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`版本`：显示插件的各个版本，以及以下选项：`版本`名称（例如5.0.1*），* `上传`日期（例如2019年2月8日），`文档`，和`存档`'
- en: The Flutter plugin for launching a URL on Android and iOS supports web, phone,
    SMS, and email schemes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter插件支持在Android和iOS上启动URL，包括web、手机、SMS和电子邮件方案。
- en: Adding a package dependency to an app
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将包依赖添加到应用程序中
- en: 'Once you have decided on the package you want to use, you have to make the
    program depend on it. In this case, we are using the `url_launcher 5.0.1` package:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定了想要使用的包，你必须让程序依赖于它。在这种情况下，我们使用的是`url_launcher 5.0.1`包：
- en: Open the `pubspec.yaml` file located inside your `app` folder.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于你的`app`文件夹内的`pubspec.yaml`文件。
- en: 'Check out the Installing tab on the package''s page, and where you will have
    the option of adding dependencies. In this example, we are adding `url_launcher:
    ^5.0.1` under dependencies.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '查看包页面上的“安装”标签，你将有机会添加依赖项。在这个例子中，我们在依赖项下添加了`url_launcher: ^5.0.1`。'
- en: 'Next, from the Terminal, run the following command, which will install packages
    from the command line:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从终端运行以下命令，这将通过命令行安装包：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using an editor such as Android Studio/IntelliJ, click Packages
    get on the top of `pubspec.yaml`. In the case of VS code, click **Get Packages** at
    the top of `Pubspec**.**yaml`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Android Studio/IntelliJ这样的编辑器，请点击`pubspec.yaml`顶部的“包获取”。在VS code的情况下，请点击`Pubspec**.**yaml`顶部的“**获取包**”：
- en: '![](img/6ac349c1-8717-4282-9fe6-4b3a9b49545a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ac349c1-8717-4282-9fe6-4b3a9b49545a.png)'
- en: 'The next step is to add the correspondent `import` snippet to your Dart code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将相应的`import`片段添加到你的Dart代码中：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you want to upgrade to a new version of the package, use the Packages upgrade
    option. It could be used in the case where there are new features available in
    that package you wish to include in the project. In the case of IntelliJ, the
    option to choose is Upgrade dependencies.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要升级到包的新版本，请使用“包升级”选项。在包中有新功能可用且你希望将其包含到项目中时，可以使用此选项。在IntelliJ中，可以选择“升级依赖项”。
- en: Ways to specify package dependencies
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定包依赖的方式
- en: 'There are two ways to specify package dependencies. As we discussed earlier, the
    package is added to `pubspec.yaml` using the shorthand form `plugin1:`. This means
    **`plugin1:any_version`. **As a developer, you can always look at `CHANGELOG.md`
    or the recent version of the package''s name to add the correct value. To ensure
    an app does not break, it is essential to specify a version, which can be done
    in one of two ways:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 指定包依赖有两种方式。正如我们之前讨论的，包是通过使用缩写形式`plugin1:`添加到`pubspec.yaml`中的。这意味着**`plugin1:any_version`**。作为一个开发者，你总是可以查看`CHANGELOG.md`或包的最近版本来添加正确的值。为了确保应用程序不会崩溃，指定一个版本是至关重要的，这可以通过两种方式之一来完成：
- en: 'Specify the version using range constraints, as follows, in which you specify
    the minimum and maximum versions:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用范围约束指定版本，如下所示，其中你指定最小和最大版本：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Range constraints using `Carat Syntax`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“Carat Syntax”进行范围约束：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding the code to the file
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码添加到文件中
- en: 'Most of the packages give insights on how to include the package components
    into the code. The package''s Example tab has more information about the code''s
    execution. In our example, we are using one gradient button to open the URL specified
    in the code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数包都提供了如何将包组件包含到代码中的见解。包的“示例”标签提供了关于代码执行的更多信息。在我们的例子中，我们使用一个梯度按钮来打开代码中指定的URL：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous code allows users to simply click on the button and open the Flutter
    Dev official website. As you may have noticed, we use the `RaisedButton` widget
    and specify the child property, which allows us to provide gradient to the button.
    The `_initiateURL()` method has a launch function that accepts the URL defined
    and acts to parse the specified URL. It also delegates the handling to the underlying
    system:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码允许用户简单地点击按钮并打开Flutter Dev官方网站。如您所注意到的，我们使用了`RaisedButton`小部件并指定了子属性，这使得我们能够为按钮提供渐变效果。`_initiateURL()`方法有一个启动函数，它接受定义的URL并解析指定的URL。它还将处理委托给底层系统：
- en: '![](img/ce0f917b-a2bf-4812-a7c9-06356f3c1b63.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce0f917b-a2bf-4812-a7c9-06356f3c1b63.png)'
- en: 'Once you have successfully executed the code and clicked on the button, Open
    Flutter Website will open the URL specified in the parameter URL. You will see
    the result on the screen on the phone''s default browser, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功执行了代码并点击了按钮， 打开Flutter网站 将打开参数中指定的URL。您将在手机的默认浏览器上看到结果，如下所示：
- en: '![](img/6b254ffb-7c7c-449f-b205-8ee9dc8d353a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b254ffb-7c7c-449f-b205-8ee9dc8d353a.png)'
- en: Using platform channels
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台通道
- en: As mentioned at the start of the chapter, Flutter is a cross-platform framework,
    and in order to get access to native APIs, you have to get access to native platform
    functions. In the case of Flutter, it does this by creating a platform channel
    to the native platform. Using these platform channels, the developers can call
    the native functions such as device information, files and folder access, sensor
    access, camera, shared preferences, and much more.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，Flutter是一个跨平台框架，为了访问原生API，您必须访问原生平台函数。在Flutter的情况下，它是通过创建到原生平台的平台通道来实现的。使用这些平台通道，开发者可以调用诸如设备信息、文件和文件夹访问、传感器访问、摄像头、共享首选项等原生函数。
- en: 'As shown in the following screenshot, platform channels can be simply imagined
    to be a communicating mechanism between your Dart code in Flutter and the platform-specific
    code of your host app. This ensures that the host services are invoked by Flutter''s
    Dart code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，平台通道可以简单地想象成Flutter中的Dart代码和宿主应用特定平台代码之间的通信机制。这确保了宿主服务可以通过Flutter的Dart代码被调用：
- en: '![](img/8590f163-d1d7-428e-9d6a-6915d4b8edcc.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8590f163-d1d7-428e-9d6a-6915d4b8edcc.png)'
- en: At this point, it is worth noting that you have to set a platform channel for
    each platform. In the case of Android, they are called `MethodChannels` and in
    iOS, they are known as `FlutterMethodChannels`**. **
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得注意的是，您必须为每个平台设置一个平台通道。在Android的情况下，它们被称为`MethodChannels`，而在iOS中，它们被称为`FlutterMethodChannels`**。 **
- en: At this point, it is important to know the platform data type support and codecs.
    The standard platform channels adopt a standard message codec that supports efficient
    binary serialization. They are JSON-lookalike. When you send values to and from
    them, the serialization and deserialization happen automatically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，了解平台数据类型支持和编解码器非常重要。标准平台通道采用支持高效二进制序列化的标准消息编解码器。它们看起来像JSON。当您向它们发送和接收值时，序列化和反序列化会自动发生。
- en: 'The Flutter team at Google has listed (source: [https://flutter.dev/docs/development/platform-integration/platform-channels](https://flutter.dev/docs/development/platform-integration/platform-channels))
    the following table, which shows how Dart values are received on the host platform
    side, and vice versa:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Google的Flutter团队列出了以下表格（来源：[https://flutter.dev/docs/development/platform-integration/platform-channels](https://flutter.dev/docs/development/platform-integration/platform-channels)），展示了Dart值在宿主平台侧的接收方式，反之亦然：
- en: '| **Dart** | **Android** | **                                           iOS**
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **Dart** | **Android** | **                                           iOS**
    |'
- en: '| `null` | `null` |                       `nil` (NSNull when nested) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `null` |                       `nil`（嵌套时为NSNull）|'
- en: '| `bool` | `java.lang.Boolean` | `NSNumber numberWithBool:` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `java.lang.Boolean` | `NSNumber numberWithBool:` |'
- en: '| `int` | `java.lang.Integer` | `NSNumber numberWithInt:` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `java.lang.Integer` | `NSNumber numberWithInt:` |'
- en: '| `int`, `if 32 bits`, `not enough` | `java.lang.Long` | `NSNumber numberWithLong:`
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `int`，`if 32 bits`，`not enough` | `java.lang.Long` | `NSNumber numberWithLong:`
    |'
- en: '| `double` | `java.lang.Double` | `NSNumber numberWithDouble:` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `java.lang.Double` | `NSNumber numberWithDouble:` |'
- en: '| `String` | `java.lang.String` | `NSString` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `java.lang.String` | `NSString` |'
- en: '| `Uint8List` | `byte[]` | `FlutterStandardTypedData typedDataWithBytes:` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8List` | `byte[]` | `FlutterStandardTypedData typedDataWithBytes:` |'
- en: '| `Int32List` | `int[]` | `FlutterStandardTypedData typedDataWithInt32:` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Int32List` | `int[]` | `FlutterStandardTypedData typedDataWithInt32:` |'
- en: '| `Int64List` | `long[]` | `FlutterStandardTypedData typedDataWithInt64:` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Int64List` | `long[]` | `FlutterStandardTypedData typedDataWithInt64:` |'
- en: '| `Float64List` | `double[]` | `FlutterStandardTypedData typedDataWithFloat64:`
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `Float64List` | `double[]` | `FlutterStandardTypedData typedDataWithFloat64:`
    |'
- en: '| `List` | `java.util.ArrayList` | `NSArray` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `List` | `java.util.ArrayList` | `NSArray` |'
- en: '| `Map` | `java.util.HashMap` | `NSDictionary` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | `java.util.HashMap` | `NSDictionary` |'
- en: In the following example, we will learn how to use platform channel in Android
    to calculate the battery percentage of an Android phone using the Android `BatteryManager`
    API**.** You canread more about the API here: [https://developer.android.com/reference/android/os/BatteryManager](https://developer.android.com/reference/android/os/BatteryManager)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将学习如何在 Android 中使用平台通道来计算 Android 手机的电池百分比，使用 Android 的 `BatteryManager`
    API。您可以在以下链接中了解更多关于 API 的信息：[https://developer.android.com/reference/android/os/BatteryManager](https://developer.android.com/reference/android/os/BatteryManager)
- en: Creating a new Flutter project
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 Flutter 项目
- en: Please create a new Flutter project. Ensure that the Android SDK path has been
    set up properly and included in the project settings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请创建一个新的 Flutter 项目。确保 Android SDK 路径已正确设置并包含在项目设置中。
- en: Creating a Flutter platform client
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Flutter 平台客户端
- en: For understanding the battery level, Android code be written and then passed
    on to the Dart code. The applications' state class holds the current state of
    the app, and we need to extend it to ensure the current battery state is captured.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解电池级别，可以编写 Android 代码并将其传递到 Dart 代码。应用程序的状态类持有应用程序的当前状态，我们需要扩展它以确保捕获当前的电池状态。
- en: 'For this reason, we will use `MethodChannel` as the channel comprising of a
    single platform method that will return the battery level of the Android phone.
    The client and the host side communicate by a unique channel name passed in the
    channel constructor. In our case, we have named it `call.flutter.io/battery`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用 `MethodChannel` 作为包含单个平台方法的通道，该方法将返回 Android 手机的电池级别。客户端和主机端通过传递给通道构造函数的唯一通道名称进行通信。在我们的案例中，我们将其命名为
    `call.flutter.io/battery`：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to invoke a method on the method channel, and we will use
    the returned result (the battery level) to update the value inside `setState`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是调用方法通道上的方法，我们将使用返回的结果（电池级别）来更新 `setState` 内的值：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, replace the build method to have a `Button` to have the action, `onPressed`**, **of
    which the result of the battery level would be shown as a `Text` value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将构建方法替换为具有动作 `onPressed` 的 `Button`，其结果将作为 `Text` 值显示电池级别。
- en: 'The complete `Main.Dart` code is shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `Main.Dart` 代码如下所示：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we will make changes to the Android code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对 Android 代码进行修改。
- en: Making changes to MainActivity.Java
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 `MainActivity.java` 文件
- en: Navigate to the Android folder inside your project, and locate the `MainActivity.java`
    file in the Java folder in the project view. Next, inside the `onCreate` method
    in this file, we create a `MethodChannel` and a set a `MethodCallHandler` inside.
    Note that the channel name used should be the same on the Flutter client side,
    as in our case: `call.flutter.io/battery`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到项目中的 Android 文件夹，并在项目视图中找到 Java 文件夹中的 `MainActivity.java` 文件。接下来，在这个文件中的
    `onCreate` 方法内，我们创建一个 `MethodChannel` 并在其中设置一个 `MethodCallHandler`。请注意，使用的通道名称应与
    Flutter 客户端侧相同，正如我们的案例：`call.flutter.io/battery`。
- en: 'Include the following imports:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 包含以下导入：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, create a `String` to hold the channel name:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `String` 来保存通道名称：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And, finally, add the `MethodChannel` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `MethodChannel` 方法：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the next step, we have to write the Android `onCreate` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们必须编写 Android 的 `onCreate` 方法：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To use `BatteryManager`, the minimum API is 21, and hence we use `VERSION_CODES.LOLLIPOP`**.**
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `BatteryManager`，最低 API 级别为 21，因此我们使用 `VERSION_CODES.LOLLIPOP`。
- en: 'Our final step is to complete the `onMethodCall` method added earlier. Using
    a single platform method, `getbatteryLevel`**, **you can simply call the Android
    code written in the previous step, and revert back the response, both in success
    as well as error cases using the response argument, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是完成之前添加的 `onMethodCall` 方法。使用单个平台方法 `getbatteryLevel`，您可以简单地调用之前步骤中编写的
    Android 代码，并使用响应参数在成功和错误情况下返回响应，如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the complete Android code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为完整的 Android 代码：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After running the code successfully, you will see the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行成功后，您将看到以下输出：
- en: '![](img/66fd0f98-e554-41e4-82c4-ba4f2d31335d.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66fd0f98-e554-41e4-82c4-ba4f2d31335d.png)'
- en: 'When clicking on the button, the Battery Level of the phone will be displayed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时，手机的电池电量将被显示：
- en: '![](img/6825914f-1ef9-4a0c-b04c-387782731345.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6825914f-1ef9-4a0c-b04c-387782731345.png)'
- en: Building and publishing your own plugin
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和发布你自己的插件
- en: 'Plugins play an important role in the Flutter ecosystem. Google developers
    and open source contributors have contributed to several published plugins. We
    have seen in the [Chapter 5](c29724b0-6438-41da-9d91-64881a6be71e.xhtml), *Widening
    our Flutter Horizons*, show to include the plugins in the code. When building
    a plugin, here are some of the tips to keep in mind:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 插件在 Flutter 生态系统中扮演着重要的角色。谷歌开发者和开源贡献者已经为几个发布的插件做出了贡献。我们在 [第 5 章](c29724b0-6438-41da-9d91-64881a6be71e.xhtml)，*拓宽我们的
    Flutter 视野*中，展示了如何在代码中包含插件。当构建插件时，以下是一些需要记住的技巧：
- en: '**Check for existing plugin availability**: See whether there are existing
    plugins available that function the same/similar way, before you code from fresh.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查现有插件的可用性**：在你从头开始编码之前，查看是否有现有的插件以相同或类似的方式工作。'
- en: '**Think Dart**:Since Flutter code is written in Dart, it''s ideal if the major
    logic is crafted in Dart, which not only makes it easy to navigate but also processing
    the code is easier, across the platform.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**考虑 Dart**：由于 Flutter 代码是用 Dart 编写的，因此如果主要的逻辑是用 Dart 编写的，这将是非常理想的，这不仅使得导航变得容易，而且跨平台处理代码也更加容易。'
- en: '**Avoid a building platform-specific plugin that is only supports**: The developer
    might be tempted to start building a plugin including every feature they might
    desire, but thinking solo-platform might not be such a good idea. Not only will
    it confuse the users about its use cases on a specific platform, it will also
    make the app behave in an unexpected way.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**避免构建仅支持特定平台的插件**：开发者可能会被诱惑开始构建一个包含他们可能需要的所有功能的插件，但只考虑单一平台可能不是一个好主意。这不仅会让用户对其在特定平台上的用例感到困惑，还可能导致应用以意想不到的方式运行。'
- en: '**Avoid building platform-specific API methods**:As a developer, you might
    be tempted to build a platform-specific method, but this can go into overkill.
    Try including the platform-specific logic to the plugin itself.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**避免构建特定平台的 API 方法**：作为开发者，你可能会被诱惑构建一个特定平台的函数，但这可能会导致过度设计。尝试将特定平台的逻辑包含在插件本身中。'
- en: '**Build for features**:Ensure that the plugin you are planning to build has
    a specific use case providing features, rather than just calling existing APIs.
    There is nothing wrong with using an existing native library, but the problem
    arises when these APIs don''t work as expected across different platforms. Focusing
    on features more than on API could help you build better plugins.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为功能而构建**：确保你计划构建的插件具有特定的用例，提供功能，而不仅仅是调用现有的 API。使用现有的本地库没有问题，但问题在于这些 API 在不同平台之间可能无法按预期工作。更多地关注功能而不是
    API 可能有助于你构建更好的插件。'
- en: '**Detail out the features and installation properly**:When your plugin is published,
    support the community by giving out more details about the plugin''s features
    and how they seamlessly include this plugin into their code. The visibility of
    the plugin matters, as if the community loves the plugin, they will rate the plugin
    higher, thus increasing the visibility. Use examples so that there are no problems
    regarding including your plugin.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详细说明功能和安装**：当你的插件发布时，通过提供更多关于插件功能和如何无缝将其包含在他们的代码中的详细信息来支持社区。插件的可视性很重要，因为如果社区喜欢这个插件，他们会对插件进行更高的评分，从而增加其可见性。使用示例，以确保在包含你的插件时没有问题。'
- en: 'To publish your own plugin, use the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布你自己的插件，请使用以下命令：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If there are no errors in the execution, you can execute the following command
    to publish the plugin and your plugin will be live in a few minutes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行过程中没有错误，你可以执行以下命令来发布插件，你的插件将在几分钟内上线：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the start of the chapter, we learned how to include packages in the Flutter
    code, followed by how to include platform-specific channels to support Flutter
    code. We also used the `BatteryManager` API to understand the battery state of
    the Android phone. In the last section, we covered some of the best tips to consider
    you build your our own plugin, followed by how to publish your own plugin.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们学习了如何在 Flutter 代码中包含包，接着是如何包含特定平台的通道以支持 Flutter 代码。我们还使用了 `BatteryManager`
    API 来了解安卓手机的电池状态。在最后一节中，我们介绍了一些构建你自己的插件时应该考虑的最佳技巧，随后是发布你自己的插件的方法。
- en: In the next chapter, we will take a look at how to use **Firebase** with Flutter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 **Firebase** 与 Flutter 结合。
