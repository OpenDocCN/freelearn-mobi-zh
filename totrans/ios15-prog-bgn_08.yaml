- en: '*Chapter 7*: Classes, Structures, and Enumerations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you've learned how to group instruction sequences together
    using functions and closures.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to think about how to represent complex objects in your code. For
    example, think about a car. You could use a `String` constant to store a car name
    and a `Double` variable to store a car price, but they are not associated with
    one another. You've seen that you can group instructions together to make functions
    and closures. In this chapter, you'll learn how to group constants and variables
    together in a single entity using **classes** and **structures**, and how to manipulate
    them. You'll also learn how to use **enumerations** to group a set of related
    values together.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have learned how to create and initialize
    a class, create a subclass from an existing class, create and initialize a structure,
    differentiate between classes and structures, and create an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Xcode playground for this chapter is in the `Chapter07` folder of the code
    bundle for this book, which can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition](https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3HbRJTA](https://bit.ly/3HbRJTA)'
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to start from scratch, create a new playground and name it `Classes,StructuresAndEnumerations`.
    You can type in and run all of the code in this chapter as you go along. Let's
    start with learning what a class is, and how to declare and define it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes are useful for representing complex objects, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual employee information for a company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items for sale at an e-commerce site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items you have in your house for insurance purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s what a class declaration and definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Every class has a descriptive name, and it contains variables or constants used
    to represent an object. Variables or constants associated with a class are called
    **properties**.
  prefs: []
  type: TYPE_NORMAL
- en: A class can also contain functions that perform specific tasks. Functions associated
    with a class are called **methods**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have declared and defined a class, you can create `Animal` class, you
    can use instances of that class to represent different animal types at the zoo.
    Each of these instances will have different values for their properties.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about classes, visit: [https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to work with classes. You'll learn how to declare and define
    classes, create instances based on the class declaration, and manipulate those
    instances. You'll start by creating a class declaration to represent animals in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s declare and define a class that can store details about animals. Add
    the following code to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You've just declared a very simple class named `Animal`. Convention dictates
    that class names start with a capital letter. This class has properties to store
    the name of the animal, the sound it makes, the number of legs it has, and whether
    it breathes oxygen or not. This class also has a method, `makeSound()`, that prints
    the noise it makes to the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an `Animal` class, let's use it to create an instance of an
    animal in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making an instance of the class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have declared and defined a class, you can create instances of that
    class. You will now create an instance of the `Animal` class that represents a
    cat. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an instance of the `Animal` class, list all its properties and call
    its `makeSound()` method, type the following after your class declaration and
    run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You access instance properties and methods by typing a dot after the instance
    name, followed by the property or method you want. You'll see the values for the
    instance properties and method calls listed in the Debug area. Since the values
    are the default values assigned when the class was created, `name` and `sound`
    contain empty strings, `numberOfLegs` contains `0`, `breathesOxygen` contains
    `true`, and the `makeSound()` method prints an empty string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s assign some values to this instance''s properties. Modify your code
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An initializer is responsible for ensuring all of the instance properties have
    valid values when a class is created. Let''s add an initializer for the `Animal`
    class. Modify your class definition as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You''ll see some errors in your code at this point. You will need to update
    your function call to address this. Modify your code as shown and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The results are the same as those in *Step 2*, but you created the instance
    and set its properties in a single instruction. Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: Now there are different types of animals, such as mammals, birds, reptiles,
    and fish. You could create a class for each type, but you could also create a
    **subclass** based on an existing class. Let's see how to do that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Making a subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A subclass of a class inherits all of the methods and properties of an existing
    class. You can also add additional properties and methods to it if you wish. You''ll
    now create `Mammal`, a subclass of the `Animal` class. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare the `Mammal` class, type in the following code just after the `Animal`
    class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typing `: Animal` after the class name makes the `Mammal` class a subclass
    of the `Animal` class. It has all the properties and methods declared in the `Animal`
    class, and one additional property, `hasFurOrHair`. Since the `Animal` class is
    the parent of the `Mammal` class, you can refer to it as the `Mammal` class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your code that creates an instance of your class as shown, and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type in the following code after all other code in your playground to display
    the contents of the `hasFurOrHair` property and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the initializer for the `Animal` class does not have a parameter to assign
    a value to `hasFurOrHair`, the default value is used, and `true` will be displayed
    in the Debug area.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have seen that a subclass can have additional properties. A subclass can
    also have additional methods, and method implementation in a subclass can differ
    from the superclass implementation. Let's see how to do that in the next section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overriding a superclass method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, you''ve been using multiple `print()` statements to display the values
    of the class instance. You''ll implement a `description()` method to display all
    of the instance properties in the Debug area, so multiple `print()` statements
    will no longer be required. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `Animal` class declaration to implement a `description()` method,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify your code as shown to use the `description()` method in place of the
    multiple `print()` statements, and run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can change the implementation of the `description()` method in the `Mammal`
    class to display the `hasFurOrHair` property''s value. Add the following code
    to your `Mammal` class definition and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'name: Cat sound: Mew numberOfLegs: 4 breathesOxygen: true hasFurOrHair: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mew
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `hasFurOrHair` property's value is displayed in the Debug area, showing
    that you are using the `Mammal` subclass implementation of the `description()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You've created class and subclass declarations and made instances of both. You've
    also added initializers and methods to both. Cool! Let's look at how to declare
    and use structures in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like classes, structures also group together properties and methods used to
    represent an object and do specific tasks. Remember the `Animal` class you created?
    You can also use a structure to accomplish the same thing. There are differences
    between classes and structures though, and you will learn more about those later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what a structure declaration and definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a structure is very similar to a class. It also has a descriptive
    name, can contain properties and methods, and you can create instances.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about structures, visit: [https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to work with structures. You'll learn how to declare and define
    structures, create instances based on the structure, and manipulate them. You'll
    start by creating a structure to represent reptiles in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a structure declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with the animal theme, let''s declare and define a structure that
    can store details of reptiles. Add the following code after all other code in
    your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is almost the same as the `Animal` class declaration you
    did earlier. Structure names also normally start with a capital letter, and this
    structure has properties to store the name of the animal, the sound it makes,
    how many legs it has, whether it breathes oxygen, and whether it has fur or hair.
    This structure also has a method, `makeSound()`, that prints the sound it makes
    to the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a `Reptile` structure declaration, let's use it to create
    an instance representing a snake in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making an instance of the structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with classes, you can create instances from a structure declaration. You
    will now create an instance of the `Reptile` structure that represents a snake,
    print out the property values of that instance, and call the `makeSound()` method.
    Type the following after your structure declaration and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you did not need to implement an initializer; structures automatically
    get an initializer for all of their properties, called the **memberwise** initializer.
    Neat! The following will be displayed in the Debug area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the structure declaration is very similar to the class declaration,
    there are two differences between a class and a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Structures cannot inherit from another structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are **reference types**, while structures are **value types**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the difference between value types and reference types in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing value types and reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes are reference types. This means when you assign a class instance to
    a variable, you are actually storing the memory location of the original instance
    in the variable, instead of the instance itself.
  prefs: []
  type: TYPE_NORMAL
- en: Structures are value types. This means when you assign a structure instance
    to a variable, that instance is copied, and whatever changes you make to the original
    instance do not affect the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will create an instance of a class and a structure and observe the
    differences between them. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll start by creating a variable containing a structure instance and assigning
    it to a second variable, then change the value of a property in the second variable.
    Type in the following code and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, you declared a structure, `SampleValueType`, that contains
    one property, `sampleProperty`. Then, you created an instance of that structure
    and assigned it to a variable, `a`. After that, you assigned `a` to a new variable,
    `b`. Next, you changed the `sampleProperty` value of `b` to `20`. When you print
    out the `sampleProperty` value of `a`, `10` is printed in the Debug area, showing
    that any changes made to the `sampleProperty` value of `b` do not affect the `sampleProperty`
    value of `a`. This is because when you assigned `a` to `b`, a copy of `a` was
    assigned to `b`, so they are completely separate instances that don't affect one
    another.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, you''ll create a variable containing a class instance and assign it to
    a second variable, then change the value of a property in the second variable.
    Type in the following code and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, you declared a class, `SampleReferenceType`, that contains
    one property, `sampleProperty`. Then, you created an instance of that class and
    assigned it to a variable, `c`. After that, you assigned `c` to a new variable,
    `d`. Next, you changed the `sampleProperty` value of `d` to `20`. When you print
    out the `sampleProperty` value of `c`, `20` is printed in the Debug area, showing
    that any changes made to `c` or `d` are affecting the same `SampleReferenceType`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the question is, which should you use, classes or structures? Let's explore
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between classes and structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've seen that you can use either a class or a structure to represent a complex
    object. So, which should you use?
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to use structures unless you need something that requires
    classes, such as subclasses. This actually helps to prevent some subtle errors
    that may occur due to classes being reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic! Now that you have learned about classes and structures, let's take
    a look at **enumerations**, which allow you to group related values together,
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enumerations allow you to group related values together, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Compass directions (E, W, N, and S)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic light colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The colors of a rainbow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand why enumerations would be ideal for this purpose, let's consider
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you''re programming a traffic light. You can use an integer variable
    to represent different traffic light colors where `0` is red, `1` is yellow and
    `2` is green, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although this is a possible way to represent a traffic light, what happens when
    you assign `3` to `trafficLightColor`? This will cause problems as `3` does not
    represent a valid traffic light color. So, it would be better if you could limit
    the possible values of `trafficLightColor` to the colors it can display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what an enumeration declaration looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Every enumeration has a descriptive name, and the body contains the associated
    values for that enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about enumerations, visit [https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html](https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to work with enumerations. You'll learn how to create and
    manipulate them. You'll start by creating one to represent a traffic light color
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create an enumeration to represent a traffic light. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates an enumeration named `TrafficLightColor`, which groups together
    the red, yellow, and green values. As you can see, the value for the `trafficLightColor`
    variable is limited to red, yellow, and green; setting any other value will generate
    an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Just like classes and structures, enumerations can contain methods. Let''s
    add a method to `TrafficLightColor`. Modify your code as shown to make `TrafficLightColor`
    return a string representing the traffic light color and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `description()` method returns a string depending on `trafficLightColor`'s
    value. Since `trafficLightColor`'s value is `TrafficLightColor.red`, `red` will
    appear in the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: You've learned how to create and use enumerations to store grouped values, and
    how to add methods to them. This concludes this chapter. Good job!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to declare complex objects using a class, create
    instances of a class, create a subclass, and override a class method. You've also
    learned how to declare a structure, create instances of a structure, and understand
    the difference between reference and value types. Finally, you learned how to
    use enumerations to represent a specific set of values.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to use classes and structures to represent complex objects,
    and how to use enumerations to group related values together in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will study how to specify common traits in classes
    and structures using protocols, extend the capability of built-in classes using
    extensions, and handle errors in your programs.
  prefs: []
  type: TYPE_NORMAL
