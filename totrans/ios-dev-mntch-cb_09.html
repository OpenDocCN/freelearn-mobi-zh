<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Interacting with Device Hardware</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detecting device orientation</li><li class="listitem" style="list-style-type: disc">Adjusting UI orientation</li><li class="listitem" style="list-style-type: disc">Proximity sensor</li><li class="listitem" style="list-style-type: disc">Retrieving battery information</li><li class="listitem" style="list-style-type: disc">Handling motion events</li><li class="listitem" style="list-style-type: disc">Handling touch events</li><li class="listitem" style="list-style-type: disc">Recognizing gestures</li><li class="listitem" style="list-style-type: disc">Custom gestures</li><li class="listitem" style="list-style-type: disc">Using the accelerometer</li><li class="listitem" style="list-style-type: disc">Using the gyroscope</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec01"/>Introduction</h1></div></div></div><p>Today's mobile devices are equipped with very advanced hardware. Be it accelerometers to detect motion and orientation, proximity sensors, GPS modules, and among many other components, quite sophisticated multi-touch screens.</p><p>In this chapter, we will be focusing on how to use this hardware within our applications to provide the user with an experience that extends into the 3D world. Specifically, we will discuss how to adjust the user interface orientation according to the position of the device, how to use the proximity sensor, and read battery information. In a series of four tasks, we will learn how to capture user touches on the screen and recognize gestures.</p><p>Last but not least, we will create advanced applications that read the raw data from the accelerometer and gyroscope sensors to detect device motion and rotation, with detailed and simple guides.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec02"/>Detecting device orientation</h1></div></div></div><p>In this recipe, we will learn how to make an application that is aware of device orientation changes.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec01"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> DeviceOrientationApp</code>.<a id="id691" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a label on the view of<code class="literal"> MainController</code>. Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private NSObject orientationObserver;
public override void ViewDidLoad (){
base.ViewDidLoad ();
UIDevice.CurrentDevice. BeginGeneratingDeviceOrientationNotifications();
this.orientationObserver = NSNotificationCenter.DefaultCenter. AddObserver(UIDevice.OrientationDidChangeNotification, delegate {
this.lblOrientation.Text = UIDevice.CurrentDevice.Orientation.ToString();
} );
}
public override void ViewDidUnload (){
base.ViewDidUnload ();
NSNotificationCenter.DefaultCenter. RemoveObserver(this.orientationObserver);
UIDevice.CurrentDevice. EndGeneratingDeviceOrientationNotifications();
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Rotate the simulator by holding the<strong> Command</strong> key on your Mac and pressing the left or right arrow keys.</li></ol></div><div><img src="img/1468EXP_09_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec03"/>How it works...</h2></div></div></div><p>Although the simulator lacks accelerometer hardware, it supports notifications for orientation changes.<a id="id692" class="indexterm"/>
</p><p>The device orientation notification mechanism can be accessed through the<code class="literal"> UIDevice.CurrentDevice</code> singleton object. To receive notifications, we first need to instruct the runtime to issue them. We do this with the following method:</p><div><pre class="programlisting">UIDevice.CurrentDevice. BeginGeneratingDeviceOrientationNotifications();
</pre></div><p>This method turns the accelerometer on and starts generating orientation notifications. We then need to start observing for the notifications, in order to respond to changes:</p><div><pre class="programlisting">this.orientationObserver = NSNotificationCenter.DefaultCenter. AddObserver(UIDevice.OrientationDidChangeNotification, delegate {
this.lblOrientation.Text = UIDevice.CurrentDevice.Orientation.ToString();
} );
</pre></div><p>Each time the device orientation changes, the observer triggers the anonymous method. In it, we output the orientation, which we get from the<code class="literal"> Orientation</code> property, to the label.</p><p>The<code class="literal"> ViewDidUnload</code> method is the method that is being called when the view controller unloads its view. Inside it, we make sure to remove the orientation observer, and we instruct the runtime to stop generating orientation notifications:<a id="id693" class="indexterm"/>
</p><div><pre class="programlisting">NSNotificationCenter.DefaultCenter. RemoveObserver(this.orientationObserver);
UIDevice.CurrentDevice.EndGeneratingDeviceOrientationNotifications();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec04"/>There's more...</h2></div></div></div><p>The<code class="literal"> Orientation</code> property returns an enumeration of the type<code class="literal"> UIDeviceOrientation</code>. Its values are the following:<a id="id694" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Unknown:</code> This value specifies that the device orientation is unknown</li><li class="listitem" style="list-style-type: disc"><code class="literal">Portrait:</code> This value specifies that the device is in its normal portrait orientation, with the<strong> home</strong> button on the bottom side</li><li class="listitem" style="list-style-type: disc"><code class="literal">PortraitUpsideDown:</code> This value specifies that the device is in upside-down portrait orientation, with the<strong> home</strong> button on the top side</li><li class="listitem" style="list-style-type: disc"><code class="literal">LandscapeLeft:</code> This value specifies that the device is in landscape orientation, with the<strong> home</strong> button on the left side</li><li class="listitem" style="list-style-type: disc"><code class="literal">LandscapeRight:</code> This value specifies that the device is in landscape orientation, with the<strong> home</strong> button on the right side</li><li class="listitem" style="list-style-type: disc"><code class="literal">FaceUp:</code> This value specifies that the device is parallel to the ground, with the screen facing up</li><li class="listitem" style="list-style-type: disc"><code class="literal">FaceDown:</code> This value specifies that the device is parallel to the ground, with the screen facing down<a id="id695" class="indexterm"/></li></ul></div><p>
<code class="literal">FaceUp</code> and<code class="literal"> FaceDown</code> are two values that cannot be reproduced on the simulator.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec01"/>Device orientation and user interface orientation</h3></div></div></div><p>What can be clearly noticed in this example is that there is a difference between a device's orientation and that of the user interface. If the device is rotated, the label gets updated with the new orientation value, but the user interface does not respond to changes. In the next recipe, we will discuss how to rotate the user interface.<a id="id696" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec05"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adjusting UI orientation</em></li><li class="listitem" style="list-style-type: disc"><em>Using the accelerometer</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec03"/>Adjusting UI orientation</h1></div></div></div><p>In this recipe, we will learn how to rotate the<strong> User Interface (UI)</strong> according to the screen orientation.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec06"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> UIOrientationApp</code>.<a id="id697" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec07"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a label on the view of<code class="literal"> MainController</code>. Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">public override bool ShouldAutorotateToInterfaceOrientation ( UIInterfaceOrientation toInterfaceOrientation){
return true;
}
public override void DidRotate ( UIInterfaceOrientation fromInterfaceOrientation){
base.DidRotate (fromInterfaceOrientation);
this.lblOutput.Text = this.InterfaceOrientation.ToString();
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Use<em> Command</em> + arrow keys to rotate the simulator. The<strong> LandscapeRight</strong> orientation is shown in the following image:</li></ol></div><div><img src="img/1468EXP_09_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec08"/>How it works...</h2></div></div></div><p>To make our UI adjust to device orientations, all we need to do is override the view controller's<code class="literal"> ShouldAutorotateToInterfaceOrientation</code> method:<a id="id698" class="indexterm"/>
</p><div><pre class="programlisting">public override bool ShouldAutorotateToInterfaceOrientation ( UIInterfaceOrientation toInterfaceOrientation)
</pre></div><p>When the view controller loads, it checks the outcome of the method for each of the available orientations. The first time it receives<code class="literal"> true</code> from it, it will automatically rotate the interface to that orientation. After loading, whenever the device rotates, the same process gets repeated.</p><p>The parameter of the method is an enumeration of the type<code class="literal"> UIInterfaceOrientation</code>, and each time the method gets called, it contains the value of the orientation the interface checks for.</p><p>The<code class="literal"> DidRotate</code> method is called after the interface orientation completes. We use the<code class="literal"> UIViewController.InterfaceOrientation</code> property, which holds the information on the view controller's current orientation, to update the label:<a id="id699" class="indexterm"/>
</p><div><pre class="programlisting">this.lblOutput.Text = this.InterfaceOrientation.ToString();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec09"/>There's more...</h2></div></div></div><p>Returning<code class="literal"> true</code> from the<code class="literal"> ShouldAutorotateToInterfaceOrientation</code> method means that the interface will rotate on all device orientations. In most cases, this is not necessary and should even be avoided, depending on our application design. To make our interface rotate to landscape orientations only, the method should be implemented as follows:</p><div><pre class="programlisting">public override bool ShouldAutorotateToInterfaceOrientation ( UIInterfaceOrientation toInterfaceOrientation){
return toInterfaceOrientation == UIInterfaceOrientation.LandscapeLeft || toInterfaceOrientation == UIInterfaceOrientation.LandscapeRight;
}
</pre></div><p>Note that this implementation will force the UI to load at landscape mode.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec02"/>User interface orientation on the simulator</h3></div></div></div><p>If you implement the<code class="literal"> ShouldAutorotateToInterfaceOrientation</code> method to only support landscape orientations, then the controller that loads the simulator "device" will also rotate at landscape orientation. However, this is for convenience only, since if you check the<code class="literal"> UIDevice.CurrentDevice.Orientation</code> property, its value will be<code class="literal"> UIDeviceOrientation.Portrait</code>.<a id="id700" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec10"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Detecting device orientation</em></li><li class="listitem" style="list-style-type: disc"><em>Using the accelerometer</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec04"/>Proximity sensor</h1></div></div></div><p>In this recipe, we will discuss using the proximity sensor to disable the device screen.<a id="id701" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec11"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> ProximitySensorApp</code>.</p><div><h3 class="title"><a id="note42"/>Note</h3><p>The simulator does not support the proximity sensor.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec12"/>How to do it...</h2></div></div></div><p>For this task, no controls are needed, besides the<code class="literal"> MainController</code> itself.<a id="id702" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Declare an<code class="literal"> NSObject</code> field that will hold the notification observer:<div><pre class="programlisting">private NSObject proximityObserver;
</pre></div></li><li class="listitem"> Enter the following code in the<code class="literal"> ViewDidLoad</code> override:<div><pre class="programlisting">UIDevice.CurrentDevice.ProximityMonitoringEnabled = true;
if (UIDevice.CurrentDevice.ProximityMonitoringEnabled){
this.proximityObserver = NSNotificationCenter.DefaultCenter. AddObserver(UIDevice.ProximityStateDidChangeNotification, delegate(NSNotification ntf) {
Console.WriteLine("Proximity state: {0}", UIDevice.CurrentDevice.ProximityState);
} );
}
</pre></div></li><li class="listitem"> Finally, enter the following code in the<code class="literal"> ViewDidUnload</code> override:<div><pre class="programlisting">if (UIDevice.CurrentDevice.ProximityMonitoringEnabled){
NSNotificationCenter.DefaultCenter. RemoveObserver(this.proximityObserver);
UIDevice.CurrentDevice.ProximityMonitoringEnabled = false;
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Put your finger over the proximity sensor, or just hold it next to your ear as you would do when on a call. Watch the<strong> Application Output</strong> pad in MonoDevelop display the state of the sensor.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec13"/>How it works...</h2></div></div></div><p>Although the functionality of the proximity sensor is quite simple, it provides a very important feature. iOS devices have only one button on the front, which is the<strong> home</strong> button. Almost every user-device interaction is based on the touch-sensitive screen. This poses a problem on the iPhone: apart from its multiple features, it is also a phone. This means that it will most likely spend some time on the side of the user's face for making calls.</p><p>To avoid accidental virtual buttons being tapped, the proximity sensor gets activated when the phone application is running, to disable the screen when the device is near the user's ear, or whatever is over the sensor.</p><p>To enable the proximity sensor, set the property of the<code class="literal"> UIDevice.CurrentDevice.ProximityMonitoringEnabled</code> to<code class="literal"> true:</code>
</p><div><pre class="programlisting">UIDevice.CurrentDevice.ProximityMonitoringEnabled = true;
</pre></div><p>If the device does not support the proximity sensor, this property will return<code class="literal"> false</code>, even after it has been set to<code class="literal"> true</code>. So, after setting it to<code class="literal"> true</code>, we can check it to see if the device supports the sensor:</p><div><pre class="programlisting">if (UIDevice.CurrentDevice.ProximityMonitoringEnabled)
</pre></div><p>After checking, we can add an observer for getting notified of the sensor's state with the<code class="literal"> UIDevice.ProximityStateDidChangeNotification</code> key:</p><div><pre class="programlisting">this.proximityObserver = NSNotificationCenter.DefaultCenter. AddObserver(UIDevice.ProximityStateDidChangeNotification, delegate(NSNotification ntf) {
Console.WriteLine("Proximity state: {0}", UIDevice.CurrentDevice.ProximityState);
} );
</pre></div><p>The<code class="literal"> ProximityState</code> property returns<code class="literal"> true</code> if the sensor has turned the screen off and<code class="literal"> false</code> if it has turned it back on.<a id="id703" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec14"/>There's more...</h2></div></div></div><p>The proximity sensor usage is not limited to phone call functionality. For example, if you are developing an application that could do some work while the device is in the user's pocket or purse, enabling the proximity sensor would make sure that no accidental controls are tapped. Or even save battery power, by just turning the screen off.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec03"/>Sensor support</h3></div></div></div><p>Not all devices support a proximity sensor. If you are targeting various iOS devices, consider that the sensor will not be available on all of them.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec15"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Retrieving battery information</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec05"/>Retrieving battery information</h1></div></div></div><p>In this recipe, we will learn how to read the charging states of the device and its battery usage.<a id="id704" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec16"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> BatteryInfoApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec17"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a label on the view of<code class="literal"> MainController</code>. Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private NSObject batteryStateChangeObserver;
public override void ViewDidLoad (){
base.ViewDidLoad ();
UIDevice.CurrentDevice.BatteryMonitoringEnabled = true;
this.batteryStateChangeObserver = NSNotificationCenter. DefaultCenter.AddObserver(UIDevice. BatteryStateDidChangeNotification, delegate (NSNotification ntf) {
this.lblOutput.Text = string.Format("Battery state: {0}", UIDevice.CurrentDevice.BatteryState);
} );
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> After the application loads, disconnect and/or connect the USB cable of the device. Watch the battery state on the label.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec18"/>How it works...</h2></div></div></div><p>We can retrieve battery information through the<code class="literal"> UIDevice</code> class. The first thing we have to do is to enable battery monitoring:</p><div><pre class="programlisting">UIDevice.CurrentDevice.BatteryMonitoringEnabled = true;
</pre></div><p>On the simulator, which does not support battery monitoring, this property will return false, even after we have set it to true.</p><p>We can then add an observer for battery state change notifications through the<code class="literal"> UIDevice.BatteryStateDidChangeNotification</code> key, as indicated in the highlighted code previously. The battery state can be retrieved through the<code class="literal"> BatteryState</code> property:</p><div><pre class="programlisting">this.lblOutput.Text = string.Format("Battery state: {0}", UIDevice.CurrentDevice.BatteryState);
</pre></div><p>Possible values of the<code class="literal"> BatteryState</code> property are:<a id="id705" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Unknown:</code> This value specifies that the battery state cannot be determined, or battery monitoring is disabled</li><li class="listitem" style="list-style-type: disc"><code class="literal">Unplugged:</code> This value specifies that the device is running on battery power</li><li class="listitem" style="list-style-type: disc"><code class="literal">Charging:</code> This value specifies that the device battery is charging, and the USB cable is connected</li><li class="listitem" style="list-style-type: disc"><code class="literal">Full:</code> This value specifies that the device battery is full, and the USB cable is connected<a id="id706" class="indexterm"/></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec19"/>There's more...</h2></div></div></div><p>Apart from the battery state, we can get information on its power level. To do this, we need to add an observer for the<code class="literal"> UIDevice.BatteryLevelDidChangeNotification</code> key:<a id="id707" class="indexterm"/>
</p><div><pre class="programlisting">private NSObject batterLevelChangeObserver;
//...
this.batterLevelChangeObserver = NSNotificationCenter.DefaultCenter .AddObserver(UIDevice.BatteryLevelDidChangeNotification, delegate(NSNotification ntf) {
this.lblOutput.Text = string.Format("Battery level: {0}", UIDevice.CurrentDevice.BatteryLevel);
} );
</pre></div><p>The<code class="literal"> BatteryLevel</code> property returns a float value in the range from<code class="literal"> 0.0</code> (battery empty) to<code class="literal"> 1.0</code> (battery full at 100 percent). If battery monitoring is disabled, it will return a value of<code class="literal"> -1.0</code>.<a id="id708" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec04"/>Disabling battery monitoring</h3></div></div></div><p>Always disable battery monitoring when not needed. The actual monitoring mechanism itself consumes battery power.<a id="id709" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec20"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Proximity sensor</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec06"/>Handling motion events</h1></div></div></div><p>In this recipe, we will learn how to intercept and respond to shake gestures.<a id="id710" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec21"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> MotionEventsApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec22"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a label on the view of<code class="literal"> MainController</code>. Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">public override bool CanBecomeFirstResponder{
get { return true; }
}
public override void ViewDidAppear (bool animated){
base.ViewDidAppear (animated);
this.BecomeFirstResponder();
}
public override void MotionBegan (UIEventSubtype motion, UIEvent evt){
base.MotionBegan (motion, evt);
this.lblOutput.Text = "Motion started!";
}
public override void MotionEnded (UIEventSubtype motion, UIEvent evt){
base.MotionEnded (motion, evt);
this.lblOutput.Text = "Motion ended!";
}
public override void MotionCancelled (UIEventSubtype motion, UIEvent evt){
base.MotionCancelled (motion, evt);
this.lblOutput.Text = "Motion cancelled!";
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Shake the device and watch the output on the label. You can also test this application on the simulator.</li><li class="listitem"> After it loads, click on<strong> Hardware | Shake Gesture</strong> on the menu bar.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec23"/>How it works...</h2></div></div></div><p>By overriding the motion methods of the<code class="literal"> UIViewController</code> class, we can intercept and respond to the motion events sent by the system. Just overriding these methods is not enough, though. For a controller to receive motion events, it needs to be the first responder. To make sure of this, we first override the<code class="literal"> CanBecomeFirstResponder</code> property and return<code class="literal"> true</code> from it:<a id="id711" class="indexterm"/>
</p><div><pre class="programlisting">public override bool CanBecomeFirstResponder{
get { return true; }
}
</pre></div><p>Then, we make sure our controller becomes the first responder when its view has appeared by calling the<code class="literal"> BecomeFirstResponder</code> method in the<code class="literal"> ViewDidAppear</code> override:<a id="id712" class="indexterm"/>
</p><div><pre class="programlisting">public override void ViewDidAppear (bool animated){
base.ViewDidAppear (animated);
this.BecomeFirstResponder();
}
</pre></div><p>The<code class="literal"> ViewDidAppear</code> method gets called after the view has appeared on the screen.<a id="id713" class="indexterm"/>
</p><p>The system determines if a motion is a shake gesture and calls the appropriate methods. We can use the following three methods to override and capture shake gestures:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MotionBegan:</code> This method specifies that shaking motion started<a id="id714" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MotionEnded:</code> This method specifies that shaking motion ended<a id="id715" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MotionCancelled:</code> This method specifies that shaking motion cancelled<a id="id716" class="indexterm"/></li></ul></div><p>When the device starts moving, the<code class="literal"> MotionBegan</code> method is called. If the motion lasts for about a second or less, the<code class="literal"> MotionEnded</code> method is called. If it lasts longer, the system classifies it as not being a shake gesture and calls the<code class="literal"> MotionCancelled</code> method. It is advisable to override all three methods and react accordingly when we want to implement shake gestures in an application.<a id="id717" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec24"/>There's more...</h2></div></div></div><p>Motion events are only sent to objects inheriting the<code class="literal"> UIResponder</code> class. This includes the<code class="literal"> UIView</code> and<code class="literal"> UIViewController</code> classes.<a id="id718" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec05"/>More info motion events</h3></div></div></div><p>The motion event mechanism is fairly simple. It merely detects near-instant device shakes, without providing any information on their direction or rate. To handle motion events based on different characteristics, the accelerometer can be used in combination.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec25"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using the accelerometer</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec07"/>Handling touch events</h1></div></div></div><p>In this recipe, we will learn how to intercept and respond to user touches.<a id="id719" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec26"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> TouchEventsApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec27"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a label on the view of<code class="literal"> MainController</code>, and enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">public override void TouchesMoved (NSSet touches, UIEvent evt){
base.TouchesMoved (touches, evt);
UITouch touch = touches.AnyObject as UITouch;
UIColor currentColor = this.View.BackgroundColor;
float red, green, blue, alpha;
currentColor.GetRGBA(out red, out green, out blue, out alpha);
PointF previousLocation = touch.PreviousLocationInView(this.View);
PointF touchLocation = touch.LocationInView(this.View);
if (previousLocation.X != touchLocation.X){
this.lblOutput.Text = "Changing background color...";
float colorValue = touchLocation.X / this.View.Bounds.Width;
this.View.BackgroundColor = UIColor.FromRGB(colorValue, colorValue, colorValue);
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Click-and-drag sideways with the cursor on the simulator's screen, and watch the view's background color gradually change from white to black. Note that clicking with the cursor on the simulator screen is the equivalent of touching the device's screen with a finger.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec28"/>How it works...</h2></div></div></div><p>To respond to user touches, the object that acts as a touch receiver must have its<code class="literal"> UserInteractionEnabled</code> property set to<code class="literal"> true</code>. Almost every object is enabled for user interaction by default, except for those whose primary usage is not intended for direct user interaction, for example, the<code class="literal"> UILabel</code> and the<code class="literal"> UIImageView</code>. We need to set the<code class="literal"> UserInteractionEnabled</code> to these objects explicitly. Apart from this, the objects that can handle touch events must inherit from the<code class="literal"> UIResponder</code> class. Note that although the<code class="literal"> UIViewController</code> class inherits from<code class="literal"> UIResponder</code> and therefore can capture touch events, it does not have a<code class="literal"> UserInteractionEnabled</code> property, and it is its main property of<code class="literal"> UIView</code> that controls the delivery of touch events. What this means is that if you override the touch methods of a<code class="literal"> UIViewController</code> but its view's<code class="literal"> UserInteractionEnabled</code> property is set to<code class="literal"> false</code>, these methods will not respond to user touches.<a id="id720" class="indexterm"/>
</p><p>The methods responsible for handling the touch events are the following:<a id="id721" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesBegan:</code> This method is called when the user touches the screen<a id="id722" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesMoved:</code> This method is called when the user drags the finger on the screen<a id="id723" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesEnded:</code> This method is called when the user lifts the finger from the screen<a id="id724" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesCancelled:</code> This method is called when the touch event has been cancelled by a system event, for example, when a notification alert is displayed<a id="id725" class="indexterm"/></li></ul></div><p>The full project can be found in the downloaded source code. The<code class="literal"> TouchesMoved</code> method implementation is explained here.</p><p>Every touch method has two parameters. The first parameter is of the type<code class="literal"> NSSet</code> and contains the<code class="literal"> UITouch</code> objects. The<code class="literal"> NSSet</code> class represents a collection of objects, while the<code class="literal"> UITouch</code> class holds the information for each user touch. The second parameter is of the type<code class="literal"> UIEvent</code> and holds the information of the actual event.</p><p>We can retrieve the<code class="literal"> UITouch</code> object related to the actual touch through the<code class="literal"> NSSet.AnyObject</code> return value:</p><div><pre class="programlisting">UITouch touch = touches.AnyObject as UITouch;
</pre></div><p>It returns an object of type<code class="literal"> NSObject</code>, which we convert to a<code class="literal"> UITouch</code>. We can get the previous and current locations of the touch through the following methods:</p><div><pre class="programlisting">PointF previousLocation = touch.PreviousLocationInView(this.View);
PointF touchLocation = touch.LocationInView(this.View);
</pre></div><p>Both of them return a<code class="literal"> PointF struct</code> containing the location of the touch in the receiver's coordinate system. After receiving the location of the touch, we adjust the background color accordingly.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec29"/>There's more...</h2></div></div></div><p>This example is based on single user touches. To enable a view to respond to multiple touches, we have to set its<code class="literal"> MultipleTouchEnabled</code> property to<code class="literal"> true</code>. We can then get all the<code class="literal"> UITouch</code> objects in an array:<a id="id726" class="indexterm"/>
</p><div><pre class="programlisting">UITouch[] allTouches = touches.ToArray&lt;UITouch&gt;();
</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec06"/>Getting the tap count</h3></div></div></div><p>We can determine the number of consecutive user taps through the<code class="literal"> UITouch.TapCount</code> property inside the<code class="literal"> ToucheEnded</code> method.<a id="id727" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec30"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>MotionEvents</em></li><li class="listitem" style="list-style-type: disc"><em>Recognizing gestures</em></li><li class="listitem" style="list-style-type: disc"><em>Custom gestures</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec08"/>Recognizing gestures</h1></div></div></div><p>In this recipe, we will discuss how to recognize touch gestures and respond accordingly.<a id="id728" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec31"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> GestureApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec32"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a label on the view of<code class="literal"> MainController</code>. Enter the following<code class="literal"> using</code> directive in the<code class="literal"> MainController</code> class source file:<div><pre class="programlisting">using MonoTouch.ObjCRuntime;
</pre></div></li><li class="listitem"> Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
UIPinchGestureRecognizer pinchGesture = new UIPinchGestureRecognizer(this, new Selector("PinchHandler:"));
this.View.AddGestureRecognizer(pinchGesture);
}
[Export("PinchHandler:")]
private void PinchHandler(UIGestureRecognizer gesture){
UIPinchGestureRecognizer pinch = gesture as UIPinchGestureRecognizer;
switch (pinch.State)
{
case UIGestureRecognizerState.Began:
this.lblOutput.Text = "Pinch began!";
break;
case UIGestureRecognizerState.Changed:
this.lblOutput.Text = "Pinch changed!";
break;
case UIGestureRecognizerState.Ended:
this.lblOutput.Text = "Pinch ended!";
break;
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Hold down the<strong> Option</strong> key and click-drag with the mouse to perform the equivalent of a pinch on the simulator screen.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec33"/>How it works...</h2></div></div></div><p>Since the iOS 3.2 version was released along with the iPad, Apple introduced the<code class="literal"> UIGestureRecognizer</code> class and its derivatives. The gesture recognizers make use of the multiple touch screens on iOS devices.<strong> Gestures</strong> are basically touch combinations, which can be performed for specific actions.<a id="id729" class="indexterm"/>
</p><p>For example, pinching on a full-screen image in the native<strong> Photos</strong> application will zoom out. The action of pinching is the gesture the user performs, while the gesture recognizer is responsible for recognizing and delivering the gesture event to its receiver.<a id="id730" class="indexterm"/>
</p><p>In this example, we create a<code class="literal"> UIPinchGestureRecognizer</code>, which will recognize pinches performed on the screen. Its instance is created with the following code:</p><div><pre class="programlisting">UIPinchGestureRecognizer pinchGesture = new UIPinchGestureRecognizer(this, new Selector("PinchHandler:"));
</pre></div><p>The constructor that initializes the instance takes two parameters. The first one is of type<code class="literal"> NSObject</code>, and it is the target object that will receive the gesture. In this case, it is the<code class="literal"> MainController</code> instance, which we pass with the<code class="literal"> this</code> keyword. The second parameter is of the type<code class="literal"> Selector</code>, contained in the<code class="literal"> MonoTouch.ObjCRuntime</code> namespace that we added, and it represents the method that will be called when the recognizer receives a gesture. In simple words, a<code class="literal"> Selector</code> in Objective-C is basically a method signature. The string we pass to its constructor represents the Objective-C method that will be called.</p><p>Since we are using C#, we can easily expose a method as an Objective-C<code class="literal"> Selector</code>. We just create the method we want and decorate it with the<code class="literal"> ExportAttribute</code>, making sure the string we pass to it is the same that we have passed to the<code class="literal"> Selector</code> constructor:</p><div><pre class="programlisting">[Export("PinchHandler:")]
private void PinchHandler(UIGestureRecognizer gesture)
</pre></div><p>Inside the method, we read the<code class="literal"> State</code> property of the gesture recognizer object and respond accordingly.<a id="id731" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec34"/>There's more...</h2></div></div></div><p>The state of each gesture recognizer is represented by an enumeration of the type<code class="literal"> UIGestureRecognizerState</code>. Its values are:<a id="id732" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Possible:</code> This value specifies that the gesture has not yet been recognized and is the default value</li><li class="listitem" style="list-style-type: disc"><code class="literal">Began:</code> This value specifies that the gesture has started</li><li class="listitem" style="list-style-type: disc"><code class="literal">Changed:</code> This value specifies that the gesture has changed</li><li class="listitem" style="list-style-type: disc"><code class="literal">Ended:</code> This value specifies that the gesture has ended</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cancelled:</code> This value specifies that the gesture has been cancelled</li><li class="listitem" style="list-style-type: disc"><code class="literal">Failed:</code> This value specifies that the gesture cannot be recognized</li><li class="listitem" style="list-style-type: disc"><code class="literal">Recognized:</code> This value specifies that the gesture has been recognized</li></ul></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec07"/>Advantage of gesture recognizers</h3></div></div></div><p>The advantage of gesture recognizers is that they save developers the time to create their own gesture recognition mechanisms, through the touch events. Furthermore, they are based on the gestures that users are accustomed to using on iOS devices.<a id="id733" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec35"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Touch events</em></li><li class="listitem" style="list-style-type: disc"><em>Custom gestures</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec09"/>Custom gestures</h1></div></div></div><p>In this recipe, we will learn how to create a custom gesture recognizer to create our own gesture.<a id="id734" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec36"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> CustomGestureApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec37"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a label on the view of<code class="literal"> MainController</code>. Create the following nested class in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private class DragLowerLeftGesture : UIGestureRecognizer{
public DragLowerLeftGesture(NSObject target, Selector action) : base(target, action){}
private PointF startLocation;
private RectangleF lowerLeftCornerRect;
public override UIGestureRecognizerState State{
get{
return base.State;
} set{
base.State = value;
}
}
public override void TouchesBegan (NSSet touches, UIEvent evt){
base.TouchesBegan (touches, evt);
UITouch touch = touches.AnyObject as UITouch;
this.startLocation = touch.LocationInView(this.View);
RectangleF viewBounds = this.View.Bounds;
this.lowerLeftCornerRect = new RectangleF(0f, viewBounds.Height - 50f, 50f, 50f);
if (this.lowerLeftCornerRect.Contains(this.startLocation)){
this.State = UIGestureRecognizerState.Failed;
} else{
this.State = UIGestureRecognizerState.Began;
}
}
public override void TouchesMoved (NSSet touches, UIEvent evt){
base.TouchesMoved (touches, evt);
this.State = UIGestureRecognizerState.Changed;
}
public override void TouchesEnded (NSSet touches, UIEvent evt){
base.TouchesEnded (touches, evt);
UITouch touch = touches.AnyObject as UITouch;
PointF touchLocation = touch.LocationInView(this.View);
if (this.lowerLeftCornerRect.Contains(touchLocation)){
this.State = UIGestureRecognizerState.Ended;
} else{
this.State = UIGestureRecognizerState.Failed;
}
}
}
</pre></div></li><li class="listitem"> Use the custom gesture recognizer as shown in the previous recipe.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec38"/>How it works...</h2></div></div></div><p>To create a gesture recognizer, declare a class that inherits from the<code class="literal"> UIGestureRecognizer</code> class. In this example, we are creating a gesture that will be recognized by dragging the finger on the screen towards a<code class="literal"> 50x50</code> point rectangle in the lower-left corner.<a id="id735" class="indexterm"/>
</p><div><pre class="programlisting">private class DragLowerLeftGesture : UIGestureRecognizer
</pre></div><p>The<code class="literal"> UIGestureRecognizer</code> class contains the same touch methods that we use to intercept touches in views. We also have access to the view it was added to through its<code class="literal"> View</code> property. Inside the<code class="literal"> TouchesBegan</code> method, we determine the initial touch location. If it is outside the lower-left portion of the view, we set the<code class="literal"> State</code> property to<code class="literal"> Began</code>. If it is inside the lower-left portion, we set the<code class="literal"> State</code> property to<code class="literal"> Failed</code> so that the selector will not be called.<a id="id736" class="indexterm"/>
</p><p>Inside the<code class="literal"> TouchesEnded</code> method, we consider the gesture as<code class="literal"> Ended</code> if the touch's location was inside the lower-left portion of the view. If it was not, the gesture recognition is considered as<code class="literal"> Failed</code>.<a id="id737" class="indexterm"/>
</p><p>The<code class="literal"> TouchesMoved</code> method is where the<code class="literal"> Changed</code> state will be set. For this simple gesture recognizer that we are creating, no other logic is needed in it.<a id="id738" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec39"/>There's more...</h2></div></div></div><p>This is a simple gesture recognizer that depends on a single touch. With the information provided in the touch methods, we can create more complex gestures that will support multiple touches.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec08"/>Another usage of custom gesture recognizers</h3></div></div></div><p>There are some views that inherit from the<code class="literal"> UIView</code> class, which according to Apple Developer Documentation should not be sub-classed. The<code class="literal"> MKMapView</code> is one of these views, which is used to display maps. This poses a problem if we want to intercept the touch events from these views. Although we could use another view over it and intercept its touch events, it is a bit complex. A more simple approach is to create a simple custom gesture recognizer and add it to the view that we cannot sub-class. This way, we can intercept its touches without having to sub-class it.<a id="id739" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec40"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Recognizing gestures</em></li><li class="listitem" style="list-style-type: disc"><em>Touch events</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec10"/>Using the accelerometer</h1></div></div></div><p>In this recipe, we will learn how to receive accelerometer events to create an application that is aware of device movement.<a id="id740" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec41"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> AccelerometerApp</code>.</p><div><h3 class="title"><a id="note43"/>Note</h3><p>The simulator does not support the accelerometer hardware. The project in this example will work correctly on a device.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec42"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add two buttons and a label on the view of<code class="literal"> MainController</code>.</li><li class="listitem"> Override the<code class="literal"> ViewDidLoad</code> method, and implement it with the following code:<div><pre class="programlisting">this.buttonStop.Enabled = false;
UIAccelerometer.SharedAccelerometer.UpdateInterval = 1 / 10;
this.buttonStart.TouchUpInside += delegate {
this.buttonStart.Enabled = false;
UIAccelerometer.SharedAccelerometer.Acceleration += this.Acceleration_Received;
this.buttonStop.Enabled = true;
} ;
this.buttonStop.TouchUpInside += delegate {
this.buttonStop.Enabled = false;
UIAccelerometer.SharedAccelerometer.Acceleration -= this.Acceleration_Received;
this.buttonStart.Enabled = true;
} ;
</pre></div></li><li class="listitem"> Add the following method in the class:<div><pre class="programlisting">private void Acceleration_Received (object sender, UIAccelerometerEventArgs e){
this.lblOutput.Text = string.Format("X: {0}\nY: {1}\nZ: {2}", e.Acceleration.X, e.Acceleration.Y, e.Acceleration.Z);
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.<a id="id741" class="indexterm"/></li><li class="listitem"> Tap the<strong> Start accelerometer</strong> button, and watch the values display on the label while moving or shaking the device.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec43"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIAccelerometer</code> class provides access to the accelerometer hardware through its<code class="literal"> SharedAccelerometer</code> static property. To activate it, all we need to do is to assign a handler to its<code class="literal"> Acceleration</code> event:<a id="id742" class="indexterm"/>
</p><div><pre class="programlisting">UIAccelerometer.SharedAccelerometer.Acceleration += this.Acceleration_Received;
</pre></div><p>Inside the handler, we receive the accelerometer values through the<code class="literal"> UIAccelerometerEventArgs.Acceleration</code> property. The property returns an object of the type<code class="literal"> UIAcceleration</code>, which contains the accelerometer amount in three properties:<code class="literal"> X, Y</code>, and<code class="literal"> Z</code>.</p><p>These properties represent motion in the<code class="literal"> X, Y</code>, and<code class="literal"> Z</code> axes. Consider the following diagram:</p><div><img src="img/1468EXP_09_03.jpg" alt="How it works..."/></div><p>Each of these values measures the amount of gravitational force by which the device moved on each axis. For example, if<code class="literal"> X</code> has a value of<code class="literal"> 1</code>, then the device is moving on the<code class="literal"> X-axis</code> to the right, with an acceleration of<code class="literal"> 1g</code>. If<code class="literal"> X</code> has a value of<code class="literal"> -1</code>, then the device is moving on the<code class="literal"> X-axis</code> to the left, with an acceleration of<code class="literal"> 1g</code>. When the device is placed on a table with its back facing the floor and is not moving, the normal values of the acceleration should be close or equal to the following:<a id="id743" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">X: 0</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Y: 0</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Z: -1</code></li></ul></div><p>Although the device is not moving,<code class="literal"> Z</code> will be<code class="literal"> -1</code>, because the device measures the Earth's gravity.</p><p>We can set the interval by which the accelerometer will issue acceleration events by setting its<code class="literal"> UpdateInterval</code> property:<a id="id744" class="indexterm"/>
</p><div><pre class="programlisting">UIAccelerometer.SharedAccelerometer.UpdateInterval = 1 / 10;
</pre></div><p>It accepts a<code class="literal"> double</code>, which represents the interval by which the accelerometer will issue its acceleration events in seconds. Care must be taken when setting the update interval, because the more events the accelerometer has to issue for a specific period of time, the more battery power it consumes.</p><p>To stop using the accelerometer, all we need to do is to unhook the handler from the<code class="literal"> Acceleration</code> event:</p><div><pre class="programlisting">UIAccelerometer.SharedAccelerometer.Acceleration -= this.Acceleration_Received;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec44"/>There's more...</h2></div></div></div><p>The<code class="literal"> UIAcceleration</code> class contains another useful property, named<code class="literal"> Time</code>. It is a double representing the relative time on which the acceleration event occurred. It is relative to CPU time, and it is not suggested to use this value to calculate the exact timestamp of the event.<a id="id745" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec09"/>Consideration using the accelerometer</h3></div></div></div><p>Although the iPhone's accelerometer is a very accurate and sensitive sensor, it should not be used for precise measurements. Also, the results it produces may vary among different iOS devices, even if those devices are of the same model.<a id="id746" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec45"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using the gyroscope</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec11"/>Using the gyroscope</h1></div></div></div><p>In this recipe, we will learn how to use the built-in gyroscope.<a id="id747" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec46"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> GyroscopeApp</code>.</p><div><h3 class="title"><a id="note44"/>Note</h3><p>The simulator does not support the gyroscope hardware. Also, only newer devices contain a gyroscope. If this application is executed on a device without a gyroscope, or on the simulator, no error will occur, but no data will be displayed.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec47"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add two buttons and a label on the view of<code class="literal"> MainController</code>. Add the namespace<code class="literal"> MonoTouch.CoreMotion</code> in the<code class="literal"> MainController.cs</code> file. Enter the following private field in the class:<div><pre class="programlisting">private CMMotionManager motionManager;
</pre></div></li><li class="listitem"> Override the<code class="literal"> ViewDidLoad</code> method, and implement it with the following code:<div><pre class="programlisting">this.motionManager = new CMMotionManager();
this.motionManager.GyroUpdateInterval = 1 / 10;
this.buttonStart.TouchUpInside += delegate {
this.motionManager.StartGyroUpdates(NSOperationQueue.MainQueue, this.GyroData_Received);
} ;
this.buttonStop.TouchUpInside += delegate {
this.motionManager.StopGyroUpdates();
} ;
</pre></div></li><li class="listitem"> Add the following method:<div><pre class="programlisting">private void GyroData_Received(CMGyroData gyroData, NSError error){
Console.WriteLine("rotation rate x: {0}, y: {1}, z: {2}", gyroData.RotationRate.x, gyroData.RotationRate.y, gyroData.RotationRate.z);
}
</pre></div></li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the<strong> Start gyroscope</strong> button and rotate the device in all axes. Watch the values displayed in the<strong> Application Output</strong>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec48"/>How it works...</h2></div></div></div><p>The gyroscope is a mechanism that measures orientation. Newer iOS devices support gyroscope hardware, along with the accelerometer, to give even more accurate measurements of device motion.<a id="id748" class="indexterm"/>
</p><p>The<code class="literal"> MonoTouch.CoreMotion</code> namespace wraps the objects contained in the native<strong> CoreMotion Framework</strong>. The process of using the gyroscope hardware in-code is similar to the one used for the accelerometer. The first difference is that there is no singleton object for the gyroscope in the<code class="literal"> UIApplication</code> class. So, we need to create an instance of the<code class="literal"> CMMotionManager</code> class:<a id="id749" class="indexterm"/>
</p><div><pre class="programlisting">private CMMotionManager motionManager;
//...
this.motionManager = new CMMotionManager();
</pre></div><p>Just like using the accelerometer, we can set the interval by which we will be receiving gyroscope events, in seconds:</p><div><pre class="programlisting">this.motionManager.GyroUpdateInterval = 1 / 10;
</pre></div><p>To start receiving gyroscope events, we call the object's<code class="literal"> StartGyroUpdates</code> method:</p><div><pre class="programlisting">this.motionManager.StartGyroUpdates(NSOperationQueue.MainQueue, this.GyroData_Received);
</pre></div><p>This method is overloaded; the first overload is parameterless and when called, the values of gyroscopic measurements are set to the<code class="literal"> GyroData</code> property. Using this overload is quite simple and easy, but there no events are triggered, and we have to provide a mechanism for reading the measurements from the property.</p><p>The second overload, which is used in this example, accepts two parameters. The first parameter is the<code class="literal"> NSOperationQueue</code>, on which the updates will occur, and the second parameter is the handler that will be executed when an update occurs.</p><p>The<code class="literal"> NSOperationQueue</code> class represents an iOS mechanism for managing<code class="literal"> NSOperation</code> objects execution. We access the runtime's main operation queue through the static<code class="literal"> NSOperationQueue.MainQueue</code> property. Basically, this way, we instruct the runtime to manage the delivery of the handler in a more effective manner.<a id="id750" class="indexterm"/>
</p><p>The second parameter is a delegate of the type<code class="literal"> CMGyroHandler</code>. Its signature, represented by the method we created, is like the following:</p><div><pre class="programlisting">private void GyroData_Received(CMGyroData gyroData, NSError error)
</pre></div><p>The<code class="literal"> CMGyroData</code> object contains the actual measurement values received from the gyroscope through its<code class="literal"> RotationRate</code> property:<a id="id751" class="indexterm"/>
</p><div><pre class="programlisting">Console.WriteLine("rotation rate x: {0}, y: {1}, z: {2}", gyroData.RotationRate.x, gyroData.RotationRate.y, gyroData.RotationRate.z);
</pre></div><p>The rotation rate is reflected on the<code class="literal"> X, Y</code>, and<code class="literal"> Z</code> axes, represented by the corresponding<code class="literal"> X, Y</code>, and<code class="literal"> Z</code> properties. Each value is the amount of rotation-angle-per-second that occurred on that axis, in radians.</p><p>Although it might seem a bit complicated at first, it is actually simple. For example, a value of<code class="literal"> 0.5</code> in the<code class="literal"> Z-axis</code> means that the device rotated with a rate of<code class="literal"> 0.5</code> radians/sec to the left. A value of<code class="literal"> -0.5</code> in the<code class="literal"> Z-axis</code> means that the device rotated with a rate of<code class="literal"> 0.5</code> radians/sec to the right. The pattern for determining the rotation direction is based on the<em> right-hand rule</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec49"/>There's more...</h2></div></div></div><p>If you want your application to be available only for devices that support the gyroscope, then add the key<code class="literal"> UIRequiredDeviceCapabilities</code> in your project's<code class="literal"> Info.plist</code> file, with the value<code class="literal"> gyroscope</code>. If your application's functionality is based fully on the gyroscope, adding this key must be considered essential to avoid the application being downloaded by users with older devices, ending up with an application that does not work.<a id="id752" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec10"/>Determining gyroscope availability</h3></div></div></div><p>To determine if the device the application is running on supports gyroscope hardware, check the value of the<code class="literal"> GyroAvailable</code> property of the<code class="literal"> CMMotionManager</code> instance.<a id="id753" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec11"/>Converting radians to degrees</h3></div></div></div><p>A radian is an angle measurement unit. To convert an angle measurement from radians to degrees, consider the following method:<a id="id754" class="indexterm"/>
</p><div><pre class="programlisting">public static double RadiansToDegrees (double radians){
return (radians * 180 / Math.PI);
}
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec50"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Using the accelerometer</em></li></ul></div></div></div></body></html>