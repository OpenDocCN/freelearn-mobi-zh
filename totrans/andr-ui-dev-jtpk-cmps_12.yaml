- en: 'Chapter 9: Exploring Interoperability APIs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of this book is to show you how to develop beautiful, fast, and maintainable
    Jetpack Compose apps. The previous chapters helped you get familiar with core
    techniques and principles, as well as important interfaces, classes, packages,
    and—of course—composable functions. The remaining chapters cover topics beyond
    a successful adoption of Android's new declarative user interface toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to look at `AndroidView()`, `AndroidViewBinding()`,
    and `ComposeView` as the interoperability **application programming interfaces**
    (**APIs**) of Jetpack Compose. The main sections are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing Views in a Compose app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between Views and composable functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding composables in View hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start by looking at how to show a traditional View hierarchy in a Compose
    app. Imagine you have written a custom component (which under the hood consists
    of several UI elements), such as an image picker, a color chooser, or a camera
    preview. Instead of rewriting your component with Jetpack Compose, you can save
    your investment by simply reusing it. A lot of third-party libraries are still
    written in Views, so I will show you how to use them in Compose apps.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have embedded a View in a Compose app, you need to share data between
    the View and your composable functions. The *Sharing data between Views and composable
    functions* section explains how to do this with ViewModels.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you may not want to rewrite an app from scratch but migrate it to Jetpack
    Compose gradually, replacing View hierarchies with composable functions step by
    step. The final main section, *Embedding composables in View hierarchies*, discusses
    how to include a Compose hierarchy in existing View-based apps.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is based on the `ZxingDemo` and `InteropDemo` samples. Please refer
    to the *Technical requirements* section of [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App**,* for information about how to install and
    set up Android Studio, and how to get the repository accompanying this book.
  prefs: []
  type: TYPE_NORMAL
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_09](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_09).
  prefs: []
  type: TYPE_NORMAL
- en: Showing Views in a Compose app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you have written a View-based custom component for one of your previous
    apps—for example, an image picker, a color chooser, or a camera preview—or you
    would like to include a third-party library such as *Zebra Crossing* (*ZXing*)
    to scan **Quick Response** (**QR**) codes and barcodes. To incorporate them into
    a Compose app, you need to add the View (or the root of a View hierarchy) to your
    composable functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom components to a Compose app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ZxingDemo` sample, shown in the following screenshot, uses the *ZXing
    Android Embedded* barcode scanner library for Android, which is based on the ZXing
    decoder. It is released under the terms of the Apache License 2.0 and is hosted
    on GitHub ([https://github.com/journeyapps/zxing-android-embedded](https://github.com/journeyapps/zxing-android-embedded)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The ZxingDemo sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_09_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The ZxingDemo sample
  prefs: []
  type: TYPE_NORMAL
- en: 'My example continuously scans for barcodes and QR codes. The decorated barcode
    view is provided by the library. If the scanner engine provides a result, the
    corresponding text is shown as an overlay using `Text()`. To use *ZXing Android
    Embedded*, you need to add an implementation dependency to your module-level `build.gradle`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The scanner accesses the camera and (optionally) the device vibrator. The app
    must request at least `android.permission.WAKE_LOCK` and `android.permission.CAMERA`
    permissions in the manifest, and the `android.permission.CAMERA` permission during
    runtime. My implementation is based on `ActivityResultContracts.RequestPermission`,
    which replaces the traditional approach overriding `onRequestPermissionsResult()`.
    Also, depending on the lifecycle of the activity, the scanner must be paused and
    resumed. For the sake of simplicity, I use a `lateinit` variable named `barcodeView`
    and invoke `barcodeView.pause()` and `barcodeView.resume()` when needed. Please
    refer to the source code of the project for details. Next, I will show you how
    to initialize the scanner library. This involves inflating a layout file (named
    `layout.xml`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The layout consists of only one element, `DecoratedBarcodeView`. It is configured
    to fill all available space. The following code snippet is part of `onCreate()`.
    Please remember that `barcodeView` is accessed in some lifecycle functions such
    as `onPause()`, and therefore is a `lateinit` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, `layout.xml` is inflated and assigned to `root`. Then, `barcodeView`
    is initialized (`initializeFromIntent()`) and configured (by setting a decoder
    factory). Finally, the continuous scanning process is started using `decodeContinuous()`.
    The `callback` lambda expression is invoked every time a new scan result is available.
    The `text` variable is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I am using `MutableLiveData`, because it can easily be observed as state. Before
    I show you how to access it inside a composable function, let''s briefly recap,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have set up and activated the scanner library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it detects a barcode or a QR code, it updates the value of a `MutableLiveData`
    instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined and initialized two `View` instances—`root` and `barcodeView`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, I show you how to access the state obtained from the ViewModel inside
    a composable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the state and `root` are passed to the `ZxingDemo()` composable.
    We display `value` using `Text()`. The `root` parameter is used to include the
    View hierarchy in the Compose UI. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The UI consists of a `Box()` composable with two children, `AndroidView()` and
    `Text()`. `AndroidView()` receives a `factory` block, which just returns `root`
    (the View hierarchy containing the scanner viewfinder). The `Text()` composable
    shows the last scan result.
  prefs: []
  type: TYPE_NORMAL
- en: The `factory` block is called exactly once, to obtain the View to be composed.
    It will always be invoked on the UI thread, so you can set View properties as
    needed. In my example, this is not needed, as all initialization has already been
    done in `onCreate()`. Configuring the barcode scanner should not be done in a
    composable, because preparing the camera and preview is potentially time-consuming.
    Also, parts of the component tree are accessed on the activity level, therefore
    references to children (`barcodeView`) are needed anyway.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I have shown you how to include a View hierarchy in your Compose
    app using `AndroidView()`. This composable function is one of the important pieces
    of the Jetpack Compose interoperability APIs. We used `layoutInflater.inflate()`
    to inflate the component tree and `findViewById()` to access one of its children.
    Modern View-based apps try to avoid `findViewById()` and use *View Binding* instead.
    In the next section, you will learn how to combine View Binding and composable
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Inflating View hierarchies with AndroidViewBinding()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, activities held references to Views in `lateinit` properties,
    if the corresponding components needed to be modified in different functions.
    The *Inflating layout files* section of [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040),
    *Understanding the Declarative Paradigm*, discussed some of the issues with this
    approach and introduced View Binding as a solution. It was adopted by many apps.
    Therefore, if you want to migrate an existing app to Jetpack Compose, you likely
    need to combine View Binding and composable functions. This section explains how
    to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `InteropDemo` sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The InteropDemo sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_09_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – The InteropDemo sample
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InteropDemo` sample consists of two activities. One (`ViewActivity`) integrates
    a composable function in a `View` hierarchy. We will turn to this in the *Embedding
    composables in View hierarchies* section. The second one, `ComposeActivity`, does
    the opposite: it inflates a `View` hierarchy using View Binding and shows the
    component tree inside a `Column()` composable. Let''s take a look here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The root composable is called `ViewIntegrationDemo()`. It receives a ViewModel
    and a lambda expression. The ViewModel is used to share data between the Compose
    and the `View` hierarchies, which I will discuss in the *Sharing data between
    Views and composable functions* section. The lambda expression starts `ViewActivity`
    and passes a value from the ViewModel (`sliderValue`). The code is illustrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Scaffold()` is an important integrational composable function. It structures
    a Compose screen. Besides top and bottom bars, it contains some content—in this
    case, a `Column()` composable with two children, `Slider()` and `AndroidViewBinding()`.
    The slider gets its current value from a ViewModel and propagates changes back
    to it. You will learn more about that in the *Revisiting ViewModels* section.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AndroidViewBinding()` is similar to `AndroidView()`. A `factory` block creates
    a View hierarchy to be composed. `CustomBinding::inflate` inflates the layout
    from the `custom.xml` file represented by `CustomBinding` and returns an instance
    of this type. The class is created and updated during builds. It provides constants
    that reflect the contents of a layout file named `custom.xml`. Here is an abridged
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This `ConstraintLayout` has two children, a `MaterialTextView` and a `MaterialButton`.
    A button click invokes the lambda expression passed to `ViewIntegrationDemo()`.
    The text fields receive the current slider value. This is done in the `update`
    block. The following code belongs below `// Here Views will be updated` inside
    `ViewIntegrationDemo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering where `textView` and `button` are defined, and why they
    can be accessed immediately. The `update` block is invoked right after the layout
    is inflated. It is an extension function of the type whose instance is returned
    by `inflate`—in my example, `CustomBinding`. Because the `custom.xml` are `button`
    and `textView`, there are corresponding variables in `CustomBinding`.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` block is also invoked when a value being used by it (`sliderValueState.value`)
    changes. In the next section, we look at when and where such changes are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between Views and composable functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State is app data that may change over time. Recomposition occurs when state
    being used by a composable changes. To achieve something similar in the traditional
    View world, we need to store data in a way that changes to it can be observed.
    There are many implementations of the *Observable* pattern. The Android Architecture
    Components (and subsequent Jetpack versions) include `LiveData` and `MutableLiveData`.
    Both are frequently used inside ViewModels to store state outside activities.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting ViewModels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I introduced you to ViewModels in the *Surviving configuration changes* section
    of [*Chapter 5*](B17505_05_ePub.xhtml#_idTextAnchor089), *Managing the State of
    Your Composable Functions*, and the *Persisting and retrieving state* section
    of [*Chapter 7*](B17505_07_ePub.xhtml#_idTextAnchor119), *Tips, Tricks, and Best
    Practices*. Before we look at how to use ViewModels to synchronize data between
    Views and composable functions, let''s briefly recap on key techniques, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To create or get an instance of a ViewModel, use the top-level `viewModels()`
    function, which belongs to the `androidx.activity` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To observe `LiveData` instances as compose state, invoke the `observeAsState()`
    extension function on a ViewModel property inside a composable function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To observe `LiveData` instances outside of composable functions, invoke `observe()`.
    This function belongs to `androidx.lifecycle.LiveData`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change a ViewModel property, invoke the corresponding setter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please make sure to add implementation dependencies of `androidx.compose.runtime:runtime-livedata`,
    `androidx.lifecycle:lifecycle-runtime-ktx`, and `androidx.lifecycle:lifecycle-viewmodel-compose`
    in the module-level `build.gradle` file as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have refamiliarized ourselves with key techniques related to ViewModels,
    let''s look at how the synchronization between Views and composable functions
    works. *Synchronization* means that a composable function and code related to
    a View observe the same ViewModel property and may trigger changes on that property.
    Triggering changes is usually done by invoking a setter. For a `Slider()` composable,
    it may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This example also shows the readout inside a composable (`sliderValueState.value`).
    Here is how `sliderValueState` has been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at traditional (non-Compose) code using View Binding. The following
    examples are part of `ViewActivity`, which also belongs to the `InteropDemo` sample.
  prefs: []
  type: TYPE_NORMAL
- en: Combining View Binding and ViewModels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activities taking advantage of View Binding usually have a `lateinit` property
    named `binding`, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`LayoutBinding.inflate()` returns an instance of `LayoutBinding`. `Binding.root`
    represents the root of the component tree. It is passed to `setContentView()`.
    Here is an abridged version of the corresponding layout file (`layout.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`ConstraintLayout` contains a `com.google.android.material.slider.Slider` and
    a `ComposeView` (which is discussed in detail in the following section). The ID
    of the slider is `slider`, so `LayoutBinding` contains an equally named variable.
    We can therefore link the slider to the ViewModel, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The block passed to `observe()` is invoked when the value stored in `sliderValue`
    changes. By updating `binding.slider.value`, we change the position of the slider
    handle, which means we update the slider. The code is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The block passed to `addOnChangeListener()` is invoked when the user drags the
    slider handle. By invoking `setSliderValue()` we update the ViewModel, which in
    turn triggers updates on observers—for example, our composable functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I familiarized you with the steps needed to tie composable
    functions and traditional Views to a ViewModel property. When the property is
    changed, all observers are called, which leads to the update of both the composable
    and View. In the following section, we continue our look at the `InteropDemo`
    sample. This time, I will show you how to embed composables in a View hierarchy.
    This is important if an existing app is to be migrated to Jetpack Compose step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding composables in View hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen, integrating Views in composable functions is simple and straightforward
    using `AndroidView()` and `AndroidViewBinding()`. But what about the other way
    round? Often, you may not want to rewrite an existing (View-based) app from scratch
    but migrate it to Jetpack Compose gradually, replacing View hierarchies with composable
    functions step by step. Depending on the complexity of the activity, it may make
    sense to start with small composables that reflect portions of the UI and incorporate
    them into the remaining layout.
  prefs: []
  type: TYPE_NORMAL
- en: '`Androidx.compose.ui.platform.ComposeView` makes composables available inside
    classic layouts. The class extends `AbstractComposeView`, which has `ViewGroup`
    as its parent. Once the layout that includes the ComposeView has been inflated,
    here is how you configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`setContent()` sets the content for this view. An initial composition will
    occur when the view is attached to a window, or when `createComposition()` is
    called. While `setContent()` is defined in `ComposeView`, `createComposition()`
    belongs to `AbstractComposeView`. It performs the initial composition for this
    view. Typically, you do not need to invoke this function directly.'
  prefs: []
  type: TYPE_NORMAL
- en: '`setViewCompositionStrategy()` configures how to manage the disposal of the
    View''s internal composition. `ViewCompositionStrategy.``DisposeOnDetached FromWindow`
    (the default) means that the composition is disposed whenever the view becomes
    detached from a window. This is preferred for simple scenarios, as in my example.
    If your view is shown inside a fragment or a component with a known `LifecycleOwner`,
    you should use `DisposeOnViewTreeLifecycleDestroyed` or `DisposeOnLifecycleDestroyed`
    instead. These, however, are topics beyond the scope of this book. The following
    line creates state based on the `sliderValue` property of the ViewModel and passes
    the value to `ComposeDemo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This composable also receives a block that launches `ComposeActivity` and passes
    the current slider value to it, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`ComposeDemo()`, as illustrated in the following screenshot, puts a `Box()`
    (which contains a `Text()`) and a `Button()`inside a `Column()`, in order to resemble
    `ViewActivity`. Wrapping `Text()` inside the `Box()`is necessary to vertically
    center the text inside an area with a particular height. A click on the button
    invokes the `onClick` lambda expression. `Text()` just shows the `value` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The InteropDemo sample showing ViewActivity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_09_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The InteropDemo sample showing ViewActivity
  prefs: []
  type: TYPE_NORMAL
- en: 'Before closing out this chapter, let me recap on important steps you need to
    take to include a Compose hierarchy in a layout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `androidx.compose.ui.platform.ComposeView` to the layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide on a `ViewCompositionStrategy`, depending on where the layout is shown
    (activity, fragment, …).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the content using `setContent {}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain a reference to the `ViewModel` by invoking `viewModels()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register listeners to relevant Views and update the `ViewModel` upon changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside composable functions, create state by invoking `observeAsState()` on
    ViewModel properties as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside composables, update the ViewModel by invoking corresponding setters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetpack Compose interoperability APIs allow for seamless two-way integration
    of composable functions and `View` hierarchies. They help you use libraries that
    rely on Views and ease the transition to Compose by making a gradual, fine-grained
    migration possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the interoperability APIs of Jetpack Compose,
    which allow you to mix composable functions and traditional Views. We started
    by incorporating a traditional View hierarchy from a third-party library in a
    Compose app, using `AndroidView()`. As recent apps favor View Binding over the
    direct use of `findViewById()`, I also showed you how to embed layouts in a composable
    with View Binding and `AndroidViewBinding()`. Once you have embedded a `View`
    in a Compose UI, you need to share data between the two worlds. The *Sharing data
    between Views and composable functions* section explained how to achieve this
    with ViewModels. The final main section, *Embedding composables in View hierarchies*,
    discussed how to include a Compose UI in existing apps using `ComposeView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B17505_10_ePub.xhtml#_idTextAnchor159), *Testing and Debugging
    Compose Apps**,* focuses on testing your Compose apps. You will learn how to use
    `ComposeTestRule` and `AndroidComposeTestRule`. Also, I will introduce you to
    the *semantics tree*.'
  prefs: []
  type: TYPE_NORMAL
