<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Failing Faster with Prototypes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Failing Faster with Prototypes</h1></div></div></div><p>This chapter is all about getting a wireframe of the project going so that you can fill in the "meat" of the game later. You'll be getting baseline graphics, menus, and the game's flow structure outlined for testing faster than you can blink. Test sooner, fail faster—this is your new motto as a game developer. Even though it may seem very simple to code, that's our intent: to create the minimum viable product—something tangible and working—as soon as possible in order to get a feel of the overall project. We're going to cover the following in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Why prototype?</li><li class="listitem">Getting a scene up and running</li><li class="listitem">Creating text (labels)</li><li class="listitem">Beginning using sprite sheets with TexturePacker</li><li class="listitem">Creating buttons</li><li class="listitem">Creating menus, scenes, and scene transitions</li><li class="listitem">Creating nodes and units (sprites)</li></ul></div><p>Throughout this book, a complete game will be created from beginning to end, starting with this chapter. Creating an ongoing project will serve two purposes, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Show how each section can fit within a full project and not just as a piece of code all on its own</li><li class="listitem">Visualize the process of an entire project from the beginning to the end without skipping any step</li></ul></div><p>In the files included with this book, you can find the finished project to see what it's going to look and feel like. Also, at the beginning of each chapter, there will be a reference to the version of the project up to that point in the book so that you can follow along with the complete explanation/examples in the book.</p><div class="note" title="Note"><h3 class="title"><a id="tip03"/>Tip</h3><p>At this point, the project is created as a fresh project by following the tutorial in <a class="link" title="Chapter 1. Refreshing Your Cocos2d Knowledge" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Refreshing Our Cocos2d Knowledge</em></span>. If you would rather use a default starting point, you can use the project in the blank <code class="literal">Project</code> folder in the files included with this book.</p><p>You can also download the code from <a class="ulink" href="https://github.com/keitzer/MasteringCocos2d">https://github.com/keitzer/MasteringCocos2d</a>.</p></div><div class="section" title="File suffixes versus directories"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl2sec26"/>File suffixes versus directories</h1></div></div></div><p>When <a id="id83" class="indexterm"/>Cocos2d and SpriteBuilder became integrated in <a id="id84" class="indexterm"/>Cocos2d 3.0, they changed the way textures are read in by Cocos2d. In previous versions, if you wanted to make a game for the iPhone and the iPad, you had to add various suffixes to your file. For example, if your image was named <code class="literal">btnPlay.png</code>, you had to create variously sized files in your project, which were named as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">btnPlay.png</code></li><li class="listitem"><code class="literal">btnPlay-hd.png</code></li><li class="listitem"><code class="literal">btnPlay-ipad.png</code></li><li class="listitem"><code class="literal">btnPlay-ipadhd.png</code></li></ul></div><p>This methodology <a id="id85" class="indexterm"/>of getting your files saved is typically referred to as using <span class="strong"><strong>file suffixes</strong></span>.</p><p>In the newer iteration of Cocos2d with SpriteBuilder, one of the ways you can manage your textures is by dragging a file of the largest possible size (for example, Retina iPad) into SpriteBuilder. When you click on <span class="strong"><strong>Publish</strong></span>, SpriteBuilder will take care of the file size variations for you. This<a id="id86" class="indexterm"/> way of handling files is referred to as using <span class="strong"><strong>directories</strong></span>.</p><div class="note" title="Note"><h3 class="title"><a id="note02"/>Note</h3><p>Here is a warning: if you decide to manually add files to the <code class="literal">Published-iOS</code> folder, do not click on <span class="strong"><strong>Clean Cache</strong></span> in SpriteBuilder, or else you will lose all of those files.</p></div><p>However, using directories has its drawbacks. For example, you may want to use TexturePacker (which we will use later in this chapter, as well as throughout the book), but there is no easy way to use it and the new directory style of saving files. You technically can, but it's such a pain that any advantage TexturePacker has is negated by the extra work you have to do. So TexturePacker can work with the directory style of file reading. Thus, it's just easier to drag the files into SpriteBuilder if you're going to use the directory style.</p><p>So how will we work around this problem if we want to take advantage of TexturePacker? Well, until there exists a version of Cocos2d and SpriteBuilder that integrates<a id="id87" class="indexterm"/> the use of TexturePacker, we have to go back<a id="id88" class="indexterm"/> to the file suffix method.</p><div class="note" title="Note"><h3 class="title"><a id="tip04"/>Tip</h3><p>Note that if you do not wish to purchase TexturePacker, don't worry; it's not required. The later code will stay the same, as Cocos2d searches for the image, whether it was loaded via sprite sheets or as an individual file. If you do not wish to use TexturePacker, feel free to avoid changing your search mode (as mentioned next) and just go ahead with the directory method. Whenever this book mentions adding a file to the sprite sheet, that's your queue to add it to SpriteBuilder.</p></div><p>Since Cocos2d 3.0 and higher versions use the directory method by default, and since we're going to switch to using file extensions, we must look up the Xcode project for <span class="strong"><strong>CCFileUtilsSearchModeDirectory</strong></span>. One of the results should be a file called <code class="literal">CCBReader.m</code>. Click on the result and it should take you to approximately line 109, where you'll see the following line of code:</p><div class="informalexample"><pre class="programlisting">sharedFileUtils.searchMode = CCFileUtilsSearchModeDirectory;</pre></div><p>You're going to change that line to use the suffix search mode:</p><div class="informalexample"><pre class="programlisting">sharedFileUtils.searchMode = CCFileUtilsSearchModeSuffix;//CCFileUtilsSearchModeDirectory;</pre></div><p>With that in place, we're ready to begin the prototype phase of our project. But first, why is it important to make a prototype? And why is it important to create it quickly? Why not just code the game slowly and eventually get the core mechanics of the game in whenever it's time?</p></div></div>
<div class="section" title="Why prototype?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Why prototype?</h1></div></div></div><p>Besides <a id="id89" class="indexterm"/>the obvious reason of asking your friends "is it fun?!" before it's fully complete, prototyping your game, especially quickly and early on in development, can be very useful for a few different reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">You can ask about the originality/innovation of your game from the perspective of an end user instead of just your own views</li><li class="listitem">You can generate ideas on how to improve the game way before it's too late to make changes</li><li class="listitem">You can get a feel of how the game actually flows from one stage to the next, and conceive a tangible product instead of just an idea</li><li class="listitem">If shown to the public, it could be a great way to begin the marketing of your game and beginning the snowball of exposure needed to succeed on iOS</li></ul></div><p>Plus, this is the best way to start a project, especially a project that includes new concepts or ideas that might be hard to get fully coded and work as intended. You might have heard of the term <span class="strong"><strong>proof of concept</strong></span>; this chapter is exactly what that is. It's a very quick overview <a id="id90" class="indexterm"/>of your entire game that you can show to others and ask, "This is<a id="id91" class="indexterm"/> proof that I can make this concept into a full-blown game. What do you think?"</p><p>Now that you've understood why making a prototype for your game is a good idea, let's quickly go over the project this book will be covering.</p><div class="section" title="Playtesting and feedback analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Playtesting and feedback analysis</h2></div></div></div><p>When <a id="id92" class="indexterm"/>you have your prototype ready for others to experience, it's best <a id="id93" class="indexterm"/>to go out and actually get some people to play your game. Ideally, you should find playtesters who are knowledgeable in that game's genre as well as within the age range of your game's target audience so that they can give quality feedback.</p><p>The feedback you receive will vary from "Wow! This is amazing!" to "I don't understand how to play this game." You have to be prepared to hear all kinds of responses. Also, just because someone says your game is bad might not necessarily mean it is bad. However, if what they're saying is objectively true, and implementing what they have to say will improve your players' experience, then you should listen to their opinion as it will make not only your current game but also future games better.</p><p>Anyway, let's get into actually making a project that others can play.</p></div><div class="section" title="Project for the book"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Project for the book</h2></div></div></div><p>To get an idea of the project this book will be going through, imagine a 9 x 9 grid with your "base" at the center and enemies spawning around the squares at the edges. It's a turn-based game. On each turn, every unit moves one square. Each unit has a number that increases by <a id="id94" class="indexterm"/>one every turn. If your unit collides with the enemy's unit, the<a id="id95" class="indexterm"/> two numbers subtract and whichever unit has a positive result stays alive. Your goal is to protect your main base from an enemy unit, surviving an attack on your main base for as many turns as you can.</p><p>Here are a few screenshots of the finished game (by the end of <a class="link" title="Chapter 7. Reaching Our Destination" href="part0057.xhtml">Chapter 7</a>, <span class="emphasis"><em>Reaching Our Destination</em></span>):</p><p>When the game first starts up, it will look like what is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00212.jpeg" alt="Project for the book"/></div><p style="clear:both; height: 1em;"> </p><p>The <a id="id96" class="indexterm"/>game<a id="id97" class="indexterm"/> midway through a session will look as follows:</p><div class="mediaobject"><img src="../Images/image00213.jpeg" alt="Project for the book"/></div><p style="clear:both; height: 1em;"> </p><p>The game over screen, when the central square is taken, will look like what is shown in this screenshot:</p><div class="mediaobject"><img src="../Images/image00214.jpeg" alt="Project for the book"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="A quick mock-up"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>A quick mock-up</h2></div></div></div><p>Whether<a id="id98" class="indexterm"/> it's Photoshop, Illustrator, MS Paint, a<a id="id99" class="indexterm"/> paper and a pencil, a whiteboard, crayons, or any other creative way to draw your ideas, it's best to get a visual of the project so that when you begin to code, you at least have a basis for why you're choosing the colors and text positions that you are choosing.</p><p>Moreover, even though we have screenshots of the finished product, which we just saw, we need to imagine where to start. For example, in the following screenshot, you'll see a quick mock-up made for this book's project, as described earlier. The dimensions are 2048 x 1536 (iPad landscape). It was done relatively quickly for the purpose of showing the game as a concept, not as a finished product that is meant for marketing purposes. Don't worry; yours doesn't have to look as good as this if your art skills are lacking.</p><div class="mediaobject"><img src="../Images/image00215.jpeg" alt="A quick mock-up"/></div><p style="clear:both; height: 1em;"> </p><p>This<a id="id100" class="indexterm"/> is an example of a great starting point <a id="id101" class="indexterm"/>because it doesn't have any menus or fancy transitions; just the game. I know there's a button that says <span class="strong"><strong>Menu</strong></span>, but that's intended for later use, when we actually implement the menu. Remember, a prototype is supposed to be quick. It doesn't matter if the graphics, colors, fonts, or even the menu placements or word choices change. The point is to get it up as fast as possible. <span class="emphasis"><em>Test sooner, fail faster</em></span>.</p></div><div class="section" title="Overview of how the Cocos2d engine works"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Overview of how the Cocos2d engine works</h2></div></div></div><p>Before<a id="id102" class="indexterm"/> we go too deep into the code, let's quickly go <a id="id103" class="indexterm"/>over how the Cocos2d engine works. If you're using Cocos2d for the first time, this should be helpful. If you've used Cocos2d before, feel free to read through this, as it might be a refresher for you.</p><p>Cocos2d is essentially a series of parents and children. The base parent is the currently running scene. You can have only one scene displayed at any given time. Within the scene, there will be children, all of which have to be of the <code class="literal">CCNode</code> type. A <code class="literal">CCNode</code> object is an object that has a position, rotation, scale, color, and various other properties. A <code class="literal">CCNode</code> object can have other <code class="literal">CCNode</code> objects added to it.</p><p>Each <a id="id104" class="indexterm"/>subclass of <code class="literal">CCNode</code> inherits from it and adds<a id="id105" class="indexterm"/> functionality on top of the <code class="literal">CCNode</code> class. For example, if we want to draw an image on the screen, we'll use <code class="literal">CCSprite</code>, which is essentially a <code class="literal">CCNode</code> object, but with an image attached. Even a scene (type of <code class="literal">CCScene</code>) is a subclass of <code class="literal">CCNode</code> (which is how each scene can have children).</p><p>Here's an image made to help describe the relationship between parents and children within Cocos2d. First, we have the individual images we want to display on the screen, in a very simple texture atlas.</p><div class="mediaobject"><img src="../Images/image00216.jpeg" alt="Overview of how the Cocos2d engine works"/></div><p style="clear:both; height: 1em;"> </p><p>Next, we<a id="id106" class="indexterm"/> have a diagram of an example of <code class="literal">CCScene</code>. Added to<a id="id107" class="indexterm"/> the scene are five <code class="literal">CCSprite</code> objects: the sky, the two trees, the road, and the player.</p><div class="mediaobject"><img src="../Images/image00217.jpeg" alt="Overview of how the Cocos2d engine works"/></div><p style="clear:both; height: 1em;"> </p><p>The sky is positioned at z-index equal to 0, the trees at z-index equal to 1 (which means they'll be displayed in front of the sky), the road at z-index equal to 2 (which means it'll be displayed in front of both the sky and the trees), and the player at z-index equal to 3 (which means it'll be displayed in front of everything). The default z-index is 0.</p><p>Everything else in Cocos2d is simple—just a <code class="literal">CCNode</code> object with other <code class="literal">CCNode</code> objects added as children.</p><p>Here's one thing to remember about the parent-child relationship that Cocos2d uses: if you move a parent by 20 points, for example, the children will also be moved by the same amount.</p><p>Now that we've briefly gone over how Cocos2d works, let's get our prototype going.</p></div></div>
<div class="section" title="Getting a scene up and running"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Getting a scene up and running</h1></div></div></div><p>Before we even start adding anything to the screen, we need to make sure we have a game that can be viewed on our device or a simulator. Once you've created the project in SpriteBuilder (or gotten the blank project that was listed earlier) and opened the project in Xcode, go to the next step.</p><div class="section" title="Creating the initial code for the scene to open"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Creating the initial code for the scene to open</h2></div></div></div><p>You <a id="id108" class="indexterm"/>should see a file called <code class="literal">MainScene.h</code> and another file called <code class="literal">MainScene.m</code>. Open the header file (which has the <code class="literal">.h</code> extension).</p><p>In the header file, add a few lines of code between the <code class="literal">@interface</code> line and the <code class="literal">@end</code> line. The header should look like this:</p><div class="informalexample"><pre class="programlisting">@interface MainScene : CCNode
{
  CGSize winSize;
}
+(CCScene*)scene;
@end</pre></div><p>Then, in the main file (which has the <code class="literal">.m</code> extension), some lines of code should be added between the <code class="literal">@implementation</code> and <code class="literal">@end</code> lines. It should look as follows:</p><div class="informalexample"><pre class="programlisting">#import "MainScene.h"

@implementation MainScene

+(CCScene *)scene
{
  return [[self alloc] init];
}

-(id)init
{
  if ((self=[super init]))
  {
   //used for positioning items on screen
    winSize = [[CCDirector sharedDirector] viewSize];
    
    float grey = 70 / 255.f;
   //these values range 0 to 1.0, so use float to get ratio
    CCNode *background = [CCNodeColor nodeWithColor:[CCColor colorWithRed:grey green:grey blue:grey]];
    [self addChild:background];
  }
  return self;
}

@end</pre></div><p>Finally, open<a id="id109" class="indexterm"/> the <code class="literal">AppDelegate.m</code> file and scroll to the bottom, where you should see a line in the <code class="literal">startScene</code> method that looks like this:</p><div class="informalexample"><pre class="programlisting">return [CCBReader loadAsScene:@"MainScene"];</pre></div><p>We're going to change it to the following:</p><div class="informalexample"><pre class="programlisting">return [MainScene scene];</pre></div><p>The code might give you an error for this line. This can be fixed by importing the <code class="literal">MainScene</code> header to the AppDelegate's main file. Simply add this to the top of the <code class="literal">AppDelegate.m</code> file:</p><div class="informalexample"><pre class="programlisting">#import "MainScene.h"</pre></div><p>Once all of this has been put in place, feel free to run your project on either your device or the simulator built into Xcode. You can read more about each option in the following sections.</p></div><div class="section" title="Run it on the simulator – doesn't require an iOS developer license"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Run it on the simulator – doesn't require an iOS developer license</h2></div></div></div><p>Running<a id="id110" class="indexterm"/> on the simulator is good for testing devices you don't own. For example, if you own an iPhone 5s and want to test how your game looks on an iPhone 6 or 6 Plus, simply load that simulator and test to see how the game looks.</p><div class="note" title="Note"><h3 class="title"><a id="tip05"/>Tip</h3><p>Note that it's best to test for performance on the device only. Do not test for performance on the simulator. You will never get a perfect representation of the device's capabilities when running on the simulator. Also, you should test only how the game looks.</p></div><p>For testing on the simulator, simply choose which device you wish to simulate from the simulators available in Xcode as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00218.jpeg" alt="Run it on the simulator – doesn't require an iOS developer license"/></div><p style="clear:both; height: 1em;"> </p><p>Choose <a id="id111" class="indexterm"/>any simulator you want, preferably a simulator that your game will eventually be supported on, and either press the play button on the left, or hit <span class="emphasis"><em>command</em></span> +<span class="strong"><strong> </strong></span>
<span class="emphasis"><em>R</em></span> to run it. It might take a few minutes to open the simulator, so be patient. But once it does, it should automatically open on the simulator. If it doesn't, just try rerunning it with the simulator already open.</p><p>Congratulations! If you have used the simulator, you now have a project that runs! Next, we are going to go over how to run it on  device.</p></div><div class="section" title="Run it on the device – requires an iOS developer license"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Run it on the device – requires an iOS developer license</h2></div></div></div><p>If you're<a id="id112" class="indexterm"/> unsure whether you want to run your game on a device or on the simulator, let me explain why the device is the king in terms of testing purposes. Not only do you get to see and feel the project just as any other user would, but you also get to experience the actual performance of the device rather than a simulated version of it. Plus, if your project is heavy on touchscreen usage (which it honestly should, or else it probably shouldn't be an iOS title), then you can effectively test the feel of the game.</p><p>For testing<a id="id113" class="indexterm"/> on the device, simply plug in your device. Its name should be listed in Xcode, like this:</p><div class="mediaobject"><img src="../Images/image00219.jpeg" alt="Run it on the device – requires an iOS developer license"/></div><p style="clear:both; height: 1em;"> </p><p>If you do not see the name of your device, make sure you select the iOS device target, and not any of the simulators. If your device is plugged in and it still shows <span class="strong"><strong>iOS Device</strong></span>, make sure you have a developer account subscription in Xcode. Refer to <a class="link" title="Chapter 1. Refreshing Your Cocos2d Knowledge" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Refreshing Our Cocos2d Knowledge</em></span>, for more details on this.</p><p>Once you see the name of your device, either press the <span class="strong"><strong>Play</strong></span> button on the left, or hit <span class="emphasis"><em>command</em></span> +<span class="strong"><strong> </strong></span>
<span class="emphasis"><em>R</em></span> to run it. It might take a minute or so to build, but once it's complete, the project will automatically open on your device.</p><p>Congratulations! You now have a project that runs. Now we can start adding some content, such as text and buttons, and then move on to creating another scene and transitioning to that and back to the original.</p></div></div>
<div class="section" title="Creating buttons and text (labels)"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Creating buttons and text (labels)</h1></div></div></div><p>If you <a id="id114" class="indexterm"/>want to place a line of text on the screen, you need to create <a id="id115" class="indexterm"/>a label. There are two types of labels in Cocos2d: <code class="literal">CCLabelBMFont</code> and <code class="literal">CCLabelTTF</code>. Bitmap Font labels are the fancy labels created with Glyph Designer, mentioned earlier in this book. TrueType Font labels are regular, unformatted text labels that use<a id="id116" class="indexterm"/> either a font file that's already<a id="id117" class="indexterm"/> on the phone or a file you've added to your project.</p><div class="note" title="Note"><h3 class="title"><a id="tip06"/>Tip</h3><p>Note that if you have a label that often needs updating, for example, a score counter or a health value, it's more efficient to use BMFonts in those cases, even if the font is a plain white font and looks exactly the same in TTF format.</p></div><div class="section" title="Let's get some text displayed – CCLabelTTF"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Let's get some text displayed – CCLabelTTF</h2></div></div></div><p>As<a id="id118" class="indexterm"/> mentioned earlier, TTF labels are simple, unformatted labels. How are these useful? The answer is, you can quickly get the prototype of your game going, and so you can better understand the flow of the game. Then, once it's ready, you can switch over to using BMFonts to make it look nice. See <a class="link" title="Chapter 6. Tidying Up and Polishing" href="part0049.xhtml">Chapter 6</a>, <span class="emphasis"><em>Tidying Up and Polishing</em></span>, to learn more about ways to improve the aesthetics of your game.</p><div class="note" title="Note"><h3 class="title"><a id="tip07"/>Tip</h3><p>Here's a short note about BMFonts: if you want to use them in your game, which you should do for performance reasons alone, keep in mind the various limitations that BMFonts have and TTF fonts don't. The first is poor quality when upscaling the label. Then, BMFonts can use only the characters that are in the font atlas, and any foreign language support might mean a lot of extra BMFonts, which could add up quickly in terms of space.</p></div><p>The first thing we're going to do is get those labels on the left side going. The following code should be added to <code class="literal">MainScene.h</code> (the <code class="literal">lbl</code> prefix in the front of the variable will indicate to us that it's a label; similarly, <code class="literal">btn</code> for button, <code class="literal">num</code> for number, and so on):</p><div class="informalexample"><pre class="programlisting">@interface MainScene : CCNode
{
  CGSize winSize;
  //Add the following:
  //the labels used for displaying the game info
  CCLabelTTF *lblTurnsSurvived, *lblUnitsKilled, *lblTotalScore;
}</pre></div><p>The following code goes into the <code class="literal">init</code> method of <code class="literal">MainScene.m</code> and will create the labels. We then want to set the position for each label because the default position is in the bottom-left corner. Finally, we add each label to the scene. Remember, the scene is just a node that can have as many children as you want:</p><div class="informalexample"><pre class="programlisting">CCLabelTTF *lblTurnsSurvivedDesc = [CCLabelTTF labelWithString:@"Turns Survived:" fontName:@"Arial" fontSize:12];
lblTurnsSurvivedDesc.position = ccp(winSize.width * 0.1, winSize.height * 0.8);
[self addChild:lblTurnsSurvivedDesc];
    
lblTurnsSurvived = [CCLabelTTF labelWithString:@"0" fontName:@"Arial" fontSize:22];
lblTurnsSurvived.position = ccp(winSize.width * 0.1, winSize.height * 0.75);
[self addChild:lblTurnsSurvived];
    
CCLabelTTF *lblUnitsKilledDesc = [CCLabelTTF labelWithString:@"Units Killed:" fontName:@"Arial" fontSize:12];
lblUnitsKilledDesc.position = ccp(winSize.width * 0.1, winSize.height * 0.6);
[self addChild:lblUnitsKilledDesc];
    
lblUnitsKilled = [CCLabelTTF labelWithString:@"0" fontName:@"Arial" fontSize:22];
lblUnitsKilled.position = ccp(winSize.width * 0.1, winSize.height * 0.55);
[self addChild:lblUnitsKilled];
    
CCLabelTTF *lblTotalScoreDesc = [CCLabelTTF labelWithString:@"Total Score:" fontName:@"Arial" fontSize:12];
lblTotalScoreDesc.position = ccp(winSize.width * 0.1, winSize.height * 0.4);
[self addChild:lblTotalScoreDesc];
    
lblTotalScore = [CCLabelTTF labelWithString:@"1" fontName:@"Arial" fontSize:22];
lblTotalScore.position = ccp(winSize.width * 0.1, winSize.height * 0.35);
[self addChild:lblTotalScore];</pre></div><p>Notice<a id="id119" class="indexterm"/> that we've used the <code class="literal">winSize</code> variable for positioning. This is useful because it not only keeps things in a relative position on the screen but also helps when coding for multiple devices that have different screen sizes (for example, iPhone 4, iPhone 5, iPad, and so on have different dimensions).</p><p>Another way to handle this would be to set the <code class="literal">positionType</code> of our labels to <code class="literal">CCPositionTypeNormalized</code>. Then we can set our position values anywhere from <code class="literal">0</code> to <code class="literal">1</code>, <code class="literal">0</code> being the far left (or bottom) of the screen, and <code class="literal">1</code> being the far right (or top) of the screen.</p></div><div class="section" title="Let's get some text displayed – CCLabelBMFont"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Let's get some text displayed – CCLabelBMFont</h2></div></div></div><p>If you <a id="id120" class="indexterm"/>aren't already familiar, let's recall: BMFonts are the nice, stylized fonts that give your game that extra level of polish without requiring too much effort from you. Refer to <a class="link" title="Chapter 6. Tidying Up and Polishing" href="part0049.xhtml">Chapter 6</a>, <span class="emphasis"><em>Tidying Up and Polishing</em></span>, to improve the aesthetics of your game. To create BMFont, you have to use a BMFont creator. We're going to use Glyph Designer, as mentioned in <a class="link" title="Chapter 1. Refreshing Your Cocos2d Knowledge" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Refreshing Our Cocos2d Knowledge</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="tip08"/>Tip</h3><p>If you followed the preceding TTF section, then you can just comment out or remove those lines of code, since we are going to redo those fonts and make them BMFont labels in this section.</p></div><p>The first thing we're going to do is create the fonts on the left side of our scene. With Glyph Designer open, select a font from the left panel (I chose <span class="strong"><strong>Britannic Bold</strong></span>, the font in the mock-up). You can mess around with the settings on the right to get a font suitable for your project, but remember that this is only a prototype and you shouldn't spend too much time on it. Have a look at the following screenshot:</p><div class="mediaobject"><img src="../Images/image00220.jpeg" alt="Let's get some text displayed – CCLabelBMFont"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="tip09"/>Tip</h3><p>Ensure the font size isn't too big or too small. As you can see in the preceding screenshot, it's set to 60. This is a decent size for the project. If it ends up being too big or too small, adjusting it is fairly simple.</p></div><p>When <a id="id121" class="indexterm"/>you're satisfied with the settings you have chosen, click on <span class="strong"><strong>Save As</strong></span> at the top, and select where you want to save the Glyph Designer file (not the actual font file). Now that it has been saved for later use if we decide to edit the font, let's move on to exporting the font so that we can use it in Cocos2d.</p><p>Depending on which style of file reading you decided to go with, there are two different ways you'll need to export the font. Make sure you follow the same style as you can use only one of the styles (but not both) within the same project. No matter which route you go by, start with the largest font size you'll need; for example, the preceding screenshot shows a font size of 60 because it's going to be seen on a Retina iPad. If it were only on an iPhone, 60 would be too large.</p><div class="section" title="Saving your BMFont using file suffixes"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Saving your BMFont using file suffixes</h3></div></div></div><p>In<a id="id122" class="indexterm"/> Glyph Designer, click on <span class="strong"><strong>Export</strong></span> at the top and<a id="id123" class="indexterm"/> navigate to the <code class="literal">Resources/Published-iOS</code> folder in your project directory (see the following screenshot). This is where you'll export the font for use with Cocos2d. Notice that because this is the largest font, meant for Retina-sized iPads, the suffix after the filename is <code class="literal">-ipadhd</code>. If you weren't designing for iPad, your largest filename suffix would be <code class="literal">-hd</code>.</p><div class="note" title="Note"><h3 class="title"><a id="tip10"/>Tip</h3><p>Note that you should leave the <code class="literal">.fnt</code>/<code class="literal">.png</code> extension (see the following screenshot) as it is. Glyph Designer will automatically add that for you.</p></div><div class="mediaobject"><img src="../Images/image00221.jpeg" alt="Saving your BMFont using file suffixes"/></div><p style="clear:both; height: 1em;"> </p><p>Once<a id="id124" class="indexterm"/> you've exported the largest phone, go ahead <a id="id125" class="indexterm"/>and adjust the settings for each tier you need. For example, since we're exporting <code class="literal">-ipadhd</code> at the 60-point font, we'd also want to make 30-point and 15-point sizes for smaller devices. In addition to reducing the font size, we can also modify the stroke and shadow settings to give relatively the same look for all sizes.</p><p>So overall, if you call your font <code class="literal">bmFont</code>, you should have the following files (each <code class="literal">.fnt</code> file will also have a <code class="literal">.png</code> file with it), with the largest font size being 60:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">bmFont-ipadhd.fnt - 60-pt</code></li><li class="listitem"><code class="literal">bmFont-ipad.fnt - 30-pt</code></li><li class="listitem"><code class="literal">bmFont-hd.fnt - 30-pt</code></li><li class="listitem"><code class="literal">bmFont.fnt - 15-pt</code></li></ul></div><div class="mediaobject"><img src="../Images/image00222.jpeg" alt="Saving your BMFont using file suffixes"/></div><p style="clear:both; height: 1em;"> </p><p>When<a id="id126" class="indexterm"/> using the file extension method, as long as you <a id="id127" class="indexterm"/>export your files to the <code class="literal">Published-iOS</code> folder, the Xcode project remains set up in a way that includes your fonts in the project. In this way, you don't need to worry about copying anything. That being said, let's begin displaying labels with this new font we just created.</p></div><div class="section" title="Saving your BMFont using directories"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Saving your BMFont using directories</h3></div></div></div><p>If you<a id="id128" class="indexterm"/> chose to go with directories, it's not as simple as<a id="id129" class="indexterm"/> just dragging the font files into SpriteBuilder (at the time of writing this book). Instead, you must create four folders within the <code class="literal">Published-iOS</code> folder of your project directory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">resources-phone</code></li><li class="listitem"><code class="literal">resources-phonehd</code></li><li class="listitem"><code class="literal">resources-tablet</code></li><li class="listitem"><code class="literal">resources-tablethd</code></li></ul></div><div class="mediaobject"><img src="../Images/image00223.jpeg" alt="Saving your BMFont using directories"/></div><p style="clear:both; height: 1em;"> </p><p>In <a id="id130" class="indexterm"/>Glyph Designer, click on <span class="strong"><strong>Export</strong></span> at the top and <a id="id131" class="indexterm"/>navigate to the <code class="literal">Published-iOS/resources-tablethd</code> folder in your project directory (see the following screenshot). This is where you'll export the font for use with Cocos2d. The name of the file here is going to be the name of the font.</p><div class="note" title="Note"><h3 class="title"><a id="tip11"/>Tip</h3><p>Leave the <code class="literal">.fnt</code>/<code class="literal">.png</code> extension as it is (see the following screenshot). Glyph Designer will automatically add it for you.</p></div><div class="mediaobject"><img src="../Images/image00224.jpeg" alt="Saving your BMFont using directories"/></div><p style="clear:both; height: 1em;"> </p><p>Once<a id="id132" class="indexterm"/> the <code class="literal">tablethd</code> version has been exported, do the <a id="id133" class="indexterm"/>same export but modify the font size and any other settings you wish to modify. For example, since we're exporting the <code class="literal">tablethd</code> size at 60-point font, we'd also want to create 30-point and 15-point sizes for smaller devices. In addition to reducing the font size, we can also modify the stroke and shadow settings to give relatively the same look for all sizes.</p><p>So overall, if you call your font <code class="literal">bmFont</code>, you should have the following files (each <code class="literal">.fnt</code> file will also have a <code class="literal">.png</code> file with it), with the largest font size being 60:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">resources-tablethd/bmFont.fnt - 60-pt</code></li><li class="listitem"><code class="literal">resources-tablet/bmFont.fnt - 30-pt</code></li><li class="listitem"><code class="literal">resources-phonehd/bmFont.fnt - 30-pt</code></li><li class="listitem"><code class="literal">resources-phone/bmFont.fnt - 15-pt</code></li></ul></div><div class="mediaobject"><img src="../Images/image00225.jpeg" alt="Saving your BMFont using directories"/></div><p style="clear:both; height: 1em;"> </p><p>When<a id="id134" class="indexterm"/> using the directory method, if you've exported the<a id="id135" class="indexterm"/> font files to the folders mentioned previously, the Xcode project will be set up in such a way that it will automatically include these files, so you don't need to worry about copying anything. That being said, let's begin to display labels with this new font we just created.</p></div><div class="section" title="Exporting the BMFont and importing to Xcode"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Exporting the BMFont and importing to Xcode</h3></div></div></div><p>Bring<a id="id136" class="indexterm"/> up Xcode and open <code class="literal">MainScene.h</code>. You're going to add these<a id="id137" class="indexterm"/> variables below the line that says <code class="literal">CGSize winSize</code>. Again, if you've followed the preceding TTF tutorial, you can delete or comment out the variables we created in that tutorial, as we will be using the same variable names here. We're stating the variable with <code class="literal">lbl</code> again so that we can easily identify it as a label:</p><div class="informalexample"><pre class="programlisting">@interface MainScene : CCNode
{
  CGSize winSize;
//the labels used for displaying the game info
//this line now uses CCLabelBMFont instead of CCLabelTTFFont
CCLabelBMFont *lblTurnsSurvived, *lblUnitsKilled, *lblTotalScore;
}</pre></div><p>Then <a id="id138" class="indexterm"/>open <code class="literal">MainScene.m</code> and add these lines of code below the code<a id="id139" class="indexterm"/> for the background layer to display the labels. If you had chosen to export your font with a different name, you must change the <code class="literal">fntFile</code> parameter to match whatever you chose:</p><div class="informalexample"><pre class="programlisting">CCLabelBMFont *lblTurnsSurvivedDesc = [CCLabelBMFont labelWithString:@"Turns Survived:" fntFile:@"bmFont.fnt"];
lblTurnsSurvivedDesc.position = ccp(winSize.width * 0.125, winSize.height * 0.8);
[self addChild:lblTurnsSurvivedDesc];
    
lblTurnsSurvived = [CCLabelBMFont labelWithString:@"0" fntFile:@"bmFont.fnt"];
lblTurnsSurvived.position = ccp(winSize.width * 0.125, winSize.height * 0.75);
[self addChild:lblTurnsSurvived];
    
CCLabelBMFont *lblUnitsKilledDesc = [CCLabelBMFont labelWithString:@"Units Killed:" fntFile:@"bmFont.fnt"];
lblUnitsKilledDesc.position = ccp(winSize.width * 0.125, winSize.height * 0.6);
[self addChild:lblUnitsKilledDesc];
    
lblUnitsKilled = [CCLabelBMFont labelWithString:@"0" fntFile:@"bmFont.fnt"];
lblUnitsKilled.position = ccp(winSize.width * 0.125, winSize.height * 0.55);
[self addChild:lblUnitsKilled];
    
CCLabelBMFont *lblTotalScoreDesc = [CCLabelBMFont labelWithString:@"Total Score:" fntFile:@"bmFont.fnt"];
lblTotalScoreDesc.position = ccp(winSize.width * 0.125, winSize.height * 0.4);
[self addChild:lblTotalScoreDesc];
    
lblTotalScore = [CCLabelBMFont labelWithString:@"1" fntFile:@"bmFont.fnt"];
lblTotalScore.position = ccp(winSize.width * 0.125, winSize.height * 0.35);
[self addChild:lblTotalScore];</pre></div><p>With these lines added, you should be able to run the game and see some fancy-looking labels on the left side of the screen, as shown here (this was run on an iPhone 5):</p><div class="mediaobject"><img src="../Images/image00226.jpeg" alt="Exporting the BMFont and importing to Xcode"/></div><p style="clear:both; height: 1em;"> </p><p>It's <a id="id140" class="indexterm"/>not much of a game if it's just displaying text, so let's add some <a id="id141" class="indexterm"/>buttons. But first, we must go over how to create sprite sheets using TexturePacker.</p><p>If you decide not to use TexturePacker, read the <span class="emphasis"><em>Not using TexturePacker – A brief how-to</em></span> section and feel free to skip over the section about using sprite sheets with TexturePacker. If that's the case, you should also be using the directory method of file reading, as there's almost no benefit of file extensions except when using a program that automatically maintains them, such as TexturePacker.</p></div></div><div class="section" title="Not using TexturePacker – A brief how-to"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Not using TexturePacker – A brief how-to</h2></div></div></div><p>As <a id="id142" class="indexterm"/>mentioned earlier, if you opt against using TexturePacker, any time it's mentioned to add the image to the sprite sheet, that's your queue to add it to SpriteBuilder and republish it, as it's assumed that you'll be using the directory mode of file reading.</p><p>To do this, drag the iPad-retina-sized image into SpriteBuilder, and click on <span class="strong"><strong>Publish</strong></span>. SpriteBuilder will auto-scale.</p><div class="note" title="Note"><h3 class="title"><a id="tip12"/>Tip</h3><p>Note, however, that in the later chapters of this book, the sprite sheets will be provided (as well as the individual images if you want to do it yourself).</p></div></div></div>
<div class="section" title="Begin using sprite sheets with TexturePacker"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Begin using sprite sheets with TexturePacker</h1></div></div></div><p>Sprite <a id="id143" class="indexterm"/>sheets are used to improve the performance<a id="id144" class="indexterm"/> of your game, not only reducing the time it takes for the game to load but also improving the performance while the game is running.</p><div class="note" title="Note"><h3 class="title"><a id="tip13"/>Tip</h3><p>Unfortunately, TexturePacker works with Cocos2d at the time of writing this book, but its use is not supported by SpriteBuilder directly. However, TexturePacker is a great solution when it comes to building sprite sheets effectively. If you wish to use TexturePacker but are currently using the directory method (the default for SpriteBuilder at the time of writing this book), go back and change your style to file extensions.</p></div><p>As mentioned in <a class="link" title="Chapter 1. Refreshing Your Cocos2d Knowledge" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Refreshing Our Cocos2d Knowledge</em></span>, we will be using TexturePacker as the go-to for our sprite sheet creator. TexturePacker is nice for a few reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It allows exporting to Cocos2d with one click</li><li class="listitem">It has auto-scaling (up or down) that supports all resolution types</li><li class="listitem">It makes updating your images later easier to import the images</li></ul></div><p>First, open TexturePacker. Then go to the <code class="literal">Images Pre-Chapter 6</code> folder, where you'll see the <code class="literal">btnMenu.png</code> image (our menu button image). Drag it into the right column of TexturePacker. It should look something like this:</p><div class="mediaobject"><img src="../Images/image00227.jpeg" alt="Begin using sprite sheets with TexturePacker"/></div><p style="clear:both; height: 1em;"> </p><p>Before <a id="id145" class="indexterm"/>changing any of the file locations, make <a id="id146" class="indexterm"/>sure you do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <span class="strong"><strong>Texture format</strong></span> drop-down box, ensure that <span class="strong"><strong>PNG</strong></span> is selected. This format should be fine for most games you'll make. However, if you find yourself wanting to make your game's final project size smaller without sacrificing quality, a recommendation is to switch to <span class="strong"><strong>zlib pvr.ccz compression</strong></span>. This is the most optimal format for Cocos2d, for not only compression per pixel but also performance when drawing the images on the screen.</li><li class="listitem">Check the box that says <span class="strong"><strong>Premultiply Alpha</strong></span>. It's not entirely important to know the details of how this works. For now, just know that in Cocos2d, the texture can be rendered faster with this checked.</li></ol><div style="height:10px; width: 1px"/></div><div class="section" title="Saving to the project location"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Saving to the project location</h2></div></div></div><p>Now that<a id="id147" class="indexterm"/> we have the image in TexturePacker, let's modify some of the settings to make sure we can effectively manage any future versions of this sprite sheet. Click on the little folder icon next to the <span class="strong"><strong>Data file</strong></span> textbox and go to the project's <code class="literal">Resources/Published-iOS</code> directory. Feel free to name the file whatever you want, but try to keep it relevant. For this example, we'll call it <code class="literal">buttonSheet</code> because it will be the sprite sheet that contains all the buttons in the game. Click on <span class="strong"><strong>Save</strong></span> when you're ready.</p><div class="note" title="Note"><h3 class="title"><a id="tip14"/>Tip</h3><p>Note that even though the file is being called <code class="literal">buttonSheet.plist</code>, there is <code class="literal">{v}</code> at the end of the filename. This is important, and is what allows TexturePacker to do the auto-scaling for us.</p></div><div class="mediaobject"><img src="../Images/image00228.jpeg" alt="Saving to the project location"/></div><p style="clear:both; height: 1em;"> </p><p>As for image format, it's generally okay to keep it at <span class="strong"><strong>RGBA8888</strong></span>. However, if your game has a<a id="id148" class="indexterm"/> large number of art assets on the screen and is suffering performance-wise, changing this to a lower setting might help.</p></div><div class="section" title="Scaling the images and publishing the sprite sheet"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Scaling the images and publishing the sprite sheet</h2></div></div></div><p>Now <a id="id149" class="indexterm"/>we need to make sure TexturePacker<a id="id150" class="indexterm"/> will correctly scale what we need. Click on the gear icon next to <span class="strong"><strong>AutoSD</strong></span>, and then open the drop-down box at the top labeled <span class="strong"><strong>Presets</strong></span>. Choose the option that best suits your needs and click on <span class="strong"><strong>Apply</strong></span>.</p><div class="note" title="Note"><h3 class="title"><a id="tip15"/>Tip</h3><p>If you're only making an iPhone game (and not an iPad version), select <span class="strong"><strong>cocos2d hd/sd</strong></span>.</p><p>Otherwise (if you are making an iPad version, which this book's project is), select <span class="strong"><strong>cocos2d ipad/hd/sd</strong></span>.</p></div><p>Finally, in <a id="id151" class="indexterm"/>the top-left corner of the<a id="id152" class="indexterm"/> screen, we click on the <span class="strong"><strong>Save defaults</strong></span> button, as it allows us to save these settings for any time when we need to create a TexturePacker sprite sheet again. Then click on <span class="strong"><strong>Save</strong></span> (or press <span class="emphasis"><em>command</em></span> +<span class="strong"><strong> </strong></span>
<span class="emphasis"><em>S</em></span>). This will ask you where you want to the save the TexturePacker file (not the sprite sheet). Generally, you'll save this file in the same folder as all your other art assets. For example, we'll have a separate directory for both the project and the individual art assets that will be copied later.</p><div class="mediaobject"><img src="../Images/image00229.jpeg" alt="Scaling the images and publishing the sprite sheet"/></div><p style="clear:both; height: 1em;"> </p><p>Once you've saved the TPS file in your location of choice, go ahead and click on <span class="strong"><strong>Publish</strong></span>. Publishing will generate the required sprite sheets for the project based on the various settings we entered earlier.</p></div><div class="section" title="Importing the sprite sheet and loading it into the memory"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Importing the sprite sheet and loading it into the memory</h2></div></div></div><p>Finally, once<a id="id153" class="indexterm"/> you have published the sprite<a id="id154" class="indexterm"/> sheet in the project directory (or anywhere really, but it's best if it's located in the project directory for easy updating later on), the way the Xcode project is set up should cause them to be automatically added to your project.</p><p>Once you've published the sprite sheet, open Xcode and go to <code class="literal">AppDelegate.m</code>. Add one line of code right above the return statement in the <code class="literal">startScene</code> method to make it look something like this:</p><div class="informalexample"><pre class="programlisting">- (CCScene*) startScene
{
  [[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"buttonSheet.plist"];
  
  return [MainScene scene];//[CCBReader loadAsScene:@"MainScene"];
}</pre></div><p>Now you're ready to start using the sprite sheet. It took a little bit of work to set it up, but for now, all you need to do is add images to the TexturePacker file, click on <span class="strong"><strong>Save</strong></span>, and then click on Publish. Your changes will be automatically reflected the next time you run your project. That being said, let's make use of the sprite sheet by turning that menu button image into an actual button.</p></div></div>
<div class="section" title="Creating buttons via CCButton and CCLayout"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Creating buttons via CCButton and CCLayout</h1></div></div></div><p>Cocos2d 3.0 changed the way buttons are displayed. If you've used previous versions of Cocos2d, you're<a id="id155" class="indexterm"/> probably familiar with <code class="literal">CCMenu</code>. That is<a id="id156" class="indexterm"/> no longer the way to create and display tappable <a id="id157" class="indexterm"/>buttons in Cocos2d. Instead, we're going to <a id="id158" class="indexterm"/>use <code class="literal">CCButton</code> and place them in a node of the <code class="literal">CCLayout</code> type. If you skipped the sprite sheet section, I strongly recommend that you go back and read it. It will save you from many frustrating moments as the project progresses.</p><p>For the book's project, we'll be adding the menu button in the bottom-left corner. Like I said, it's extremely easy to add the buttons once you have the images included in the project.</p><p>Open the <code class="literal">MainScene.m</code> file, and add these lines of code below the code for the labels in the <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">CCButton *btnMenu = [CCButton buttonWithTitle:@""
  spriteFrame:[CCSpriteFrame frameWithImageNamed:@"btnMenu.png"]];
btnMenu.position = ccp(winSize.width * 0.125, winSize.height * 0.1);
[self addChild:btnMenu];</pre></div><p>When you run it, you should see the menu button appear in the bottom-left corner. If you used the <code class="literal">pvr.ccz</code> format and the button flips horizontally, don't worry. Just go back to TexturePacker, check <a id="id159" class="indexterm"/>the box that says <span class="strong"><strong>Flip PVR</strong></span>, save<a id="id160" class="indexterm"/> the file, and then publish. Go back to Xcode <a id="id161" class="indexterm"/>and rerun the project. It should look something<a id="id162" class="indexterm"/> like this:</p><div class="mediaobject"><img src="../Images/image00230.jpeg" alt="Creating buttons via CCButton and CCLayout"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Adding the Restart button"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Adding the Restart button</h2></div></div></div><p>Add <a id="id163" class="indexterm"/>the <span class="strong"><strong>Restart</strong></span> button (in this case, <code class="literal">btnRestart.png</code>) to <a id="id164" class="indexterm"/>either TexturePacker or SpriteBuilder depending on which method you used, click on Save, and then publish to update the files so that the <span class="strong"><strong>Restart</strong></span> button can be used. With the <span class="strong"><strong>Restart</strong></span> button's image added, you can modify the <code class="literal">MainScene.m</code> file's code to look something like this:</p><div class="informalexample"><pre class="programlisting">CCButton *btnMenu = [CCButton buttonWithTitle:@"" spriteFrame:[CCSpriteFrame frameWithImageNamed:@"btnMenu.png"]];
    
CCButton *btnRestart = [CCButton buttonWithTitle:@"" spriteFrame:[CCSpriteFrame frameWithImageNamed:@"btnRestart.png"]];
    
CCLayoutBox *layoutButtons = [[CCLayoutBox alloc] init];
[layoutButtons addChild:btnRestart];
[layoutButtons addChild:btnMenu];
layoutButtons.spacing = 10.f;
layoutButtons.anchorPoint = ccp(0.5f, 0.5f);
layoutButtons.direction = CCLayoutBoxDirectionVertical;
[layoutButtons layout];
layoutButtons.position = ccp(winSize.width * 0.125, winSize.height * 0.15);
[self addChild:layoutButtons];</pre></div><p>This<a id="id165" class="indexterm"/> will allow the restart button and the menu button to<a id="id166" class="indexterm"/> be lined up perfectly. Plus, if you ever decide to move both buttons, but you want them at the same distance relative to each other, just reposition the layout box. And voilà!</p><p>What you can do as a quick learning experience is to try messing around with the spacing values; or change the direction, or even the anchor point. You'll get a better understanding of why each line of code is absolutely necessary to create this effect when you try testing different values.</p><p>Go ahead and modify some of the values. You can always revert to the preceding code.</p><p>So far, using the initial code that you just saw, if you run the project, this is what it will look like:</p><div class="mediaobject"><img src="../Images/image00231.jpeg" alt="Adding the Restart button"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Creating nodes and units (sprites)"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Creating nodes and units (sprites)</h1></div></div></div><p>Remember, everything in Cocos2d is, at its base, a <code class="literal">CCNode</code> object. Nodes can have other nodes <a id="id167" class="indexterm"/>as children. For example, if you wish to create a character with a<a id="id168" class="indexterm"/> jetpack attached, the character can be a <code class="literal">CCSprite</code> object (a node object with an image) and the jetpack can be a <code class="literal">CCSprite</code> object as a child of the character.</p><p>Anyway, this is a chapter about prototypes, and we've yet to create any real gameplay. Let's get that going with a few images, some touch controls, and much more.</p><div class="section" title="Setting up the background"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Setting up the background</h2></div></div></div><p>Add the<a id="id169" class="indexterm"/> background image to the sprite sheet (or SpriteBuilder), save, publish, and then in the <code class="literal">MainScene.m</code> file's <code class="literal">init</code> method, add the image to the screen as a <code class="literal">CCSprite</code> object below the <code class="literal">CCLayoutBox</code> code:</p><div class="informalexample"><pre class="programlisting">CCSprite *board = [CCSprite spriteWithImageNamed:@"imgBoard.png"];
board.position = ccp(winSize.width * 0.625, winSize.height/2);
[self addChild:board];</pre></div><p>Let's run the game, and uh oh! We seem to have run into the first issue with our prototype. Although it's not entirely necessary to get all the bugs and kinks out during this phase, this one is important for the gameplay. Plus, it's a great opportunity to learn about device-specific scaling. If you'll take a look at the following screenshots, one of which was<a id="id170" class="indexterm"/> taken on an iPhone 5 and the other on an iPad Retina, you'll notice an issue with the game board being a bit too big on the phone. Here is a screenshot of the game from an iPhone 5:</p><div class="mediaobject"><img src="../Images/image00232.jpeg" alt="Setting up the background"/></div><p style="clear:both; height: 1em;"> </p><p>An iPad Retina screenshot of the game appears as follows:</p><div class="mediaobject"><img src="../Images/image00233.jpeg" alt="Setting up the background"/></div><p style="clear:both; height: 1em;"> </p><p>Luckily, it's <a id="id171" class="indexterm"/>not too far off, as the auto-scaling from either TexturePacker or SpriteBuilder has given us a relatively accurate scale for the game board. The only thing we need to do is modify the scale of the board very slightly on only the phone, and not the tablet. This can be done by adding these lines of code after you've declared the board variable:</p><div class="informalexample"><pre class="programlisting">if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
  board.scale = 0.8;</pre></div><p>Conversely, if you wish to detect an iPad, just use <code class="literal">UIUserInterfaceIdiomPad</code> instead.</p><p>Now, if you run it on a phone (whether it's your own or the simulator), you'll see that the grid is nicely within the screen's bounds.</p></div><div class="section" title="Defining and adding a unit to the screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>Defining and adding a unit to the screen</h2></div></div></div><p>Since<a id="id172" class="indexterm"/> each unit is basically the same, except with a different color and <a id="id173" class="indexterm"/>number, we should define ourselves a class. To do that, we follow the same instructions regarding a new scene, except that this time, we're going to call the <code class="literal">Unit</code> class and set the subclass as a <code class="literal">CCSprite</code> type.</p><div class="mediaobject"><img src="../Images/image00234.jpeg" alt="Defining and adding a unit to the screen"/></div><p style="clear:both; height: 1em;"> </p><p>Open <code class="literal">Unit.h</code>, and make it look like the following:</p><div class="informalexample"><pre class="programlisting">#import "CCSprite.h"

NS_ENUM(NSInteger, UnitDirection)
{
  DirUp,
  DirDown,
  DirLeft,
  DirRight,
  DirStanding //for when a new one spawns at the center
};

@interface Unit : CCSprite

@property (nonatomic, assign) NSInteger unitValue;
@property (nonatomic, assign) BOOL isFriendly;
@property (nonatomic, assign) enum UnitDirection direction;
//9x9 grid, 1,1 is top left, 9,9 is bottom right
@property (nonatomic, assign) CGPoint gridPos;
@property (nonatomic, strong) CCColor *color;
@property (nonatomic, strong) CCLabelBMFont *lblValue;

+(Unit*)friendlyUnit;
+(Unit*)enemyUnitWithNumber:(NSInteger)value atGridPosition:(CGPoint)pos;
@end</pre></div><p>This <a id="id174" class="indexterm"/>will basically allow us to give our units a move direction. We also get a <a id="id175" class="indexterm"/>value associated with them, a Boolean to determine whether it's a friendly unit or not (needed for both movement as well as collisions), and various other stuff.</p><p>Now open <code class="literal">Unit.m</code> and add the following code between <code class="literal">@implementation</code> and <code class="literal">@end</code>:</p><div class="informalexample"><pre class="programlisting">+(Unit*)friendlyUnit
{
  return [[self alloc] initWithFriendlyUnit];
}

+(Unit*)enemyUnitWithNumber:(NSInteger)num atGridPosition:(CGPoint)pos
{
  return [[self alloc] initWithEnemyWithNumber:num atPos:pos];
}

-(id)initCommon
{
  if ((self=[super initWithImageNamed:@"imgUnit.png"]))
  {
    if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
      self.scale = 0.8;
    
    self.lblValue = [CCLabelBMFont labelWithString:@"1" fntFile:@"bmFont.fnt"];
    self.lblValue.scale = 1.5;
    self.lblValue.position = ccp(self.contentSize.width/2, self.contentSize.height/1.75);
    [self addChild:self.lblValue];
  }
  return self;
}

-(id)initWithFriendlyUnit
{
  if ((self=[self initCommon]))
  {
    self.isFriendly = YES;
    self.unitValue = 1;
    self.direction = DirStanding;
    self.color = [CCColor colorWithRed:0 green:0.8f blue:0]; //green for friendly
    self.gridPos = ccp(5,5);
  }
  return self;
}

-(id)initWithEnemyWithNumber:(NSInteger)num atPos:(CGPoint)p
{
  if ((self=[self initCommon]))
  {
    self.isFriendly = NO;
    self.unitValue = num;
    self.lblValue.string = [NSString stringWithFormat:@"%ld", (long)num];
    self.direction = DirLeft;
    self.color = [CCColor colorWithRed:0.8f green:0 blue:0]; //red for enemy
    self.gridPos = p;
  }
  return self;
}</pre></div><p>The <code class="literal">init</code> methods set up some important stuff: position on the grid, color, whether it's a friendly <a id="id176" class="indexterm"/>unit or not, the value of the unit when it first spawns, the label in<a id="id177" class="indexterm"/> which to show the value, and the direction it intends to move on the next turn.</p><p>Let's open <code class="literal">MainScene.m</code> and spawn a friendly unit and an enemy unit on the screen. Because we defined the class so well, it's very simple to spawn two units with only a few lines of code. Make sure you include the <code class="literal">Unit.h</code> at the top too:</p><div class="informalexample"><pre class="programlisting">Unit *friendly = [Unit friendlyUnit];
friendly.position = ccp(winSize.width/2, winSize.height/2);
[self addChild:friendly];
    
Unit *enemy = [Unit enemyUnitWithNumber:1 atGridPosition:ccp(1,1)];
enemy.position = ccp(winSize.width - 50, winSize.height/2);
[self addChild:enemy];</pre></div><div class="mediaobject"><img src="../Images/image00235.jpeg" alt="Defining and adding a unit to the screen"/></div><p style="clear:both; height: 1em;"> </p><p>However, the<a id="id178" class="indexterm"/> positions still need to be calculated, and the fact that we assigned a <a id="id179" class="indexterm"/>grid coordinate doesn't mean anything to the game. We need to determine the actual positions on the screen. That is, if we say the position is (5, 5), it better know that means smack dab in the middle of the grid. However, the only place that knows the screen coordinates is the main scene, so open <code class="literal">MainScene.m</code> and add the following method to get the screen position based on a grid coordinate:</p><div class="informalexample"><pre class="programlisting">-(CGPoint)getPositionForGridCoord:(CGPoint)pos
{
  CGPoint screenPos;
  Unit *u = [Unit friendlyUnit];
  
  CGFloat borderValue = 1.f;
  if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
    borderValue = 0.6f;
  
  screenPos.x = winSize.width * 0.625 + (u.boundingBox.size.width + borderValue) * (pos.x-5);
  screenPos.y = winSize.height/2 - (u.boundingBox.size.width + borderValue) * (pos.y-5);
  
  return screenPos;
}

Now change the positioning of the units to reflect this change:
Unit *friendly = [Unit friendlyUnit];
friendly.position = [self getPositionForGridCoord:friendly.gridPos];
[self addChild:friendly];
    
Unit *enemy = [Unit enemyUnitWithNumber:2 atGridPosition:ccp(4,7)];
enemy.position = [self getPositionForGridCoord:enemy.gridPos];
[self addChild:enemy];</pre></div><p>Have a<a id="id180" class="indexterm"/> look<a id="id181" class="indexterm"/> at the following screenshot; this is how your game will now look like:</p><div class="mediaobject"><img src="../Images/image00236.jpeg" alt="Defining and adding a unit to the screen"/></div><p style="clear:both; height: 1em;"> </p><p>Running the game should get you something like what is shown in the preceding screenshot. And yes, even though this screenshot is from an iPad, the code works equally well on an iPhone of any resolution, as the formula for determining the position works on the assumption that (5, 5) is the center of the grid.</p><p>Now <a id="id182" class="indexterm"/>let's get these units moving around the screen with some touch <a id="id183" class="indexterm"/>mechanics. First, place the red unit to the right of the green in the rightmost section of the grid—(9, 5), for those who are lazy and don't want to calculate it.</p></div><div class="section" title="Moving the units around with touch controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>Moving the units around with touch controls</h2></div></div></div><p>Touch <a id="id184" class="indexterm"/>detection is extremely easy in Cocos2d. From version 3.3 onwards, all you need to do is add one line of code and a few methods, and you're good.</p><p>That being said, add this line of code to the <code class="literal">initWithFriendlyUnit</code> method of the <code class="literal">Unit</code> class (we want to enable touch only on the friendly units, not the enemies):</p><div class="informalexample"><pre class="programlisting">[self setUserInteractionEnabled:YES];

Then add the following methods in Unit.m that will intercept all touches made on each unit:
-(void)touchBegan:(CCTouch *)touch withEvent:(CCTouchEvent *)event
{
  
}

-(void)touchMoved:(CCTouch *)touch withEvent:(CCTouchEvent *)event
{
  
}

-(void)touchEnded:(CCTouch *)touch withEvent:(CCTouchEvent *)event
{
  
}</pre></div><p>These<a id="id185" class="indexterm"/> methods are fairly self-descriptive in terms of what they do. The <code class="literal">touchBegan</code> method registers a touch every time a finger touches the screen, the <code class="literal">touchMoved</code> method registers a touch every time the finger is dragged along the screen, and the <code class="literal">touchEnded</code> method registers when the finger is lifted off the screen.</p><p>In order to determine which unit is being dragged and in which direction, add these three variables to the <code class="literal">Unit.h</code> file:</p><div class="informalexample"><pre class="programlisting">@property (nonatomic, assign) BOOL isBeingDragged;
@property (nonatomic, assign) CGPoint touchDownPos;
@property (nonatomic, assign) enum UnitDirection dragDirection;</pre></div><p>Also add this method declaration:</p><div class="informalexample"><pre class="programlisting">-(void)updateLabel;</pre></div><p>Once that's done, open <code class="literal">Unit.m</code> and add code to the following methods.</p><p>First you must create this method, which will set the displayed string of the Unit's label to the Unit's actual value:</p><div class="informalexample"><pre class="programlisting">-(void)updateLabel
{
  self.lblValue.string = [NSString stringWithFormat:@"%ld", (long)self.unitValue];
}</pre></div><p>Then we need to handle our touches in order to update the label, so the following code needs to be added to the <code class="literal">touchBegan</code> method, which will grab the <code class="literal">CCTouch</code> method's location relative to where it is inside a given node. For now, we want to know where the touch is occurring relative to the <code class="literal">Unit</code> itself, and we'll set that in our <code class="literal">touchDownPos</code> variable:</p><div class="informalexample"><pre class="programlisting">self.touchDownPos = [touch locationInNode:self];
self.dragDirection = DirStanding;</pre></div><p>Then <a id="id186" class="indexterm"/>you have to add the following code to the <code class="literal">touchMoved</code> method. This will determine what direction the finger is being dragged, based on the <code class="literal">x</code> and <code class="literal">y</code> difference from <code class="literal">touchDownPos</code> and the current <code class="literal">touchPos</code> variables:</p><div class="informalexample"><pre class="programlisting">CGPoint touchPos = [touch locationInNode:self];
//if it's not already being dragged and the touch is dragged far enough away...
if (!self.isBeingDragged &amp;&amp; ccpDistance(touchPos, self.touchDownPos) &gt; 6)
{  
  self.isBeingDragged = YES;
    
  CGPoint difference = ccp(touchPos.x - self.touchDownPos.x, touchPos.y - self.touchDownPos.y);
  //determine direction
  if (difference.x &gt; 0)
  {
      if (difference.x &gt; fabsf(difference.y))
        self.dragDirection = DirRight;
      else if (difference.y &gt; 0)
        self.dragDirection = DirUp;
      else
        self.dragDirection = DirDown;
  }
  else
  {
      if (difference.x &lt; -1* fabsf(difference.y))
        self.dragDirection = DirLeft;
      else if (difference.y &gt; 0)
        self.dragDirection = DirUp;
      else
        self.dragDirection = DirDown;
  }
}</pre></div><p>Finally, add this section of code to the <code class="literal">touchEnded</code> method. This will actually update the grid position of the unit based on what direction it was being dragged in:</p><div class="informalexample"><pre class="programlisting">//if it was being dragged in the first place
if (self.isBeingDragged)
{
  CGPoint touchPos = [touch locationInNode:self];
  //stop the dragging
  self.isBeingDragged = NO;
    
  if (ccpDistance(touchPos, self.touchDownPos) &gt; self.boundingBox.size.width/2)
  {
      NSInteger gridX, gridY;
      gridX = self.gridPos.x;
      gridY = self.gridPos.y;
      
      //move unit that direction
      if (self.dragDirection == DirUp)
        --gridY;
      else if (self.dragDirection == DirDown)
        ++gridY;
      else if (self.dragDirection == DirLeft)
        --gridX;
      else if (self.dragDirection == DirRight)
        ++gridX;
      
      //keep within the grid bounds
      if (gridX &lt; 1) gridX = 1;
      if (gridY &gt; 9) gridX = 9;
      
      if (gridY &lt; 1) gridY = 1;
      if (gridY &gt; 9) gridY = 9;
      
      //if it's not in the same place... aka, a valid move taken
      if (!(gridX == self.gridPos.x &amp;&amp; gridY == self.gridPos.y))
      {
        self.gridPos = ccp(gridX, gridY);
        self.unitValue++;
        self.direction = self.dragDirection;
        [self updateLabel];
      }
  }
}</pre></div><p>Now, if <a id="id187" class="indexterm"/>you run the game, you'll see that when you tap (or click, if running on the simulator) and drag that unit… oh my! Why isn't the unit moving? We set the grid coordinate and everything! Even the unit's value is being increased properly.</p><p>But aye! We <a id="id188" class="indexterm"/>didn't tell the main scene that the unit needed to be moved, since that's where the unit positioning happens. That being said, we want a way to let our main scene know that a unit was moved so that we can update its position.</p></div><div class="section" title="Talking between scenes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>Talking between scenes</h2></div></div></div><p>A very <a id="id189" class="indexterm"/>common way to do this is by making use of <code class="literal">NSNotificationCenter</code>. It's broken down into two parts: a sender and a receiver. The sender is called a notification and the receiver is called an observer. What we need to do is send a notification through <code class="literal">NSNotificationCenter</code> so that any observer set up can receive the notification.</p><p>First, we need to declare a constant to reduce human errors when coding. We want to do this because the notifications need to be exact, or else they won't work.</p><p>So, open <code class="literal">Unit.h</code> and add this line below <code class="literal">#import</code> but above <code class="literal">NS_ENUM</code>:</p><div class="informalexample"><pre class="programlisting">FOUNDATION_EXPORT NSString *const kTurnCompletedNotification;</pre></div><p>Then, at the top of <code class="literal">Unit.m</code>, below the <code class="literal">#import</code> statement but above <code class="literal">@implementation</code>, insert this line of code:</p><div class="informalexample"><pre class="programlisting">NSString *const kTurnCompletedNotification = @"unitDragComplete";</pre></div><p>It doesn't entirely matter what the string is; it's just that it has to be something unique from any other notification you end up creating later on.</p><p>Then go ahead and add this little line of code right below the <code class="literal">[self updateLabel]</code> line in the <code class="literal">touchEnded</code> method of <code class="literal">Unit.m</code>:</p><div class="informalexample"><pre class="programlisting">//pass the unit through to the MainScene
[[NSNotificationCenter defaultCenter] postNotificationName:kTurnCompletedNotification object:nil userInfo:@{@"unit" : self}];</pre></div><p>This will send a notification to the observer that something has happened. In this case, we want to notify the main scene that the current unit has been moved via dragging and needs its position updated. That's why we pass <code class="literal">self</code> (the current Unit)—so that we can update the position of the specific unit that was moved.</p><p>Finally, let's hop over to <code class="literal">MainScene.m</code> and add the following code at the bottom of (or top of; it's your preference) the <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(moveUnit:) name:kTurnCompletedNotification object:nil];</pre></div><p>Then add the following methods: <code class="literal">moveUnit</code> and <code class="literal">dealloc</code>. The <code class="literal">moveUnit</code> method is what we want called when the notification <a id="id190" class="indexterm"/>gets pushed. We have an <code class="literal">NSNotification</code> parameter that grabs the <code class="literal">NSDictionary</code> parameter passed from the <code class="literal">Unit</code> class. We also need the <code class="literal">dealloc</code> to remove the observer, or else it could catch future notifications by accident, and that can cause the game to crash:</p><div class="informalexample"><pre class="programlisting">-(void)moveUnit:(NSNotification*)notif
{
  NSDictionary *userInfo = [notif userInfo];
  Unit *u = (Unit*)userInfo[@"unit"];
  u.position = [self getPositionForGridCoord:u.gridPos];
}

-(void)dealloc
{
  [[NSNotificationCenter defaultCenter] removeObserver:self];
}</pre></div><p>Hurray! Now when you run the code, you should get the unit shifting from grid spot to grid spot with each swipe, in any direction. Now it's starting to feel like a game. However, it still lacks interaction with the enemies, and none of the scores are being increased. Let's add that next.</p></div><div class="section" title="Interaction with enemies and scoring"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Interaction with enemies and scoring</h2></div></div></div><p>First, we<a id="id191" class="indexterm"/> need some variables to keep track of the numbers. So in <code class="literal">MainScene.h</code>, add this under the BMFont label variables:</p><div class="informalexample"><pre class="programlisting">NSInteger numTurnSurvived, numUnitsKilled, numTotalScore;</pre></div><p>In <code class="literal">MainScene.m</code>, add the following method to update the label for each counter:</p><div class="informalexample"><pre class="programlisting">-(void)updateLabels
{
  lblTotalScore.string = [NSString stringWithFormat:@"%ld", (long)numTotalScore];
  lblTurnsSurvived.string = [NSString stringWithFormat:@"%ld", (long)numTurnSurvived];
  lblUnitsKilled.string = [NSString stringWithFormat:@"%ld", (long)numUnitsKilled];
}</pre></div><p>Add these lines to the <code class="literal">moveUnit</code> method to increment the respective numbers:</p><div class="informalexample"><pre class="programlisting">++numTurnSurvived;
++numTotalScore;
[self updateLabels];</pre></div><p>Then initialize the variables somewhere in the <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">numTotalScore = 1;
numTurnSurvived = 0;
numUnitsKilled = 0;</pre></div><p>Now you'll notice that each time your unit moves around, the score and the <code class="literal">turns survived</code> labels increases by 1. But the unit can still go straight through the enemy unit. Let's fix that.</p><p>First, we<a id="id192" class="indexterm"/> need to compare the grid locations after a move with all possible enemies on the screen to see whether there was a collision. However, if we're going to cycle through all the enemies, it means we'll need an array to hold them all, so we declare an <code class="literal">NSMutableArray</code> parameter in the <code class="literal">MainScene.h</code> file:</p><div class="informalexample"><pre class="programlisting">NSMutableArray *arrEnemies;</pre></div><p>At the bottom of the <code class="literal">init</code> method in the <code class="literal">MainScene.m</code> file, after you spawn the enemy, add the following lines of code:</p><div class="informalexample"><pre class="programlisting">arrEnemies = [[NSMutableArray alloc] init];
[arrEnemies addObject:enemy];</pre></div><p>At the end of the <code class="literal">moveUnit</code> method, we need to cycle through all the enemies and check whether the grid location is the same (that is, whether we're about to run into an enemy):</p><div class="informalexample"><pre class="programlisting">//for each Unit in the arrEnemies array...
for (Unit *enemy in arrEnemies)
{
  if (enemy.gridPos.x == u.gridPos.x &amp;&amp;
     enemy.gridPos.y == u.gridPos.y)
  {
     //collision!
       
  }
}</pre></div><p>Under the collision comment, we now want to compare the unit values. Whichever unit has the higher value will win, and the unit with the lower value will be removed from the board (and the array). In the case of a tie, both will be removed. It's also important to update the <code class="literal">unitsKilled</code> counter here:</p><div class="informalexample"><pre class="programlisting">{
      //collision!      
      NSInteger enemyVal = enemy.unitValue;
      NSInteger friendVal = u.unitValue;
      
      //tie, both dead
      if (enemyVal == friendVal)
      {
        [self removeChild:u];
        [arrEnemies removeObject:enemy];
        [self removeChild:enemy];
        ++numUnitsKilled;
      }
      //enemy higher
      else if (enemy.unitValue &gt; u.unitValue)
      {
        enemy.unitValue -= friendVal;
        [enemy updateLabel];
        [self removeChild:u];
      }
      //friendly higher
      else
      {
        u.unitValue -= enemyVal;
        [u updateLabel];
        [arrEnemies removeObject:enemy];
        [self removeChild:enemy];
        ++numUnitsKilled;
      }
      
      //exit the for loop so no "bad things" happen
      break;
  }</pre></div><p>Finally, move<a id="id193" class="indexterm"/> the <code class="literal">[self updateLabels]</code> method call in the <code class="literal">moveUnit</code> method to the end of the method (that is, after the loop ends), or else the <code class="literal">unitsKilled</code> label won't be updated until the next turn, which might confuse your players.</p><p>That's it! You can move around, run into enemies, combine your score, have the labels updated, and even restart the game if you lose (by going to <span class="strong"><strong>Menu</strong></span> and tapping the <span class="strong"><strong>Play</strong></span> button). Here's what the game more or less looks like so far.</p><p>On an iPad, the game scene appears as follows:</p><div class="mediaobject"><img src="../Images/image00237.jpeg" alt="Interaction with enemies and scoring"/></div><p style="clear:both; height: 1em;"> </p><p>On <a id="id194" class="indexterm"/>an iPhone 5, the game scene appears like this:</p><div class="mediaobject"><img src="../Images/image00238.jpeg" alt="Interaction with enemies and scoring"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Creating menus, scenes, and scene transitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Creating menus, scenes, and scene transitions</h1></div></div></div><p>Scenes<a id="id195" class="indexterm"/> make up the core of Cocos2d. When you go from the main<a id="id196" class="indexterm"/> menu to the <span class="strong"><strong>Level Select</strong></span> screen, those are (when done in a best <a id="id197" class="indexterm"/>practice coding way) two different scenes. You can transition from one scene to another in any way your heart desires. However, it's generally done by tapping a button. For example, <span class="strong"><strong>Play</strong></span>, <span class="strong"><strong>Settings</strong></span>, and <span class="strong"><strong>Shop</strong></span> are all examples of a menu button that a user might press to trigger a scene transition.</p><div class="section" title="Creating a new file for the scene"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Creating a new file for the scene</h2></div></div></div><p>Most <a id="id198" class="indexterm"/>likely, your game isn't going to have just one screen. If so, then you can skim over this as it likely won't pertain to you. However, the vast majority of games made have at the very least a main menu, a settings menu, a pause screen, and some sort of screen besides the main game screen.</p><p>The next few screenshots show how to create a file with a <code class="literal">CCNode</code> object as the parent class. If you already know how to do this, feel free to skip to the next step.</p><p>In Xcode, right-click (or press <span class="emphasis"><em>Ctrl</em></span> and click) on the source folder at the top of the project navigator, and then click on <span class="strong"><strong>New File</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00239.jpeg" alt="Creating a new file for the scene"/></div><p style="clear:both; height: 1em;"> </p><p>In the<a id="id199" class="indexterm"/> dialog window that opens, under the iOS <span class="strong"><strong>Source</strong></span> section, select <span class="strong"><strong>Cocoa Touch Class</strong></span> and click on <span class="strong"><strong>Next</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00240.jpeg" alt="Creating a new file for the scene"/></div><p style="clear:both; height: 1em;"> </p><p>Name the class something relevant, as you may have to go back to it later. We're going to use <code class="literal">MenuScene</code> as<a id="id200" class="indexterm"/> the name of our class. Once you've named the class, click on <span class="strong"><strong>Next</strong></span>.</p><div class="note" title="Note"><h3 class="title"><a id="tip16"/>Tip</h3><p>Make sure you change <span class="strong"><strong>Subclass of</strong></span> to <code class="literal">CCNode</code>, or else you'll be unable to make a new scene out of it.</p></div><div class="mediaobject"><img src="../Images/image00241.jpeg" alt="Creating a new file for the scene"/></div><p style="clear:both; height: 1em;"> </p><p>Talking about where to save the file, it's recommended to keep all of your project's class files in the same directory. As shown in the following screenshot, we're saving the <span class="strong"><strong>MenuScene</strong></span> file we wish to create in the <code class="literal">Source</code> folder, where the <span class="strong"><strong>MainScene</strong></span> files are located. </p><p>Once you've chosen a location, click on <span class="strong"><strong>Create</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00242.jpeg" alt="Creating a new file for the scene"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Turning a class into an official CCScene subclass"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>Turning a class into an official CCScene subclass</h2></div></div></div><p>It's <a id="id201" class="indexterm"/>not officially a scene yet, but that's what we're going to add now. In the header file of the class you just created, add a similar block of code between the <code class="literal">@interface</code> and <code class="literal">@end</code> lines—like what we have in the <code class="literal">MainScene.m</code> file. For example, your header might look something like this:</p><div class="informalexample"><pre class="programlisting">@interface MenuScene : CCNode
{
  CGSize winSize;
}
+(CCScene*)scene;
@end</pre></div><p>Then, in the main file for the class, add the following between the <code class="literal">@implementation</code> and <code class="literal">@end</code> lines (yes, it's a copy-paste job for each scene you create):</p><div class="informalexample"><pre class="programlisting">+(CCScene *)scene
{
  return [[self alloc] init];
}

-(id)init
{
  if ((self=[super init]))
  {

  }
  return self;
}</pre></div><p>With that in place, you can now begin to add code to the main menu scene. Let's quickly add a<a id="id202" class="indexterm"/> background color to the <code class="literal">init</code> method so that we know the scene works when we eventually link a button and transition to it. We're going to give it a random green color, because the default is black:</p><div class="informalexample"><pre class="programlisting">-(id)init
{
  if ((self=[super init]))
  {
    //these values range 0 to 1.0, so use float to get ratio
    CCNode *background = [CCNodeColor nodeWithColor:[CCColor colorWithRed:58/255.f green:138/255.f blue:88/255.f]];
    [self addChild:background];
  }
  return self;
}</pre></div></div><div class="section" title="Linking the button in the game to go to the menu"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Linking the button in the game to go to the menu</h2></div></div></div><p>Open <code class="literal">MainScene.m</code>, and include the scene you created at the top of the file:</p><div class="informalexample"><pre class="programlisting">#import "MainScene.h"
#import "MenuScene.h" //the line to add. Note: it says MENU scene, not MAIN scene. They're similar, but different. We want both here.

@implementation MainScene</pre></div><p>Then<a id="id203" class="indexterm"/> go to the section of code where you declared the <span class="strong"><strong>Menu</strong></span> button. Right after you declare it, add the following line of code. This will connect the menu button to a method called <code class="literal">goToMenu</code>. The <code class="literal">setTarget</code> method is the way <code class="literal">CCButton</code> knows what to do when it gets tapped:</p><div class="informalexample"><pre class="programlisting">[btnMenu setTarget:self selector:@selector(goToMenu)];</pre></div><p>Then, below the <code class="literal">init</code> method, add the <code class="literal">goToMenu</code> method, like this:</p><div class="informalexample"><pre class="programlisting">-(void)goToMenu
{
  [[CCDirector sharedDirector] replaceScene:[MenuScene scene]];
}</pre></div><p>With these three things added, you should be able to run the game and click on the menu button. Voilà! We have a transition to the <code class="literal">Menu</code> scene, albeit rather ugly at the moment. But <a id="id204" class="indexterm"/>there's no way to get back to the game screen, so let's add a <span class="strong"><strong>Play</strong></span> button to do so.</p></div><div class="section" title="Creating and linking a button in the menu to go to the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>Creating and linking a button in the menu to go to the game</h2></div></div></div><p>Now that <a id="id205" class="indexterm"/>we're able to get to the <span class="strong"><strong>Menu</strong></span> scene, let's quickly <a id="id206" class="indexterm"/>add a <span class="strong"><strong>Play</strong></span> button so that we can start to create the core of the gameplay and round out this prototype.</p><p>First, add the <span class="strong"><strong>Play</strong></span> button to TexturePacker, save, and publish. Then open <code class="literal">MenuScene.m</code> and add the following to the <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">winSize = [CCDirector sharedDirector].viewSize;
CCButton *btnPlay = [CCButton buttonWithTitle:@"" spriteFrame:[CCSpriteFrame frameWithImageNamed:@"btnPlay.png"]];
btnPlay.position = ccp(winSize.width/2, winSize.height/2);
[btnPlay setTarget:self selector:@selector(goToGame)];
[self addChild:btnPlay];</pre></div><p>Also add the <code class="literal">goToGame</code> method below <code class="literal">init</code> so that the button actually has a method to call:</p><div class="informalexample"><pre class="programlisting">-(void)goToGame
{
  [[CCDirector sharedDirector] replaceScene:[MainScene scene]];
}</pre></div><p>Run the project and click on the <span class="strong"><strong>Menu</strong></span> button. You should see a clickable <span class="strong"><strong>Play</strong></span> button that will take you back to the game. Yay, scene transitions! Now that the play button is in place and we have the basic layout between scenes, we can get working on the core of the game.</p><p>One final thing you could do would be to create a <code class="literal">restartGame</code> method, set the target of the <span class="strong"><strong>Restart</strong></span> button to <code class="literal">self</code>, and set the selector of the restart button to the <code class="literal">restartGame</code> method. Inside the <code class="literal">restartGame</code> method you have created, simply call the <code class="literal">replaceScene</code> method (like what you just did), but this time, use <code class="literal">MainScene</code> instead of <code class="literal">MenuScene</code> so that the scene transitions to a fresh/clean/new/whatever version of itself. This is a good idea because this is the minimal code for the very effect we're trying to achieve here.</p></div></div>
<div class="section" title="Where to go from here?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Where to go from here?</h1></div></div></div><p>It's quite clear that the project is far from complete at this stage. However, there are a lot of things that are a core of the game's implementation: the dragging, the scoring, and the grid formation. From here on, it's probably best to continue to iterate on the project and slowly add stuff until it's a fully working prototype with very minimal baseline mechanics working. For example, we could add some enemy spawning, <span class="strong"><strong>Artificial Intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>), the user's units automatically moving, and so on.</p><p>But as far as this book is concerned, we're going to move on as the point of this chapter was to go straight into a prototype. That's basically what we have here—something we can show our friends and family and say, "Hey, this is what the concept is, and this is what I've got so far." With the prototype, you can gauge things such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Is the game board too small for the player's fingers?</li><li class="listitem">Is the concept too confusing?</li><li class="listitem">Is it hard to interact with the character?</li></ul></div><p>With time, all of these will be sorted, but it's better to learn about the biggest problems early on rather than find them after your game has been published on the App Store and you notice that nobody is downloading it.</p><div class="section" title="Some suggestions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>Some suggestions</h2></div></div></div><p>If you're following the book's tutorial/example project (which I hope you are), try adding the following on your own, all of which will be added outside this book for consolidation purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Automatically moving the red unit each turn and increasing its score</li><li class="listitem">Spawning a red unit every three or four turns around the border and adding it to the array (and possibly implementing the movement as you did with the previous red unit)</li><li class="listitem">Spawning another friendly unit with a value of <code class="literal">1</code> when you move away from (5, 5)</li><li class="listitem">Creating and maintaining a friendly unit array</li><li class="listitem">Making all friendly units move in the direction they were last instructed</li></ul></div><p>Don't worry if you don't want to take the time to implement these by yourself. A later chapter will have them pre-implemented, and you can download the source code to get an up-to-date version before you begin that chapter.</p><p>However, it is highly recommended that you do try coding on your own, as that's the entire point of this book—to push you further as a coder. The tutorials are here for support, but the main purpose is to show you cool things and let you run loose with the tools at your disposal.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>A prototype for the game, as shown in this chapter, can be done relatively quickly (not that many pages compared to how much content was put in). If you have a large-scale game (which is almost certainly the case), now would be the best time to go about creating the other scenes, adding buttons that link the scenes together, creating the characters in the game, and even adding some baseline code for the core of the game.</p><p>In general, the way to prototype quickly and iterate more often is to get the simplest parts that draw a wireframe of the project first so that the people holding the prototype can fill the gaps with their imagination (or if you hand them a near-complete project, they won't have to fill any gaps). It's like drawing a person on a piece of paper. First, you draw a rough version of their body position, then fill in a bit of the muscle and fat, and finally draw the details such as fingers, clothes, facial expressions, and so on.</p><p>In the next chapter, we'll cover in depth how to create some really awesome mechanics and do with Cocos2d what most developers don't do.</p></div></body></html>