<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Optimizing Your UI</h1></div></div></div><p>Your app's user interface is your most direct connection to the user, so you'll want to make sure it's <em>perfect</em>.</p><p>Up until now we've concentrated on creating a beautifully designed user interface that's packed with useful features—but this is only half the battle. If your app is going to rack up those 5-star Google Play reviews, you'll need to create a UI that's quick to render, responsive, and generally delivers an all-around great user experience.</p><p>Performance is crucial to creating a successful UI, and a successful app in general. If your app is laggy, prone to crashing, gobbles up data and memory, or drains the user's battery, then no one is going to want to use it, no matter how good your UI looks!</p><p>In this chapter, I'm going to show you how to hunt out all the most common performance problems that may be impacting your app. Since you'll want to fix any problems you do encounter, along the way I'll also be touching on some of the reasons why these problems occur in the first place, and the steps you can take to address them.</p><p>By the time you've completed this chapter, you'll know how to create a smooth and responsive UI that people will <em>love</em> using.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Timing your code</h1></div></div></div><p>Don't wait for your app to start throwing errors before you go looking for performance-related problems. Your app could be slowly leaking memory, allocating too many objects, or struggling under the weight of a complex view hierarchy. None of these will necessarily throw an error, but they'll definitely have a negative impact on your app's performance.</p><p>If you're going to create a high-performance app, you need to go <em>looking</em> for problems.</p><p>Timing your code is a powerful way of seeing <em>exactly</em> what's going on in your app, including any sections of code that are running slower or longer than others. The first Android SDK tool we're going to look at lets you do just that.</p><p>
<strong>TraceView</strong> is a graphical viewer that can profile any Android app running on your device.</p><p>TraceView, like most of the tools we're going to cover in this chapter, can only measure a running application. So the first step is to install the app you want to test on your Android device, and then attach that device to your computer. Alternatively, you could use an emulator and suitable AVD. Make sure your app is running and its UI is visible.</p><div><div><h3 class="title"><a id="tip99"/>Tip</h3><p>
<strong>Before and after—measuring your app's performance</strong></p><p>When you discover a problem with your app, obviously you're going to want to fix that problem. But after you've made some changes, how do you know that the problem is truly fixed?</p><p>If you use TraceView to measure your app's performance before and after you make your changes, you'll have all the data you need to see whether your optimizations have had any significant impact on your app's performance. So even if you don't identify any code that needs optimizing, TraceView's output is still valuable data that you should keep to hand and refer back to as you work on optimizing your app.</p></div></div><p>To launch TraceView, select <strong>Tools</strong> from the Android Studio toolbar, followed by <strong>Android</strong> and <strong>Android Device Monitor</strong>. The <strong>Android Device Monitor</strong> will open in a new window.</p><div><div><h3 class="title"><a id="note100"/>Note</h3><p>The <strong>Android Device Monitor</strong> is a standalone tool that's included as part of the Android SDK. Throughout this chapter, I'll be using several tools that are included in the <strong>Android Device Monitor</strong>. Although I'll be accessing the <strong>Android Device Monitor</strong> via the Android Studio user interface throughout this chapter, you can also launch the <strong>Android Device Monitor</strong> separately. If you want to bypass Android Studio, or if you're using Eclipse, you can launch the <strong>Android Device Monitor</strong> by finding the <code class="literal">monitor</code> file in your Android SDK download and double-clicking it. The <strong>Android Device Monitor</strong> will then open in a new window.</p></div></div><p>In the <strong>Android Device Monitor</strong> window, select the <strong>DDMS</strong> tab. Along the left-hand side of the screen you'll find a <strong>Devices </strong>tab that lists all the currently detected devices and emulators. Select the device or AVD that contains your app, and you'll see a list of all the processes that are running on this device. Select the process you want to profile.</p><p>If you don't see your application in the list, check it's running and that its UI is visible.</p><p>Start method profiling by clicking the Start Method Profiling icon (where the cursor is positioned in the following screenshot):</p><p>
</p><div><img src="img/B05061_9_1.jpg" alt="Timing your code"/></div><p>
</p><p>At this point, you'll be presented with two profiling options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Trace-based profiling</strong>: Traces the entry and exit of <em>every </em>method, no matter how small. This kind of profiling has a massive overhead, so you should only trace everything when you have absolutely no idea what to profile. You can then use this data to narrow your search for a follow-up round of sample-based profiling.</li><li class="listitem" style="list-style-type: disc"><strong>Sample-based profiling</strong>: Collects the call stacks at a frequency specified by you. With this kind of profiling, the overhead is proportional to the sampling frequency, so the overhead is generally much more manageable.</li></ul></div><p>Make your selection and TraceView will start recording. Spend some time interacting with your app, making sure to interact with all the sections and methods you want to profile. Then, click the Stop Method Profiling icon and DDMS will pull the trace file from your device and load it in the viewer.</p><div><div><h3 class="title"><a id="note101"/>Note</h3><p>Depending on how much recording you've done, this data may take a few moments to launch, so you may need to be patient.</p></div></div>You'll end up with a trace file that looks something like this:
<p>
</p><div><img src="img/B05061_9_2.jpg" alt="Timing your code"/></div><p>
</p><p>A trace file consists of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Timeline panel:<p>This panel displays where each thread and method started and stopped, so you can track how your code is executing over time.</p><p>The timeline panel displays each thread's execution on its own row, in a different color. You'll see a spike where each method starts (the left bar) and stops (the right bar). The line between these points is the amount of time it took the method to execute.</p><p>If you spot any long lines of the same color, this is an indication that this method is eating up processing time and you should gather more information about this method. Click on any method you want to learn more about, and its stats will appear in the Profile panel.</p></li><li class="listitem" style="list-style-type: disc">Profile Panel:<p>This panel provides lots of information about what happened inside the currently selected method, including how many times that method was called, how many times it was called recursively, and the percentage of total CPU time used by this method, inclusive and exclusive of the execution time of all its child methods. This data helps you identify any methods that need optimizing.</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Identifying overdraw</h1></div></div></div><p>When Android draws the screen, it starts with the highest-level container and then draws all the children and grandchildren on top of this parent view. This means that an individual pixel may be drawn more than once in a single cycle, in a process known as <strong>overdraw</strong>.</p><p>Coloring pixels that are only going to end up getting covered by subsequent views is a waste of processing power, and the more times you paint the screen, the more overdraw you're adding.</p><p>Overdraw is a particular problem for mobile devices such as Android, which have limited memory bandwidth to begin with and may struggle with GPU-intensive drawing tasks. By identifying and rectifying unnecessary or excessive overdraw, you'll increase your app's rendering speed.</p><div><div><h3 class="title"><a id="note102"/>Note</h3><p>Large amounts of overdraw can also indicate more serious problems with your user interface, so checking the amount of overdraw in your app can also point you in the direction of areas you should investigate further.</p></div></div><p>It's unrealistic to try and eliminate <em>every</em> instance of overdraw, as some areas of overdraw are normal and unavoidable. If your app has a blue background, then every element you place on top of that background is going to cause some overdraw, but this is unavoidable—can you imagine releasing an app that's just a single blue screen, and nothing else?</p><p>You only need to worry about excessive amounts of overdraw, such as multiple full-screen layers, or overdraw that doesn't contribute anything to the final image the user sees on screen, such as content that's completely hidden behind other views.</p><p>Android devices running 4.2 and higher have a built-in feature that lets you see the amount of overdraw present in any app installed on your Android device (and even the amount of overdraw present throughout the Android system, if you're curious about that sort of thing).</p><p>To see the amount of overdraw that's occurring in your app, install the app you want to test on a physical Android device running 4.2 or later. Then open your device's <strong>Settings</strong>, followed by <strong>Developer options</strong>. Give <strong>Debug GPU Overdraw</strong> a tap, and select <strong>Show overdraw areas</strong> from the pop-up that appears:</p><p>
</p><div><img src="img/B05061_9_3.jpg" alt="Identifying overdraw"/></div><p>
</p><div><div><h3 class="title"><a id="note103"/>Note</h3><p>The <strong>Debug GPU overdraw</strong> pop-up contains a <strong>Show areas for Deuteranomaly</strong> option, which serves the same purpose as the standard <strong>Debug GPU Overdraw</strong>, but with color correction to compensate for people with deuteranopia color blindness (reduced sensitivity to green light).</p></div></div><p>With this option selected, the Android system colors each area of the screen differently, depending on how many times each pixel has been drawn and redrawn.</p><p>
</p><div><img src="img/B05061_9_4.jpg" alt="Identifying overdraw"/></div><p>
</p><p>These colors are your guide to areas where overdraw is a particular problem:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>No Color = no overdraw</strong>: These pixels were painted once.</li><li class="listitem" style="list-style-type: disc"><strong>Blue</strong>: An overdraw of 1x, so these pixels were painted twice. In other words, the screen was drawn once, and then drawn again on top. Although the amount of overdraw you can afford varies from device to device, the majority of devices should be able to handle a single level of overdraw. Large areas of blue are acceptable, but if the entire window is blue then you may want to investigate further to see whether you can strip away some of this overdraw.</li><li class="listitem" style="list-style-type: disc"><strong>Green</strong>: An overdraw of 2x. These pixels were painted three times. Medium-sized areas of green are okay, but if more than half of your screen is green you should look into whether you can optimize some of this green away.</li><li class="listitem" style="list-style-type: disc"><strong>Light red</strong>: An overdraw of 3x. Some small areas of light red may be unavoidable, but any medium or large areas of red are a cause for concern.</li><li class="listitem" style="list-style-type: disc"><strong>Dark red</strong>: An overdraw of 4x, which means this pixel was painted at least five times—possibly even more! You should <em>always </em>investigate any dark red areas.</li></ul></div><p>When you're investigating an area of excessive overdraw, your first stop should be checking out the layout's corresponding XML file to see whether there's any obvious areas of overlap. In particular, be on the lookout for:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Any drawables that aren't visible to the user.</li><li class="listitem" style="list-style-type: disc">Any backgrounds that are being drawn on top of one another, particularly full-screen backgrounds. If your UI has several layers of background before your app even starts drawing its content, then you're inevitability going to end up with some serious overdraw.</li><li class="listitem" style="list-style-type: disc">Any areas that draw a white background on top of another white background.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewGroups</code> nested inside <code class="literal">ViewGroups</code>. Look into whether you can replace these multiple <code class="literal">ViewGroups</code> with a <code class="literal">RelativeLayout</code>.</li></ul></div><p>Another tool that's useful for identifying unnecessary views and nested layouts is the <strong>Hierarchy View</strong> tool that comes with the Android SDK and is accessed through the <strong>Android Device Monitor</strong>.</p><p>Like many of the diagnostic tools I'll be using throughout this chapter, <strong>Hierarchy View</strong> can only communicate with an app that's running in an AVD or a physical Android device. However, unlike the other diagnostic tools, <strong>Hierarchy View</strong> can only connect to a device that's running a developer version of the Android operating system. If you <em>don't </em>have a developer device, you can get around this restriction by adding the <code class="literal">ViewServer</code> class (<a class="ulink" href="https://github.com/romainguy/ViewServer">https://github.com/romainguy/ViewServer</a>
) to your project.</p><p>If you're using a physical Android device, you also need to make sure debugging is enabled. Open your device's <strong>Settings</strong>, followed by <strong>Developer options</strong>, and then drag the <strong>Android debugging</strong> slider to the <strong>On</strong> position.</p><p>Open the Android Device Monitor (by selecting <strong>Tools</strong> | <strong>Android |<strong> </strong>
</strong>
<strong>Android Device Monitor</strong>) and click the <strong>Hierarchy View</strong> button (where the cursor is positioned in the following screenshot):</p><p>
</p><div><img src="img/B05061_9_5.jpg" alt="Identifying overdraw"/></div><p>
</p><p>Select your device from the <strong>Windows</strong> tab and you'll see a list of all the Activity objects running on the selected device, listed by component name.</p><p>To populate the various <strong>Hierarchy View</strong> panes, click the blue <strong>load the view hierarchy into the tree view</strong> icon. Depending on how complex your app's view hierarchy is, the tree may take some time to load.</p><p>Once your project's <strong>Hierarchy View</strong> has loaded, you may want to spend some time exploring that hierarchy in the various windows (I'll be discussing these in more detail in the next section), but one of the quickest and easiest ways of identifying large areas of overdraw is to export the Activity's hierarchy as a Photoshop document.</p><p>When you create a PSD document from the <strong>Hierarchy View</strong> output, each <code class="literal">View</code> is displayed as a separate layer. This means you can use the PSD document to peel back each layer of your app, and see exactly what each layer is contributing to your UI. Inspecting each layer can help you identify sources of overdraw, or if you already suspect that certain areas of your app are suffering from overdraw, then you can put your theory to the test by hiding the different layers and seeing how this impacts the final rendered image the user sees on screen.</p><p>To export your hierarchy as a Photoshop document, click the <strong>Capture the window layers as a Photoshop document</strong> icon (where the cursor is positioned in the following screenshot):</p><p>
</p><div><img src="img/B05061_9_6.jpg" alt="Identifying overdraw"/></div><p>
</p><p>This button generates a PSD file that you can inspect in Adobe Photoshop or in any image-editing tool that supports PSD files, such as the free and open source Gimp program (<a class="ulink" href="https://www.gimp.org">https://www.gimp.org</a>).</p><p>
</p><div><img src="img/B05061_9_7.jpg" alt="Identifying overdraw"/><p>Examining the layers of our application in GIMP</p></div><p>
</p><p>Spend some time exploring the different layers that make up your UI.</p><p>This PSD document is particularly useful for identifying one of the major causes of overdraw: multiple white backgrounds. Multiple white backgrounds can be difficult to spot, so one trick is to replace the white backgrounds in your PSD file with different images. You can then check what portions of these images are visible as you move through the different layers of your UI.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Simplifying your Hierarchy View</h1></div></div></div><p>Another common cause of performance problems is your app's <strong>Hierarchy View</strong>.</p><p>When the Android system renders each view, it goes through three stages: measure, layout, and draw. The time it takes the system to complete each stage is affected by the number of views in your hierarchy, and how these views are arranged.</p><p>Arranging your views in deeper, more complex, hierarchies will have a noticeable impact on your app's rendering speed. You should be on the lookout for any opportunities to flatten your view hierarchy and remove nested layouts.</p><p>As well as highlighting areas of overdraw, <strong>Hierarchy View</strong> helps you visualize your app's view hierarchy and provides some really useful performance information about how long each view takes to render.</p><p>The <strong>Hierarchy View</strong> tool consists of three different windows.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec115"/>Tree View</h2></div></div></div><p>This window provides a bird's eye view of the currently selected Activity's view hierarchy:</p><p>
</p><div><img src="img/B05061_9_8.jpg" alt="Tree View"/></div><p>
</p><p>Each node in Tree View represents a single <code class="literal">View</code>. When you select a node, additional information about that <code class="literal">View</code> appears in a small window above the node:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>View class</strong>: The object's class</li><li class="listitem" style="list-style-type: disc"><strong>View object address</strong>: A pointer to the <code class="literal">View </code>object</li><li class="listitem" style="list-style-type: disc"><strong>View object ID</strong>: The value of the object's <code class="literal">android:id</code> attribute</li></ul></div><p>You'll also see a preview of how this <code class="literal">View</code> will appear on an Android device. By seeing exactly what each <code class="literal">View</code> is contributing to the final UI, you can decide whether this <code class="literal">View</code> is adding anything of value. If it isn't, then you should remove it from your app.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec116"/>Tree overview</h2></div></div></div><p>This window contains a map representation of the Activity's entire view hierarchy:</p><p>
</p><div><img src="img/B05061_9_9.jpg" alt="Tree overview"/></div><p>
</p><p>This high-level view of your hierarchy structure is particularly useful for seeing just how complex your view hierarchy really is, as well as helping you identify nested layouts and other opportunities to flatten your layout.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec117"/>Layout View</h2></div></div></div><p>This window displays a skeleton of your Activity's UI.</p><p>When you select a node in either the<strong> Tree View</strong> or <strong>Tree Overview</strong> window, the <strong>Layout View</strong> highlights the areas that this <code class="literal">View</code> paints. Again, this helps you weed out redundant <code class="literal">Views</code>:</p><p>
</p><div><img src="img/B05061_9_10.jpg" alt="Layout View"/></div><p>
</p><p>While <strong>Hierarchy View</strong> is great for spotting nested layouts and redundant views, there are some view hierarchy issues that you can't spot just by looking at these three windows.</p><p>To help you identify any problems that may be lurking beneath the surface, you can use the <strong>Hierarchy View</strong> tool to measure how long it takes each <code class="literal">View</code> to move through each phase of the rendering process (measure, layout, and draw). Armed with this information, you'll know exactly what <code class="literal">Views</code> you need to optimize.</p><p>Hierarchy View's <strong>Tree Overview</strong> doesn't display render times by default. To add this information to the <strong>Tree Overview</strong>, you need to select the root node of the part of the tree you want to profile. Then click the green, red, and purple Venn diagram icon (when you hover over this icon, you'll see an <strong>Obtain layout times for tree rooted at selected node</strong> tooltip).</p><p>After a few moments, three colored dots will appear on each node within this section of the view hierarchy. These dots indicate the rendering speed of this <code class="literal">View</code> relative to the other profiled <code class="literal">Views</code>.</p><p>From left to right, these dots indicate the time it takes to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Measure the view</li><li class="listitem" style="list-style-type: disc">Layout the view</li><li class="listitem" style="list-style-type: disc">Draw the view</li></ul></div><p>The color of each dot indicates the time it takes the <code class="literal">View</code> to move through each phase of the rendering process:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Green</strong>: This view is faster than at least half of the other profiled nodes. A green dot in the measure position means that this view has a faster layout time than at least 50% of the other profiled nodes.</li><li class="listitem" style="list-style-type: disc"><strong>Yellow</strong>: This view is in the slowest 50% of all the profiled nodes.</li><li class="listitem" style="list-style-type: disc"><strong>Red</strong>: This view is the slowest out of all the profiled nodes.</li></ul></div><p>You can use this information to identify which <code class="literal">Views</code> are the slowest to measure, layout, and draw, so you not only know which <code class="literal">Views</code> you need to optimize but also the part of the rendering process you should be focusing on.</p><p>When you click a profiled node you'll also see the measure, layout, and draw times for that <code class="literal">View</code>, displayed in milliseconds.</p><p>
</p><div><img src="img/B05061_9_11.jpg" alt="Layout View"/></div><p>
</p><p>Just remember that these performance indicators are relative to one another, so your view hierarchy is always going to include some red and yellow nodes.</p><p>Before you start looking for ways to optimize <code class="literal">Views</code> with yellow and red dots, ask yourself whether these <code class="literal">Views</code> have a good reason for rendering more slowly, for example views that have more children are always going to lag behind nodes that have less children.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Spotting memory leaks</h1></div></div></div><p>Android may be a memory-managed environment, but you still need to scrutinize how your app is handling memory.</p><p>
<strong>Garbage collection</strong> (<strong>GC</strong>) can <em>only </em>remove objects that it recognizes as unreachable. If your app allocates objects that the Android system doesn't identify as unreachable, then those objects are never going to get garbage collected. They're going to hang around, polluting your heap, and taking up valuable space.</p><p>As your app continues to leak objects that the system can't garbage collect, the amount of usable space will get smaller and smaller. The Android system will try to compensate for this shrinking memory by running longer and more frequent GC events.</p><p>While your typical GC event won't have a noticeable impact on your app's performance, as more and longer GC events start occurring in a small space of time, your users may notice a drop in performance, and may even encounter an <code class="literal">OutOfMemoryError</code>.</p><p>Memory leaks can be difficult to detect, but the Android SDK comes with several tools that you can use to scour your app for those sometimes subtle signs of memory-management problems.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec118"/>Memory monitor</h2></div></div></div><p>Memory monitor tracks your app's memory usage over time. This is another tool that can only communicate with a running app, so make sure to install your app on a physical device or an emulator before you proceed.</p><p>You can access memory monitor from the main Android Studio screen by selecting the <strong>Android Monitor</strong> tab towards the bottom of the screen, and then selecting the <strong>Memory</strong> tab.</p><p>Make sure the app you want to test is visible onscreen. As soon as memory monitor detects your running app, it'll start recording memory usage, displaying the memory your app is using in dark blue and the unallocated memory in light blue.</p><p>
</p><div><img src="img/B05061_9_12.jpg" alt="Memory monitor"/></div><p>
</p><div><div><h3 class="title"><a id="tip104"/>Tip</h3><p>
<strong>Troubleshooting</strong></p><p>If Memory Monitor displays a <strong>No debuggable applications</strong> message, open Android Studio's <strong>Tools</strong> menu, select <strong>Android,</strong> and make sure <strong>Enable adb integration </strong>is selected. This feature can be temperamental, so if it doesn't work at first then try the <em>very</em> high-tech solution of toggling <strong>Enable adb integration</strong> on and off a few times. If you're using a physical Android device, it may also help to disconnect your device and reconnect it to a different USB port.</p></div></div><p>Spend some time interacting with your app while keeping an eye on memory monitor. Eventually your app's memory usage will swell until there's no unallocated memory left. At this point, the system will free up some memory by triggering a GC event, causing the allocated memory to drop.</p><p>Most GC events are perfectly normal, but if you see GC events becoming longer and more frequent then this is an indication that a memory leak may be occurring in your app.</p><p>If you track a suspected memory leak over a period of time, you may eventually see the Android system try to accommodate your app's insatiable thirst for memory by granting it a higher memory ceiling. If you see this happening in memory monitor, then this is a sign that a serious memory leak is occurring in your app, and you should investigate it in more detail.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec119"/>Heap tab</h2></div></div></div><p>If you spot strange memory usage in the memory monitor, you can use the Android Device Monitor's Heap tab to gather more information about how your app is using memory.</p><p>As the name suggests, this tab provides data about your app's heap usage, including the kind of objects your app is allocating, the number of allocated objects, and how much space these objects are taking up.</p><p>Android smartphones and tablets have a finite amount of heap space that can only accommodate a certain number of objects. As the heap grows, the Android system will try to free up memory by triggering a GC event—which we already know is bad news for performance.</p><p>To access the heap tab, launch the <strong>Android Device Monitor</strong>, select the <strong>DDMS</strong> tab, and then select your device or AVD from the <strong>Devices</strong> panel, followed by the process you want to examine. Click the <strong>Update heap</strong> button (where the cursor is positioned in the following screenshot):</p><p>
</p><div><img src="img/B05061_9_13.jpg" alt="Heap tab"/></div><p>
</p><p>Select the <strong>Heap</strong> tab and spend some time interacting with your app.</p><p>The heap output is only displayed after a GC event has occurred, so you'll either have to be patient and wait for an organic GC event, or you can force a GC event by clicking the <strong>Cause GC</strong> button. Once a GC has occurred, the Heap tab will display information about your app's heap usage.</p><p>
</p><div><img src="img/B05061_9_14.jpg" alt="Heap tab"/></div><p>
</p><p>Spend some time interacting with your app, triggering GC events before <em>and</em> after you perform different actions so you can compare how these actions impact the heap. In this way, you can isolate the actions that are causing the memory leak, as well as any other memory-related problems your app is experiencing.</p><p>When you're tracking down problems in your app's heap, it may to help to generate a HPROF file, which is a snapshot of all the objects in your app's heap plus detailed information about the related classes and instances.</p><p>Once you've generated a HPROF file, you can view it in Android Studio or in a separate profiling tool, such as the Eclipse Memory Analyzer (<a class="ulink" href="http://www.eclipse.org/mat">http://www.eclipse.org/mat</a>).</p><p>To retrieve a HPROF file, click the <strong>Dump HPROF</strong> icon (next to the <strong>Update Heap</strong> icon). Give your file a name and save it.</p><p>To analyze your heap dump in Android Studio, open your HPROF file as a new Android project. Android Studio will automatically open the file in its Android Memory HPROF Viewer, ready for you to analyze in more detail.</p><p>
</p><div><img src="img/B05061_9_15.jpg" alt="Heap tab"/></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec120"/>Object allocation – understanding memory churn</h2></div></div></div><p>Another common memory problem that you should check for is memory churn.</p><p>Memory churn occurs when your app allocates lots of temporary objects in a short period of time, which can quickly gobble up a device's available memory, triggering those performance-sapping GC events.</p><p>You can check for memory churn using the Android SDK's <strong>Allocation Tracker</strong>, which lists all the objects your app is allocating to memory when you perform different actions. If you spot any suspicious-looking allocations, you can then use <strong>Allocation Tracker</strong> to inspect the classes and threads that are responsible for allocating these objects.</p><p>Inside the Android Device Monitor, select the <strong>DDMS</strong> tab and then open the <strong>Allocation Tracker</strong> tab. Select your device or AVD from the <strong>Devices</strong> tab, followed by the process you want to examine.</p><p>In the <strong>Allocation Tracker</strong> tab, click the <strong>Start Tracking</strong> button and spend some time interacting with your app. To see a list of all the objects that have been allocated since you started tracking, click the <strong>Get Allocation</strong>s button. Android Studio will then open a tab that displays all the allocations that occurred during this sampling period.</p><p>Click on any allocated object to see more information about that object:</p><p>
</p><div><img src="img/B05061_9_16.jpg" alt="Object allocation – understanding memory churn"/></div><p>
</p><p>When you're ready to stop collecting data, click the <strong>Stop Tracking</strong> button.</p><p>Each row in the <strong>Allocation Tracking</strong> tab represents a specific allocation, and provides the following information for that allocation:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Allocation order</li><li class="listitem" style="list-style-type: disc">Allocation size</li><li class="listitem" style="list-style-type: disc">Allocated class</li><li class="listitem" style="list-style-type: disc">Thread ID. This is the thread that made the allocation</li><li class="listitem" style="list-style-type: disc">Allocated In. This is the function in your code that's responsible for this allocation</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Debugging your project</h1></div></div></div><p>It's crucial that you thoroughly test your app for bugs before releasing it. Android Studio provides a range of tools that you can use to debug an app running on an emulator or a physical Android device, although these tools can only test a debuggable version of your app, which means you'll need to run your app in debug mode.</p><p>To run your app in debug mode, open your project's module-level <code class="literal">build.gradle</code> file and add the following:</p><pre class="programlisting">apply plugin: 'com.android.application' &#13;
 &#13;
......... &#13;
 &#13;
......... &#13;
  } &#13;
   buildTypes {  &#13;
          debug {  &#13;
                  debuggable true &#13;
            }  &#13;
    }  &#13;
} &#13;
</pre><p>After editing your Gradle build file, make sure you sync your project. Next, click the <strong>Debug</strong> icon or select <strong>Run </strong>from the Android Studio toolbar, followed by <strong>Debug</strong>.</p><p>Select the AVD or physical Android device where you want to install and test the debuggable version of your app. Once your app has loaded, Android Studio's <strong>Debug</strong> perspective should open automatically.</p><div><div><h3 class="title"><a id="note105"/>Note</h3><p>If the <strong>Debug </strong>perspective doesn't open automatically, select <strong>View</strong> from the Android Studio toolbar, followed by <strong>Tool window</strong> and <strong>Debug</strong>.</p></div></div><p>The Debug perspective consists of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Debugger</strong>: Displays threads and variables</li><li class="listitem" style="list-style-type: disc"><strong>Console</strong>: Displays the device status</li></ul></div><p>To debug an app that's already running, click <strong>Attach debugger to Android process</strong>. In the <strong>Choose Process</strong> window, select the device and the app you want to attach the debugger to and then click <strong>OK</strong>.</p><p>Once you have a debuggable version of your app up and running, you can view the log messages related to your application. To view these messages, select the <strong>Android Monitor</strong> tab that appears along the bottom of the Android Studio screen and then select the l<strong>ogcat </strong>tab:</p><p>
</p><div><img src="img/B05061_9_17.jpg" alt="Debugging your project"/></div><p>
</p><p>Logcat can sometimes be a case of information overload, so Android Studio provides several ways of filtering the logcat output. One method is to use the <strong>Log Level</strong> drop-down menu. By default, this menu is set to <strong>Verbose</strong>, which displays all log messages, but there are several more specific options you can choose from:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Debug</strong>: Displays log messages that are useful during development, plus message levels lower in this list</li><li class="listitem" style="list-style-type: disc"><strong>Info</strong>:<strong> </strong>Displays expected log messages for regular usage, plus message levels lower in this list</li><li class="listitem" style="list-style-type: disc"><strong>Warn</strong>:<strong> </strong>Displays possible issues that are not yet errors, plus message levels lower in this list</li><li class="listitem" style="list-style-type: disc"><strong>Error</strong>: Displays issues that have caused errors, plus message levels lower in this list</li><li class="listitem" style="list-style-type: disc"><strong>Assert</strong>: Displays issues that should <em>never </em>happen</li></ul></div><p>If none of these filters meet your debugging needs, you can create custom filters. Open the <strong>Show only selected application</strong> dropdown (towards the right side of the <strong>logcat</strong> panel) and then select <strong>Edit Filter Configuration</strong>.</p><p>This opens a <strong>Create New LogCat Filter</strong> window, where you can craft a new filter by providing the following information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Filter name</strong>: If you're creating a new filter, you should give this filter a unique name. If you're modifying an existing filter, select it from the left-hand pane and its name will appear in this field.</li><li class="listitem" style="list-style-type: disc"><strong>Log Tag</strong>: Every log message has a tag associated with it, which indicates the system component the message originated from. If you want to see messages that originate from a certain system component only, you can enter that component's tag here.</li><li class="listitem" style="list-style-type: disc"><strong>Log Message</strong>: If you only want to see messages that contain certain elements or character strings, specify them in the <strong>Log Message</strong> field.</li><li class="listitem" style="list-style-type: disc"><strong>Package Name</strong>: If you want your filter to display messages that relate to a certain package only, enter this package name here.</li><li class="listitem" style="list-style-type: disc"><strong>PID</strong>: If you only want to see messages that refer to a specific process, enter that process ID here.</li><li class="listitem" style="list-style-type: disc"><strong>Log Level</strong>: To filter based on log level, open this dropdown and select anything other than the default <strong>Verbose</strong> option.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec121"/>Working with breakpoints</h2></div></div></div><p>Having trouble working out where an error is originating from? You can use breakpoints to pause the execution of your app at a particular line of code. By creating multiple breakpoints and scrutinizing your app every time it comes to a stop, you can gradually isolate the portion of code that's responsible for the error.</p><p>To set a breakpoint:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the file where you want to create your breakpoint.</li><li class="listitem">Locate the line where you want to set your breakpoint and click on this line.</li><li class="listitem">Click the yellow portion that appears in the left-hand sidebar. A red dot will appear, indicating that you've successfully created a breakpoint.</li></ol></div><p>
</p><div><img src="img/B05061_9_18.jpg" alt="Working with breakpoints"/></div><p>
</p><p>After creating your breakpoints, click the Rerun app icon (the green <strong>Play</strong> icon along the left-hand toolbar).</p><p>Every time Android Studio reaches a breakpoint, it'll pause the execution of your app and highlight the triggered breakpoint in your code. You can then open the <strong>Debug</strong> window (by selecting the <strong>Debug</strong> tab in the bottom toolbar) and use the debugger and console to gather more information about what's going on in your app at this exact point in the execution of your code. You may also want to take a look at the <strong>logcat</strong> output. Repeat this process until you've isolated the code that's causing the problem.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec80"/>Configuring your breakpoints</h3></div></div></div><p>If you have a very specific kind of breakpoint in mind, you can make some changes to your breakpoint settings. Start by clicking the <strong>View Breakpoints </strong>icon (where the cursor is positioned in the following screenshot):</p><p>
</p><div><img src="img/B05061_9_19.jpg" alt="Configuring your breakpoints"/></div><p>
</p><p>The Breakpoint window appears and lists all the breakpoints you've created in the current project. To see what changes you can make to a breakpoint, select that breakpoint from the left-hand list.</p><p>
</p><div><img src="img/B05061_9_20.jpg" alt="Configuring your breakpoints"/></div><p>
</p><p>This window gives you lots of different options for configuring the selected breakpoint:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Suspend</strong>: Select this checkbox to enable a suspend policy for this breakpoint, then choose from <strong>All</strong> (when a breakpoint is hit, all threads are suspended) or <strong>Thread</strong> (when a breakpoint is hit, only the thread where the breakpoint is hit is suspended).</li><li class="listitem" style="list-style-type: disc"><strong>Condition</strong>: Select this checkbox, then in the accompanying textbox specify a condition for hitting this breakpoint. The condition must be a Java Boolean expression with a <code class="literal">true/false</code> value. This condition is evaluated each time the breakpoint is reached, and if the result is true the specified action is performed.</li><li class="listitem" style="list-style-type: disc"><strong>Log message to console</strong>: Select this checkbox to display a log message in the console when this breakpoint is hit.</li><li class="listitem" style="list-style-type: disc"><strong>Log evaluated expression</strong>: Select this checkbox to evaluate an expression when this breakpoint is hit and display the results in Android Studio's console.</li><li class="listitem" style="list-style-type: disc"><strong>Remove once hit</strong>: When enabled, this breakpoint will be triggered once and then removed.</li><li class="listitem" style="list-style-type: disc"><strong>Disabled until the selected breakpoint is hit</strong>: This breakpoint is dependent on another breakpoint, and will only be enabled once the specified breakpoint has been triggered.</li><li class="listitem" style="list-style-type: disc"><strong>Instance filters</strong>: To limit breakpoint hits to instances of a particular object, select this checkbox and then provide the ID value of the instance you want to use.</li><li class="listitem" style="list-style-type: disc"><strong>Class filters</strong>: Select this checkbox to have this breakpoint behave differently in reaction to different classes. Then, specify the classes that'll trigger the breakpoint in the accompanying textbox. To define classes where the breakpoint <em>shouldn't </em>be triggered, add these classes to the textbox but preface them with a minus symbol.</li><li class="listitem" style="list-style-type: disc"><strong>Pass count</strong>: Define the number of times a breakpoint should be reached, but ignored, by selecting this checkbox and then specifying the number of times the breakpoint should be skipped. After the specified number of passes, the breakpoint will be triggered as normal.</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Examining your code with Lint</h1></div></div></div><p>It's important to check that there are no problems with the structural quality of your code, as these can cause errors and have a negative impact on your app's performance. Conveniently, the Android SDK comes with Lint, a static code-scanning tool that's <em>perfect </em>for identifying and correcting structural problems with your code.</p><p>In Android Studio, the configured Lint expressions run every time you build your app and print the output to Android Studio's <strong>Events log</strong>, which you can access by selecting the <strong>Events log</strong> tab.</p><p>However, you can also run Lint on a specific module at any time, by right-clicking on that module's file or folder and then selecting <strong>Analyze</strong>
<strong> | </strong>
<strong>Inspect code,</strong> followed by the area you want to inspect (<strong>Whole project, </strong>
<strong>Module</strong>, or <strong>Custom Scope</strong>). Make your selection, and Android Studio automatically opens a new <strong>Inspection</strong> tab where you can view the Lint output.</p><p>To help you zero in on critical problems, Lint provides a description and a severity level for every issue it reports.</p><p>
</p><div><img src="img/B05061_9_21.jpg" alt="Examining your code with Lint"/></div><p>
</p><p>Make sure you correct <em>all </em>errors that Lint detects before you release your app.</p><p>If you need to make some changes to the default Lint settings, select <strong>Android Studio</strong> from the toolbar, followed by <strong>Preferences</strong>. In the window that appears, double-click <strong>Editor</strong> and select <strong>Inspections</strong>.</p><p>This opens the <strong>Inspection Configuration</strong> page, which lists all the supported Lint profiles and inspections.</p><p>
</p><div><img src="img/B05061_9_22.jpg" alt="Examining your code with Lint"/></div><p>
</p><p>Here, you can explore the different inspections and make edits such as changing their severity level and scope.</p><p>You can also run Lint inspections for a specific build variant or for all build variants, by adding the <code class="literal">lintOptions</code> property to your project's module-level <code class="literal">build.gradle</code> file. For example, if you wanted to set your Lint's <code class="literal">abortOnError </code>option to <code class="literal">false</code>, you'd need to add the following to your <code class="literal">build.gradle </code>file:</p><pre class="programlisting"> &#13;
apply plugin: 'com.android.application' &#13;
 &#13;
android { &#13;
 &#13;
........... &#13;
............. &#13;
.............. &#13;
 &#13;
  lintOptions { &#13;
 &#13;
//Lint shouldn't exit the process when it discovers errors// &#13;
 &#13;
         abortOnError false &#13;
    } &#13;
</pre><p>You can find a complete list of all your Lint configuration options 
at Google's GitHub (<a class="ulink" href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions">http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions</a>).
</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Optimizing your code with ProGuard</h1></div></div></div><p>The ProGuard tool shrinks and optimizes your code by removing unused code and renaming classes, fields, and methods with semantically obscure names. The end result is a smaller <code class="literal">APK</code> that's more difficult to reverse engineer, something that's particularly important if your app has access to sensitive information.</p><p>ProGuard runs automatically when you build your app in release mode. To build a release version of your app, you need to enable the <code class="literal">minifyEnabled</code> property in your project's module-level <code class="literal">build.gradle</code> file and make sure <code class="literal">buildTypes </code>is set to <code class="literal">release</code>. For example:</p><pre class="programlisting">android {   ...  buildTypes { &#13;
 &#13;
 //The buildTypes element controls whether your app is built in debug or release mode// &#13;
        release { &#13;
 &#13;
//In this example, we're building a release version of our app so we can run ProGuard. If your build.gradle file contains the debug attribute, then make sure you remove it so it doesn't prevent ProGuard from running//  &#13;
 &#13;
           minifyEnabled true &#13;
 &#13;
//To enable ProGuard, add the minifyEnabled property and set it to true// &#13;
 &#13;
            proguardFiles getDefaultProguardFile('proguard-android.txt'), &#13;
           'proguard-rules.pro'&#13;
        }&#13;
    }&#13;
  }</pre><p>The <code class="literal">getDefaultProguardFile</code> attribute obtains the default ProGuard settings specified in the <code class="literal">Android/sdk/tools/proguard/proguard-android.txt</code> file that you downloaded as part of the Android SDK. Alternatively, you can use the <code class="literal">proguard-android-optimize.txt</code> file, which contains the same rules but has optimization enabled.</p><p>If you want to add some project-specific options to the default ProGuard settings, open your project's <code class="literal">Gradle Scripts/proguard-rules.pro</code> file and add your new rules.</p><p>For more information about the different ProGuard settings that you can add to this file, check out the ProGuard manual (
<a class="ulink" href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html">https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html</a>
).</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec58"/>Scrutinize each pixel</h1></div></div></div><p>Another tool you may want to explore is <strong>Pixel Perfect</strong>.</p><p>The <strong>Pixel Perfect</strong> window displays a magnified version of the screen that's currently visible on the attached Android device or emulator, and lets you scrutinize the individual pixels that make up your UI. You can also use it to overlay an image over your UI, which is handy for checking how your UI compares to your digital wireframes.</p><p>
<strong>Pixel Perfect</strong> is integrated into the <strong>Android Device Monitor</strong>. To launch <strong>Pixel Perfect</strong>, select <strong>Window</strong> from the <strong>Android Device Monitor</strong> toolbar, followed by <strong>Open Perspective</strong>, <strong>Pixel Perfect,</strong> and <strong>OK</strong>.</p><p>
</p><div><img src="img/B05061_9_23.jpg" alt="Scrutinize each pixel"/></div><p>
</p><p>The <strong>Pixel Perfect</strong> window contains the following areas.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec122"/>Pixel Perfect pane</h2></div></div></div><p>This window displays a magnified version of the UI that's currently visible on the connected Android device or AVD.</p><p>By default, Pixel Perfect doesn't update automatically to reflect changes that occur on screen, so you'll need to keep clicking this pane's <strong>Refresh Screenshot</strong> icon. Alternatively, if you want Pixel Perfect to update automatically, then select the <strong>Automatically Refresh the screenshot</strong> icon.</p><p>One of Pixel Perfect's most useful features is the ability to load <code class="literal">jpg</code>, <code class="literal">jpeg</code>, <code class="literal">png</code>, <code class="literal">gif</code>, or <code class="literal">bmp</code> images as an overlay. This is particularly useful if you want to take stock of how the current screen compares to your original design, as you can load a digital wireframe (or any other digital design docs you have to hand) as an overlay.</p><p>To load an image as an overlay, navigate to the screen you want to work with and make sure it's being displayed in the Pixel Perfect window. Select the <strong>Load an image to overlay the screenshot</strong> icon, and then select the image you want to use as your overlay.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec123"/>Pixel Perfect tree</h2></div></div></div><p>This is a hierarchical list of all the <code class="literal">View</code> objects that are currently visible. Just be aware that system objects also appear in this list.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec124"/>Pixel Perfect Loupe pane</h2></div></div></div><p>This pane contains the magnified screen image, overlaid by a grid where one square represents one pixel. To see more information about a particular pixel, select it and the Loupe pane will display the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Pixel swatch</strong>: A rectangle filled with the same color as the selected pixel</li><li class="listitem" style="list-style-type: disc"><strong>HTML color code</strong>: The pixel's corresponding hexadecimal RGB code</li><li class="listitem" style="list-style-type: disc"><strong>RGB color values</strong>: The pixel's R, G, and B color values</li><li class="listitem" style="list-style-type: disc"><strong>X and Y coordinates</strong>: The pixel's coordinates, as a px value</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec59"/>Processes and threads</h1></div></div></div><p>How your app handles threads and processes has a significant impact on your app's performance. By default, when the user launches an app, the Android system creates a single thread of execution for that application. All components run in this single thread, which is known as the <em>main</em> thread or the <em>UI</em> thread.</p><p>Unless you specify otherwise, most of the operations you perform in your app run in the foreground on this main thread. Most of the time this single-thread model works fine, but if your app needs to perform particularly intensive work or long-running operations, then the main thread can become blocked. This can cause your app to freeze, display system errors, and potentially even crash.</p><p>If you're going to deliver a good user experience, then it's vital you don't block the UI thread with intensive or long-running operations. If you do need to run demanding processes, then you should create additional threads.</p><p>This involves specifying which process a certain component belongs to in your project's <code class="literal">Manifest</code> file. The <code class="literal">Manifest</code> entry for each type of component (activity, service, receiver, or provider) includes an <code class="literal">android:process</code> attribute that specifies the process where this component should run. If you want the system to create a new process for this component, preface the <code class="literal">android:process </code>value with a colon, for example <code class="literal">android:process=":myprocess"</code>.</p><p>If you need to handle more complex interactions, you may want to consider using a <code class="literal">Handler </code>to process messages delivered from the main thread, or you could use the <code class="literal">AsyncTask</code> class to simplify the execution of worker thread tasks that need to interact with your UI.</p><div><div><h3 class="title"><a id="tip106"/>Tip</h3><p>
<strong>Using AsyncTask</strong></p><p><code class="literal">AsyncTask</code> provides you with an easy way of performing synchronous work on your user interface without blocking the main thread. Using <code class="literal">AsyncTask</code>, you can separate tasks into the work that should be performed on the main thread and operations that should be performed on a separate worker thread. In this way, <code class="literal">AsyncTask</code> is a way of executing some work in a background thread and then publishing the results back to the main thread.</p><p>To use <code class="literal">AsyncTask</code>, you need to subclass <code class="literal">AsyncTask</code> and then implement the <code class="literal">doInBackground()</code> callback method, which executes automatically on a worker thread and performs background operations. The value returned by <code class="literal">doInBackground()</code> is then sent to <code class="literal">onPostExecute()</code>, and from here you can run the task by calling <code class="literal">execute()</code> on the main thread.</p><p>Ideally, you should only use <code class="literal">AsyncTasks</code> for short operations. If you need to keep threads running for more than a few seconds, it's recommended that you use APIs such as <code class="literal">Executor</code>, <code class="literal">ThreadPoolExecutor,</code> and <code class="literal">FutureTask</code>, which are provided as part of the <code class="literal">java.util.concurrent</code> package.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec125"/>Terminating processes</h2></div></div></div><p>When deciding how your application should handle processes, it's worth bearing in mind that even though the Android system will try and maintain all processes for as long as possible, it will kill off processes if memory starts getting low.</p><p>When deciding what processes to keep alive and which processes to terminate, the system decides how important each process is to the user by placing these processes in an <strong>importance hierarchy</strong>. Processes with the lowest importance are the first to go, while processes at the top of the importance hierarchy are rarely killed off.</p><div><div><h3 class="title"><a id="note107"/>Note</h3><p>The Android system will increase the ranking of a process if another, more important, process depends on it. A process that's supporting another process can <em>never </em>be ranked lower than the most important process it's supporting.</p></div></div><p>Ranked from most important to least important, the different levels of Android's importance hierarchy are detailed in the following sections.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec81"/>Foreground processes</h3></div></div></div><p>This is a process that's essential for the actions the user is currently performing. The Android system assigns a process this ranking if it hosts either:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An <code class="literal">Activity</code> that the user is interacting with</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Service</code> that's running in the foreground</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Service</code> that's bound to the activity the user is currently interacting with</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Service</code> that's executing one of its lifecycle callbacks (<code class="literal">onCreate</code>, <code class="literal">onStart</code>, or <code class="literal">onDestroy</code>)</li><li class="listitem" style="list-style-type: disc">A <code class="literal">BroadcastReceiver</code> that's executing its <code class="literal">onReceive()</code> method</li></ul></div><p>If any of these conditions are true, that process is considered a foreground process. The Android system only kills foreground processes as a very last resort.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec82"/>Visible processes</h3></div></div></div><p>This is a process that doesn't have any foreground components but may still affect what the user is seeing on screen. The Android system assigns this ranking if the process hosts a <code class="literal">Service</code> that's bound to a visible Activity, or an Activity that's not in the foreground but is still visible to the user, for example an Activity where the <code class="literal">onPause()</code> method has been called.</p><p>The Android system will only kill a visible process if there's not enough memory to support all foreground processes.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec83"/>Service processes</h3></div></div></div><p>This is a process that's running a <code class="literal">Service</code>, but doesn't fall into either of the two higher categories.</p><p>Although service processes are not directly related to anything the user sees, they usually perform actions that the user cares about. The system will avoid killing service processes unless doing so is the only way to keep all foreground and visible processes running.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec84"/>Background processes</h3></div></div></div><p>Background processes hold an Activity that's not currently visible to the user. Since background processes don't have a direct impact on the user experience, the system may kill background processes off at any time if it needs to reclaim memory for foreground, visible, or service processes.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec85"/>Empty processes</h3></div></div></div><p>This is a process that doesn't hold any active components. The system may keep empty processes alive for caching purposes, but make no mistake, they're the first to go if the system needs to free up some memory.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Re-using layouts with &gt; and &lt;merge/&gt;</h1></div></div></div><p>The Android platform provides a range of simple, reusable UI components known as widgets, but sometimes there may be larger or more complex UI components that you need to reuse across multiple screens, such as a panel containing a progress bar and a <strong>Cancel</strong> button, or a user profile consisting of a username and an avatar.</p><p>If your project features elements that you want to use multiple times, you can save yourself time and effort by implementing these elements as a reusable layout. You can then import these reusable elements into as many layout files as you want, using Android's <code class="literal">&gt;</code> and <code class="literal">&lt;merge/&gt;</code> tags.</p><p>To extract common elements into a reusable layout, create a new XML layout resource file and then define the UI elements you want to reuse. Pay special attention to the file's root view as this will also be included every time you embed this component in other layouts.</p><p>To import your reusable component into a layout resource file, just add the <code class="literal">include</code> tag and reference the layout file you want to import. For example, if you'd created a reusable layout called <code class="literal">contactslist </code>and wanted to import this component into another layout, you'd use the following:</p><pre class="programlisting">   &lt;include layout="@layout/contactslist"/&gt; &#13;
</pre><p>However, be aware that using the <code class="literal">include </code>tag can introduce redundant <code class="literal">ViewGroups </code>into your view hierarchy.</p><p>Imagine you have a layout called <code class="literal">main_layout.xml</code> that uses a vertical <code class="literal">LinearLayout</code> as its root view. You have a re-usable <code class="literal">contactslist_layout.xml</code> component that you want to include in this <code class="literal">main_layout</code> file, but the <code class="literal">contactslist_layout</code> also uses a vertical <code class="literal">LinearLayout</code> as its root view.</p><p>If you include <code class="literal">contactslist_layout.xml</code> in your main layout, you're going to end up with a vertical <code class="literal">LinearLayout </code>inside a vertical <code class="literal">LinearLayout</code>. This duplicate vertical layout isn't contributing anything to the UI, but it <em>is</em> making your view hierarchy more complex and potentially slowing down your app. So how do we get rid of this duplicate <code class="literal">LinearLayout</code>? The answer is by using the <code class="literal">merge</code> tag.</p><p>The<code class="literal"> merge </code>element helps to eliminate the redundant <code class="literal">ViewGroups</code> that can work their way into your view hierarchy when you include reusable layouts.</p><p>When you use the <code class="literal">merge</code> element as the root view of a reusable layout, the <code class="literal">LayoutInflator</code> skips the <code class="literal">merge</code> tag and inserts the reusable views into the <code class="literal">main_layout</code> as though they've always been part of that layout. As a result, your view hierarchy is simpler—which is nothing but good news for your app's performance!</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec126"/>Loading views only when needed</h2></div></div></div><p>Depending on your app, you may find yourself with a user interface that contains a large number of complex views that you rarely use, such as pop-ups and progress indicators.</p><p>One possible solution to this problem is to add some of these complex <code class="literal">Views</code> via a <code class="literal">ViewStub</code>, which is a variation of the <code class="literal">include</code> tag. A <code class="literal">ViewStub</code> is a lightweight view that isn't included in your layout directly, so it's very cheap to keep in your view hierarchy.</p><p>When you add a <code class="literal">View </code>via a <code class="literal">ViewStub</code>, the <code class="literal">ViewStub </code>only loads the <code class="literal">View</code> as and when it's needed. This allows you to create complex layouts consisting of lots of small views, and your UI will still render quickly and smoothly as you're not immediately populating your user interface with lots of complex <code class="literal">Views</code>.</p><p>To use a <code class="literal">ViewStub</code>, you need to specify the layout you want to inflate using the <code class="literal">android:id</code> attribute, for example:</p><pre class="programlisting">&lt;ViewStub &#13;
   android:id="@+id/popup" &#13;
   android:inflatedId="@+id/popup_import" &#13;
   android:layout="@layout/basic_popup" &#13;
   android:layout_height="wrap_content"  &#13;
   android:layout_width="match_parent" /&gt; &#13;
</pre><p>When it's time to load your <code class="literal">ViewStub's</code> layout, you just need to set the <code class="literal">ViewStub</code> to visible. To do this, either change the visibility of the stub by calling <code class="literal">setVisibility(View.VISIBLE)</code>:</p><pre class="programlisting">((ViewStub) findViewById(R.id.popup)).setVisibility(View.VISIBLE); &#13;
</pre><p>Or invoke the <code class="literal">inflate()</code> method:</p><pre class="programlisting">View importPopup = ((ViewStub) findViewById(R.id.popup)).inflate(); &#13;
</pre><p>The inflated layout replaces the <code class="literal">ViewStub</code>, and at this point the <code class="literal">ViewStub</code> element is no longer part of your view hierarchy.</p><div><div><h3 class="title"><a id="note108"/>Note</h3><p>
<code class="literal">ViewStub</code> currently doesn't support the <code class="literal">merge</code> tag in the layouts to be inflated.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter, I covered some of the most common performance problems you need to be aware of when developing Android apps, including overdraw, memory leaks, and complex view hierarchies.</p><p>We took an in-depth look at numerous tools you can use to check whether some of the most common performance problems are affecting your Android projects. We also looked at how to gather more information about any problems you <em>do</em> diagnose, so you're in a better position to fix them.</p><p>There's just one chapter left to go! In the final chapter, I'm going to cover all the best practices and guidelines that didn't fit neatly into any of the previous chapters. And since security is such a big concern for mobile users and developers at the moment, I'll also show you how to lock down your UI (and your app in general) so you can be confident that your app isn't leaving users open to security vulnerabilities.</p></div></body></html>