["```kt\n    fun main(args: Array<String>) { \n      val sum = { x: Int, y: Int -> x + y } // (1) \n      println(\"Sum ${sum(12,14)}\")// (2) \n      val anonymousMult = {x: Int -> (Random().nextInt(15)+1) * x}\n      // (3) \n      println(\"random output ${anonymousMult(2)}\")// (4) \n    } \n```", "```kt\n    fun square(n:Int):Int {//(1) \n      return n*n \n    } \n\n    fun main(args: Array<String>) { \n      println(\"named pure func square = ${square(3)}\") \n      val qube = {n:Int -> n*n*n}//(2) \n      println(\"lambda pure func qube = ${qube(3)}\") \n    } \n```", "```kt\nnamed pure func square = 9\nlambda pure func qube = 27 \n```", "```kt\n    fun highOrderFunc(a:Int, validityCheckFunc:(a:Int)->Boolean) {//(1) \n      if(validityCheckFunc(a)) {//(2) \n        println(\"a $a is Valid\") \n      } else { \n        println(\"a $a is Invalid\") \n      } \n    } \n\n    fun main(args: Array<String>) { \n      highOrderFun(12,{ a:Int -> a.isEven()})//(3) \n      highOrderFunc(19,{ a:Int -> a.isEven()}) \n    } \n```", "```kt\na 12 is Valid \na 19 is Invalid \n```", "```kt\n    fun doSomeStuff(a:Int = 0) = a+(a*a) \n\n    fun main(args: Array<String>) { \n      for (i in 1..10) { \n        println(\"$i Output ${doSomeStuff(i)}\") \n      } \n    } \n```", "```kt\n    inline fun doSomeStuff(a:Int = 0) = a+(a*a) \n\n    fun main(args: Array<String>) { \n      for (i in 1..10) { \n        println(\"$i Output ${doSomeStuff(i)}\") \n      } \n    } \n```", "```kt\n    inline fun highOrderFuncInline(a:Int, validityCheckFunc:(a:Int)- \n    >Boolean) { \n      if(validityCheckFunc(a)) { \n         println(\"a $a is Valid\") \n      } else { \n        println(\"a $a is Invalid\") \n      } \n     } \n\n    fun main(args: Array<String>) { \n      highOrderFuncInline(12,{ a:Int -> a.isEven()}) \n      highOrderFuncInline(19,{ a:Int -> a.isEven()}) \n    } \n```", "```kt\n    init{ \n      nums = Pair(a,b) \n\n      subjectAdd.map({ it.first+it.second }).subscribe({println\n      (\"Add = $it\")} )//1 \n      subjectSub.map({ it.first-it.second }).subscribe({println\n      (\"Substract = $it\")} ) \n      subjectMult.map({ it.first*it.second }).subscribe\n      ({println(\"Multiply = $it\")} ) \n      subjectDiv.map({ it.first/(it.second*1.0) }).subscribe\n      ({println(\"Divide = $it\")} ) \n\n      subjectCalc.subscribe({ \n        with(it) { \n          calculateAddition() \n          calculateSubstraction() \n          calculateMultiplication() \n          calculateDivision() \n        } \n      }) \n\n      subjectCalc.onNext(this) \n     } \n```", "```kt\n    class ReactiveCalculator(a:Int, b:Int) { \n      val subjectCalc: io.reactivex.subjects.Subject\n      <ReactiveCalculator>   = \n      io.reactivex.subjects.PublishSubject.create() \n\n      var nums:Pair<Int,Int> = Pair(0,0) \n\n      init{ \n        nums = Pair(a,b) \n\n        subjectCalc.subscribe({ \n          with(it) { \n            calculateAddition() \n            calculateSubstraction() \n            calculateMultiplication() \n            calculateDivision() \n          } \n        }) \n\n        subjectCalc.onNext(this) \n       } \n\n       inline fun calculateAddition():Int { \n         val result = nums.first + nums.second \n         println(\"Add = $result\") \n         return result \n       } \n\n       inline fun calculateSubstraction():Int { \n         val result = nums.first - nums.second \n         println(\"Substract = $result\") \n         return result \n       } \n\n      inline fun calculateMultiplication():Int { \n        val result = nums.first * nums.second \n        println(\"Multiply = $result\") \n        return result \n      } \n\n      inline fun calculateDivision():Double { \n        val result = (nums.first*1.0) / (nums.second*1.0) \n        println(\"Multiply = $result\") \n        return result \n      } \n\n      inline fun modifyNumbers (a:Int = nums.first, b: \n      Int = nums.second) { \n        nums = Pair(a,b) \n        subjectCalc.onNext(this) \n      } \n\n      fun handleInput(inputLine:String?) { \n        if(!inputLine.equals(\"exit\")) { \n            val pattern: java.util.regex.Pattern =\n            java.util.regex.Pattern.compile\n            (\"([a|b])(?:\\\\s)?=(?:\\\\s)?(\\\\d*)\"); \n\n            var a: Int? = null \n            var b: Int? = null \n\n            val matcher: java.util.regex.Matcher = \n            pattern.matcher(inputLine) \n\n            if (matcher.matches() && matcher.group(1) != null &&  \n            matcher.group(2) != null) { \n                if(matcher.group(1).toLowerCase().equals(\"a\")){ \n                    a = matcher.group(2).toInt() \n                } else if(matcher.group(1).toLowerCase().equals(\"b\")){ \n                    b = matcher.group(2).toInt() \n                } \n            } \n\n            when { \n                a != null && b != null -> modifyNumbers(a, b) \n                a != null -> modifyNumbers(a = a) \n                b != null -> modifyNumbers(b = b) \n                else -> println(\"Invalid Input\") \n\n            } \n         } \n      } \n\n    } \n```", "```kt\nInitial Output with a = 15, b = 10\nAdd = 25\nSubstract = 5\nMultiply = 150\nMultiply = 1.5\nEnter a = <number> or b = <number> in separate lines\nexit to exit the program\na = 6\nAdd = 16\nSubstract = -4\nMultiply = 60\nMultiply = 0.6\nb=4\nAdd = 10\nSubstract = 2\nMultiply = 24\nMultiply = 1.5\nexit\n\n```", "```kt\n    apply plugin: 'kotlin' \n\n    kotlin { \n      experimental { \n        coroutines 'enable' \n      } \n    } \n```", "```kt\n    repositories { \n      ... \n      jcenter() \n    } \n    dependencies { \n      ... \n      compile \"org.jetbrains.kotlinx:kotlinx-coroutines-core:0.16\" \n    } \n```", "```kt\n    <plugin> \n      <groupId>org.jetbrains.kotlin</groupId> \n      <artifactId>kotlin-maven-plugin</artifactId> \n      ... \n      <configuration> \n        <args> \n            <arg>-Xcoroutines=enable</arg> \n        </args> \n      </configuration> \n    </plugin> \n    <repositories> \n      ... \n      <repository> \n        <id>central</id> \n        <url>http://jcenter.bintray.com</url> \n      </repository> \n    </repositories> \n    <dependencies> \n      ... \n      <dependency> \n        <groupId>org.jetbrains.kotlin</groupId> \n        <artifactId>kotlinx-coroutines-core</artifactId> \n        <version>0.16</version> \n      </dependency> \n    </dependencies> \n```", "```kt\n    suspend fun longRunningTsk():Long {//(1) \n      val time = measureTimeMillis {//(2) \n        println(\"Please wait\") \n        delay(2,TimeUnit.SECONDS)//(3) \n        println(\"Delay Over\") \n      } \n      return time \n    } \n\n    fun main(args: Array<String>) { \n      runBlocking {//(4) \n        val exeTime = longRunningTsk()//(5) \n        println(\"Execution Time is $exeTime\") \n      } \n    } \n```", "```kt\nPlease wait \nDelay Over \nExecution Time is 2018 \n```", "```kt\n    fun main(args: Array<String>) { \n      val time = async(CommonPool) { longRunningTsk() }//(1) \n      println(\"Print after async \") \n      runBlocking { println(\"printing time ${time.await()}\") }//(2) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      var a = 0 \n      var b = 1 \n      print(\"$a, \") \n      print(\"$b, \") \n\n      for(i in 2..9) { \n        val c = a+b \n        print(\"$c, \") \n        a=b \n        b=c \n      } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val fibonacciSeries = buildSequence {//(1) \n        var a = 0 \n        var b = 1 \n        yield(a)//(2) \n        yield(b) \n\n        while (true) { \n            val c = a+b \n            yield(c)//(3) \n            a=b \n            b=c \n        } \n     } \n\n     println(fibonacciSeries.take(10) join \",\" )//(4) \n\n    } \n```", "```kt\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34 \n```", "```kt\n    class ReactiveCalculator(a:Int, b:Int) { \n      val subjectCalc:\n      io.reactivex.subjects.Subject<ReactiveCalculator> =\n      io.reactivex.subjects.PublishSubject.create() \n\n      var nums:Pair<Int,Int> = Pair(0,0) \n\n      init{ \n        nums = Pair(a,b) \n\n        subjectCalc.subscribe({ \n            with(it) { \n                calculateAddition() \n                calculateSubstraction() \n                calculateMultiplication() \n                calculateDivision() \n            } \n        }) \n\n        subjectCalc.onNext(this) \n      } \n\n      inline fun calculateAddition():Int { \n        val result = nums.first + nums.second \n        println(\"Add = $result\") \n        return result \n      } \n\n      inline fun calculateSubstraction():Int { \n        val result = nums.first - nums.second \n        println(\"Substract = $result\") \n        return result \n      } \n\n      inline fun calculateMultiplication():Int { \n        val result = nums.first * nums.second \n        println(\"Multiply = $result\") \n        return result \n     } \n\n     inline fun calculateDivision():Double { \n        val result = (nums.first*1.0) / (nums.second*1.0) \n        println(\"Division = $result\") \n        return result \n     } \n\n     inline fun modifyNumbers (a:Int = nums.first, b: \n     Int = nums.second) { \n        nums = Pair(a,b) \n        subjectCalc.onNext(this) \n\n     } \n\n     suspend fun handleInput(inputLine:String?) {//1 \n        if(!inputLine.equals(\"exit\")) { \n            val pattern: java.util.regex.Pattern =  \n            java.util.regex.Pattern.compile\n            (\"([a|b])(?:\\\\s)?=(?:\\\\s)?(\\\\d*)\"); \n\n            var a: Int? = null \n            var b: Int? = null \n\n            val matcher: java.util.regex.Matcher =\n            pattern.matcher(inputLine) \n\n            if (matcher.matches() && matcher.group(1) != null &&\n            matcher.group(2) != null) { \n                if(matcher.group(1).toLowerCase().equals(\"a\")){ \n                    a = matcher.group(2).toInt() \n                } else if(matcher.group(1).toLowerCase().equals(\"b\")){ \n                    b = matcher.group(2).toInt() \n                } \n            } \n\n            when { \n                a != null && b != null -> modifyNumbers(a, b) \n                a != null -> modifyNumbers(a = a) \n                b != null -> modifyNumbers(b = b) \n                else -> println(\"Invalid Input\") \n\n            } \n         } \n       } \n\n    } \n\n    fun main(args: Array<String>) { \n    println(\"Initial Out put with a = 15, b = 10\") \n    var calculator: ReactiveCalculator = ReactiveCalculator(15, 10) \n\n    println(\"Enter a = <number> or b = <number> in separate lines\\nexit\n    to exit the program\") \n    var line:String? \n    do { \n        line = readLine(); \n        async(CommonPool) {//2 \n            calculator.handleInput(line) \n        } \n    } while (line!= null && !line.toLowerCase().contains(\"exit\")) \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val maybeValue: Maybe<Int> = Maybe.just(14)//1 \n      maybeValue.subscribeBy(//2 \n        onComplete = {println(\"Completed Empty\")}, \n        onError = {println(\"Error $it\")}, \n        onSuccess = { println(\"Completed with value $it\")} \n      ) \n      val maybeEmpty:Maybe<Int> = Maybe.empty()//3 \n      maybeEmpty.subscribeBy( \n        onComplete = {println(\"Completed Empty\")}, \n        onError = {println(\"Error $it\")}, \n        onSuccess = { println(\"Completed with value $it\")} \n      ) \n    } \n```", "```kt\nCompleted with value 14 \nCompleted Empty \n```"]