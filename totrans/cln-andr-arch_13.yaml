- en: '*Chapter 10*: Putting It All Together'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：整合一切'
- en: In this chapter, we will analyze what we have done so far in the previous chapters
    and look at different ways we can improve the layers of the application. Later,
    we will explore the benefit of clean architecture when we integrate instrumented
    testing into the application, where we will swap the data source dependencies
    with mock dependencies to ensure the reliability of the tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析前几章中我们所做的工作，并探讨我们可以以不同的方式改进应用程序的层级。稍后，我们将探讨在将仪器测试集成到应用程序中时的清洁架构的好处，我们将用模拟依赖替换数据源依赖，以确保测试的可靠性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Inspecting module dependencies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查模块依赖
- en: Instrumentation testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪器测试
- en: By the end of the chapter, you will be able to identify and remove external
    dependencies in the use case layer of the application to enforce the **Common
    Closure Principle** (**CCP**) and know how to create instrumented tests on Android
    with mock data sources.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够识别并删除应用程序用例层中的外部依赖，以强制执行**共同封闭原则**（**CCP**），并了解如何在Android上使用模拟数据源创建仪器测试。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The hardware and software requirements are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和软件要求如下：
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Arctic Fox 2020.3.1 Patch 3
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3sLr0HS](https://bit.ly/3sLr0HS)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3sLr0HS](https://bit.ly/3sLr0HS)
- en: Inspecting module dependencies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查模块依赖
- en: In this section, we will analyze the dependencies used across the different
    modules in the application created in the previous chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析在前几章创建的应用程序中不同模块之间使用的依赖项。
- en: 'Following *Exercise 09.01 – Transitioning to MVI* from [*Chapter 9*](B18320_09_ePub.xhtml#_idTextAnchor098),
    *Implementing an MVI Architecture*, we now have a fully functioning application
    split into separate modules, representing different layers. We can analyze the
    relationship between the different modules by looking at the `dependencies` block
    in the `build.gradle` file in each module and focusing in particular on the `implementation(project(path:
    "{module}"))` lines. If we were to draw a diagram, it would look like the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '随着从[*第9章*](B18320_09_ePub.xhtml#_idTextAnchor098)的*练习09.01 – 转向MVI*过渡，我们现在有一个完全功能的应用程序，它被分割成独立的模块，代表不同的层级。我们可以通过查看每个模块中的`build.gradle`文件中的`dependencies`块，并特别关注`implementation(project(path:
    "{module}"))`行，来分析不同模块之间的关系。如果我们绘制一个图表，它看起来会像以下这样：'
- en: '![Figure 10.1 – A module dependency diagram for exercise 09.01'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 练习09.01的模块依赖图]'
- en: '](img/Figure_10.01_B18320.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.01_B18320.jpg)'
- en: Figure 10.1 – A module dependency diagram for exercise 09.01
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 练习09.01的模块依赖图
- en: 'In the preceding figure, we can see that the `:domain` module, which is part
    of the domain layer, is at the center, with the modules from the other layers
    having a dependency toward it. The `:app` module is responsible for assembling
    all of the dependencies, and this means that it will have a dependency on all
    the other modules. This means that we are in a good clean architecture position
    because we want the entities and use cases to have minimal dependencies on other
    components. If we continue analyzing the `build.gradle` files for each module
    and include the external dependencies as well, we will see additional dependencies
    on external libraries for each module:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到`:domain`模块，它是领域层的一部分，位于中心，其他层的模块都依赖于它。`:app`模块负责组装所有依赖项，这意味着它将依赖于所有其他模块。这意味着我们处于良好的清洁架构位置，因为我们希望实体和用例对其他组件的依赖最小化。如果我们继续分析每个模块的`build.gradle`文件，并包括外部依赖项，我们将看到每个模块对外部库的额外依赖：
- en: '![Figure 10.2 – A module dependency diagram with external dependencies for
    exercise 09.01'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – 练习09.01的模块依赖图，包含外部依赖]'
- en: '](img/Figure_10.02_B18320.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.02_B18320.jpg)'
- en: Figure 10.2 – A module dependency diagram with external dependencies for exercise
    09.01
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 练习09.01的模块依赖图，包含外部依赖
- en: In *Figure 10.2*, we can see some of the relevant external dependencies our
    modules use. `:data-remote` uses dependencies toward Retrofit and OkHttp for networking,
    the `:data-local` module has dependencies toward Room and DataStore, while the
    presentation layer modules depend on things such as Compose, ViewModel, and the
    Android framework. Dependencies that were used used across the entire project
    were coroutines, flows, and Hilt.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 10.2* 中，我们可以看到我们的模块使用的一些相关外部依赖。`:data-remote` 使用 Retrofit 和 OkHttp 的依赖进行网络操作，`:data-local`
    模块依赖于 Room 和 DataStore，而表示层模块依赖于 Compose、ViewModel 和 Android 框架。在整个项目中使用的依赖项包括协程、flows
    和 Hilt。
- en: Having dependencies on Hilt and coroutines might pose a problem for the `:domain`
    and `:data-repository` modules. We want these two modules to be as stable as possible,
    and having external dependencies will create problems every time we update the
    versions for those libraries. We decided to use flows because of their threading
    benefits, the reactive approach, and because they were developed as an extension
    to the Kotlin framework. They might still pose a problem if we wanted to adapt
    our use cases for multiple platforms using Kotlin Multiplatform. A solution for
    this would be to develop a reactive plugin that would abstract the usage of flows
    and use this abstraction across the different modules. This would allow us to
    swap different reactive libraries without changing the code inside the module.
    While this solution would fix the problem, it comes with lots of baggage because
    we would need to abstract both the streams of data and the operators that the
    project requires from the flows framework, which would give us more code to maintain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Hilt 和协程的依赖可能会对 `:domain` 和 `:data-repository` 模块造成问题。我们希望这两个模块尽可能稳定，而外部依赖会在我们更新这些库的版本时每次都造成问题。我们决定使用
    flows，因为它们具有线程优势、响应式方法，并且因为它们是作为 Kotlin 框架的扩展开发的。如果我们想要使用 Kotlin Multiplatform
    对多个平台进行适配，它们可能仍然会存在问题。一个解决方案是开发一个反应式插件，该插件将抽象化 flows 的使用，并在不同的模块中使用这种抽象。这将使我们能够在不更改模块内部代码的情况下交换不同的反应式库。虽然这个解决方案会解决问题，但它带来了很多负担，因为我们需要从
    flows 框架中抽象出项目所需的数据流和操作符，这将给我们带来更多的代码需要维护。
- en: When it comes to the Hilt dependency, we can remove the references to Hilt from
    the `:domain` and `:data-repository` modules and move the Hilt modules into `:app`.
    Another solution would be to create new Gradle modules that would be responsible
    for providing the necessary dependency. For example, a `:domain-hilt` module could
    be created, where it would have a `@Module` annotated class that would provide
    all of the dependencies that the `:domain` module would need to expose. This approach
    can be used for other modules that we wish to export into applications that use
    different dependency injection frameworks to avoid the dependency on Hilt in those
    projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Hilt 依赖时，我们可以从 `:domain` 和 `:data-repository` 模块中移除对 Hilt 的引用，并将 Hilt 模块移动到
    `:app` 中。另一个解决方案是创建新的 Gradle 模块，这些模块将负责提供必要的依赖。例如，可以创建一个 `:domain-hilt` 模块，其中包含一个
    `@Module` 注解的类，该类将提供 `:domain` 模块所需的所有依赖项。这种方法可以用于其他我们希望导出到使用不同依赖注入框架的应用程序中的模块，以避免在这些项目中依赖
    Hilt。
- en: Module dependencies will increase as applications develop new features and evolve;
    this means we should take time and assess the dependencies used in a project.
    This will help us identify potential issues and whether we can scale an application
    properly. We should also account for external dependencies and analyze the influence
    they have over our project. In the following section, we will look at an exercise
    on how to reduce the dependencies that the domain and repository modules have
    on Hilt.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序开发新功能和演进，模块依赖将增加；这意味着我们应该花时间评估项目中的依赖项。这将帮助我们识别潜在问题，并确定我们是否可以正确地扩展应用程序。我们还应该考虑外部依赖，并分析它们对我们项目的影响。在下一节中，我们将探讨一个关于如何减少领域和仓库模块对
    Hilt 依赖的练习。
- en: Exercise 10.01 – Reduce dependencies
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.01 – 减少依赖
- en: Modify *Exercise 09.01 – transitioning to MVI* in [*Chapter 9*](B18320_09_ePub.xhtml#_idTextAnchor098),
    *Implementing an MVI Architecture*, so that the `domain` and `data-repository`
    modules will no longer depend on Hilt and instead provide the dependencies from
    those modules inside the `app` module.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *第 9 章* 中 *练习 09.01 – 转向 MVI*，*实现 MVI 架构*，以便 `domain` 和 `data-repository`
    模块将不再依赖于 Hilt，而是从 `app` 模块内部提供这些模块的依赖项。
- en: 'Before completing this exercise, you will need to do the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个练习之前，你需要做以下事情：
- en: Remove Hilt from the `domain` module.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`domain`模块中移除Hilt。
- en: Remove the `@Inject` annotation from the `GetPostsWithUsersWithInteractionUseCase`,
    `GetPostUseCase`, `GetUserUseCase`, and `UpdateInteractionUseCase` classes.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GetPostsWithUsersWithInteractionUseCase`、`GetPostUseCase`、`GetUserUseCase`和`UpdateInteractionUseCase`类中删除`@Inject`注解。
- en: Rename the `AppModule` class `UseCaseModule` and use `@Provides` to provide
    dependencies to the preceding objects.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AppModule`类重命名为`UseCaseModule`，并使用`@Provides`为前面的对象提供依赖。
- en: Remove Hilt from the `data-repository` module and delete the use of the `@Inject`
    annotation.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`data-repository`模块中移除Hilt，并删除`@Inject`注解的引用。
- en: Move `RepositoryModule` from the `data-repository` module into `app` and use
    `@Provides` to provide the dependencies to `PostRepository`, `UserRepository`,
    and `InteractionRepository`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RepositoryModule`从`data-repository`模块移动到`app`模块，并使用`@Provides`为`PostRepository`、`UserRepository`和`InteractionRepository`提供依赖。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'In the `build.gradle` file of the `domain` module, remove the use of the `kapt`
    and Hilt plugins:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`domain`模块的`build.gradle`文件中，移除对`kapt`和Hilt插件的引用：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the same file, delete the usages of Hilt from the `dependencies` block:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，从`dependencies`块中删除Hilt的引用：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Delete the use of `@Inject` from `GetPostsWithUsersWithInteractionUseCase`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GetPostsWithUsersWithInteractionUseCase`中删除`@Inject`的引用：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Delete the use of `@Inject` from `GetPostUseCase`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GetPostUseCase`中删除`@Inject`的引用：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Delete the use of `@Inject` from `GetUserUseCase`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GetUserUseCase`中删除`@Inject`的引用：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Delete the use of `@Inject` from `UpdateInteractionUseCase`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`UpdateInteractionUseCase`中删除`@Inject`的引用：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the app module, rename `AppModule` `UseCaseModule`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在app模块中，将`AppModule`重命名为`UseCaseModule`。
- en: 'In the app module in the `UseCaseModule` class, provide a dependency to `GetPostsWithUsersWithInteractionUseCase`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UseCaseModule`类中的app模块，为`GetPostsWithUsersWithInteractionUseCase`提供依赖：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we need to use `@Provides` because we are no longer in the same module,
    which means we should treat this as an external dependency, which needs the `@Provides`
    annotation, similar to how we provided the Room and Retrofit dependencies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要使用`@Provides`，因为我们不再处于同一个模块中，这意味着我们应该将其视为外部依赖，这需要`@Provides`注解，类似于我们提供Room和Retrofit依赖的方式。
- en: 'In the same class, provide a dependency to `GetPostUseCase`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个类中，为`GetPostUseCase`提供依赖：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this snippet, we follow the approach of the previous step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们遵循上一步的方法。
- en: 'In the same class, provide a dependency to `GetUserUseCase`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个类中，为`GetUserUseCase`提供依赖：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this snippet, we follow the approach of the previous step.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们遵循上一步的方法。
- en: 'In the same class, provide a dependency to `UpdateInteractionUseCase`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个类中，为`UpdateInteractionUseCase`提供依赖：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this snippet, we follow the approach of the previous step.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们遵循上一步的方法。
- en: 'In the `build.gradle` file of the `data-repository` module, remove the use
    of the `kapt` and Hilt plugins:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data-repository`模块的`build.gradle`文件中，移除对`kapt`和Hilt插件的引用：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the same file, delete the usages of Hilt from the `dependencies` block:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，从`dependencies`块中删除Hilt的引用：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Move the `RepositoryModule` class from the injection package in the `data-repository`
    module into the injection package in the `app` module and make the class not abstract.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RepositoryModule`类从`data-repository`模块的注入包移动到`app`模块的注入包，并使该类非抽象。
- en: 'Delete the use of `@Inject` from `InteractionRepositoryImpl`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`InteractionRepositoryImpl`中删除`@Inject`的引用：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Delete the use of `@Inject` from `PostRepositoryImpl`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`PostRepositoryImpl`中删除`@Inject`的引用：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Delete the use of `@Inject` from `UserRepositoryImpl`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`UserRepositoryImpl`中删除`@Inject`的引用：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `RepositoryModule` class, replace the `bindPostRespository` method with
    a `@Provides` method:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RepositoryModule`类中，将`bindPostRespository`方法替换为`@Provides`方法：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are no longer able to use the `@Binds` annotation because we removed
    the `@Inject` annotation from the `PostRepositoryImpl` class, and because it is
    an external dependency, we will need to use `@Provides`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们不再能够使用`@Binds`注解，因为我们从`PostRepositoryImpl`类中移除了`@Inject`注解，并且因为它是一个外部依赖，我们将需要使用`@Provides`。
- en: 'In the same file, replace the `bindUserRepository` method with a `@Provides`
    method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，将`bindUserRepository`方法替换为`@Provides`方法：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the same file, replace `bindInteractionRepositorymethod` with a `@Provides`
    method:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，将`bindInteractionRepositorymethod`替换为`@Provides`方法：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run the application, we should see the same output that we got in *Exercise
    09.01 – Transitioning to MVI*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们应该看到与*练习09.01 – 转换到MVI*中相同的输出：
- en: '![Figure 10.3 – The output of exercise 10.01'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 练习10.01的输出'
- en: '](img/Figure_10.03_B18320_Merged.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.03_B18320_Merged.jpg)'
- en: Figure 10.3 – The output of exercise 10.01
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 练习10.01的输出
- en: The project is now in a state where the `domain` and `data-repository` modules
    no longer depend on Hilt. This means that all the other modules that depend on
    these two will be less exposed to potential issues caused by updates to Hilt.
    It also means that in the future, if we want to change the dependency injection
    framework used across the application, the `domain` and `data-repository` modules
    will remain unaffected by the change. In the section that follows, we will look
    at how we can create instrumentation tests with mock data to test that the modules
    are well integrated and that the data being passed is processed appropriately.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在处于`domain`和`data-repository`模块不再依赖于Hilt的状态。这意味着所有依赖这两个模块的其他模块将较少暴露于由Hilt更新引起的潜在问题。这也意味着，在未来，如果我们想要更改应用程序中使用的依赖注入框架，`domain`和`data-repository`模块将不会受到影响。在接下来的部分中，我们将探讨如何使用模拟数据创建仪器测试来测试模块是否良好集成以及传递的数据是否得到适当处理。
- en: Instrumentation testing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪器测试
- en: In this section, we will look at how to perform instrumentation testing for
    an Android application and how we can take advantage of dependency injection to
    inject either mock data or add test-related logic without modifying the structure
    of an application's code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何对Android应用程序进行仪器测试，以及我们如何利用依赖注入注入模拟数据或添加与测试相关的逻辑，而无需修改应用程序代码的结构。
- en: Instrumentation testing is a set of tests that are run on an Android device
    or emulator and is represented by the tests written in the `androidTest` directory.
    Just like other parts of Android development, instrumentation testing evolved
    across the years to improve the quality of test code and to provide the ability
    to create better tests and assertions. Initially, testing was done using test
    classes such as `ActivityTestCase`, `ContentProviderTestCase`, and `ServiceTestCase`,
    which were mainly used to test individual components of an application in isolation.
    The addition of the Espresso testing libraries allows us to easily test multiple
    activities as part of the journey a user would undertake.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器测试是一组在Android设备或模拟器上运行的测试，由`androidTest`目录中的测试表示。就像Android开发的其它部分一样，仪器测试在多年中不断发展，以提高测试代码的质量，并提供了创建更好测试和断言的能力。最初，测试是通过使用如`ActivityTestCase`、`ContentProviderTestCase`和`ServiceTestCase`等测试类来完成的，这些类主要用于在隔离状态下测试应用程序的各个组件。Espresso测试库的添加使我们能够轻松地测试用户可能执行的多项活动作为旅程的一部分。
- en: 'In order to add Espresso and the associated libraries into a project, the following
    will need to be added to any module''s `build.gradle` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Espresso及其相关库添加到项目中，需要在任何模块的`build.gradle`文件中添加以下内容：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is an example of a test written using Espresso:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Espresso编写的测试示例：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we use the `ActivityScenario` launch method to start
    `MainActivity` and transition `Activity` to the `RESUMED` state. We then use `onView`,
    which requires `ViewMatcher`, and `withId` looks up `View` by its ID and returns
    `ViewMatcher` holding that information. We then have the option to use `perform`,
    which requires `ViewAction`. This is for when we want to interact with certain
    views. We can also perform `ViewAssertion` using the `check` method. In this case,
    we are checking whether a view is displayed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`ActivityScenario`启动方法来启动`MainActivity`并将`Activity`状态转换为`RESUMED`。然后我们使用`onView`，它需要`ViewMatcher`，并通过`withId`根据其ID查找`View`并返回包含该信息的`ViewMatcher`。然后我们有使用`perform`的选项，它需要`ViewAction`。这是当我们想要与某些视图交互时的情况。我们还可以使用`check`方法执行`ViewAssertion`。在这种情况下，我们正在检查视图是否显示。
- en: 'Another useful addition to help with testing is the orchestrator. The orchestrator
    is useful when we want to delete the data generated by the tests that might be
    kept in memory or persisted on the device and that in turn might impact other
    tests and cause them to malfunction. What the orchestrator does is uninstall the
    application before each executed test so that every test will be on a freshly
    installed app. In order to add the orchestrator to the application, you will need
    to add it to the module''s `build.gradle` file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有助于测试的有用补充是协调器。当我们需要删除测试生成的数据，这些数据可能保存在内存中或持久化在设备上，进而可能影响其他测试并导致它们故障时，协调器非常有用。协调器的作用是在每次执行测试之前卸载应用程序，这样每个测试都将在一个新安装的应用程序上进行。为了将协调器添加到应用程序中，您需要在模块的`build.gradle`文件中添加它：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will add the orchestrator configuration into the test execution and pass
    the instruction to delete the application data after each test. To add the orchestrator
    dependency into the project, the following is required:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在测试执行中添加协调器配置，并在每次测试后传递删除应用程序数据的指令。要将协调器依赖项添加到项目中，需要以下操作：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Espresso also comes with many extensions, one of which is the concept of `IdlingResource`.
    When both local tests (tests that are run on the development machine) and instrumented
    tests are run, they are run on a dedicated set of threads for testing. The Espresso
    testing library will monitor the main thread of the application, and when it is
    idle, it will make the assertions required. If the application uses background
    threads, Espresso will need a way to be informed by this. We can use `IdlingResource`
    to indicate to Espresso wait for an action to complete before continuing its execution.
    An example of `IdlingResource` is `CountingIdlingResource`, which will hold a
    counter for each operation Espresso will need to wait for. The counter is incremented
    before each long-running operation and then decremented after the operation is
    completed. Before each test, `IdlingResource` will need to be registered and then
    unregistered when the test finishes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso还附带了许多扩展，其中之一是`IdlingResource`的概念。当运行本地测试（在开发机上运行的测试）和仪器化测试时，它们会在专门的一组线程上运行。Espresso测试库将监控应用程序的主线程，当它空闲时，将执行所需的断言。如果应用程序使用后台线程，Espresso需要一种方式来通知这一点。我们可以使用`IdlingResource`来指示Espresso在继续执行之前等待某个动作完成。`IdlingResource`的一个例子是`CountingIdlingResource`，它将为Espresso需要等待的每个操作保持一个计数器。在每次长时间运行的操作之前，计数器会增加，操作完成后会减少。在每次测试之前，`IdlingResource`需要注册，测试完成后注销：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding example, we have `CountingIdlingResource` being incremented
    at the beginning of the `doOperation` method and decremented after the long operation
    we intend to perform. To register and unregister `IdlingResource`, we can perform
    the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`doOperation`方法开始时增加`CountingIdlingResource`的计数，在执行我们打算进行的长时间操作之后减少。为了注册和注销`IdlingResource`，我们可以执行以下操作：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we register `IdlingResource` in the `setUp` method, which is
    called before each test because of the `@Before` annotation, and unregister it
    in the `tearDown` method, which is called after each test because of the `@After`
    annotation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`setUp`方法中注册`IdlingResource`，由于`@Before`注解，该方法在每次测试之前被调用，并在`tearDown`方法中注销它，由于`@After`注解，该方法在每次测试之后被调用。
- en: 'Because `IdlingResource` is a part of Espresso but needs to be used when operations
    inside the application''s code are executed, we want to avoid using `IdlingResource`
    alongside that code. A solution for this is to decorate the class that contains
    the operation and then use dependency injection to inject the decorated dependency
    into the test. To decorate the code, we will need to have an abstraction for the
    operation. An example of this is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`IdlingResource`是Espresso的一部分，但在执行应用程序代码内的操作时需要使用它，所以我们希望避免在相关代码中使用`IdlingResource`。为此，我们可以通过装饰包含操作的类，然后使用依赖注入将装饰过的依赖注入到测试中。为了装饰代码，我们需要有一个操作抽象。以下是一个例子：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding example, we have created an interface that defines the `doOperation`
    method, and then we implement the interface with the long-running operation into
    a class. We can now create a class that will belong to the `androidTest` folder,
    which will decorate the current implementation of the class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个定义`doOperation`方法的接口，然后我们通过将长时间运行的操作实现为类来使用该接口。现在我们可以创建一个属于`androidTest`文件夹的类，它将装饰当前类的实现：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we have another implementation of `MyInterface`, which will hold a reference
    to the abstraction and `CountingIdlingResource`. When `doOperation` is called,
    we will increment `IdlingResource`, call the operation, and then, when it's done,
    decrement `IdlingResource`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实现了 `MyInterface` 的另一个版本，它将持有对抽象和 `CountingIdlingResource` 的引用。当调用 `doOperation`
    时，我们将增加 `IdlingResource`，调用操作，然后，当操作完成时，减少 `IdlingResource`。
- en: 'If we want to inject the new dependency into the test, we will need first to
    define a new class that extends `Application`, which will hold the dependency
    graph containing the test dependencies. If we are using Hilt, it already provides
    such a class in the form of `HiltTestApplication`. If we want to integrate Hilt
    into the instrumented tests, we will need the following dependencies to be added
    to the module''s `build.gradle` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将新依赖项注入到测试中，我们首先需要定义一个新的扩展 `Application` 的类，该类将包含包含测试依赖项的依赖项图。如果我们使用 Hilt，它已经以
    `HiltTestApplication` 的形式提供了这样的类。如果我们想要将 Hilt 集成到受测测试中，我们需要将以下依赖项添加到模块的 `build.gradle`
    文件中：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To provide the `HiltTestApplication` class to the test, we will need to change
    the instrumented test runner. An example of a new test runner will look like the
    following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `HiltTestApplication` 类提供给测试，我们需要更改受测测试运行器。一个新测试运行器的示例如下：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this example, we are extending from `AndroidJUnitRunner`, and in the `newApplication`
    method, we invoke the `super` method, and we pass `HiltTestApplication` as the
    `name`. This means that when the test is executed, `HiltTestApplication` will
    be used instead of the `Application` class we defined in our main code. We will
    now need to change the configuration in the module''s `build.gradle` file to use
    the preceding runner:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们扩展了 `AndroidJUnitRunner`，并在 `newApplication` 方法中调用 `super` 方法，并将 `HiltTestApplication`
    作为 `name` 传递。这意味着当测试执行时，将使用 `HiltTestApplication` 而不是我们在主代码中定义的 `Application`
    类。我们现在需要更改模块的 `build.gradle` 文件中的配置以使用前面的运行器：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This allows the instrumented test to use the runner we have created. Let''s
    now assume that we have the following module, which will provide the initial dependency:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许受测测试使用我们创建的运行器。现在假设我们有一个以下模块，它将提供初始依赖项：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we are using a simple binding to connect an implementation to the abstraction.
    In the `androidTest` folder, we can create a new module in which we replace this
    instance with the decorated one:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用简单的绑定将实现连接到抽象。在 `androidTest` 文件夹中，我们可以创建一个新的模块，在其中用装饰实例替换此实例：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, we use the `@TestInstallIn` annotation, which will make the
    dependencies in this module live as long as the test application and replace the
    dependencies in the previous module. We can then provide dependencies for `IdlingResource`
    and `MyDecoratedClass`, which will wrap `MyClass` and use `IdlingResource`. If
    we want these changes to take effect in the tests, we will need the following
    changes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了 `@TestInstallIn` 注解，这将使此模块中的依赖项与测试应用程序的生命周期保持一致，并替换上一个模块中的依赖项。然后我们可以为
    `IdlingResource` 和 `MyDecoratedClass` 提供依赖项，后者将包装 `MyClass` 并使用 `IdlingResource`。如果我们想要这些更改在测试中生效，我们需要以下更改：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we have used the `@HiltAndroidTest` annotation because we want
    to inject `CountingIdlingResources` into the test. We then used `HiltAndroidTestRule`
    to perform the injection. We also gave it the highest priority in terms of the
    order of execution for test rules. Finally, we were able to register and unregister
    `CountingIdlingResources` for each test in the class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了 `@HiltAndroidTest` 注解，因为我们想要将 `CountingIdlingResources` 注入到测试中。然后我们使用了
    `HiltAndroidTestRule` 来执行注入。我们还给它赋予了测试规则执行顺序中的最高优先级。最后，我们能够在类中的每个测试中注册和注销 `CountingIdlingResources`。
- en: 'Jetpack Compose comes with its own testing libraries, which require the following
    configuration to the module''s `build.gradle` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 自带测试库，需要将以下配置添加到模块的 `build.gradle` 文件中：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To write tests for Jetpack Compose components, we will need to define a Compose
    test rule using `createComposeRule` when we want to test individual composable
    methods, or `createAndroidComposeRule` if we want to test the Compose content
    of an entire activity. An example would look like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Jetpack Compose 组件编写测试，当我们想要测试单个可组合方法时，需要使用 `createComposeRule` 定义一个 Compose
    测试规则，或者如果我们想要测试整个活动的 Compose 内容，则使用 `createAndroidComposeRule`。一个示例如下：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding example, we have defined a test rule that will be responsible
    for testing the Compose content inside `MyActivity`. If we want the test to interact
    with the user interface or assert that it displays the correct information, we
    have the following structure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个测试规则，该规则将负责测试 `MyActivity` 内部的 Compose 内容。如果我们想让测试与用户界面交互或断言它显示正确的信息，我们将有如下结构：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this example we use the `onNode` method to locate a particular element,
    such as `Text` or `Button`. We then have the `assertIsDisplayed` method, which
    is used to check whether the node is displayed. Finally, we have the `performClick`
    method, which will click on the element. Jetpack Compose uses its own `IdlingResource`
    type, which can be registered in the Compose test rule, similar to the following
    example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `onNode` 方法来定位特定的元素，例如 `Text` 或 `Button`。然后我们有 `assertIsDisplayed`
    方法，用于检查节点是否显示。最后，我们有 `performClick` 方法，它将点击元素。Jetpack Compose 使用它自己的 `IdlingResource`
    类型，可以在 Compose 测试规则中注册，类似于以下示例：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From a clean architecture perspective, we should strive to make our application's
    code as testable as possible. This applies to both local tests such as unit tests
    and instrumented tests. We want to be able to ensure that the tests are reliable;
    this usually means that we will need to remove the dependency on network calls,
    which means we will need to provide a way to inject mock data into the application
    without modifying the application's code. We also need to be able to either inject
    `IdlingResources` into the application or use decorated dependencies to verify
    that the data inserted by the user is the correct data received in the data layer.
    This also involves the ability to decorate these dependencies to add extra logic
    without modifying the application's code. In the following section, we will look
    at an exercise in which we will inject various dependencies containing testing
    logic into the application and assess the difficulty it takes to introduce them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从干净架构的角度来看，我们应该努力使我们的应用程序代码尽可能可测试。这适用于本地测试，如单元测试和仪器测试。我们希望确保测试是可靠的；这通常意味着我们需要移除对网络调用的依赖，这意味着我们需要提供一种方法将模拟数据注入应用程序而不修改应用程序的代码。我们还需要能够将
    `IdlingResources` 注入到应用程序中，或者使用装饰依赖项来验证用户插入的数据是否是数据层接收到的正确数据。这也涉及到装饰这些依赖项以添加额外逻辑的能力，而不修改应用程序的代码。在下一节中，我们将查看一个练习，我们将向应用程序中注入包含测试逻辑的各种依赖项，并评估引入它们的难度。
- en: Exercise 10.02 – Instrumented testing
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.02 – 仪器测试
- en: 'Add one instrumented test to *Exercise 10.01 – Reduce dependencies*, which
    will assert that the following data is displayed onscreen:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 向 *Exercise 10.01 – 减少依赖* 添加一个仪器测试，该测试将断言以下数据显示在屏幕上：
- en: '![Figure 10.4 – The expected output of exercise 10.02'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.4 – 练习 10.02 的预期输出'
- en: '](img/Figure_10.04_B18320.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.04_B18320.jpg]'
- en: Figure 10.4 – The expected output of exercise 10.02
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.4 – 练习 10.02 的预期输出
- en: To achieve this, you will need to create a new implementation of `RemotePostDataSource`,
    which will return a list of four posts; two posts will belong to one user and
    the other two will belong to another user. The same thing will need to be done
    for `RemoteUserDataSource`, which will return the two users. These implementations
    will need to be injected into the test. To ensure that the test will wait for
    the background work to complete, you will need to decorate each repository with
    `IdlingResource`, which will also need to be injected into the test.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要创建一个新的 `RemotePostDataSource` 实现，该实现将返回四个帖子；其中两个帖子属于一个用户，另外两个帖子属于另一个用户。同样，对于返回两个用户的
    `RemoteUserDataSource`，也需要执行同样的操作。这些实现需要注入到测试中。为了确保测试将等待后台工作完成，你需要用 `IdlingResource`
    装饰每个仓库，这些 `IdlingResource` 也需要注入到测试中。
- en: 'Before completing this exercise, you will need to do the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个练习之前，你需要做以下事情：
- en: Integrate the testing libraries into the app module.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试库集成到应用模块中。
- en: Create `PostAppTestRunner`, which will be used to provide `HiltTestApplication`
    to the Android instrumentation test runner.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PostAppTestRunner`，它将被用来向 Android 仪器测试运行器提供 `HiltTestApplication`。
- en: Create a `ComposeCountingIdlingResource` class, which will wrap an Espresso
    `CountingIndlingResource` and implement the Compose `IdlingResource`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ComposeCountingIdlingResource` 类，它将包装一个 Espresso 的 `CountingIndlingResource`
    并实现 Compose 的 `IdlingResource`。
- en: Create `MockRemotePostDataSource` and `MockRemoteUserDataSource`, which will
    be responsible for returning the users and posts in presented in *Figure 10.4*.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MockRemotePostDataSource`和`MockRemoteUserDataSource`，它们将负责返回在*图10.4*中展示的用户和帖子。
- en: Create `IdlingInteractionRepository`, `IdlingUserRepository`, and `IdlingPostRespository`,
    which will decorate `InteractionRepository`, `UserRepository`, and `PostRepository`,
    and use the `ComposeCountingIdlingResource`, which will be incremented when new
    data is loaded and decremented when data loading is done.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`IdlingInteractionRepository`、`IdlingUserRepository`和`IdlingPostRepository`，这些类将装饰`InteractionRepository`、`UserRepository`和`PostRepository`，并使用`ComposeCountingIdlingResource`，当加载数据时将增加计数，当数据加载完成时将减少计数。
- en: Create `IdlingRepositoryModule` and `MockRemoteDataSourceModule`, which will
    replace `RepositoryModule` and `RemoteDataSourceModule` respectively in the tests.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`IdlingRepositoryModule`和`MockRemoteDataSourceModule`，它们将分别在测试中替换`RepositoryModule`和`RemoteDataSourceModule`。
- en: Create `MainActivityTest`, which will have one test, and use `createAndroidComposeRule`
    to assert that the list of mock data is displayed.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MainActivityTest`，它将有一个测试，并使用`createAndroidComposeRule`来断言显示模拟数据列表。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'In the top-level `build.gradle` file, add the following library versions:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶级`build.gradle`文件中，添加以下库版本：
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the same file, make sure that the following `androidTest` dependencies are
    added:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的文件中，确保添加以下`androidTest`依赖项：
- en: '[PRE37]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we are defining the mappings for all the testing libraries we will be
    using so that they will be available across multiple modules.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义所有将要使用的测试库的映射，以便它们可以在多个模块中使用。
- en: 'In the `build.gradle` file of the app module, add the required test dependencies:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用模块的`build.gradle`文件中，添加所需的测试依赖项：
- en: '[PRE38]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `androidTest` folder of the app module, create the `PostAppTestRunner`
    class inside the `java/{package-name}` folder:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用模块的`androidTest`文件夹中，在`java/{package-name}`文件夹内创建`PostAppTestRunner`类：
- en: '[PRE39]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `build.gradle` file of the app module, set the following test configuration.
    Make sure to replace `{package-name}` with the package that the `PostAppTestRunner`
    is in:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用模块的`build.gradle`文件中，设置以下测试配置。确保将`{package-name}`替换为`PostAppTestRunner`所在的包：
- en: '[PRE40]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `androidTest` folder of the app module, create the following packages
    inside the `java/{package-name}` folder – `idling`, `injection`, `remote`, `repository`,
    and `test`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用模块的`androidTest`文件夹中，在`java/{package-name}`文件夹内创建以下包 – `idling`、`injection`、`remote`、`repository`和`test`。
- en: 'Inside the `idling` package, create a new class called `ComposeCountingIdlingResource`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`idling`包内，创建一个名为`ComposeCountingIdlingResource`的新类：
- en: '[PRE41]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we have used the `CountingIdlingResource` class from Espresso to perform
    the logic for incrementing, decrementing, and providing its current idling state
    through the `isIdleNow` method, which is used by Jetpack Compose.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了Espresso的`CountingIdlingResource`类来执行增加、减少和通过`isIdleNow`方法提供其当前空闲状态逻辑，该方法由Jetpack
    Compose使用。
- en: 'In the same package, create a file called `IdlingUtils` with the following
    method:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的包中，创建一个名为`IdlingUtils`的文件，包含以下方法：
- en: '[PRE42]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is an extension function that we can use to increment `IdlingResource`
    before `Flow` is collected and decrement it when the first value of `Flow` is
    being emitted.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个扩展函数，我们可以在收集`Flow`之前增加`IdlingResource`，在`Flow`的第一个值被发射时减少它。
- en: 'In the `repository` package, create a class called `IdlingInteractionRepository`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`repository`包中，创建一个名为`IdlingInteractionRepository`的类：
- en: '[PRE43]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This class has a reference to the `ComposeCountingIdlingResource` object and
    the `attachIdling` method created previously to increment when the data is loaded
    or saved and to decrement when it's done performing these operations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个对`ComposeCountingIdlingResource`对象的引用和之前创建的`attachIdling`方法，当数据加载或保存时增加计数，当完成这些操作时减少计数。
- en: 'In the same package, create a class called `IdlingPostRepository`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的包中，创建一个名为`IdlingPostRepository`的类：
- en: '[PRE44]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this snippet, we follow the approach of the previous step.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们遵循上一步的方法。
- en: 'In the same package, create a class called `IdlingUserRepository`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的包中，创建一个名为`IdlingUserRepository`的类：
- en: '[PRE45]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this snippet, we follow the approach of the previous step.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们遵循上一步的方法。
- en: 'In the `injection` package, create the `IdlingRepositoryModule` class:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`injection`包中，创建`IdlingRepositoryModule`类：
- en: '[PRE46]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `IdlingRepositoryModule` class, provide a dependency for `ComposeCountingIdlingResource`,
    which will be a single instance across all the repositories:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IdlingRepositoryModule` 类中，提供一个对 `ComposeCountingIdlingResource` 的依赖，这将是一个跨所有仓库的单例：
- en: '[PRE47]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this snippet, we are providing a single instance of `ComposeCountingIdlingResource`
    so that when multiple repositories load data at the same time, the same counter
    will be used for all of them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们提供了一个 `ComposeCountingIdlingResource` 的单例实例，以便当多个仓库同时加载数据时，将使用相同的计数器为它们所有。
- en: 'In the same file, provide a dependency for `IdlingPostRepository`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，提供一个对 `IdlingPostRepository` 的依赖：
- en: '[PRE48]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this snippet, we are providing an instance of the `IdlingPostRepository`,
    which will wrap an instance of `PostRepositoryImpl` and have a reference to the
    `ComposeCountingIdlingResource` instance defined previously.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们提供了一个 `IdlingPostRepository` 的实例，它将包装一个 `PostRepositoryImpl` 的实例，并且有一个对之前定义的
    `ComposeCountingIdlingResource` 实例的引用。
- en: 'In the same file, provide a dependency for `IdlingUserRepository`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，提供一个对 `IdlingUserRepository` 的依赖：
- en: '[PRE49]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this snippet, we are providing an instance of `IdlingUserRepository`, which
    will wrap an instance of `UserRepositoryImpl` and have a reference to the `ComposeCountingIdlingResource`
    instance defined previously.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们提供了一个 `IdlingUserRepository` 的实例，它将包装一个 `UserRepositoryImpl` 的实例，并且有一个对之前定义的
    `ComposeCountingIdlingResource` 实例的引用。
- en: 'In the same file, provide a dependency for `IdlingInteractionRepository`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，提供一个对 `IdlingInteractionRepository` 的依赖：
- en: '[PRE50]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this snippet, we are providing an instance of `IdlingInteractionRepository`,
    which will wrap an instance of `InteractionRepositoryImpl` and have a reference
    to the `ComposeCountingIdlingResource` instance defined previously.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们提供了一个 `IdlingInteractionRepository` 的实例，它将包装一个 `InteractionRepositoryImpl`
    的实例，并且有一个对之前定义的 `ComposeCountingIdlingResource` 实例的引用。
- en: 'In the `remote` package, create a class called `MockRemoteUserDataSource` and
    create a list of `User` objects representing the test data:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `remote` 包中，创建一个名为 `MockRemoteUserDataSource` 的类，并创建一个代表测试数据的 `User` 对象列表：
- en: '[PRE51]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we have created a list in which we return two users and put it into `Flow`
    for the `getUsers` method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个列表，其中返回两个用户，并将其放入 `Flow` 的 `getUsers` 方法中。
- en: 'In the same package, create a class called `MockRemotePostDataSource` and create
    a list of `Post` objects representing the test data:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个名为 `MockRemotePostDataSource` 的类，并创建一个代表测试数据的 `Post` 对象列表：
- en: '[PRE52]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Similar to what we did with the users, we create a list of posts and connect
    the first two posts to the first user and the last two posts to the second user.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对用户所做的一样，我们创建了一个帖子列表，并将前两个帖子连接到第一个用户，将最后两个帖子连接到第二个用户。
- en: 'In the `injection` package, create a class called `MockRemoteDataSourceModule`,
    which will be responsible for binding the previous two implementations to the
    abstractions:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `injection` 包中，创建一个名为 `MockRemoteDataSourceModule` 的类，它将负责将之前的两个实现绑定到抽象：
- en: '[PRE53]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `test` package, create a class called `MainActivityTest`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test` 包中，创建一个名为 `MainActivityTest` 的类：
- en: '[PRE54]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we are initializing our test rules, which are for Hilt and Compose, in
    that exact order. Then, we inject `ComposeCountingIdlingResource` into the test
    class so that we can register it into the Compose test rule.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在初始化我们的测试规则，这些规则是针对 Hilt 和 Compose 的，并且按照这个确切顺序。然后，我们将 `ComposeCountingIdlingResource`
    注入到测试类中，以便我们可以将其注册到 Compose 测试规则中。
- en: 'In the `MainActivityTest` class, add a test that will assert that the required
    data is displayed on the screen:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivityTest` 类中，添加一个测试，该测试将断言所需的数据显示在屏幕上：
- en: '[PRE55]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we have added a test that asserts that the header text is displayed, the
    two users are displayed for each of their posts, and that each post is displayed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个测试，断言标题文本被显示，每个用户都显示在其帖子中，并且每个帖子都被显示。
- en: 'If we run the test, we should see the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，我们应该看到以下输出：
- en: '![Figure 10.5 – The test output for exercise 10.02'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 练习 10.02 的测试输出'
- en: '](img/Figure_10.05_B18320.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.05_B18320.jpg)'
- en: Figure 10.5 – The test output for exercise 10.02
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 练习 10.02 的测试输出
- en: As part of this exercise, we were able to provide mock data to the application
    without changing any of its existing code by changing the remote data sources
    and building upon existing functionality, by adding `IdlingResources` to our repositories.
    Both techniques were possible using dependency injection, and because of abstractions,
    we introduced different layers of the application when we performed dependency
    inversion. This makes the application's code testable and provides us with the
    opportunity to test different scenarios and create various types of tests to ensure
    the integration of different components.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这项练习的一部分，我们通过更改远程数据源并基于现有功能添加`IdlingResources`到我们的仓库中，能够在不更改应用现有代码的情况下向应用提供模拟数据。这两种技术都使用了依赖注入，并且由于抽象的存在，我们在执行依赖反转时引入了应用的不同层。这使得应用代码可测试，并为我们提供了测试不同场景和创建各种类型测试的机会，以确保不同组件的集成。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the exercises we've done in previous chapters and
    found potential issues with the dependencies that the modules of the application
    have. We looked at potential solutions for these problems. Then, we looked at
    a practical application of clean architecture, which is the implementation of
    instrumented tests, and how we can change the data sources of an application to
    ensure testing reliability. We looked at how we can implement instrumented tests
    using Jetpack Compose and Hilt to provide dependency injection, and then we applied
    them in an exercise in which we changed the dependencies for the tests. This serves
    as just one example of the benefits of clean architecture. Other benefits will
    come in situations where multiple flavors are used to publish similar applications
    and want to inject different implementations or configurations for each application
    we want to build. Another benefit comes when dealing with multiple platforms (such
    as Android and iOS), where we can define entities, use cases and repositories
    agnostically of the platforms using cross platform frameworks and then inject
    the implementations for retrieving and persisting the data for each platform.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了之前章节中进行的练习，并发现了应用模块依赖中可能存在的问题。我们研究了这些问题的潜在解决方案。然后，我们探讨了清洁架构的实际应用，即实现仪器化测试，以及我们如何更改应用的数据源以确保测试的可靠性。我们探讨了如何使用Jetpack
    Compose和Hilt实现仪器化测试，并提供依赖注入，然后在一个练习中应用了它们，该练习中我们更改了测试的依赖项。这仅仅是一个清洁架构好处的例子。在其他情况下，当使用多个版本发布类似的应用并希望为每个要构建的应用注入不同的实现或配置时，也会有其他好处。另一个好处是在处理多个平台（如Android和iOS）时，我们可以使用跨平台框架无差别地定义实体、用例和仓库，然后注入每个平台检索和持久化数据的具体实现。
- en: In [*Chapter 9*](B18320_09_ePub.xhtml#_idTextAnchor098), *Implementing an MVI
    Architecture*, we showed how we can change an application's presentation layer
    without impacting other layers. In a clean application, this should be possible
    for the data layer as well. We saw how libraries have changed and evolved over
    time. When networking libraries change, we should be able to transition to new
    libraries without causing issues in the other modules of an application. The same
    principle can be applied to local storage. We should be able to change from Room
    to other ways of persisting data locally. A good rule of thumb for how modules
    should be created is to view each module as a library that can be released and
    imagine yourself as the end user. You should have now a good idea of how clean
    architecture is supposed to work, the problems it is trying to solve, and how
    you can apply it to an Android application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18320_09_ePub.xhtml#_idTextAnchor098)《实现MVI架构》中，我们展示了如何在不影响其他层的情况下更改应用的表现层。在清洁应用中，数据层也应该能够做到这一点。我们看到了库是如何随着时间的推移而改变和演化的。当网络库发生变化时，我们应该能够过渡到新的库，而不会在其他应用模块中引起问题。同样的原则也可以应用于本地存储。我们应该能够从Room转换到其他本地数据持久化方式。一个关于模块应该如何创建的好规则是，将每个模块视为一个可以发布的库，并想象自己是最终用户。你现在应该对清洁架构应该如何工作、它试图解决的问题以及如何将其应用于Android应用有一个很好的了解。
