- en: Chapter 3. Debugging with OpenGL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使用 OpenGL ES 调试
- en: The **Open Graphics Library** (**OpenGL**) can be simply defined as a *software
    interface to the graphics hardware*. It is a 3D graphics and modeling library
    that is highly portable and extremely fast. Using the OpenGL graphics API, you
    can create some brilliant graphics that are capable of representing 2D and 3D
    data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放图形库**（**OpenGL**）可以简单地定义为“图形硬件的软件接口”。它是一个高度可移植且非常快速的 3D 图形和建模库。使用 OpenGL
    图形 API，你可以创建一些能够表示 2D 和 3D 数据的出色图形。'
- en: The OpenGL library is a multi-purpose, open-source graphics library that supports
    applications for 2D and 3D digital content creation, mechanical and architectural
    design, virtual prototyping, flight simulation, and video games, and allows application
    developers to configure a 3D graphics pipeline, and submit data to it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 库是一个多用途的开源图形库，支持 2D 和 3D 数字内容创作、机械和建筑设计、虚拟原型设计、飞行模拟和视频游戏等应用，并允许应用程序开发者配置
    3D 图形管线，并向其提交数据。
- en: An object is defined by connected vertices. The vertices of the object are then
    transformed, lit, and assembled into primitives, and rasterized to create a 2D
    image that can be directly sent to the underlying graphics hardware to render
    the drawing, which is deemed to be typically very fast, due to the hardware being
    dedicated to processing graphics commands.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对象由连接的顶点定义。然后对象的顶点被变换、光照，并组装成原语，然后光栅化以创建一个可以直接发送到底层图形硬件进行渲染的 2D 图像，这通常非常快，因为硬件是专门用于处理图形命令的。
- en: '**OpenGL for Embedded Systems** (**OpenGL ES**) is a simplified version of
    the popular OpenGL framework that has been developed to be much easier to learn
    and implement, eliminating the need for redundant functionality within the iOS
    graphics hardware. This framework has been optimized to take full advantage of
    hardware-accelerated mathematical operations, so that developers can get the best
    performance.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入式系统 OpenGL**（**OpenGL ES**）是流行的 OpenGL 框架的简化版本，它被开发得更容易学习和实现，消除了 iOS 图形硬件中冗余功能的需求。这个框架已经优化，以充分利用硬件加速的数学运算，从而使开发者能够获得最佳性能。'
- en: In this chapter, we will be focusing on the new debugging features that come
    with the OpenGL ES debugger that enables developers to track down issues specific
    to OpenGL ES in your code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注 OpenGL ES 调试器带来的新调试特性，使开发者能够追踪代码中与 OpenGL ES 相关的具体问题。
- en: 'In this chapter we will:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about the new workflow feature within Xcode 4
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Xcode 4 中的新工作流程特性
- en: Create a simple project to debug an OpenGL ES application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的项目来调试 OpenGL ES 应用程序
- en: Familiarize ourselves with the OpenGL ES 2.0 programmable pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 OpenGL ES 2.0 可编程管线
- en: Compile and link shaders into an OpenGL ES program
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和链接着色器到 OpenGL ES 程序
- en: Pass data from an application to shaders, using uniforms and attributes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统一变量和属性从应用程序传递数据到着色器
- en: Detect OpenGL ES State information (view textures and shaders)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测 OpenGL ES 状态信息（视图纹理和着色器）
- en: Set and use breakpoints to catch OpenGL ES errors
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用断点来捕获 OpenGL ES 错误
- en: Set conditional OpenGL ES entry point breakpoints
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置条件 OpenGL ES 入口点断点
- en: Break on frame boundaries
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在帧边界处断点
- en: We have some fantastic stuff to cover in this chapter, so let's get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨一些精彩的内容，让我们开始吧。
- en: Understanding the new workflow feature within Xcode
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Xcode 中的新工作流程特性
- en: In this section, we will be taking a look at the improvements that have been
    made to the Xcode 4 development environment, and how this can enable us to debug
    OpenGL ES applications much easier, compared to the previous versions of Xcode.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Xcode 4 开发环境所做的改进，以及这如何使我们比之前版本的 Xcode 更容易地调试 OpenGL ES 应用程序。
- en: We will look at how we can use the frame capture feature of the debugger to
    capture all frame objects that are included within an OpenGL ES application. This
    tool enables you to list all the frame objects that are currently used by your
    application at a given point of time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用调试器的帧捕获功能来捕获 OpenGL ES 应用程序中包含的所有帧对象。这个工具使你能够在特定时间点列出应用程序当前使用的所有帧对象。
- en: We will familiarize ourselves with the new OpenGL ES debugger within Xcode,
    to enable us to track down specific issues relating to OpenGL ES within the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将熟悉 Xcode 中的新 OpenGL ES 调试器，以便我们能够追踪代码中与 OpenGL ES 相关的具体问题。
- en: Creating a simple project to debug an OpenGL ES application
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的项目以调试OpenGL ES应用程序
- en: Before we can proceed, we first need to create our `OpenGLESExample` project.
    To refresh your memory, you can refer to the section that we covered in [Chapter
    2](ch02.html "Chapter 2. Using iCloud and the Storage APIs"), under the section
    *Creating the iCloudExample application:*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们首先需要创建我们的`OpenGLESExample`项目。为了唤起您的记忆，您可以参考我们在[第2章](ch02.html "第2章。使用iCloud和存储API")中涵盖的部分，在*创建iCloudExample应用程序*部分：
- en: Launch Xcode from the `/Developer/Applications` folder.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/Developer/Applications`文件夹中启动Xcode。
- en: Select the **OpenGL Game** template from the **Project** template dialog box.![Creating
    a simple project to debug an OpenGL ES application](img/2267EXP_03_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**模板对话框中选择**OpenGL游戏**模板。![创建一个简单的项目以调试OpenGL ES应用程序](img/2267EXP_03_01.jpg)
- en: Then, click on the **Next** button to proceed to the next step in the wizard.
    This will allow you to enter in the **Product Name** and your **Company Identifier**.![Creating
    a simple project to debug an OpenGL ES application](img/2267EXP_03_02.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**下一步**按钮以继续向导的下一步。这将允许您输入**产品名称**和您的**公司标识符**。![创建一个简单的项目以调试OpenGL ES应用程序](img/2267EXP_03_02.jpg)
- en: Enter in `OpenGLESExample` for the **Product Name**, and ensure that you have
    selected **iPhone** from the **Device Family** dropdown box.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**产品名称**中输入`OpenGLESExample`，并确保您已从**设备家族**下拉框中选择了**iPhone**。
- en: Next, click on the **Next** button to proceed to the final step in the wizard.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**下一步**按钮以继续向导的最终步骤。
- en: 6 Choose the folder location where you would like to save your project.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6 选择您想要保存项目的文件夹位置。
- en: Then, click on the **Create** button to save your project at the location specified.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**创建**按钮以在指定位置保存您的项目。
- en: Once your project has been created, you will be presented with the Xcode development
    interface, along with the project files that the template created for you within
    the Project **Navigator** window.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了项目，您将看到Xcode开发界面，以及模板在项目**导航器**窗口中为您创建的项目文件。
- en: Now that we have our project created, we need to configure our project to enable
    us to debug the state of the objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目，我们需要配置项目以使我们能够调试对象的状态。
- en: Detecting OpenGL ES state information and objects
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测OpenGL ES状态信息和对象
- en: 'To enable us to detect and monitor the state of the objects within our application,
    we need to enable this feature through the **Edit Scheme…** section of our project,
    as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们能够检测和监控应用程序中对象的状态，我们需要通过项目中的**编辑方案…**部分启用此功能，如图下所示：
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_03.jpg)'
- en: From the **Edit Scheme** section, as shown in the following screenshot, select
    the **Run OpenGLESExampleDebug** action, then click on the **Options** tab, and
    then select the **OpenGL ES Enable** frame capture checkbox.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在**编辑方案**部分，如图下所示，选择**运行OpenGLESExampleDebug**操作，然后点击**选项**选项卡，然后选择**OpenGL
    ES启用**帧捕获复选框。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this feature to work, you must run the application on an iOS device, and
    the device must be running iOS 5.0 or later. This feature will not work within
    the iOS simulator. You will need to ensure that after you have attached your device,
    you will then need to restart Xcode for this option to become available.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此功能正常工作，您必须在iOS设备上运行应用程序，并且设备必须运行iOS 5.0或更高版本。此功能在iOS模拟器中不会工作。您需要确保在连接设备后，您需要重新启动Xcode以使此选项可用。
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_04.jpg)'
- en: When you have configured your project correctly, click on the **OK** button
    to accept the changes made, and close the dialog box. Next, build and run your
    OpenGL ES application. When you run your application, you will see two three-dimensional
    and colored box cubes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正确配置了项目后，点击**确定**按钮以接受所做的更改，并关闭对话框。接下来，构建并运行您的OpenGL ES应用程序。当您运行应用程序时，您将看到两个三维彩色立方体盒子。
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_05.jpg)'
- en: 'When you run your application on the iOS device, you will notice that the frame
    capture appears within the Xcode 4 debug bar, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在iOS设备上运行应用程序时，您会注意到帧捕获出现在Xcode 4调试栏中，如图下所示：
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_06.jpg)'
- en: 'When using the OpenGL ES features of Xcode 4.2, these debugging features enable
    you to do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Xcode 4.2的OpenGL ES功能时，这些调试功能使您能够执行以下操作：
- en: Inspect OpenGL ES state information.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查OpenGL ES状态信息。
- en: Introspect OpenGL ES objects such as view textures and shaders.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反思OpenGL ES对象，如视图纹理和着色器。
- en: Step through draw calls and watch changes with each call.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步进绘制调用并观察每次调用时的变化。
- en: Step through the state calls that proceed each draw call to see exactly how
    the image is constructed.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步进每个绘制调用之前的每个状态调用，以确切了解图像是如何构建的。
- en: The following screenshot displays the captured frame of our sample application.
    The debug navigator contains a list of every draw call and state call associated
    with that particular frame.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的示例应用程序捕获的帧。调试导航器包含与该特定帧相关联的每个绘制调用和状态调用的列表。
- en: 'The buffers that are associated with the frame are shown within the editor
    pane, and the state information is shown in the debug windowpane. The default
    view when the OpenGL ES frame capture is launched is displayed in the **Auto**
    view. This view displays the color portion, which is the `Renderbuffer #1`, as
    well as its grayscale equivalent of the image, that being `Renderbuffer #2`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '与帧关联的缓冲区在编辑器面板中显示，状态信息在调试窗口面板中显示。当启动OpenGL ES帧捕获时，默认视图显示在**自动**视图中。此视图显示颜色部分，即`Renderbuffer
    #1`，以及图像的灰度等效部分，即`Renderbuffer #2`。'
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_07.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_07.jpg)'
- en: You can also toggle the visibility between each of the channels for red, green
    and blue, as well as the alpha channels, and then use the **Range** scroll to
    adjust the color range. This can be done easily by selecting each of the cog buttons,
    shown in the previous screenshot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在红色、绿色和蓝色以及alpha通道的每个通道之间切换可见性，然后使用**范围**滚动条调整颜色范围。这可以通过选择前一个截图所示的每个齿轮按钮轻松完成。
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_08.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_08.jpg)'
- en: You also have the ability to step through each of the draw calls in the debug
    navigator, or by using the double arrows and slider in the debug bar.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过调试导航器中的每个绘制调用或使用调试栏中的双箭头和滑块来步进每个绘制调用。
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_09.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_09.jpg)'
- en: When using the draw call arrows or sliders, you can have Xcode select the stepped-to
    draw call from the debug navigator. This can be achieved by *Control* + clicking
    below the captured frame, and choosing the **Reveal in Debug Navigator** from
    the shortcut menu.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用绘制调用箭头或滑块时，您可以让Xcode从调试导航器中选择步进的绘制调用。这可以通过*Control* + 点击捕获的帧下方，并从快捷菜单中选择**在调试导航器中显示**来实现。
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_10.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_10.jpg)'
- en: You can also use the shortcut menu to toggle between the standard view of drawing
    the image, as well as showing the wireframe view of the object, by selecting the
    **Show Wireframe** option from the pop-up menu, as shown in the previous screenshot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用快捷菜单在绘制图像的标准视图和显示对象的线框视图之间切换，通过从弹出菜单中选择**显示线框**选项，如前一个截图所示。
- en: 'When using the wireframe view of an object, it highlights the element that
    is being drawn by the selected draw call. To turn off the wireframe feature and
    have the image return back to the normal state, select the **Hide Wireframe**
    option from the pop-up menu, as shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用对象的线框视图时，它突出显示由所选绘制调用绘制的元素。要关闭线框功能并将图像返回到正常状态，请从弹出菜单中选择**隐藏线框**选项，如以下截图所示：
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_11.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![检测OpenGL ES状态信息和对象](img/2267EXP_03_11.jpg)'
- en: Now that you have a reasonable understanding of debugging through an OpenGL
    ES application and its draw calls, let's take a look at how we can view the textures
    associated with an OpenGL ES application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对通过OpenGL ES应用程序及其绘制调用进行调试有了合理的理解，让我们看看我们如何查看与OpenGL ES应用程序关联的纹理。
- en: View textures
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看纹理
- en: 'When referring to textures in OpenGL ES 2.0, this is basically an image that
    can be sampled by the graphics engine pipeline, and is used to map a colored image
    onto a mapping surface. To view objects that have been captured by the frame capture
    button, follow these simple steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当在OpenGL ES中引用纹理时，这基本上是一个可以被图形引擎管道采样的图像，并用于将彩色图像映射到映射表面上。要查看通过帧捕获按钮捕获的对象，请按照以下简单步骤操作：
- en: Open the **Assistant Editor** to see the objects associated with the captured
    frame. In this view, you can choose to see all of the objects, only bound objects,
    or the stack. This can be accessed from the **View | Assistant Editor | Show Assistant
    Editor** menu, as shown in the following screenshot:![View textures](img/2267EXP_03_12.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**辅助编辑器**以查看与捕获帧关联的对象。在此视图中，你可以选择查看所有对象、仅绑定对象或堆栈。这可以通过以下截图所示的**视图 | 辅助编辑器
    | 显示辅助编辑器**菜单访问：![查看纹理](img/2267EXP_03_12.jpg)
- en: 'Open a secondary assistant editor pane, so that you can see both the objects
    and the stack frame at the same time. This can be accessed from the **View | Assistant
    Editor | Add Assistant Editor** menu shown previously, or by clicking on the **+**
    symbol, as shown in the following screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个辅助编辑器面板，这样你就可以同时看到对象和堆栈帧。这可以通过之前显示的**视图 | 辅助编辑器 | 添加辅助编辑器**菜单访问，或者通过点击以下截图所示的**+**符号：
- en: '![View textures](img/2267EXP_03_14.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![查看纹理](img/2267EXP_03_14.jpg)'
- en: 'To see details about any object contained within the OpenGL ES assistant editor,
    double-click on the object, or choose the item from the pop-up list, as shown
    in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看OpenGL ES辅助编辑器中任何对象的详细信息，请双击该对象，或从弹出列表中选择该项，如图下所示截图：
- en: 'It is worth mentioning that, from within this view, you have the ability to
    change the orientation of any object that has been captured and has been rendered
    to the view. To change the orientation, locate the **Orientation** options shown
    at the bottom-right hand of the screen. Objects can be changed to appear in one
    or more views as needed, and these are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，从该视图中，你可以更改已捕获并渲染到视图中的任何对象的朝向。要更改朝向，找到屏幕右下角显示的**方向**选项。根据需要，对象可以被更改以在一个或多个视图中显示，如下所示：
- en: Rotate clockwise
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺时针旋转
- en: Rotate counter-clockwise
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆时针旋转
- en: Flip orientation vertically
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直翻转方向
- en: Flip orientation horizontally
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平翻转方向
- en: '![View textures](img/2267EXP_03_13.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![查看纹理](img/2267EXP_03_13.jpg)'
- en: For example, if you want to see information about the **vertex array object**
    (VAO), you would double-click on it to see it in more detail, as shown in the
    following screenshot.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想查看关于**顶点数组对象**（VAO）的信息，你可以双击它以更详细地查看，如图下所示截图。
- en: '![View textures](img/2267EXP_03_15.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![查看纹理](img/2267EXP_03_15.jpg)'
- en: This displays all the `X, Y`, and `Z-axes` required to construct each of our
    objects. Next, we will take a look into how shaders are constructed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了构建我们每个对象所需的全部`X, Y`和`Z`轴。接下来，我们将探讨着色器的构建方式。
- en: Shaders
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器
- en: There are two types of shaders that you can write for OpenGL ES; these are **Vertex
    shaders** and **Fragment shaders**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为OpenGL ES编写两种类型的着色器；这些是**顶点着色器**和**片段着色器**。
- en: These two shaders make up what is known as the **Programmable** portion of the
    OpenGL ES 2.0 programmable pipeline, and are written in a C-like language syntax,
    called **The OpenGL ES Shading Language** (GLSL).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个着色器构成了OpenGL ES 2.0可编程管道中所谓的**可编程**部分，并且使用类似于C语言的语法编写，称为**OpenGL ES着色语言**（GLSL）。
- en: 'The following screenshot outlines the OpenGL ES 2.0 programmable pipeline,
    and combines a version of the OpenGL Shading Language for programming **Vertex
    Shader** and **Fragment Shader** that has been adapted for embedded platforms
    for iOS devices:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图概述了OpenGL ES 2.0可编程管道，并结合了一个适用于iOS设备的嵌入式平台的OpenGL着色语言版本，用于编程**顶点着色器**和**片段着色器**：
- en: '![Shaders](img/2267EXP_03_17.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![着色器](img/2267EXP_03_17.jpg)'
- en: 'Shaders are not new, these have been used in a variety of games that use OpenGL.
    Such games that come to mind are: Doom 3 and Quake 4, or several flight simulators,
    such as Microsoft''s Flight Simulator X.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器并不新鲜，这些已经在各种使用OpenGL的游戏中得到了应用。例如，Doom 3和Quake 4，或者几个飞行模拟器，如微软的Flight Simulator
    X。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Once thing to note about shaders, is that they are not compiled when your application
    is built. The source code of the shader gets stored within your application bundle
    as a text file, or defined within your code as a string literal, that is, `vertShaderPathname
    = [[NSBundlemainBundle] pathForResource:@"Shader" ofType:@"vsh"]`;
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于着色器有一点需要注意，那就是它们在应用程序构建时不会被编译。着色器的源代码以文本文件的形式存储在您的应用程序包中，或者作为字符串字面量定义在您的代码中，即`vertShaderPathname
    = [[NSBundlemainBundle] pathForResource:@"Shader" ofType:@"vsh"]`;
- en: Before you can use your shaders, your application has to load and compile each
    of them. This is done to preserve device independence.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用着色器之前，您的应用程序必须加载和编译每个着色器。这样做是为了保持设备独立性。
- en: Let's take for example, if Apple decided to change to a different GPU manufacturer,
    for future releases of its iPhone, the compiled shaders may not work on the new
    GPU. Having your application deferring the compilation to runtime will avoid this
    problem, and any latest versions of the GPU will be fully supported without a
    need for you to rebuild your application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以苹果决定为未来发布的iPhone更换不同的GPU制造商为例，如果苹果更换了GPU制造商，编译后的着色器可能在新GPU上无法工作。让您的应用程序在运行时延迟编译将避免这个问题，并且任何最新的GPU版本都将得到全面支持，而无需您重新构建应用程序。
- en: The following table explains the differences between the two shaders.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下表解释了两种着色器之间的区别。
- en: '| **Shader type** | Description |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **着色器类型** | 描述 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Vertex shaders | These are programs that get called once-per-vertex in your
    scene. An example to explain this better would be - if you were rendering a simple
    scene with a single square, with one vertex at each corner, this would be called
    four times.Their job is to perform some calculations such as lighting, geometry
    transforms, moving, scaling and rotating of objects, to simulate realism. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 顶点着色器 | 这些是在您的场景中每次调用一次的程序。为了更好地解释这一点，例如，如果您使用单个正方形渲染一个简单的场景，每个角落有一个顶点，这将被调用四次。它们的工作是执行一些计算，如光照、几何变换、移动、缩放和旋转对象，以模拟现实感。|'
- en: '| Fragment shaders | These are programs that get called once-per-pixel in your
    scene. So, if you''re rendering that same simple scene with a single square, it
    will be called once for each pixel that the square covers. Fragment shaders can
    also perform lighting calculations, and so on, but their most important job is
    to set the final color for the pixel. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 片段着色器 | 这些是在您的场景中每次调用一次的程序。例如，如果您使用单个正方形渲染相同的简单场景，它将为正方形覆盖的每个像素调用一次。片段着色器还可以执行光照计算等操作，但它们最重要的任务是设置像素的最终颜色。|'
- en: 'Next, we will start by examining the implementation of the vertex shader that
    the OpenGL template created for us. You will notice that these shaders are code
    files that have been implemented using C-Syntax like instructions. Lets, start
    by examining each section of the vertex shader file, by following these simple
    steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从检查OpenGL模板为我们创建的顶点着色器实现开始。您会注意到这些着色器是使用类似C语法的指令实现的代码文件。让我们首先通过以下简单步骤检查顶点着色器文件的每个部分：
- en: Open the `Shader.vsh` vertex shader file located within the `OpenGLESExample`
    folder of the **Project Navigator** window, and examine the following code snippet.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于**项目导航器**窗口中的`OpenGLESExample`文件夹内的`Shader.vsh`顶点着色器文件，并检查以下代码片段。
- en: '[PRE0]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will take a look at what this piece of code is doing and explain what
    is actually going on. So let's start.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看这段代码的功能，并解释实际上发生了什么。那么，让我们开始吧。
- en: The attribute keyword declares that this shader is going to be passed in an
    input variable called `position`. This will be used to indicate the position of
    the vertex. You will notice that the `position` variable has been declared of
    type `vec4`, which means that each vertex contains four floating-point values.
    The second attribute input variable that is declared with the variable name `normal`,
    has been declared of type `vec3`, which means that the vertex contains three floating-point
    values that are used for the rotational aspect around the `x`, `y`, and `z` axes.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`attribute`关键字声明这个着色器将通过一个名为`position`的输入变量传递。这将用于指示顶点的位置。您会注意到`position`变量已被声明为`vec4`类型，这意味着每个顶点包含四个浮点值。第二个声明为`normal`的属性输入变量已被声明为`vec3`类型，这意味着顶点包含三个用于围绕`x`、`y`和`z`轴旋转的浮点值。'
- en: The third attribute input variable that is declared with the variable name diffuseColor,
    defines the color to be used for the vertex. We declare another variable called
    colorVarying. You will notice that it doesn't contain the attribute keyword. This
    is because it is an output variable that will be passed to the fragment shader.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用变量名 `diffuseColor` 声明的第三个属性输入变量，定义了用于顶点的颜色。我们声明了另一个名为 `colorVarying` 的变量。你会注意到它不包含属性关键字。这是因为它是一个输出变量，将被传递到片段着色器。
- en: The varying keyword tells us the value for a particular vertex. This basically
    means that you can specify a different color for each vertex, and it will make
    all the values in-between a neat gradient that you will see in the final output.
    We have declared this as vec4, because colors are comprised of four component
    values.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`varying` 关键字告诉我们特定顶点的值。这基本上意味着你可以为每个顶点指定不同的颜色，这将使所有中间值形成一个整洁的渐变，你将在最终输出中看到。我们将其声明为
    vec4，因为颜色由四个分量值组成。'
- en: Finally, we declare two uniform keyword variables called `modelViewProjectionMatrix
    and normalMatrix`. The model, view, and projection matrices are three separate
    matrices. Model maps from an object's local coordinate space into world space,
    view from world space to camera space, and projection from camera to screen.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们声明了两个名为 `modelViewProjectionMatrix` 和 `normalMatrix` 的统一关键字变量。模型矩阵、视图矩阵和投影矩阵是三个独立的矩阵。模型矩阵将对象的局部坐标空间映射到世界空间，视图矩阵将世界空间映射到相机空间，投影矩阵将相机空间映射到屏幕空间。
- en: When all three are used, you can then use the one result to map all the way
    from object space to screen space, enabling you to work out what you need to pass
    on to the next stage of a programmable pipeline from the incoming vertex positions.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用所有三个时，你可以使用其中一个结果将对象空间映射到屏幕空间，从而让你能够确定需要传递给可编程管道下一阶段的顶点位置信息。
- en: The normal matrix vectors are used to determine how much light is received at
    the specified vertex or surface. Uniforms are a second form of data that allow
    you to pass from your application code to the shaders. Uniform types are available
    to both vertex and fragment shaders, which, unlike attributes, are only available
    to the vertex shader.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正常矩阵向量用于确定指定顶点或表面接收到的光量。统一变量是允许你从应用程序代码传递到着色器的第二种数据形式。统一类型对顶点和片段着色器都可用，与属性不同，属性只对顶点着色器可用。
- en: Note
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The value of a uniform cannot be changed by the shaders, and will have the same
    value every time a shader runs for a given trip through the pipeline. Uniforms
    can also contain any kind of data that you want to pass along for use in your
    shader.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 统一变量的值不能被着色器更改，并且每次着色器在管道中给定行程时都将具有相同的值。统一变量还可以包含任何你想要传递到着色器中以供使用的任意类型的数据。
- en: Next, we assign the value from the color per-vertex attribute to the varying
    variable `colorVarying`. This value will then be available in the fragment shader
    in interpolated form.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从每个顶点的颜色属性值将值赋给 `colorVarying` 变量。这个值将在片段着色器中以插值形式可用。
- en: Finally, we modify the `gl_Position` output variable, using the floating point
    translate variable to move the vertex along the `X, Y`, and `Z-axes`, based on
    the value of the translate uniform.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们修改了 `gl_Position` 输出变量，使用浮点平移变量沿着 `X, Y` 和 `Z` 轴移动顶点，基于平移统一变量的值。
- en: Next, we will take a look at the fragment shader that the OpenGL ES template
    created for us.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将查看OpenGL ES模板为我们创建的片段着色器。
- en: Open the `Shader.fsh` fragment shader file located within the **OpenGLESExample**
    folder of the **Project Navigator** window, and examine the following code snippet.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 **Project Navigator** 窗口 **OpenGLESExample** 文件夹中的 `Shader.fsh` 片段着色器文件，并检查以下代码片段。
- en: '[PRE1]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will now take a look at this code snippet, and explain what is actually going
    on here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看这段代码，并解释这里实际上发生了什么。
- en: You will notice that within the fragment shader, the declaration of the varying
    type variable `colorVarying`, as highlighted in the code, has the same name as
    it did in the vertex shader. This is very important; if these names were different,
    OpenGL ES won't realize it's the same variable, and your program will produce
    unexpected results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在片段着色器中，突出显示的 `colorVarying` 变量的声明与顶点着色器中的名称相同。这非常重要；如果这些名称不同，OpenGL ES
    将不会意识到它们是相同的变量，你的程序将产生意外的结果。
- en: The type is also very important, and it has to be the same data type as it was
    declared within the vertex shader. This is a GLSL keyword that is used to specify
    the precision of the number of bytes used to represent a number.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类型也非常重要，它必须与在顶点着色器中声明的数据类型相同。这是一个GLSL关键字，用于指定表示数字的字节数的精度。
- en: From a programming point of view, the more bytes that are used to represent
    a number, the fewer problems you will be likely to have with the rounding of floating
    point calculations. GLSL allows the user to precision modifiers any time a variable
    is declared, and it must be declared within this file. Failure to declare it within
    the fragment shader, will result in your shader failing to compile.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度来看，用于表示数字的字节数越多，你可能会遇到的浮点计算舍入问题就越少。GLSL允许用户在任何声明变量时使用精度修饰符，并且必须在文件中声明。如果在片段着色器中未声明它，将导致你的着色器无法编译。
- en: The `lowp` keyword is going to give you the best performance with the least
    accuracy during interpolation. This is the better option when dealing with colors,
    where small rounding errors don't matter. Should you find the need to increase
    the precision, it is better to use the `mediump` or `highp`, if the lack of precision
    causes you problems within your application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`lowp`关键字在插值过程中会提供最佳性能和最低精度。当处理颜色时，这是更好的选择，因为小的舍入误差并不重要。如果你需要提高精度，最好使用`mediump`或`highp`，如果精度不足导致你在应用程序中遇到问题。'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the **OpenGL ES Shading Language** (GLSL) or the **Precision
    modifiers**, refer to the following documentation located at: [http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf](http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于**OpenGL ES着色语言**（GLSL）或**精度修饰符**的信息，请参阅以下位于：[http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf](http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf)的文档。
- en: Error handling in OpenGL ES
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES的错误处理
- en: OpenGL provides simple error-handling routines for the base GL and GLU libraries.
    You can use the function `glGetError` to check for errors. OpenGL only records
    the first error to occur. All subsequent errors are ignored, until the error buffer
    is cleared by a call to `glGetError`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL为基本GL和GLU库提供简单的错误处理例程。你可以使用`glGetError`函数来检查错误。OpenGL只记录第一个发生的错误。所有后续的错误都会被忽略，直到通过调用`glGetError`清除错误缓冲区。
- en: 'The command that caused the error is ignored, so it has no effect on OpenGL
    state or on the frame buffer contents. Once recorded, the current error code isn''t
    cleared and additional errors aren''t recorded until you call the query command
    `glGetError()`, which returns the current error code. After you''ve queried and
    cleared the current error code, or if there''s no error to begin with, `glGetError()`
    returns `GL_NO_ERROR`. The syntax of the `glGetError` function is defined as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 导致错误的命令被忽略，因此它对OpenGL状态或帧缓冲区内容没有影响。一旦记录，当前错误代码不会清除，并且不会记录额外的错误，直到你调用查询命令`glGetError()`，该命令返回当前错误代码。在你查询并清除当前错误代码之后，或者如果一开始就没有错误，`glGetError()`返回`GL_NO_ERROR`。`glGetError`函数的语法定义如下：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `glGetError` function returns the value of the error flag. When an error
    has been detected in either the GL or GLU libraries, the error flag is set to
    the appropriate error code value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`glGetError`函数返回错误标志的值。当在GL或GLU库中检测到错误时，错误标志设置为适当的错误代码值。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If `GL_NO_ERROR` is returned, there has been no detectable error since the last
    call to `glGetError()`, or since the GL was initialized.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回`GL_NO_ERROR`，则自上次调用`glGetError()`以来或自GL初始化以来没有检测到错误。
- en: If no other errors are recorded until the `glGetError()` method is called, the
    error code is returned, and the flag is reset to `GL_NO_ERROR`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用`glGetError()`方法之前没有记录其他错误，将返回错误代码，并将标志重置为`GL_NO_ERROR`。
- en: The following table lists the basic defined OpenGL error codes and their descriptions
    that are returned by the `glGetError` method call.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了由`glGetError`方法调用返回的基本定义的OpenGL错误代码及其描述：
- en: '| **Error code** | **Description** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **错误代码** | **描述** |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GL_INVALID_ENUM` | `GLenum` argument out of range |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `GL_INVALID_ENUM` | `GLenum`参数超出范围 |'
- en: '| `GL_INVALID_VALUE` | Numeric argument out of range |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `GL_INVALID_VALUE` | 数字参数超出范围 |'
- en: '| `GL_INVALID_OPERATION` | Operation illegal in current state |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `GL_INVALID_OPERATION` | 当前状态下非法操作 |'
- en: '| `GL_STACK_OVERFLOW` | Command would cause a stack overflow |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `GL_STACK_OVERFLOW` | 命令会导致栈溢出 |'
- en: '| `GL_STACK_UNDERFLOW` | Command would cause a stack underflow |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `GL_STACK_UNDERFLOW` | 命令会导致栈下溢 |'
- en: '| `GL_OUT_OF_MEMORY` | Not enough memory left to execute command |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `GL_OUT_OF_MEMORY` | 执行命令时内存不足 |'
- en: '| `GL_NO_ERROR` | No error has occurred. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `GL_NO_ERROR` | 没有发生错误。 |'
- en: Detecting errors by setting up breakpoints
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过设置断点来检测错误
- en: Setting breakpoints within your code gives you the flexibility to stop execution
    at any point within your code, so that you can investigate and step through to
    find out why a piece of code is not working correctly. This is particularly handy
    if you want to step through specific OpenGL functions. These breakpoints should
    be set immediately before calling the function, and your program will be stopped
    and the status bar will indicate which function caused the breakpoint.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中设置断点为你提供了在任何点停止执行的能力，这样你可以调查并逐步执行以找出为什么某段代码不能正确工作。如果你想要逐步执行特定的 OpenGL
    函数，这尤其有用。这些断点应该在调用函数之前立即设置，并且你的程序将被停止，状态栏将指示哪个函数导致了断点。
- en: Setting up breakpoints in your code
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的代码中设置断点
- en: Although you can use the debugger to pause execution of your program at any
    time and view the state of the running code, it's usually helpful to set breakpoints
    before running your executable so that you can stop at known points, and view
    the values of variables in your source code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用调试器在任何时候暂停程序的执行并查看运行代码的状态，但在运行可执行文件之前设置断点通常更有帮助，这样你可以在已知点停止，并查看源代码中变量的值。
- en: A breakpoint is basically an instruction in your code that tells the application
    to *stop* when the breakpoint is reached, and execution of the program pauses,
    waiting for further instructions as to what to do next. During this phase, you
    have the opportunity to either inspect the current values of any of the properties,
    or step through the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 断点基本上是代码中的一条指令，告诉应用程序在达到断点时停止，程序执行暂停，等待进一步的指令以确定下一步操作。在这个阶段，你有机会检查任何属性当前值，或者逐步执行代码。
- en: Let's take a look at the following routine that uses the `glGetError` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下使用 `glGetError` 方法的例程。
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that we have declared a variable `err`, which will be used to
    store the error number that will be returned by the `glGetError` method. We then
    cycle through and output each error message's details to the debug console window
    until no more errors exist, upon which, we exit from the loop. Although you can
    use the Xcode 4 debugger to pause execution of your program at any time to view
    the state of your running code, it is more helpful to set breakpoints at those
    areas prior to running your application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们已声明了一个变量 `err`，它将用于存储 `glGetError` 方法将返回的错误号。然后我们遍历并输出每个错误消息的详细信息到调试控制台窗口，直到没有更多错误为止，然后退出循环。虽然你可以使用
    Xcode 4 调试器在任何时候暂停程序的执行以查看运行代码的状态，但在运行应用程序之前在那些区域设置断点更有帮助。
- en: To set breakpoints, open any source implementation file, and click within the
    gutter pane section of the Xcode source editor, next to the spot to where you
    would like your program to stop. When you add a breakpoint, Xcode will automatically
    enable it and this will be indicated by a light blue color as shown in the screenshot
    below. Breakpoints can also be toggled to be switched off, by clicking on the
    breakpoint again, having this turn to more of a transparent color.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置断点，请打开任何源实现文件，并在 Xcode 源编辑器的行号区域（gutter pane section）中点击，点击位置是你希望程序停止的地方。当你添加断点时，Xcode
    会自动启用它，并在下面的屏幕截图中以浅蓝色显示。通过再次点击断点，也可以切换断点以关闭，此时颜色会变得更加透明。
- en: The **Breakpoint Navigator** window shows all current breakpoints that have
    been set within your project, and will display all active as well as inactive
    breakpoints.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**断点导航器**窗口显示项目中设置的所有当前断点，并将显示所有活动和非活动断点。'
- en: '![Setting up breakpoints in your code](img/2267EXP_03_18.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![在你的代码中设置断点](img/2267EXP_03_18.jpg)'
- en: This view contains several options that can be configured for each breakpoint,
    and a breakpoint can contain multiple conditions. You can choose to log messages
    out to the Xcode console window, or execute a `debug` command. To access this
    view, hold down the *control* key, and right-click with the mouse.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图包含可以针对每个断点配置的几个选项，一个断点可以包含多个条件。您可以选择将消息记录到Xcode控制台窗口，或执行一个`debug`命令。要访问此视图，请按住*控制*键，并用鼠标右键单击。
- en: A new feature that comes with Xcode 4.2, is the ability to capture OpenGL frames,
    so that you can debug your code right within the Xcode development environment,
    and scroll through each of your OpenGL ES method calls, as well as viewing state
    and objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 4.2带来的一个新功能是能够捕获OpenGL帧，这样您就可以在Xcode开发环境中直接调试代码，滚动查看每个OpenGL ES方法调用，以及查看状态和对象。
- en: Setting conditional OpenGL ES entry point breakpoints
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置条件OpenGL ES入口点断点
- en: 'We have looked at setting breakpoints within your code in the event that you
    want your application to stop whenever that particular line is hit. Another way
    in which you can use breakpoints, is to have them stop when a particular condition
    has been met, and then have it perform a particular action, as shown in following
    example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在您希望应用程序在特定行被击中时停止的情况下设置代码中的断点。另一种使用断点的方法是，当满足特定条件时停止，然后执行特定的操作，如下面的示例所示：
- en: '![Setting conditional OpenGL ES entry point breakpoints](img/2267EXP_03_19.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![设置条件OpenGL ES入口点断点](img/2267EXP_03_19.jpg)'
- en: You have the ability to either have it stop when the condition has been met,
    as seen in this screenshot, or you can choose to ignore the condition altogether
    and have it fire after a specified number of times the method gets called.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择在条件满足时停止，如图所示，或者您可以选择完全忽略条件，并在方法被调用指定次数后执行。
- en: You can then choose to have it fire of a particular action. As you can see from
    this screenshot, we set up a condition to capture the current frame when the variable
    `transY` is greater than or equal to `2`. This will then launch the **OpenGL Frame
    Capture** section, so that we can step through and debug our code further, to
    see what is going on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以选择执行特定的操作。如从下面的屏幕截图中可以看到，我们设置了一个条件，当变量`transY`大于或等于`2`时捕获当前帧。这将启动**OpenGL帧捕获**部分，以便我们可以逐步调试代码，查看发生了什么。
- en: There are other ways in which we can debug OpenGL ES projects through the use
    of **Instruments**, which we will be covering in [Chapter 6](ch06.html "Chapter 6. Xcode
    Tools - Improvements"),*Xcode Tools Improvements*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用**Instruments**来调试OpenGL ES项目，这些内容将在[第6章](ch06.html "第6章. Xcode工具 -
    改进")*Xcode工具改进*中介绍。
- en: Breaking on frame boundaries
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在帧边界上断点
- en: 'The **OpenGL ES Debugger** allows you to see all of the frames that are being
    drawn within your application. You can have your application break at a certain
    point within your program, and then use the debug navigator to navigate to the
    area within your code to where the frame has been drawn. In the following screenshot,
    it displays the instance of the captured frame, and displays the state calls associated
    within that frame:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL ES调试器**允许您查看应用程序中正在绘制的所有帧。您可以让应用程序在程序中的某个特定点中断，然后使用调试导航器导航到代码中帧被绘制的地方。在下面的屏幕截图中，它显示了捕获的帧实例，并显示了与该帧相关联的状态调用：'
- en: '![Breaking on frame boundaries](img/2267EXP_03_20.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![在帧边界上断点](img/2267EXP_03_20.jpg)'
- en: Selecting the `glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)` option, as shown in the
    previous screenshot, will allow you to see a list of all of the associated draw
    calls that have been made. You can also cycle through the frames that have been
    captured by using the scrub bar, as highlighted in the previous screenshot.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 选择如图所示的`glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)`选项，将允许您看到所有相关绘制调用的列表。您还可以使用滚动条循环查看之前屏幕截图中捕获的帧。
- en: '![Breaking on frame boundaries](img/2267EXP_03_21.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![在帧边界上断点](img/2267EXP_03_21.jpg)'
- en: 'Clicking on the **[OpenGLESExampleViewController drawframe]** method , as shown
    in the previous screenshot, will open the Xcode development IDE and take you directly
    to the area to where your code is located, as shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 点击如图所示的**[OpenGLESExampleViewController drawframe]**方法，将打开Xcode开发IDE，并直接带您到代码所在的位置，如下面的屏幕截图所示：
- en: '![Breaking on frame boundaries](img/2267EXP_03_16.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![在帧边界处中断](img/2267EXP_03_16.jpg)'
- en: By using the OpenGL ES debugger, you can step through each of your frames within
    your application, to help you track-down and debug when textures are not rendering
    properly, or if the colors on your object look odd.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用OpenGL ES调试器，你可以逐帧遍历你的应用程序，帮助你追踪和调试纹理渲染不正确的情况，或者如果对象的颜色看起来很奇怪。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the differences between vertex shaders and
    fragment shaders, and their relation to one another. We then looked at the new
    debugging features of OpenGL ES, and how this new debugger in Xcode allows you
    to track down issues specific to OpenGL ES within your code, right within the
    Xcode IDE.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了顶点着色器和片段着色器之间的区别，以及它们之间的关系。然后我们探讨了OpenGL ES的新调试功能，以及这个新的Xcode调试器如何允许你在Xcode
    IDE中追踪代码中特定的OpenGL ES问题。
- en: We familiarized ourselves with the OpenGL ES frame capture tool, its ability
    to stop execution of a program, and grab the current frame contents that are being
    rendered on the iOS device. This is so that we are able to easily track-down and
    correct program issues, by taking a closer look at the program state information
    of objects, by scrolling through the debug navigator stack trace, as well as the
    ability to see all of the textures and shaders currently being used by the application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉了OpenGL ES帧捕获工具，它能够停止程序的执行，并抓取iOS设备上正在渲染的当前帧内容。这样我们就能轻松追踪并纠正程序问题，通过仔细查看对象的状态信息，通过滚动调试导航器堆栈跟踪，以及查看应用程序当前正在使用的所有纹理和着色器。
- en: We also learned about the OpenGL ES `glGetError` method call, and how we can
    use this to provide us with a list of errors that have been detected. To end the
    chapter, we looked at how we can break on frame boundaries within OpenGL and see
    the values of the current program frame state, as defined by the objects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了OpenGL ES的`glGetError`方法调用，以及我们如何使用它来提供已检测到的错误列表。为了结束本章，我们探讨了如何在OpenGL中在帧边界处中断，并查看由对象定义的当前程序帧状态。
- en: In the next chapter, we will gain an understanding of what **Storyboards** are,
    and how we can apply the various transitions between views, as well as how to
    create and configure scenes and storyboard files, to present these programmatically.
    We will also look at how to build and integrate Twitter capabilities into our
    application, to tweet photos and standard messages.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解什么是**故事板**，以及我们如何应用视图之间的各种过渡，以及如何创建和配置场景和故事板文件，以程序化地展示它们。我们还将探讨如何构建和集成Twitter功能到我们的应用程序中，以发送照片和标准消息。
