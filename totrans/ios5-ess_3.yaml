- en: Chapter 3. Debugging with OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Open Graphics Library** (**OpenGL**) can be simply defined as a *software
    interface to the graphics hardware*. It is a 3D graphics and modeling library
    that is highly portable and extremely fast. Using the OpenGL graphics API, you
    can create some brilliant graphics that are capable of representing 2D and 3D
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL library is a multi-purpose, open-source graphics library that supports
    applications for 2D and 3D digital content creation, mechanical and architectural
    design, virtual prototyping, flight simulation, and video games, and allows application
    developers to configure a 3D graphics pipeline, and submit data to it.
  prefs: []
  type: TYPE_NORMAL
- en: An object is defined by connected vertices. The vertices of the object are then
    transformed, lit, and assembled into primitives, and rasterized to create a 2D
    image that can be directly sent to the underlying graphics hardware to render
    the drawing, which is deemed to be typically very fast, due to the hardware being
    dedicated to processing graphics commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenGL for Embedded Systems** (**OpenGL ES**) is a simplified version of
    the popular OpenGL framework that has been developed to be much easier to learn
    and implement, eliminating the need for redundant functionality within the iOS
    graphics hardware. This framework has been optimized to take full advantage of
    hardware-accelerated mathematical operations, so that developers can get the best
    performance.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be focusing on the new debugging features that come
    with the OpenGL ES debugger that enables developers to track down issues specific
    to OpenGL ES in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the new workflow feature within Xcode 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple project to debug an OpenGL ES application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarize ourselves with the OpenGL ES 2.0 programmable pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile and link shaders into an OpenGL ES program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass data from an application to shaders, using uniforms and attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect OpenGL ES State information (view textures and shaders)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set and use breakpoints to catch OpenGL ES errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set conditional OpenGL ES entry point breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break on frame boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have some fantastic stuff to cover in this chapter, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the new workflow feature within Xcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be taking a look at the improvements that have been
    made to the Xcode 4 development environment, and how this can enable us to debug
    OpenGL ES applications much easier, compared to the previous versions of Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at how we can use the frame capture feature of the debugger to
    capture all frame objects that are included within an OpenGL ES application. This
    tool enables you to list all the frame objects that are currently used by your
    application at a given point of time.
  prefs: []
  type: TYPE_NORMAL
- en: We will familiarize ourselves with the new OpenGL ES debugger within Xcode,
    to enable us to track down specific issues relating to OpenGL ES within the code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple project to debug an OpenGL ES application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can proceed, we first need to create our `OpenGLESExample` project.
    To refresh your memory, you can refer to the section that we covered in [Chapter
    2](ch02.html "Chapter 2. Using iCloud and the Storage APIs"), under the section
    *Creating the iCloudExample application:*
  prefs: []
  type: TYPE_NORMAL
- en: Launch Xcode from the `/Developer/Applications` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **OpenGL Game** template from the **Project** template dialog box.![Creating
    a simple project to debug an OpenGL ES application](img/2267EXP_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the **Next** button to proceed to the next step in the wizard.
    This will allow you to enter in the **Product Name** and your **Company Identifier**.![Creating
    a simple project to debug an OpenGL ES application](img/2267EXP_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in `OpenGLESExample` for the **Product Name**, and ensure that you have
    selected **iPhone** from the **Device Family** dropdown box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Next** button to proceed to the final step in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6 Choose the folder location where you would like to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the **Create** button to save your project at the location specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your project has been created, you will be presented with the Xcode development
    interface, along with the project files that the template created for you within
    the Project **Navigator** window.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our project created, we need to configure our project to enable
    us to debug the state of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting OpenGL ES state information and objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable us to detect and monitor the state of the objects within our application,
    we need to enable this feature through the **Edit Scheme…** section of our project,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the **Edit Scheme** section, as shown in the following screenshot, select
    the **Run OpenGLESExampleDebug** action, then click on the **Options** tab, and
    then select the **OpenGL ES Enable** frame capture checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this feature to work, you must run the application on an iOS device, and
    the device must be running iOS 5.0 or later. This feature will not work within
    the iOS simulator. You will need to ensure that after you have attached your device,
    you will then need to restart Xcode for this option to become available.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you have configured your project correctly, click on the **OK** button
    to accept the changes made, and close the dialog box. Next, build and run your
    OpenGL ES application. When you run your application, you will see two three-dimensional
    and colored box cubes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run your application on the iOS device, you will notice that the frame
    capture appears within the Xcode 4 debug bar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When using the OpenGL ES features of Xcode 4.2, these debugging features enable
    you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspect OpenGL ES state information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introspect OpenGL ES objects such as view textures and shaders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step through draw calls and watch changes with each call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step through the state calls that proceed each draw call to see exactly how
    the image is constructed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot displays the captured frame of our sample application.
    The debug navigator contains a list of every draw call and state call associated
    with that particular frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The buffers that are associated with the frame are shown within the editor
    pane, and the state information is shown in the debug windowpane. The default
    view when the OpenGL ES frame capture is launched is displayed in the **Auto**
    view. This view displays the color portion, which is the `Renderbuffer #1`, as
    well as its grayscale equivalent of the image, that being `Renderbuffer #2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also toggle the visibility between each of the channels for red, green
    and blue, as well as the alpha channels, and then use the **Range** scroll to
    adjust the color range. This can be done easily by selecting each of the cog buttons,
    shown in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You also have the ability to step through each of the draw calls in the debug
    navigator, or by using the double arrows and slider in the debug bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When using the draw call arrows or sliders, you can have Xcode select the stepped-to
    draw call from the debug navigator. This can be achieved by *Control* + clicking
    below the captured frame, and choosing the **Reveal in Debug Navigator** from
    the shortcut menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also use the shortcut menu to toggle between the standard view of drawing
    the image, as well as showing the wireframe view of the object, by selecting the
    **Show Wireframe** option from the pop-up menu, as shown in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the wireframe view of an object, it highlights the element that
    is being drawn by the selected draw call. To turn off the wireframe feature and
    have the image return back to the normal state, select the **Hide Wireframe**
    option from the pop-up menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting OpenGL ES state information and objects](img/2267EXP_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have a reasonable understanding of debugging through an OpenGL
    ES application and its draw calls, let's take a look at how we can view the textures
    associated with an OpenGL ES application.
  prefs: []
  type: TYPE_NORMAL
- en: View textures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When referring to textures in OpenGL ES 2.0, this is basically an image that
    can be sampled by the graphics engine pipeline, and is used to map a colored image
    onto a mapping surface. To view objects that have been captured by the frame capture
    button, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Assistant Editor** to see the objects associated with the captured
    frame. In this view, you can choose to see all of the objects, only bound objects,
    or the stack. This can be accessed from the **View | Assistant Editor | Show Assistant
    Editor** menu, as shown in the following screenshot:![View textures](img/2267EXP_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a secondary assistant editor pane, so that you can see both the objects
    and the stack frame at the same time. This can be accessed from the **View | Assistant
    Editor | Add Assistant Editor** menu shown previously, or by clicking on the **+**
    symbol, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![View textures](img/2267EXP_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see details about any object contained within the OpenGL ES assistant editor,
    double-click on the object, or choose the item from the pop-up list, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that, from within this view, you have the ability to
    change the orientation of any object that has been captured and has been rendered
    to the view. To change the orientation, locate the **Orientation** options shown
    at the bottom-right hand of the screen. Objects can be changed to appear in one
    or more views as needed, and these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotate clockwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate counter-clockwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flip orientation vertically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flip orientation horizontally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![View textures](img/2267EXP_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, if you want to see information about the **vertex array object**
    (VAO), you would double-click on it to see it in more detail, as shown in the
    following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![View textures](img/2267EXP_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This displays all the `X, Y`, and `Z-axes` required to construct each of our
    objects. Next, we will take a look into how shaders are constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two types of shaders that you can write for OpenGL ES; these are **Vertex
    shaders** and **Fragment shaders**.
  prefs: []
  type: TYPE_NORMAL
- en: These two shaders make up what is known as the **Programmable** portion of the
    OpenGL ES 2.0 programmable pipeline, and are written in a C-like language syntax,
    called **The OpenGL ES Shading Language** (GLSL).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot outlines the OpenGL ES 2.0 programmable pipeline,
    and combines a version of the OpenGL Shading Language for programming **Vertex
    Shader** and **Fragment Shader** that has been adapted for embedded platforms
    for iOS devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shaders](img/2267EXP_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Shaders are not new, these have been used in a variety of games that use OpenGL.
    Such games that come to mind are: Doom 3 and Quake 4, or several flight simulators,
    such as Microsoft''s Flight Simulator X.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once thing to note about shaders, is that they are not compiled when your application
    is built. The source code of the shader gets stored within your application bundle
    as a text file, or defined within your code as a string literal, that is, `vertShaderPathname
    = [[NSBundlemainBundle] pathForResource:@"Shader" ofType:@"vsh"]`;
  prefs: []
  type: TYPE_NORMAL
- en: Before you can use your shaders, your application has to load and compile each
    of them. This is done to preserve device independence.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take for example, if Apple decided to change to a different GPU manufacturer,
    for future releases of its iPhone, the compiled shaders may not work on the new
    GPU. Having your application deferring the compilation to runtime will avoid this
    problem, and any latest versions of the GPU will be fully supported without a
    need for you to rebuild your application.
  prefs: []
  type: TYPE_NORMAL
- en: The following table explains the differences between the two shaders.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shader type** | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Vertex shaders | These are programs that get called once-per-vertex in your
    scene. An example to explain this better would be - if you were rendering a simple
    scene with a single square, with one vertex at each corner, this would be called
    four times.Their job is to perform some calculations such as lighting, geometry
    transforms, moving, scaling and rotating of objects, to simulate realism. |'
  prefs: []
  type: TYPE_TB
- en: '| Fragment shaders | These are programs that get called once-per-pixel in your
    scene. So, if you''re rendering that same simple scene with a single square, it
    will be called once for each pixel that the square covers. Fragment shaders can
    also perform lighting calculations, and so on, but their most important job is
    to set the final color for the pixel. |'
  prefs: []
  type: TYPE_TB
- en: 'Next, we will start by examining the implementation of the vertex shader that
    the OpenGL template created for us. You will notice that these shaders are code
    files that have been implemented using C-Syntax like instructions. Lets, start
    by examining each section of the vertex shader file, by following these simple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Shader.vsh` vertex shader file located within the `OpenGLESExample`
    folder of the **Project Navigator** window, and examine the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will take a look at what this piece of code is doing and explain what
    is actually going on. So let's start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attribute keyword declares that this shader is going to be passed in an
    input variable called `position`. This will be used to indicate the position of
    the vertex. You will notice that the `position` variable has been declared of
    type `vec4`, which means that each vertex contains four floating-point values.
    The second attribute input variable that is declared with the variable name `normal`,
    has been declared of type `vec3`, which means that the vertex contains three floating-point
    values that are used for the rotational aspect around the `x`, `y`, and `z` axes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The third attribute input variable that is declared with the variable name diffuseColor,
    defines the color to be used for the vertex. We declare another variable called
    colorVarying. You will notice that it doesn't contain the attribute keyword. This
    is because it is an output variable that will be passed to the fragment shader.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The varying keyword tells us the value for a particular vertex. This basically
    means that you can specify a different color for each vertex, and it will make
    all the values in-between a neat gradient that you will see in the final output.
    We have declared this as vec4, because colors are comprised of four component
    values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we declare two uniform keyword variables called `modelViewProjectionMatrix
    and normalMatrix`. The model, view, and projection matrices are three separate
    matrices. Model maps from an object's local coordinate space into world space,
    view from world space to camera space, and projection from camera to screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all three are used, you can then use the one result to map all the way
    from object space to screen space, enabling you to work out what you need to pass
    on to the next stage of a programmable pipeline from the incoming vertex positions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The normal matrix vectors are used to determine how much light is received at
    the specified vertex or surface. Uniforms are a second form of data that allow
    you to pass from your application code to the shaders. Uniform types are available
    to both vertex and fragment shaders, which, unlike attributes, are only available
    to the vertex shader.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The value of a uniform cannot be changed by the shaders, and will have the same
    value every time a shader runs for a given trip through the pipeline. Uniforms
    can also contain any kind of data that you want to pass along for use in your
    shader.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we assign the value from the color per-vertex attribute to the varying
    variable `colorVarying`. This value will then be available in the fragment shader
    in interpolated form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we modify the `gl_Position` output variable, using the floating point
    translate variable to move the vertex along the `X, Y`, and `Z-axes`, based on
    the value of the translate uniform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will take a look at the fragment shader that the OpenGL ES template
    created for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `Shader.fsh` fragment shader file located within the **OpenGLESExample**
    folder of the **Project Navigator** window, and examine the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now take a look at this code snippet, and explain what is actually going
    on here.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that within the fragment shader, the declaration of the varying
    type variable `colorVarying`, as highlighted in the code, has the same name as
    it did in the vertex shader. This is very important; if these names were different,
    OpenGL ES won't realize it's the same variable, and your program will produce
    unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: The type is also very important, and it has to be the same data type as it was
    declared within the vertex shader. This is a GLSL keyword that is used to specify
    the precision of the number of bytes used to represent a number.
  prefs: []
  type: TYPE_NORMAL
- en: From a programming point of view, the more bytes that are used to represent
    a number, the fewer problems you will be likely to have with the rounding of floating
    point calculations. GLSL allows the user to precision modifiers any time a variable
    is declared, and it must be declared within this file. Failure to declare it within
    the fragment shader, will result in your shader failing to compile.
  prefs: []
  type: TYPE_NORMAL
- en: The `lowp` keyword is going to give you the best performance with the least
    accuracy during interpolation. This is the better option when dealing with colors,
    where small rounding errors don't matter. Should you find the need to increase
    the precision, it is better to use the `mediump` or `highp`, if the lack of precision
    causes you problems within your application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the **OpenGL ES Shading Language** (GLSL) or the **Precision
    modifiers**, refer to the following documentation located at: [http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf](http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL provides simple error-handling routines for the base GL and GLU libraries.
    You can use the function `glGetError` to check for errors. OpenGL only records
    the first error to occur. All subsequent errors are ignored, until the error buffer
    is cleared by a call to `glGetError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command that caused the error is ignored, so it has no effect on OpenGL
    state or on the frame buffer contents. Once recorded, the current error code isn''t
    cleared and additional errors aren''t recorded until you call the query command
    `glGetError()`, which returns the current error code. After you''ve queried and
    cleared the current error code, or if there''s no error to begin with, `glGetError()`
    returns `GL_NO_ERROR`. The syntax of the `glGetError` function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `glGetError` function returns the value of the error flag. When an error
    has been detected in either the GL or GLU libraries, the error flag is set to
    the appropriate error code value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `GL_NO_ERROR` is returned, there has been no detectable error since the last
    call to `glGetError()`, or since the GL was initialized.
  prefs: []
  type: TYPE_NORMAL
- en: If no other errors are recorded until the `glGetError()` method is called, the
    error code is returned, and the flag is reset to `GL_NO_ERROR`.
  prefs: []
  type: TYPE_NORMAL
- en: The following table lists the basic defined OpenGL error codes and their descriptions
    that are returned by the `glGetError` method call.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Error code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_INVALID_ENUM` | `GLenum` argument out of range |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_INVALID_VALUE` | Numeric argument out of range |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_INVALID_OPERATION` | Operation illegal in current state |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_STACK_OVERFLOW` | Command would cause a stack overflow |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_STACK_UNDERFLOW` | Command would cause a stack underflow |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_OUT_OF_MEMORY` | Not enough memory left to execute command |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_NO_ERROR` | No error has occurred. |'
  prefs: []
  type: TYPE_TB
- en: Detecting errors by setting up breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting breakpoints within your code gives you the flexibility to stop execution
    at any point within your code, so that you can investigate and step through to
    find out why a piece of code is not working correctly. This is particularly handy
    if you want to step through specific OpenGL functions. These breakpoints should
    be set immediately before calling the function, and your program will be stopped
    and the status bar will indicate which function caused the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up breakpoints in your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you can use the debugger to pause execution of your program at any
    time and view the state of the running code, it's usually helpful to set breakpoints
    before running your executable so that you can stop at known points, and view
    the values of variables in your source code.
  prefs: []
  type: TYPE_NORMAL
- en: A breakpoint is basically an instruction in your code that tells the application
    to *stop* when the breakpoint is reached, and execution of the program pauses,
    waiting for further instructions as to what to do next. During this phase, you
    have the opportunity to either inspect the current values of any of the properties,
    or step through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the following routine that uses the `glGetError` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we have declared a variable `err`, which will be used to
    store the error number that will be returned by the `glGetError` method. We then
    cycle through and output each error message's details to the debug console window
    until no more errors exist, upon which, we exit from the loop. Although you can
    use the Xcode 4 debugger to pause execution of your program at any time to view
    the state of your running code, it is more helpful to set breakpoints at those
    areas prior to running your application.
  prefs: []
  type: TYPE_NORMAL
- en: To set breakpoints, open any source implementation file, and click within the
    gutter pane section of the Xcode source editor, next to the spot to where you
    would like your program to stop. When you add a breakpoint, Xcode will automatically
    enable it and this will be indicated by a light blue color as shown in the screenshot
    below. Breakpoints can also be toggled to be switched off, by clicking on the
    breakpoint again, having this turn to more of a transparent color.
  prefs: []
  type: TYPE_NORMAL
- en: The **Breakpoint Navigator** window shows all current breakpoints that have
    been set within your project, and will display all active as well as inactive
    breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up breakpoints in your code](img/2267EXP_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This view contains several options that can be configured for each breakpoint,
    and a breakpoint can contain multiple conditions. You can choose to log messages
    out to the Xcode console window, or execute a `debug` command. To access this
    view, hold down the *control* key, and right-click with the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: A new feature that comes with Xcode 4.2, is the ability to capture OpenGL frames,
    so that you can debug your code right within the Xcode development environment,
    and scroll through each of your OpenGL ES method calls, as well as viewing state
    and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Setting conditional OpenGL ES entry point breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have looked at setting breakpoints within your code in the event that you
    want your application to stop whenever that particular line is hit. Another way
    in which you can use breakpoints, is to have them stop when a particular condition
    has been met, and then have it perform a particular action, as shown in following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting conditional OpenGL ES entry point breakpoints](img/2267EXP_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You have the ability to either have it stop when the condition has been met,
    as seen in this screenshot, or you can choose to ignore the condition altogether
    and have it fire after a specified number of times the method gets called.
  prefs: []
  type: TYPE_NORMAL
- en: You can then choose to have it fire of a particular action. As you can see from
    this screenshot, we set up a condition to capture the current frame when the variable
    `transY` is greater than or equal to `2`. This will then launch the **OpenGL Frame
    Capture** section, so that we can step through and debug our code further, to
    see what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways in which we can debug OpenGL ES projects through the use
    of **Instruments**, which we will be covering in [Chapter 6](ch06.html "Chapter 6. Xcode
    Tools - Improvements"),*Xcode Tools Improvements*.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking on frame boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **OpenGL ES Debugger** allows you to see all of the frames that are being
    drawn within your application. You can have your application break at a certain
    point within your program, and then use the debug navigator to navigate to the
    area within your code to where the frame has been drawn. In the following screenshot,
    it displays the instance of the captured frame, and displays the state calls associated
    within that frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking on frame boundaries](img/2267EXP_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the `glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)` option, as shown in the
    previous screenshot, will allow you to see a list of all of the associated draw
    calls that have been made. You can also cycle through the frames that have been
    captured by using the scrub bar, as highlighted in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking on frame boundaries](img/2267EXP_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the **[OpenGLESExampleViewController drawframe]** method , as shown
    in the previous screenshot, will open the Xcode development IDE and take you directly
    to the area to where your code is located, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking on frame boundaries](img/2267EXP_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By using the OpenGL ES debugger, you can step through each of your frames within
    your application, to help you track-down and debug when textures are not rendering
    properly, or if the colors on your object look odd.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the differences between vertex shaders and
    fragment shaders, and their relation to one another. We then looked at the new
    debugging features of OpenGL ES, and how this new debugger in Xcode allows you
    to track down issues specific to OpenGL ES within your code, right within the
    Xcode IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We familiarized ourselves with the OpenGL ES frame capture tool, its ability
    to stop execution of a program, and grab the current frame contents that are being
    rendered on the iOS device. This is so that we are able to easily track-down and
    correct program issues, by taking a closer look at the program state information
    of objects, by scrolling through the debug navigator stack trace, as well as the
    ability to see all of the textures and shaders currently being used by the application.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the OpenGL ES `glGetError` method call, and how we can
    use this to provide us with a list of errors that have been detected. To end the
    chapter, we looked at how we can break on frame boundaries within OpenGL and see
    the values of the current program frame state, as defined by the objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will gain an understanding of what **Storyboards** are,
    and how we can apply the various transitions between views, as well as how to
    create and configure scenes and storyboard files, to present these programmatically.
    We will also look at how to build and integrate Twitter capabilities into our
    application, to tweet photos and standard messages.
  prefs: []
  type: TYPE_NORMAL
