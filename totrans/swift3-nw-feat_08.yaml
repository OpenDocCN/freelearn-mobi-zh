- en: Chapter 8. Oh Goodness! Look Whats New in the Foundation Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last year, Apple delivered a great talk on the benefits of using value types
    and protocol-oriented design patterns in our code. This year with Swift 3, the
    team at Apple added value types to the Foundation framework. Many of our favorite
    and heavily used classes now have value type equivalents. We will cover how to
    use Foundation value types throughout this chapter and have you wondering why
    value types weren't included with Swift from the beginning!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: New to Foundation and made possible by Swift 3, the new measurements and units
    API [https://developer.apple.com/reference/foundation/nsmeasurement](https://developer.apple.com/reference/foundation/nsmeasurement)
    addresses pain points that have been with Objective-C and Swift developers for
    a long time. Apple has created an extremely well thought out solution to our problems.
    We will use several examples to hammer in the concepts so that you will leave
    this chapter better prepared to handle your measurement challenges in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Mutability and Foundation value types
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key concepts of the Swift language is to give developers the ability
    to control the mutability of their objects. We use `let` to make a value a constant
    and `var` to make the value a variable. However, certain types, when imported
    from Objective-C, do not provide easy mutability features. Swift 3 aims to change
    this by adding a new set of Foundation value types to wrap reference types in
    order to provide mutable options for developers. In fact, this really isn't all
    that new as Foundation already uses many value types in both Objective-C and Swift.
    Foundation has existing types such as primitives, Enumerations, Option sets, and
    C structure types that already were value types in previous versions of Swift
    and Objective-C.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: To make the conversion from reference type to value type possible, Swift uses
    the *copy-on-write* technique for new value types whose underlying data contains
    more than just simple data. With *copy-on-write*, the value type represents a
    pointer to shared data and only makes a copy of the data, if there is a request
    to change the data by one of the references to it. The following table lists the
    new value types added to the Foundation framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1: new value types:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value type** | **class Type** |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '| `AffineTransform` | `NSAffineTransform` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '| `CharacterSet` | `NSCharacterSet`, `NSMutableCharacterSet` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: '| `Data` | `NSData` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| `Date` | `NSDate` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| `DateComponents` | `NSDateComponents` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| `DateInterval` (new) |  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| `Decimal` | `NSDecimal` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| `IndexPath` | `NSIndexPath` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `IndexSet` | `NSIndexSet`, `NSMutableIndexSet` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `Measurement` (new) |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `Notification` | `NSNotification` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `PersonNameComponents` | `NSPersonNameComponents` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| `URL` | `NSURL` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| `URLComponents` | `NSURLComponents` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| `URLRequest` | `NSURLRequest`, `NSMutableURLRequest` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| `URLQueryItem` | `NSURLQueryItem` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| `UUID` | `NSUUID` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: These new value types work just like their counterparts, with the added value
    that you can control the mutability in a more transparent way. Some of the new
    value types are implemented as structure types and will have one or more mutating
    methods exposed. The good news is that the new Foundation value types will have
    no impact on existing Objective-C code. However, there will be an impact on the
    Swift side. Any existing Swift code migrated to Swift 3 that uses reference types
    will shift to call the new value types. While the migrator will do much of the
    heavy lifting, you will still have opportunities to further enhance your code
    use. This is because the migrator utilizes a strategy of making the minimum number
    of changes possible. As an example, the migrator will not attempt to change any
    Swift subclasses for reference types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Value types versus reference types
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a refresher, let's quickly cover the difference between value and reference
    types. Value types hold values and copy content on assignment or when they are
    passed to methods as a parameter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, `avg2` copies the value of `avg1`, and is free to
    change its value without affecting the value of `avg1`. Reference types, on the
    other hand, share content by default. Changing one of the variables will change
    the underlying value that each reference shares.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we use the reference type `NSDateComponents` to create `dateComponents1`
    and set the day calendar unit to 10\. We then create another variable and assign
    our first value to it. Since both variables share their underlying data, modifying
    either variable changes both values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Nested enumerations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Foundation framework takes advantage of Swift 3's new nested enumeration
    feature. This feature allows the migrator to import related Objective-C enumerations
    into Swift under a common type. For example, the `NSDateFormatterStyle` and `NSDateFormatterBehavior`
    enumerations are imported as nested enumerations to the `DateFormatter` class
    in Swift. Let's see how we get to a nested enumeration in Swift 3, starting with
    an Objective-C enumeration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Swift 2.2-Better but not quite done:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Swift 3:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Working with nested enumerations in Swift 3 is an improvement over Swift 2.2
    because we no longer have to worry about a polluted global namespace of C-based
    enumerations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Strongly typed string enumerations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Foundation framework has a lot of string-based constants. For example, `UIKit`
    uses `NSNotifications` to publishing notifications for an iOS app's lifecycle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'New for Foundation, Objective-C now has the ability to use strongly typed string
    enumerations. This new feature allowed the Foundation team to update the enumerations
    in Objective-C. Our notifications listed earlier can now use the `NSNotificationName`
    type and convert our preceding constants to:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In Swift, `NSNotificationName` types are imported as an extension on `NSNotification.Name`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Class properties
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For historical reasons, the Foundation framework contains many cases where the
    state of a property is closely associated with the type. Therefore, you will find
    lots of class properties on Objective-C types. New for the Swift 3 release, we
    get a tweak to Objective-C that allows us to use a new syntax for creating class
    properties. These class properties in Objective-C will be imported into Swift
    as class properties as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C (old way):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Objective-C (new way):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Swift 2.2:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Swift 3:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Type safe access with value types
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New with Swift 3, you can use Foundation value types to get compile time checks
    to eliminate many of the errors that couldn't be discovered until runtime when
    using reference-based Foundation types. Let's work through an example that demonstrates
    a runtime check in Swift 2.2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2.2:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our example, I created a reference to an existing file named `testFile.txt`.
    I would like to know some of the attributes of the file, which I can get by passing
    an array of strings to the `resourceValuesForKeys` method of my file reference.
    I can read the values using subscript notation and even update the values. Further,
    I can write the new values back to file with the `setResourceValues` method. The
    problem we experience is subtle and not shown until we execute this block of code.
    The `NSURLCreationDateKey` expects its value to be a valid `NSDate`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: However, I passed a string value. At runtime, our code block crashes with an
    error as we attempt to update our file with the new resource values. What we want
    is a way to check our constraints at compile time. Swift 3 now gives us a way
    to do this, and the Foundation framework has been updated to reflect this new
    feature. Let's update our example to reflect using type safe access to our file
    resources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 3:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our updated example, our resource types are now strongly typed values of
    type `URLResourceKey`. When we request the resources from our file, we are returned
    a struct that contains strongly typed properties. These two changes allow us to
    have type safe access and help us to catch issues at compile time. That's a pretty
    nice feature to have and the Foundation team agrees, which is evident by all of
    the APIs they updated to provide us better type constraints.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Measurements and units
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Swift 3's release, the Foundation team is releasing a new API to make handling
    measurements easier for developers. By allowing developers to create measurements
    from common built-in units (or create custom ones), convert between units and
    format them for display. We will cover each of the main areas of the Measurement
    API to get you ready to use them in your projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Measurement
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A measurement is composed of a unit and a value. A unit is a class that contains
    a single property to hold a symbol. We will come back to units in a moment. For
    now, let's focus on what you can do with a measurement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With a measurement, we can define a value and its unit type, which can be used
    to convert to another type. We also gain validation that we aren't mixing measurement
    values that don't work together. It would not necessarily make sense to add a
    length unit to one that stores a volume. Without the measurement's API, you would
    have to write your own methods to ensure the proper constraints held true.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Unit and dimension
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *Unit* is a class that has symbol property. A `Dimension` is a subclass of
    `Unit` and is used to express categories of units. A `Dimension` contains a base
    unit and allows conversion between units via the `UnitConverter` type. `Dimension`
    types also contain singletons for many of the common units you will encounter
    when dealing with measurements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following table contains a listing of the `Dimension` subclasses that are
    available with Foundation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2, Dimension subclasses:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '| `UnitAcceleration` | `UnitAngle` | `UnitArea` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `UnitConcentrationMass` | `UnitDispersion` | `UnitDuration` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `UnitElectricCharge` | `UnitElectricCurrent` | `UnitElectricPotentialDifference`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| `UnitElectricResistance` | `UnitEnergy` | `UnitFrequency` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| `UnitFuelEfficiency` | `UnitLength` | `UnitIlluminance` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `UnitMass` | `UnitPower` | `UnitPressure` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `UnitSpeed` | `UnitTemperature` | `UnitVolume` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: When using the built-in `Dimension` subclasses, you get basic conversion for
    free. For example, I created a `boxHeight` measurement with units of `UnitLength.feet`
    and a `*smallBoxHeight*` with units of `UnitLength.inches`. Next, I added the
    two measurements together and stored the value. The `totalHeight` variable stores
    the combined value using `UnitLength` base value of meters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also use our comparison operations like `==`, `>`, `<` because our measurements
    convert to the base unit before doing the conversions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Custom units
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are going to be times when you need a unit type that doesn't conform to
    one of the pre-built `Dimension` subclasses. To make your own units, you will
    need to create a unit type on an existing `Dimension`, supplying a symbol and
    unit converter function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can add new units to any of the `Dimension` subclasses. Our preceding example
    creates a new `burgers` unit on `UnitLength`. If you need more of a time-based
    unit, you could create a unit on `UnitDuration`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By providing a converter function, you ensure that your unit can be converted
    between its unit and the base unit on the `Dimension` with which it is associated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Custom Dimension types
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to create our new units for the `Dimension` subclasses,
    the questions that begs to be asked is whether you can create custom `Dimension`
    types. As you might have already guessed, creating a new `Dimension` subclass
    is also possible and straightforward.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Convert functions
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In each of the prior `Measurement` examples, we used the `UnitConverterLinear`
    function as our converter function. As mentioned earlier, you need to include
    a converter function any time you add a new unit to a `Dimension`. The converter
    method is used to convert to and from the `Dimension` base unit value. The `UnitConverterLinear`
    converter allows you to make conversions between units when the relation is linear
    (for example, *y = mx + b)*. This class has two initializers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: One to provide just the slope (coefficient or *m* in our line equation) when
    there is no offset.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other to allow you to provide both a slope and offset (b).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Linear Conversion:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `UnitConverterLinear` converter is really useful and will allow you to cover
    many conversions by just providing the ratio between two unit values. However,
    this converter won't fit every relationship between two units. Therefore, you
    can also subclass `UnitConverter` and create a conversion formula that meets your
    use case when the need arises.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you choose to create your own custom unit converter, you are will need to
    override the `baseUnitValue(fromValue value: Double)` and `value(fromBaseUnitValue
    baseUnitValue: Double)` methods. These two methods are used internally to perform
    conversions for you.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Formatting measurements
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dealing with formatting is tough, and you don't have to look any further than
    the `NSDateFormatter` to see how complicated things could be when working with
    dates. Fortunately, the Foundation team added a new measurements formatter to
    do all of the heavy lifting for us. `MeasurementFormatter` will handle formatting
    our `Measurements` and `Unit` types, while taking into account the user's locale.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `UnitOptions` property on `MeasurementFormatter` is a special property that
    we need to take a moment to discuss. The `UnitOptions` property is a struct on
    the `MeasurementFormatter` and instructs our formatter to use the preferred unit
    of the user's locale by default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our example here, we create a custom unit ( `*gittieSecond*` ) and a measurement
    using this unit. We then create a `MeasurementFormatter` and call the `string`
    method, passing our measurement, to get a formatted measurement using the `Dimension` base
    unit. Even though our custom unit has a `gs` symbol, the formatter converts and
    displays our measurement using `seconds`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To change the output of the formatter from using the base unit to instead use
    our `gittieSecond` unit, we need to modify the `UnitOptions` property on the formatter.
    In my locale, the preferred unit for `UnitDuration` is `seconds`. By changing
    the `UnitOptions` use reference `providedUnit`, we ensure that our formatter will
    use the same unit as the `getterThere` measurement passed to the formatter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered changes to the Foundation framework. We started
    with a discussion on mutability and new value types in Foundation. You learned
    that both value and reference types have their place in our code. Next, we covered
    nested enumerations and strongly typed string enumerations. We explored class
    properties and the type-safe access benefits of value types. Finally, we spent
    a great deal of time discussing the new Measurements API introduced this year
    in Foundation. In the next chapter, we will cover testing and debugging. Swift
    3 introduces several changes in testing and debugging that should help improve
    the quality of the code you write.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Foundation框架的变化。我们从Foundation中可变性和新值类型的话题开始讨论。你了解到在代码中，值类型和引用类型都有其合适的位置。接下来，我们介绍了嵌套枚举和强类型字符串枚举。我们探讨了类属性和值类型的类型安全访问优势。最后，我们花费了大量时间讨论了今年在Foundation中引入的新测量API。在下一章中，我们将讨论测试和调试。Swift
    3在测试和调试方面引入了多项变化，这些变化应该有助于提高你编写的代码质量。
