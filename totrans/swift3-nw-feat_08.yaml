- en: Chapter 8. Oh Goodness! Look Whats New in the Foundation Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。哦，太好了！看看在 Foundation 框架中的新内容
- en: Last year, Apple delivered a great talk on the benefits of using value types
    and protocol-oriented design patterns in our code. This year with Swift 3, the
    team at Apple added value types to the Foundation framework. Many of our favorite
    and heavily used classes now have value type equivalents. We will cover how to
    use Foundation value types throughout this chapter and have you wondering why
    value types weren't included with Swift from the beginning!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 去年，苹果公司做了一场关于在代码中使用值类型和面向协议的设计模式的益处的精彩演讲。今年，随着 Swift 3 的发布，苹果团队将值类型添加到了 Foundation
    框架中。我们许多喜爱且广泛使用的类现在都有了值类型的对应版本。在本章中，我们将介绍如何使用 Foundation 值类型，并让你思考为什么值类型从一开始就没有包含在
    Swift 中！
- en: New to Foundation and made possible by Swift 3, the new measurements and units
    API [https://developer.apple.com/reference/foundation/nsmeasurement](https://developer.apple.com/reference/foundation/nsmeasurement)
    addresses pain points that have been with Objective-C and Swift developers for
    a long time. Apple has created an extremely well thought out solution to our problems.
    We will use several examples to hammer in the concepts so that you will leave
    this chapter better prepared to handle your measurement challenges in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 新增于 Foundation 且由 Swift 3 使之成为可能的新测量和单位 API [https://developer.apple.com/reference/foundation/nsmeasurement](https://developer.apple.com/reference/foundation/nsmeasurement)
    解决了 Objective-C 和 Swift 开发者长期以来的痛点。苹果公司为我们的问题创造了一个极其周到的解决方案。我们将通过几个示例来强化这些概念，以便你在未来更好地应对测量挑战。
- en: Mutability and Foundation value types
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性和 Foundation 值类型
- en: One of the key concepts of the Swift language is to give developers the ability
    to control the mutability of their objects. We use `let` to make a value a constant
    and `var` to make the value a variable. However, certain types, when imported
    from Objective-C, do not provide easy mutability features. Swift 3 aims to change
    this by adding a new set of Foundation value types to wrap reference types in
    order to provide mutable options for developers. In fact, this really isn't all
    that new as Foundation already uses many value types in both Objective-C and Swift.
    Foundation has existing types such as primitives, Enumerations, Option sets, and
    C structure types that already were value types in previous versions of Swift
    and Objective-C.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 语言的一个关键概念是赋予开发者控制其对象可变性的能力。我们使用 `let` 来使一个值成为常量，使用 `var` 来使一个值成为变量。然而，某些类型，当从
    Objective-C 导入时，并不提供易于使用的可变性功能。Swift 3 通过添加一组新的 Foundation 值类型来包裹引用类型，从而为开发者提供可变选项，旨在改变这一现状。实际上，这并不是什么新鲜事，因为
    Foundation 已经在 Objective-C 和 Swift 中使用了许多值类型。Foundation 已经存在的类型包括原始类型、枚举、选项集和
    C 结构类型，这些在 Swift 和 Objective-C 的早期版本中已经是值类型。
- en: To make the conversion from reference type to value type possible, Swift uses
    the *copy-on-write* technique for new value types whose underlying data contains
    more than just simple data. With *copy-on-write*, the value type represents a
    pointer to shared data and only makes a copy of the data, if there is a request
    to change the data by one of the references to it. The following table lists the
    new value types added to the Foundation framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使从引用类型到值类型的转换成为可能，Swift 使用了 *copy-on-write* 技术来处理新值类型，其底层数据包含的不仅仅是简单数据。在 *copy-on-write*
    中，值类型代表一个指向共享数据的指针，并且只有在有请求通过其引用之一更改数据时，才会复制数据。以下表格列出了添加到 Foundation 框架中的新值类型。
- en: 'Table 1: new value types:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1：新的值类型：
- en: '| **Value type** | **class Type** |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| **值类型** | **类 Type** |'
- en: '| `AffineTransform` | `NSAffineTransform` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `AffineTransform` | `NSAffineTransform` |'
- en: '| `CharacterSet` | `NSCharacterSet`, `NSMutableCharacterSet` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `CharacterSet` | `NSCharacterSet`, `NSMutableCharacterSet` |'
- en: '| `Data` | `NSData` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `Data` | `NSData` |'
- en: '| `Date` | `NSDate` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `Date` | `NSDate` |'
- en: '| `DateComponents` | `NSDateComponents` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `DateComponents` | `NSDateComponents` |'
- en: '| `DateInterval` (new) |  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `DateInterval` (新) |  |'
- en: '| `Decimal` | `NSDecimal` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `Decimal` | `NSDecimal` |'
- en: '| `IndexPath` | `NSIndexPath` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `IndexPath` | `NSIndexPath` |'
- en: '| `IndexSet` | `NSIndexSet`, `NSMutableIndexSet` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `IndexSet` | `NSIndexSet`, `NSMutableIndexSet` |'
- en: '| `Measurement` (new) |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `Measurement` (新) |  |'
- en: '| `Notification` | `NSNotification` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `Notification` | `NSNotification` |'
- en: '| `PersonNameComponents` | `NSPersonNameComponents` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `PersonNameComponents` | `NSPersonNameComponents` |'
- en: '| `URL` | `NSURL` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `URL` | `NSURL` |'
- en: '| `URLComponents` | `NSURLComponents` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `URLComponents` | `NSURLComponents` |'
- en: '| `URLRequest` | `NSURLRequest`, `NSMutableURLRequest` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `URLRequest` | `NSURLRequest`, `NSMutableURLRequest` |'
- en: '| `URLQueryItem` | `NSURLQueryItem` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `URLQueryItem` | `NSURLQueryItem` |'
- en: '| `UUID` | `NSUUID` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `UUID` | `NSUUID` |'
- en: These new value types work just like their counterparts, with the added value
    that you can control the mutability in a more transparent way. Some of the new
    value types are implemented as structure types and will have one or more mutating
    methods exposed. The good news is that the new Foundation value types will have
    no impact on existing Objective-C code. However, there will be an impact on the
    Swift side. Any existing Swift code migrated to Swift 3 that uses reference types
    will shift to call the new value types. While the migrator will do much of the
    heavy lifting, you will still have opportunities to further enhance your code
    use. This is because the migrator utilizes a strategy of making the minimum number
    of changes possible. As an example, the migrator will not attempt to change any
    Swift subclasses for reference types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的值类型工作方式与它们的对应类型相同，额外的好处是你可以以更透明的方式控制可变性。一些新的值类型被实现为结构体类型，并将公开一个或多个可变方法。好消息是新的
    Foundation 值类型对现有的 Objective-C 代码没有影响。然而，它将对 Swift 侧产生影响。任何现有的 Swift 代码迁移到 Swift
    3，并使用引用类型，将转向调用新的值类型。虽然迁移器会做很多繁重的工作，但你仍有机会进一步优化你的代码。这是因为迁移器采用了一种尽可能少做更改的策略。例如，迁移器不会尝试更改任何
    Swift 子类以用于引用类型。
- en: Value types versus reference types
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: As a refresher, let's quickly cover the difference between value and reference
    types. Value types hold values and copy content on assignment or when they are
    passed to methods as a parameter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，让我们快速了解一下值类型和引用类型之间的区别。值类型持有值，在赋值或作为参数传递给方法时复制内容。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, `avg2` copies the value of `avg1`, and is free to
    change its value without affecting the value of `avg1`. Reference types, on the
    other hand, share content by default. Changing one of the variables will change
    the underlying value that each reference shares.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`avg2` 复制了 `avg1` 的值，并且可以自由更改其值而不影响 `avg1` 的值。另一方面，引用类型默认共享内容。更改其中一个变量将改变每个引用共享的底层值。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we use the reference type `NSDateComponents` to create `dateComponents1`
    and set the day calendar unit to 10\. We then create another variable and assign
    our first value to it. Since both variables share their underlying data, modifying
    either variable changes both values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用引用类型 `NSDateComponents` 创建 `dateComponents1` 并将日历单位设置为 10。然后我们创建另一个变量并将第一个值赋给它。由于两个变量共享其底层数据，修改任何一个变量都会改变两个值。
- en: Nested enumerations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套枚举
- en: The Foundation framework takes advantage of Swift 3's new nested enumeration
    feature. This feature allows the migrator to import related Objective-C enumerations
    into Swift under a common type. For example, the `NSDateFormatterStyle` and `NSDateFormatterBehavior`
    enumerations are imported as nested enumerations to the `DateFormatter` class
    in Swift. Let's see how we get to a nested enumeration in Swift 3, starting with
    an Objective-C enumeration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Foundation 框架利用了 Swift 3 的新嵌套枚举功能。这个功能允许迁移器将相关的 Objective-C 枚举导入到 Swift 中，作为一个公共类型。例如，`NSDateFormatterStyle`
    和 `NSDateFormatterBehavior` 枚举被导入到 Swift 的 `DateFormatter` 类中作为嵌套枚举。让我们看看如何在 Swift
    3 中实现嵌套枚举，从 Objective-C 枚举开始。
- en: 'In Objective-C:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Swift 2.2-Better but not quite done:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2.2-更好但尚未完成：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Swift 3:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Working with nested enumerations in Swift 3 is an improvement over Swift 2.2
    because we no longer have to worry about a polluted global namespace of C-based
    enumerations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中使用嵌套枚举比 Swift 2.2 有所改进，因为我们不再需要担心基于 C 的枚举污染全局命名空间。
- en: Strongly typed string enumerations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强类型字符串枚举
- en: The Foundation framework has a lot of string-based constants. For example, `UIKit`
    uses `NSNotifications` to publishing notifications for an iOS app's lifecycle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Foundation 框架有很多基于字符串的常量。例如，`UIKit` 使用 `NSNotifications` 发布 iOS 应用生命周期的通知。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'New for Foundation, Objective-C now has the ability to use strongly typed string
    enumerations. This new feature allowed the Foundation team to update the enumerations
    in Objective-C. Our notifications listed earlier can now use the `NSNotificationName`
    type and convert our preceding constants to:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Foundation 来说，Objective-C 现在有了使用强类型字符串枚举的能力。这个新特性允许 Foundation 团队更新 Objective-C
    中的枚举。我们之前列出的通知现在可以使用 `NSNotificationName` 类型，并将先前的常量转换为：
- en: 'In Objective-C:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In Swift, `NSNotificationName` types are imported as an extension on `NSNotification.Name`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，`NSNotificationName` 类型作为 `NSNotification.Name` 的扩展导入。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Class properties
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类属性
- en: For historical reasons, the Foundation framework contains many cases where the
    state of a property is closely associated with the type. Therefore, you will find
    lots of class properties on Objective-C types. New for the Swift 3 release, we
    get a tweak to Objective-C that allows us to use a new syntax for creating class
    properties. These class properties in Objective-C will be imported into Swift
    as class properties as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，Foundation框架中包含许多属性状态与类型紧密关联的案例。因此，你会在Objective-C类型上找到许多类属性。对于Swift 3的发布，我们得到了对Objective-C的一个调整，允许我们使用新的语法来创建类属性。这些Objective-C中的类属性也将作为类属性导入Swift中。
- en: 'In Objective-C (old way):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C（旧方法）：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Objective-C (new way):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C（新方法）：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Swift 2.2:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 2.2中：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Swift 3:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 3中：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Type safe access with value types
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型的类型安全访问
- en: New with Swift 3, you can use Foundation value types to get compile time checks
    to eliminate many of the errors that couldn't be discovered until runtime when
    using reference-based Foundation types. Let's work through an example that demonstrates
    a runtime check in Swift 2.2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 3的新特性，你可以使用Foundation值类型来在编译时进行类型安全检查，以消除使用基于引用的Foundation类型时在运行时无法发现的许多错误。让我们通过一个示例来演示Swift
    2.2中的运行时检查。
- en: 'In Swift 2.2:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 2.2中：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our example, I created a reference to an existing file named `testFile.txt`.
    I would like to know some of the attributes of the file, which I can get by passing
    an array of strings to the `resourceValuesForKeys` method of my file reference.
    I can read the values using subscript notation and even update the values. Further,
    I can write the new values back to file with the `setResourceValues` method. The
    problem we experience is subtle and not shown until we execute this block of code.
    The `NSURLCreationDateKey` expects its value to be a valid `NSDate`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我创建了一个指向现有文件`testFile.txt`的引用。我想了解一些文件属性，这些属性可以通过将字符串数组传递给我的文件引用的`resourceValuesForKeys`方法来获取。我可以使用索引符号读取值，甚至更新值。此外，我可以用`setResourceValues`方法将新值写回文件。我们遇到的问题很微妙，直到我们执行这段代码才会显示出来。`NSURLCreationDateKey`期望其值是一个有效的`NSDate`。
- en: However, I passed a string value. At runtime, our code block crashes with an
    error as we attempt to update our file with the new resource values. What we want
    is a way to check our constraints at compile time. Swift 3 now gives us a way
    to do this, and the Foundation framework has been updated to reflect this new
    feature. Let's update our example to reflect using type safe access to our file
    resources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我传递了一个字符串值。在运行时，当我们尝试使用新的资源值更新我们的文件时，我们的代码块崩溃并出现错误。我们想要的是一种在编译时检查约束的方法。Swift
    3现在为我们提供了这样做的方法，Foundation框架也已更新以反映这一新特性。让我们更新我们的示例，以反映使用类型安全访问我们的文件资源。
- en: 'In Swift 3:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 3中：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our updated example, our resource types are now strongly typed values of
    type `URLResourceKey`. When we request the resources from our file, we are returned
    a struct that contains strongly typed properties. These two changes allow us to
    have type safe access and help us to catch issues at compile time. That's a pretty
    nice feature to have and the Foundation team agrees, which is evident by all of
    the APIs they updated to provide us better type constraints.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的更新示例中，我们的资源类型现在是类型为`URLResourceKey`的强类型值。当我们从文件请求资源时，我们返回一个包含强类型属性的struct。这两个变化使我们能够进行类型安全访问，并帮助我们编译时捕捉问题。这是一个相当好的特性，Foundation团队也同意，这从他们更新的所有API中可以看出，这些API为我们提供了更好的类型约束。
- en: Measurements and units
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量和单位
- en: With Swift 3's release, the Foundation team is releasing a new API to make handling
    measurements easier for developers. By allowing developers to create measurements
    from common built-in units (or create custom ones), convert between units and
    format them for display. We will cover each of the main areas of the Measurement
    API to get you ready to use them in your projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Swift 3的发布，Foundation团队发布了一个新的API，使开发者处理测量变得更加容易。通过允许开发者从常见的内置单位（或创建自定义单位）创建测量，在单位之间进行转换，以及为显示格式化它们。我们将涵盖Measurement
    API的主要区域，以便你准备好在你的项目中使用它们。
- en: Measurement
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量
- en: A measurement is composed of a unit and a value. A unit is a class that contains
    a single property to hold a symbol. We will come back to units in a moment. For
    now, let's focus on what you can do with a measurement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测量由一个单位和值组成。单位是一个包含单个属性以持有符号的类。我们稍后会回到单位。现在，让我们专注于你可以用测量做什么。
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With a measurement, we can define a value and its unit type, which can be used
    to convert to another type. We also gain validation that we aren't mixing measurement
    values that don't work together. It would not necessarily make sense to add a
    length unit to one that stores a volume. Without the measurement's API, you would
    have to write your own methods to ensure the proper constraints held true.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测量，我们可以定义一个值及其单位类型，这可以用于转换为其他类型。我们还获得了验证，确保我们不会混合不兼容的测量值。将长度单位添加到存储体积的单位上并不一定有意义。如果没有测量
    API，你将不得不编写自己的方法来确保适当的约束保持有效。
- en: Unit and dimension
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单位和维度
- en: A *Unit* is a class that has symbol property. A `Dimension` is a subclass of
    `Unit` and is used to express categories of units. A `Dimension` contains a base
    unit and allows conversion between units via the `UnitConverter` type. `Dimension`
    types also contain singletons for many of the common units you will encounter
    when dealing with measurements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unit* 是一个具有符号属性的类。`Dimension` 是 `Unit` 的子类，用于表示单位类别。`Dimension` 包含一个基本单位，并允许通过
    `UnitConverter` 类型在单位之间进行转换。`Dimension` 类型还包含了许多常见单位的单例，这些单位在处理测量时可能会遇到。'
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following table contains a listing of the `Dimension` subclasses that are
    available with Foundation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 Foundation 中可用的 `Dimension` 子类。
- en: 'Table 2, Dimension subclasses:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2，`Dimension` 子类：
- en: '| `UnitAcceleration` | `UnitAngle` | `UnitArea` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `UnitAcceleration` | `UnitAngle` | `UnitArea` |'
- en: '| `UnitConcentrationMass` | `UnitDispersion` | `UnitDuration` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `UnitConcentrationMass` | `UnitDispersion` | `UnitDuration` |'
- en: '| `UnitElectricCharge` | `UnitElectricCurrent` | `UnitElectricPotentialDifference`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `UnitElectricCharge` | `UnitElectricCurrent` | `UnitElectricPotentialDifference`
    |'
- en: '| `UnitElectricResistance` | `UnitEnergy` | `UnitFrequency` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `UnitElectricResistance` | `UnitEnergy` | `UnitFrequency` |'
- en: '| `UnitFuelEfficiency` | `UnitLength` | `UnitIlluminance` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `UnitFuelEfficiency` | `UnitLength` | `UnitIlluminance` |'
- en: '| `UnitMass` | `UnitPower` | `UnitPressure` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `UnitMass` | `UnitPower` | `UnitPressure` |'
- en: '| `UnitSpeed` | `UnitTemperature` | `UnitVolume` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `UnitSpeed` | `UnitTemperature` | `UnitVolume` |'
- en: When using the built-in `Dimension` subclasses, you get basic conversion for
    free. For example, I created a `boxHeight` measurement with units of `UnitLength.feet`
    and a `*smallBoxHeight*` with units of `UnitLength.inches`. Next, I added the
    two measurements together and stored the value. The `totalHeight` variable stores
    the combined value using `UnitLength` base value of meters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用内置的 `Dimension` 子类时，你可以免费获得基本的转换。例如，我创建了一个 `boxHeight` 测量值，单位为 `UnitLength.feet`，以及一个
    `*smallBoxHeight*`，单位为 `UnitLength.inches`。然后，我将这两个测量值相加并存储了值。`totalHeight` 变量使用
    `UnitLength` 的基本单位米来存储组合值。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also use our comparison operations like `==`, `>`, `<` because our measurements
    convert to the base unit before doing the conversions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用我们的比较操作，如 `==`、`>`、`<`，因为我们的测量值在转换之前会转换为基本单位。
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Custom units
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义单位
- en: There are going to be times when you need a unit type that doesn't conform to
    one of the pre-built `Dimension` subclasses. To make your own units, you will
    need to create a unit type on an existing `Dimension`, supplying a symbol and
    unit converter function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将来会有需要创建一个不符合预构建 `Dimension` 子类之一的单元类型的时候。为了创建自己的单位，你需要在现有的 `Dimension` 上创建一个单元类型，提供符号和单位转换函数。
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can add new units to any of the `Dimension` subclasses. Our preceding example
    creates a new `burgers` unit on `UnitLength`. If you need more of a time-based
    unit, you could create a unit on `UnitDuration`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向任何 `Dimension` 子类添加新的单位。我们前面的例子在 `UnitLength` 上创建了一个新的 `burgers` 单位。如果你需要一个更多基于时间的单位，你可以在
    `UnitDuration` 上创建一个单位。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By providing a converter function, you ensure that your unit can be converted
    between its unit and the base unit on the `Dimension` with which it is associated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供转换函数，你确保了你的单位可以在其单位和关联的 `Dimension` 的基本单位之间进行转换。
- en: Custom Dimension types
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义维度类型
- en: Now that we know how to create our new units for the `Dimension` subclasses,
    the questions that begs to be asked is whether you can create custom `Dimension`
    types. As you might have already guessed, creating a new `Dimension` subclass
    is also possible and straightforward.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何为 `Dimension` 子类创建新的单位，接下来要问的问题是，你是否可以创建自定义的 `Dimension` 类型。正如你可能已经猜到的，创建一个新的
    `Dimension` 子类也是可能的，并且很简单。
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Convert functions
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换函数
- en: 'In each of the prior `Measurement` examples, we used the `UnitConverterLinear`
    function as our converter function. As mentioned earlier, you need to include
    a converter function any time you add a new unit to a `Dimension`. The converter
    method is used to convert to and from the `Dimension` base unit value. The `UnitConverterLinear`
    converter allows you to make conversions between units when the relation is linear
    (for example, *y = mx + b)*. This class has two initializers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `Measurement` 示例中，我们使用了 `UnitConverterLinear` 函数作为我们的转换函数。如前所述，每次向 `Dimension`
    添加新单位时，都需要包含一个转换函数。转换方法用于在 `Dimension` 基本单位值之间进行转换。`UnitConverterLinear` 转换器允许你在关系是线性的情况下（例如，*y
    = mx + b*）在单位之间进行转换。此类有两个初始化器：
- en: One to provide just the slope (coefficient or *m* in our line equation) when
    there is no offset.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当没有偏移量时，提供一个仅包含斜率（系数或我们线性方程中的 *m*）。
- en: The other to allow you to provide both a slope and offset (b).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个允许你提供斜率和偏移量（b）。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Linear Conversion:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 线性转换：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `UnitConverterLinear` converter is really useful and will allow you to cover
    many conversions by just providing the ratio between two unit values. However,
    this converter won't fit every relationship between two units. Therefore, you
    can also subclass `UnitConverter` and create a conversion formula that meets your
    use case when the need arises.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnitConverterLinear` 转换器非常有用，它将允许你通过仅提供两个单位值之间的比率来覆盖许多转换。然而，这个转换器可能不适合两个单位之间的所有关系。因此，你还可以子类化
    `UnitConverter` 并在需要时创建一个满足你用例的转换公式。'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you choose to create your own custom unit converter, you are will need to
    override the `baseUnitValue(fromValue value: Double)` and `value(fromBaseUnitValue
    baseUnitValue: Double)` methods. These two methods are used internally to perform
    conversions for you.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你选择创建自己的自定义单位转换器，你需要重写 `baseUnitValue(fromValue value: Double)` 和 `value(fromBaseUnitValue
    baseUnitValue: Double)` 方法。这两个方法用于内部为你执行转换。'
- en: Formatting measurements
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量值格式化
- en: Dealing with formatting is tough, and you don't have to look any further than
    the `NSDateFormatter` to see how complicated things could be when working with
    dates. Fortunately, the Foundation team added a new measurements formatter to
    do all of the heavy lifting for us. `MeasurementFormatter` will handle formatting
    our `Measurements` and `Unit` types, while taking into account the user's locale.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 处理格式化问题很棘手，你只需看看 `NSDateFormatter` 就能明白在处理日期时事情可能会多么复杂。幸运的是，Foundation 团队为我们添加了一个新的测量格式化器来承担所有繁重的工作。`MeasurementFormatter`
    将处理我们的 `Measurements` 和 `Unit` 类型格式化，同时考虑到用户的地区设置。
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `UnitOptions` property on `MeasurementFormatter` is a special property that
    we need to take a moment to discuss. The `UnitOptions` property is a struct on
    the `MeasurementFormatter` and instructs our formatter to use the preferred unit
    of the user's locale by default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeasurementFormatter` 上的 `UnitOptions` 属性是一个特殊的属性，我们需要花点时间来讨论。`UnitOptions`
    属性是 `MeasurementFormatter` 上的一个结构体，并指示我们的格式化器默认使用用户地区设置的首选单位。'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our example here, we create a custom unit ( `*gittieSecond*` ) and a measurement
    using this unit. We then create a `MeasurementFormatter` and call the `string`
    method, passing our measurement, to get a formatted measurement using the `Dimension` base
    unit. Even though our custom unit has a `gs` symbol, the formatter converts and
    displays our measurement using `seconds`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个自定义单位（`*gittieSecond*`）和一个使用此单位的测量。然后我们创建了一个 `MeasurementFormatter`
    并调用 `string` 方法，传递我们的测量，以获取使用 `Dimension` 基本单位格式的测量。尽管我们的自定义单位有一个 `gs` 符号，但格式化器会将我们的测量转换为并使用
    `seconds` 显示。
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To change the output of the formatter from using the base unit to instead use
    our `gittieSecond` unit, we need to modify the `UnitOptions` property on the formatter.
    In my locale, the preferred unit for `UnitDuration` is `seconds`. By changing
    the `UnitOptions` use reference `providedUnit`, we ensure that our formatter will
    use the same unit as the `getterThere` measurement passed to the formatter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将格式化器的输出从使用基本单位更改为使用我们的 `gittieSecond` 单位，我们需要修改格式化器上的 `UnitOptions` 属性。在我的地区设置中，`UnitDuration`
    的首选单位是 `seconds`。通过更改 `UnitOptions` 使用提供的 `referenceUnit`，我们确保我们的格式化器将使用与传递给格式化器的
    `getterThere` 测量相同的单位。
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered changes to the Foundation framework. We started
    with a discussion on mutability and new value types in Foundation. You learned
    that both value and reference types have their place in our code. Next, we covered
    nested enumerations and strongly typed string enumerations. We explored class
    properties and the type-safe access benefits of value types. Finally, we spent
    a great deal of time discussing the new Measurements API introduced this year
    in Foundation. In the next chapter, we will cover testing and debugging. Swift
    3 introduces several changes in testing and debugging that should help improve
    the quality of the code you write.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Foundation框架的变化。我们从Foundation中可变性和新值类型的话题开始讨论。你了解到在代码中，值类型和引用类型都有其合适的位置。接下来，我们介绍了嵌套枚举和强类型字符串枚举。我们探讨了类属性和值类型的类型安全访问优势。最后，我们花费了大量时间讨论了今年在Foundation中引入的新测量API。在下一章中，我们将讨论测试和调试。Swift
    3在测试和调试方面引入了多项变化，这些变化应该有助于提高你编写的代码质量。
