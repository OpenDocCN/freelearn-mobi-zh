["```kt\nfun main(args: Array<String>) {\n    listOf(1, 2, 3)\n            .map { i -> i * 2 }\n            .map(Int::toString)\n            .forEach(::println)\n}\n```", "```kt\ninterface Functor<C<_>> { //Invalid Kotlin code\n    fun <A,B> map(ca: C<A>, transform: (A) -> B): C<B>\n}\n```", "```kt\ntrait Functor[F[_]] extends Invariant[F] { self =>\n  def map[A, B](fa: F[A])(f: A => B): F[B]\n\n  //More code here\n```", "```kt\nsealed class Option<out T> {\n    object None : Option<Nothing>() {\n        override fun toString() = \"None\"\n    }\n\n    data class Some<out T>(val value: T) : Option<T>()\n\n    companion object\n}\n```", "```kt\nfun <T, R> Option<T>.map(transform: (T) -> R): Option<R> = when (this) {\n    Option.None -> Option.None\n    is Option.Some -> Option.Some(transform(value))\n}\n```", "```kt\nfun main(args: Array<String>) {\n    println(Option.Some(\"Kotlin\")\n            .map(String::toUpperCase)) //Some(value=KOTLIN)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    println(Option.Some(\"Kotlin\").map(String::toUpperCase)) //Some(value=KOTLIN)\n    println(Option.None.map(String::toUpperCase)) //None\n}\n```", "```kt\nfun <A, B, C> ((A) -> B).map(transform: (B) -> C): (A) -> C = { t -> transform(this(t)) }\n```", "```kt\nfun main(args: Array<String>) {\n    val add3AndMultiplyBy2: (Int) -> Int = { i: Int -> i + 3 }.map { j -> j * 2 }\n    println(add3AndMultiplyBy2(0)) //6\n    println(add3AndMultiplyBy2(1)) //8\n    println(add3AndMultiplyBy2(2)) //10\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val result = listOf(1, 2, 3)\n            .flatMap { i ->\n                listOf(i * 2, i + 3)\n            }\n            .joinToString()\n\n    println(result) //2, 4, 4, 5, 6, 6\n}\n```", "```kt\ninterface Monad<C<_>>: Functor<C> { //Invalid Kotlin code\n    fun <A, B> flatMap(ca:C<A>, fm:(A) -> C<B>): C<B>\n}\n```", "```kt\nfun <T, R> Option<T>.flatMap(fm: (T) -> Option<R>): Option<R> = when (this) {\n    Option.None -> Option.None\n    is Option.Some -> fm(value)\n}\n```", "```kt\nfun <T, R> Option<T>.map(transform: (T) -> R): Option<R> = flatMap { t -> Option.Some(transform(t)) }\n```", "```kt\nfun calculateDiscount(price: Option<Double>): Option<Double> {\n    return price.flatMap { p ->\n        if (p > 50.0) {\n            Option.Some(5.0)\n        } else {\n            Option.None\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    println(calculateDiscount(Option.Some(80.0))) //Some(value=5.0)\n    println(calculateDiscount(Option.Some(30.0))) //None\n    println(calculateDiscount(Option.None)) //None\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val maybeFive = Option.Some(5)\n    val maybeTwo = Option.Some(2)\n\n    println(maybeFive.flatMap { f ->\n        maybeTwo.flatMap { t ->\n            Option.Some(f + t)\n        }\n    }) // Some(value=7)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val maybeFive = Option.Some(5)\n    val maybeTwo = Option.Some(2)\n\n    println(maybeFive.flatMap { f ->\n        maybeTwo.map { t ->\n            f + t\n        }\n    }) // Some(value=7)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val numbers = listOf(1, 2, 3)\n    val functions = listOf<(Int) -> Int>({ i -> i * 2 }, { i -> i + 3 })\n    val result = numbers.flatMap { number ->\n        functions.map { f -> f(number) }\n    }.joinToString()\n\n    println(result) //2, 4, 4, 5, 6, 6\n}\n```", "```kt\ninterface Functor<C<_>> { //Invalid Kotlin code\n    fun <A,B> map(ca:C<A>, transform:(A) -> B): C<B>\n}\n\ninterface Applicative<C<_>>: Functor<C> { //Invalid Kotlin code\n    fun <A> pure(a:A): C<A>\n\n    fun <A, B> ap(ca:C<A>, fab: C<(A) -> B>): C<B>\n}\n\ninterface Monad<C<_>>: Applicative<C> { //Invalid Kotlin code\n    fun <A, B> flatMap(ca:C<A>, fm:(A) -> C<B>): C<B>\n}\n```", "```kt\nfun <T, R> List<T>.ap(fab: List<(T) -> R>): List<R> = fab.flatMap { f -> this.map(f) }\n```", "```kt\nfun main(args: Array<String>) {\n    val numbers = listOf(1, 2, 3)\n    val functions = listOf<(Int) -> Int>({ i -> i * 2 }, { i -> i + 3 })\n    val result = numbers.flatMap { number ->\n        functions.map { f -> f(number) }\n    }.joinToString()\n\n    println(result) //2, 4, 4, 5, 6, 6\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val numbers = listOf(1, 2, 3)\n    val functions = listOf<(Int) -> Int>({ i -> i * 2 }, { i -> i + 3 })\n    val result = numbers\n            .ap(functions)\n            .joinToString()\n    println(result) //2, 4, 6, 4, 5, 6\n}\n```", "```kt\nfun <T> Option.Companion.pure(t: T): Option<T> = Option.Some(t)\n\n```", "```kt\n//Option\nfun <T, R> Option<T>.ap(fab: Option<(T) -> R>): Option<R> = fab.flatMap { f -> map(f) }\n\n//List\nfun <T, R> List<T>.ap(fab: List<(T) -> R>): List<R> = fab.flatMap { f -> this.map(f) }\n```", "```kt\nfun main(args: Array<String>) {\n    val maybeFive = Option.Some(5)\n    val maybeTwo = Option.Some(2)\n\n    println(maybeFive.flatMap { f ->\n        maybeTwo.map { t ->\n            f + t\n        }\n    }) // Some(value=7)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val maybeFive = Option.pure(5)\n    val maybeTwo = Option.pure(2)\n\n    println(maybeTwo.ap(maybeFive.map { f -> { t: Int -> f + t } })) // Some(value=7)\n}\n```", "```kt\ninfix fun <T, R> Option<(T) -> R>.`(*)`(o: Option<T>): Option<R> = flatMap { f: (T) -> R -> o.map(f) }\n```", "```kt\nfun main(args: Array<String>) {\n    val maybeFive = Option.pure(5)\n    val maybeTwo = Option.pure(2)\n\n    println(Option.pure { f: Int -> { t: Int -> f + t } } `(*)` maybeFive `(*)` maybeTwo) // Some(value=7)\n}\n```", "```kt\nobject Function1 {\n    fun <A, B> pure(b: B) = { _: A -> b }\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val f: (String) -> Int = Function1.pure(0)\n    println(f(\"Hello,\"))    //0\n    println(f(\"World\"))     //0\n    println(f(\"!\"))         //0\n}\n```", "```kt\nfun <A, B, C> ((A) -> B).map(transform: (B) -> C): (A) -> C = { t -> transform(this(t)) }\n\nfun <A, B, C> ((A) -> B).flatMap(fm: (B) -> (A) -> C): (A) -> C = { t -> fm(this(t))(t) }\n\nfun <A, B, C> ((A) -> B).ap(fab: (A) -> (B) -> C): (A) -> C = fab.flatMap { f -> map(f) }\n```", "```kt\nfun main(args: Array<String>) {\n    val add3AndMultiplyBy2: (Int) -> Int = { i: Int -> i + 3 }.ap { { j: Int -> j * 2 } }\n    println(add3AndMultiplyBy2(0)) //6\n    println(add3AndMultiplyBy2(1)) //8\n    println(add3AndMultiplyBy2(2)) //10\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val add3AndMultiplyBy2: (Int) -> Pair<Int, Int> = { i:Int -> i + 3 }.ap { original -> { j:Int -> original to (j * 2) } }\n    println(add3AndMultiplyBy2(0)) //(0, 6)\n    println(add3AndMultiplyBy2(1)) //(1, 8)\n    println(add3AndMultiplyBy2(2)) //(2, 10)\n}\n```"]