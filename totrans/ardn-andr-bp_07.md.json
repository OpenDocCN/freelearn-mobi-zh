["```java\n// Control Arduino board from BLE\n\n// Libraries\n#include <SPI.h>\n#include \"Adafruit_BLE_UART.h\"\n#include <aREST.h>\n\n// Pins\n#define ADAFRUITBLE_REQ 10\n#define ADAFRUITBLE_RDY 2   // Should be pin 2 or 3\n#define ADAFRUITBLE_RST 9\n\n// Relay pin\nconst int relay_pin = 7;\n\n// Create aREST instance\naREST rest = aREST();\n\n// BLE instance\nAdafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);\n\nvoid setup(void)\n{  \n  // Start Serial\n  Serial.begin(115200);\n\n  // Start BLE\n  BTLEserial.begin();\n\n  // Give name and ID to device\n  rest.set_id(\"001\");\n  rest.set_name(\"relay_control\");\n\n   // Init relay pin\n  pinMode(relay_pin,OUTPUT);\n}\n\nvoid loop() {  \n\n  // Tell the nRF8001 to do whatever it should be working on.\n  BTLEserial.pollACI();\n\n  // Ask what is our current status\n  aci_evt_opcode_t status = BTLEserial.getState();\n\n  // Handle REST calls\n  if (status == ACI_EVT_CONNECTED) {\n    rest.handle(BTLEserial);\n  }\n }\n```", "```java\n#include <SPI.h>\n#include \"Adafruit_BLE_UART.h\"\n#include <aREST.h>\n```", "```java\n#define ADAFRUITBLE_REQ 10\n#define ADAFRUITBLE_RDY 2     // This should be an interrupt pin, on Uno thats #2 or #3\n#define ADAFRUITBLE_RST 9\n```", "```java\nconst int relay_pin = 7;\n```", "```java\naREST rest = aREST();\n```", "```java\nAdafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);\n```", "```java\nBTLEserial.begin();\n```", "```java\nrest.set_id(\"001\");\nrest.set_name(\"relay_control\");\n```", "```java\npinMode(relay_pin,OUTPUT);\n```", "```java\nBTLEserial.pollACI();\naci_evt_opcode_t status = BTLEserial.getState();\n```", "```java\nif (status == ACI_EVT_CONNECTED) {\n  rest.handle(BTLEserial);\n}\n```", "```java\n    <uses-permission android:name=\"android.permission.BLUETOOTH\"/>\n    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/>\n```", "```java\n<RelativeLayout \n\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    tools:context=\".SpeechActivity\">\n\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Talk to Arduino\"\n        android:id=\"@+id/talktoArduino\"\n        android:layout_centerVertical=\"true\"\n        android:layout_centerHorizontal=\"true\" />\n\n    <EditText\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/recordedTalk\"\n        android:text=\"What is recorded will be written here\"\n        android:layout_alignParentBottom=\"true\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginBottom=\"139dp\" />\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:textAppearance=\"?android:attr/textAppearanceSmall\"\n        android:text=\"Bluetooth Output\"\n        android:id=\"@+id/btView\"\n        android:layout_marginTop=\"76dp\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_centerHorizontal=\"true\" />\n\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Refresh\"\n        android:id=\"@+id/refreshBtn\"\n        android:layout_above=\"@+id/talktoArduino\"\n        android:layout_alignStart=\"@+id/talktoArduino\"\n        android:layout_alignEnd=\"@+id/talktoArduino\" />\n</RelativeLayout>\n```", "```java\npublic class SpeechActivity extends Activity {\n```", "```java\n    private static final int VOICE_RECOGNITION_REQUEST = 1;\n\n    //Getting the name for Log Tags\n    private final String LOG_TAG = SpeechActivity.class.getSimpleName();\n\n    //Declare U.I Elements\n    private Button startTalk;\n    private Button refresh;\n    private EditText speechInput;\n    private TextView btv;\n\n    // UUIDs for UAT service and associated characteristics.\n    public static UUID UART_UUID = UUID.fromString(\"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\");\n    public static UUID TX_UUID = UUID.fromString(\"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\");\n    public static UUID RX_UUID = UUID.fromString(\"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\");\n    // UUID for the BTLE client characteristic which is necessary for notifications.\n    public static UUID CLIENT_UUID = UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\");\n\n    // BTLE stateta\n    private BluetoothAdapter adapter;\n    private BluetoothGatt gatt;\n    private BluetoothGattCharacteristic tx;\n    private BluetoothGattCharacteristic rx;\n\n    private boolean areServicesAccessible = false;\n```", "```java\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_speech);\n        startTalk = (Button) findViewById(R.id.talktoArduino);\n        refresh = (Button) findViewById(R.id.refreshBtn);\n        speechInput = (EditText) findViewById(R.id.recordedTalk);\n        btv = (TextView) findViewById(R.id.btView);\n\n        startTalk.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                recordSpeech();\n            }\n        });\n\n        refresh.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                restartScan();\n            }\n        });\n\n    }\n```", "```java\n    public void recordSpeech() {\n\n        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);\n\n        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);\n\n        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, \"You can now send a command to the Arduino\");\n\n        startActivityForResult(intent, VOICE_RECOGNITION_REQUEST);\n    }\n```", "```java\n    @Override\n\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\n        if (requestCode == VOICE_RECOGNITION_REQUEST && resultCode == RESULT_OK) {\n\n            ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n\n            String userInput = matches.get(0);\n\n            TextView textSaid = (TextView) findViewById(R.id.recordedTalk);\n\n            textSaid.setText(matches.get(0));\n\n            //add an if else loop or case statement\n\n            if (userInput.equalsIgnoreCase(\"switch on\")) {\n                String setOutputMessage = \"/digital/7/1 /\";\n                tx.setValue(setOutputMessage.getBytes(Charset.forName(\"UTF-8\")));\n                if (gatt.writeCharacteristic(tx)) {\n                    writeSensorData(\"Sent: \" + setOutputMessage);\n                } else {\n                    writeSensorData(\"Couldn't write TX characteristic!\");\n                }\n            } else if (userInput.equalsIgnoreCase(\"switch off\")) {\n                String setOutputMessage = \"/digital/7/0 /\";\n                tx.setValue(setOutputMessage.getBytes(Charset.forName(\"UTF-8\")));\n                if (gatt.writeCharacteristic(tx)) {\n                    writeSensorData(\"Sent: \" + setOutputMessage);\n                } else {\n                    writeSensorData(\"Couldn't write TX characteristic!\");\n                }\n            }\n\n        }\n        super.onActivityResult(requestCode, resultCode, data);\n    }\n```", "```java\n    private void writeSensorData(final CharSequence text) {\n        Log.e(LOG_TAG, text.toString());\n        btv.setText(text.toString());\n    }\n```", "```java\n    // BTLE device scanning bluetoothGattCallback.\n\n    // Main BTLE device bluetoothGattCallback where much of the logic occurs.\n    private BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() {\n        // Called whenever the device connection state changes, i.e. from disconnected to connected.\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n            super.onConnectionStateChange(gatt, status, newState);\n            if (newState == BluetoothGatt.STATE_CONNECTED) {\n                writeSensorData(\"Connected!\");\n                // Discover services.\n                if (!gatt.discoverServices()) {\n                    writeSensorData(\"Failed to start discovering services!\");\n                }\n            } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {\n                writeSensorData(\"Disconnected!\");\n            } else {\n                writeSensorData(\"Connection state changed.  New state: \" + newState);\n            }\n        }\n\n        // Called when services have been discovered on the remote device.\n        // It seems to be necessary to wait for this discovery to occur before\n        // manipulating any services or characteristics.\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            super.onServicesDiscovered(gatt, status);\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                writeSensorData(\"Service discovery completed!\");\n            } else {\n                writeSensorData(\"Service discovery failed with status: \" + status);\n            }\n            // Save reference to each characteristic.\n            tx = gatt.getService(UART_UUID).getCharacteristic(TX_UUID);\n            rx = gatt.getService(UART_UUID).getCharacteristic(RX_UUID);\n\n            // Setup notifications on RX characteristic changes (i.e. data received).\n            // First call setCharacteristicNotification to enable notification.\n            if (!gatt.setCharacteristicNotification(rx, true)) {\n                writeSensorData(\"Couldn't set notifications for RX characteristic!\");\n            }\n\n            // Next update the RX characteristic's client descriptor to enable notifications.\n            if (rx.getDescriptor(CLIENT_UUID) != null) {\n                BluetoothGattDescriptor desc = rx.getDescriptor(CLIENT_UUID);\n                desc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n                if (!gatt.writeDescriptor(desc)) {\n                    writeSensorData(\"Couldn't write RX client descriptor value!\");\n                }\n            } else {\n                writeSensorData(\"Couldn't get RX client descriptor!\");\n            }\n            areServicesAccessible = true;\n        }\n    };\n```", "```java\n    protected void onStart() {\n        Log.d(LOG_TAG,\"onStart has been called\");\n        super.onStart();\n        // / Scan for all BTLE devices.\n        // The first one with the UART service will be chosen--see the code in the scanCallback.\n        adapter = BluetoothAdapter.getDefaultAdapter();\n        startScan();\n    }\n\n    //When this Activity isn't visible anymore\n    protected void onStop() {\n        Log.d(LOG_TAG,\"onStop has been called\");\n        //disconnect and close Bluetooth Connection for better reliability\n        if (gatt != null) {\n            gatt.disconnect();\n            gatt.close();\n            gatt = null;\n            tx = null;\n            rx = null;\n        }\n        super.onStop();\n    }\n```", "```java\n    private void startScan() {\n        if (!adapter.isEnabled()) {\n            adapter.enable();\n        }\n        if (!adapter.isDiscovering()) {\n            adapter.startDiscovery();\n        }\n        writeSensorData(\"Scanning for devices...\");\n        adapter.startLeScan(scanCallback);\n    }\n\n    private void stopScan() {\n        if (adapter.isDiscovering()) {\n            adapter.cancelDiscovery();\n        }\n        writeSensorData(\"Stopping scan\");\n        adapter.stopLeScan(scanCallback);\n    }\n\n    private void restartScan() {\n        stopScan();\n        startScan();\n    }\n```", "```java\n    /**\n     * Main callback following an LE device scan\n     */\n    private BluetoothAdapter.LeScanCallback scanCallback = new BluetoothAdapter.LeScanCallback() {\n        // Called when a device is found.\n        @Override\n        public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) {\n            Log.d(LOG_TAG, bluetoothDevice.getAddress());\n\n            writeSensorData(\"Found device: \" + bluetoothDevice.getAddress());\n\n            // Check if the device has the UART service.\n            if (BluetoothUtils.parseUUIDs(bytes).contains(UART_UUID)) {\n                // Found a device, stop the scan.\n                adapter.stopLeScan(scanCallback);\n                writeSensorData(\"Found UART service!\");\n                // Connect to the device.\n                // Control flow will now go to the bluetoothGattCallback functions when BTLE events occur.\n                gatt = bluetoothDevice.connectGatt(getApplicationContext(), false, bluetoothGattCallback);\n            }\n        }\n    };\n}\n```", "```java\npublic class BluetoothUtils {\n\n    // Filtering by custom UUID is broken in Android 4.3 and 4.4, see:\n    //   http://stackoverflow.com/questions/18019161/startlescan-with-128-bit-uuids-doesnt-work-on-native-android-ble-implementation?noredirect=1#comment27879874_18019161\n    // This is a workaround function from the SO thread to manually parse advertisement data.\n    public static List<UUID> parseUUIDs(final byte[] advertisedData) {\n        List<UUID> uuids = new ArrayList<UUID>();\n\n        int offset = 0;\n        while (offset < (advertisedData.length - 2)) {\n            int len = advertisedData[offset++];\n            if (len == 0)\n                break;\n\n            int type = advertisedData[offset++];\n            switch (type) {\n                case 0x02: // Partial list of 16-bit UUIDs\n                case 0x03: // Complete list of 16-bit UUIDs\n                    while (len > 1) {\n                        int uuid16 = advertisedData[offset++];\n                        uuid16 += (advertisedData[offset++] << 8);\n                        len -= 2;\n                        uuids.add(UUID.fromString(String.format(\"%08x-0000-1000-8000-00805f9b34fb\", uuid16)));\n                    }\n                    break;\n                case 0x06:// Partial list of 128-bit UUIDs\n                case 0x07:// Complete list of 128-bit UUIDs\n                    // Loop through the advertised 128-bit UUID's.\n                    while (len >= 16) {\n                        try {\n                            // Wrap the advertised bits and order them.\n                            ByteBuffer buffer = ByteBuffer.wrap(advertisedData, offset++, 16).order(ByteOrder.LITTLE_ENDIAN);\n                            long mostSignificantBit = buffer.getLong();\n                            long leastSignificantBit = buffer.getLong();\n                            uuids.add(new UUID(leastSignificantBit,\n                                    mostSignificantBit));\n                        } catch (IndexOutOfBoundsException e) {\n                            // Defensive programming.\n                            //Log.e(LOG_TAG, e.toString());\n                            continue;\n                        } finally {\n                            // Move the offset to read the next uuid.\n                            offset += 15;\n                            len -= 16;\n                        }\n                    }\n                    break;\n                default:\n                    offset += (len - 1);\n                    break;\n            }\n        }\n        return uuids;\n    }\n}\n```"]