- en: Chapter 8. Apps for TVs, Cars, and Wearables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most exciting new directions that Android has gone in recently, is
    the extension of the platform from phones and tablets to televisions, car dashboards
    and wearables such as watches. These new devices allow us to provide added functionality
    to our existing apps, as well as creating wholly original apps designed specifically
    for these new environments.
  prefs: []
  type: TYPE_NORMAL
- en: We have already acquired the skills needed to develop such apps and this chapter
    is really more concerned with explaining the idiosyncrasies of each platform and
    the guidelines Google is keen for us to follow. This is particularly vital when
    it comes to developing apps that people will use when driving, as safety has to
    be of prime importance. There are also certain technical issues that need to be
    addressed when developing wearable apps, such as the pairing of the device with
    a handset and the entirely different UI and methods of use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create wearable AVDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect a wearable emulator to a handset with adb commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect a wearable emulator to a handset emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a project with both mobile and wearable modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Wearable UI Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create shape-aware layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and customize cards for wearables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand wearable design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access wearable sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an app available for Google TV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include Leanback support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand Android Auto safety guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure an Auto project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Google simulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send SMS messages using the Android Device Monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Wear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating or adapting apps for wearables is probably the most complicated of
    the three form factors dealt with in this chapter and requires a little more setting
    up than the other projects. However, wearables often give us access to one of
    the more fun new sensors, the heart rate monitor. In seeing how this works, we
    also get to see, how to manage sensors in general.
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry if you do not have access to an Android wearable device, as we
    will be constructing AVDs. You will ideally have an actual Android 5 handset,
    if you wish to pair it with the AVD. If you do not, it is still possible to work
    with two emulators but it is a little more complex to set up. Bearing this in
    mind, we can now prepare our first wearable app.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing and connecting to a wearable AVD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is perfectly possible to develop and test wearable apps on the emulator alone,
    but if we want to test all wearable features, we will need to pair it with a phone
    or a tablet. The next exercise assumes that you have an actual device. If you
    do not, still complete tasks 1 through 4 and we will cover how the rest can be
    achieved with an emulator a little later on.
  prefs: []
  type: TYPE_NORMAL
- en: Open Android Studio. You do not need to start a project at this point.![Constructing
    and connecting to a wearable AVD](img/B04321_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the SDK Manager and ensure you have the relevant packages installed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the AVD Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two new Android Wear AVDs, one round and one square, like so:![Constructing
    and connecting to a wearable AVD](img/B04321_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure USB Debugging is selected on your handset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the Android Wear app from the Play Store at this URL: [https://play.google.com/store/apps/details?id=com.google.android.wearable.app](https://play.google.com/store/apps/details?id=com.google.android.wearable.app).
    Connect it to your computer and start one of the AVDs we just created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and open the folder containing the `adb.exe` file. It will probably be
    something like `user\AppData\Local\Android\sdk\platform-tools\`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using *Shift* + right-click, select **Open command window here**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the command window, issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`adb -d forward tcp:5601 tcp:5601`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch the companion app and follow the instructions to pair the two devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Being able to connect a real-world device to an AVD is a great way to develop
    form factors without having to own the devices. The wearable companion app simplifies
    the process of connecting the two. If you have had the emulator running for any
    length of time, you will have noticed that many actions, such as notifications,
    are sent to the wearable automatically. This means that very often our apps will
    link seamlessly with a wearable device, without us having to include code to pre-empt
    this.
  prefs: []
  type: TYPE_NORMAL
- en: The `adb.exe` (**Android Debug Bridge**) is a vital part of our development
    toolkit. Most of the time, the Android Studio manages it for us. However, it is
    useful to know that it is there and a little about how to interact with it. We
    used it here to manually open a port between our wearable AVD and our handset.
  prefs: []
  type: TYPE_NORMAL
- en: There are many `adb` commands that can be issued from the command prompt and
    perhaps the most useful is `adb devices`, which lists all currently debuggable
    devices and emulators, and is very handy when things are not working, to see if
    an emulator needs restarting. Switching the ADB off and on can be achieved using
    `adb kill-server` and `adb start-server` respectively. Using `adb help` will list
    all available commands.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The port forwarding command we used in step 10, needs to be issued every time
    the phone is disconnected from the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Without writing any code as such, we have already seen some of the features
    that are built into an Android Wear device and the way that the Wear UI differs
    from most other Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you usually develop with the latest Android hardware, it is often still
    a good idea to use an emulator, especially for testing the latest SDK updates
    and pre-releases. If you do not have a real device, then the next, small section
    will show you how to connect your wearable AVD to a handset AVD.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a wearable AVD with another emulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pairing two emulators is very similar to pairing with a real device. The main
    difference is the way we install the companion app without access to the Play
    Store. Follow these steps to see how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Start up, an AVD. This will need to be targeting Google APIs as seen here:![Connecting
    a wearable AVD with another emulator](img/B04321_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `com.google.android.wearable.app-2.apk`. There are many places
    online where it can be found with a simple search, I used [www.file-upload.net/download](http://www.file-upload.net/download).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the file in your `sdk/platform-tools` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Shift* + right-click in this folder and select **Open command window here**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start your wearable AVD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `adb devices` into the command prompt, making sure that both emulators
    are visible with an output similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enter `adb telnet localhost 5554` at the command prompt, where `5554` is the
    phone emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, enter `adb redir add tcp:5601:5601`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now use the Wear app on the handheld AVD to connect to the watch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we've just seen, setting up a Wear project takes a little longer than some
    of the other exercises we have performed. Once set up though, the process is very
    similar to that of developing for other form factors, and something we can now
    get on with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a wearable project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the apps that we have developed so far, have required just a single module,
    and this makes sense as we have only been building for single devices. In this
    next step, we will be developing across two devices and so will need two modules.
    This is very simple to do, as you will see in these next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project in the Android Studio and call it something like `Wearable
    App`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Target Android Devices** screen, select both **Phone and Tablet** and
    **Wear**, like so:![Creating a wearable project](img/B04321_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be asked to add two Activities. Select **Blank Activity** for the Mobile
    Activity and **Blank Wear Activity** for Wear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everything else can be left as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app on both round and square virtual devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing you will have noticed is the two modules, mobile and wear. The
    first is the same as we have seen many times, but there are a few subtle differences
    with the wear module and it is worth taking a little look at. The most important
    difference is the `WatchViewStub` class. The way it is used can be seen in the
    `activity_main.xml` and `MainActivity.java` files of the wear module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This frame layout extension is designed specifically for wearables and detects
    the shape of the device, so that the appropriate layout is inflated. Utilizing
    the `WatchViewStub` is not quite as straightforward, as one might imagine, as
    the appropriate layout is only inflated after the `WatchViewStub` has done its
    thing. This means that, to access any views within the layout, we need to employ
    a special listener that is called once the layout has been inflated. How this
    `OnLayoutInflatedListener()` works can be seen by opening the `MainActivity.java`
    file in the wear module and examining the `onCreate()` method, which will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Other than the way that wearable apps and devices are set up for developing,
    the other significant difference is the UI. The widgets and layouts that we use
    for phones and tablets are not suitable, in most cases, for the diminished size
    of a watch screen. Android provides a whole new set of UI components, that we
    can use and this is what we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a UI for wearables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as having to consider the small size of wearable when designing layouts,
    we also have the issue of shape. Designing for a round screen brings its own challenges,
    but fortunately the **Wearable UI Library** makes this very simple. As well as
    the `WatchViewStub`, that we encountered in the previous section that inflates
    the correct layout, there is also a way to design a single layout that inflates
    in such a way, that it is suitable for both square and round screens.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The project setup wizard included this library for us automatically in the
    `build.gradle (Module: wear)` file as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps demonstrate how to create a shape-aware layout with a `BoxInsetLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project we created in the last section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will need three images that must be placed in the `drawable` folder of
    the wear module: one called `background_image` of around 320 x 320 px and two
    of around 50 x 50 px, called `right_icon` and `left_icon`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file in the wear module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace its content with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `BoxInsetLayout`, add the following `FrameLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this, add these three views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `MainActivity.java` file in the wear module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `onCreate()` method, delete all lines after the line `setContentView(R.layout.activity_main);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run the app on both square and round emulators.![Designing the layout](img/B04321_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, the `BoxInsetLayout` does a fine job of inflating our layout
    regardless of screen shape. How it works is very simple. The `BoxInsetLayout`
    creates a square region, that is as large as can fit inside the circle of a round
    screen. This is set with the `app:layout_box="all"` instruction, which can also
    be used for positioning components, as we will see in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: We have also set the padding of the `BoxInsetLayout` to 15 dp and that of the
    `FrameLayout` to 5 dp. This has the effect of a margin of 5 dp on round screens
    and 15 dp on square ones.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you use the `WatchViewStub` and create separate layouts for each screen
    shape or `BoxInsetLayout` and just one layout file depends entirely on your preference
    and the purpose and design of your app. Whichever method you choose, you will
    no doubt want to add Material Design elements to your wearable app, the most common
    and versatile of these being the card. In the following section, we will explore
    the two ways that we can do this, the `CardScrollView` and the `CardFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding cards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `CardFragment` class provides a default card view, providing two text views
    and an image. It is beautifully simple to set up, has all the Material Design
    features such as rounded corners and a shadow, and is suitable for nearly all
    purposes. It can be customized, as we will see, although the `CardScrollView`
    is often a better option. First, let us see, how to implement a default card for
    wearables:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file in the wear module of the current project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete or comment out the the text view and two image views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainActivity.java` file in the wear module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onCreate()` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app on one or other of the wearable emulators to see how the default
    card looks.![Adding cards](img/B04321_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We met the `FragmentManager` in [Chapter 6](ch06.html "Chapter 6. Notifications
    and the Action Bar"), *Notifications and the Action Bar* and here it operates
    in a very similar fashion and requires little explanation. The way we created
    the `CardFragment` itself, is also very straightforward. We used two string parameters
    here, but there is a third, drawable parameter and if the line is changed to `CardFragment
    cardFragment = CardFragment.create("TITLE", "with description and drawable", R.drawable.left_icon);`
    then we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding cards](img/B04321_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This default implementation for cards on wearable is fine for most purposes
    and it can be customized by overriding its `onCreateContentView()` method. However,
    the `CardScrollView` is a very handy alternative, and this is what we will look
    at next.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing cards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `CardScrollView` is defined from within our layout and furthermore it detects
    screen shape and adjusts the margins to suit each shape. To see how this is done,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file in the wear module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete or comment out every element, except the root `BoxInsetLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the following `CardScrollView` inside the `BoxInsetLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this, add this `CardFrame`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `CardFrame`, add a `LinearLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some views to this, so that the preview resembles the layout here:![Customizing
    cards](img/B04321_08_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code we added to the `onCreate()` method with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now test the app on an emulator, which will produce the following result:![Customizing
    cards](img/B04321_08_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As can be seen in the previous image, the Android Studio has preview screens
    for both wearable shapes. Like some other previews, these are not always what
    you will see on a device, but they allow us to put layouts together very quickly,
    by dragging and dropping widgets.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `CardScrollView` and `CardFrame` are even easier to implement
    than the `CardFragment` and also far more flexible, as we can design almost any
    layout we can imagine. We assigned `app:layout_box` here again, only this time
    using `bottom`, causing the card to be placed as low on the screen as possible.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important, when designing for such small screens, to keep our layouts
    as clean and simple as possible. Google's design principles state that wearable
    apps should be glanceable. This means that, as with a traditional wrist watch,
    the user should be able to glance at our app and immediately take in the information
    and return to what they were doing.
  prefs: []
  type: TYPE_NORMAL
- en: Another of Google's design principle—*Zero to low interaction*—is only a single
    tap or swipe a user needs to do to interact with our app. With these principles
    in mind, let us create a small app, with some actual functionality. In the next
    section, we will take advantage of the new heart rate sensor found in many wearable
    devices and display current beats-per-minute on the display.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing sensor data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The location of an Android Wear device on the user''s wrist, makes it the perfect
    piece of hardware for fitness apps, and not surprisingly, these apps are immensely
    popular. As with most features of the SDK, accessing sensors is pleasantly simple,
    using classes such as managers and listeners and requiring only a few lines of
    code, as you will see by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project we have been working on in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the background image with one that might be suitable for a fitness app.
    I have used a simple image of a heart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete everything, except the root `BoxInsetLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place this `TextView` inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the Manifest file in the wear module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following permission inside the root manifest node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `MainActivity.java` file in the wear module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a `SensorEventListener` on the Activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the two methods required by the listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `onCreate()` method, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this `onResume()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And this `onPause()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `onSensorChanged()` callback, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you do not have access to a real device, you can download a sensor simulator
    from here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://code.google.com/p/openintents/wiki/SensorSimulator](https://code.google.com/p/openintents/wiki/SensorSimulator)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The app is now ready to test.![Accessing sensor data](img/B04321_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We began by adding a permission in the `AndroidManifest.xml` file in the appropriate
    module; this is something we have done before and need to do any time we are using
    features, that require the user's permission before installing.
  prefs: []
  type: TYPE_NORMAL
- en: The inclusion of a background image may seem necessary, but an appropriate background
    is a real aid to glancability as the user can tell instantly which app they are
    looking at.
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear, from the way the `SensorManager` and the `Sensor` are set
    up in the `onCreate()` method, that all sensors are accessed in the same way and
    different sensors can be accessed with different constants. We used `TYPE_HEART_RATE`
    here, but any other sensor can be started with the appropriate constant, and all
    sensors can be managed with the same basic structures as we found here, the only
    real difference being the way each sensor returns `SensorEvent.values[]`. A comprehensive
    list of all sensors, and descriptions of the values they produce can be found
    at [http://developer.android.com/reference/android/hardware/Sensor.html](http://developer.android.com/reference/android/hardware/Sensor.html).
  prefs: []
  type: TYPE_NORMAL
- en: As with any time our apps utilize functions that run in the background, it is
    vital that we unregister our listeners, whenever they are no longer needed, in
    our Activity's `onPause()` method. We didn't use the `onAccuracyChanged()` callback
    here, but its purpose should be clear and there are many possible apps where its
    use is essential.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our exploration of wearable apps and how they are put together.
    Such devices continue to become more prevalent and the possibility of ever more
    imaginative uses is endless. Providing we consider why and how people use smart
    watches, and the like, and develop to take advantage of the location of these
    devices by programming glanceable interfaces that require the minimum of interactivity,
    Android Wear seems certain to grow in popularity and use, and the developers will
    continue to produce ever more innovative apps.
  prefs: []
  type: TYPE_NORMAL
- en: Android TV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the opposite end of the size spectrum to Android Wear, is Android TV. Like
    Wear, the size of this form factor is all important, when it comes to how we design
    apps for it. The main consideration is the distance the user is from the screen,
    which is usually around 10 feet. This means designing simple and clean layouts
    and avoiding small and/or lengthy text.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Wear, many of the apps we design for phones and tablets can be made available
    for TVs as well. As one would imagine, this requires some fiddling around with
    the manifest, so as to make our apps visible to users searching for TV-specific
    apps in the Google Play store. Also, TVs do not have many of the functions that
    our phones do, such as GPS and touchscreens, and we need to take this into consideration
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The TV app template generated by the project wizard in Android Studio has bugs,
    and unless Google have fixed it by the time you read this, it is far from straightforward
    to use it to generate a working app. It is still worth taking a look though, as
    the Java directory contains over a dozen purpose-built classes that are very handy
    for apps designed for streaming and broadcasting television shows and the like.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the template does not work, is actually a good thing in our case,
    as we can use this section to see how to build a TV-compatible app from scratch
    or, if you prefer, how to convert an already developed app so that it is available
    to install on an Android TV.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise can be carried out using a blank activity template for
    a phone and a tablet or any app you have developed.
  prefs: []
  type: TYPE_NORMAL
- en: Open your project's manifest file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the root manifest node, add these permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same node, add these feature uses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find or create a 320 x 180 px `xhdpi` banner image to represent your app. Ideally,
    it should contain text as well as an identifiable image, such as the following:![Android
    TV](img/B04321_08_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the image in your `drawable` folder, and call it `banner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line inside the application node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open your `build.gradle` file and add this dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the manifest, change the theme declaration line to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a TV AVD and test the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although, we have not had to do very much here, there is still quite a lot to
    explain. Most of what we have done, is to make sure that our app is visible when
    browsing the Play store for TV apps. TVs do not support portrait screen layouts,
    so if this feature is required, it will simply not appear in the Play store as
    available for TV. We want to include the feature for devices that do support this
    orientation, and this is how we do that and still make our app available to TV
    users. We have to include the permission to record audio with all TV apps, but
    TVs do not generally support microphones.
  prefs: []
  type: TYPE_NORMAL
- en: The **Leanback Support Library** that we added in step 7 is a very useful tool
    for developing for TV. It provides a very suitable theme, `Theme.Leanback`, several
    useful widgets designed for TV, and it manages margins in such a way that our
    layout is not clipped. Without it, we would have to set wide margins of about
    10 percent to avoid this kind of TV over-scanning. If we wanted to write specifically
    for TV, we would also have changed the category inside our main activity's intent
    filter to `<category android:name="android.intent.category.LEANBACK_LAUNCHER"
    />`.
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a lot more to programming for Android TV, especially when it
    comes to broadcasting and streaming, that we cannot cover here. Generally speaking
    though, developing TV apps requires the same skills as programming for handheld
    devices and many apps run perfectly well on both formats. Providing we take into
    account the distance the user is from the screen and the limited input methods,
    we can write programs that provide a satisfying experience across all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The Android OS is a very flexible system and well suited to a wide variety of
    form factors. We've seen how it can run on screens as small as an inch and a half
    or as large as a home cinema. Android Lollipop heralded yet another new and exciting
    platform, allowing users to run Android apps when they are out in their cars.
  prefs: []
  type: TYPE_NORMAL
- en: Android Auto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android Auto apps are apps that, when connected to a compatible car dashboard,
    run certain restricted content on the driver''s dashboard. When developing for
    cars, the primary concern has to be safety and no Auto app that does not meet
    these strict standard will not be published on the Play store. Many Android apps
    are far too distracting to be suitable for use when driving. In fact, Android
    Auto really only supports two functions: audio playback and text-to-speech messaging.
    It is beyond the scope of this book to explore this comprehensively, but this
    is certainly a good time to see how such apps are set up and how to use the media
    and messaging simulators provided in the SDK. First though, we need to take a
    look at the safety rules insisted on by Google for Auto apps:'
  prefs: []
  type: TYPE_NORMAL
- en: There must be no animated elements on the Auto screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only audio ads are allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps must support voice control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All buttons and clickable controls must respond within two seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text must be longer than 120 characters and must always be in the default Roboto
    font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Icons must be white, so that the system can control contrast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps must support day and night mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App must support voice commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App-specific buttons must respond to user actions with no more than a two-second
    delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IMPORTANT: These, and several other stipulations, will be tested by Google
    before publication, so it is essential that you run all of these tests yourself.
    The full list can be found at [http://developer.android.com/distribute/essentials/quality/auto.html](http://developer.android.com/distribute/essentials/quality/auto.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Designing apps that are suitable for day and night modes and that can have contrast
    controlled by the system to automatically remain readable in different light conditions,
    is quite a detailed subject and Google has produced a very useful guide to this,
    which can be found at [http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf](http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the restrictions we have covered Auto apps are developed in the same
    way as any other. There is one minor difference though, when developing for Auto,
    we need to define which in-car capabilities our app is using. This is done using
    an XML file. Follow these short steps, to see how:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Android Studio project for phone and tablet, or open an existing
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Android resource directory** inside the `res` directory and call
    it `xml`.![Android Auto](img/B04321_08_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this `xml` folder, create a new Android resource file and call it something
    like `auto_config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the manifest file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add these lines inside the `application` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it, our app will now detect whether its host device is connected to a
    car dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are just two things here that need to be pointed out here. The two named
    uses are for running audio playback apps and receiving messages respectively.
    We would only need both, if our app was designed for both functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google provide simulators for testing both media browsing and messaging apps,
    letting us test projects from the safety of a desk. The following steps demonstrate
    how to install them and use a telnet connection to send dummy SMS messages:'
  prefs: []
  type: TYPE_NORMAL
- en: From Android studio, open the SDK Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you have the latest versions of the Android Auto API Simulators, which
    are in the `Extras` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a device or an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to your `sdk/extras/google/simulators` folder and open the command window
    there, with *Shift* + right-click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that your device is connected with `adb devices`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter these two commands to install both simulators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using a third party virtual device, such as Genymotion, you will
    be able to install these apps by dragging and dropping them onto the emulator's
    screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing the simulators with an `adb` command is very simple, and of course
    any .`apk` file can be installed this way to a connected device. The media browser
    simulator can be tested with most media services such as Play Music.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Auto](img/B04321_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Text can be sent to the messaging simulator by launching the **Android Device
    Monitor** from the **Emulator Control** tab.
  prefs: []
  type: TYPE_NORMAL
- en: That's about as much as we can cover of Android Auto here. The platform provides
    some of the most exciting new possibilities offered by Lollipop, and no doubt
    Android will be found in more and more vehicles in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Wear, TV, and Auto represent radical departures from traditional form
    factors and are equally different from each other. This means that we have had
    to cover a lot of varied ground here.
  prefs: []
  type: TYPE_NORMAL
- en: Despite their diminutive size and functionality, wearables offer us an enormous
    range of possibilities. We know now how to create and connect wearable AVDs and
    how to develop easily for both square and round devices. We then went on to see
    what is required to set up a TV app, how to convert existing apps to be available
    on TV and about the useful library and features provided by Leanback support.
    We concluded by exploring the stringent safety rules that must be applied when
    developing and the tools available for testing Auto on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest overhauls, although perhaps less visible to the user, involves
    the camera APIs. These are entirely new to Lollipop and these along with adding
    multimedia to our apps is what we will move on to in the next chapter.
  prefs: []
  type: TYPE_NORMAL
