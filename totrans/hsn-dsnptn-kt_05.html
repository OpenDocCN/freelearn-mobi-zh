<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Functional Programming</h1>
                
            
            
                
<p class="calibre2">In this chapter, we're going to discuss basic principles of functional programming, and how they fit into the Kotlin programming language. We won't introduce much new syntax, as you'll soon see. It would have been hard to discuss benefits of the language in the previous chapters without touching on concepts such as <em class="calibre14">data immutability</em> and <em class="calibre14">functions as first-class values</em>. But, as we did before, we'll look at those features from a different angle: not how to use them to implement well-known design patterns in a better way, but their purpose.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Why functional programming?</li>
<li class="calibre12">Immutability</li>
<li class="calibre12">Functions as values</li>
<li class="calibre12">Expressions, not statements</li>
<li class="calibre12">Recursion</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Why functional programming?</h1>
                
            
            
                
<p class="calibre2">Functional programming has been around for almost as long as other programming paradigms, such as procedural and object-oriented programming, if not longer. But in the past 10 years, it has gained major momentum. The reason for that is because something else stalled: CPU speeds. We cannot speed up our CPUs as much as we did in the past, so we must parallelize our programs. And it turns out that the functional programming paradigm is exceptional at running parallel tasks.</p>
<p class="calibre2">The evolution of multicore processors is a very interesting topic by itself, but we'll be able to cover it only briefly. Workstations had multiple processors since the 1980s at least, to support running tasks from different users in parallel. Since workstations were huge anyway, they didn't need to worry about cramming everything into one chip. But with multiprocessors coming to the consumer market around 2005, it was necessary to have one physical unit that could do work in parallel. That's the reason we have multiple cores on one chip in our PC or laptop.</p>
<p class="calibre2">But that's not the only reason some swear by functional programming. Here are a few more:</p>
<ul class="calibre11">
<li class="calibre12">Functional programming favors pure functions, and pure functions are usually easier to reason about and to test</li>
<li class="calibre12">Code written in a functional way is often more declarative than imperative, dealing with the <em class="calibre25">what</em> and not the <em class="calibre25">how</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Immutability</h1>
                
            
            
                
<p class="calibre2">One of the key concepts of functional programming is immutability. It means that from the moment the function receives input to the moment the function returns output, the object doesn't change. How could it change, you wonder? Let's see a simple example:</p>
<pre class="calibre18">fun &lt;T&gt; printAndClear(list: MutableList&lt;T&gt;) {<br class="title-page-name"/>    for (e in list) {<br class="title-page-name"/>        println(e)<br class="title-page-name"/>        list.remove(e)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>printAndClear(mutableListOf("a", "b", "c"))</pre>
<p class="calibre2">The output would be first <kbd class="calibre13">"a"</kbd>, then we'll receive <kbd class="calibre13">ConcurrentModificationException</kbd>.</p>
<p class="calibre2">Wouldn't it be great if we could protect ourselves from such runtime exceptions in the first place? </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tuples</h1>
                
            
            
                
<p class="calibre2">In functional programming, a tuple is a piece of data that cannot be changed after it is created. One of the most basic tuples in Kotlin is Pair:</p>
<pre class="calibre18">val pair = "a" to 1</pre>
<p class="calibre2">Pair contains two properties, first and second, and is immutable:</p>
<pre class="calibre18">pair.first = "b" // Doesn't work<br class="title-page-name"/>pair.second = 2  // Still doesn't</pre>
<p class="calibre2">We can destructure a Pair into two separate values:</p>
<pre class="calibre18">val (key, value) = pair<br class="title-page-name"/>println("$key =&gt; $value")</pre>
<p class="calibre2">When iterating over a map, we receive another tuple, <kbd class="calibre13">Map.Entry</kbd>:</p>
<pre class="calibre18">for (p in mapOf(1 to "Sunday", 2 to "Monday")) {<br class="title-page-name"/>   println("${p.key} ${p.value}")<br class="title-page-name"/>}</pre>
<p class="calibre2">In general, <em class="calibre14">data classes</em> are usually a good implementation for tuples. But, as we'll see in the <em class="calibre14">Value Mutation</em> section, not every data class is a proper tuple.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Value mutation</h1>
                
            
            
                
<p class="calibre2">In Maronic, we would like to count the average score over one thousand games. For that, we have the following data class:</p>
<pre class="calibre18">data class AverageScore(var totalScore: Int = 0,<br class="title-page-name"/>                        var gamesPlayed: Int = 0) {<br class="title-page-name"/>    val average: Int<br class="title-page-name"/>        get() = if (gamesPlayed &lt;= 0)<br class="title-page-name"/>                    0<br class="title-page-name"/>                else<br class="title-page-name"/>                    totalScore / gamesPlayed<br class="title-page-name"/>}</pre>
<p class="calibre2">We were smart: we protected ourselves from any invalid output by checking for divisions by zero.</p>
<p class="calibre2">But what will happen when we write the following code?</p>
<pre class="calibre18">val counter = AverageScore()<br class="title-page-name"/><br class="title-page-name"/>thread(isDaemon = true) {<br class="title-page-name"/>    while(true) counter.gamesPlayed = 0<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>for (i in 1..1_000) {<br class="title-page-name"/>    counter.totalScore += Random().nextInt(100)<br class="title-page-name"/>    counter.gamesPlayed++<br class="title-page-name"/><br class="title-page-name"/>    println(counter.average)<br class="title-page-name"/>}</pre>
<p class="calibre2">Soon enough, you'll receive <kbd class="calibre13">ArithmeticException</kbd> anyway. Our counter somehow becomes zero.</p>
<p class="calibre2">If you want your data classes to be immutable, be sure to specify all their properties as <kbd class="calibre13">val</kbd> (values), and not <kbd class="calibre13">var</kbd> (variables).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Immutable collections</h1>
                
            
            
                
<p class="calibre2">I think that our junior developer learned their lesson. Instead, they produced this code, which is not very efficient, but which gets rid of those variables:</p>
<pre class="calibre18">data class ScoreCollector(val scores: MutableList&lt;Int&gt; = mutableListOf())<br class="title-page-name"/><br class="title-page-name"/>val counter = ScoreCollector()<br class="title-page-name"/><br class="title-page-name"/>for (i in 1..1_000) {<br class="title-page-name"/>    counter.scores += Random().nextInt(100)<br class="title-page-name"/><br class="title-page-name"/>    println(counter.scores.sumBy { it } / counter.scores.size)<br class="title-page-name"/>}</pre>
<p class="calibre2">But the maleficent thread strikes again:</p>
<pre class="calibre18">thread(isDaemon= true, name="Maleficent") {<br class="title-page-name"/>    while(true) counter.scores.clear()<br class="title-page-name"/>}</pre>
<p class="calibre2">We again receive <kbd class="calibre13">ArithmeticException</kbd>.</p>
<p class="calibre2">It's not enough that your data class contains only values. If its value is a collection, it must be immutable in order for the data class to be considered immutable. The same rule is applied to classes contained within other data classes:</p>
<pre class="calibre18">data class ImmutableScoreCollector(val scores: List&lt;Int&gt;)</pre>
<p class="calibre2">Now the maleficent thread cannot even call <kbd class="calibre13">clear()</kbd> on this collection. But how should we add scores to it?</p>
<p class="calibre2">One option is to pass the entire list in the constructor:</p>
<pre class="calibre18">val counter = ImmutableScoreCollector(List(1_000) {<br class="title-page-name"/>    Random().nextInt(100)<br class="title-page-name"/>})</pre>
<p class="calibre2"> </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Functions as values</h1>
                
            
            
                
<p class="calibre2">We already covered some of the functional capabilities of Kotlin in the chapters dedicated to Design Patterns. The <strong class="calibre5">Strategy</strong> and <strong class="calibre5">Command</strong> design patterns are but a few that heavily rely on the ability to accept functions as arguments, return functions, store them as values, or put them inside collections. In this section, we'll cover some other aspects of functional programming in Kotlin, such as function purity and currying.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Higher-order functions</h1>
                
            
            
                
<p class="calibre2">As we discussed previously, in Kotlin, it's possible for a function to return another function:</p>
<pre class="calibre18">fun generateMultiply(): <strong class="calibre1">(</strong><strong class="calibre1">Int, Int) -&gt; Int</strong> {<br class="title-page-name"/>    return { x: Int, y: Int -&gt; x * y}<br class="title-page-name"/>}</pre>
<p class="calibre2">Functions can also be assigned to a variable or value to be invoked later on:</p>
<pre class="calibre18">val multiplyFunction = generateMultiply()<br class="title-page-name"/>...<br class="title-page-name"/>println(multiplyFunction(3, 4))</pre>
<p class="calibre2">The function assigned to a variable is usually called a <em class="calibre14">literal function</em>. It's also possible to specify a function as a parameter:</p>
<pre class="calibre18">fun mathInvoker(x: Int, y: Int, <strong class="calibre1">mathFunction: (Int, Int) -&gt; Int</strong>) {<br class="title-page-name"/>    println(mathFunction(x, y))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>mathInvoker(5, 6, multiplyFunction)</pre>
<p class="calibre2">If a function is the last parameter, it can also be supplied ad hoc, outside of the brackets:</p>
<pre class="calibre18">mathInvoker(7, 8) { x, y -&gt;<br class="title-page-name"/>   x * y<br class="title-page-name"/>}</pre>
<p class="calibre2">In general, a function without a name is called an <em class="calibre14">anonymous</em> function. If a function without a name uses short syntax, it's called a lambda:</p>
<pre class="calibre18">val squareAnonymous = fun(x: Int) = x * x<br class="title-page-name"/>val squareLambda = {x: Int -&gt; x * x} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pure functions</h1>
                
            
            
                
<p class="calibre2">A pure function is a function without any side effects. Take the following function, for example:</p>
<pre class="calibre18">fun sayHello() {<br class="title-page-name"/>    println("Hello")<br class="title-page-name"/>}</pre>
<p class="calibre2">How do you test to see whether <kbd class="calibre13">"Hello"</kbd> is indeed printed? The task is not as simple as it seems, as we'll need some means to capture the standard output, the same console where we usually see stuff printed. </p>
<p class="calibre2">Compare it to the following function:</p>
<pre class="calibre18">fun hello() = "Hello"</pre>
<p class="calibre2">The following function doesn't have any side effects. That makes it a lot easier to test:</p>
<pre class="calibre18">fun testHello(): Boolean {<br class="title-page-name"/>    return "Hello" == hello()<br class="title-page-name"/>}</pre>
<p class="calibre2">Does the <kbd class="calibre13">hello()</kbd> function look a bit meaningless to your eyes? That's actually one of the properties of pure functions. Their invocation could be replaced by their result (if we knew all their results, that is). This is often called <em class="calibre14">referential transparency</em>.</p>
<p class="calibre2">Not every function written in Kotlin is pure:</p>
<pre class="calibre18">fun &lt;T&gt; removeFirst(list: MutableList&lt;T&gt;): T {<br class="title-page-name"/>    return list.removeAt(0)<br class="title-page-name"/>}</pre>
<p class="calibre2">If we call the function twice on the same list, it will return different results:</p>
<pre class="calibre18">val list = mutableListOf(1, 2, 3)<br class="title-page-name"/><br class="title-page-name"/>println(removeFirst(list)) // Prints 1<br class="title-page-name"/>println(removeFirst(list)) // Prints 2</pre>
<p class="calibre2">Try this one:</p>
<pre class="calibre18">fun &lt;T&gt; withoutFirst(list: List&lt;T&gt;): T {<br class="title-page-name"/>    return ArrayList(list).removeAt(0)<br class="title-page-name"/>}</pre>
<p class="calibre2">Now our function is totally predictable, no matter how many times we invoke it:</p>
<pre class="calibre18">val list = mutableListOf(1, 2, 3)<br class="title-page-name"/><br class="title-page-name"/>println(withoutFirst(list)) // It's 1<br class="title-page-name"/>println(withoutFirst(list)) // Still 1</pre>
<p class="calibre2">As you can see, we used an immutable interface this time, <kbd class="calibre13">List&lt;T&gt;</kbd>, which helps us by preventing even the possibility of mutating our input. Together with immutable values from the previous section, pure functions provide a very strong tool that allows easier testing by providing predictable results and parallelization of our algorithms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Currying</h1>
                
            
            
                
<p class="calibre2">Currying is a way to translate a function that takes a number of arguments into a chain of functions that each take a single argument. This may sound confusing, so let's look at a simple example:</p>
<pre class="calibre18">fun subtract(x: Int, y: Int): Int {<br class="title-page-name"/>    return x - y<br class="title-page-name"/>}<br class="title-page-name"/>println(subtract(50, 8))</pre>
<p class="calibre2">This is a function that returns two arguments. The result is quite obvious. But maybe we would like to invoke this function with the following syntax instead:</p>
<pre class="calibre18">subtract(50)(8)</pre>
<p class="calibre2">We've already seen how we can return a function from another function:</p>
<pre class="calibre18">fun subtract(x: Int): (Int) -&gt; Int {<br class="title-page-name"/>    return fun(y: Int): Int {<br class="title-page-name"/>        return x - y<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here it is in the shorter form:</p>
<pre class="calibre18">fun subtract(x: Int) = fun(y: Int): Int {<br class="title-page-name"/>    return x + y<br class="title-page-name"/>}</pre>
<p class="calibre2">And here it is in an even shorter form:</p>
<pre class="calibre18">fun subtract(x: Int) = {y: Int -&gt; x - y}</pre>
<p class="calibre2">Although not very useful by itself, it's still an interesting concept to grasp. And if you're a JavaScript developer looking for a new job, make sure you understand it really well, since it's being asked about in nearly every interview.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Memoization</h1>
                
            
            
                
<p class="calibre2">If our function always returns the same output for the same input, we could easily map between previous input and output, and use it as a cache. That technique is called <em class="calibre14">memoization</em>:</p>
<pre class="calibre18">class Summarizer {<br class="title-page-name"/>    private val resultsCache = mutableMapOf&lt;List&lt;Int&gt;, Double&gt;()<br class="title-page-name"/><br class="title-page-name"/>    fun summarize(numbers: List&lt;Int&gt;): Double {<br class="title-page-name"/>        return resultsCache.computeIfAbsent(numbers, ::sum)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    private fun sum(numbers: List&lt;Int&gt;): Double {<br class="title-page-name"/>        return numbers.sumByDouble { it.toDouble() }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We use a method reference operator, <kbd class="calibre13">::</kbd>, to tell <kbd class="calibre13">computeIfAbsent</kbd> to use the <kbd class="calibre13">sum()</kbd> method in the event that input wasn't cached yet. </p>
<p class="calibre2">Note that <kbd class="calibre13">sum()</kbd> is a pure function, while <kbd class="calibre13">summarize()</kbd> is not. The latter will behave differently for the same input. But that's exactly what we want in this case:</p>
<pre class="calibre18">val l1 = listOf(1, 2, 3)<br class="title-page-name"/>val l2 = listOf(1, 2, 3)<br class="title-page-name"/>val l3 = listOf(1, 2, 3, 4)<br class="title-page-name"/><br class="title-page-name"/>val summarizer = Summarizer()<br class="title-page-name"/><br class="title-page-name"/>println(summarizer.summarize(l1)) // Computes, new input<br class="title-page-name"/>println(summarizer.summarize(l1)) // Object is the same, no compute<br class="title-page-name"/>println(summarizer.summarize(l2)) // Value is the same, no compute<br class="title-page-name"/>println(summarizer.summarize(l3)) // Computes</pre>
<p class="calibre2">The combination of immutable objects, pure functions, and plain old classes provides us with a powerful tool for performance optimizations. Just remember, nothing is free. We only trade one resource, CPU time, for another resource, memory. And it's up to you to decide which resource is more expensive for you in each case.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Expressions, not statements</h1>
                
            
            
                
<p class="calibre2">A statement is a block of code that doesn't return anything. An expression, on the other hand, returns a new value. Since statements produce no results, the only way for them to be useful is to mutate state. And functional programming tries to avoid mutating the state as much as possible. Theoretically, the more we rely on expressions, the more our functions will be pure, with all the benefits of functional purity.</p>
<p class="calibre2">We've used the <kbd class="calibre13">if</kbd> expression many times already, so one of its benefits should be clear: it's less verbose and, for that reason, less error-prone than the <kbd class="calibre13">if</kbd> statement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pattern matching</h1>
                
            
            
                
<p class="calibre2">The concept of pattern matching is like <kbd class="calibre13">switch/case</kbd> on steroids for someone who comes from Java. We've already seen how <kbd class="calibre13">when</kbd> expression can be used, in <a href="part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 1</a>, <em class="calibre14">Getting Started with Kotlin</em>, so let's briefly discuss why this concept is important for the functional paradigm.</p>
<p class="calibre2">As you may know, <kbd class="calibre13">switch</kbd> in Java accepts only some primitive types, strings, or enums.</p>
<p class="calibre2">Consider the following code in Java:</p>
<pre class="calibre18">class Cat implements Animal {<br class="title-page-name"/>    public String purr() {<br class="title-page-name"/>        return "Purr-purr";<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Dog implements Animal {<br class="title-page-name"/>    public String bark() {<br class="title-page-name"/>        return "Bark-bark";<br class="title-page-name"/>    }</pre>
<pre class="calibre18">}<br class="title-page-name"/><br class="title-page-name"/>interface Animal {}</pre>
<p class="calibre2">If we were to decide which of the functions to call, we would need something like this:</p>
<pre class="calibre18">public String getSound(Animal animal) {<br class="title-page-name"/>    String sound = null;<br class="title-page-name"/>    if (animal instanceof Cat) {<br class="title-page-name"/>        sound = ((Cat)animal).purr();<br class="title-page-name"/>    }<br class="title-page-name"/>    else if (animal instanceof Dog) {<br class="title-page-name"/>        sound = ((Dog)animal).bark();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    if (sound == null) {<br class="title-page-name"/>        throw new RuntimeException();<br class="title-page-name"/>    }<br class="title-page-name"/>    return sound;<br class="title-page-name"/>}</pre>
<p class="calibre2">This method could be shortened by introducing multiple returns, but in real projects, multiple returns are usually bad practice. </p>
<p class="calibre2">Since we don't have a <kbd class="calibre13">switch</kbd> statement for classes, we need to use an <kbd class="calibre13">if</kbd> statement instead. </p>
<p class="calibre2">Compare that with the following Kotlin code:</p>
<pre class="calibre18">fun getSound(animal: Animal) = when(animal) {<br class="title-page-name"/>    is Cat -&gt; animal.purr()<br class="title-page-name"/>    is Dog -&gt; animal.bark()<br class="title-page-name"/>    else -&gt; throw RuntimeException()<br class="title-page-name"/>}</pre>
<p class="calibre2">Since <kbd class="calibre13">when</kbd> is an expression, we avoided the intermediate variable altogether. But what's more, using pattern matching, we can also avoid most of the code that concerns type checks and casts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Recursion</h1>
                
            
            
                
<p class="calibre2">Recursion is a function invoking itself with new arguments:</p>
<pre class="calibre18">fun <strong class="calibre1">sumRec</strong>(i: Int, numbers: List&lt;Int&gt;): Long {<br class="title-page-name"/>    return if (i == numbers.size) {<br class="title-page-name"/>        0<br class="title-page-name"/>    } else {<br class="title-page-name"/>        numbers[i] + <strong class="calibre1">sumRec</strong>(i + 1, numbers)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We usually avoid recursion, due to <strong class="calibre5">Stack Overflow</strong> error that we may receive if our call stack is too deep. You can call this function with a list that contains a million numbers to experience it:</p>
<pre class="calibre18">val numbers = List(1_000_000) {it}<br class="title-page-name"/>println(sumRec(0,  numbers)) // Crashed pretty soon, around 7K </pre>
<p class="calibre2">One of the great benefits of tail recursion is that it avoids the dreaded stack overflow exception.</p>
<p class="calibre2">Let's rewrite our recursive function using a new keyword, <kbd class="calibre13">tailrec</kbd>, to avoid that problem:</p>
<pre class="calibre18"><strong class="calibre1">tailrec</strong> fun sumRec(i: Int, sum: Long, numbers: List&lt;Int&gt;): Long {<br class="title-page-name"/>    return if (i == numbers.size) {<br class="title-page-name"/>        return sum<br class="title-page-name"/>    } else {<br class="title-page-name"/>        sumRec(i+1, numbers[i] + sum, numbers)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now the compiler will optimize our call and avoid exception completely.</p>
<p class="calibre2"> </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">You should now have a better understanding of functional programming and its benefits.  We've discussed the concepts of immutability and pure functions. A combination of the two often results in more testable code, which is easier to maintain. </p>
<p class="calibre2">Currying and memoization are two useful patterns that originate from functional programming.</p>
<p class="calibre2">Kotlin has a <kbd class="calibre13">tailrec</kbd> keyword that allows the compiler to optimize <em class="calibre14">tail recursion</em>. We also looked at higher-order functions, expressions versus statements, and pattern matching.</p>
<p class="calibre2">In the next chapter, we'll put this knowledge to practical use, and discover how reactive programming builds upon functional programming in order to create scalable and resilient systems.</p>


            

            
        
    </body></html>