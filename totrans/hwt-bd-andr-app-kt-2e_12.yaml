- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persisting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter goes in depth about data persistence in Android. By the end of
    the chapter, you will know multiple ways to store (persist) data directly on a
    device and the frameworks accessible to do this. When dealing with a filesystem,
    you will know how it’s partitioned and how you can read and write files in different
    locations and use different frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to structure your code and save data.
    In the activity, you also had the opportunity to build a repository and use it
    to access and save data through Room. In this chapter, you will learn about alternative
    ways to persist data on a device through the Android filesystem and how it’s structured
    into external and internal memory.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also develop your understanding of read and write permissions, learn
    how to create the `FileProvider` class to offer other apps access to your files,
    and learn how you can save those files without requesting permissions on external
    drives. You’ll also see how to download files from the internet and save them
    on a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Another concept that will be explored in this chapter is using the **Camera**
    application to take photos and videos on your application’s behalf and save them
    to external storage using FileProviders.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Preferences and DataStore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoped storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/XlTwZ](https://packt.link/XlTwZ)
  prefs: []
  type: TYPE_NORMAL
- en: Preferences and DataStore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you are tasked with integrating a third-party API that uses something
    such as OAuth to implement logging in with Facebook, Google, and suchlike. The
    way these mechanisms work is as follows – they give you a token that you have
    to store locally and that can then be used to send other requests to access user
    data.
  prefs: []
  type: TYPE_NORMAL
- en: This raises several questions. How can you store that token? Do you use Room
    just for one token? Do you save the token in a separate file and implement methods
    for writing the file? What if that file has to be accessed in multiple places
    at the same time? `SharedPreferences` and `DataStore` are answers to these questions.
    `SharedPreferences` is a functionality that allows you to save Booleans, integers,
    floats, longs, strings, and sets of strings into an XML file.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to save new values, you specify what values you want to save for
    the associated keys, and when you are done, you commit the change, which will
    trigger the save to the XML file in an asynchronous way. The `SharedPreferences`
    mappings are also kept in memory so that when you want to read these values, it’s
    instantaneous, thereby removing the need for an asynchronous call to read the
    XML file.
  prefs: []
  type: TYPE_NORMAL
- en: We now have two ways to store data in key-value pairs in the form of `SharedPreferences`
    and `DataStore`. We will now look at how each of them works and the benefits each
    one provides.
  prefs: []
  type: TYPE_NORMAL
- en: SharedPreferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way to access the `SharedPreference` object is through the `Context` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is where you specify the name of your preferences, and the
    second is how you want to expose a file to other apps. Currently, the best mode
    is the private one. All of the others present potential security risks.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to write data into your preferences file, you first need to get
    access to the Preferences editor. The editor will give you access to write the
    data. You can then write your data in it. Once you finish writing, you will have
    to apply the changes that will trigger persistence to the XML file and change
    the in-memory values as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two choices to apply the changes on your preference file – `apply`
    or `commit`. Choosing `apply` will save your changes in memory instantly, but
    then writing to disk will be asynchronous, which is useful if you want to save
    data from from your app’s main thread. `commit` does everything synchronously
    and gives you a Boolean result, informing you whether the operation was successful
    or not. In practice, `apply` tends to be favored over `commit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you want to clear your entire data. The same principle will apply; you’ll
    need `editor`, `clear`, and `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to read the values you previously saved, you can use the `SharedPreferences`
    object to read the stored values. If there is no saved value, you can opt for
    a default value to be returned instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We should now have an idea about how we can persist data with `SharedPreferences`,
    and we can apply this in an exercise in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.01 – wrapping SharedPreferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to build an application that displays `TextView`, `EditText`, and
    a button. `TextView` will display the previously saved value in `SharedPreferences`.
    The user can type new text, and when the button is clicked, the text will be saved
    in `SharedPreferences` and `TextView` will display the updated text. We will need
    to use `ViewModel` and `LiveData` to make the code more testable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to complete this exercise, we will need to create a `Wrapper` class,
    which will be responsible for saving the text. This class will return the value
    of the text as `LiveData`. This will be injected into our `ViewModel`, which will
    be bound to the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project with an empty activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s begin by adding the appropriate libraries to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s make our `Wrapper` class in the `main/java` folder in the `root` package,
    which will listen for changes in `SharedPreferences` and update the value of `LiveData`
    when the preferences change. The class will contain methods to save the new text
    and retrieve `LiveData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/a2RuN](https://packt.link/a2RuN).
  prefs: []
  type: TYPE_NORMAL
- en: Note the top of the file. We’ve added a listener so that when our `SharedPreferences`
    values change, we can look up the new value and update our `LiveData` model. This
    will allow us to observe `LiveData` for any changes and just update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The `saveText` method will open the editor, set the new value, and apply the
    changes. The `getText` method will read the last saved value, set it in `LiveData`,
    and return the `LiveData` object. This is helpful in scenarios where the app is
    opened and we want to access the last value prior to the app closing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s set up the `Application` class with the instance of the preferences
    in the `main/java` folder in the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add the appropriate attributes in the `application` tag to `Android``Manifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s build the `ViewModel` component in the `main/java` folder in the
    root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define our `activity_main.xml` layout file in the `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/2c5Ay](https://packt.link/2c5Ay).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in `MainActivity`, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/ZRWNc](https://packt.link/ZRWNc).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code will produce the output presented in *Figure 12**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Output of Exercise 12.01](img/B19411_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Output of Exercise 12.01
  prefs: []
  type: TYPE_NORMAL
- en: Once you insert a value, try closing the application and reopening it. The app
    will display the last persisted value.
  prefs: []
  type: TYPE_NORMAL
- en: DataStore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DataStore` persistence library represents an alternative to `SharedPreferences`
    when we want to store data in key-value pairs through the Preference `DataStore`,
    or if we want to store entire objects through the Proto `DataStore`. Both libraries
    avoid dependencies with the Android framework (unlike `SharedPreferences`, which
    requires a `Context` object to be initialized) and are built using coroutines
    and flows, making them the ideal candidate when coroutines and flows are used
    in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This integration allows the `DataStore` to notify subscribers of all changes,
    which means that developers no longer have to concern themselves with handling
    the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we initialize `Context.dataStore` in the top-level
    Kotlin file. We then define three separate keys for separate types we want to
    read from. Inside `MyAppSettings`, we map the values from `context.dataStore.data`
    and extract the values from our keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to store data in our `DataStore`, then we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `suspend` keyword comes from coroutines, and it signals that we need to
    place the method invocation into an asynchronous call. `context.dataStore.edit`
    will make the preferences in the `DataStore` mutable and allow us to change the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.02 – Preference DataStore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to build an application that displays `TextView`, `EditText`, and
    a button. `TextView` will display the value that was added to `DataStore`. The
    user can type new text, and when the button is clicked, the text will be saved
    in `DataStore` and `TextView` will display the updated text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to use `ViewModel` and `LiveData`. In the `ViewModel`, we will
    collect the data coming from `DataStore` and place it in a `LiveData` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project with an empty activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s begin by adding the appropriate libraries to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class called `SettingsStore` in the `main/java` folder in the root
    package, which will contain methods to load and save data from `DataStore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we have defined a key for storing the text, a field
    to retrieve the saved text, and a method to save it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `SettingsViewModel` in the `main/java` folder in
    the root package, which will collect the data from `SettingsStore` in `LiveData`
    and invoke it to save the new text values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, `viewModelScope` is an extension of `ViewModel` and
    represents `CoroutineScope`, which ensures that the background work is done while
    `ViewModel` is still active to avoid any possible leaks. Using this, we can collect
    the existing text into `LiveData` when `ViewModel` is initialized and then invoke
    the `saveText` method from `SettingsStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s set up the `Application` class with the `SettingsStore` instance
    in the `main/java` folder in the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s add the appropriate attributes in the `application` tag to `Android``Manifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s define our `activity_main.xml` layout file in the `res/layout`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/8f854](https://packt.link/8f854).
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, in `MainActivity`, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/gydeC](https://packt.link/gydeC).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run the application, we should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Output of Exercise 12.02](img/B19411_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Output of Exercise 12.02
  prefs: []
  type: TYPE_NORMAL
- en: If we enter a new text and click the `DataStore` will emit a new value for each
    change. We will look at flows and other reactive streams in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have looked at how the `DataStore` library works and its
    benefits, especially regarding streams of data. In the following chapters, we
    will continue to look at other ways of persisting data, using files.
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve discussed Room, `SharedPreferences`, and `DataStore` and specified how
    the data they store is written to files. You may ask yourself, where are these
    files stored? These particular files are stored in internal storage. Internal
    storage is a dedicated space for every app that other apps are unable to access
    (unless a device is rooted). There is no limit to the amount of storage your app
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: However, users have the ability to delete their app’s files from the **Settings**
    menu. Internal storage occupies a smaller part of the total available space, which
    means that you should be careful when it comes to storing files there. There is
    also external storage. The files your app stores in external storage are accessible
    to other apps and the files from other apps are accessible to your one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, you can use the `/data/data/{packageName}`. If you have access
    to this folder, this means that the device is rooted. Using this, you can visualize
    the database files and the `SharedPreferences` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of how the **Device File Explorer** looks can be viewed in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.3 – Android’s Device File Explorer \uFEFFfor an\uFEFF emulated\
    \ device](img/Image100608.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Android’s Device File Explorer for an emulated device
  prefs: []
  type: TYPE_NORMAL
- en: Internal storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Internal storage requires no permissions from the user. To access the internal
    storage directories, you can use one of the following methods from the `Context`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getDataDir()`: Returns the root folder of your application sandbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFilesDir()`: A dedicated folder for application files – recommended for
    usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCacheDir()`: A dedicated folder where files can be cached. Storing files
    here does not guarantee that you can retrieve them later because the system may
    decide to delete this directory to free up memory. This folder is linked to the
    **Clear Cache** option in **Settings**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDir(name, mode)`: Returns a folder that will be created if it does not
    exist, based on the name specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When users use the **Clear Data** option from **Settings**, most of these folders
    will be deleted, bringing the app to a similar state as a fresh installation.
    When the app is uninstalled, these files will be deleted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example of reading a cache file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will read from `my-file.txt`, located in the `Cache` directory,
    and will create `FileInputStream` for that file. Then, a buffer will be used that
    will collect the bytes from the file. The collected bytes will be placed in the
    `bytes` byte array, which will contain all of the data read from that file. Reading
    will stop when the entire length of the file has been read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing to the `my-file.txt` file will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding example does is take the byte array you want to write, create
    a new `File` object, create the file if it doesn’t exist, and write the bytes
    into the file through `FileOutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many alternatives to dealing with files. The readers (`StreamReader`,
    `StreamWriter`, and so on) are better equipped for character-based data. There
    are also third-party libraries that help with disk I/O operations. One of the
    most common third parties that help with I/O operations is called `OkHttp` library,
    which is used in combination with Retrofit to make API calls. The methods provided
    by Okio are the same methods it uses to write and read data in HTTP communications.
  prefs: []
  type: TYPE_NORMAL
- en: External storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading and writing in external storage requires user permission for reading
    and writing. If write permission is granted, then your app has the ability to
    read the external storage. Once these permissions are granted, then your app can
    do whatever it pleases on the external storage.
  prefs: []
  type: TYPE_NORMAL
- en: That may present a problem because users may not choose to grant these permissions.
    However, there are specialized methods that offer you the possibility to write
    to the external storage in folders dedicated to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most common ways of accessing external storage are from the `Context`
    and `Environment` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Context.getExternalFilesDir(mode)`: This method will return the path to the
    directory on the external storage dedicated to your application. Specifying different
    modes (pictures, movies, and so on) will create different subfolders, depending
    on how you want your files saved. This method *does not* *require permissions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getExternalCacheDir()`: This will point toward an application’s cache
    directory on the external storage. The same considerations should be applied to
    this `cache` folder as to the internal storage option. This method *does not*
    *require permissions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Environment` class has access to paths of some of the most common folders
    on a device. However, on newer devices, apps may not have access to those files
    and folders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using hardcoded paths to files and folders. The Android operating system
    may shift the location of folders around, depending on the device or Android version.
  prefs: []
  type: TYPE_NORMAL
- en: FileProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This represents a specialized implementation of `ContentProviders` that is useful
    in organizing the file and folder structure of your application. It allows you
    to specify an XML file, in which you define how your files should be split between
    internal and external storage if you choose to do so. It also gives you the ability
    to grant access to other apps to your files by hiding the path and generating
    a unique URI to identify and query your file.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileProvider` lets you pick between six different folders, where you can set
    up your folder hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Context.getFilesDir()` (files-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getCacheDir()` (cache-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Environment.getExternalStorageDirectory()` (external-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getExternalFilesDir(null)` (external-files-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getExternalCacheDir()` (external-cache-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first result of `Context.getExternalMediaDirs()` (external-media-path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main benefits of `FileProvider` are the abstractions it provides in organizing
    your files while leaving a developer to define the paths in an XML file, and more
    importantly, if you choose to use it to store files in external storage, you do
    not have to ask for permissions from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit is the fact that it makes sharing of internal files easier while
    giving a developer control of what files other apps can access without exposing
    their real location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us understand better through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will make `FileProvider` use the internal `files` directory
    and create a folder named `my-folder-name`. When the path is converted to a URI,
    then the URI will use `my-visible-name`.
  prefs: []
  type: TYPE_NORMAL
- en: The Storage Access Framework (SAF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SAF is a file picker introduced in Android KitKat that apps can use for
    their users to pick files, with a view to them being processed or uploaded. You
    can use it in your app in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Your app requires a user to process a file saved on a device by another app
    (photos and videos)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to save a file on a device and give a user the choice of where to save
    the file and the name of the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to offer the files your application uses to other apps for scenarios
    similar to the first scenario in this list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is again useful because your app will avoid read and write permissions
    and still write and access external storage. The way this works is based on intents.
    You can register for an activity result for `GetDocument` or `CreateDocument`.
    Then, in the activity result callback, the system will give you a URI that grants
    you temporary permissions to that file, allowing you to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of the SAF is the fact that files don’t have to be on a device.
    Apps such as Google Drive expose their content in the SAF, and when a Google Drive
    file is selected, it will be downloaded to the device and the URI will be sent
    as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to mention is the SAF’s support for virtual files, meaning
    that it will expose Google docs, which have their own format, but when those docs
    are downloaded through the SAF, their formats will be converted to a common format
    such as PDF.
  prefs: []
  type: TYPE_NORMAL
- en: Asset files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`assets` folder inside your project. You can then group your files inside your
    assets using folders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access these files at runtime through the `AssetManager` class, which
    itself can be accessed through the context object. `AssetManager` offers you the
    ability to look up the files and read them, but it does not permit any write operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example lists all files inside the root of the `assets` folder.
    The `open` function returns `inputStream`, which can be used to read the file
    information if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: One common usage of the `assets` folder is for custom fonts. If your application
    uses custom fonts, then you can use the `assets` folder to store font files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the following exercise, you will need an emulator. You can do so by selecting
    **Tools** | **AVD Manager** in Android Studio. Then, you can create one with the
    **Create Virtual Device** option, selecting the type of emulator, clicking **Next**,
    and then selecting an x86 image. Any image larger than Lollipop should be acceptable
    for this exercise. Next, you can give your image a name and click **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.03 – copying files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create an app that will keep a file named `my-app-file.txt` in the `assets`
    directory. The app will display two buttons called `FileProvider` and `SAF`. When
    the `FileProvider` button is clicked, the file will be saved on the external storage
    inside the app’s external storage dedicated area (`Context.getExternalFilesDir(null)`).
    The `SAF` button will open the SAF and allow a user to indicate where the file
    should be saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this exercise, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a file provider that will use the `Context.getExternalFilesDir(null)`
    location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `my-app-file.txt` to the preceding location when the `FileProvider` button
    is clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `Intent.ACTION_CREATE_DOCUMENT` when the `SAF` button is clicked and copy
    the file to the location provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a separate thread for the file copy to comply with the Android guidelines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Apache IO library to help with the file copy functionality, by providing
    methods that allow us to copy data from `InputStream` to `OutputStream`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project with an empty activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start with our Gradle configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `my-app-file.txt` file in the `main/assets` folder. Feel free to
    fill it up with the text you want to be read. If the `main/assets` folder doesn’t
    exist, then you can create it. To create the `assets` folder, you can right-click
    on the `main` folder, select `assets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This folder will now be recognized by the build system, and any file inside
    it will also be installed on the device along with the app. You may need to switch
    **Project View** from **Android** to **Project** to be able to view this file
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a class that will wrap `AssetManager` in the `main/java`
    folder in the root package and define a method to access this particular file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s work on the `FileProvider` aspect. Create the `xml` folder in the
    `res` folder. Define `file_provider_paths.xml` inside the new folder. We will
    define `external-files-path`, name it `docs`, and place it in the `docs/` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add `FileProvider` to the `AndroidManifest.xml` file and link
    it with the new path we defined inside the `<``application` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name will point to the `FileProvider` path that’s part of the Android Support
    Library. The `authorities` field represents the domain your application has (usually
    the package name of the application).
  prefs: []
  type: TYPE_NORMAL
- en: The exported field indicates whether we wish to share our provider with other
    apps, and `grantUriPermissions` indicates whether we wish to grant other applications
    access to certain files through the URI. The metadata links the XML file we defined
    previously with `FileProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `ProviderFileManager` class in the `main/java` folder in the root
    package, which is responsible for accessing the `docs` folder and writing data
    into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/Gp0Ph](https://packt.link/Gp0Ph).
  prefs: []
  type: TYPE_NORMAL
- en: '`getDocsFolder` will return the path to the `docs` folder we defined in the
    XML. If the folder does not exist, then it will be created.'
  prefs: []
  type: TYPE_NORMAL
- en: The `writeStream` method will extract the URI for the file we wish to save and,
    using the Android `ContentResolver` class, will give us access to the `OutputStream`
    class of the file we will be saving in. Note that `FileToUriMapper` doesn’t exist
    yet. The code is moved into a separate class in order to make this class testable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `FileToUriMapper` class in the `main/java` folder in the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getUriForFile` method is part of the `FileProvider` class, and its role
    is to convert the path of a file into a URI that can be used by `ContentProviders`
    and `ContentResolvers` to access data. Because the method is static, it prevents
    us from testing properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the following strings are added to `strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now move on to defining our UI for the `activity_main.xml` file in the
    `res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/Pw37X](https://packt.link/Pw37X).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define our `MainActivity` class in the `main/java` folder in the
    root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/FBXgY](https://packt.link/FBXgY).
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we chose `MainActivity` to create our objects and inject data
    into the different classes we have. If we execute this code and click the `FileProvider`
    button, we don’t see an output on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we look at Android’s **Device File Explorer**, we can locate where
    the file was saved. The path may be different on different devices and operating
    systems. The paths could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mnt/sdcard/Android/data/<package_name>/files/docs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sdcard/Android/data/<package_name>/files/docs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`storage/emulated/0/Android/data/<package_name>/files/docs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Output of copy through FileProvider](img/B19411_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Output of copy through FileProvider
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the logic for the `SAF` button. We will need to start an activity
    pointing toward `SAF` with the `CREATE_DOCUMENT` intent, in which we specify that
    we want to create a text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will then need the result of `SAF` so that we can copy the file to the location
    selected by a user. In `MainActivity` in `onCreate`, we can add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding code will do is register for an `Activity` result when a
    user creates a new file. We will then invoke `writeStreamFromUri` from `ProviderFileManager`
    to save the contents from the file in the `assets` folder in the file created
    by the user. When the button is clicked, we will then launch the file creation
    screen from the SAF.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the URI. We can add a method to `ProviderFileManager` that will
    copy our file to a location given by `uri`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the preceding code and click on the **SAF** button, we will see the
    output presented in *Figure 12**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Output of copy through the SAF](img/B19411_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Output of copy through the SAF
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to save the file, the SAF will be closed and the callback from
    `registerForActivityResult` will be invoked, which will trigger the file copy.
    Afterward, you can navigate the Android Device File Manager tool to see whether
    the file was saved properly.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Android 10 and with further updates in Android 11, the notion of scoped
    storage was introduced. The main idea behind this is to allow apps to gain more
    control of their files in external storage and prevent other apps from accessing
    these files.
  prefs: []
  type: TYPE_NORMAL
- en: The consequences of this mean that `READ_EXTERNAL_STORAGE` and `WRITE_EXTERNAL_STORAGE`
    will only apply to files a user interacts with (such as media files). This discourages
    apps from creating their own directories in external storage, instead sticking
    with the one already provided to them through `Context.getExternalFilesDir`.
  prefs: []
  type: TYPE_NORMAL
- en: FileProviders and the SAF are a good way of making your app comply with scoped
    storage practices, with one allowing the app to use `Context.getExternalFilesDir`
    and the other using the built-in File Explorer app, which will now avoid files
    from other applications in the `Android/data` and `Android/obb` folders in external
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Camera and media storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android offers a variety of ways to interact with media on its devices, from
    building your own camera application and controlling how users take photos and
    videos to using an existing camera application and instructing it on how to take
    photos and videos.
  prefs: []
  type: TYPE_NORMAL
- en: Android also comes with a `MediaStore` content provider, allowing applications
    to extract information about media files that are set on a device and shared between
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful in situations where you want a custom display for media files
    that exist on a device (such as a photo or music player application) and in situations
    where you use the `MediaStore.ACTION_PICK` intent to select a photo from the device
    and want to extract the information about the selected media image (this is usually
    the case for older applications where the SAF cannot be used).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use an existing camera application, you will need to use the `MediaStore.ACTION_IMAGE_CAPTURE`
    intent to start a camera application for a result and pass the URI of the image
    you wish to save. The user will then go to the camera activity and take the photo,
    and then you handle the result of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `photoUri` parameter will represent the location of where you want your
    photo to be saved. It should point to an empty file with a JPEG extension. You
    can build this file in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file on the external storage using the `File` object (this requires
    the `WRITE_EXTERNAL_STORAGE` permission) and then use the `Uri.fromFile()` method
    to convert it into `URI` (this is no longer applicable on Android 10 and above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a file in a `FileProvider` location using the `File` object, and then
    use the `FileProvider.getUriForFile()` method to obtain the URI and grant it permissions
    if necessary (the recommended approach for when your app targets Android 10 and
    Android 11)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same mechanism can be applied to videos using `MediaStore.ACTION_VIDEO_CAPTURE`.
  prefs: []
  type: TYPE_NORMAL
- en: If your application relies heavily on camera features, then you can exclude
    the application from users whose devices don’t have cameras by adding the `<uses-feature>`
    tag to the `AndroidManifest.xml` file. You can also specify the camera as non-required
    and query whether the camera is available using the `Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to have your file saved in `MediaStore`, there are multiple ways
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send an `ACTION_MEDIA_SCANNER_SCAN_FILE` broadcast with the URI of your media:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the media scanner to scan files directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the media into `ContentProvider` directly using `ContentResolver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `MediaScanner` functionality no longer adds files from `Context.getExternal`
    **FilesDir** in Android 10 and above. Apps should rely on the `insert` method
    instead if they choose to share their media files with other apps.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.04 – taking photos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to build an application that has two buttons; the first button will
    open a camera app to take a photo, and the second button will open the camera
    app to record a video. We will use `FileProvider` to save the photos to external
    storage (external-path) in two folders, `pictures` and `movies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The photos will be saved using `img_{timestamp}.jpg`, and the videos will be
    saved using `video_{timestamp}.mp4`. After a photo and video have been saved,
    you will copy the file from `FileProvider` into `MediaStore` so that they will
    be visible for other apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project with an empty activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s add the libraries in `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to request the `WRITE_EXTERNAL_STORAGE` permission for devices
    that predate Android 10, which means we need the following in `AndroidManifest.xml`
    outside of the `<``application` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define a `FileHelper` class, which will contain methods that are harder
    to test in the `test` folder in the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define our `FileProvider` paths in `res/xml/file_provider_paths.xml`.
    Make sure to include the appropriate package name for your application in `FileProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add the file provider paths to the `AndroidManifest.xml` file inside
    the `<``application` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now define a model that will hold both `Uri` and the associated path
    for a file in the `main/java` folder in the root package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s create a `ContentHelper` class in the `main/java` folder in the root package,
    which will provide us with the data required for `ContentResolver`. We will define
    two methods for accessing the photo and video content URI and two methods that
    will create `ContentValues`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We do this because of the static methods required to obtain URIs and create
    `ContentValues`, which makes this functionality hard to test. The following code
    is truncated for space. The full code you need to add can be found via the link
    that follows this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/DhOLR](https://packt.link/DhOLR).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the `ProviderFileManager` class in the `main/java` folder
    in the root package, where we will define methods to generate files for photos
    and videos that will then be used by the camera and the methods that will save
    to the media store. Again, the code has been truncated for brevity. Please see
    the link that follows this code block for the full code that you need to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/ohv7a](https://packt.link/ohv7a).
  prefs: []
  type: TYPE_NORMAL
- en: Note how we defined the root folders as `context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)`
    and `context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)`. This connects
    to `file_provider_paths.xml` and it will create a set of folders called `Movies`
    and `Pictures` in the application’s dedicated folder in external storage. The
    `insertToStore` method is where the files will be then copied to the `MediaStore`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create an entry into that store that will give us a URI for that
    entry. Next, we copy the contents of the files from the URI generated by `FileProvider`
    into `OutputStream`, pointing to the `MediaStore` entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following strings to `strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define the layout for our activity in `res/layout/activity_main.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/6iSNp](https://packt.link/6iSNp).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `MainActivity` class in the `main/java` folder in the root
    package, where we will check whether we need to request `WRITE_STORAGE_PERMISSION`,
    request it if we need to, and after it is granted, open the camera to take a photo
    or a video. As before, the code here has been truncated for brevity. You can access
    the full code using the link that follows the code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/YeHWC](https://packt.link/YeHWC).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding code, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Output of Exercise 12.04](img/B19411_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Output of Exercise 12.04
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on either of the buttons, you will be redirected to the camera application,
    where you can take a photo or a video if you are running the example on Android
    10 and above. If you’re running on lower Android versions, then the permissions
    will be asked first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have taken your photo and confirmed it, you will be taken back to
    the application. The photo will be saved in the location you defined in `FileProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The location of the captured files through the camera app](img/B19411_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – The location of the captured files through the camera app
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see where the files are located with the
    help of Android Studio’s **Device File Explorer**. If you open any file-exploring
    app, such as the **Files**, **Gallery**, or **Google Photos** app, you will be
    able to see the videos and pictures taken.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The files from the app present in the File Explorer app](img/B19411_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – The files from the app present in the File Explorer app
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.01 – dog downloader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are tasked with building an application that will target Android versions
    above API 21 and display a list of URLs for dog photos. The URL you will connect
    to is `https://dog.ceo/api/breed/hound/images/random/{number}`, where `number`
    will be controlled through a **Settings** screen, where a user can choose the
    number of URLs they want to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The **Settings** screen will be opened through an option presented on the home
    screen. When a user clicks on a URL, an image will be downloaded locally in the
    application’s external cache path. While the image is being downloaded, the user
    will see an indeterminate progress bar. The list of URLs will be persisted locally
    using Room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technologies that we will use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit to retrieve the list of URLs and download files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room to persist the list of URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SharedPreferences` to store the number of URLs to retrieve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileProvider` to store the files in the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache IO to write the files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository to combine all the data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveData` and `ViewModel` to handle the logic from the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecyclerView` for the list of items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response JSON will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `api` package that will contain the network-related classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a data class that will model the response JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Retrofit `Service` class that will contain two methods. The first method
    will represent the API call to return a list of breeds, and the second method
    will represent the API call to download the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `storage` package, and inside it, create a `room` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `Dog` entity, which will contain an autogenerated ID and a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `DogDao` class, which will contain methods to insert a list of `Dogs`,
    delete all `Dogs`, and query all `Dogs`. The `delete` method is required because
    the API model does not have any unique identifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `storage` package, create a `preference` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `preference` package, create a wrapper class around `SharedPreferences`
    that will return the number of URLs we need to use and set the number. The default
    will be `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `res/xml`, define your folder structure for `FileProvider`. The files should
    be saved in the root folder of the `external-cache-path` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `storage` package, create a `filesystem` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `filesystem` package, define a class that will be responsible for
    writing `InputStream` into a file in `FileProvider`, using `Context.externalCacheDir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `repository` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `repository` package, create a sealed class that will hold the result
    of an API call. The subclasses of the sealed class will be `Success`, `Error`,
    and `Loading`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `Repository` interface that will contain two methods, one to load the
    list of URLs and the other to download a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `DogUi` model class that will be used in the UI layer of your application
    and that will be created in your repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a mapper class that will convert your API models into entities and entities
    into UI models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an implementation for `Repository` that will implement the preceding
    two methods. The repository will hold references to `DogDao`, the Retrofit `Service`
    class, the `Preferences` wrapper class, the class managing the files, the `Dog`
    mapping class, and the `Executor` class for multithreading. When downloading the
    files, we will use the filename extracted from the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that will extend `Application`, which will initialize the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `ViewModel` class used by your UI, which will have a reference to
    `Repository` and call it to load the URL list and download the images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define your UI, which will be composed of two activities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MainActivity` which displays the list of URLs and will have a click action
    to start the downloads. This activity will have a progress bar, which will be
    displayed when the download takes place. The screen will also have a `SettingsActivity`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SettingsActivity`, which will display `EditText` and `Button` and save
    the number of URLs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/z6g5j](https://packt.link/z6g5j).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed alternatives to Room when it comes to persisting
    data. We looked first at `SharedPreferences` and how it constitutes a handy solution
    for data persistence when it’s in a key-value format and the amount of data is
    small. We also looked at `DataStore` and how we can use it like `SharedPreferences`
    but with built-in observability, which notifies us when values are changed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked over something that was continuously changing when it comes
    to the Android framework – the evolution of abstractions regarding a filesystem.
    We started with an overview of the types of storage that Android has and then
    took a more in-depth look at two of the abstractions – `FileProvider`, which your
    app can use to store files on a device and share them with others if necessary,
    and the SAF, which can be used to save files on the device in a location selected
    by a user.
  prefs: []
  type: TYPE_NORMAL
- en: We also used the benefits of `FileProvider` to generate URIs for files in order
    to use camera applications to take photos and record videos, saving them in the
    application’s files while also adding them to `MediaStore`.
  prefs: []
  type: TYPE_NORMAL
- en: The activity performed in this chapter combines all the elements discussed previously
    to illustrate the point that even though you have to balance multiple sources
    inside an application, you can do it in a more readable way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the activity and exercises in this chapter and the previous one,
    we kept having to use the `application` class to instantiate the data sources.
    In the next chapter, you will learn how to overcome this through dependency injection
    and see how it can benefit Android applications.
  prefs: []
  type: TYPE_NORMAL
