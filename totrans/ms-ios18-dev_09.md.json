["```swift\n import Charts\nstruct BarMarkView: View {\n    struct Sales: Identifiable {\n        var id: UUID = UUID()\n        let itemType: String\n        let qty: Int\n    }\n    let data: [Sales] = [\n        Sales(itemType: \"Apples\", qty: 50),\n        Sales(itemType: \"Oranges\", qty: 60),\n        Sales(itemType: \"Watermelons\", qty: 30)\n    ]\n    var body: some View {\n        VStack { <st c=\"3731\">Chart(data) {</st>\n <st c=\"3744\">BarMark(</st>\n <st c=\"3753\">x: .value(\"Fruit\", $0.itemType),</st>\n <st c=\"3786\">y: .value(\"qty\", $0.qty)</st>\n <st c=\"3811\">)</st>\n <st c=\"3813\">}</st> }\n    }\n}\n```", "```swift\n<st c=\"4928\">Chart</st>(data) { <st c=\"4943\">BarMark</st>(\n                    x: .value(\"Fruit\", $0.itemType),\n                    y: .value(\"qty\", $0.qty)\n                )\n            }\n```", "```swift\n<st c=\"5323\">Chart</st> { <st c=\"5332\">ForEach</st>(data, id:\\.id) { item in <st c=\"5366\">BarMark</st>(x: .value(\"Fruit\",\n                              item.itemType),\n                            y: .value(\"qty\", item.qty))\n                }\n            }\n```", "```swift\n struct Sales: Identifiable {\n    var id: UUID = UUID()\n    let itemType: String\n    let qty: Int <st c=\"6816\">var fruitColor: String = \"\"</st> }\n```", "```swift\n let data: [Sales] = [\n        Sales(itemType: \"Apples\", qty: 20, fruitColor:\n          \"Green\"),\n        Sales(itemType: \"Apples\", qty: 30, fruitColor:\n          \"Red\"),\n        Sales(itemType: \"Oranges\", qty: 60),\n        Sales(itemType: \"Watermelons\", qty: 30)\n]\n```", "```swift\n Chart(data) {\n            BarMark(x: .value(\"Fruit\", $0.itemType),\n                    y: .value(\"qty\", $0.qty)) <st c=\"7469\">.foregroundStyle(by: .value(\"Color\",</st>\n <st c=\"7505\">$0.fruitColor))</st> }\n```", "```swift\n let data: [Sales] = [\n        Sales(itemType: \"Apples\", qty: 20, fruitColor:\n              \"Green\"),\n        Sales(itemType: \"Apples\", qty: 30, fruitColor:\n              \"Red\"), <st c=\"8655\">Sales(itemType: \"Apples\", qty: 40, fruitColor:</st>\n <st c=\"8701\">\"Yellow\"),</st> ]\n```", "```swift\n Chart(data) {\n                BarMark( <st c=\"8876\">x: .value(\"Qty\", $0.qty)</st> )\n                .foregroundStyle(by: .value(\"Color\",\n                  $0.fruitColor))\n            }\n```", "```swift\n public init<X>(<st c=\"9316\">init()</st> function in this code example is the method that we are using. Now, let’s see what the chart we create looks like when it’s only one-dimensional (*<st c=\"9469\">Figure 9</st>**<st c=\"9478\">.3</st>*):\n\t\t\t![Figure 9.3: A 1D chart](img/B21795_09_3.jpg)\n\n\t\t\t<st c=\"9510\">Figure 9.3: A 1D chart</st>\n\t\t\t<st c=\"9532\">In</st> *<st c=\"9536\">Figure 9</st>**<st c=\"9544\">.3</st>*<st c=\"9546\">, our data is presented in a one-dimensional chart presenting three different types</st> <st c=\"9630\">of apples.</st>\n\t\t\t<st c=\"9640\">One thing still bothers us here: notice</st> <st c=\"9680\">that the fruit colors don’t match</st> <st c=\"9714\">the actual colors the Charts framework assigned to each fruit when it created the chart.</st> <st c=\"9804\">That’s because the Charts framework generates the colors while encoding the value.</st> <st c=\"9887\">If we want to match the fruit color to the chart presented color, we need to use the</st> `<st c=\"9972\">chartForegroundStyleScale</st>` <st c=\"9997\">view modifier:</st>\n\n```", "```swift\n let emma = \"Emma Johnson\"\nlet liam = \"Liam Patel\"\nlet sophia = \"Sophia Garcia\"\nlet data: [EmployeDayWork] = [\n        EmployeDayWork(name:emma, startTime: 10, endTime:\n          12),\n        EmployeDayWork(name:liam, startTime: 8, endTime:\n          11),\n        EmployeDayWork(name: sophia, startTime: 10.5,\n          endTime: 11.5),\n        EmployeDayWork(name: emma, startTime: 14, endTime:\n          15),\n        EmployeDayWork(name: liam, startTime: 13.5,\n          endTime: 14.2),\n        EmployeDayWork(name: sophia, startTime: 15,\n          endTime: 16)\n]\n```", "```swift\n Chart(data) {\n                BarMark( <st c=\"12006\">xStart</st>: .value(\"Start\", $0.startTime), <st c=\"12046\">xEnd</st>: .value(\"End\", $0.endTime), <st c=\"12080\">y</st>: .value(\"Employee\", $0.name)\n                )\n            }\n```", "```swift\n struct SalesFigure: Identifiable {\n    var id: UUID = UUID()\n    let product: String\n    let day: Date\n    let amount: Double\n}\n```", "```swift\n let phoneProduct = \"Phone\"\nlet salesFigures: [SalesFigure] = [\n        SalesFigure(product: phoneProduct, day:\n          Date(timeIntervalSince1970: 1714078800), amount:\n            100),\n        SalesFigure(product: phoneProduct, day:\n          Date(timeIntervalSince1970: 1714165200), amount:\n            120),\n        SalesFigure(product: phoneProduct, day:\n          Date(timeIntervalSince1970: 1714251600), amount:\n            90),\n        SalesFigure(product: phoneProduct, day:\n          Date(timeIntervalSince1970: 1714338000), amount:\n            70)\n    ]\n```", "```swift\n Chart(salesFigures) { <st c=\"14738\">LineMark(</st>\n <st c=\"14747\">x: .value(\"time\", $0.day),</st>\n <st c=\"14774\">y: .value(\"amount\", $0.amount)</st>\n <st c=\"14805\">)</st> }\n```", "```swift\n<st c=\"15320\">let tabletProduct = \"Tablet\"</st> let salesFigures: [SalesFigure] = [\n        SalesFigure(product: phoneProduct, day:\n          Date(timeIntervalSince1970: 1714078800), amount:\n            100), <st c=\"15481\">SalesFigure(product: tabletProduct, day:</st>\n <st c=\"15521\">Date(timeIntervalSince1970: 1714078800), amount:</st>\n <st c=\"15570\">70),</st> // …\n        SalesFigure(product: phoneProduct, day:\n          Date(timeIntervalSince1970: 1714338000), amount:\n            70), <st c=\"15675\">SalesFigure(product: tabletProduct, day:</st>\n <st c=\"15715\">Date(timeIntervalSince1970: 1714338000), amount:</st>\n <st c=\"15764\">110)</st> ]\n```", "```swift\n LineMark(\n     x: .value(\"time\", $0.day),\n     y: .value(\"amount\", $0.amount)\n     )<st c=\"16099\">foregroundStyle</st> view modifier applies different styles to different product types. Looking at the code, we can see that the chart can distinguish between these two types.\n\t\t\t<st c=\"16269\">Let’s see what the chart looks like after we have added the tablet sales figures (</st>*<st c=\"16352\">Figure 9</st>**<st c=\"16361\">.7</st>*<st c=\"16363\">):</st>\n\t\t\t![Figure 9.7: LineMark chart with two types of product sales figures](img/B21795_09_7.jpg)\n\n\t\t\t<st c=\"16416\">Figure 9.7: LineMark chart with two types of product sales figures</st>\n\t\t\t*<st c=\"16482\">Figure 9</st>**<st c=\"16491\">.7</st>* <st c=\"16493\">shows tablet sales compared to phone sales.</st> <st c=\"16538\">We can see that while the phone sales declined, the tablet sales increased.</st> <st c=\"16614\">That’s an insight that is difficult to get just from</st> <st c=\"16667\">the dataset.</st>\n\t\t\t<st c=\"16679\">Thus far, we have created two primary</st> <st c=\"16717\">types of charts: bar and line charts.</st> <st c=\"16756\">These two types are pretty popular, as they are simple to understand and work for many</st> <st c=\"16843\">use cases.</st>\n\t\t\t<st c=\"16853\">Another popular chart type Apple added in iOS 17 is</st> **<st c=\"16906\">SectorMark</st>**<st c=\"16916\">, also known as a</st> <st c=\"16934\">pie chart.</st>\n\t\t\t<st c=\"16944\">Creating a SectorMark chart</st>\n\t\t\t<st c=\"16972\">A SectorMark, or pie, chart</st> <st c=\"17000\">provides a way to visualize the proportions of different values.</st> <st c=\"17066\">Unlike the other charts, the pie chart is based on a circular shape divided into slices, and each slide represents a different</st> <st c=\"17193\">item value.</st>\n\t\t\t<st c=\"17204\">Apparently, the SectorMark chart looks like another form of Stacked Marks we covered earlier (under</st> *<st c=\"17305\">Adding</st>* *<st c=\"17312\">Stacked Marks</st>*<st c=\"17325\">).</st>\n\t\t\t<st c=\"17328\">However, SectorMark charts became more popular than Stacked Marks as they are visually appealing and easier to understand.</st> <st c=\"17452\">Moreover, StackedMark and SectorMark charts are excellent for comparing different parts and seeing their contribution to the whole.</st> <st c=\"17584\">However, stacked marks are practical when we want to compare one whole to another, and SectorMark charts are helpful when we want to focus on</st> <st c=\"17726\">one whole.</st>\n\t\t\t<st c=\"17736\">Like the previous examples, to create a SectorMark chart, we need to prepare a dataset.</st> <st c=\"17825\">So, let’s create a dataset representing a poll result about</st> <st c=\"17885\">consuming fruits:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"18148\">In this example, we created a structure named</st> `<st c=\"18195\">FavoriteFruit</st>`<st c=\"18208\">, which contains the name of the fruit and the number of people who chose</st> <st c=\"18282\">that fruit.</st>\n\t\t\t<st c=\"18293\">To use the data dataset, we will add a</st> `<st c=\"18333\">SectorMark</st>` <st c=\"18343\">view to</st> <st c=\"18352\">our chart:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"18480\">The</st> `<st c=\"18485\">SectorMark</st>` <st c=\"18495\">structure has an angle parameter that reflects the numeric value of the slice.</st> <st c=\"18575\">We also added the</st> `<st c=\"18593\">foregroundStyle</st>` <st c=\"18608\">view modifier, which colors the slice according to the item’s</st> <st c=\"18671\">fruit property.</st>\n\t\t\t<st c=\"18686\">Let’s look at what the SectorMark chart looks like when running our code (</st>*<st c=\"18761\">Figure 9</st>**<st c=\"18770\">.8</st>*<st c=\"18772\">):</st>\n\t\t\t![Figure 9.8: SectorMark chart](img/B21795_09_8.jpg)\n\n\t\t\t<st c=\"18777\">Figure 9.8: SectorMark chart</st>\n\t\t\t*<st c=\"18805\">Figure 9</st>**<st c=\"18814\">.8</st>* <st c=\"18816\">shows a beautiful, colorful pie</st> <st c=\"18848\">chart, including the legend titles.</st> <st c=\"18885\">We can even set an inner radius to add a</st> **<st c=\"18926\">donut style</st>** <st c=\"18937\">to</st> <st c=\"18941\">the chart:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"19088\">The addition of the inner radius creates a</st> **<st c=\"19132\">hole</st>** <st c=\"19136\">in the pie chart, as we can see in</st> *<st c=\"19172\">Figure 9</st>**<st c=\"19180\">.9</st>*<st c=\"19182\">:</st>\n\t\t\t![Figure 9.9: A SectorMark chart with an inner radius](img/B21795_09_9.jpg)\n\n\t\t\t<st c=\"19185\">Figure 9.9: A SectorMark chart with an inner radius</st>\n\t\t\t*<st c=\"19236\">Figure 9</st>**<st c=\"19245\">.9</st>* <st c=\"19247\">shows a donut-shaped SectorMark chart.</st> <st c=\"19287\">This shape allows us to provide more information in the center of the chart.</st> <st c=\"19364\">Some even say that this form is more readable to users as it eliminates the need to</st> <st c=\"19448\">compare angles.</st>\n\t\t\t<st c=\"19463\">Until now, we have</st> <st c=\"19482\">created</st> `<st c=\"19491\">BarMark</st>`<st c=\"19498\">,</st> `<st c=\"19500\">LineMark</st>`<st c=\"19508\">, and</st> `<st c=\"19514\">SectorMark</st>` <st c=\"19524\">charts.</st> <st c=\"19533\">The following chart combines two charts we discussed – the LineMark and stacked BarMark charts.</st> <st c=\"19629\">That’s the</st> `<st c=\"19640\">AreaMark</st>` <st c=\"19648\">chart.</st>\n\t\t\t<st c=\"19655\">Creating an AreaMark chart</st>\n\t\t\t<st c=\"19682\">The stacked BarMark chart</st> <st c=\"19708\">we discussed under the</st> *<st c=\"19732\">Adding Stacked Marks</st>* <st c=\"19752\">section shows two important figures – the total value of a category and how that total is divided into sub-categories while observing the different proportions.</st> <st c=\"19914\">The LineMark chart, on the other hand, shows the trend or patterns between different</st> <st c=\"19999\">data points.</st>\n\t\t\t<st c=\"20011\">However, what if we want to combine these two types of marks, showing how a value is composed of different categories</st> <st c=\"20130\">over time?</st>\n\t\t\t<st c=\"20140\">That’s what the AreaMark chart</st> <st c=\"20172\">is for.</st>\n\t\t\t<st c=\"20179\">Let’s take our LineMark sales figures example.</st> <st c=\"20227\">We have a dataset representing phone and tablet sales over time.</st> <st c=\"20292\">Now, we want to see the total sales of these two types of products over time while still observing the different trends of</st> <st c=\"20415\">each product.</st>\n\t\t\t<st c=\"20428\">So, we can create an</st> `<st c=\"20450\">AreaMark</st>` <st c=\"20458\">chart based on the</st> <st c=\"20478\">same dataset:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"20651\">Our code example is identical</st> <st c=\"20681\">to the LineMark example we discussed under the</st> *<st c=\"20729\">Creating LineMark charts</st>* <st c=\"20753\">section; the only difference is that we are now using AreaMark instead</st> <st c=\"20825\">of LineMark.</st>\n\t\t\t<st c=\"20837\">However, the result is different (</st>*<st c=\"20872\">Figure 9</st>**<st c=\"20881\">.10</st>*<st c=\"20884\">):</st>\n\t\t\t![Figure 9.10: An AreaMark chart for total sales](img/B21795_09_10.jpg)\n\n\t\t\t<st c=\"20889\">Figure 9.10: An AreaMark chart for total sales</st>\n\t\t\t<st c=\"20935\">At first glance,</st> *<st c=\"20953\">Figure 9</st>**<st c=\"20961\">.10</st>* <st c=\"20964\">shows similar information as</st> *<st c=\"20994\">Figure 9</st>**<st c=\"21002\">.7</st>*<st c=\"21004\">—trends of product sales figures.</st> <st c=\"21039\">However, there are differences.</st> <st c=\"21071\">The filled area in</st> *<st c=\"21090\">Figure 9</st>**<st c=\"21098\">.10</st>* <st c=\"21101\">represents the</st> **<st c=\"21117\">total sales</st>** <st c=\"21128\">of products for both phones and tablets, and each color represents a different product type.</st> <st c=\"21222\">On the other hand,</st> *<st c=\"21241\">Figure 9</st>**<st c=\"21249\">.7</st>* <st c=\"21251\">only shows a comparison between these two product types, side</st> <st c=\"21314\">by side.</st>\n\t\t\t<st c=\"21322\">The AreaMark chart</st> <st c=\"21341\">is great for market share analysis, financial data visualization, and general information, including data trends and</st> <st c=\"21459\">cumulative totals.</st>\n\t\t\t<st c=\"21477\">However, charts can give us much more than data comparison and trends.</st> <st c=\"21549\">Let’s meet our final chart, PointMark, which can provide a different level</st> <st c=\"21624\">of insight.</st>\n\t\t\t<st c=\"21635\">Creating a PointMark chart</st>\n\t\t\t<st c=\"21662\">Until now, we have discussed</st> <st c=\"21691\">marks that have helped us compare sales figures or observe trends.</st> <st c=\"21759\">What about areas such as correlation analysis or predictive modeling?</st> <st c=\"21829\">To fulfill that need, the PointMark chart, also known as the</st> **<st c=\"21890\">scatterplot chart</st>**<st c=\"21907\">, aims to show the relatio</st><st c=\"21933\">nships</st> <st c=\"21940\">between</st> <st c=\"21949\">two variables.</st>\n\t\t\t<st c=\"21963\">Let’s find the correlation</st> <st c=\"21990\">between students’ study hours and grades.</st> <st c=\"22033\">First, we create a dataset representing</st> <st c=\"22073\">the data:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"22717\">This code example has a</st> `<st c=\"22742\">StudentData</st>` <st c=\"22753\">structure containing information about student study time and grades.</st> `<st c=\"22824\">studentsDataSet</st>` <st c=\"22839\">is an array that contains information about</st> <st c=\"22884\">ten students.</st>\n\t\t\t<st c=\"22897\">Now, let’s create a</st> `<st c=\"22918\">PointMark</st>` <st c=\"22927\">chart based on</st> <st c=\"22943\">that array:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"23061\">Like previous charts, the</st> `<st c=\"23087\">PointMark</st>` <st c=\"23096\">structure</st> <st c=\"23106\">has</st> `<st c=\"23111\">x</st>` <st c=\"23112\">and</st> `<st c=\"23117\">y</st>` <st c=\"23118\">parameters.</st> <st c=\"23131\">The</st> `<st c=\"23135\">x</st>` <st c=\"23136\">parameter represents the hours studied, and the</st> `<st c=\"23185\">y</st>` <st c=\"23186\">parameter represents</st> <st c=\"23208\">the score.</st>\n\t\t\t*<st c=\"23218\">Figure 9</st>**<st c=\"23227\">.11</st>* <st c=\"23230\">shows what the</st> `<st c=\"23246\">PointMark</st>` <st c=\"23255\">chart looks like when running</st> <st c=\"23286\">the code:</st>\n\n\t\t\t![Figure 9.11: PointMark chart](img/B21795_09_11.jpg)\n\n\t\t\t<st c=\"23300\">Figure 9.11: PointMark chart</st>\n\t\t\t*<st c=\"23328\">Figure 9</st>**<st c=\"23337\">.11</st>* <st c=\"23340\">shows that most students achieve high grades when studying more hours.</st> <st c=\"23412\">We can also identify one student who managed to achieve a mid-level grade almost without studying</st> <st c=\"23510\">at all!</st>\n\t\t\t<st c=\"23517\">Even though PointMark is less common than the previous charts we reviewed, it can be helpful in financial, CRM, or</st> <st c=\"23633\">education apps.</st>\n\t\t\t<st c=\"23648\">Speaking of education apps, many apps require other types of charts.</st> <st c=\"23718\">That includes charts that are based on functions</st> <st c=\"23766\">and not datasets.</st> <st c=\"23785\">With Charts, we can also work more dynamically and straightforwardly visualize functions.</st> <st c=\"23875\">Let’s see how to</st> <st c=\"23892\">do that.</st>\n\t\t\t<st c=\"23900\">Visualizing functions with Charts</st>\n\t\t\t<st c=\"23934\">Until now, we have discussed</st> <st c=\"23963\">how to build charts using datasets, which include raw data</st> <st c=\"24022\">information such as sales figures, market shares, or usage trends.</st> <st c=\"24090\">However, we don’t have to use datasets to create charts, as functions can also perform as a data source for</st> <st c=\"24198\">our charts.</st>\n\t\t\t<st c=\"24209\">For example, we may want to display a normal distribution line graph next to our BarMark chart.</st> <st c=\"24306\">We could also create an education app that displays mathematical functions such as circles or a</st> <st c=\"24402\">sinus function.</st>\n\t\t\t<st c=\"24417\">To do that, we need to use a different</st> <st c=\"24456\">type of chart</st> <st c=\"24471\">called</st> **<st c=\"24478\">plot</st>**<st c=\"24482\">.</st>\n\t\t\t<st c=\"24483\">The Charts framework has two types of plots –</st> `<st c=\"24530\">LinePlot</st>` <st c=\"24538\">and</st> `<st c=\"24543\">AreaPlot</st>`<st c=\"24551\">. Let’s see an example of</st> `<st c=\"24577\">LinePlot</st>` <st c=\"24585\">sh</st><st c=\"24588\">owing a graph for a</st> <st c=\"24609\">sinus function:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"24681\">In this (very!) short code example, we added a</st> `<st c=\"24729\">LinePlot</st>` <st c=\"24737\">chart with a closure that returns the</st> `<st c=\"24776\">y</st>` <st c=\"24777\">value of a given</st> `<st c=\"24795\">x</st>` <st c=\"24796\">value.</st> <st c=\"24804\">In this case, we used a simple</st> `<st c=\"24835\">sin</st>` <st c=\"24838\">function.</st> *<st c=\"24849\">Figure 9</st>**<st c=\"24857\">.12</st>* <st c=\"24860\">shows what the chart</st> <st c=\"24882\">looks like:</st>\n\t\t\t![Figure 9.12: A LinePlot chart](img/B21795_09_12.jpg)\n\n\t\t\t<st c=\"24895\">Figure 9.12: A LinePlot chart</st>\n\t\t\t<st c=\"24924\">In</st> *<st c=\"24928\">Figure 9</st>**<st c=\"24936\">.12</st>*<st c=\"24939\">, we can see the</st> `<st c=\"24956\">LinePlot</st>` <st c=\"24964\">chart generated from a simple</st> <st c=\"24995\">mathematical function.</st>\n\t\t\t<st c=\"25017\">As mentioned earlier</st> <st c=\"25038\">in this section, the second chart type we can use to visualize</st> <st c=\"25101\">functions is</st> `<st c=\"25115\">AreaPlot</st>`<st c=\"25123\">, the equivalent</st> <st c=\"25140\">of</st> `<st c=\"25143\">AreaMark</st>`<st c=\"25151\">:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"25210\">In this code example, we only changed the chart type from</st> `<st c=\"25269\">LinePlot</st>` <st c=\"25277\">to</st> `<st c=\"25281\">AreaPlot</st>`<st c=\"25289\">.</st> `<st c=\"25291\">AreaPlot</st>` <st c=\"25299\">visualizes the function by filling the area it defines.</st> <st c=\"25356\">Let’s see the output in</st> *<st c=\"25380\">Figure 9</st>**<st c=\"25388\">.13</st>*<st c=\"25391\">:</st>\n\t\t\t![Figure 9.13: The AreaPlot chart type](img/B21795_09_13.jpg)\n\n\t\t\t<st c=\"25394\">Figure 9.13: The AreaPlot chart type</st>\n\t\t\t*<st c=\"25430\">Figure 9</st>**<st c=\"25439\">.13</st>* <st c=\"25442\">shows the same sinus function graph, now filled</st> <st c=\"25491\">with color.</st>\n\t\t\t<st c=\"25502\">Using the LinePlot and AreaPlot chart types to visualize math functions is about much more than just showing how the sinus function behaves.</st> <st c=\"25644\">It is excellent for education, scientific research, finance, health, and business apps.</st> <st c=\"25732\">Now that we know how to create LinePlot and AreaPlot, we have whole</st> <st c=\"25800\">new options.</st>\n\t\t\t<st c=\"25812\">We went over many chart</st> <st c=\"25836\">types, and by now, we can quickly</st> <st c=\"25870\">create charts, just like creating a</st> <st c=\"25907\">simple list!</st>\n\t\t\t<st c=\"25919\">The</st> **<st c=\"25924\">List</st>** <st c=\"25928\">type provides a way to interact</st> <st c=\"25960\">with its items, allowing us to navigate or delve into more information.</st> <st c=\"26033\">So, let’s see how to make our</st> <st c=\"26063\">charts interactive!</st>\n\t\t\t<st c=\"26082\">Allowing interaction using ChartProxy</st>\n\t\t\t<st c=\"26120\">Now that we know how to create</st> <st c=\"26151\">charts, let’s discover more hidden tricks by adding user interaction capabilities.</st> <st c=\"26235\">User interaction in charts, with its many uses, allows users to explore the chart’s data using touch.</st> <st c=\"26337\">Here are some use cases for user interaction</st> <st c=\"26382\">with charts:</st>\n\n\t\t\t\t*   `<st c=\"26446\">BarMark</st>` <st c=\"26453\">or</st> `<st c=\"26457\">SectorMark</st>` <st c=\"26467\">charts, the user can navigate to a new screen that shows additional information about the particular data point.</st> <st c=\"26581\">For example, if the</st> `<st c=\"26601\">BarMark</st>` <st c=\"26608\">chart shows information about watermelon sales, we can navigate the user to a screen that details the watermelon</st> <st c=\"26722\">sales deals.</st>\n\t\t\t\t*   `<st c=\"26794\">LineMark</st>` <st c=\"26802\">charts, for example, provides insights to the user on data points not originally part of the dataset if our</st> `<st c=\"26911\">LinkMark</st>` <st c=\"26919\">chart includes information about the growing population in a specific city over time, touching a particular point the chart can display the population value on a</st> <st c=\"27082\">specific date.</st>\n\t\t\t\t*   **<st c=\"27096\">Comparing data marks</st>**<st c=\"27117\">: The user can highlight and compare multiple data marks, which is extremely useful in</st> <st c=\"27205\">BarMark-based charts.</st>\n\n\t\t\t<st c=\"27226\">Moreover, learning how to add interaction capabilities can help us explore more things with our charts, such as how the charts are built and how their calculation</st> <st c=\"27390\">logic works.</st>\n\t\t\t<st c=\"27402\">To understand how interaction works, we need to get to know more Swift Charts</st> <st c=\"27481\">framework components:</st>\n\n\t\t\t\t*   `<st c=\"27502\">chartOverlay</st>`<st c=\"27515\">: This is a view modifier that helps us add an overlay view to a chart.</st> <st c=\"27588\">We can use the</st> `<st c=\"27603\">chartOverlay</st>` <st c=\"27615\">view modifier to add more graphic details to our chart, such as rulers and texts.</st> <st c=\"27698\">We can also use the</st> `<st c=\"27718\">chartOverlay</st>` <st c=\"27730\">view modifier to observe gestures and</st> <st c=\"27769\">user interaction.</st>\n\t\t\t\t*   `<st c=\"27786\">ChartProxy</st>`<st c=\"27797\">: This is a proxy that lets us access the chart values based on the chart area.</st> <st c=\"27878\">Using</st> `<st c=\"27884\">ChartProxy</st>`<st c=\"27894\">, we can convert locations to values and</st> <st c=\"27935\">vice versa.</st>\n\n\t\t\t`<st c=\"27946\">ChartOverlay</st>` <st c=\"27959\">and</st> `<st c=\"27964\">ChartProxy</st>` <st c=\"27974\">are essential components when handling user interaction; therefore, they come hand in hand.</st> <st c=\"28067\">When adding a</st> `<st c=\"28081\">chartOverlay</st>` <st c=\"28093\">view modifier, it comes with a prox</st><st c=\"28129\">y</st> <st c=\"28131\">to have complete access to</st> <st c=\"28159\">the chart.</st>\n\t\t\t<st c=\"28169\">Let’s try to take a LineMark chart and add a horizontal ruler that allows users to drag their fingers across it.</st> <st c=\"28283\">We’ll start by adding</st> <st c=\"28305\">an overlay.</st>\n\t\t\t<st c=\"28316\">Adding an overlay to our chart</st>\n\t\t\t<st c=\"28347\">The solution for providing</st> <st c=\"28374\">an overlay to our chart consists</st> <st c=\"28407\">of a common practice in SwiftUI using a view modifier.</st> <st c=\"28463\">Look at the following</st> <st c=\"28485\">code example:</st>\n\n```", "```swift\n .chartOverlay { proxy in\n            ZStack(alignment: .topLeading) {\n                    Rectangle().fill(.clear)\n                        .contentShape(Rectangle())\n                        .gesture(\n                            DragGesture()\n                                .onChanged { value in\n                            }\n                        )\n                    let lineHeight = proxy.plotSize.height\n                    Rectangle()\n                        .fill(.red)\n                        .frame(width: 2, height:\n                          lineHeight)\n                        .position(x: markerX, y:\n                          lineHeight/2)\n            }\n        }\n```", "```swift\n @State var markerX: CGFloat = 50\n```", "```swift\n .onChanged { value in <st c=\"30499\">mark</st><st c=\"30503\">erX = value.location.x</st>\n <st c=\"30526\">if let closestDate = getClosestDateForLocation(x:</st>\n <st c=\"30576\">value.location.x, proxy: proxy) {</st>\n <st c=\"30610\">if let positionX = proxy.position(forX:</st>\n <st c=\"30650\">closestDate) {</st>\n <st c=\"30665\">markerX = positionX</st> }\n}\n```", "```swift\n func getClosestDateForLocation(x: CGFloat, proxy: ChartProxy) -> Date? {\n        var returnedSalesFigure: SalesFigure? if let date = proxy.value(atX: x) as Date? {\n            var mDistance: TimeInterval = .infinity\n            for salesFigure in salesFigures {\n                let distance =\n                  abs(salesFigure.day.distance(to: date))\n                if distance < mDistance {\n                    returnedSalesFigure = salesFigure\n                    mDistance = distance\n                }\n            }\n        }\n        return returnedSalesFigure?.day\n    }\n```", "```swift\n if let date = proxy.value(atX: x) as Date? {\n```", "```swift\n func position<P>(forX value: P) -> CGFloat? where P : <st c=\"33289\">Plottable</st> public struct LineMark {\n     init<X, Y>(x: <st c=\"33338\">PlottableValue</st><X>, y: PlottableValue<Y>)\n     where X : <st c=\"33389\">Plottable</st>, Y : <st c=\"33404\">Plottable</st> }\n```", "```swift\n extension Date : Plottable, PrimitivePlottableProtocol\nextension String : Plottable, PrimitivePlottableProtocol\n```", "```swift\n struct Sales: Identifiable {\n    var id: UUID = UUID()\n    let itemType: String\n    let qty: Int <st c=\"34619\">var fruitColor: String = \"\"</st> }\n```", "```swift\n enum FruitType {\n    case Apples\n    case Oranges\n    case Watermelons\n}\nstruct Sales: Identifiable {\n    var id: UUID = UUID() <st c=\"35032\">let itemType: FruitType</st> let qty: Int\n    var fruitColor: String = \"\"\n}\n```", "```swift\n extension FruitType: <st c=\"35274\">Plottable</st> {\n    var <st c=\"35290\">primitivePlottable</st>: String {\n        rawValue\n    }\n}\n```", "```swift\n\n```", "```swift\n\n```"]