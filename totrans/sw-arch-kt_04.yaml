- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Peer-to-Peer and Client-Server Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter explores two fundamental architectural patterns for organizing
    and structuring communication systems: **peer-to-peer** (**P2P**) and **client-server**
    architectures. These architectural patterns have significantly impacted the way
    we design and implement various modern network systems.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a comprehensive understanding of the P2P and client-server
    architectures, in terms of their principles, characteristics, and applications.
    Afterward, we will compare and identify the crucial differences between these
    two approaches and analyze their respective strengths and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the trade-offs and pros and cons of the P2P and client-server
    architectures. More importantly, we will discuss factors to consider when deciding
    between these two models, with the desired system quality attributes such as scalability,
    fault tolerance, security, and control. We will also explore the possibility of
    a hybrid model for flexibility and adaptability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example of a networked system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-server architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P2P architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison between client-server and P2P architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example of a networked system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the same real-life example that we have been using in previous chapters.
    Households in a village exchange services with each other. Each household has
    an isolated copy of the software that keeps the records of the contract for exchanged
    services.
  prefs: []
  type: TYPE_NORMAL
- en: They are suffering an ongoing problem; that is, sometimes two households that
    exchanged services have a discrepancy between the contract records kept in their
    own copy of the software. This has caused a few disputes among households.
  prefs: []
  type: TYPE_NORMAL
- en: 'An engineer wants to eliminate these disputes by synchronizing the contracts
    between two copies of the software. The synchronization requires two copies of
    the software to be connected. An oversimplified interaction of the synchronization
    is illustrated in *Figure 4**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Synchronization of contracts for exchanged services among households](img/B21737_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Synchronization of contracts for exchanged services among households
  prefs: []
  type: TYPE_NORMAL
- en: In the diagram, *Household A* sends the details of the contract to *Household
    B*. The received contract is compared against the contract stored locally in *Household
    B*. *Household B* resolves the conflicts for any differences found. The revised
    contract (*contract’*) is then sent to *Household A*. *Household A* also compares
    the contracts and resolves any conflicts. *Household A* sends another revised
    contract (*contract’’*) to *Household B*. This time, *Household B* does not find
    any differences and therefore acknowledges *Household A* with the contract. *Household
    A* receives the acknowledgment from *Household B* and sends a final acknowledgment
    that both households have synchronized the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we have a way to synchronize contracts between two copies of the
    software, we still need a way for them to discover each other and communicate.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to explore the P2P and client-server architectures in the next
    section and relate them to the context of solving the problem in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-server architecture is a model for organizing distributed systems and
    computer networks. In this architecture, the roles of the client and the server
    are clearly defined, and each component plays at least one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clients are devices or components that request resources or services, and servers
    are the devices or components that serve requests or provide services. An example
    of client-server architecture over the internet is illustrated in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Client-server architecture (C1)](img/B21737_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Client-server architecture (C1)
  prefs: []
  type: TYPE_NORMAL
- en: Usually, clients are everyday user-facing devices such as laptops, phones, and
    televisions. They tend to be lightweight devices with limited computation power,
    and they usually only need to be available during communication with servers.
  prefs: []
  type: TYPE_NORMAL
- en: Servers are devices dedicated to serving requests and are usually hosted in
    the cloud or data centers. They usually have more computational power, more storage,
    and more network bandwidth, and are highly available to serve requests from clients.
    Systems with client-server architecture start with servers being available to
    serve requests from clients.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions between clients and servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interactions between clients and servers fall into a request-response model.
    Clients send to servers a request that identifies a resource or specifies the
    details of the service needed. Servers receive the request, validate it, process
    it, and send back a corresponding response containing the requested resources
    or the outcome of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Note that clients always initiate the interaction and have the knowledge of
    how to locate the servers. On the contrary, servers only know the location of
    the client within the context of the corresponding request.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the resources or services provided are centralized in servers.
    Clients do not directly communicate with other clients. Any resource that might
    need to be shared among clients is hosted on servers and is available to be requested
    by clients instead.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture results in much higher and broader non-functional requirements
    for servers compared to clients. We are now going to discuss some of the key system
    quality attributes in servers.
  prefs: []
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servers usually need to be available as much as possible, so they are operational
    to serve requests from clients whenever required. Typically, this means there
    are redundant instances of the servers running at the same time. There might be
    a failover mechanism to route requests to an available server, a backup system
    to recover the last known state of the server, and monitoring tools to proactively
    ensure servers are up.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servers are centralized to serve numerous clients at the same time. Being fast
    and efficient is paramount to sustaining servers to be operational. Latency and
    throughput are the two major system quality attributes for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Latency under client-server architecture is the total time that has elapsed
    between a request being sent from a client and the corresponding response being
    received by a client. Throughput is the number of requests that arrive in servers
    per time unit.
  prefs: []
  type: TYPE_NORMAL
- en: The performance of servers depends on multiple factors, such as processing power,
    memory, network bandwidth, and disk I/O. There are usually multiple components
    in servers that contribute to performance-related system quality attributes, such
    as filesystems, databases, messaging middleware, and even third-party systems.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servers sometimes need to cope with a growing and shrinking number of client
    requests. Here are some common approaches to managing this.
  prefs: []
  type: TYPE_NORMAL
- en: A load balancer can be deployed to distribute the requests from clients to a
    pool of servers. It keeps track of the health and traffic of each server instance
    so it can aim to route requests to the less busy server and archive an equal workload
    among servers.
  prefs: []
  type: TYPE_NORMAL
- en: Servers can be horizontally scaled by running more instances to distribute the
    load, or vertically scaled by upgrading the hardware capabilities of servers.
  prefs: []
  type: TYPE_NORMAL
- en: There should also be a configuration of a minimum or desired number of running
    server instances, so the number of servers can drop when the load is not heavy.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The requests are centralized to be served in servers and the corresponding data
    is also centralized in servers. Security becomes of significant importance. There
    are at least four major areas to address.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, servers should only process incoming requests that come from identifiable
    clients. Clients need to be authenticated by various means, such as passwords
    or multi-factor verifications. The details of the approaches will be covered in
    [*Chapter 14*](B21737_14.xhtml#_idTextAnchor442).
  prefs: []
  type: TYPE_NORMAL
- en: Servers should also have control over which requests can be accepted by which
    client. For example, a normal client cannot access system settings while an administrator
    client can. Clients are usually authorized by internal processes not visible outside
    servers, so clients are not able to bypass the checks.
  prefs: []
  type: TYPE_NORMAL
- en: The data in the request and response payload may contain personal or sensitive
    information that requires protection. In these cases, the communication between
    clients and servers may require encryption in an agreed-upon protocol. The encryption
    method may be personalized so that a client’s data cannot be read by other clients.
  prefs: []
  type: TYPE_NORMAL
- en: Servers will also need to have a basic defense against common malicious attacks,
    for example, **denial of service** (**DOS**), **cross-site scripting** (**XSS**),
    and **man in the** **middle** (**MitM**).
  prefs: []
  type: TYPE_NORMAL
- en: Server discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clients need to locate an available server to send their requests. There are
    several common discovery mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Static and hardcoded addresses as client configurations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Domain Name System** (**DNS**), which translates server IP addresses into
    human-readable domain names'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic DNS services that dynamically change the server addresses
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service registry services that allow clients to query the appropriate server
    to connect to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load balancers that distribute requests from clients to a pool of available
    servers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service mesh, which abstracts service discovery, load balancing, and other network
    concerns with a dedicated infrastructure layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Common client-server architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many variations of architecture styles that handle the communication
    between clients and servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PATCH`, and `DELETE`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/place` or `/update`) while using mostly only the GET and POST HTTP methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**As asynchronous messages**: In this architecture, clients and servers do
    not directly contact each other. Instead, they communicate through messaging infrastructure
    as queues and topics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**As two-way dedicated connections**: Clients and servers open a dedicated
    channel over a **Transmission Control Protocol** (**TCP**) connection to communicate.
    This style of communication is usually seen in systems that require lower latency
    and frequent messaging.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client-server solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to apply the client-server architecture to solve the real-life
    example of service contract synchronization between two households. It is recommended
    to draft the interactions between clients and servers before coding. Let us assume
    HTTP as the communication protocol.
  prefs: []
  type: TYPE_NORMAL
- en: We will use REST architecture in this solution. We need to define endpoints
    that are provided by servers so clients can use these endpoints to facilitate
    the necessary communication.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – defining client-server communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us illustrate a sample scenario of client-server communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Sample client-server interaction for service contract synchronization](img/B21737_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Sample client-server interaction for service contract synchronization
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the messages sent between clients and servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Household A* submits a draft of a service contract to servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household B* gets the service contract drafted by *Household A* from servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household B* revises the service contract and submits it to servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household A* gets the service contract revised by *Household B* from servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household A* acknowledges to the servers that it agrees with the service contract.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household B* gets the service contract agreed by *Household A* from servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household B* acknowledges to the servers that it agrees with the service contract.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household A* gets the service contract agreed upon by both households from
    the servers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From these messages, we can define a few HTTP endpoints to be called by clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT /contracts/{id}`: Submit a draft or revised service contract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /contracts/{id}`: Get a service contract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /contracts/{id}/agreedAt`: Acknowledge agreeing to a service contract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `{id}` is the unique identifier of the resource as the service contract.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – defining a message payload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The message payload used for `PUT` and `GET` endpoints needs to be defined.
    The service contract itself is the resource, so its model is the payload. The
    `PATCH` endpoint does not need to return a payload. The payload will be defined
    using the **OpenAPI 3.0** model, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity’s sake, the `ServiceContract` class is defined by an integer
    ID and two parties. Each party has the name of the household, the service provided,
    and an optional time when the household agrees with the service contract.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – defining API specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the three HTTP endpoints were identified in *step 1*, it is necessary
    to go into the details of each endpoint and define them as API specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Let us assume that only the two households in the service contract can see the
    service contract. This means we need certain ways to authenticate and authorize
    the `GET` endpoint. In this example, we enforce that the `GET` request should
    include a header to specify which household requests it. In production systems,
    it should use something more secure, such as a **JSON Web Token** (**JWT**) issued
    by a trusted **identity and access management** (**IAM**) system and the decoded
    token contains claims that would reveal the household name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there are two input parameters for the `GET` endpoint, as described
    here in the OpenAPI 3.0 model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first input parameter is the identifier of the service contract, shown in
    the URI path. The second input parameter is the household name, found in the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the response, we need to consider the success and failure cases. The
    possible outcomes should be captured as HTTP status codes in the response, documented
    in the OpenAPI 3.0 model shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The request can be valid, and the service contract exists, therefore an HTTP
    status code of `200` (OK) and the payload of the service contract are returned.
    The request could be initiated by a household not mentioned in the service contract,
    and therefore it is not authorized and an HTTP status code of 403 (Forbidden)
    is returned. Or the service contract of the given ID simply does not exist, and
    an HTTP status code of `404` (Not Found) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PUT` endpoint uses the same URI path variables and header values as the
    `GET` endpoint, and in addition, a request body, which is the service contract
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The request body is the `ServiceContract` component itself, so the schema refers
    to the specification of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response of the `PUT` endpoint is quite different from the `GET` endpoint.
    All the different scenarios are captured by the HTTP status codes in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, the service contract in the request payload may have used the same
    household names for both parties, and therefore it is not valid and an HTTP status
    code of `400` (Bad Request) is returned. Also, if the household name in the header
    does not appear in the service contract’s party section, then it is not authorized,
    and an HTTP status code of `403` (Forbidden) is returned. If the request is valid,
    there are two outcomes. If a new service contract is created in servers, the HTTP
    status code `201` (Created) is returned with the service contract as the payload.
    If an existing one is updated, then the HTTP status code `200` (OK) is returned
    instead, together with the service contract as the payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final endpoint, the `PATCH` endpoint, is simple. It uses the exact same
    set of input parameters as the `GET` endpoint, as there is no need for a request
    body and the request merely needs to identify an existing service contract. All
    responses are specified here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The failed outcomes in the response of the `PATCH` endpoint are the same as
    the `GET` endpoint, in identifying an existing service contract. But the successful
    outcome of the `PATCH` endpoint is different from the other two endpoints, because
    it has no request body, and therefore an HTTP status code of `204` (No Content)
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – server development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the API specifications, we are ready to develop server endpoints.
    The corresponding entities need to be defined in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is semantically equivalent to the OpenAPI 3.0 component definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to use a highly available storage system to keep service
    contracts permanently, for example, a database. However, in this example, we simplify
    the repository to keep service contracts in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This thread-safe in-memory map uses the integer IDs of the service contract
    as the keys and the `ServiceContract` objects as the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, **http4k** is used as the server framework because of its
    small code footprint. We need to set up the means to read and write different
    values. This is achieved by declaring a couple of **http4k Lenses** to validate
    and transform the payload into type-safe structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the Lens for `ServiceContract` objects as the body and the household
    name in the header. They will be used in the actual endpoint implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'http4k configures endpoint routing by simply declaring an `HTTPHandler` using
    the `route()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `route()` function, a list of endpoints is declared and the details
    of the implementation are defined. The following are the implementation details
    of the `GET` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This implementation defines the routing URI of `GET /contracts/{id}`. Then,
    it uses the http4k Lens defined previously to read the household name from the
    header. The service contract ID is also read from the path variable.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is an attempt to get the `ServiceContract` object from the in-memory
    map we defined previously. If the object is not found, an HTTP status of `404`
    (Not Found) is returned. If the service contract is found, but the household name
    in the header is not that of either party of the service contract, then an HTTP
    status of `403` (Forbidden) is returned. Otherwise, everything is fine, and an
    HTTP status of `200` (OK) is returned with the response body transformed from
    the `ServiceContract` object by the http4k Lens defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PUT` endpoint is also defined similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: However, the `PUT` endpoint transforms the request body into a `ServiceContract`
    object with the http4k Lens.
  prefs: []
  type: TYPE_NORMAL
- en: The service contract ID from the URI path variable is checked against the `ServiceContract`
    object to ensure that the ID is the same as the `id` field inside the object.
    Also, there is a validation to ensure that household names in each party of the
    `ServiceContract` object are different. Any validation failures here would result
    in returning an HTTP status code of `400` (Bad Request).
  prefs: []
  type: TYPE_NORMAL
- en: Like the `GET` endpoint, there is a check to ensure the household name in the
    header matches that of one of the parties in the `ServiceContract` object; otherwise,
    an HTTP status code of `403` (Forbidden) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, the `ServiceContract` object is put into the in-memory map. The `put`
    function returns the previous value associated with the key. If the previous value
    is `null`, then an HTTP status of `201` (Created) is returned; otherwise, an HTTP
    status of `200` (OK) is returned. Both cases come with the response body transformed
    from the `ServiceContract` object by the http4k Lens defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last endpoint, `PATCH`, has a very similar implementation to the `GET`
    endpoint in the first half. The same input parameters are read, and the servers
    attempt to get the `ServiceContract` object from the in-memory map. The first
    part of the implementation ends with the necessary validations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After validating the request, the household that agrees to the contract is
    located. An `agreedAt` timestamp is set to the relevant party of the contract.
    Also, the revised contract is put to the shared `ConcurrentHashMap` previously
    declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The second part of the implementation focuses on adding the `agreedAt` timestamp
    to the correct party of the `ServiceContract` object. Since validation has passed
    to ensure that the household is either one of the two, the servers determine which
    one it is and create a variant of the original `ServiceContract` object, with
    the `agreedAt` timestamp set to the current timestamp, using the `copy` function.
    The value in memory is then updated. An HTTP status code of `204` (No Content)
    is then returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function launches the server and starts listening to requests incoming
    on port `9000`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – client development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier, clients always initiate interactions with servers. So,
    the client implementation in this example reflects the client-server interaction
    in the sequence diagram in *Figure 4**.3*. For simplicity reasons, we use a `main`
    function to simulate both households in this example. We start with creating an
    HTTP client using **OKHTTP**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the initial service contract drafted by *Household A* is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the initial service contract is submitted to servers by calling the `PUT`
    endpoint. Subsequently, *Household B* received the initial service contract by
    calling the `GET` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Household B* revises the contract and submits the revised contract to the
    server by calling the `PUT` endpoint. Then, *Household A* receives the revised
    contract by calling the `GET` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Household A* is happy with the revised contract. *Household A* acknowledges
    its agreement to the service contract through the servers, by calling the `PATCH`
    endpoint. Now it is *Household B*’s turn to receive and acknowledge the service
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Household B* sees that *Household A* agreed to the service contract. *Household
    B* then also acknowledges its agreement to the service contract through the servers,
    by calling the `PUT` endpoint. Finally, it comes back to *Household A* to receive
    the service contract agreed by both households:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The client-service interaction in this example has concluded. The service contract
    between *Household A* and *Household B* is mutually agreed upon and synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this example implementation, we demonstrated how to divide the roles
    of clients and servers in solving the service contract synchronization problem
    with the client-server architecture.
  prefs: []
  type: TYPE_NORMAL
- en: What systems use client-server architecture?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Client-server architecture is widely used in many systems. Here are a couple
    of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**B2C systems**: Most **business-to-customer** (**B2C**) systems use client-server
    architecture, where the client is either a web browser or a mobile application.
    A client holds very little data, only data about the user. Meanwhile, servers
    hold most of the data of all clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**B2B systems**: Most **business-to-business** (**B2B**) systems use client-server
    architecture, where a part of the business system of a firm acts as a client to
    servers of another business system of another firm. These systems share some data
    because of the communication between clients and servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online gaming**: Many online games use client-server architecture to maintain
    a shared state of the game among multiple players. The game client runs on players’
    devices and communicates with the game server to synchronize states and interact
    with other players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Financial service systems**: Finance services are heavily regulated by various
    authorities and there are strict rules on how the data is stored and distributed.
    Client-server architecture can keep unnecessary data away from clients and have
    servers keeping sensitive data and complying with regulatory and audit controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instant messaging, chat, and email systems**: Popular messaging platforms
    such as Slack, WhatsApp, Discord, and Microsoft Outlook use the client-server
    architecture. Clients connect to the servers to send and receive messages to other
    clients, broadcast messages to a group of clients, share files, and participate
    in real-time chat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming next, we will explore another option, P2P architecture, and how the same
    problem of the households and their service contracts can be solved differently.
  prefs: []
  type: TYPE_NORMAL
- en: P2P architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: P2P architecture is rooted in the idea of the absence of a centralized authority
    for coordination. A P2P network is formed of numerous nodes (“peers”) that have
    equal roles in communicating with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Each node can request resources or services from other nodes, while also providing
    resources or services to other nodes. This distributed nature of P2P networks
    enables efficient resource sharing and collaboration among participants.
  prefs: []
  type: TYPE_NORMAL
- en: There is no hard non-functional requirement on the computational power, storage,
    and network bandwidth for each node coming from the P2P architecture. However,
    consistency is a major non-functional concern in many P2P systems.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no central authority or server that controls the data in a P2P system.
    Each node stores and manages its own data, and the nodes communicate directly
    with each other to share and synchronize information. This distributed nature
    of P2P systems brings several consistency challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data replication and concurrency control**: A node in a P2P system often
    replicates its data across multiple nodes to improve availability and fault tolerance.
    This replication can lead to inconsistencies if the data is modified at different
    nodes at the same time. It is crucial that updates are propagated to all relevant
    nodes in a timely manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, if multiple nodes update the same data at the same time, there is
    a conflict about which update should take place. Implementing effective concurrency
    control mechanisms, such as locking, versioning, or conflict resolution strategies,
    is necessary to maintain data consistency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Eventual consistency**: In a distributed network where nodes are spread out,
    delays and partitions can occur, making it difficult to achieve strong and immediate
    consistency. Instead, **peer-to-peer** (**P2P**) systems focus on eventual consistency,
    meaning that a consistent state will eventually be reached after some time, even
    in the presence of network disruptions or node failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Causal consistency**: Another option for consistency is causal consistency,
    where related events are received by all nodes in the same order, and unrelated
    events are received in any order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consensus and Quorum**: In some P2P systems, all nodes must reach a specific
    state or be updated before changes are accepted. This is known as the consensus
    approach. Alternatively, a quorum-based approach requires agreement from only
    a majority of nodes. Both methods help maintain a certain level of consistency
    but introduce extra coordination and communication overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merkle trees and hashing**: Merkle trees or hash-based approaches can be
    used to efficiently detect and resolve inconsistencies in the distributed data,
    allowing nodes to quickly identify and synchronize their data. These approaches
    are widely used in decentralized systems such as blockchain networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping and node discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A P2P network starts with the first node available, and then other nodes join.
    This process is called **bootstrapping**. Before a new node joins an existing
    P2P network, the new node must somehow discover at least one other node in the
    network. We will now cover several node discovery mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Static
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most basic way to discover a node is that each node has the addresses of
    all other nodes in static configurations. The obvious limitation of this approach
    is the number of nodes that can be configured. The limitation of IP addresses
    can be overcome by techniques such as **relay servers**, **network address translation**
    (**NAT**), and **hole-punching**. This is about storage and memory limitations
    to hold the addresses of all nodes in each node.
  prefs: []
  type: TYPE_NORMAL
- en: A P2P network with static node discovery can be bootstrapped by attempting to
    connect each node from the static configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Contrary to the concept of decentralization, some P2P networks have a centralized
    directory that maintains a list of active nodes in the network. That means the
    network starts with the centralized directory being available. When a node joins
    the network, it lists itself as available in the directory. Also, each node can
    get a list of available nodes from the centralized directory.
  prefs: []
  type: TYPE_NORMAL
- en: The centralized directory falls into the category of servers, which requires
    very different system quality attributes from other nodes. For example, the centralized
    directory must be highly available; otherwise, it cannot accept new nodes or provide
    a list of available nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast or broadcast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a private or **local area network** (**LAN**), a P2P network can be established
    by having each node send broadcast or multicast messages to all other nodes. A
    couple of nodes can decide to respond, and the originator node is able to discover
    them. The network is started the first time a node is discovered. This discovery
    mechanism is suitable only for small networks with a limited number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast networks usually use **User Datagram Protocol** (**UDP**) as the transport
    protocol. This is usually configured in a designated subnet to avoid broadcast
    floods and limit security risks.
  prefs: []
  type: TYPE_NORMAL
- en: Kademlia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Kademlia** is a specification of the network structure and message protocol
    that is used in P2P networks. A **distributed hash table** (**DHT**) emerges across
    multiple nodes in the network. The network usually uses multicast UDP as the transport
    protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: Each node has a node ID, which is usually an unsigned big random integer number.
    The node ID prefix is used to calculate a hash value using a universal hash function.
    The hash value translates to a bucket in the hash table, and this is how each
    node maintains the IDs of other nodes in its local hash table and uses it as a
    routing table.
  prefs: []
  type: TYPE_NORMAL
- en: When a node joins the network, it broadcasts its node ID to all nodes in the
    network. Then, other nodes find a bucket to keep the ID of the new node in their
    routing tables.
  prefs: []
  type: TYPE_NORMAL
- en: Node IDs that are close to each other have their buckets close to each other
    as well. The “distance” between two node IDs calculated by the **exclusive OR**
    (**XOR**) function is used for node discovery. When a node wants to discover another
    node in the network, it starts from the bucket that is closest to its node ID
    and iteratively finds a responsive node by traversing buckets, from the closest
    to the farthest away.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging information with other nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nodes can share their own nodes among themselves as well. The exchange among
    nodes comes with a few variations.
  prefs: []
  type: TYPE_NORMAL
- en: If the P2P network has a well-known structure, such as a DHT, a node can crawl
    the structure using a certain protocol to query nodes for information about other
    nodes. The downside is that a newly joined node would still need another mechanism
    to get an initial list of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A newly joined node can also contact a few bootstrapping nodes to query information
    about other nodes. This does, however, rely on the availability of the well-known
    bootstrapping nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A gossip protocol can also be employed among nodes to periodically share information
    with a few random neighbor nodes. The information should collectively spread like
    gossiping or an epidemic, though it takes some time to emerge. This protocol scales
    very well from small to big networks. It is also fault-tolerant, which means if
    a neighbor node fails, other neighbor nodes would still be able to provide alternative
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Communication among nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a node has information on how to contact other nodes in the network, it
    can initiate communication.
  prefs: []
  type: TYPE_NORMAL
- en: Direct communication with IP addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most basic form of communication between two nodes is to have one node directly
    contact another node using an IP address. This approach is often used in small
    networks or LANs. Nodes in the network use transport protocols such as TCP for
    more reliable and ordered messages, or they use UDP for faster and unordered messages.
  prefs: []
  type: TYPE_NORMAL
- en: Hole-punching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a node under one local network to connect to another node under another
    local network, the nodes are not able to use IP addresses for direct communication.
    Let us consider the situation in the following sample network topology. See *Figure
    4**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – A sample network topology with home networks](img/B21737_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – A sample network topology with home networks
  prefs: []
  type: TYPE_NORMAL
- en: '*Node 1* has no direct way to communicate with *Node 2* via the internet, since
    both nodes are behind their own home networks. However, if the home networks and
    **internet service provider** (**ISP**) networks support NAT, then **hole-punching**
    can be employed to allow *Node 1* to indirectly communicate with *Node 2* with
    this relay mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'NAT is a mechanism that translates local network addresses to public and global
    IP addresses. As a result, both *Node 1* and *Node 2* have their own global IP
    addresses, and they can communicate with each other. This is illustrated in the
    diagram here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A sample network topology with home networks and NATs](img/B21737_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – A sample network topology with home networks and NATs
  prefs: []
  type: TYPE_NORMAL
- en: '*Node 1* has opened its port `443` to receive messages and can be located by
    the private IP address `192.168.1.10` under its home network. Its home network
    has a NAT mapping of `192.168.1.10:443` (as an internal address) to `10.168.3.234:80006`
    (as an external address). Then, the ISP network also has a NAT mapping of an internal
    address of `10.168.3.234:80006` to a global address of `108.27.39.3:24390`. *Node
    2* has a similar NAT mapping path except its global address is `23.1.80.0:2877`.'
  prefs: []
  type: TYPE_NORMAL
- en: From this point, we can start the hole-punching in steps, and assume *Node 1*
    has already discovered *Node 2*’s global address. Firstly, *Node 1* contacts its
    home network with the source local address (*Node 1*) and the target global address
    (*Node 2*). Then, the home network relays this information and contacts its ISP
    network similarly.
  prefs: []
  type: TYPE_NORMAL
- en: The ISP network where *Node 1* originated then contacts another ISP network
    where *Node 2* originated, using the global address.
  prefs: []
  type: TYPE_NORMAL
- en: The ISP network where *Node 2* originated contacts the target local home network
    with the translated address local to the ISP network. Then, the home network contacts
    the target *Node 2* in its network with the translated address local to the home
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The NATs punch temporary *holes* in their respective tables where they translate
    internal and external addresses. As a result, *Node A* and *Node B* can establish
    communication with multiple networks and NATs in the middle to relay messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note that hole-punching behind firewalls would not work if the firewalls were
    stateless. Stateless firewalls do not track connections and do not remember the
    translations of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Publish-subscribe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Publish-subscribe** is an alternative model for P2P communication, where
    node discovery is not necessary. Instead, nodes publish messages to specific topics
    of interest, and other nodes subscribed to those topics would receive the messages.
    If the messages are delivered with a broker, then nodes still need to know the
    address of the broker to publish and receive messages. Publish-subscribe removes
    the need for node discovery and spreads information efficiently to relevant receivers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a publish-subscribe architecture with a broker is shown in *Figure
    4**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Publish-subscribe architecture](img/B21737_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Publish-subscribe architecture
  prefs: []
  type: TYPE_NORMAL
- en: The publisher does not know the subscribers. It knows the address of the broker
    and the topic where a message should be published. Subscribers register their
    interests in certain topics with the broker and receive messages associated with
    the topics.
  prefs: []
  type: TYPE_NORMAL
- en: The broker is a type of infrastructure middleware that receives messages from
    publishers. It stores the messages and manages subscriptions by subscribers. Most
    importantly, it routes messages to the appropriate subscribers based on their
    registered interests.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to delve into the implementation of the P2P solution.
  prefs: []
  type: TYPE_NORMAL
- en: The P2P solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to apply the P2P architecture to solve a real-life example of service
    contract synchronization between two households. For simplicity’s sake, let us
    assume the two households have already discovered each other and their devices
    run in the same local network.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – defining P2P communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to draft the interactions between nodes before coding. Let us
    assume that UDP is used as the communication protocol. Nodes communicate directly
    with each other, using IP addresses and ports. See *Figure 4**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Sample P2P interaction service contract synchronization](img/B21737_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Sample P2P interaction service contract synchronization
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the messages sent between the nodes of *Household A* and
    *Household B* as described in *Figure 4**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Household A* submits a draft of a service contract to *Household B*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household B* revises the service contract and submits it to *Household A*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household A* acknowledges to *Household B* that it agrees with the service
    contract.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household B* acknowledges to *Household A* that it agrees with the service
    contract.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the communication protocol is defined, the message’s payload should be
    defined as the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – defining the message payload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the communication defined previously, the only message that passes around
    is the service contract itself. The model of the service contract remains the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we externalize the `ServiceContract` class as a byte array
    to be sent across the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – peer development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start with scaffolding some necessary transport functions for nodes
    to communicate using UDP. As a node can produce and consume a message, it seems
    sensible to define a generic UDP node class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UdpNode` class uses the **Non-Blocking Input/Output** (**NIO**) package
    to support three major functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a message to a target node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving a message from another node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While supporting these functions, the `UdpNode` class should only be changed
    if the transport mechanism needs to change, leaving it with a single responsibility
    of addressing concerns at the transport level, and conforming to the **single-responsibility
    principle**.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the serialization and deserialization of the `ServiceContract` class
    is delegated to the `DtoConvertor` interface with generic type `T`, so the `UdpNode`
    class is not coupled to the `ServiceContract` class.
  prefs: []
  type: TYPE_NORMAL
- en: The handling of and responding to a `ServiceContract` object is an application-level
    concern, and this concern is delegated to a transformer lambda from the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `start` function of the `UdpNode` class is simple. It binds the node to
    the configured address and gets it ready to consume a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `produce` function clears the outbound buffer before it calls `DtoConvertor`
    to write on it. Then, the buffer is sent to the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `consume` function clears the inbound buffer first, then the channel receives
    the byte array and writes it to the buffer. Then, `DtoConvertor` is called to
    convert the byte array into a `ServiceContract` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The transformer lambda is called to determine the response to the `ServiceContract`
    object. If the response is `null`, then nothing happens. If the response is another
    `ServiceContract` object, then the `produce` function is called to send the response
    back to the node that sends the original message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important class in this example is `DtoConvertor`. It is designed to
    be generic and to encapsulate the serialization and deserialization of a generic
    type, `E`, to a byte array. There are only three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `allocate` function creates a `ByteBuffer` that is large enough to hold
    the designated type. The `toBuffer` function writes a `E` to `ByteBuffer`, and
    the `fromBuffer` function reads a DTO of type `E` from `ByteBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Kotlin singleton, `ServiceContractConvertor`, is declared to implement the
    `DtoConvertor` interface with the `ServiceContract` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toBuffer` function writes each field in a `ServiceContract` object in
    a certain order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fromBuffer` function reads from a `ByteBuffer` each field of the `ServiceContract`
    object in the same order and returns the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, there are two `main` functions, one for *Household A* and one for *Household
    B*, to represent how each of them negotiates the service contract.
  prefs: []
  type: TYPE_NORMAL
- en: '*Household A*’s behaviors are defined in the following code block, and then
    the node starts listening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Household A* does not respond to a `ServiceContract` object under the following
    circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: The same household name appears in both parties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both households have already agreed to the contract
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Household A* is not involved in any party'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, *Household A* agrees with `ServiceContract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then, *Household A* sends the draft contract to *Household B*. At the end, *Household
    A* enters an infinite loop to try to consume any further messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, *Household B* has its behaviors defined in another `main`
    function and then it starts listening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, *Household B* does not respond to a `ServiceContract` object under
    the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: The same household name appears in both parties as it is not valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both households have already agreed to the contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Household B* is not involved in any party'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Household B* would revise the service received in the contract from *Cleaning*
    to *Babysitting*, and *Household B* would accept if the service received were
    *Babysitting*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When both `main` functions run, we should see the two nodes representing *Household
    A* and *Household B* negotiating the service contract. Eventually, the service
    contract is mutually agreed upon and synchronized. We should see an output like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Household A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Household B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have demonstrated how to solve the service contract synchronization
    problem using UDP. To fully demonstrate the P2P network, there must be numerous
    nodes available to send and receive messages in a multicast UDP network. Moreover,
    there should be a data replication and consistency mechanism among the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: What systems use P2P architecture?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'P2P architecture is used in a few common systems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Napster** was one of the earliest P2P systems that was commonly used by people
    to share files on the internet. Napster used a centralized directory server to
    maintain an index of available files and their locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BitTorrent** is a popular P2P protocol used to distribute large files on
    the internet. It breaks down large files into smaller pieces and allows each piece
    to be shared independently. Users download and upload these pieces simultaneously.
    Upon completion, BitTorrent combines the pieces back into a file for users. BitTorrent
    has reduced the need for centralization for file sharing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralized finance** (**DeFi**) is a more recent example. Cryptocurrencies
    such as **Bitcoin** and **Ethereum** operate on P2P networks. Nodes in the network
    communicate and validate transactions without relying on a central authority,
    using a consensus algorithm. This distributed and synchronized share state enables
    decentralized and trustless digital currency systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now going to compare the two architectures, client-server and P2P, to
    see which architecture is more useful in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between client-server and P2P architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-server and P2P architectures should be seen as a spectrum of models ranging
    from centralization to decentralization, with a lot of viable hybrid models in
    between the two. See *Figure 4**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The spectrum from decentralized to centralized architectures](img/B21737_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The spectrum from decentralized to centralized architectures
  prefs: []
  type: TYPE_NORMAL
- en: Centralized architectures have simpler ways of achieving strong consistency,
    and decentralized architectures have more complex ways of achieving usually weaker
    consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Client-server architectures are useful in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a need for central control and management, typically applicable to
    industries under regulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are mission-critical processes that require systems to be highly available,
    resilient, and consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot of data to be collected and correlated, and the data needs to
    be consistent, replicated, secure, and accessed in a secure manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the contrary, P2P architectures are useful in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a need to avoid the high cost of hosting servers and to make use of
    the existing resources of the peer nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a need to share resources freely without central control or censorship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a need to avoid relying on a subset of processing that could result
    in total system failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have delved into two important architectures, **client-server** and **P2P**,
    with the context of solving the synchronization problem of a real-life example
    of a service contract between households.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how systems of each architecture can be bootstrapped, and which
    system quality attributes are required for each architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We have also demonstrated in Kotlin code how the synchronization problem can
    be solved by each architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We have described a couple of real-life systems that employ client-server and
    P2P architectures. We have also compared the two.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a brief understanding of the two architectures and what
    problems they solve, and also be able to reason which architecture can be used
    in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapter, we are going to explore the architecture patterns often
    used in the frontend.
  prefs: []
  type: TYPE_NORMAL
