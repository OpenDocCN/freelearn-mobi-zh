- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Peer-to-Peer and Client-Server Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对等网络和客户端-服务器架构
- en: 'This chapter explores two fundamental architectural patterns for organizing
    and structuring communication systems: **peer-to-peer** (**P2P**) and **client-server**
    architectures. These architectural patterns have significantly impacted the way
    we design and implement various modern network systems.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了两种组织和结构化通信系统的基本架构模式：**对等网络**（**P2P**）和**客户端-服务器**架构。这些架构模式对我们设计和实现各种现代网络系统的方式产生了重大影响。
- en: This chapter provides a comprehensive understanding of the P2P and client-server
    architectures, in terms of their principles, characteristics, and applications.
    Afterward, we will compare and identify the crucial differences between these
    two approaches and analyze their respective strengths and limitations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从原理、特性和应用等方面全面介绍了 P2P 和客户端-服务器架构。之后，我们将比较并确定这两种方法之间的关键差异，并分析各自的优缺点。
- en: We will cover the trade-offs and pros and cons of the P2P and client-server
    architectures. More importantly, we will discuss factors to consider when deciding
    between these two models, with the desired system quality attributes such as scalability,
    fault tolerance, security, and control. We will also explore the possibility of
    a hybrid model for flexibility and adaptability.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖 P2P 和客户端-服务器架构的权衡利弊。更重要的是，我们将讨论在决定这两种模型时需要考虑的因素，包括期望的系统质量属性，如可扩展性、容错性、安全性和控制。我们还将探讨混合模型的可能性，以实现灵活性和适应性。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: A real-life example of a networked system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络化系统的真实示例
- en: Client-server architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: P2P architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P2P 架构
- en: Comparison between client-server and P2P architectures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器架构与 P2P 架构的比较
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章使用的所有代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-4)
- en: A real-life example of a networked system
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个网络化系统的真实示例
- en: We will use the same real-life example that we have been using in previous chapters.
    Households in a village exchange services with each other. Each household has
    an isolated copy of the software that keeps the records of the contract for exchanged
    services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在前几章中一直在使用的真实示例。村庄中的家庭相互交换服务。每个家庭都有一个独立的软件副本，用于保存交换服务的合同记录。
- en: They are suffering an ongoing problem; that is, sometimes two households that
    exchanged services have a discrepancy between the contract records kept in their
    own copy of the software. This has caused a few disputes among households.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 他们正在遭受一个持续的问题；那就是，有时两个交换服务的家庭在他们自己的软件副本中保留的合同记录之间存在差异。这导致了一些家庭之间的纠纷。
- en: 'An engineer wants to eliminate these disputes by synchronizing the contracts
    between two copies of the software. The synchronization requires two copies of
    the software to be connected. An oversimplified interaction of the synchronization
    is illustrated in *Figure 4**.1*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工程师希望通过同步两个软件副本之间的合同来消除这些纠纷。同步需要两个软件副本连接起来。同步的简化交互在*图 4**.1*中展示：
- en: '![Figure 4.1 – Synchronization of contracts for exchanged services among households](img/B21737_04_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 家庭间交换服务的合同同步](img/B21737_04_1.jpg)'
- en: Figure 4.1 – Synchronization of contracts for exchanged services among households
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 家庭间交换服务的合同同步
- en: In the diagram, *Household A* sends the details of the contract to *Household
    B*. The received contract is compared against the contract stored locally in *Household
    B*. *Household B* resolves the conflicts for any differences found. The revised
    contract (*contract’*) is then sent to *Household A*. *Household A* also compares
    the contracts and resolves any conflicts. *Household A* sends another revised
    contract (*contract’’*) to *Household B*. This time, *Household B* does not find
    any differences and therefore acknowledges *Household A* with the contract. *Household
    A* receives the acknowledgment from *Household B* and sends a final acknowledgment
    that both households have synchronized the contract.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，*家庭A*将合同的详细信息发送给*家庭B*。接收到的合同与*家庭B*本地存储的合同进行比较。*家庭B*解决发现的任何差异。然后，修改后的合同（*contract’*）被发送给*家庭A*。*家庭A*也对比合同并解决任何冲突。*家庭A*将另一个修改后的合同（*contract’’*）发送给*家庭B*。这次，*家庭B*没有发现任何差异，因此用合同确认了*家庭A*。*家庭A*从*家庭B*那里收到确认并发出最终确认，表明两个家庭已同步合同。
- en: Given that we have a way to synchronize contracts between two copies of the
    software, we still need a way for them to discover each other and communicate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有一种在软件的两个副本之间同步合同的方法，我们还需要一种让它们发现彼此并通信的方法。
- en: We are going to explore the P2P and client-server architectures in the next
    section and relate them to the context of solving the problem in this example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨P2P和客户端-服务器架构，并将它们与解决本例中问题的上下文联系起来。
- en: Client-server architecture
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: Client-server architecture is a model for organizing distributed systems and
    computer networks. In this architecture, the roles of the client and the server
    are clearly defined, and each component plays at least one of them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构是一种组织分布式系统和计算机网络的模式。在这个架构中，客户端和服务器的作用被明确定义，每个组件至少扮演其中一个角色。
- en: 'Clients are devices or components that request resources or services, and servers
    are the devices or components that serve requests or provide services. An example
    of client-server architecture over the internet is illustrated in *Figure 4**.2*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是请求资源或服务的设备或组件，而服务器是处理请求或提供服务的设备或组件。互联网上的客户端-服务器架构的示例在*图4.2*中说明：
- en: '![Figure 4.2 – Client-server architecture (C1)](img/B21737_04_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 客户端-服务器架构 (C1)](img/B21737_04_2.jpg)'
- en: Figure 4.2 – Client-server architecture (C1)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 客户端-服务器架构 (C1)
- en: Usually, clients are everyday user-facing devices such as laptops, phones, and
    televisions. They tend to be lightweight devices with limited computation power,
    and they usually only need to be available during communication with servers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，客户端是面向日常用户的设备，如笔记本电脑、手机和电视。它们往往是轻量级的设备，计算能力有限，并且通常只需要在与服务器通信时可用。
- en: Servers are devices dedicated to serving requests and are usually hosted in
    the cloud or data centers. They usually have more computational power, more storage,
    and more network bandwidth, and are highly available to serve requests from clients.
    Systems with client-server architecture start with servers being available to
    serve requests from clients.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是专门用于处理请求的设备，通常托管在云或数据中心。它们通常具有更多的计算能力、更多的存储和更多的网络带宽，并且高度可用以服务来自客户端的请求。具有客户端-服务器架构的系统从服务器可用以服务客户端请求开始。
- en: Interactions between clients and servers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端与服务器之间的交互
- en: Interactions between clients and servers fall into a request-response model.
    Clients send to servers a request that identifies a resource or specifies the
    details of the service needed. Servers receive the request, validate it, process
    it, and send back a corresponding response containing the requested resources
    or the outcome of the service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与服务器之间的交互属于请求-响应模型。客户端向服务器发送一个请求，该请求标识一个资源或指定所需服务的详细信息。服务器接收请求，验证它，处理它，并返回一个相应的响应，其中包含请求的资源或服务的结果。
- en: Note that clients always initiate the interaction and have the knowledge of
    how to locate the servers. On the contrary, servers only know the location of
    the client within the context of the corresponding request.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，客户端总是发起交互，并知道如何定位服务器。相反，服务器只知道在相应请求的上下文中客户端的位置。
- en: As a result, the resources or services provided are centralized in servers.
    Clients do not directly communicate with other clients. Any resource that might
    need to be shared among clients is hosted on servers and is available to be requested
    by clients instead.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，提供的资源或服务集中在服务器上。客户端不直接与其他客户端通信。任何可能需要在客户端之间共享的资源都托管在服务器上，并可供客户端请求。
- en: This architecture results in much higher and broader non-functional requirements
    for servers compared to clients. We are now going to discuss some of the key system
    quality attributes in servers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构导致服务器相对于客户端具有更高的非功能性需求。我们现在将讨论服务器中的一些关键系统质量属性。
- en: Availability
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性
- en: Servers usually need to be available as much as possible, so they are operational
    to serve requests from clients whenever required. Typically, this means there
    are redundant instances of the servers running at the same time. There might be
    a failover mechanism to route requests to an available server, a backup system
    to recover the last known state of the server, and monitoring tools to proactively
    ensure servers are up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通常需要尽可能多地保持可用状态，以便在需要时能够服务客户端的请求。通常这意味着有多个服务器实例同时运行。可能存在故障转移机制，将请求路由到可用的服务器，备份系统以恢复服务器最后已知状态，以及监控工具以主动确保服务器处于运行状态。
- en: Performance
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Servers are centralized to serve numerous clients at the same time. Being fast
    and efficient is paramount to sustaining servers to be operational. Latency and
    throughput are the two major system quality attributes for performance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器集中以同时为众多客户端提供服务。快速和高效对于维持服务器运行至关重要。延迟和吞吐量是性能的两个主要系统质量属性。
- en: Latency under client-server architecture is the total time that has elapsed
    between a request being sent from a client and the corresponding response being
    received by a client. Throughput is the number of requests that arrive in servers
    per time unit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器架构中，延迟是指从客户端发送请求到客户端接收到相应响应所经过的总时间。吞吐量是单位时间内到达服务器的请求数量。
- en: The performance of servers depends on multiple factors, such as processing power,
    memory, network bandwidth, and disk I/O. There are usually multiple components
    in servers that contribute to performance-related system quality attributes, such
    as filesystems, databases, messaging middleware, and even third-party systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的性能取决于多个因素，例如处理能力、内存、网络带宽和磁盘I/O。服务器中通常有多个组件有助于性能相关的系统质量属性，例如文件系统、数据库、消息中间件，甚至第三方系统。
- en: Scalability
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Servers sometimes need to cope with a growing and shrinking number of client
    requests. Here are some common approaches to managing this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器有时需要应对客户端请求数量的增长和减少。以下是一些常见的管理方法。
- en: A load balancer can be deployed to distribute the requests from clients to a
    pool of servers. It keeps track of the health and traffic of each server instance
    so it can aim to route requests to the less busy server and archive an equal workload
    among servers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以部署负载均衡器来将客户端的请求分配到一组服务器。它跟踪每个服务器实例的健康状况和流量，以便可以将请求路由到较不繁忙的服务器，并在服务器之间实现均衡的工作负载。
- en: Servers can be horizontally scaled by running more instances to distribute the
    load, or vertically scaled by upgrading the hardware capabilities of servers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以通过运行更多实例来水平扩展以分配负载，或者通过升级服务器的硬件能力来垂直扩展。
- en: There should also be a configuration of a minimum or desired number of running
    server instances, so the number of servers can drop when the load is not heavy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应该配置一个最小或期望运行的服务器实例数量，以便在负载不重时服务器数量可以减少。
- en: Security
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: The requests are centralized to be served in servers and the corresponding data
    is also centralized in servers. Security becomes of significant importance. There
    are at least four major areas to address.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请求被集中到服务器上提供服务，相应数据也集中存储在服务器上。安全性变得极为重要。至少有四个主要领域需要解决。
- en: Firstly, servers should only process incoming requests that come from identifiable
    clients. Clients need to be authenticated by various means, such as passwords
    or multi-factor verifications. The details of the approaches will be covered in
    [*Chapter 14*](B21737_14.xhtml#_idTextAnchor442).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器应仅处理来自可识别客户端的传入请求。客户端需要通过各种方式（如密码或多因素验证）进行身份验证。这些方法的细节将在[*第14章*](B21737_14.xhtml#_idTextAnchor442)中介绍。
- en: Servers should also have control over which requests can be accepted by which
    client. For example, a normal client cannot access system settings while an administrator
    client can. Clients are usually authorized by internal processes not visible outside
    servers, so clients are not able to bypass the checks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器还应控制哪些请求可以被哪些客户端接受。例如，普通客户端无法访问系统设置，而管理员客户端可以。客户端通常通过服务器外部不可见的内部流程进行授权，因此客户端无法绕过检查。
- en: The data in the request and response payload may contain personal or sensitive
    information that requires protection. In these cases, the communication between
    clients and servers may require encryption in an agreed-upon protocol. The encryption
    method may be personalized so that a client’s data cannot be read by other clients.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应负载中的数据可能包含需要保护的个人或敏感信息。在这些情况下，客户端和服务器之间的通信可能需要在协议中实现加密。加密方法可以是个性化的，这样其他客户端就无法读取客户端的数据。
- en: Servers will also need to have a basic defense against common malicious attacks,
    for example, **denial of service** (**DOS**), **cross-site scripting** (**XSS**),
    and **man in the** **middle** (**MitM**).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器还需要对常见的恶意攻击有基本的防御措施，例如，**拒绝服务**（**DOS**）、**跨站脚本**（**XSS**）和**中间人攻击**（**MitM**）。
- en: Server discovery
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器发现
- en: 'Clients need to locate an available server to send their requests. There are
    several common discovery mechanisms:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端需要定位一个可用的服务器来发送它们的请求。存在几种常见的发现机制：
- en: Static and hardcoded addresses as client configurations
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态和硬编码的地址作为客户端配置。
- en: '**Domain Name System** (**DNS**), which translates server IP addresses into
    human-readable domain names'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**域名系统**（**DNS**），它将服务器IP地址转换为人类可读的域名。'
- en: Dynamic DNS services that dynamically change the server addresses
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态DNS服务，动态更改服务器地址。
- en: Service registry services that allow clients to query the appropriate server
    to connect to
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务注册服务，允许客户端查询要连接的适当服务器。
- en: Load balancers that distribute requests from clients to a pool of available
    servers
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负载均衡器，将客户端请求分配到一组可用的服务器。
- en: Service mesh, which abstracts service discovery, load balancing, and other network
    concerns with a dedicated infrastructure layer
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务网格，它通过专用基础设施层抽象化服务发现、负载均衡和其他网络问题。
- en: Common client-server architectures
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的客户端-服务器架构
- en: 'There are many variations of architecture styles that handle the communication
    between clients and servers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多处理客户端和服务器之间通信的架构风格变体：
- en: '`GET`, `POST`, `PATCH`, and `DELETE`.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PATCH`和`DELETE`。'
- en: '`/place` or `/update`) while using mostly only the GET and POST HTTP methods.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用GET和POST HTTP方法时，主要使用`/place`或`/update`。
- en: '**As asynchronous messages**: In this architecture, clients and servers do
    not directly contact each other. Instead, they communicate through messaging infrastructure
    as queues and topics.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**作为异步消息**：在这种架构中，客户端和服务器不直接相互联系。相反，它们通过消息基础设施作为队列和主题进行通信。'
- en: '**As two-way dedicated connections**: Clients and servers open a dedicated
    channel over a **Transmission Control Protocol** (**TCP**) connection to communicate.
    This style of communication is usually seen in systems that require lower latency
    and frequent messaging.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**作为双向专用连接**：客户端和服务器在**传输控制协议**（**TCP**）连接上打开专用通道进行通信。这种通信方式通常出现在需要较低延迟和频繁消息的系统。'
- en: The client-server solution
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器解决方案
- en: We are going to apply the client-server architecture to solve the real-life
    example of service contract synchronization between two households. It is recommended
    to draft the interactions between clients and servers before coding. Let us assume
    HTTP as the communication protocol.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用客户端-服务器架构来解决两个家庭之间服务合同同步的现实生活示例。建议在编码之前制定客户端和服务器之间的交互。让我们假设HTTP作为通信协议。
- en: We will use REST architecture in this solution. We need to define endpoints
    that are provided by servers so clients can use these endpoints to facilitate
    the necessary communication.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此解决方案中，我们将使用REST架构。我们需要定义服务器提供的端点，以便客户端可以使用这些端点来促进必要的通信。
- en: Step 1 – defining client-server communication
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 - 定义客户端-服务器通信
- en: 'Let us illustrate a sample scenario of client-server communication:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个客户端-服务器通信的示例场景来说明：
- en: '![Figure 4.3 – Sample client-server interaction for service contract synchronization](img/B21737_04_3.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 服务合同同步的示例客户端-服务器交互](img/B21737_04_3.jpg)'
- en: Figure 4.3 – Sample client-server interaction for service contract synchronization
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 服务合同同步的示例客户端-服务器交互
- en: 'The following are the messages sent between clients and servers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在客户端和服务器之间发送的消息：
- en: '*Household A* submits a draft of a service contract to servers.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭A* 向服务器提交服务合同的草稿。'
- en: '*Household B* gets the service contract drafted by *Household A* from servers.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭B* 从服务器获取由 *家庭A* 起草的服务合同。'
- en: '*Household B* revises the service contract and submits it to servers.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭B* 修订服务合同并将其提交给服务器。'
- en: '*Household A* gets the service contract revised by *Household B* from servers.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭A* 从服务器获取由 *家庭B* 修订的服务合同。'
- en: '*Household A* acknowledges to the servers that it agrees with the service contract.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭A* 向服务器确认它同意服务合同。'
- en: '*Household B* gets the service contract agreed by *Household A* from servers.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭B* 从服务器获取由 *家庭A* 同意的服务合同。'
- en: '*Household B* acknowledges to the servers that it agrees with the service contract.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭B* 向服务器确认它同意服务合同。'
- en: '*Household A* gets the service contract agreed upon by both households from
    the servers.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭A* 从服务器获取两个家庭都同意的服务合同。'
- en: 'From these messages, we can define a few HTTP endpoints to be called by clients:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些消息中，我们可以定义一些HTTP端点供客户端调用：
- en: '`PUT /contracts/{id}`: Submit a draft or revised service contract'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /contracts/{id}`: 提交草稿或修订后的服务合同'
- en: '`GET /contracts/{id}`: Get a service contract'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /contracts/{id}`: 获取服务合同'
- en: '`PATCH /contracts/{id}/agreedAt`: Acknowledge agreeing to a service contract'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /contracts/{id}/agreedAt`: 确认同意服务合同'
- en: Here, `{id}` is the unique identifier of the resource as the service contract.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`{id}` 是作为服务合同的资源唯一标识符。
- en: Step 2 – defining a message payload
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 - 定义消息负载
- en: 'The message payload used for `PUT` and `GET` endpoints needs to be defined.
    The service contract itself is the resource, so its model is the payload. The
    `PATCH` endpoint does not need to return a payload. The payload will be defined
    using the **OpenAPI 3.0** model, as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `PUT` 和 `GET` 端点的消息负载需要定义。服务合同本身是资源，因此其模型是负载。`PATCH` 端点不需要返回负载。负载将使用 **OpenAPI
    3.0** 模型定义，如下所示：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For simplicity’s sake, the `ServiceContract` class is defined by an integer
    ID and two parties. Each party has the name of the household, the service provided,
    and an optional time when the household agrees with the service contract.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，`ServiceContract` 类由一个整数ID和两个当事人定义。每个当事人都有家庭名称、提供的服务以及家庭同意服务合同的可选时间。
- en: Step 3 – defining API specifications
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 - 定义API规范
- en: Even though the three HTTP endpoints were identified in *step 1*, it is necessary
    to go into the details of each endpoint and define them as API specifications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在第1步中已识别了三个HTTP端点，但有必要深入了解每个端点并将它们定义为API规范。
- en: Let us assume that only the two households in the service contract can see the
    service contract. This means we need certain ways to authenticate and authorize
    the `GET` endpoint. In this example, we enforce that the `GET` request should
    include a header to specify which household requests it. In production systems,
    it should use something more secure, such as a **JSON Web Token** (**JWT**) issued
    by a trusted **identity and access management** (**IAM**) system and the decoded
    token contains claims that would reveal the household name.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设只有服务合同中的两个家庭可以看到服务合同。这意味着我们需要某些方式来验证和授权 `GET` 端点。在这个例子中，我们强制执行 `GET` 请求应包含一个标题来指定哪个家庭请求。在生产系统中，它应该使用更安全的方法，例如由受信任的
    **身份和访问管理**（**IAM**）系统签发的 **JSON Web Token**（**JWT**），解码的令牌包含会揭示家庭名称的声明。
- en: 'Therefore, there are two input parameters for the `GET` endpoint, as described
    here in the OpenAPI 3.0 model:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`GET` 端点有两个输入参数，如下所述的 OpenAPI 3.0 模型中：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first input parameter is the identifier of the service contract, shown in
    the URI path. The second input parameter is the household name, found in the header.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输入参数是服务合同的标识符，显示在URI路径中。第二个输入参数是家庭名称，位于标题中。
- en: 'As for the response, we need to consider the success and failure cases. The
    possible outcomes should be captured as HTTP status codes in the response, documented
    in the OpenAPI 3.0 model shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应，我们需要考虑成功和失败的情况。可能的输出应该作为HTTP状态码在响应中捕获，并在以下所示的 OpenAPI 3.0 模型中记录：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The request can be valid, and the service contract exists, therefore an HTTP
    status code of `200` (OK) and the payload of the service contract are returned.
    The request could be initiated by a household not mentioned in the service contract,
    and therefore it is not authorized and an HTTP status code of 403 (Forbidden)
    is returned. Or the service contract of the given ID simply does not exist, and
    an HTTP status code of `404` (Not Found) is returned.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可能是有效的，并且服务合同存在，因此返回 HTTP 状态码 `200`（OK）和服务合同负载。请求可能是由服务合同中未提及的家庭发起的，因此未获授权，并返回
    HTTP 状态码 403（禁止）。或者，给定的 ID 的服务合同根本不存在，并返回 HTTP 状态码 `404`（未找到）。
- en: 'The `PUT` endpoint uses the same URI path variables and header values as the
    `GET` endpoint, and in addition, a request body, which is the service contract
    itself:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 端点使用与 `GET` 端点相同的 URI 路径变量和头值，此外还有一个请求体，即服务合同本身：'
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The request body is the `ServiceContract` component itself, so the schema refers
    to the specification of the component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体是 `ServiceContract` 组件本身，因此模式引用了组件的规范。
- en: 'The response of the `PUT` endpoint is quite different from the `GET` endpoint.
    All the different scenarios are captured by the HTTP status codes in the response:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 端点的响应与 `GET` 端点大不相同。所有不同的场景都通过响应中的 HTTP 状态码捕获：'
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Firstly, the service contract in the request payload may have used the same
    household names for both parties, and therefore it is not valid and an HTTP status
    code of `400` (Bad Request) is returned. Also, if the household name in the header
    does not appear in the service contract’s party section, then it is not authorized,
    and an HTTP status code of `403` (Forbidden) is returned. If the request is valid,
    there are two outcomes. If a new service contract is created in servers, the HTTP
    status code `201` (Created) is returned with the service contract as the payload.
    If an existing one is updated, then the HTTP status code `200` (OK) is returned
    instead, together with the service contract as the payload.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请求负载中的服务合同可能使用了双方相同的家庭名称，因此它无效，并返回 HTTP 状态码 `400`（错误请求）。此外，如果头部的家庭名称在服务合同的当事人部分中未出现，则它未获授权，并返回
    HTTP 状态码 `403`（禁止）。如果请求有效，有两种结果。如果在服务器中创建新的服务合同，则返回 HTTP 状态码 `201`（已创建），并将服务合同作为负载。如果更新现有的服务合同，则返回
    HTTP 状态码 `200`（OK），并附带服务合同作为负载。
- en: 'The final endpoint, the `PATCH` endpoint, is simple. It uses the exact same
    set of input parameters as the `GET` endpoint, as there is no need for a request
    body and the request merely needs to identify an existing service contract. All
    responses are specified here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终端点，即 `PATCH` 端点，很简单。它使用与 `GET` 端点完全相同的输入参数集，因为没有必要请求体，请求只需识别现有的服务合同。所有响应都在此指定：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The failed outcomes in the response of the `PATCH` endpoint are the same as
    the `GET` endpoint, in identifying an existing service contract. But the successful
    outcome of the `PATCH` endpoint is different from the other two endpoints, because
    it has no request body, and therefore an HTTP status code of `204` (No Content)
    is returned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH` 端点响应中的失败结果与 `GET` 端点相同，在识别现有服务合同方面。但 `PATCH` 端点的成功结果与其他两个端点不同，因为它没有请求体，因此返回
    HTTP 状态码 `204`（无内容）。'
- en: Step 4 – server development
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步 – 服务器开发
- en: 'Now that we have the API specifications, we are ready to develop server endpoints.
    The corresponding entities need to be defined in Kotlin:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 API 规范，我们准备开发服务器端点。相应的实体需要在 Kotlin 中定义：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this is semantically equivalent to the OpenAPI 3.0 component definitions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与 OpenAPI 3.0 组件定义在语义上是等效的。
- en: 'It is recommended to use a highly available storage system to keep service
    contracts permanently, for example, a database. However, in this example, we simplify
    the repository to keep service contracts in memory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用高度可用的存储系统来永久保存服务合同，例如，数据库。然而，在这个例子中，我们简化了存储库，将服务合同保存在内存中：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This thread-safe in-memory map uses the integer IDs of the service contract
    as the keys and the `ServiceContract` objects as the values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程安全的内存映射使用服务合同的整数 ID 作为键，`ServiceContract` 对象作为值。
- en: 'In this example, **http4k** is used as the server framework because of its
    small code footprint. We need to set up the means to read and write different
    values. This is achieved by declaring a couple of **http4k Lenses** to validate
    and transform the payload into type-safe structures:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**http4k**因其代码体积小而被用作服务器框架。我们需要设置读取和写入不同值的方法。这是通过声明几个**http4k Lenses**来验证和将有效负载转换为类型安全结构来实现的：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have the Lens for `ServiceContract` objects as the body and the household
    name in the header. They will be used in the actual endpoint implementations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`ServiceContract`对象的Lens作为主体，家庭名称在头部。它们将在实际的端点实现中使用。
- en: 'http4k configures endpoint routing by simply declaring an `HTTPHandler` using
    the `route()` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: http4k通过简单地使用`route()`函数声明一个`HTTPHandler`来配置端点路由：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside the `route()` function, a list of endpoints is declared and the details
    of the implementation are defined. The following are the implementation details
    of the `GET` endpoint:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`route()`函数内部，声明了一个端点列表，并定义了实现的细节。以下是对`GET`端点的实现细节：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This implementation defines the routing URI of `GET /contracts/{id}`. Then,
    it uses the http4k Lens defined previously to read the household name from the
    header. The service contract ID is also read from the path variable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现定义了`GET /contracts/{id}`的路由URI。然后，它使用之前定义的http4k Lens从头部读取家庭名称。服务合同ID也从路径变量中读取。
- en: Then there is an attempt to get the `ServiceContract` object from the in-memory
    map we defined previously. If the object is not found, an HTTP status of `404`
    (Not Found) is returned. If the service contract is found, but the household name
    in the header is not that of either party of the service contract, then an HTTP
    status of `403` (Forbidden) is returned. Otherwise, everything is fine, and an
    HTTP status of `200` (OK) is returned with the response body transformed from
    the `ServiceContract` object by the http4k Lens defined previously.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试从之前定义的内存映射中获取`ServiceContract`对象。如果对象未找到，则返回HTTP状态`404`（未找到）。如果找到服务合同，但头部中的家庭名称不是服务合同任一方的，则返回HTTP状态`403`（禁止）。否则，一切正常，并返回HTTP状态`200`（OK），响应体由之前定义的http4k
    Lens转换自`ServiceContract`对象。
- en: 'The `PUT` endpoint is also defined similarly:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`端点也是类似定义的：'
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, the `PUT` endpoint transforms the request body into a `ServiceContract`
    object with the http4k Lens.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`PUT`端点使用http4k Lens将请求体转换为`ServiceContract`对象。
- en: The service contract ID from the URI path variable is checked against the `ServiceContract`
    object to ensure that the ID is the same as the `id` field inside the object.
    Also, there is a validation to ensure that household names in each party of the
    `ServiceContract` object are different. Any validation failures here would result
    in returning an HTTP status code of `400` (Bad Request).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从URI路径变量中读取的服务合同ID与`ServiceContract`对象进行核对，以确保ID与对象内部的`id`字段相同。此外，还有一个验证确保`ServiceContract`对象中每一方的家庭名称是不同的。任何验证失败都会导致返回HTTP状态码`400`（错误请求）。
- en: Like the `GET` endpoint, there is a check to ensure the household name in the
    header matches that of one of the parties in the `ServiceContract` object; otherwise,
    an HTTP status code of `403` (Forbidden) is returned.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与`GET`端点一样，有一个检查确保头部中的家庭名称与`ServiceContract`对象中的任一方匹配；否则，返回HTTP状态码`403`（禁止）。
- en: Afterward, the `ServiceContract` object is put into the in-memory map. The `put`
    function returns the previous value associated with the key. If the previous value
    is `null`, then an HTTP status of `201` (Created) is returned; otherwise, an HTTP
    status of `200` (OK) is returned. Both cases come with the response body transformed
    from the `ServiceContract` object by the http4k Lens defined previously.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将`ServiceContract`对象放入内存映射中。`put`函数返回与键关联的先前值。如果先前值为`null`，则返回HTTP状态`201`（已创建）；否则，返回HTTP状态`200`（OK）。两种情况都带有之前定义的http4k
    Lens转换自`ServiceContract`对象的响应体。
- en: 'The last endpoint, `PATCH`, has a very similar implementation to the `GET`
    endpoint in the first half. The same input parameters are read, and the servers
    attempt to get the `ServiceContract` object from the in-memory map. The first
    part of the implementation ends with the necessary validations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个端点`PATCH`与第一个半部分的`GET`端点实现非常相似。读取相同的输入参数，服务器尝试从内存映射中获取`ServiceContract`对象。实现的第一部分以必要的验证结束：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After validating the request, the household that agrees to the contract is
    located. An `agreedAt` timestamp is set to the relevant party of the contract.
    Also, the revised contract is put to the shared `ConcurrentHashMap` previously
    declared:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证请求后，找到同意合同的家庭。为合同的有关方设置`agreedAt`时间戳。此外，修订后的合同被放入之前声明的共享`ConcurrentHashMap`中：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second part of the implementation focuses on adding the `agreedAt` timestamp
    to the correct party of the `ServiceContract` object. Since validation has passed
    to ensure that the household is either one of the two, the servers determine which
    one it is and create a variant of the original `ServiceContract` object, with
    the `agreedAt` timestamp set to the current timestamp, using the `copy` function.
    The value in memory is then updated. An HTTP status code of `204` (No Content)
    is then returned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的第二部分专注于将`agreedAt`时间戳添加到`ServiceContract`对象的正确方。由于验证已经通过以确保家庭是两个之一，服务器确定它是哪一个，并使用`copy`函数创建原始`ServiceContract`对象的一个变体，将`agreedAt`时间戳设置为当前时间戳。然后更新内存中的值。随后返回HTTP状态码`204`（无内容）。
- en: 'Finally, there is the `main` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是`main`函数：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `main` function launches the server and starts listening to requests incoming
    on port `9000`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数启动服务器并开始监听端口`9000`上传入的请求。'
- en: Step 5 – client development
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 客户端开发
- en: 'As mentioned earlier, clients always initiate interactions with servers. So,
    the client implementation in this example reflects the client-server interaction
    in the sequence diagram in *Figure 4**.3*. For simplicity reasons, we use a `main`
    function to simulate both households in this example. We start with creating an
    HTTP client using **OKHTTP**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，客户端总是首先与服务器进行交互。因此，本例中的客户端实现反映了图4**.3**中的顺序图中的客户端-服务器交互。出于简化原因，我们在这个例子中使用`main`函数来模拟两个家庭。我们首先创建一个使用**OKHTTP**的HTTP客户端：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, the initial service contract drafted by *Household A* is created:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由*家庭A*起草的初始服务合同被创建：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the initial service contract is submitted to servers by calling the `PUT`
    endpoint. Subsequently, *Household B* received the initial service contract by
    calling the `GET` endpoint:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过调用`PUT`端点将初始服务合同提交给服务器。随后，*家庭B*通过调用`GET`端点接收初始服务合同：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Household B* revises the contract and submits the revised contract to the
    server by calling the `PUT` endpoint. Then, *Household A* receives the revised
    contract by calling the `GET` endpoint:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*家庭B*通过调用`PUT`端点来修订合同，并将修订后的合同提交给服务器。然后，*家庭A*通过调用`GET`端点接收修订后的合同：'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Household A* is happy with the revised contract. *Household A* acknowledges
    its agreement to the service contract through the servers, by calling the `PATCH`
    endpoint. Now it is *Household B*’s turn to receive and acknowledge the service
    contract:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*家庭A*对修订后的合同感到满意。*家庭A*通过调用`PATCH`端点通过服务器确认其对服务合同的同意。现在轮到*家庭B*接收并确认服务合同：'
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Household B* sees that *Household A* agreed to the service contract. *Household
    B* then also acknowledges its agreement to the service contract through the servers,
    by calling the `PUT` endpoint. Finally, it comes back to *Household A* to receive
    the service contract agreed by both households:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*家庭B*看到*家庭A*同意了服务合同。然后，*家庭B*也通过调用`PUT`端点通过服务器确认其对服务合同的同意。最后，它回到*家庭A*接收双方同意的服务合同：'
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The client-service interaction in this example has concluded. The service contract
    between *Household A* and *Household B* is mutually agreed upon and synchronized.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的客户端-服务交互已经结束。*家庭A*和*家庭B*之间的服务合同已经相互同意并同步。
- en: Throughout this example implementation, we demonstrated how to divide the roles
    of clients and servers in solving the service contract synchronization problem
    with the client-server architecture.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个示例实现过程中，我们展示了如何使用客户端-服务器架构来解决服务合同同步问题中客户端和服务器角色的划分。
- en: What systems use client-server architecture?
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些系统使用客户端-服务器架构？
- en: 'Client-server architecture is widely used in many systems. Here are a couple
    of examples:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构在许多系统中被广泛使用。以下是一些例子：
- en: '**B2C systems**: Most **business-to-customer** (**B2C**) systems use client-server
    architecture, where the client is either a web browser or a mobile application.
    A client holds very little data, only data about the user. Meanwhile, servers
    hold most of the data of all clients.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B2C系统**：大多数**企业对消费者**（**B2C**）系统使用客户端-服务器架构，其中客户端要么是网页浏览器，要么是移动应用程序。客户端只保存很少的数据，只有关于用户的数据。同时，服务器保存了所有客户端的大部分数据。'
- en: '**B2B systems**: Most **business-to-business** (**B2B**) systems use client-server
    architecture, where a part of the business system of a firm acts as a client to
    servers of another business system of another firm. These systems share some data
    because of the communication between clients and servers.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B2B系统**：大多数**企业对企业**（**B2B**）系统使用客户端-服务器架构，其中一家公司的业务系统的一部分充当客户端，连接到另一家公司的业务系统的服务器。这些系统由于客户端和服务器之间的通信而共享一些数据。'
- en: '**Online gaming**: Many online games use client-server architecture to maintain
    a shared state of the game among multiple players. The game client runs on players’
    devices and communicates with the game server to synchronize states and interact
    with other players.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线游戏**：许多在线游戏使用客户端-服务器架构来维护多个玩家之间的游戏共享状态。游戏客户端在玩家的设备上运行，并与游戏服务器通信以同步状态并与其他玩家互动。'
- en: '**Financial service systems**: Finance services are heavily regulated by various
    authorities and there are strict rules on how the data is stored and distributed.
    Client-server architecture can keep unnecessary data away from clients and have
    servers keeping sensitive data and complying with regulatory and audit controls.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金融服务系统**：金融服务受到各种机构的严格监管，对数据的存储和分发有严格的规则。客户端-服务器架构可以将不必要的数据与客户端隔离开来，让服务器保存敏感数据并遵守监管和审计控制。'
- en: '**Instant messaging, chat, and email systems**: Popular messaging platforms
    such as Slack, WhatsApp, Discord, and Microsoft Outlook use the client-server
    architecture. Clients connect to the servers to send and receive messages to other
    clients, broadcast messages to a group of clients, share files, and participate
    in real-time chat.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时通讯、聊天和电子邮件系统**：流行的消息平台，如Slack、WhatsApp、Discord和Microsoft Outlook，都使用客户端-服务器架构。客户端连接到服务器以向其他客户端发送和接收消息，向一组客户端广播消息，共享文件，并参与实时聊天。'
- en: Coming next, we will explore another option, P2P architecture, and how the same
    problem of the households and their service contracts can be solved differently.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一种选择，即对等网络架构，以及如何以不同的方式解决家庭及其服务合同的问题。
- en: P2P architecture
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对等网络架构
- en: P2P architecture is rooted in the idea of the absence of a centralized authority
    for coordination. A P2P network is formed of numerous nodes (“peers”) that have
    equal roles in communicating with one another.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对等网络架构基于没有中央权威机构进行协调的理念。一个对等网络由许多节点（“对等点”）组成，这些节点在相互通信中具有平等的角色。
- en: Each node can request resources or services from other nodes, while also providing
    resources or services to other nodes. This distributed nature of P2P networks
    enables efficient resource sharing and collaboration among participants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点可以从其他节点请求资源或服务，同时也可以向其他节点提供资源或服务。这种对等网络的分布式特性使得参与者之间能够有效地共享资源和协作。
- en: There is no hard non-functional requirement on the computational power, storage,
    and network bandwidth for each node coming from the P2P architecture. However,
    consistency is a major non-functional concern in many P2P systems.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 来自对等网络架构的每个节点在计算能力、存储和网络带宽方面没有硬性非功能性要求。然而，一致性是许多对等网络系统中的一个主要非功能性关注点。
- en: Consistency
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性
- en: 'There is no central authority or server that controls the data in a P2P system.
    Each node stores and manages its own data, and the nodes communicate directly
    with each other to share and synchronize information. This distributed nature
    of P2P systems brings several consistency challenges:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在对等网络系统中没有中央权威机构或服务器控制数据。每个节点存储和管理自己的数据，节点之间直接通信以共享和同步信息。这种对等网络的分布式特性带来了几个一致性挑战：
- en: '**Data replication and concurrency control**: A node in a P2P system often
    replicates its data across multiple nodes to improve availability and fault tolerance.
    This replication can lead to inconsistencies if the data is modified at different
    nodes at the same time. It is crucial that updates are propagated to all relevant
    nodes in a timely manner.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复制和并发控制**：在P2P系统中，一个节点通常会在多个节点上复制其数据以提高可用性和容错性。如果数据在多个节点上同时修改，这种复制可能导致不一致。及时将更新传播到所有相关节点至关重要。'
- en: Moreover, if multiple nodes update the same data at the same time, there is
    a conflict about which update should take place. Implementing effective concurrency
    control mechanisms, such as locking, versioning, or conflict resolution strategies,
    is necessary to maintain data consistency.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，如果多个节点同时更新相同的数据，将存在关于哪个更新应该发生的冲突。实施有效的并发控制机制，如锁定、版本控制或冲突解决策略，对于维护数据一致性是必要的。
- en: '**Eventual consistency**: In a distributed network where nodes are spread out,
    delays and partitions can occur, making it difficult to achieve strong and immediate
    consistency. Instead, **peer-to-peer** (**P2P**) systems focus on eventual consistency,
    meaning that a consistent state will eventually be reached after some time, even
    in the presence of network disruptions or node failures.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：在节点分布广泛的分布式网络中，可能会出现延迟和分区，这使得实现强一致性变得困难。相反，**对等网络**（**P2P**）系统侧重于最终一致性，这意味着经过一段时间后，即使在网络中断或节点故障的情况下，最终也会达到一致状态。'
- en: '**Causal consistency**: Another option for consistency is causal consistency,
    where related events are received by all nodes in the same order, and unrelated
    events are received in any order.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**因果一致性**：另一种一致性选项是因果一致性，其中相关事件以相同的顺序被所有节点接收，而不相关的事件可以以任何顺序接收。'
- en: '**Consensus and Quorum**: In some P2P systems, all nodes must reach a specific
    state or be updated before changes are accepted. This is known as the consensus
    approach. Alternatively, a quorum-based approach requires agreement from only
    a majority of nodes. Both methods help maintain a certain level of consistency
    but introduce extra coordination and communication overhead.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共识和法定人数**：在某些P2P系统中，在更改被接受之前，所有节点必须达到特定状态或被更新。这被称为共识方法。另一种基于法定人数的方法只需要大多数节点的同意。这两种方法都有助于维护一定水平的一致性，但引入了额外的协调和通信开销。'
- en: '**Merkle trees and hashing**: Merkle trees or hash-based approaches can be
    used to efficiently detect and resolve inconsistencies in the distributed data,
    allowing nodes to quickly identify and synchronize their data. These approaches
    are widely used in decentralized systems such as blockchain networks.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Merkle树和哈希**：Merkle树或基于哈希的方法可以用于高效地检测和解决分布式数据中的不一致性，使节点能够快速识别并同步其数据。这些方法在区块链网络等去中心化系统中被广泛使用。'
- en: Bootstrapping and node discovery
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导和节点发现
- en: A P2P network starts with the first node available, and then other nodes join.
    This process is called **bootstrapping**. Before a new node joins an existing
    P2P network, the new node must somehow discover at least one other node in the
    network. We will now cover several node discovery mechanisms.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络从第一个可用的节点开始，然后其他节点加入。这个过程称为**引导**。在新的节点加入现有的P2P网络之前，新节点必须以某种方式发现网络中的至少一个其他节点。我们现在将介绍几种节点发现机制。
- en: Static
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态
- en: The most basic way to discover a node is that each node has the addresses of
    all other nodes in static configurations. The obvious limitation of this approach
    is the number of nodes that can be configured. The limitation of IP addresses
    can be overcome by techniques such as **relay servers**, **network address translation**
    (**NAT**), and **hole-punching**. This is about storage and memory limitations
    to hold the addresses of all nodes in each node.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '发现节点最基本的方式是每个节点在其静态配置中都有所有其他节点的地址。这种方法的明显局限性是可以配置的节点数量。可以通过**中继服务器**、**网络地址转换**（**NAT**）和**打孔**等技术克服IP地址的限制。这是关于存储和内存限制，以在每个节点中存储所有节点的地址。 '
- en: A P2P network with static node discovery can be bootstrapped by attempting to
    connect each node from the static configuration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 具有静态节点发现的P2P网络可以通过尝试从静态配置连接每个节点来进行引导。
- en: Centralized directory
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中式目录
- en: Contrary to the concept of decentralization, some P2P networks have a centralized
    directory that maintains a list of active nodes in the network. That means the
    network starts with the centralized directory being available. When a node joins
    the network, it lists itself as available in the directory. Also, each node can
    get a list of available nodes from the centralized directory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与去中心化的概念相反，一些P2P网络有一个集中的目录，维护网络中活动节点的列表。这意味着网络从集中的目录可用开始。当一个节点加入网络时，它在目录中列出自己为可用。此外，每个节点都可以从集中的目录中获取可用节点的列表。
- en: The centralized directory falls into the category of servers, which requires
    very different system quality attributes from other nodes. For example, the centralized
    directory must be highly available; otherwise, it cannot accept new nodes or provide
    a list of available nodes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 集中的目录属于服务器类别，它需要与其他节点非常不同的系统质量属性。例如，集中的目录必须高度可用；否则，它不能接受新节点或提供可用节点列表。
- en: Multicast or broadcast
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多播或广播
- en: In a private or **local area network** (**LAN**), a P2P network can be established
    by having each node send broadcast or multicast messages to all other nodes. A
    couple of nodes can decide to respond, and the originator node is able to discover
    them. The network is started the first time a node is discovered. This discovery
    mechanism is suitable only for small networks with a limited number of nodes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个私有或**局域网**（**LAN**）中，可以通过每个节点向所有其他节点发送广播或多播消息来建立P2P网络。几台节点可以决定响应，原始节点能够发现它们。网络在第一次发现节点时启动。这种发现机制仅适用于节点数量有限的网络。
- en: Multicast networks usually use **User Datagram Protocol** (**UDP**) as the transport
    protocol. This is usually configured in a designated subnet to avoid broadcast
    floods and limit security risks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 多播网络通常使用**用户数据报协议**（**UDP**）作为传输协议。这通常配置在指定的子网中，以避免广播洪水并限制安全风险。
- en: Kademlia
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kademlia
- en: '**Kademlia** is a specification of the network structure and message protocol
    that is used in P2P networks. A **distributed hash table** (**DHT**) emerges across
    multiple nodes in the network. The network usually uses multicast UDP as the transport
    protocol.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kademlia** 是P2P网络中使用的网络结构和消息协议的规范。在网络的多个节点之间出现了一个**分布式哈希表**（**DHT**）。网络通常使用多播UDP作为传输协议。'
- en: Each node has a node ID, which is usually an unsigned big random integer number.
    The node ID prefix is used to calculate a hash value using a universal hash function.
    The hash value translates to a bucket in the hash table, and this is how each
    node maintains the IDs of other nodes in its local hash table and uses it as a
    routing table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都有一个节点ID，这通常是一个未签名的大的随机整数。节点ID前缀用于使用通用哈希函数计算哈希值。哈希值对应于哈希表中的一个桶，这就是每个节点如何在本地哈希表中维护其他节点的ID并将其用作路由表的方式。
- en: When a node joins the network, it broadcasts its node ID to all nodes in the
    network. Then, other nodes find a bucket to keep the ID of the new node in their
    routing tables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个节点加入网络时，它会向网络中的所有节点广播其节点ID。然后，其他节点在它们的路由表中找到一个桶来保存新节点的ID。
- en: Node IDs that are close to each other have their buckets close to each other
    as well. The “distance” between two node IDs calculated by the **exclusive OR**
    (**XOR**) function is used for node discovery. When a node wants to discover another
    node in the network, it starts from the bucket that is closest to its node ID
    and iteratively finds a responsive node by traversing buckets, from the closest
    to the farthest away.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 相邻的节点ID也有相邻的桶。通过**异或**（**XOR**）函数计算的两个节点ID之间的“距离”用于节点发现。当一个节点想要在网络中查找另一个节点时，它从最接近其节点ID的桶开始，通过遍历桶（从最近到最远）迭代地找到一个响应的节点。
- en: Exchanging information with other nodes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与其他节点交换信息
- en: Nodes can share their own nodes among themselves as well. The exchange among
    nodes comes with a few variations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间也可以共享它们自己的节点。节点之间的交换有一些变化。
- en: If the P2P network has a well-known structure, such as a DHT, a node can crawl
    the structure using a certain protocol to query nodes for information about other
    nodes. The downside is that a newly joined node would still need another mechanism
    to get an initial list of nodes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果P2P网络有一个已知的结构，例如DHT，节点可以使用某种协议爬取结构，以查询其他节点的信息。缺点是，新加入的节点仍然需要另一种机制来获取初始节点列表。
- en: A newly joined node can also contact a few bootstrapping nodes to query information
    about other nodes. This does, however, rely on the availability of the well-known
    bootstrapping nodes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新加入的节点也可以联系几个引导节点，以查询有关其他节点的信息。然而，这确实依赖于知名引导节点的可用性。
- en: A gossip protocol can also be employed among nodes to periodically share information
    with a few random neighbor nodes. The information should collectively spread like
    gossiping or an epidemic, though it takes some time to emerge. This protocol scales
    very well from small to big networks. It is also fault-tolerant, which means if
    a neighbor node fails, other neighbor nodes would still be able to provide alternative
    information.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间也可以采用gossip协议，定期与几个随机邻居节点共享信息。信息应该像八卦或流行病一样集体传播，尽管它需要一些时间才能显现。该协议从小型到大型网络都具有良好的可扩展性。它也是容错的，这意味着如果邻居节点失败，其他邻居节点仍然能够提供替代信息。
- en: Communication among nodes
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点间的通信
- en: Once a node has information on how to contact other nodes in the network, it
    can initiate communication.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点了解如何联系网络中的其他节点，它就可以开始通信。
- en: Direct communication with IP addresses
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接使用IP地址进行通信
- en: The most basic form of communication between two nodes is to have one node directly
    contact another node using an IP address. This approach is often used in small
    networks or LANs. Nodes in the network use transport protocols such as TCP for
    more reliable and ordered messages, or they use UDP for faster and unordered messages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 两个节点之间最基本的通信形式是使用IP地址让一个节点直接联系另一个节点。这种方法通常用于小型网络或局域网。网络中的节点使用TCP等传输协议来发送更可靠和有序的消息，或者使用UDP来发送更快但无序的消息。
- en: Hole-punching
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 穿孔打孔
- en: 'For a node under one local network to connect to another node under another
    local network, the nodes are not able to use IP addresses for direct communication.
    Let us consider the situation in the following sample network topology. See *Figure
    4**.4*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个本地网络下的节点要连接到另一个本地网络下的节点，这些节点无法使用IP地址进行直接通信。让我们考虑以下示例网络拓扑的情况。参见*图4.4*：
- en: '![Figure 4.4 – A sample network topology with home networks](img/B21737_04_4.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 带有家庭网络的示例网络拓扑](img/B21737_04_4.jpg)'
- en: Figure 4.4 – A sample network topology with home networks
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 带有家庭网络的示例网络拓扑
- en: '*Node 1* has no direct way to communicate with *Node 2* via the internet, since
    both nodes are behind their own home networks. However, if the home networks and
    **internet service provider** (**ISP**) networks support NAT, then **hole-punching**
    can be employed to allow *Node 1* to indirectly communicate with *Node 2* with
    this relay mechanism.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点1*没有直接通过互联网与*节点2*通信的方法，因为这两个节点都位于它们自己的家庭网络后面。然而，如果家庭网络和**互联网服务提供商**（**ISP**）网络支持NAT，那么可以使用**穿孔打孔**技术允许*节点1*通过这种中继机制间接与*节点2*通信。'
- en: 'NAT is a mechanism that translates local network addresses to public and global
    IP addresses. As a result, both *Node 1* and *Node 2* have their own global IP
    addresses, and they can communicate with each other. This is illustrated in the
    diagram here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: NAT是一种将本地网络地址转换为公共和全球IP地址的机制。因此，*节点1*和*节点2*都有自己的全球IP地址，并且它们可以相互通信。这在本图中有说明：
- en: '![Figure 4.5 – A sample network topology with home networks and NATs](img/B21737_04_5.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 带有家庭网络和NAT的示例网络拓扑](img/B21737_04_5.jpg)'
- en: Figure 4.5 – A sample network topology with home networks and NATs
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 带有家庭网络和NAT的示例网络拓扑
- en: '*Node 1* has opened its port `443` to receive messages and can be located by
    the private IP address `192.168.1.10` under its home network. Its home network
    has a NAT mapping of `192.168.1.10:443` (as an internal address) to `10.168.3.234:80006`
    (as an external address). Then, the ISP network also has a NAT mapping of an internal
    address of `10.168.3.234:80006` to a global address of `108.27.39.3:24390`. *Node
    2* has a similar NAT mapping path except its global address is `23.1.80.0:2877`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点1*已打开其端口`443`以接收消息，并且可以通过其家庭网络下的私有IP地址`192.168.1.10`进行定位。其家庭网络将`192.168.1.10:443`（作为内部地址）映射到`10.168.3.234:80006`（作为外部地址）。然后，ISP网络也将内部地址`10.168.3.234:80006`映射到全球地址`108.27.39.3:24390`。*节点2*具有类似的NAT映射路径，但其全球地址是`23.1.80.0:2877`。'
- en: From this point, we can start the hole-punching in steps, and assume *Node 1*
    has already discovered *Node 2*’s global address. Firstly, *Node 1* contacts its
    home network with the source local address (*Node 1*) and the target global address
    (*Node 2*). Then, the home network relays this information and contacts its ISP
    network similarly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们可以逐步开始打孔，并假设 *节点1* 已经发现了 *节点2* 的全局地址。首先，*节点1* 使用源本地地址 (*节点1*) 和目标全局地址
    (*节点2*) 与其家庭网络进行联系。然后，家庭网络中继此信息，并类似地联系其ISP网络。
- en: The ISP network where *Node 1* originated then contacts another ISP network
    where *Node 2* originated, using the global address.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*节点1* 所在的ISP网络使用全局地址联系另一个 *节点2* 所在的ISP网络。
- en: The ISP network where *Node 2* originated contacts the target local home network
    with the translated address local to the ISP network. Then, the home network contacts
    the target *Node 2* in its network with the translated address local to the home
    network.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点2* 所在的ISP网络使用转换后的地址与目标本地家庭网络进行联系。然后，家庭网络使用转换后的地址与家庭网络中的目标 *节点2* 进行联系。'
- en: The NATs punch temporary *holes* in their respective tables where they translate
    internal and external addresses. As a result, *Node A* and *Node B* can establish
    communication with multiple networks and NATs in the middle to relay messages.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: NATs 在各自的表中临时打上 *孔洞*，以便将内部和外部地址进行转换。因此，*节点A* 和 *节点B* 可以与多个网络以及中间的NATs建立通信，以中继消息。
- en: Note that hole-punching behind firewalls would not work if the firewalls were
    stateless. Stateless firewalls do not track connections and do not remember the
    translations of addresses.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果防火墙是无状态的，那么防火墙后面的打孔就不会起作用。无状态防火墙不跟踪连接，也不记得地址的转换。
- en: Publish-subscribe
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布-订阅
- en: '**Publish-subscribe** is an alternative model for P2P communication, where
    node discovery is not necessary. Instead, nodes publish messages to specific topics
    of interest, and other nodes subscribed to those topics would receive the messages.
    If the messages are delivered with a broker, then nodes still need to know the
    address of the broker to publish and receive messages. Publish-subscribe removes
    the need for node discovery and spreads information efficiently to relevant receivers.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布-订阅** 是P2P通信的另一种模型，其中不需要节点发现。相反，节点将消息发布到感兴趣的特定主题，订阅了这些主题的其他节点将接收到这些消息。如果消息通过代理传递，则节点仍然需要知道代理的地址来发布和接收消息。发布-订阅消除了节点发现的需求，并有效地将信息传播给相关接收者。'
- en: 'An example of a publish-subscribe architecture with a broker is shown in *Figure
    4**.6*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有代理的发布-订阅架构示例显示在 *图4**.6*：
- en: '![Figure 4.6 – Publish-subscribe architecture](img/B21737_04_6.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 发布-订阅架构](img/B21737_04_6.jpg)'
- en: Figure 4.6 – Publish-subscribe architecture
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 发布-订阅架构
- en: The publisher does not know the subscribers. It knows the address of the broker
    and the topic where a message should be published. Subscribers register their
    interests in certain topics with the broker and receive messages associated with
    the topics.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者不知道订阅者。它知道代理的地址以及消息应该发布的主题。订阅者将它们对某些主题的兴趣注册到代理，并接收与主题相关的消息。
- en: The broker is a type of infrastructure middleware that receives messages from
    publishers. It stores the messages and manages subscriptions by subscribers. Most
    importantly, it routes messages to the appropriate subscribers based on their
    registered interests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是一种基础设施中间件，它从发布者那里接收消息。它存储消息并管理订阅者的订阅。最重要的是，它根据订阅者注册的兴趣将消息路由到适当的订阅者。
- en: Now, we are going to delve into the implementation of the P2P solution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨P2P解决方案的实施。
- en: The P2P solution
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P2P解决方案
- en: We are going to apply the P2P architecture to solve a real-life example of service
    contract synchronization between two households. For simplicity’s sake, let us
    assume the two households have already discovered each other and their devices
    run in the same local network.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用P2P架构来解决两个家庭之间服务合同同步的实际情况。为了简化，让我们假设这两个家庭已经发现彼此，并且它们的设备运行在同一个本地网络中。
- en: Step 1 – defining P2P communication
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤1 – 定义P2P通信
- en: 'We are going to draft the interactions between nodes before coding. Let us
    assume that UDP is used as the communication protocol. Nodes communicate directly
    with each other, using IP addresses and ports. See *Figure 4**.7*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在编码之前制定节点之间的交互。让我们假设使用UDP作为通信协议。节点直接使用IP地址和端口相互通信。参见 *图4**.7*：
- en: '![Figure 4.7 – Sample P2P interaction service contract synchronization](img/B21737_04_7.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 示例P2P交互服务合同同步](img/B21737_04_7.jpg)'
- en: Figure 4.7 – Sample P2P interaction service contract synchronization
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 示例P2P交互服务合同同步
- en: 'The following are the messages sent between the nodes of *Household A* and
    *Household B* as described in *Figure 4**.7*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 *家庭A* 和 *家庭B* 的节点之间发送的消息，如 *图4.7* 所述：
- en: '*Household A* submits a draft of a service contract to *Household B*.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭A* 向 *家庭B* 提交一份服务合同的草案。'
- en: '*Household B* revises the service contract and submits it to *Household A*.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭B* 修改服务合同并将其提交给 *家庭A*。'
- en: '*Household A* acknowledges to *Household B* that it agrees with the service
    contract.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭A* 向 *家庭B* 确认它同意服务合同。'
- en: '*Household B* acknowledges to *Household A* that it agrees with the service
    contract.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭B* 向 *家庭A* 确认它同意服务合同。'
- en: After the communication protocol is defined, the message’s payload should be
    defined as the next step.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了通信协议之后，下一步应该定义消息的负载。
- en: Step 2 – defining the message payload
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 定义消息负载
- en: 'From the communication defined previously, the only message that passes around
    is the service contract itself. The model of the service contract remains the
    same:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前定义的通信中，唯一传递的消息就是服务合同本身。服务合同的模式保持不变：
- en: '[PRE21]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we externalize the `ServiceContract` class as a byte array
    to be sent across the wire.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `ServiceContract` 类外部化为一个字节数组，以便通过网络发送。
- en: Step 3 – peer development
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 同伴开发
- en: 'Let us start with scaffolding some necessary transport functions for nodes
    to communicate using UDP. As a node can produce and consume a message, it seems
    sensible to define a generic UDP node class as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为节点使用UDP进行通信构建一些必要的传输函数开始。由于一个节点可以产生和消费消息，因此定义一个通用的UDP节点类如下似乎是合理的：
- en: '[PRE22]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `UdpNode` class uses the **Non-Blocking Input/Output** (**NIO**) package
    to support three major functions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`UdpNode` 类使用 **非阻塞输入/输出**（**NIO**）包来支持三个主要功能：'
- en: Bootstrapping the node
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动节点
- en: Sending a message to a target node
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向目标节点发送消息
- en: Receiving a message from another node
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收来自另一个节点的消息
- en: While supporting these functions, the `UdpNode` class should only be changed
    if the transport mechanism needs to change, leaving it with a single responsibility
    of addressing concerns at the transport level, and conforming to the **single-responsibility
    principle**.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持这些功能的同时，`UdpNode` 类只有在传输机制需要更改时才应进行更改，使其仅具有处理传输层面问题的单一职责，并符合 **单一职责原则**。
- en: Therefore, the serialization and deserialization of the `ServiceContract` class
    is delegated to the `DtoConvertor` interface with generic type `T`, so the `UdpNode`
    class is not coupled to the `ServiceContract` class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ServiceContract` 类的序列化和反序列化委托给具有泛型类型 `T` 的 `DtoConvertor` 接口，这样 `UdpNode`
    类就不与 `ServiceContract` 类耦合。
- en: The handling of and responding to a `ServiceContract` object is an application-level
    concern, and this concern is delegated to a transformer lambda from the constructor.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 处理和响应 `ServiceContract` 对象是应用层面的关注点，并且这个关注点由构造函数委托给转换器 lambda。
- en: 'The `start` function of the `UdpNode` class is simple. It binds the node to
    the configured address and gets it ready to consume a message:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`UdpNode` 类的 `start` 函数很简单。它将节点绑定到配置的地址，并使其准备好消费消息：'
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `produce` function clears the outbound buffer before it calls `DtoConvertor`
    to write on it. Then, the buffer is sent to the channel:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`produce` 函数在调用 `DtoConvertor` 写入之前清除输出缓冲区。然后，将缓冲区发送到通道：'
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `consume` function clears the inbound buffer first, then the channel receives
    the byte array and writes it to the buffer. Then, `DtoConvertor` is called to
    convert the byte array into a `ServiceContract` object:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`consume` 函数首先清除输入缓冲区，然后通道接收字节数组并将其写入缓冲区。然后，调用 `DtoConvertor` 将字节数组转换为 `ServiceContract`
    对象：'
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The transformer lambda is called to determine the response to the `ServiceContract`
    object. If the response is `null`, then nothing happens. If the response is another
    `ServiceContract` object, then the `produce` function is called to send the response
    back to the node that sends the original message.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 调用转换器 lambda 函数来确定对 `ServiceContract` 对象的响应。如果响应是 `null`，则不执行任何操作。如果响应是另一个 `ServiceContract`
    对象，则调用 `produce` 函数将响应发送回发送原始消息的节点。
- en: 'Another important class in this example is `DtoConvertor`. It is designed to
    be generic and to encapsulate the serialization and deserialization of a generic
    type, `E`, to a byte array. There are only three functions:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，另一个重要的类是`DtoConvertor`。它被设计成通用的，用于封装泛型类型`E`到字节数组的序列化和反序列化。只有三个函数：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `allocate` function creates a `ByteBuffer` that is large enough to hold
    the designated type. The `toBuffer` function writes a `E` to `ByteBuffer`, and
    the `fromBuffer` function reads a DTO of type `E` from `ByteBuffer`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocate`函数创建一个足够大的`ByteBuffer`以容纳指定的类型。`toBuffer`函数将一个`E`写入`ByteBuffer`，而`fromBuffer`函数从`ByteBuffer`中读取类型为`E`的DTO。'
- en: 'A Kotlin singleton, `ServiceContractConvertor`, is declared to implement the
    `DtoConvertor` interface with the `ServiceContract` type:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了一个Kotlin单例`ServiceContractConvertor`，以实现`DtoConvertor`接口，并具有`ServiceContract`类型：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `toBuffer` function writes each field in a `ServiceContract` object in
    a certain order:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBuffer`函数按照一定的顺序将`ServiceContract`对象中的每个字段写入：'
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `fromBuffer` function reads from a `ByteBuffer` each field of the `ServiceContract`
    object in the same order and returns the object:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromBuffer`函数按照相同的顺序从`ByteBuffer`中读取`ServiceContract`对象的每个字段，并返回该对象：'
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, there are two `main` functions, one for *Household A* and one for *Household
    B*, to represent how each of them negotiates the service contract.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两个`main`函数，一个用于*家庭A*，一个用于*家庭B*，以表示它们如何协商服务合同。
- en: '*Household A*’s behaviors are defined in the following code block, and then
    the node starts listening:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*家庭A*的行为定义在下面的代码块中，然后节点开始监听：'
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Household A* does not respond to a `ServiceContract` object under the following
    circumstances:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*家庭A*在以下情况下不会对`ServiceContract`对象做出响应：'
- en: The same household name appears in both parties
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双方都出现了相同的家庭名称，因为它是不合法的
- en: Both households have already agreed to the contract
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个家庭都已经同意了合同
- en: '*Household A* is not involved in any party'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*家庭A*不参与任何一方'
- en: 'Otherwise, *Household A* agrees with `ServiceContract`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，*家庭A*同意`ServiceContract`：
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, *Household A* sends the draft contract to *Household B*. At the end, *Household
    A* enters an infinite loop to try to consume any further messages.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*家庭A*将草案合同发送给*家庭B*。最后，*家庭A*进入一个无限循环以尝试消费任何进一步的消息。
- en: 'On the other hand, *Household B* has its behaviors defined in another `main`
    function and then it starts listening:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*家庭B*的行为定义在另一个`main`函数中，然后它开始监听：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, *Household B* does not respond to a `ServiceContract` object under
    the following circumstances:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*家庭B*在以下情况下不会对`ServiceContract`对象做出响应：
- en: The same household name appears in both parties as it is not valid
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于家庭名称在双方都出现，因此它是不合法的
- en: Both households have already agreed to the contract
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个家庭都已经同意了合同
- en: '*Household B* is not involved in any party'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*家庭B*不参与任何一方'
- en: '*Household B* would revise the service received in the contract from *Cleaning*
    to *Babysitting*, and *Household B* would accept if the service received were
    *Babysitting*.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*家庭B*会将合同中从*清洁*服务更改为*育儿*服务，并且如果收到的服务是*育儿*，则*家庭B*会接受。'
- en: 'When both `main` functions run, we should see the two nodes representing *Household
    A* and *Household B* negotiating the service contract. Eventually, the service
    contract is mutually agreed upon and synchronized. We should see an output like
    this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个`main`函数运行时，我们应该看到代表*家庭A*和*家庭B*的两个节点协商服务合同。最终，服务合同被相互同意并同步。我们应该看到如下输出：
- en: 'Household A:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭A：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Household B:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭B：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point, we have demonstrated how to solve the service contract synchronization
    problem using UDP. To fully demonstrate the P2P network, there must be numerous
    nodes available to send and receive messages in a multicast UDP network. Moreover,
    there should be a data replication and consistency mechanism among the nodes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经展示了如何使用UDP解决服务合同同步问题。为了完全展示P2P网络，必须有大量的节点可供在多播UDP网络中发送和接收消息。此外，节点之间应该有一个数据复制和一致性机制。
- en: What systems use P2P architecture?
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用P2P架构的系统有哪些？
- en: 'P2P architecture is used in a few common systems, such as the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: P2P架构在几个常见的系统中使用，例如以下：
- en: '**Napster** was one of the earliest P2P systems that was commonly used by people
    to share files on the internet. Napster used a centralized directory server to
    maintain an index of available files and their locations.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Napster**是人们常用以在互联网上共享文件的最早P2P系统之一。Napster使用一个集中式目录服务器来维护可用文件及其位置的索引。'
- en: '**BitTorrent** is a popular P2P protocol used to distribute large files on
    the internet. It breaks down large files into smaller pieces and allows each piece
    to be shared independently. Users download and upload these pieces simultaneously.
    Upon completion, BitTorrent combines the pieces back into a file for users. BitTorrent
    has reduced the need for centralization for file sharing.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BitTorrent** 是一种流行的P2P协议，用于在互联网上分发大文件。它将大文件分解成更小的片段，并允许每个片段独立共享。用户同时下载和上传这些片段。完成后，BitTorrent将片段重新组合成文件供用户使用。BitTorrent减少了文件共享对中心化的需求。'
- en: '**Decentralized finance** (**DeFi**) is a more recent example. Cryptocurrencies
    such as **Bitcoin** and **Ethereum** operate on P2P networks. Nodes in the network
    communicate and validate transactions without relying on a central authority,
    using a consensus algorithm. This distributed and synchronized share state enables
    decentralized and trustless digital currency systems.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化金融** (**DeFi**) 是一个较新的例子。例如，**比特币**和**以太坊**这样的加密货币在P2P网络上运行。网络中的节点通过共识算法进行通信和验证交易，而不依赖于中央权威机构。这种分布式和同步的共享状态使得去中心化和无需信任的数字货币系统成为可能。'
- en: We are now going to compare the two architectures, client-server and P2P, to
    see which architecture is more useful in certain circumstances.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将比较这两种架构，客户端-服务器和P2P，以了解在特定情况下哪种架构更有用。
- en: Comparison between client-server and P2P architectures
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器和P2P架构之间的比较
- en: Client-server and P2P architectures should be seen as a spectrum of models ranging
    from centralization to decentralization, with a lot of viable hybrid models in
    between the two. See *Figure 4**.8*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器和P2P架构应被视为从集中化到去中心化的一系列模型，两者之间有许多可行的混合模型。参见 *图4.8*。
- en: '![Figure 4.8 – The spectrum from decentralized to centralized architectures](img/B21737_04_8.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 从去中心化到中心化架构的谱系](img/B21737_04_8.jpg)'
- en: Figure 4.8 – The spectrum from decentralized to centralized architectures
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 从去中心化到中心化架构的谱系
- en: Centralized architectures have simpler ways of achieving strong consistency,
    and decentralized architectures have more complex ways of achieving usually weaker
    consistency.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 中心化架构有更简单的方式实现强一致性，而去中心化架构有更复杂的方式实现通常较弱的致性。
- en: 'Client-server architectures are useful in the following circumstances:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构在以下情况下是有用的：
- en: There is a need for central control and management, typically applicable to
    industries under regulations
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要中央控制和管理的需求，通常适用于受监管的行业
- en: There are mission-critical processes that require systems to be highly available,
    resilient, and consistent
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些任务关键流程需要系统具有高度可用性、弹性和一致性
- en: There is a lot of data to be collected and correlated, and the data needs to
    be consistent, replicated, secure, and accessed in a secure manner
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要收集和关联大量数据，并且数据需要一致、复制、安全，并以安全的方式访问
- en: 'On the contrary, P2P architectures are useful in the following circumstances:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，P2P架构在以下情况下是有用的：
- en: There is a need to avoid the high cost of hosting servers and to make use of
    the existing resources of the peer nodes
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要避免托管服务器的昂贵成本，并利用对等节点的现有资源
- en: There is a need to share resources freely without central control or censorship
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在没有中央控制或审查的情况下自由共享资源
- en: There is a need to avoid relying on a subset of processing that could result
    in total system failure
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要避免依赖于可能导致整个系统失败的子集处理
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have delved into two important architectures, **client-server** and **P2P**,
    with the context of solving the synchronization problem of a real-life example
    of a service contract between households.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入探讨了两种重要架构，**客户端-服务器**和**P2P**，以解决现实生活服务合同同步问题的背景。
- en: We have covered how systems of each architecture can be bootstrapped, and which
    system quality attributes are required for each architecture.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了每种架构的启动方式，以及每种架构所需的系统质量属性。
- en: We have also demonstrated in Kotlin code how the synchronization problem can
    be solved by each architecture.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过Kotlin代码演示了如何通过每种架构解决同步问题。
- en: We have described a couple of real-life systems that employ client-server and
    P2P architectures. We have also compared the two.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了一些采用客户端-服务器和P2P架构的现实生活系统，并比较了这两种架构。
- en: You should now have a brief understanding of the two architectures and what
    problems they solve, and also be able to reason which architecture can be used
    in different situations.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对这两种架构及其解决的问题有一个简要的了解，并且能够推断出在不同情况下可以使用哪种架构。
- en: In the coming chapter, we are going to explore the architecture patterns often
    used in the frontend.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨在前端中常用的一些架构模式。
