["```swift\nstruct Car {\n    let brand: String\n    let isElectric: Bool\n}\n```", "```swift\nlet aCar = Car(brand: \"Ford\", isElectric: false)\nlet anElectricCar = Car(brand: \"Tesla\", isElectric: true)\nlet cars = [aCar, anElectricCar]\n```", "```swift\nlet onlyElectricCars = cars.filter { $0.isElectric }\n```", "```swift\nlet onlyElectricCarsAgain = cars.filter { $0[keyPath: \\Car.isElectric] }\n```", "```swift\nlet onlyElectricCarsNewWay = cars.filter(\\.isElectric)\n```", "```swift\nprint(onlyElectricCars)\nprint(onlyElectricCarsAgain)\nprint(onlyElectricCarsNewWay)\n```", "```swift\n[__lldb_expr_5.Car(brand: \"Tesla\", isElectric: true)]\n[__lldb_e xpr_5.Car(brand: \"Tesla\", isElectric: true)]\n[__lldb_expr_5.Car(brand: \"Tesla\", isElectric: true)]\n```", "```swift\nimport Foundation\nstruct MyPow {\n    let base: Double\n    func callAsFunction(_ x: Double) -> Double {\n        return pow(base, x)\n    }\n}\n```", "```swift\nlet base2Pow = MyPow(base: 2)\nprint(base2Pow.callAsFunction(3)) \n```", "```swift\n8.0\n```", "```swift\nprint(base2Pow(3))\n```", "```swift\n8.0\n```", "```swift\nstruct Building {\n    var floors: [String]\n    subscript(index: Int, default default: String = \"Unknown\") -> String {\n        if index >= 0 && index < floors.count {\n            return floors[index]\n        } else {\n            return `default`\n        }\n    }\n}\nlet building = Building(floors: [\"Ground Floor\", \"1st\", \"2nd\", \"3rd\"])\n```", "```swift\nprint(building[0])\n```", "```swift\nGround Floor\n```", "```swift\nprint(building[5])\n```", "```swift\nUnknown\n```", "```swift\nlet numbers = [1,2,3,4,5]\n    .lazy\n    .filter { $0 % 2 == 0 }\n    .filter { print($0); return true }\n_ = numbers.count\n```", "```swift\n2\n4\n```", "```swift\nenum Test { case a, b }\nfunc check(t: Test) {\n  if t != .c {\n    print(\"okay\")\n  }\n}\n```", "```swift\nerror: Chapter 1.5.playground:14:12: error: type 'Test' has no member 'c'\n  if t != .c {\n          ~^\n```", "```swift\nerror: binary operator '!=' cannot be applied to operands of type 'Test' and '_'\n  if t != .c {\n     ~ ^  ~~~~~~\n```", "```swift\nenum TaskError: Error {\n  case someRecoverableError\n  case someFailure(msg: String)\n  case anotherFailure(msg: String)\n}\nfunc performTask() throws -> String {\n  throw TaskError.someFailure(msg: \"Some Error\")\n}\nfunc recover() {}\n```", "```swift\ndo {\n  try performTask()\n} catch let error as TaskError {\n  switch error {\n  case TaskError.someRecoverableError:\n    recover()\n  case TaskError.someFailure(let msg),\n       TaskError.anotherFailure(let msg):\n    print(msg)\n  }\n}\n```", "```swift\ndo {\n  try performTask()\n} catch TaskError.someRecoverableError {\n  recover()\n} catch TaskError.someFailure(let msg),\n        TaskError.anotherFailure(let msg) {\n  print(msg)\n}\n```", "```swift\nUIView.animate(withDuration: 0.3, animations: {\n  self.view.alpha = 0\n}, completion: { _ in\n  self.view.removeFromSuperview()\n})\n```", "```swift\nUIView.animate(withDuration: 0.3, animations: {\n  self.view.alpha = 0\n}) { _ in\n  self.view.removeFromSuperview()\n}\n```", "```swift\nUIView.animate(withDuration: 0.3) {\n  self.view.alpha = 0\n} completion: { _ in\n  self.view.removeFromSuperview()\n}\n```", "```swift\nenum Volume: Comparable {\n    case low\n    case medium\n    case high\n    private static func minimum(_ lhs: Self, _ rhs: Self) -> Self {\n        switch (lhs, rhs) {\n        case (.low,    _), (_, .low   ):\n            return .low\n        case (.medium, _), (_, .medium):\n            return .medium\n        case (.high,   _), (_, .high  ):\n            return .high\n        }\n    }\n    static func < (lhs: Self, rhs: Self) -> Bool {\n        return (lhs != rhs) && (lhs == Self.minimum(lhs, rhs))\n    }\n}\n```", "```swift\nenum Size: Comparable {\n  case small(Int)\n  case medium\n  case large(Int)\n}\nlet sizes: [Size] = [.medium, .small(1), .small(2), .large(0)]\n```", "```swift\n[.small(1), .small(2), .medium, .large(0)]\n```", "```swift\nstruct SomeStruct {\n    var x = 0\n    func doSomething(_ task: @escaping () -> Void) {\n      task()\n    }\n    func test() {\n      doSomething { \n        x += 1 // note no self.x\n      }\n    }\n}\n```", "```swift\nclass SomeClass {\n    var x = 0\n    func doSomething(_ task: @escaping () -> Void) {\n      task()\n    }\n    func test() {\n      doSomething { [self] in\n        x += 1 // instead of self.x += 1\n        x = x * 5 // instead of self.x = self.x * 5\n      }\n    }\n}\n```", "```swift\n@main\nstruct TerminalApp {\n    static func main() {\n        print(\"Hello Swift 5.3!\")\n    }\n}\n```", "```swift\nstruct Stack<Element> {\n    private var array = [Element]()\n    mutating func push(_ item: Element) {\n        array.append(item)\n    }\n    mutating func pop() -> Element? {\n        array.popLast()\n    }\n}\nextension Stack {\n    func sorted() -> [Element] where Element: Comparable {\n        array.sorted()\n    }\n}\n```", "```swift\nprotocol Maximizable {\n    static var maxValue: Self { get }\n}\n```", "```swift\nextension Int: Maximizable {\n  static var maxValue: Int { Int.max }\n}\n```", "```swift\nenum Priority: Maximizable {\n    case minValue\n    case someValue(Int)\n    case maxValue\n}\n```"]