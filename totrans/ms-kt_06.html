<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer082">
			<h1 id="_idParaDest-75" class="chapter-number"><a id="_idTextAnchor084"/>6</h1>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor085"/>Network Calls with Kotlin Coroutines</h1>
			<p>Most of the apps we use on our phones fetch data that is hosted online on a server. As such, we developers have to understand how to request and send data to the servers too. In this chapter, we will learn how to send and request data that is hosted online and display it in <span class="No-Break">our apps.</span></p>
			<p>In this chapter, we will learn how to perform network calls with a networking library, <strong class="bold">Retrofit</strong>. We will learn how to consume <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) using this library. Moreso, we will learn how to take advantage of <strong class="bold">Kotlin coroutines</strong> to perform asynchronous network requests in <span class="No-Break">our app.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Setting <span class="No-Break">up Retrofit</span></li>
				<li>Introduction to <span class="No-Break">Kotlin coroutines</span></li>
				<li>Using Kotlin coroutines for <span class="No-Break">network calls</span></li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio"><span class="No-Break">https://developer.android.com/studio</span></a><span class="No-Break">) downloaded.</span></p>
			<p>You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor087"/>Setting up Retrofit</h1>
			<p>Retrofit is a type-safe REST client for Android, Java, and Kotlin developed by Square. The library provides a <a id="_idIndexMarker274"/>powerful framework for authenticating and interacting with APIs and sending network requests with OkHttp. In this book, we will be using Retrofit to perform our <span class="No-Break">network requests.</span></p>
			<p>To begin with, we will add the Retrofit dependencies using our newly created version catalog. Let’s define the versions in the <strong class="source-inline">libs.versions.toml</strong> file <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
retrofit = "2.9.0"
retrofitSerializationConverter = "1.0.0"
serializationJson = "1.5.1"
coroutines = "1.7.3"
okhttp3 = "4.11.0"</pre>			<p>Next, let’s define the <a id="_idIndexMarker275"/>libraries in the <strong class="source-inline">libs.versions.toml</strong> file in the libraries section of our versions catalog <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
retrofit = { module = "com.squareup.retrofit2:retrofit" , version.ref = "retrofit" }
retrofit-serialization = { module = "com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter", version.ref = "retrofitSerializationConverter" }
coroutines = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core" , version.ref = "coroutines" }
coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android" , version.ref = "coroutines" }
serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "serializationJson" }
okhttp3 = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp3" }</pre>			<p>We are adding these dependencies to <span class="No-Break">our project:</span></p>
			<ul>
				<li><strong class="bold">Retrofit</strong>: As mentioned earlier, we will use Retrofit to perform our <span class="No-Break">network requests.</span></li>
				<li><strong class="bold">Retrofit serialization</strong>: This is a converter<a id="_idIndexMarker276"/> that uses <strong class="bold">Kotlinx serialization</strong> to convert Kotlin objects to and <span class="No-Break">from JSON.</span></li>
				<li><strong class="bold">Coroutines</strong>: We will use Kotlin coroutines to perform our network requests asynchronously. We will be learning more about <span class="No-Break">coroutines shortly.</span></li>
				<li><strong class="bold">Kotlinx serialization JSON</strong>: This is a Kotlin serialization library for JSON. We will use this to parse our JSON responses. We have other serialization libraries, such as Moshi and Gson, but we <a id="_idIndexMarker277"/>used the Kotlinx serialization library for the <span class="No-Break">following reasons:</span><ul><li><strong class="bold">Kotlin-centric development</strong>: Kotlinx serialization is designed with Kotlin in mind, providing seamless integration and native support for <span class="No-Break">Kotlin serialization.</span></li><li><strong class="bold">Declarative syntax</strong>: Kotlinx serialization uses a declarative syntax, leveraging Kotlin’s language features for concise and readable <span class="No-Break">serialization code.</span></li><li><strong class="bold">Compile-time safety</strong>: Compile-time safety is a key feature, catching serialization-related errors during the compilation phase and reducing the likelihood of <span class="No-Break">runtime errors.</span></li><li><strong class="bold">Custom serialization strategies</strong>: We have the flexibility to define custom serialization strategies for specific types or scenarios, offering fine-grained control over the <span class="No-Break">serialization process.</span></li><li><strong class="bold">Seamless integration with Kotlin ecosystem</strong>: Being part of the Kotlin ecosystem, Kotlinx serialization integrates seamlessly with other Kotlin libraries and frameworks, contributing to a cohesive <span class="No-Break">development experience.</span></li></ul></li>
				<li><strong class="bold">OkHttp</strong>: This is an HTTP client that is used to make network requests. It provides some utilities for working <span class="No-Break">with Retrofit.</span></li>
			</ul>
			<p>All these dependencies will be added together, so this is a chance for us to group them in our <strong class="bold">bundles</strong> section. In our <strong class="source-inline">libs.versions.toml</strong> file, add this bundle below our <span class="No-Break">Koin bundle:</span></p>
			<pre class="source-code">
networking = ["retrofit", "retrofit-serialization", "serialization-json", "coroutines", "coroutines-android"]</pre>			<p>Here, we create a new bundle called <strong class="source-inline">networking</strong> and add all the dependencies that we specified earlier on. We have to sync the project for our changes to be added to the project. Tap on <strong class="bold">Sync Now</strong> in the notification that appears at the top when you edit the <strong class="source-inline">libs.versions.toml</strong> file. After<a id="_idIndexMarker278"/> syncing, let us start setting up the plugins <span class="No-Break">and dependencies.</span></p>
			<p> First, in our project-level <strong class="source-inline">build.gradle.kts</strong> file, we need to add the Kotlinx serialization plugin. Open the project-level <strong class="source-inline">build.gradle.kts</strong> file and on the plugins block add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
id("org.jetbrains.kotlin.plugin.serialization") version "1.8.20" apply false</pre>			<p>We define the Kotlinx serialization plugin and specify the version to use. This will set up the Kotlinx serialization plugin for us. The plugin generates Kotlin code for serializable classes. We will use this plugin to generate our models. Next, let us set up the plugin in our app module. Open the app-level <strong class="source-inline">build.gradle.kts</strong> file and add the following in the <span class="No-Break">plugins block:</span></p>
			<pre class="source-code">
id("kotlinx-serialization")</pre>			<p>This ensures our module is set up to use the Kotlinx serialization plugin. Next, we will add our <strong class="source-inline">networking</strong> bundle to our app module. In the app-level <strong class="source-inline">build.gradle.kts</strong> file, add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
implementation(libs.bundles.networking)</pre>			<p>This will add all the dependencies that we have specified in our <strong class="source-inline">networking</strong> bundle. Having done all these, our project is set up to use Retrofit. We will be using Koin to create a Retrofit instance<a id="_idIndexMarker279"/> that will be injected into classes that need it. Let us head over to the <strong class="source-inline">Module.kt</strong> file and add the <span class="No-Break"><strong class="source-inline">PetsViewModel</strong></span><span class="No-Break"> definition:</span></p>
			<pre class="source-code">
single {
    Retrofit.Builder()
        .addConverterFactory(
            Json.asConverterFactory(contentType = "application/json".toMediaType())
        )
        .baseUrl("https://cataas.com/api/")
        .build()
}</pre>			<p>In the preceding code, we created a Retrofit instance using the Retrofit builder. We also added a converter factory that uses Kotlinx serialization to convert Kotlin objects to and from JSON. We also specified the base URL for our API. We are using the <strong class="bold">Cat as a Service API</strong> (<a href="https://cataas.com/">https://cataas.com/</a>), which <a id="_idIndexMarker280"/>returns cat images. We will use this instance to create our API class, which is a class with methods that will be used to make network requests. Let us create this class. Create a new Kotlin interface inside the data package called <strong class="source-inline">CatsAPI.kt</strong> and add the <span class="No-Break">following method:</span></p>
			<pre class="source-code">
@GET("cats")
suspend fun fetchCats(
    @Query("tag") tag: String,
): Response&lt;List&lt;Cat&gt;&gt;</pre>			<p>In the preceding code, we use the <strong class="source-inline">@GET</strong> annotation to specify that we will be using the <strong class="source-inline">GET</strong> HTTP method for this request. Inside the method, we are also specifying a path that will be appended to our<a id="_idIndexMarker281"/> base URL to make the full URL for our request. Using the <strong class="source-inline">GET</strong> method means our method will only request data. We have the following built-in <span class="No-Break">HTTP annotations:</span></p>
			<ul>
				<li><strong class="source-inline">POST</strong>: This is used when we want to send data to <span class="No-Break">the server</span></li>
				<li><strong class="source-inline">PUT</strong>: This is used when we want to update data on <span class="No-Break">the server</span></li>
				<li><strong class="source-inline">DELETE</strong>: This is used when we want to delete data from <span class="No-Break">the server</span></li>
				<li><strong class="source-inline">HEAD</strong>: This method asks for a response identical to the one that would correspond to a <strong class="source-inline">GET</strong> request but without the <span class="No-Break">response body</span></li>
				<li><strong class="source-inline">PATCH</strong>: This is used when we want to update data partially on <span class="No-Break">the server</span></li>
				<li><strong class="source-inline">OPTIONS</strong>: This method requests permitted communication options for the <span class="No-Break">target resource</span></li>
			</ul>
			<p>Back to our <strong class="source-inline">fetchCats()</strong> function, you can notice that we use the <strong class="source-inline">@Query</strong> annotation to specify the query parameter for our request. We use the <strong class="source-inline">tag</strong> query parameter to specify the type of cat we want to fetch. We also use the <strong class="source-inline">suspend</strong> keyword to specify that this method will be called from a coroutine or another <strong class="source-inline">suspend</strong> function. We will learn more about coroutines shortly in the <em class="italic">Introduction to Kotlin coroutines</em> section of this chapter. We also use the <strong class="source-inline">Response</strong> class to wrap up our response. This class is provided by Retrofit and it contains the HTTP response metadata such as response code, headers, and the raw response body. We also specify that the response will be a list of <strong class="source-inline">Cat</strong> objects. Retrofit will map the response to a list of <strong class="source-inline">Cat</strong> objects. To resolve the error for the <strong class="source-inline">Cat</strong> <strong class="source-inline">data class</strong>, let us create it. Create a new Kotlin data class inside the data package called <strong class="source-inline">Cat.kt</strong> and add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
@Serializable
data class Cat(
    @SerialName ("createdAt")
    val createdAt: String,
    @SerialName("_id")
    val id: String,
    @SerialName("owner")
    val owner: String,
    @SerialName("tags")
    val tags: List&lt;String&gt;,
    @SerialName("updatedAt")
    val updatedAt: String
)</pre>			<p>The <strong class="source-inline">Cat</strong> data class has the fields that correspond to the JSON response from the Cat as a Service API. It is also annotated with the <strong class="source-inline">@Serializable</strong> annotation. This annotation is provided by Kotlinx Serialization and it is used to mark a class as serializable. This annotation is required for all the classes that we want to serialize or deserialize. We have used<a id="_idIndexMarker282"/> the <strong class="source-inline">@SerialName</strong> annotation before each variable in our data class. The <strong class="source-inline">@SerialName</strong> is an annotation used to customize the mapping between Kotlin property names and the corresponding names used in the serialized form, such as JSON or other data interchange formats. This annotation allows you to specify a different name for a property when it is serialized or deserialized, providing flexibility in handling <span class="No-Break">naming conventions.</span></p>
			<p>In our project, we are using Koin for dependency injection. So, we now need to create an instance of our <strong class="source-inline">CatsAPI</strong> class in our Koin modules. Let us head back to the <strong class="source-inline">Module.kt</strong> file and below the Retrofit instance add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
single { get&lt;Retrofit&gt;().create(CatsAPI::class.java) }</pre>			<p>Here, we get our Retrofit instance and use it to create an instance of our <strong class="source-inline">CatsAPI</strong> class, which we use to make the actual network requests. With that, our project is ready to make the network<a id="_idIndexMarker283"/> requests. But before that, let us learn more about Kotlin coroutines as we are going to modify our repository to <span class="No-Break">use coroutines.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor088"/>Introduction to Kotlin coroutines</h1>
			<p>Coroutines, introduced by JetBrains <a id="_idIndexMarker284"/>for Kotlin, provide a way to write asynchronous code in a more readable and synchronous manner. We can use them to perform background tasks and they are a great way to perform network requests and long-running tasks such as reading and writing to a database. They do these tasks off the main thread and ensure that we don’t block our main thread while performing these operations. The main benefits of using coroutines are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>They are lightweight and easy <span class="No-Break">to use.</span></li>
				<li>They have built-in <span class="No-Break">cancellation support.</span></li>
				<li>They lower the chances of apps having <span class="No-Break">memory leaks.</span></li>
				<li>As mentioned in earlier chapters, Jetpack libraries also support and <span class="No-Break">use coroutines.</span></li>
			</ul>
			<p>We have already added the core and Android coroutines libraries in our app. Let us understand some coroutines basics before proceeding to use coroutines in <span class="No-Break">our project.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor089"/>Coroutine basics</h2>
			<p>In this section, we will be<a id="_idIndexMarker285"/> looking at different terms and concepts used in <span class="No-Break">Kotlin coroutines:</span></p>
			<ul>
				<li><strong class="source-inline">suspend</strong>: This is a keyword that is used to mark a function. A <strong class="source-inline">suspend</strong> function is a function that can be paused and resumed at a later time. We have already used this keyword in our <strong class="source-inline">CatsAPI</strong> class to mark the <strong class="source-inline">fetchCats()</strong> function as a <strong class="source-inline">suspend</strong> function. A <strong class="source-inline">suspend</strong> function can only be called from another <strong class="source-inline">suspend</strong> function or from <span class="No-Break">a coroutine.</span></li>
				<li><strong class="bold">Coroutine builders</strong>: These are functions that are used to create coroutines. We have the <strong class="source-inline">launch</strong> and <strong class="source-inline">async</strong> coroutine builders. <strong class="source-inline">launch</strong> is used to create a coroutine that does not return a result while <strong class="source-inline">async</strong> is used to create a coroutine that returns a result. The result is a <strong class="source-inline">Deferred</strong> object and we can use the <strong class="source-inline">await()</strong> method to get the result. Both of these builders return a <strong class="source-inline">Job</strong> object that we can use to check if the coroutine is still active or if it has been canceled. We can also use the job to wait for the coroutine to finish. A job ends when it’s completed <span class="No-Break">or canceled.</span></li>
				<li><strong class="bold">Jobs</strong>: A job is a coroutine instance with a <strong class="bold">life cycle</strong> and can be canceled. We can use the job to check if the coroutine is still active or if it has been canceled. We can also use the <a id="_idIndexMarker286"/>job to wait for the coroutine to finish. A job ends when it’s completed or canceled. As mentioned earlier, both the <strong class="source-inline">launch</strong> and <strong class="source-inline">async</strong> coroutine builders return a <strong class="source-inline">Job</strong> object which we use to manage the coroutine life cycle. We have a normal <strong class="source-inline">Job</strong> and <strong class="source-inline">SupervisorJob</strong>. A normal <strong class="source-inline">Job</strong> is canceled when any of its children fail. <strong class="source-inline">SupervisorJob</strong> is not canceled when any of its children fail. It is recommended to use <strong class="source-inline">SupervisorJob</strong> when we have multiple coroutines <span class="No-Break">running concurrently.</span></li>
				<li><strong class="bold">Coroutine scope</strong>: This keeps track of all the coroutines we create using the <strong class="source-inline">launch</strong> or <strong class="source-inline">async</strong> builders. It is responsible for knowing how long a coroutine will live. Every coroutine builder is defined as an extension function of scope. Coroutines cannot be launched without a scope. We have <strong class="source-inline">GlobalScope</strong>, which is a scope that is not tied to any life cycle. It is not recommended to use this scope as it can lead to memory leaks. In Android, the KTX libraries provide <strong class="source-inline">viewModelScope</strong>, which is a scope that is tied to <strong class="source-inline">ViewModel</strong>. We can use this scope to launch coroutines that will be canceled when <strong class="source-inline">ViewModel</strong> is destroyed. We also have <strong class="source-inline">lifecycleScope</strong>, which is a scope that is tied to an activity or fragment life cycle. We can use this scope to launch coroutines that will be canceled when the life cycle is destroyed. We can also create our own custom scopes if we want to launch coroutines that will be canceled when a custom life cycle <span class="No-Break">is destroyed.</span></li>
				<li><strong class="bold">Coroutine context</strong>: This is a collection <a id="_idIndexMarker287"/>of many elements. <strong class="source-inline">CoroutineContext</strong> defines the behavior of our coroutines using elements such as <span class="No-Break">the following:</span><ul><li><strong class="source-inline">Job</strong>: This manages the life cycle of <span class="No-Break">the coroutine.</span></li><li><strong class="source-inline">CoroutineDispatcher</strong>: This defines the thread on which the coroutine <span class="No-Break">will run.</span></li><li><strong class="source-inline">CoroutineName</strong>: This defines the name of <span class="No-Break">the coroutine.</span></li><li><strong class="source-inline">CoroutineExceptionHandler</strong>: This handles uncaught exceptions in <span class="No-Break">the coroutine.</span></li></ul></li>
				<li><strong class="bold">Dispatchers</strong>: These specify which thread the coroutines will run on. We have the <span class="No-Break">following dispatchers:</span><ul><li><strong class="source-inline">Dispatchers.Main</strong>: This is the main thread. It is used when we need to interact with the UI in <span class="No-Break">our coroutines.</span></li><li><strong class="source-inline">Dispatchers.IO</strong>: This is a thread pool that is optimized for IO tasks such as reading and writing to a database or making <span class="No-Break">network requests.</span></li><li><strong class="source-inline">Dispatchers.Default</strong>: This is a thread pool that is optimized for <span class="No-Break">CPU-intensive tasks.</span></li><li><strong class="source-inline">Dispatchers.Unconfined</strong>: This is a dispatcher that is not confined to any thread. It is used to create a coroutine that inherits the context of the <span class="No-Break">parent coroutine.</span></li></ul><p class="list-inset">Inside coroutines, we can use the <strong class="source-inline">withContext()</strong> function to switch between different dispatchers. <strong class="source-inline">withContext()</strong> is a <strong class="source-inline">suspend</strong> function that switches the context of <span class="No-Break">the coroutine.</span></p></li>
				<li><strong class="bold">Flows</strong>: Suspend functions only return single values. Flows are a type of asynchronous data stream that can return multiple values. We can use flows to return multiple values from a <strong class="source-inline">suspend</strong> function. We can also use flows to perform asynchronous operations. Flows are <strong class="bold">cold streams</strong>. This means that they only start emitting values <a id="_idIndexMarker288"/>when they are collected. We can use the <strong class="source-inline">collect()</strong> function to collect values from a flow. We have <strong class="source-inline">StateFlow</strong> and <strong class="source-inline">SharedFlow</strong>, which are types of flows. <strong class="source-inline">StateFlow</strong> is a flow that emits the current value to new collectors and emits new values to existing collectors. <strong class="source-inline">SharedFlow</strong> is a flow that emits new values to all collectors. We will be learning more about flows in the next <a id="_idIndexMarker289"/>chapter. In Android, we will normally use the two types of flows to emit data to our UI. We will see the usage of <strong class="source-inline">StateFlow</strong> in <strong class="source-inline">ViewModel</strong> as we refactor it to <span class="No-Break">use coroutines.</span></li>
			</ul>
			<p>With this understanding of the basics, in the next section, we will be refactoring our repository to <span class="No-Break">use coroutines.</span></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor090"/>Using Kotlin coroutines for network calls</h1>
			<p>In this section, we will refactor our repository to use coroutines. We will use <strong class="source-inline">StateFlow</strong> to emit data <a id="_idIndexMarker290"/>from <strong class="source-inline">ViewModel</strong> to the view layer. We will also use the <strong class="source-inline">Dispatchers.IO</strong> dispatcher to perform our network requests on a <span class="No-Break">background thread.</span></p>
			<p>Let us start by creating a <strong class="source-inline">NetworkResult</strong> <strong class="source-inline">sealed class</strong>, which will represent the different states of our <span class="No-Break">network request:</span></p>
			<pre class="source-code">
sealed class NetworkResult&lt;out T&gt; {
    data class Success&lt;out T&gt;(val data: T) : NetworkResult&lt;T&gt;()
    data class Error(val error: String) : NetworkResult&lt;Nothing&gt;()
}</pre>			<p>The <strong class="source-inline">NetworkResult</strong> class is a sealed class that has two subclasses. We have the <strong class="source-inline">Success</strong> data class that will be used to represent a successful network request. It has a data property that will be used to hold the data returned from the network request. We also have the <strong class="source-inline">Error</strong> class, which will be used to represent a failed network request. It has an <strong class="source-inline">error</strong> property that will be used to hold the error message returned from the network request. The sealed class encapsulates a generic data type <strong class="source-inline">T</strong>, which makes it easier for us to<a id="_idIndexMarker291"/> reuse the class in all our network calls. The <strong class="source-inline">Success</strong> data class also has a generic parameter for the <span class="No-Break">same purpose.</span></p>
			<p>Next, let us modify <strong class="source-inline">PetsRepository</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
interface PetsRepository {
    suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt;
}</pre>			<p>We have updated the interface to use the <strong class="source-inline">NetworkResult</strong> class. We have also marked the <strong class="source-inline">getPets()</strong> function as a <strong class="source-inline">suspend</strong> function. We will use this method to fetch the cats from the API. Next, let us modify <strong class="source-inline">PetsRepositoryImpl</strong> to add the changes <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">PetsRepository</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
class PetsRepositoryImpl(
    private  val catsAPI: CatsAPI,
    private val dispatcher: CoroutineDispatcher
): PetsRepository {
    override suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt; {
        return withContext(dispatcher) {
            try {
                val response = catsAPI.fetchCats("cute")
                if (response.isSuccessful) {
                    NetworkResult.Success(response.body()!!)
                } else {
                    NetworkResult.Error(response.errorBody().toString())
                }
            } catch (e: Exception) {
                NetworkResult.Error(e.message ?: "Unknown error")
            }
        }
    }
}</pre>			<p>We have changed a number of <span class="No-Break">things here:</span></p>
			<ul>
				<li>First, we added a constructor that takes in an instance of our <strong class="source-inline">CatsAPI</strong> class, which we will use to <a id="_idIndexMarker292"/>make our network requests. It also has a <strong class="source-inline">dispatcher</strong> parameter, which will be used to specify the dispatcher that we will use to perform our network requests. We will use the <strong class="source-inline">Dispatchers.IO</strong> dispatcher to perform our network requests on a <span class="No-Break">background thread.</span></li>
				<li>We have also changed the return type of the <strong class="source-inline">getPets()</strong> function to <strong class="source-inline">NetworkResult&lt;List&lt;Cat&gt;&gt;</strong>. This is because we will return a <strong class="source-inline">NetworkResult</strong> object from <span class="No-Break">this method.</span></li>
				<li>We use the <strong class="source-inline">withContext()</strong> function to switch the context of the coroutine to the <strong class="source-inline">Dispatchers.IO</strong> dispatcher. This ensures that the network request is performed on a <span class="No-Break">background thread.</span></li>
				<li>We have also wrapped our network request in a <strong class="source-inline">try-catch</strong> block. This is to ensure we catch all the <a id="_idIndexMarker293"/>errors that might occur during the <span class="No-Break">network request.</span></li>
				<li>Inside our <strong class="source-inline">try</strong> block, we are making the network request using our <strong class="source-inline">CatsAPI</strong> instance. We use the <strong class="source-inline">fetchCats()</strong> method to make the request. We pass in the <strong class="source-inline">cute</strong> tag to specify the type of cats we want to fetch. We check if the response is successful. If it is, we return a <strong class="source-inline">NetworkResult.Success</strong> object with the response body. If it is not, we return a <strong class="source-inline">NetworkResult.Error</strong> object with the <span class="No-Break">error message.</span></li>
				<li>Lastly, we catch all the exceptions that might occur during the network request and return a <strong class="source-inline">NetworkResult.Error</strong> object with the <span class="No-Break">error message.</span></li>
			</ul>
			<p>In our Koin modules, we also need to change how we instantiate our repository. Let us head over to <strong class="source-inline">Module.kt</strong> and update the <strong class="source-inline">PetsRepository</strong> definition <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
single&lt;PetsRepository&gt; { PetsRepositoryImpl(get(), get()) }
single { Dispatchers.IO }</pre>			<p>We inject the <strong class="source-inline">CatsAPI</strong> instance and the <strong class="source-inline">dispatcher</strong> into our repository. We also declare the dispatcher as a single instance. Now we need to modify our <strong class="source-inline">PetsViewModel</strong> to accommodate these changes. To begin with, we need to create a state class that holds the state of our network request and exposes it to our view. Create a new Kotlin data class inside the <strong class="source-inline">view</strong> package <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">PetsUIState.kt</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
data class PetsUIState(
    val isLoading: Boolean = false,
    val pets: List&lt;Cat&gt; = emptyList(),
    val error: String? = null
)</pre>			<p>The <strong class="source-inline">PetsUIState</strong> class is a data class that holds the state of our network request. It has <span class="No-Break">three properties:</span></p>
			<ul>
				<li><strong class="source-inline">isLoading</strong>: This is a<a id="_idIndexMarker294"/> Boolean that is used to indicate whether the network request is loading <span class="No-Break">or not.</span></li>
				<li><strong class="source-inline">pets</strong>: This is a list of cats that will be returned from the <span class="No-Break">network request.</span></li>
				<li><strong class="source-inline">error</strong>: This is a string that will be used to hold the error message returned from the <span class="No-Break">network request.</span></li>
			</ul>
			<p>Next, in <strong class="source-inline">PetsViewModel</strong>, let us create a variable that will hold the state of our <span class="No-Break">network request:</span></p>
			<pre class="source-code">
val petsUIState = MutableStateFlow(PetsUIState())</pre>			<p>We use the <strong class="source-inline">MutableStateFlow</strong> class to hold the state of our network request. <strong class="source-inline">MutableStateFlow</strong> allows us to update the value of the state. We initialize it with an empty <strong class="source-inline">PetsUIState</strong> object. Next, let us update the <strong class="source-inline">getPets()</strong> method <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
private fun getPets() {
    petsUIState.value = PetsUIState(isLoading = true)
    viewModelScope.launch {
        when (val result = petsRepository.getPets()) {
            is NetworkResult.Success -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, pets = result.data)
                }
            }
            is NetworkResult.Error -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, error = result.error)
                }
            }
        }
    }
}</pre>			<p>Here, we will break down the <a id="_idIndexMarker295"/><span class="No-Break">preceding code:</span></p>
			<ul>
				<li>We update the value of the <strong class="source-inline">petsUIState</strong> variable to indicate that the network request <span class="No-Break">is loading.</span></li>
				<li>We use <strong class="source-inline">viewModelScope</strong> to launch a coroutine. This ensures that the coroutine is canceled when the <strong class="source-inline">ViewModel</strong> <span class="No-Break">is destroyed.</span></li>
				<li>There is a <strong class="source-inline">when</strong> statement, which is a Kotlin pattern-matching feature to check the result of the network request. If the result is a <strong class="source-inline">NetworkResult.Success</strong> object, we update the value of <strong class="source-inline">petsUIState</strong> to indicate that the network request was successful and passed in the list of cats. If the result is a <strong class="source-inline">NetworkResult.Error</strong> object, we update the value of <strong class="source-inline">petsUIState</strong> to indicate that the network request failed and pass in the <span class="No-Break">error message.</span></li>
			</ul>
			<p>In <strong class="source-inline">PetsViewModel</strong>, let us add a new <strong class="source-inline">init</strong> block that will call the <span class="No-Break"><strong class="source-inline">getPets()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
init {
    getPets()
}</pre>			<p>This will ensure that the <strong class="source-inline">getPets()</strong> function is called when <strong class="source-inline">ViewModel</strong> is created. We now need to update our <strong class="source-inline">PetList</strong> composable to accommodate these changes, too. We will also add more UI components since we need to show the loading state, images, and error messages. Let<a id="_idIndexMarker296"/> us start by adding a library that allows us to load images from a URL. We will use Coil (<a href="https://coil-kt.github.io/coil/">https://coil-kt.github.io/coil/</a>), which is an image-loading library. In the versions catalog, let’s add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
coil-compose = "io.coil-kt:coil-compose:2.4.0"</pre>			<p>We will also add the <strong class="source-inline">coil-compose</strong> dependency to our <strong class="source-inline">compose</strong> bundle so that it can be provided alongside other compose libraries. The updated compose bundle will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose"]</pre>			<p>Let us now create a new composable that displays an image and tags for each cat inside the <strong class="source-inline">view</strong> package called <strong class="source-inline">PetListItem.kt</strong> and add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(cat: Cat) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
                repeat(cat.tags.size) {
                    SuggestionChip(
                        modifier = Modifier
                            .padding(start = 3.dp, end = 3.dp),
                        onClick = { },
                        label = {
                            Text(text = cat.tags[it])
                        }
                    )
                }
            }
        }
    }
}</pre>			<p>This composable takes in a <strong class="source-inline">Cat</strong> object and displays the image and tags for the cat. We use the <strong class="source-inline">AsyncImage</strong> composable from the Coil library to load the image from the URL. We also use the <strong class="source-inline">FlowRow</strong> composable to<a id="_idIndexMarker297"/> display the tags for the cat. We use the <strong class="source-inline">SuggestionChip</strong> composable to display each tag. We display the image and tags in the <span class="No-Break"><strong class="source-inline">ElevatedCard</strong></span><span class="No-Break"> composable.</span></p>
			<p>Next, let us update our <strong class="source-inline">PetList</strong> composable to accommodate these changes. In the <strong class="source-inline">PetList.kt</strong> file, update the <strong class="source-inline">PetList</strong> composable <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@Composable
fun PetList(modifier: Modifier) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    Column(
        modifier = modifier
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AnimatedVisibility(
            visible = petsUIState.isLoading
        ) {
            CircularProgressIndicator()
        }
        AnimatedVisibility(
            visible = petsUIState.pets.isNotEmpty()
        ) {
            LazyColumn {
                items(petsUIState.pets) { pet -&gt;
                    PetListItem(cat = pet)
                }
            }
        }
        AnimatedVisibility(
            visible = petsUIState.error != null
        ) {
            Text(text = petsUIState.error ?: "")
        }
    }
}</pre>			<p>The following is the breakdown of the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li>Same as before, we use the <strong class="source-inline">koinViewModel()</strong> function to get an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">PetsViewModel</strong></span><span class="No-Break">.</span></li>
				<li>We use the <strong class="source-inline">collectAsStateWithLifecycle()</strong> function to collect the state of our network request. This function is provided by the <strong class="source-inline">lifecycle-runtime-compose</strong> library. It is used to collect the state of a flow and automatically cancel the<a id="_idIndexMarker298"/> collection when the life cycle is destroyed. We use the <strong class="source-inline">petsUIState</strong> property of <strong class="source-inline">PetsViewModel</strong> to get the state of our <span class="No-Break">network request.</span></li>
				<li>We have a <strong class="source-inline">Column</strong> composable that contains three <strong class="source-inline">AnimatedVisibility</strong> composables. The first one is used to display a <strong class="source-inline">CircularProgressIndicator</strong> when the network request is loading. The second one is used to display the list of cats when the network request is successful. The last one is used to display an error message when the network <span class="No-Break">request fails.</span></li>
			</ul>
			<p>The <strong class="source-inline">collectAsStateWithLifecycle()</strong> shows an error since we have not added its dependency. Let us add it to our libraries section in the versions catalog <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
compose-lifecycle = { module = "androidx.lifecycle:lifecycle-runtime-compose", version.ref = "lifecycle" }</pre>			<p>We will also add it to our <strong class="source-inline">compose</strong> bundle so that it can be provided alongside other compose libraries. The updated compose bundle will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose", "compose-lifecycle"]</pre>			<p>Do a Gradle sync and the IDE will prompt you to add imports for the <span class="No-Break"><strong class="source-inline">collectAsStateWithLifecycle()</strong></span><span class="No-Break"> function.</span></p>
			<p>We have completed updating all<a id="_idIndexMarker299"/> our layers to use the new coroutines approach. Good work so far! One last thing: since our app is now fetching these items from an API hosted online, we need to add the <strong class="source-inline">INTERNET</strong> permission to our app. Open the <strong class="source-inline">AndroidManifest.xml file</strong> and add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</pre>			<p>Run the app and see if everything is working as expected. We can see a list of cute cats with their tags being displayed. We can also see the loading indicator when the network request is loading and the error message when the network request fails. We have successfully refactored our app to <span class="No-Break">use coroutines.</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B19779_06_01.jpg" alt="Figure 6.1 – Cute cats" width="1011" height="1057"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Cute cats</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor091"/>Summary</h1>
			<p>In this chapter, we learned how to perform network calls with Retrofit. Moreso, we learned how to take advantage of Kotlin coroutines to perform asynchronous network requests in our app and refactored our app to fetch some cute cats with <span class="No-Break">Kotlin coroutines.</span></p>
			<p>In the next chapter, we will be looking at another Jetpack library, <strong class="bold">Jetpack Navigation</strong>, to handle navigation in <span class="No-Break">our app.</span></p>
		</div>
	</div></div></body></html>