<html><head></head><body><div><div><div><h1 id="_idParaDest-75" class="chapter-number"><a id="_idTextAnchor084"/>6</h1>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor085"/>Network Calls with Kotlin Coroutines</h1>
			<p>Most of the apps we use on our phones fetch data that is hosted online on a server. As such, we developers have to understand how to request and send data to the servers too. In this chapter, we will learn how to send and request data that is hosted online and display it in our apps.</p>
			<p>In this chapter, we will learn how to perform network calls with a networking library, <strong class="bold">Retrofit</strong>. We will learn how to consume <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) using this library. Moreso, we will learn how to take advantage of <strong class="bold">Kotlin coroutines</strong> to perform asynchronous network requests in our app.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Setting up Retrofit</li>
				<li>Introduction to Kotlin coroutines</li>
				<li>Using Kotlin coroutines for network calls</li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptersix</a>.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor087"/>Setting up Retrofit</h1>
			<p>Retrofit is a type-safe REST client for Android, Java, and Kotlin developed by Square. The library provides a <a id="_idIndexMarker274"/>powerful framework for authenticating and interacting with APIs and sending network requests with OkHttp. In this book, we will be using Retrofit to perform our network requests.</p>
			<p>To begin with, we will add the Retrofit dependencies using our newly created version catalog. Let’s define the versions in the <code>libs.versions.toml</code> file as follows:</p>
			<pre class="source-code">
retrofit = "2.9.0"
retrofitSerializationConverter = "1.0.0"
serializationJson = "1.5.1"
coroutines = "1.7.3"
okhttp3 = "4.11.0"</pre>			<p>Next, let’s define the <a id="_idIndexMarker275"/>libraries in the <code>libs.versions.toml</code> file in the libraries section of our versions catalog as follows:</p>
			<pre class="source-code">
retrofit = { module = "com.squareup.retrofit2:retrofit" , version.ref = "retrofit" }
retrofit-serialization = { module = "com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter", version.ref = "retrofitSerializationConverter" }
coroutines = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core" , version.ref = "coroutines" }
coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android" , version.ref = "coroutines" }
serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "serializationJson" }
okhttp3 = { module = "com.squareup.okhttp3:okhttp", version.ref = "okhttp3" }</pre>			<p>We are adding these dependencies to our project:</p>
			<ul>
				<li><strong class="bold">Retrofit</strong>: As mentioned earlier, we will use Retrofit to perform our network requests.</li>
				<li><strong class="bold">Retrofit serialization</strong>: This is a converter<a id="_idIndexMarker276"/> that uses <strong class="bold">Kotlinx serialization</strong> to convert Kotlin objects to and from JSON.</li>
				<li><strong class="bold">Coroutines</strong>: We will use Kotlin coroutines to perform our network requests asynchronously. We will be learning more about coroutines shortly.</li>
				<li><strong class="bold">Kotlinx serialization JSON</strong>: This is a Kotlin serialization library for JSON. We will use this to parse our JSON responses. We have other serialization libraries, such as Moshi and Gson, but we <a id="_idIndexMarker277"/>used the Kotlinx serialization library for the following reasons:<ul><li><strong class="bold">Kotlin-centric development</strong>: Kotlinx serialization is designed with Kotlin in mind, providing seamless integration and native support for Kotlin serialization.</li><li><strong class="bold">Declarative syntax</strong>: Kotlinx serialization uses a declarative syntax, leveraging Kotlin’s language features for concise and readable serialization code.</li><li><strong class="bold">Compile-time safety</strong>: Compile-time safety is a key feature, catching serialization-related errors during the compilation phase and reducing the likelihood of runtime errors.</li><li><strong class="bold">Custom serialization strategies</strong>: We have the flexibility to define custom serialization strategies for specific types or scenarios, offering fine-grained control over the serialization process.</li><li><strong class="bold">Seamless integration with Kotlin ecosystem</strong>: Being part of the Kotlin ecosystem, Kotlinx serialization integrates seamlessly with other Kotlin libraries and frameworks, contributing to a cohesive development experience.</li></ul></li>
				<li><strong class="bold">OkHttp</strong>: This is an HTTP client that is used to make network requests. It provides some utilities for working with Retrofit.</li>
			</ul>
			<p>All these dependencies will be added together, so this is a chance for us to group them in our <code>libs.versions.toml</code> file, add this bundle below our Koin bundle:</p>
			<pre class="source-code">
networking = ["retrofit", "retrofit-serialization", "serialization-json", "coroutines", "coroutines-android"]</pre>			<p>Here, we create a new bundle called <code>networking</code> and add all the dependencies that we specified earlier on. We have to sync the project for our changes to be added to the project. Tap on <code>libs.versions.toml</code> file. After<a id="_idIndexMarker278"/> syncing, let us start setting up the plugins and dependencies.</p>
			<p> First, in our project-level <code>build.gradle.kts</code> file, we need to add the Kotlinx serialization plugin. Open the project-level <code>build.gradle.kts</code> file and on the plugins block add the following:</p>
			<pre class="source-code">
id("org.jetbrains.kotlin.plugin.serialization") version "1.8.20" apply false</pre>			<p>We define the Kotlinx serialization plugin and specify the version to use. This will set up the Kotlinx serialization plugin for us. The plugin generates Kotlin code for serializable classes. We will use this plugin to generate our models. Next, let us set up the plugin in our app module. Open the app-level <code>build.gradle.kts</code> file and add the following in the plugins block:</p>
			<pre class="source-code">
id("kotlinx-serialization")</pre>			<p>This ensures our module is set up to use the Kotlinx serialization plugin. Next, we will add our <code>networking</code> bundle to our app module. In the app-level <code>build.gradle.kts</code> file, add the following:</p>
			<pre class="source-code">
implementation(libs.bundles.networking)</pre>			<p>This will add all the dependencies that we have specified in our <code>networking</code> bundle. Having done all these, our project is set up to use Retrofit. We will be using Koin to create a Retrofit instance<a id="_idIndexMarker279"/> that will be injected into classes that need it. Let us head over to the <code>Module.kt</code> file and add the <code>PetsViewModel</code> definition:</p>
			<pre class="source-code">
single {
    Retrofit.Builder()
        .addConverterFactory(
            Json.asConverterFactory(contentType = "application/json".toMediaType())
        )
        .baseUrl("https://cataas.com/api/")
        .build()
}</pre>			<p>In the preceding code, we created a Retrofit instance using the Retrofit builder. We also added a converter factory that uses Kotlinx serialization to convert Kotlin objects to and from JSON. We also specified the base URL for our API. We are using the <code>CatsAPI.kt</code> and add the following method:</p>
			<pre class="source-code">
@GET("cats")
suspend fun fetchCats(
    @Query("tag") tag: String,
): Response&lt;List&lt;Cat&gt;&gt;</pre>			<p>In the preceding code, we use the <code>@GET</code> annotation to specify that we will be using the <code>GET</code> HTTP method for this request. Inside the method, we are also specifying a path that will be appended to our<a id="_idIndexMarker281"/> base URL to make the full URL for our request. Using the <code>GET</code> method means our method will only request data. We have the following built-in HTTP annotations:</p>
			<ul>
				<li><code>POST</code>: This is used when we want to send data to the server</li>
				<li><code>PUT</code>: This is used when we want to update data on the server</li>
				<li><code>DELETE</code>: This is used when we want to delete data from the server</li>
				<li><code>HEAD</code>: This method asks for a response identical to the one that would correspond to a <code>GET</code> request but without the response body</li>
				<li><code>PATCH</code>: This is used when we want to update data partially on the server</li>
				<li><code>OPTIONS</code>: This method requests permitted communication options for the target resource</li>
			</ul>
			<p>Back to our <code>fetchCats()</code> function, you can notice that we use the <code>@Query</code> annotation to specify the query parameter for our request. We use the <code>tag</code> query parameter to specify the type of cat we want to fetch. We also use the <code>suspend</code> keyword to specify that this method will be called from a coroutine or another <code>suspend</code> function. We will learn more about coroutines shortly in the <em class="italic">Introduction to Kotlin coroutines</em> section of this chapter. We also use the <code>Response</code> class to wrap up our response. This class is provided by Retrofit and it contains the HTTP response metadata such as response code, headers, and the raw response body. We also specify that the response will be a list of <code>Cat</code> objects. Retrofit will map the response to a list of <code>Cat</code> objects. To resolve the error for the <code>Cat</code> <code>data class</code>, let us create it. Create a new Kotlin data class inside the data package called <code>Cat.kt</code> and add the following:</p>
			<pre class="source-code">
@Serializable
data class Cat(
    @SerialName ("createdAt")
    val createdAt: String,
    @SerialName("_id")
    val id: String,
    @SerialName("owner")
    val owner: String,
    @SerialName("tags")
    val tags: List&lt;String&gt;,
    @SerialName("updatedAt")
    val updatedAt: String
)</pre>			<p>The <code>Cat</code> data class has the fields that correspond to the JSON response from the Cat as a Service API. It is also annotated with the <code>@Serializable</code> annotation. This annotation is provided by Kotlinx Serialization and it is used to mark a class as serializable. This annotation is required for all the classes that we want to serialize or deserialize. We have used<a id="_idIndexMarker282"/> the <code>@SerialName</code> annotation before each variable in our data class. The <code>@SerialName</code> is an annotation used to customize the mapping between Kotlin property names and the corresponding names used in the serialized form, such as JSON or other data interchange formats. This annotation allows you to specify a different name for a property when it is serialized or deserialized, providing flexibility in handling naming conventions.</p>
			<p>In our project, we are using Koin for dependency injection. So, we now need to create an instance of our <code>CatsAPI</code> class in our Koin modules. Let us head back to the <code>Module.kt</code> file and below the Retrofit instance add the following:</p>
			<pre class="source-code">
single { get&lt;Retrofit&gt;().create(CatsAPI::class.java) }</pre>			<p>Here, we get our Retrofit instance and use it to create an instance of our <code>CatsAPI</code> class, which we use to make the actual network requests. With that, our project is ready to make the network<a id="_idIndexMarker283"/> requests. But before that, let us learn more about Kotlin coroutines as we are going to modify our repository to use coroutines.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor088"/>Introduction to Kotlin coroutines</h1>
			<p>Coroutines, introduced by JetBrains <a id="_idIndexMarker284"/>for Kotlin, provide a way to write asynchronous code in a more readable and synchronous manner. We can use them to perform background tasks and they are a great way to perform network requests and long-running tasks such as reading and writing to a database. They do these tasks off the main thread and ensure that we don’t block our main thread while performing these operations. The main benefits of using coroutines are as follows:</p>
			<ul>
				<li>They are lightweight and easy to use.</li>
				<li>They have built-in cancellation support.</li>
				<li>They lower the chances of apps having memory leaks.</li>
				<li>As mentioned in earlier chapters, Jetpack libraries also support and use coroutines.</li>
			</ul>
			<p>We have already added the core and Android coroutines libraries in our app. Let us understand some coroutines basics before proceeding to use coroutines in our project.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor089"/>Coroutine basics</h2>
			<p>In this section, we will be<a id="_idIndexMarker285"/> looking at different terms and concepts used in Kotlin coroutines:</p>
			<ul>
				<li><code>suspend</code>: This is a keyword that is used to mark a function. A <code>suspend</code> function is a function that can be paused and resumed at a later time. We have already used this keyword in our <code>CatsAPI</code> class to mark the <code>fetchCats()</code> function as a <code>suspend</code> function. A <code>suspend</code> function can only be called from another <code>suspend</code> function or from a coroutine.</li>
				<li><code>launch</code> and <code>async</code> coroutine builders. <code>launch</code> is used to create a coroutine that does not return a result while <code>async</code> is used to create a coroutine that returns a result. The result is a <code>Deferred</code> object and we can use the <code>await()</code> method to get the result. Both of these builders return a <code>Job</code> object that we can use to check if the coroutine is still active or if it has been canceled. We can also use the job to wait for the coroutine to finish. A job ends when it’s completed or canceled.</li>
				<li><code>launch</code> and <code>async</code> coroutine builders return a <code>Job</code> object which we use to manage the coroutine life cycle. We have a normal <code>Job</code> and <code>SupervisorJob</code>. A normal <code>Job</code> is canceled when any of its children fail. <code>SupervisorJob</code> is not canceled when any of its children fail. It is recommended to use <code>SupervisorJob</code> when we have multiple coroutines running concurrently.</li>
				<li><code>launch</code> or <code>async</code> builders. It is responsible for knowing how long a coroutine will live. Every coroutine builder is defined as an extension function of scope. Coroutines cannot be launched without a scope. We have <code>GlobalScope</code>, which is a scope that is not tied to any life cycle. It is not recommended to use this scope as it can lead to memory leaks. In Android, the KTX libraries provide <code>viewModelScope</code>, which is a scope that is tied to <code>ViewModel</code>. We can use this scope to launch coroutines that will be canceled when <code>ViewModel</code> is destroyed. We also have <code>lifecycleScope</code>, which is a scope that is tied to an activity or fragment life cycle. We can use this scope to launch coroutines that will be canceled when the life cycle is destroyed. We can also create our own custom scopes if we want to launch coroutines that will be canceled when a custom life cycle is destroyed.</li>
				<li><code>CoroutineContext</code> defines the behavior of our coroutines using elements such as the following:<ul><li><code>Job</code>: This manages the life cycle of the coroutine.</li><li><code>CoroutineDispatcher</code>: This defines the thread on which the coroutine will run.</li><li><code>CoroutineName</code>: This defines the name of the coroutine.</li><li><code>CoroutineExceptionHandler</code>: This handles uncaught exceptions in the coroutine.</li></ul></li>
				<li><code>Dispatchers.Main</code>: This is the main thread. It is used when we need to interact with the UI in our coroutines.</li><li><code>Dispatchers.IO</code>: This is a thread pool that is optimized for IO tasks such as reading and writing to a database or making network requests.</li><li><code>Dispatchers.Default</code>: This is a thread pool that is optimized for CPU-intensive tasks.</li><li><code>Dispatchers.Unconfined</code>: This is a dispatcher that is not confined to any thread. It is used to create a coroutine that inherits the context of the parent coroutine.</li></ul><p class="list-inset">Inside coroutines, we can use the <code>withContext()</code> function to switch between different dispatchers. <code>withContext()</code> is a <code>suspend</code> function that switches the context of the coroutine.</p></li>
				<li><code>suspend</code> function. We can also use flows to perform asynchronous operations. Flows are <code>collect()</code> function to collect values from a flow. We have <code>StateFlow</code> and <code>SharedFlow</code>, which are types of flows. <code>StateFlow</code> is a flow that emits the current value to new collectors and emits new values to existing collectors. <code>SharedFlow</code> is a flow that emits new values to all collectors. We will be learning more about flows in the next <a id="_idIndexMarker289"/>chapter. In Android, we will normally use the two types of flows to emit data to our UI. We will see the usage of <code>StateFlow</code> in <code>ViewModel</code> as we refactor it to use coroutines.</li>
			</ul>
			<p>With this understanding of the basics, in the next section, we will be refactoring our repository to use coroutines.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor090"/>Using Kotlin coroutines for network calls</h1>
			<p>In this section, we will refactor our repository to use coroutines. We will use <code>StateFlow</code> to emit data <a id="_idIndexMarker290"/>from <code>ViewModel</code> to the view layer. We will also use the <code>Dispatchers.IO</code> dispatcher to perform our network requests on a background thread.</p>
			<p>Let us start by creating a <code>NetworkResult</code> <code>sealed class</code>, which will represent the different states of our network request:</p>
			<pre class="source-code">
sealed class NetworkResult&lt;out T&gt; {
    data class Success&lt;out T&gt;(val data: T) : NetworkResult&lt;T&gt;()
    data class Error(val error: String) : NetworkResult&lt;Nothing&gt;()
}</pre>			<p>The <code>NetworkResult</code> class is a sealed class that has two subclasses. We have the <code>Success</code> data class that will be used to represent a successful network request. It has a data property that will be used to hold the data returned from the network request. We also have the <code>Error</code> class, which will be used to represent a failed network request. It has an <code>error</code> property that will be used to hold the error message returned from the network request. The sealed class encapsulates a generic data type <code>T</code>, which makes it easier for us to<a id="_idIndexMarker291"/> reuse the class in all our network calls. The <code>Success</code> data class also has a generic parameter for the same purpose.</p>
			<p>Next, let us modify <code>PetsRepository</code> as follows:</p>
			<pre class="source-code">
interface PetsRepository {
    suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt;
}</pre>			<p>We have updated the interface to use the <code>NetworkResult</code> class. We have also marked the <code>getPets()</code> function as a <code>suspend</code> function. We will use this method to fetch the cats from the API. Next, let us modify <code>PetsRepositoryImpl</code> to add the changes from <code>PetsRepository</code>:</p>
			<pre class="source-code">
class PetsRepositoryImpl(
    private  val catsAPI: CatsAPI,
    private val dispatcher: CoroutineDispatcher
): PetsRepository {
    override suspend fun getPets(): NetworkResult&lt;List&lt;Cat&gt;&gt; {
        return withContext(dispatcher) {
            try {
                val response = catsAPI.fetchCats("cute")
                if (response.isSuccessful) {
                    NetworkResult.Success(response.body()!!)
                } else {
                    NetworkResult.Error(response.errorBody().toString())
                }
            } catch (e: Exception) {
                NetworkResult.Error(e.message ?: "Unknown error")
            }
        }
    }
}</pre>			<p>We have changed a number of things here:</p>
			<ul>
				<li>First, we added a constructor that takes in an instance of our <code>CatsAPI</code> class, which we will use to <a id="_idIndexMarker292"/>make our network requests. It also has a <code>dispatcher</code> parameter, which will be used to specify the dispatcher that we will use to perform our network requests. We will use the <code>Dispatchers.IO</code> dispatcher to perform our network requests on a background thread.</li>
				<li>We have also changed the return type of the <code>getPets()</code> function to <code>NetworkResult&lt;List&lt;Cat&gt;&gt;</code>. This is because we will return a <code>NetworkResult</code> object from this method.</li>
				<li>We use the <code>withContext()</code> function to switch the context of the coroutine to the <code>Dispatchers.IO</code> dispatcher. This ensures that the network request is performed on a background thread.</li>
				<li>We have also wrapped our network request in a <code>try-catch</code> block. This is to ensure we catch all the <a id="_idIndexMarker293"/>errors that might occur during the network request.</li>
				<li>Inside our <code>try</code> block, we are making the network request using our <code>CatsAPI</code> instance. We use the <code>fetchCats()</code> method to make the request. We pass in the <code>cute</code> tag to specify the type of cats we want to fetch. We check if the response is successful. If it is, we return a <code>NetworkResult.Success</code> object with the response body. If it is not, we return a <code>NetworkResult.Error</code> object with the error message.</li>
				<li>Lastly, we catch all the exceptions that might occur during the network request and return a <code>NetworkResult.Error</code> object with the error message.</li>
			</ul>
			<p>In our Koin modules, we also need to change how we instantiate our repository. Let us head over to <code>Module.kt</code> and update the <code>PetsRepository</code> definition as follows:</p>
			<pre class="source-code">
single&lt;PetsRepository&gt; { PetsRepositoryImpl(get(), get()) }
single { Dispatchers.IO }</pre>			<p>We inject the <code>CatsAPI</code> instance and the <code>dispatcher</code> into our repository. We also declare the dispatcher as a single instance. Now we need to modify our <code>PetsViewModel</code> to accommodate these changes. To begin with, we need to create a state class that holds the state of our network request and exposes it to our view. Create a new Kotlin data class inside the <code>view</code> package called <code>PetsUIState.kt</code>:</p>
			<pre class="source-code">
data class PetsUIState(
    val isLoading: Boolean = false,
    val pets: List&lt;Cat&gt; = emptyList(),
    val error: String? = null
)</pre>			<p>The <code>PetsUIState</code> class is a data class that holds the state of our network request. It has three properties:</p>
			<ul>
				<li><code>isLoading</code>: This is a<a id="_idIndexMarker294"/> Boolean that is used to indicate whether the network request is loading or not.</li>
				<li><code>pets</code>: This is a list of cats that will be returned from the network request.</li>
				<li><code>error</code>: This is a string that will be used to hold the error message returned from the network request.</li>
			</ul>
			<p>Next, in <code>PetsViewModel</code>, let us create a variable that will hold the state of our network request:</p>
			<pre class="source-code">
val petsUIState = MutableStateFlow(PetsUIState())</pre>			<p>We use the <code>MutableStateFlow</code> class to hold the state of our network request. <code>MutableStateFlow</code> allows us to update the value of the state. We initialize it with an empty <code>PetsUIState</code> object. Next, let us update the <code>getPets()</code> method as follows:</p>
			<pre class="source-code">
private fun getPets() {
    petsUIState.value = PetsUIState(isLoading = true)
    viewModelScope.launch {
        when (val result = petsRepository.getPets()) {
            is NetworkResult.Success -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, pets = result.data)
                }
            }
            is NetworkResult.Error -&gt; {
                petsUIState.update {
                    it.copy(isLoading = false, error = result.error)
                }
            }
        }
    }
}</pre>			<p>Here, we will break down the <a id="_idIndexMarker295"/>preceding code:</p>
			<ul>
				<li>We update the value of the <code>petsUIState</code> variable to indicate that the network request is loading.</li>
				<li>We use <code>viewModelScope</code> to launch a coroutine. This ensures that the coroutine is canceled when the <code>ViewModel</code> is destroyed.</li>
				<li>There is a <code>when</code> statement, which is a Kotlin pattern-matching feature to check the result of the network request. If the result is a <code>NetworkResult.Success</code> object, we update the value of <code>petsUIState</code> to indicate that the network request was successful and passed in the list of cats. If the result is a <code>NetworkResult.Error</code> object, we update the value of <code>petsUIState</code> to indicate that the network request failed and pass in the error message.</li>
			</ul>
			<p>In <code>PetsViewModel</code>, let us add a new <code>init</code> block that will call the <code>getPets()</code> function:</p>
			<pre class="source-code">
init {
    getPets()
}</pre>			<p>This will ensure that the <code>getPets()</code> function is called when <code>ViewModel</code> is created. We now need to update our <code>PetList</code> composable to accommodate these changes, too. We will also add more UI components since we need to show the loading state, images, and error messages. Let<a id="_idIndexMarker296"/> us start by adding a library that allows us to load images from a URL. We will use Coil (<a href="https://coil-kt.github.io/coil/">https://coil-kt.github.io/coil/</a>), which is an image-loading library. In the versions catalog, let’s add the following:</p>
			<pre class="source-code">
coil-compose = "io.coil-kt:coil-compose:2.4.0"</pre>			<p>We will also add the <code>coil-compose</code> dependency to our <code>compose</code> bundle so that it can be provided alongside other compose libraries. The updated compose bundle will be as follows:</p>
			<pre class="source-code">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose"]</pre>			<p>Let us now create a new composable that displays an image and tags for each cat inside the <code>view</code> package called <code>PetListItem.kt</code> and add the following:</p>
			<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(cat: Cat) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
                repeat(cat.tags.size) {
                    SuggestionChip(
                        modifier = Modifier
                            .padding(start = 3.dp, end = 3.dp),
                        onClick = { },
                        label = {
                            Text(text = cat.tags[it])
                        }
                    )
                }
            }
        }
    }
}</pre>			<p>This composable takes in a <code>Cat</code> object and displays the image and tags for the cat. We use the <code>AsyncImage</code> composable from the Coil library to load the image from the URL. We also use the <code>FlowRow</code> composable to<a id="_idIndexMarker297"/> display the tags for the cat. We use the <code>SuggestionChip</code> composable to display each tag. We display the image and tags in the <code>ElevatedCard</code> composable.</p>
			<p>Next, let us update our <code>PetList</code> composable to accommodate these changes. In the <code>PetList.kt</code> file, update the <code>PetList</code> composable as follows:</p>
			<pre class="source-code">
@Composable
fun PetList(modifier: Modifier) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    Column(
        modifier = modifier
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AnimatedVisibility(
            visible = petsUIState.isLoading
        ) {
            CircularProgressIndicator()
        }
        AnimatedVisibility(
            visible = petsUIState.pets.isNotEmpty()
        ) {
            LazyColumn {
                items(petsUIState.pets) { pet -&gt;
                    PetListItem(cat = pet)
                }
            }
        }
        AnimatedVisibility(
            visible = petsUIState.error != null
        ) {
            Text(text = petsUIState.error ?: "")
        }
    }
}</pre>			<p>The following is the breakdown of the preceding code:</p>
			<ul>
				<li>Same as before, we use the <code>koinViewModel()</code> function to get an instance of <code>PetsViewModel</code>.</li>
				<li>We use the <code>collectAsStateWithLifecycle()</code> function to collect the state of our network request. This function is provided by the <code>lifecycle-runtime-compose</code> library. It is used to collect the state of a flow and automatically cancel the<a id="_idIndexMarker298"/> collection when the life cycle is destroyed. We use the <code>petsUIState</code> property of <code>PetsViewModel</code> to get the state of our network request.</li>
				<li>We have a <code>Column</code> composable that contains three <code>AnimatedVisibility</code> composables. The first one is used to display a <code>CircularProgressIndicator</code> when the network request is loading. The second one is used to display the list of cats when the network request is successful. The last one is used to display an error message when the network request fails.</li>
			</ul>
			<p>The <code>collectAsStateWithLifecycle()</code> shows an error since we have not added its dependency. Let us add it to our libraries section in the versions catalog as follows:</p>
			<pre class="source-code">
compose-lifecycle = { module = "androidx.lifecycle:lifecycle-runtime-compose", version.ref = "lifecycle" }</pre>			<p>We will also add it to our <code>compose</code> bundle so that it can be provided alongside other compose libraries. The updated compose bundle will be as follows:</p>
			<pre class="source-code">
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel", "coil-compose", "compose-lifecycle"]</pre>			<p>Do a Gradle sync and the IDE will prompt you to add imports for the <code>collectAsStateWithLifecycle()</code> function.</p>
			<p>We have completed updating all<a id="_idIndexMarker299"/> our layers to use the new coroutines approach. Good work so far! One last thing: since our app is now fetching these items from an API hosted online, we need to add the <code>INTERNET</code> permission to our app. Open the <code>AndroidManifest.xml file</code> and add the following:</p>
			<pre class="source-code">
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</pre>			<p>Run the app and see if everything is working as expected. We can see a list of cute cats with their tags being displayed. We can also see the loading indicator when the network request is loading and the error message when the network request fails. We have successfully refactored our app to use coroutines.</p>
			<div><div><img src="img/B19779_06_01.jpg" alt="Figure 6.1 – Cute cats" width="1011" height="1057"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Cute cats</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor091"/>Summary</h1>
			<p>In this chapter, we learned how to perform network calls with Retrofit. Moreso, we learned how to take advantage of Kotlin coroutines to perform asynchronous network requests in our app and refactored our app to fetch some cute cats with Kotlin coroutines.</p>
			<p>In the next chapter, we will be looking at another Jetpack library, <strong class="bold">Jetpack Navigation</strong>, to handle navigation in our app.</p>
		</div>
	</div></div></body></html>