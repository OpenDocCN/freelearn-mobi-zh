- en: Getting Started with Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover basic Kotlin syntax, and discuss what design patterns
    are good for and why they should be used in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is not to cover the entire language vocabulary, but
    to get you familiar with some basic concepts and idioms. The following chapters
    will slowly expose you to more language features as they become relevant to the
    design patterns we'll discuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic language syntax and features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic language syntax and features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you come from Java, C#, Scala or any other statically typed programming
    language, you'll find Kotlin syntax quite familiar. This is not by coincidence,
    but to make the transfer to this new language as smooth as possible for those
    with previous experience in other languages. Besides that familiarity, Kotlin
    brings a vast amount of features, such as better type safety. As we move ahead,
    you'll notice that all of them are attempting to solve real-world problems. That
    pragmatic approach is very consistent across the language. For example, one of
    the strongest sides of Kotlin is complete Java interoperability. You can have
    Java and Kotlin classes alongside each other, and freely use any library that
    is available in Java for a Kotlin project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the goals of language are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having clear syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being type-safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first chapter will discuss how these goals are achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the major paradigms in programming languages are procedural, object-oriented,
    and functional paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Being practical, Kotlin allows for any of these paradigms. It has classes and
    inheritance, coming from the object-oriented approach. It has higher-order functions
    from functional programming. But you don't have to wrap everything in classes
    if you don't want to. You can structure your entire code as just a set of procedures
    and structs. You will see how all these approaches come together, as different
    examples will use different paradigms to solve the problems discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you'll need to do when you start programming in Kotlin is create
    a new file. Kotlin's extension is usually `.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Java, there's no strong relationship between the filename and class name.
    You can put as many public classes in your file as you want, as long as the classes
    are related to one another and your file doesn't grow too long to read.
  prefs: []
  type: TYPE_NORMAL
- en: No semicolons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, every line of code must be terminated with a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But Kotlin is a pragmatic language. So, instead, it infers during compilation
    where it should put the semicolons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, you won't need to put semicolons in your code. They're considered
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a convention, if your file contains a single class, name your file the same
    as your class.
  prefs: []
  type: TYPE_NORMAL
- en: If your file contains more than one class, then the filename should describe
    the common purpose of those classes. Use CamelCase when naming your files, as
    per the Kotlin Coding Conventions: [https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules](https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules).
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, you don''t have to write your code in a file for simple snippets.
    You can also play with the language online: try [http://kotlinlang.org/](http://kotlinlang.org/) or
    use REPL and interactive shell after installing Kotlin and running `kotlinc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It wouldn't be convenient to have all your classes and functions in the same
    folder or under the same namespace. That's the reason Kotlin, similar to many
    other languages, uses the notion of a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Java, Kotlin uses packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you're mixing Java and Kotlin, Kotlin files should follow Java package rules.
  prefs: []
  type: TYPE_NORMAL
- en: In purely Kotlin projects, common package prefixes can be omitted from the folder
    structure. For example, if all your projects are under the `me.soshin` package,
    place your controllers in the `/controllers` folder and not in the `/me/soshin/controllers`
    folder like Java does.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start with the Kotlin type system, and compare it to what Java provides.
  prefs: []
  type: TYPE_NORMAL
- en: The Java examples are for familiarity, and not to prove that Kotlin is superior
    to Java in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a simple string in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We defined that `s` is of type `String`. But why? Isn't it obvious at this point?
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin provides us with type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the compiler will decide what type of variable should be used. Unlike
    interpreted languages (such as JavaScript, Groovy, or Ruby), the type of variable
    is defined only once. This will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You may wonder why we've used one `var` and one `val` to define the variables.
    We'll explain it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: val versus var
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, variables can be declared final. Final variables can be assigned only
    once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin urges you to use immutable data as much as possible. Final variables
    in Kotlin are simply `val`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do have a case in which you would like to reassign a variable, use `var` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We were taught very early in Java that comparing objects using `==` won't produce
    the expected results, since it tests for reference equality, and we need to use
    `equals()` for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'JVM does string interning to prevent that in some basic cases, so for the sake
    of the example we''ll use `new String()` to avoid that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin translates `==` to `equals()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do want to check for reference equality, use `===`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Null safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the most notorious exception in the Java world is `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason behind this exception is that every object in Java can be `null`.
    The code here shows us why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, marking `s` as `final` would prevent the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From anywhere in the code it''s still possible to pass `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Java 8, there''s been an `optional` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In a more functional style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But... it doesn't solve our problem. We can still pass `null` instead of the
    proper `Optional.empty()` and crash the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin checks it even earlier—during compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to our `printLength()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function with null won''t compile any more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specifically want your type to be able to receive nulls, you''ll need
    to mark it as nullable using the question mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Declaring functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything is an object in Java. If you have a method that doesn't rely on any
    state, it still must be wrapped by a class. You're probably familiar with a lot
    of `Util` classes in Java that only have static methods, and their only purpose
    is to satisfy the language requirements and bundle those methods together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, a function can be declared outside of a class instead of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s enough to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Functions declared outside of any class are already static.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many examples in this book assume that the code we provide is wrapped in the
    main function. If you don''t see a signature of the function, it probably should
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fun main(args: Array<String>)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword to declare a function is `fun`. The argument type comes after the
    argument name, and not before. And if the function doesn't return anything, the
    return type can be omitted completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you do want to declare the return type? Again, it will come after the
    function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of other topics regarding function declarations, such as default
    and named arguments, default parameters, and variable numbers of arguments. We'll
    introduce them in the following chapters, with relevant examples.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One could say that control flow is the bread and butter of writing programs.
    We''ll start with two conditional expressions: `if` and `when`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the if expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously it was noted that Kotin likes variables to be assigned only once.
    And it also doesn''t like nulls so much. You probably wondered how that would
    ever work out in the real world. In Java, constructs such as this are quite common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is an oversimplified situation, but still, you have a variable
    that at some point absolutely must be `null`, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, `if` is just a statement and doesn''t return anything. On the contrary,
    in Kotlin, `if` is an expression, meaning it returns a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with Java, you can easily read this code. This function
    receives a Boolean (which cannot be null), and returns a string (and never a null).
    But since it is an expression, it can return a result. And the result is assigned
    to our variable only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify it even further:'
  prefs: []
  type: TYPE_NORMAL
- en: The return type could be inferred
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The return as the last line can be omitted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple `if` expression can be written in one line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, our final result in Kotlin will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Single line functions in Kotlin are very cool and pragmatic. But you should
    make sure that somebody else other than you can understand what they do. Use with
    care.
  prefs: []
  type: TYPE_NORMAL
- en: Using the when expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if (no pun intended) we want to have more conditions in our `if` statement?
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we use the `switch` statement. In Kotlin, there's a `when` expression,
    which is a lot more powerful, since it can embed some other Kotlin features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a method that''s based on the amount of money that  will give
    cause to suggest a nice birthday gift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `when` also supports a range of values. The default case is
    covered by the `else` block. In the following examples, we will elaborate on even
    more powerful ways to use this expression.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, use `when` if you have more than two conditions. Use `if`
    for simple checks.
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we would like to actually print those results?
  prefs: []
  type: TYPE_NORMAL
- en: First, as you may have already noticed, in one of the examples above, Kotlin
    provides a nifty `println()` standard function that wraps the bulkier `System.out.println()`
    from Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, more importantly, as in many other modern languages, Kotlin supports string
    interpolation using the `${}` syntax. Following on from the example before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re interpolating a variable, and not a function, curly braces could
    be omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This would print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Classes and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Kotlin is multi-paradigm, it has a strong affinity to the Java programming
    language, which is based on classes. Keeping Java and JVM interoperability in
    mind, it's no wonder that Kotlin also has the notion of classes and classical
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare a `class`, we use a class keyword, exactly like in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s no `new` keyword in Kotlin. The instantiation of a class simply looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the class has no body, as in this simple example, we can omit the **curly
    brackets**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exactly like in Java, abstract classes are marked by `abstract` and interfaces
    by the `interface` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As in Java 8, interfaces in Kotlin can have a default implementation of functions,
    as long as they don''t rely on any state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no `inherits` and `implements` keywords in Kotlin. Instead, both
    the name of an abstract class and all the names of the interfaces that class implements
    are put after a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can still distinguish the abstract class by the parenthesis that comes after
    its name, and there can still be only one `abstract` class, as there are no multiple
    inheritances in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `DungeonMaster` has access to both functions from `Greeter` and `AbstractDungeonMaster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the preceding code, it will print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `DungeonMaster` looks a bit awkward now, since it can proclaim the start
    of only one game. Let''s add a non-empty constructor to our `abstract` class to
    fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `DungeonMaster` must receive the name of the game and pass it to the
    `abstract` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What if we wanted to extend `DungeonMaster` by having an `EvilDungeonMaster`?
  prefs: []
  type: TYPE_NORMAL
- en: In Java, all classes can be extended, unless they're marked `final`. In Kotlin,
    no class can be extended, unless it's marked `open`. The same goes for functions
    in abstract classes. That's the reason why we declared `DungeonMaster` as `open`
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll change `AbstractDungeonMaster` a bit again to give more power to the
    evil ruler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add the following to our `EvilDungeonMaster` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Whereas in Java, `@Override` is an optional annotation, in Kotlin it is a mandatory
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot hide supertype methods, and code that doesn't use `override` explicitly
    won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, we are used to the concept of getters and setters. A typical class
    may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we want to get a person's name, we call `getName()`. If we want to change
    it, we call `setName()`. That's quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to set the name only once, during object instantiation, we can specify
    the non-default constructor and remove the setter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: All this dates back to the beginning of Java, somewhere around '95.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you''ve worked with C#, for example, you''re probably familiar with
    the idea of properties. To understand them, let''s go to the first example and
    change it a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading a person''s name is not much shorter: `p.name`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, changing the name is much more intuitive: `p.name = "Alex";`.'
  prefs: []
  type: TYPE_NORMAL
- en: But by doing so, we lost a lot of control over our object. We cannot make `PublicPerson`
    immutable. If we want everybody to be able to read the person's name, they'll
    also be able to change it at any point in time. And what if later we decide that
    all names must be uppercase? With setter, we could do that. But not with the public
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties provide a solution for all those problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This may look the same as the Java example, with all its problems. But actually,
    behind the scenes, it's compiled to a getter and setter pair, just like the first
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'And since properties in Kotlin are translated into getters and setters, we
    can also control their behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't need to check that `value` is null. The `String` type simply
    cannot receive nulls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming from Java, it may seem intuitive to use the following assignment: `this.name
    = value.toUpperCase()`. But, in Kotlin, this will create a circular dependency.
    Instead, there''s a `field` identifier that we''re using, which is provided automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember how Kotlin is all about productiveness? One of the most common tasks
    for Java developers is to create another **Plain Old Java Object** (**POJO**).
    If you're not familiar with POJO, it is basically an object that only has getters,
    setters, and an implementation of `equals` or `hashCode` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task is so common that Kotlin has it built into the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a class with two getters and no setters (note the `val` part),
    which will also implement `equals`, `hashCode`, and `clone` functions in the correct
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of data classes is one of the biggest improvements in reducing
    the amount of boilerplate in the language.
  prefs: []
  type: TYPE_NORMAL
- en: More control flow – loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's discuss another common control structure—a loop. Loops are a very
    natural construct for most developers. Without loops, it would be very hard to
    repeat the same block of code more than once (although we will discuss how to
    do that without loops in later chapters).
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop in Java, which prints each character of a string on a new line,
    may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The same loop in Kotlin is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that while the usual `for` loop in Java is exclusive (it excludes the last
    index by definition, unless specified otherwise), the `for` loop over ranges in
    Kotlin is inclusive. That's the reason we have to subtract one from the length
    to prevent overflow (string index out of range): `(word.length-1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to avoid that, you can use the `until` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike some other languages, reversing the range indexes won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If your intention is to print the word in reverse order, for example, use the
    `downTo` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It may seem confusing that `until` and `downTo` are called functions, although
    they look more like operators. This is another interesting Kotlin feature called
    **infix call**, which will be discussed later on.
  prefs: []
  type: TYPE_NORMAL
- en: For-each loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, if you''re a bit familiar with Java, you may argue that the previous
    code could be improved by using a `for-each` construct instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The same in Kotlin would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: While loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no changes to the `while` loop functionality, so we''ll cover them
    very briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will print numbers from 1 to 10\. Note that we are forced to define `x`
    as `var`. In the following chapters, we'll discuss much more idiomatic ways to
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lesser used `do while` loop is also present in the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed from the previous examples that `String` in Kotlin has
    some methods that its Java counterpart is lacking, such as `reversed()`. How is
    that achieved, if it's the same `String` type as in Java and, as we know, `String`
    in Java cannot be extended by any other class, since it's declared `final`?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the source code, you''ll find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This feature is called an extension function, and it also exists in some other
    languages, such as C# or Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: To extend a class without inheriting from it, we prefix the function name, `reversed`
    in our example, with a class name we want to extend.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that the extension function cannot override the member function. The `inline` keyword
    will be discussed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are a bit familiar with basic Kotlin syntax, we can move on to discuss
    what design patterns are all about.
  prefs: []
  type: TYPE_NORMAL
- en: What are design patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different misconceptions surrounding design patterns. In general,
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Missing language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not necessary in dynamic language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relevant only to object-oriented languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relevant only to enterprises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But actually, design patterns are just a proven way to solve a common problem.
    As a concept, they are not limited to a specific programming language (Java),
    nor to a family of languages (C-family, for example), nor are they limited to
    programming in general. You may have even heard of design patterns in software
    architecture, which discuss how different systems can efficiently communicate
    with each other. There are service-oriented architectural patterns, which you
    may know as **Service-Oriented Architecture** (**SOA**), and microservice design
    patterns that evolved from SOA and emerged over the past few years. The future
    will, for sure, bring us even more design pattern *families*.
  prefs: []
  type: TYPE_NORMAL
- en: Even in the physical world, outside software development, we're surrounded by
    design patterns and commonly accepted solutions to a certain problem. Let's look
    at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns in real life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you ride an elevator lately? Was there a mirror on the wall of the elevator?
    Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: How did you feel when you last rode an elevator that had no mirror and no glass
    walls?
  prefs: []
  type: TYPE_NORMAL
- en: The main reason we commonly have mirrors in our elevators is to solve a common
    problem. Riding in an elevator is boring. We could put in a picture. But a picture
    would also get boring after a while, if you rode the same elevator at least twice
    a day. Cheap, but not much of an improvement.
  prefs: []
  type: TYPE_NORMAL
- en: We could put in a TV screen, as some do. But it makes the elevator more expensive.
    And it also requires a lot of maintenance. We need to put some content on the
    screen, to make it not too repetitive. So either there's a person whose responsibility
    is to renew the content once in a while, or a third-party company that does it
    for us. We'll also have to handle different problems that may occur with screen
    hardware and the software behind it. Seeing the "Blue Screen of Death" is amusing,
    of course, but only mildly.
  prefs: []
  type: TYPE_NORMAL
- en: Some architects even go for putting elevator shafts on the building exterior,
    and making part of the walls transparent. This may provide some exciting views.
    But this solution also requires maintenance (dirty windows don't make for the
    best view), and a lot of architectural planning.
  prefs: []
  type: TYPE_NORMAL
- en: So, we put in a mirror. You get to watch an attractive person even if you ride
    alone. Some studies indicate that we find ourselves more attractive than we are,
    anyway. Maybe you get a chance to review your appearances one last time before
    that important meeting. Mirrors visually expand the visual space and make the
    entire trip less claustrophobic, or less awkward, if it's the start of a day and
    the elevator is really crowded.
  prefs: []
  type: TYPE_NORMAL
- en: Design process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try and understand what we did just now.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't invent mirrors in elevators. We've seen them thousands of times. But
    we formalized the problem (riding in an elevator is boring) and discussed alternative
    solutions (TV screens, glass walls) and the benefits of the commonly used solution
    (solves the problem, easy to implement). That's what design patterns are all about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic steps of the design process are:'
  prefs: []
  type: TYPE_NORMAL
- en: Define exactly what the current problem is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider different alternatives, based on the pros and cons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the solution that solves the problem, while best fitting your specific
    constraints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why use design patterns in Kotlin?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin comes to solve the real-world problems of today. In the following chapters,
    we will discuss both *Design Patterns* first introduced by the Gang of Four back
    in '94, as well as design patterns that emerged from the functional programming
    paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find that some of the design patterns are so common or useful that they're
    already built into the language as reserved keywords or standard functions. Some
    of them will need to combine a set of language features. And some are not so useful
    any more, since the world has moved forward, and they're being replaced by some
    other patterns.
  prefs: []
  type: TYPE_NORMAL
- en: But in any case, familiarity with design patterns and best practices expands
    your "developer toolbox" and creates shared vocabulary between you and your colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, in this chapter, we covered the main goals of the Kotlin programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'We went through the variables that are defined, such as `val`, `var`, null
    safety, and type inference. We observed how program flow is controlled by commands
    such as `if`, `when`, `for`, and `while`, and we also took a look at the different
    keywords used to define classes and interfaces: `class`, `interface`, `data`,
    and `abstract` class. We learned how to construct new classes and how we inherit
    from interfaces and implement classes. And finally, we learned what design patterns
    are good for, and why we need them in Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll start discussing the first of the three design
    pattern families: creation patterns.'
  prefs: []
  type: TYPE_NORMAL
