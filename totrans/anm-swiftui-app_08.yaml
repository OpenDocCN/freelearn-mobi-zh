- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating a Bouquet of Flowers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the next project. Here, we will create a bouquet of flowers, animate
    the flower petals so they open and close, and then add a smoke/vapor effect to
    make it look like the flower is breathing by using the `blur` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the flowers, we will place a winter backdrop, and make it snow too by
    using the `CAEmitter` class. The `CAEmitter` class is a UIKit class that was built
    for animation, but to be able to access it, we will need to use a SwiftUI bridging
    protocol called `UIViewRepresentable`. The `UIViewRepresentable` protocol will
    let us bridge the two frameworks, UIKit and SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: Accompanying this, we will include two labels – **Breathe In** and **Breathe
    Out** – so that you can breathe along with the flowers, similar to a meditation
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables and a winter background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the text labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `blur` modifier to create a vapor effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the flower petals in an arc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the flower bouquet and the animated breath
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating falling snow in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 8` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables and a winter background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s get started and create a new SwiftUI project – I have called it `Breathing
    Flower`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, go ahead and download the assets for this project. The images are `bouquet`,
    `petal`, `smoke`, `snow`, and `winterNight`. After you download them, drop the
    images into the Assets catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the pictures we need loaded into the project. So, let’s start in
    `ContentView` and add the variables we need to make this flower come alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be familiar with the process of creating animating variables by
    now. Here, we made a variety of variables, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Petal`: To track the petal’s movements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`breatheInLabel` and `breatheOutLabel`: To track the **Breathe In** and **Breathe**
    **Out** labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offsetBreath`: To move the breath from inside the flower to outside the flower'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diffuseBreath`: To track the transformation of the smoke from a still image
    to an animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`breatheTheBouquet`: To keep track of the bouquet animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we put these variables to use, let’s head into the `body` property and
    add a winter image to the scene. First, create a `ZStack` in order to hold all
    of the views that we will be adding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is familiar code to us now. Here, we are using the `Image` initializer
    and passing in the background image called `winterNight`, which is in the assets
    catalog. Then, we are resizing the image and using the `aspectRatio` option of
    `fill` to take up the whole screen, before finally giving it some dimensions with
    the `frame` modifier. This is what the scene looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The winterNight background ](img/B18674_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The winterNight background'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added the background to the scene, our next goal is to add
    some labels: **Breathe In** and **Breathe Out**. What we want to achieve here
    is to make the two labels grow and shrink at the same time as the flower petals
    open and close, so these labels will have the same duration and delay as the flower
    petals in the project, perfectly in sync.'
  prefs: []
  type: TYPE_NORMAL
- en: Animating the text labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s add two labels that can act as a guide for the user to watch their
    breath. Still working in the `ZStack` and moving directly underneath the previous
    line of code, add another `ZStack`, and fill it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s dissect this code a little bit and see what we’re doing. First, we’re
    adding a second `ZStack`, then a group, to help keep the code organized.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `Text` initializer and type in whatever text we’d like to appear
    on the screen. In our case, we are typing in `Breathe In` and `Breathe Out`, and
    just like that, we have text on the screen. Then, using the `font` modifier, you
    can change the font to one of your choosing. Xcode comes with many built-in fonts,
    and I am using one called `papyrus`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to know the names of the fonts that you can use for iOS, you
    can go to the following website: [https://developer.apple.com/fonts/system-fonts/](https://developer.apple.com/fonts/system-fonts/).'
  prefs: []
  type: TYPE_NORMAL
- en: As well as choosing the specific font type, we set the font `size` parameter
    to `35`, and use the `foregroundColor` modifier to make the **Breathe In** label
    green and the **Breathe Out** label orange.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the opacity of the text labels is animated here by using the `breatheIn`
    and `breatheOut` variables. When those variables are `true`, their opacity will
    be set to `0`, which makes the label text invisible. But when the `breatheIn`
    and `breatheOut` variables are `false`, the text will be set to `1`, and they
    will become visible again.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we set the size of the two text labels by using the `scaleEffect`
    modifier. We’re using a ternary operator, which checks whether the `breatheIn`
    and `breatheOut` variables are `true` or not; if so, then we will scale the labels
    down to `0`; otherwise, when the `breatheIn` and `breatheOut` variables are `true`,
    we will scale the text labels back up to full size, which is `35` points.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code positions the label on the screen for the `y` axis, using
    the `offset` modifier. Remember, the *y* axis position views vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we add the `animation` modifier. The animation will start as it usually
    does when the `breatheIn` and `breatheOut` variables become `true`. The animation
    will have a duration of 2 seconds, which means it will take 2 seconds to complete,
    and then it will have a delay of 2 seconds before starting again.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that completes the animation of the `onAppear` modifier right after the
    closing brace of the first `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we’ve seen, `onAppear` will run the code in its body when the view first
    appears – that is, when the user taps on the app to open it. The code we want
    to run is the `breatheIn` and `breatheOut` variables; we want to toggle them to
    their opposite Boolean value to start the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this code in the previews or the simulator, you’ll see two labels,
    each with its own color, scaling up and scaling down, and at the same time, fading
    in and out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: The Breathe In and Breathe Out labels added ](img/B18674_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: The Breathe In and Breathe Out labels added'
  prefs: []
  type: TYPE_NORMAL
- en: That completes the labels. Now, let’s focus our attention on making an image
    that looks like vapor to represent breath.
  prefs: []
  type: TYPE_NORMAL
- en: Using the blur modifier to create a vapor effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the project, we will be using the `blur` modifier, which will
    apply a Gaussian blur to an image using a radius value that we specify. If you’re
    not familiar with what a Gaussian blur is, this is a technique that is widely
    used in image editing software (such as Photoshop) and works by reducing the noise
    and detail of an image to create a smooth blurring visual effect.
  prefs: []
  type: TYPE_NORMAL
- en: We will use an image of smoke, called `breath` (which is in the Assets catalog),
    and apply the `blur` modifier to it, which will create a vapor effect and make
    our flower look like it’s breathing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is very little code needed to achieve this effect. Coming out of the
    previous group we made, let’s make a new group and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the group, we use the `Image` initializer and pass in the image we want to
    use, `breath`. Then, we give it some dimensions, with a width of `35` and a height
    of `125`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the code offsets the image vertically on the *y* axis. Then, when
    the `offsetBreath` variable becomes `true`, the image moves `90` points up, so
    it’s coming out of the flower, and when `offsetBreath` is `false`, the image moves
    back down and is set back to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the animation to the image and to the `offset` modifier (yes, we
    can animate an `offset` modifier too!). We are using the same `duration` and `delay`
    values as the text labels (2 seconds, respectively) so that the labels and vapor
    animate in sync.
  prefs: []
  type: TYPE_NORMAL
- en: The next line is the `blur` modifier – this is what creates the magic of turning
    the image into a puff of vapor. This modifier has a parameter called `radius`,
    which accepts any integer number; the smaller the number, the less Gaussian blur
    is applied to the image, whereas the larger the number, the more blurred the image
    becomes. The ternary operator oversees the setting of the `radius` value to either
    `1` or `60`, so depending on whether the `diffuseBreath` variable is `true` or
    `false`, we can control the amount of Gaussian blur on the image. When `diffuseBreath`
    becomes `true`, the image gets blurred by only `1` point, but when `diffuseBreath`
    becomes `false`, the code will add `60` points of Gaussian blur to the image.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the next line of code – this is the `offset` modifier and is responsible
    for positioning the blur. We want to offset the smoke so it moves from inside
    the flower to outside the flower. This is accomplished by checking the `diffuseBreath`
    variable; when it’s `true`, the vapor moves `50` points up, and when it’s `false`,
    the vapor moves `100` points down.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the `animation` modifier will interpolate through all the Gaussian
    blur values, from `1` to `60`. In this interpolation (or looping, if you will),
    these values will act on the image very quickly, so fast that the non-moving still
    image of smoke will be transformed into an actual animation of smoke that will
    move up and disperse, as real smoke does.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that we are using two `animation` modifiers here.
    The reason for this is that the first one is placed right after the `offset` modifier,
    so it is being used to animate the offset of the image up and down; any code we
    add *after* that `animation` modifier will not be animated, hence the use of the
    second `animation` modifier. The second one is used to animate the `blur` modifier
    to make smoke and to animate the offset that moves the smoke. So remember, the
    `animation` modifiers act on the views above them, but if we need to add more
    of them, we can just add them as needed to animate any subsequent views, as we
    have done here.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we add the `shadow` modifier, which will add a subtle shadow of `20`
    points around the moving breath when it exits the flower.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to see the smoke transformation, add the `offsetBreath` and `diffuseBreath`
    variables to the `onAppear` modifier, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: The smoke in our animation ](img/B18674_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: The smoke in our animation'
  prefs: []
  type: TYPE_NORMAL
- en: As the animation starts out, the image of smoke is only being blurred by `1`
    point, but as the `offset` modifier moves the image upward, the blurring increases
    all the way to `60` points. At `60` points, the once still image has now been
    transformed into smoke, mimicking a breath.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, something interesting to check out later is that if you want to
    see the process of the smoke image turning into moving vapor at any time, then
    add this line of code beneath the `shadow` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will move the smoke image to the front of the scene, and you will see it
    being transformed into moving vapor.
  prefs: []
  type: TYPE_NORMAL
- en: With the vapor effect added, we can move on to the next step, which is adding
    the bouquet of flowers to the image.
  prefs: []
  type: TYPE_NORMAL
- en: Animating flower petals in an arc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a background, text labels, and an inhaling and exhaling breath effect;
    now let’s add the petals to the scene. We can add the petal code in a separate
    file, so press *Command* + *N* to bring up the `PetalView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal here is to make five petals move in an arc, so they open and close.
    We only need two variables for this, so this will be a very small file: we need
    one Boolean (`Bool`) variable to track the animation, and another variable to
    hold the number of rotations we want for each petal. Let’s add them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Binding` variable called `petal` will handle the animation. We are using
    the `Binding` wrapper because we are in a new struct, and we will need to use
    this variable in another struct, `ContentView`. When we prefix a variable with
    the `Binding` wrapper, we can then use it (bind it) to another struct or view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now move into the `body` property and create a petal. Add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only three lines of code to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we add the petal image from the Assets Catalog to the scene and appropriately
    size it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we use the `rotationEffect` modifier to open and close the petal by choosing
    between two `degree` values: one value for the petal opening and one for its closing.
    We also anchor the rotation point to the bottom of the petal, so the petals will
    open and close in an arc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we simply call the `animation` modifier to add the animation. Again, we
    continue to keep `duration` and `delay` at `2` seconds and set `autoreverses`
    to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see the petal image in the previews, let’s modify the `previews` struct
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The only change in the `PetalView_Previews` struct is that we use the `petal`
    parameter and pass in the value of `.constant(true)`. This turns the `petal` variable
    to `true`, enabling the previews to display the contents of the `PetalsView` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now move back into `ContentView`, and call this new `PetalView` struct
    five times to display all five petals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code calls `PetalView` four times to add four petals to the UI, and then
    the fifth petal (the middle one) is added by a call to the `Image` initializer,
    as this petal will not be animated. The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: The petals  ](img/B18674_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: The petals'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the dollar sign syntax (`$`) for the `petal` parameter: that is how
    we use the `Binding` variable in another struct. In the `degrees` parameter, we
    have two values: again, one for when the petal is open, and one for when it is
    closed. When the binding `$petal` property is `true`, the `degrees` value on the
    left is used, and when the `$petal` property is `false`, the `degrees` value on
    the right will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the middle petal will not be animated, so we only need to call the `Image`
    initializer and then set its size. The remaining petals use the same code; the
    only changes are the values for the `degrees` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that completes the petals. Let’s see how they animate by toggling the `petal`
    variable in the `onAppear` method, as we have done with the other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The petals open and close as we have set them up – to a specific point, rotating
    in an arc, and then closing again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: The petals animated ](img/B18674_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The petals animated'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three components left to add to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: A bouquet of flowers positioned directly over the petals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moving breath surrounding the flowers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snow falling in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next section, we will implement the first two points: adding the bouquet
    and the moving breath.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the flower bouquet and the animated breath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding the first component, the bouquet, is relatively easy, as it is stuff
    we have already done; however, the second component, the moving breath, is a little
    tricky (but not to worry, we will go slow and everything will be explained).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first up, the bouquet. In `ContentView`, after the petal group’s closing
    brace, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This looks like a lot of code, but really, we are creating two bouquets using
    very similar code. The reason why I’m using two bouquets and overlapping them
    is to create the illusion of a full bunch of flowers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at the code. We start with the grouping organizational feature,
    and inside the group, we add the image for both bouquets. I’m setting the aspect
    ratio to `fit`, so the bouquet image keeps its proportional size, and framing
    the image with a value of `300` x `400`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the `rotation` modifier on each bouquet, so we can rotate them
    to the proper angle we want in the scene; a `37`-degree rotation for the first
    bouquet looks good, whereas `32` degrees for the second bouquet works better for
    that one. Then, each bouquet gets offset a little bit on the `x` and `y` axes,
    so they’re neatly positioned directly over the breath. This location will help
    hide the breath, as we don’t want to see that until it animates up from the bouquet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line scales the bouquets up a little. The reason for this is that
    we want to create the effect that the bouquets are breathing as well, along with
    the petals. The top bouquet gets scaled up to `1.04`, and the bottom bouquet gets
    scaled to `1.02`. Notice the top bouquet gets scaled up slightly more than the
    bottom bouquet: this is because we wanted to stagger the two bouquets a little.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, `anchor` is set to `center`, so the two bouquets will expand and contract
    from that point.
  prefs: []
  type: TYPE_NORMAL
- en: The next line adds some hue rotation to the color of the bouquets so that they
    will change color along with the animation. We previously used the `hueRotation`
    modifier in [*Chapter 5*](B18674_05.xhtml#_idTextAnchor073), so that’s nothing
    new here, but we are using different values for `hueRotation` to help make the
    bouquets more varied in appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we use the `rotation3DEffect` modifier only on the bottom bouquet.
    This is because the bouquet image for the top and bottom are identical; they are
    simply one image that we’re using in two places, so by using the `rotation3DEffect`
    modifier here and passing in a value of `1` for the `y` parameter, this will flip
    the bouquet image on the *y* axis to the bouquet’s opposite side. This helps give
    the overall look a more symmetrical appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the animation for both bouquets; this is the same animation
    as we’ve done for the previous views, with a 2-second duration and a 2-second
    delay, so all the animations are in sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to see this animation in action, once again, we need to add the
    animating variable in charge of the bouquet to the `onAppear` modifier. So, add
    the following code to the `onAppear` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we run the app, we will see the two bouquets expanding and contracting
    slightly, along with the petals moving too. You will also see the bouquets’ colors
    changing, which is due to the `hueRotation` modifier we used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: The bouquet moving ](img/B18674_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The bouquet moving'
  prefs: []
  type: TYPE_NORMAL
- en: The bouquet expanding and contracting is a subtle look (it’s not pronounced
    like the petals opening and closing), which is the look we’re going for here;
    we just want to create a slight expanding effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that done and our app already looking really good, we just need to add
    one more component to the project: snow.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating falling snow in the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making snow fall within your app really makes it come alive: it gives a rather
    magical look to it and sets the right mood for our winter scene. To do this, we
    need to utilize the power of UIKit and the `UIViewRepresentable` protocol, along
    with the `CAEmitter` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you continue through the rest of this chapter, don’t worry if some of the
    UIKit classes and methods look different or unfamiliar to you as compared to the
    SwiftUI classes and methods we’ve been using. That’s because they *are* different,
    and that’s for a whole different book if you’d like to learn about UIKit. However,
    moving forward in this chapter, I will explain the different UIKit properties
    and methods used to make the snow for our animation, so you can get familiar with
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the UIViewRepresentable protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIViewRepresentable` protocol is what’s called a **wrapper** for UIKit.
    It allows SwiftUI to work with UIKit and use UIKits classes and methods. If you’ve
    ever coded with UIKit, you’ll know it’s quite different compared to SwiftUI. For
    one thing, it uses something called **Storyboards**, which are a different way
    to design your layout and organize your views by way of dragging and dropping
    objects from an object library, such as buttons and sliders and text, and connecting
    them together on a big storyboard in Xcode. The positioning of all those objects
    is completely different as well and uses a system called **Auto Layout**, which
    is a system of methods and rules to keep your objects spaced apart and located
    on the screen, but it was very complicated and had a big learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI eliminates Storyboards and Auto Layout and is a complete departure from
    UIKit in how you design and build apps. It’s simpler and uses much less code to
    achieve the same results (as you probably already know). But, occasionally, we
    need to access some of the methods and classes that UIKit offers in order to do
    different things in our apps – for example, here, to make snow. That’s why we
    need the `UIViewRepresentable` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The `UIViewRepresentable` protocol acts as a bridge between these two different
    frameworks, UIKit and SwiftUI, and lets us access the classes and methods we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a new file to contain the snow code. Press *Command* + *N*
    and create a SwiftUIView file called `SnowView`. Then, at the top of the struct,
    we will modify its heading to make it conform to the `UIViewRepresentable` protocol.
    So, change the struct’s heading to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we add the `UIViewRepresentable` protocol to the struct’s heading (right
    after the colon), this tells the system that we are now allowed to use the classes
    and methods from the UIKit framework. It also means we have to implement the required
    methods for this protocol. Some protocols only need you to declare them into a
    struct heading, as we have just done, but others also need you to implement some
    methods in order to satisfy the protocol requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with methods and errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UIViewRepresentable` requires that we add two methods to the struct: `makeUIView`
    and `updateView`. But because we haven’t added those methods yet, the change we
    just made will break our code and display an error: **SnowView does not conform
    to protocol UIViewRepresentable**. That is true because, as mentioned, we need
    to implement two methods to satisfy this protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s add the first method now, `makeUIView`, by adding the following code
    to the `SnowView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `makeUIView` method returns `UIView`, which will contain the snow, so we
    can use it in the `ContentView` later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method we need to add is called `updateView`, which we can do directly
    under the previous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This method is used when we want to update the view with new data. Since we
    don’t need to do any updating when the snow is made, we can leave this method
    empty. However, it’s a required method so it does have to be here in the `SnowView`
    struct; otherwise, the code won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the two required methods, the protocol should be satisfied.
    However, we still get an error: `makeUIView` method and the fact that it has no
    return code in its body. The `makeUIView` method needs to return `UIView` (or
    simply, a view) in order for the error to go away. So, let’s fill out the `makeUIView`
    method with the code that will return a view, which will, in turn, make our snow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set up the size of the view to fit the screen correctly.
    Remember, we are making a new view using UIKit’s classes and methods, so we have
    to tell it how big the screen dimensions should be for this view. Add the following
    code to the `makeUIView` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code creates a constant that will hold the bounds of the screen
    – that’s the rectangle of the screen from top to bottom and left to right.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code creates the view that we will need to return when we
    finish writing this method out. We’re setting the view to the size of the screen’s
    width and height so that when we make the snow, we’re using the entire boundaries
    of the iPhone screen, not just a little portion of it.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code uses the `masksToBounds` Boolean property and sets it
    to `true`. The `masksToBounds` property indicates to the system whether sublayers
    are clipped to the layer’s bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '`ZStack`, each view you place inside it gets stacked upon the previous view.'
  prefs: []
  type: TYPE_NORMAL
- en: So with all this stacking up of views, there may be parts of a view that you
    may not want to show, and other parts of that same view you do want to show. The
    `maskToBounds` property will clip any subviews to the bounds of the screen, which
    is helpful because we only want the snow to fall within the size of the screen;
    we don’t want any snow in any surrounding areas off the screen, only within the
    bounds of the screen, so we set this property to `true` to clip off any excess.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to return a view in order to silence this error. Remember, the
    `makeUIView` method has a `return` statement in its declaration, so add the following
    code at the end of our previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have our screen size set up, we are returning a view, and we are error-free!
    The next task is to create the snow, which we can do by using UIKit’s `CAEmitter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CAEmitter class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CAEmitter** (which stands for **Core Animation Emitter**) is a class that
    has methods and properties that let us emit, animate, and render particle systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what’s a particle system? A particle system is just what it sounds like:
    a system that can produce hundreds or thousands of little particles on the iPhone
    screen, in any size that we want, moving at any speed that we set, and in any
    shape that we design.'
  prefs: []
  type: TYPE_NORMAL
- en: The particle shape that we want has already been designed because we will be
    using the `snowflake` image that we will drop into the assets catalog. However,
    we have to design how many snowflakes to make, how fast to make them move, how
    long to keep them on the screen, and the location on the screen from which they
    are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s go ahead and create an `emitter` instance, using the `CAEmitter`
    class. Add the following code just underneath the `masksToBounds` line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates the `emitter` instance using the `CAEmitter` class.
  prefs: []
  type: TYPE_NORMAL
- en: The next line sets the location and size of the emitter. Here, we are locating
    the emitter `200` points along the `x` axis, which is about the middle of the
    iPhone screen, and `-100` points along the `y` axis. This puts the emitter 100
    points up and off from the iPhone screen. We put the emitter above the visible
    portion of the screen because we don’t want to see the snowflakes being created,
    we just want to see them falling.
  prefs: []
  type: TYPE_NORMAL
- en: As for the size of the emitter, we’re making it the exact size as the iPhone
    screen, which means using the `frame.width` and `frame.height` values.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve designed our emitter, let’s design the cell. To explain the difference
    between these two terms, think of the **emitter** as a box that holds thousands
    of confetti particles, and each of those confetti particles is a **cell**. In
    our case, our cell will be a snowflake.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our cell and make it move on screen, add the following code just under
    the emitter code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created the `cell` instance using the `CAEmitterCell` class and loaded
    it up with different properties. The following is a list of what these properties
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`birthRate`: How fast each cell or particle will be made. Using a value of
    `40` mimics a gentle snowfall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lifetime`: How long to keep the cell on the screen before it’s removed. Using
    a value of `25` ensures that each snowflake stays on the screen long enough to
    make it to the bottom of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`velocity`: How fast we want the cell to move on the screen. We’re using a
    value of `60`, which is a speed that’s not too fast or too slow for the snowflake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`: How big we want to make each cell. A value of `.025` is a nice size
    for the snowflake, as it’s not too big or too small for an iPhone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emissionRange`: How far we want to spread out the cells as they are being
    emitted. For this value, we are using a mathematical expression called Pi (often
    shown as the symbol π), which is defined as the circumference of a circle divided
    by the diameter of the same circle. Without getting too mathematical here, the
    `CGFloat.pi` value equals `180` degrees – imagine a horizontal line drawn from
    the left to the right side of the phone screen; the value sets the snow to fall
    evenly from all areas of that line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contents`: Sets the contents of the cell to an image of our choice, which
    was set as the `snow` image (make sure that you’ve added the image into the Assets
    Catalog so it can be accessed with this line of code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emitterCells`: The cell particles that will become the snow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addSublayer`: Adds a new layer to the scene. Remember that in SwiftUI, a layer
    is very similar to a view, and everything is a view in SwiftUI (buttons, text,
    colors, and more). In the UIKit world, a layer can also be thought of as a view
    – when the `addSublayer` function is called, it will add whatever layer is in
    its parameter to the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, these cell configuration values are completely arbitrary, so go ahead
    and experiment and make the snowflakes as big as you want, design them how you
    want, and make them move on the screen according to what you want them to do.
    There are no hard and fast rules when adding values into a cell; it’s all about
    experimenting and having fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with that, we have completed the snow file. If you want to test the result,
    you can click **Play**; however, as the default background of the preview is white,
    you won’t see our white snow. You can change this by swapping the background color,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That will change the background color to black so you can see the snow; however,
    as we know, we will be using a winter background for the final animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to finish things off, we need to call this `SnowView` file inside `ContentView`.
    To do that, head back to `ContentView` and add this final line of code right under
    the background code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And that completes the project. You can now go ahead and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: The finished project ](img/B18674_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: The finished project'
  prefs: []
  type: TYPE_NORMAL
- en: The project has a breathing label animation, a breathing petal animation, a
    breathing bouquet animation, and a snow animation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we created the illusion of a bouquet of flowers breathing
    by using a collection of coding modifiers: we used `blur` to create the illusion
    of smoke, and `scale` and `rotationEffect` to make the flowers expand and contract
    in an arc, and we also added labels on the screen. On top of this, we used the
    `UIViewRepresentable` protocol and the `CAEmitter` class, and incorporated particle
    systems to create falling snow.'
  prefs: []
  type: TYPE_NORMAL
- en: Here are some extra thoughts on how to take this app further, or just practice
    adding some more features, to help stretch your skills with SwiftUI animations.
    How about adding some sound to the project? We did that in [*Chapter 4*](B18674_04.xhtml#_idTextAnchor060)
    with the Record Player project, and it’s very easy to do – you could add some
    guided voice narration that simply says “breathe in, breathe out” or some meditative
    music.
  prefs: []
  type: TYPE_NORMAL
- en: Or how about adding a button or slider that will change the speed of the animation?
    Maybe you want to increase the petal opening and closing speed. If you’re not
    sure how to do that, keep following along in the book because, later, we will
    build a color game with a UI that uses buttons and sliders.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue to the next chapter, where we will see how to animate a `stroke`
    modifier so it creates a moving line around any shape.
  prefs: []
  type: TYPE_NORMAL
