- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Animating a Bouquet of Flowers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画一束花
- en: Welcome to the next project. Here, we will create a bouquet of flowers, animate
    the flower petals so they open and close, and then add a smoke/vapor effect to
    make it look like the flower is breathing by using the `blur` modifier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到下一个项目。在这里，我们将创建一束花，动画花瓣使其开合，然后添加烟雾/蒸汽效果，使其看起来像花在呼吸，使用`blur`修改器。
- en: Behind the flowers, we will place a winter backdrop, and make it snow too by
    using the `CAEmitter` class. The `CAEmitter` class is a UIKit class that was built
    for animation, but to be able to access it, we will need to use a SwiftUI bridging
    protocol called `UIViewRepresentable`. The `UIViewRepresentable` protocol will
    let us bridge the two frameworks, UIKit and SwiftUI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在花朵后面，我们将放置一个冬季背景，并使用`CAEmitter`类使其下雪。`CAEmitter`类是一个用于动画的UIKit类，但为了能够访问它，我们需要使用一个名为`UIViewRepresentable`的SwiftUI桥接协议。`UIViewRepresentable`协议将使我们能够桥接两个框架，UIKit和SwiftUI。
- en: Accompanying this, we will include two labels – **Breathe In** and **Breathe
    Out** – so that you can breathe along with the flowers, similar to a meditation
    app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们将包括两个标签——**吸气**和**呼气**——这样你就可以与花朵一起呼吸，类似于冥想应用。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Adding the variables and a winter background
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加变量和冬季背景
- en: Animating the text labels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画文本标签
- en: Using the `blur` modifier to create a vapor effect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`blur`修改器创建蒸汽效果
- en: Animating the flower petals in an arc
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在弧形中动画花瓣
- en: Adding the flower bouquet and the animated breath
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加花束和动画呼吸
- en: Creating falling snow in the scene
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中创建下雪效果
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the resources and finished project from the `Chapter 8` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub上的`Chapter 8`文件夹下载资源和完善的项目：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: Adding the variables and a winter background
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加变量和冬季背景
- en: Let’s get started and create a new SwiftUI project – I have called it `Breathing
    Flower`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个新的SwiftUI项目——我将其命名为`Breathing Flower`。
- en: Next, go ahead and download the assets for this project. The images are `bouquet`,
    `petal`, `smoke`, `snow`, and `winterNight`. After you download them, drop the
    images into the Assets catalog.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请继续下载本项目的资源。这些图像包括`bouquet`、`petal`、`smoke`、`snow`和`winterNight`。下载后，将这些图像拖放到资源目录中。
- en: 'We now have the pictures we need loaded into the project. So, let’s start in
    `ContentView` and add the variables we need to make this flower come alive:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将所需的图片加载到项目中。那么，让我们从`ContentView`开始，添加使这朵花栩栩如生的变量：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should be familiar with the process of creating animating variables by
    now. Here, we made a variety of variables, including the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了创建动画变量的过程。在这里，我们创建了许多变量，包括以下内容：
- en: '`Petal`: To track the petal’s movements'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Petal`：用于追踪花瓣的运动'
- en: '`breatheInLabel` and `breatheOutLabel`: To track the **Breathe In** and **Breathe**
    **Out** labels'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`breatheInLabel` 和 `breatheOutLabel`：用于追踪**吸气**和**呼气**标签'
- en: '`offsetBreath`: To move the breath from inside the flower to outside the flower'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offsetBreath`：将呼吸从花内部移动到花外部'
- en: '`diffuseBreath`: To track the transformation of the smoke from a still image
    to an animation'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`diffuseBreath`：跟踪烟雾从静态图像到动画的转换'
- en: '`breatheTheBouquet`: To keep track of the bouquet animation'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`breatheTheBouquet`：用于跟踪花束动画'
- en: 'Before we put these variables to use, let’s head into the `body` property and
    add a winter image to the scene. First, create a `ZStack` in order to hold all
    of the views that we will be adding:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将这些变量投入使用之前，让我们进入`body`属性，并向场景添加一个冬季图像。首先，创建一个`ZStack`来容纳我们将要添加的所有视图：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is familiar code to us now. Here, we are using the `Image` initializer
    and passing in the background image called `winterNight`, which is in the assets
    catalog. Then, we are resizing the image and using the `aspectRatio` option of
    `fill` to take up the whole screen, before finally giving it some dimensions with
    the `frame` modifier. This is what the scene looks like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们现在熟悉的代码。在这里，我们使用`Image`初始化器，并传入名为`winterNight`的背景图像，该图像位于资源目录中。然后，我们调整图像大小，并使用`fill`的`aspectRatio`选项使其占据整个屏幕，最后使用`frame`修改器为其添加一些尺寸。这就是场景的样子：
- en: '![Figure 8.1: The winterNight background ](img/B18674_08_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：冬夜背景](img/B18674_08_01.jpg)'
- en: 'Figure 8.1: The winterNight background'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：冬季夜晚背景
- en: 'Now that we have added the background to the scene, our next goal is to add
    some labels: **Breathe In** and **Breathe Out**. What we want to achieve here
    is to make the two labels grow and shrink at the same time as the flower petals
    open and close, so these labels will have the same duration and delay as the flower
    petals in the project, perfectly in sync.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为场景添加了背景，我们的下一个目标是添加一些标签：**Breathe In** 和 **Breathe Out**。我们想要实现的是让这两个标签在花瓣打开和关闭的同时生长和收缩，因此这些标签将具有与项目中花瓣相同的持续时间和延迟，完美同步。
- en: Animating the text labels
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画文本标签
- en: 'Now, let’s add two labels that can act as a guide for the user to watch their
    breath. Still working in the `ZStack` and moving directly underneath the previous
    line of code, add another `ZStack`, and fill it with the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加两个标签，作为用户观察呼吸的指南。仍然在 `ZStack` 中工作，直接在上一行代码的下方添加另一个 `ZStack`，并填充以下内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s dissect this code a little bit and see what we’re doing. First, we’re
    adding a second `ZStack`, then a group, to help keep the code organized.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微分析一下这段代码，看看我们在做什么。首先，我们添加了一个第二个 `ZStack`，然后是一个组，以帮助保持代码的整洁。
- en: Next, we use the `Text` initializer and type in whatever text we’d like to appear
    on the screen. In our case, we are typing in `Breathe In` and `Breathe Out`, and
    just like that, we have text on the screen. Then, using the `font` modifier, you
    can change the font to one of your choosing. Xcode comes with many built-in fonts,
    and I am using one called `papyrus`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `Text` 初始化器并输入我们希望在屏幕上显示的任何文本。在我们的例子中，我们输入了 `Breathe In` 和 `Breathe
    Out`，就这样，我们在屏幕上有了文本。然后，使用 `font` 修饰符，你可以将字体更改为你选择的任何一种。Xcode 内置了许多字体，我正在使用一个名为
    `papyrus` 的字体。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you’d like to know the names of the fonts that you can use for iOS, you
    can go to the following website: [https://developer.apple.com/fonts/system-fonts/](https://developer.apple.com/fonts/system-fonts/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道可用于 iOS 的字体名称，你可以访问以下网站：[https://developer.apple.com/fonts/system-fonts/](https://developer.apple.com/fonts/system-fonts/)。
- en: As well as choosing the specific font type, we set the font `size` parameter
    to `35`, and use the `foregroundColor` modifier to make the **Breathe In** label
    green and the **Breathe Out** label orange.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择特定的字体类型外，我们还设置了字体 `size` 参数为 `35`，并使用 `foregroundColor` 修饰符将 **Breathe In**
    标签设置为绿色，将 **Breathe Out** 标签设置为橙色。
- en: Next, the opacity of the text labels is animated here by using the `breatheIn`
    and `breatheOut` variables. When those variables are `true`, their opacity will
    be set to `0`, which makes the label text invisible. But when the `breatheIn`
    and `breatheOut` variables are `false`, the text will be set to `1`, and they
    will become visible again.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用 `breatheIn` 和 `breatheOut` 变量来动画化文本标签的不透明度。当这些变量为 `true` 时，它们的不透明度将被设置为
    `0`，这使得标签文本不可见。但当 `breatheIn` 和 `breatheOut` 变量为 `false` 时，文本将被设置为 `1`，它们将再次变得可见。
- en: After that, we set the size of the two text labels by using the `scaleEffect`
    modifier. We’re using a ternary operator, which checks whether the `breatheIn`
    and `breatheOut` variables are `true` or not; if so, then we will scale the labels
    down to `0`; otherwise, when the `breatheIn` and `breatheOut` variables are `true`,
    we will scale the text labels back up to full size, which is `35` points.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过使用 `scaleEffect` 修饰符设置两个文本标签的大小。我们使用三元运算符，检查 `breatheIn` 和 `breatheOut`
    变量是否为 `true`；如果是，则将标签缩放到 `0`；否则，当 `breatheIn` 和 `breatheOut` 变量为 `true` 时，我们将文本标签恢复到全尺寸，即
    `35` 点。
- en: The next line of code positions the label on the screen for the `y` axis, using
    the `offset` modifier. Remember, the *y* axis position views vertically.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码使用 `offset` 修饰符在屏幕上定位标签的 `y` 轴位置。记住，*y* 轴位置视图是垂直的。
- en: Lastly, we add the `animation` modifier. The animation will start as it usually
    does when the `breatheIn` and `breatheOut` variables become `true`. The animation
    will have a duration of 2 seconds, which means it will take 2 seconds to complete,
    and then it will have a delay of 2 seconds before starting again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了 `animation` 修饰符。动画将在 `breatheIn` 和 `breatheOut` 变量变为 `true` 时开始，就像通常那样。动画将持续
    2 秒，这意味着它需要 2 秒才能完成，然后会有 2 秒的延迟再次开始。
- en: 'And that completes the animation of the `onAppear` modifier right after the
    closing brace of the first `ZStack`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就在第一个 `ZStack` 的闭合括号之后完成了 `onAppear` 修饰符的动画：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we’ve seen, `onAppear` will run the code in its body when the view first
    appears – that is, when the user taps on the app to open it. The code we want
    to run is the `breatheIn` and `breatheOut` variables; we want to toggle them to
    their opposite Boolean value to start the animation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`onAppear`会在视图首次出现时运行其体内的代码——也就是说，当用户点击应用以打开它时。我们想要运行的代码是`breatheIn`和`breatheOut`变量；我们想要将它们切换到其相反的布尔值以启动动画。
- en: 'When you run this code in the previews or the simulator, you’ll see two labels,
    each with its own color, scaling up and scaling down, and at the same time, fading
    in and out:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在预览或模拟器中运行此代码时，你会看到两个标签，每个标签都有其自己的颜色，可以放大和缩小，同时，还可以淡入淡出：
- en: '![Figure 8.2: The Breathe In and Breathe Out labels added ](img/B18674_08_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：添加了“吸气”和“呼气”标签](img/B18674_08_02.jpg)'
- en: 'Figure 8.2: The Breathe In and Breathe Out labels added'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：添加了“吸气”和“呼气”标签
- en: That completes the labels. Now, let’s focus our attention on making an image
    that looks like vapor to represent breath.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了标签。现在，让我们集中精力制作一个看起来像蒸汽的图像来表示呼吸。
- en: Using the blur modifier to create a vapor effect
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模糊修饰符创建蒸汽效果
- en: In this part of the project, we will be using the `blur` modifier, which will
    apply a Gaussian blur to an image using a radius value that we specify. If you’re
    not familiar with what a Gaussian blur is, this is a technique that is widely
    used in image editing software (such as Photoshop) and works by reducing the noise
    and detail of an image to create a smooth blurring visual effect.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目部分，我们将使用`blur`修饰符，它将使用我们指定的半径值对图像应用Gaussian模糊。如果你不熟悉高斯模糊是什么，这是一种在图像编辑软件（如Photoshop）中广泛使用的技巧，它通过减少图像的噪声和细节来创建平滑的模糊视觉效果。
- en: We will use an image of smoke, called `breath` (which is in the Assets catalog),
    and apply the `blur` modifier to it, which will create a vapor effect and make
    our flower look like it’s breathing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`breath`的烟雾图像（它在资产目录中），并对其应用`blur`修饰符，这将创建蒸汽效果并使花朵看起来像在呼吸。
- en: 'There is very little code needed to achieve this effect. Coming out of the
    previous group we made, let’s make a new group and add the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此效果所需的代码非常少。从我们之前创建的组中出来，让我们创建一个新的组并添加以下代码：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the group, we use the `Image` initializer and pass in the image we want to
    use, `breath`. Then, we give it some dimensions, with a width of `35` and a height
    of `125`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在组中，我们使用`Image`初始化器并传入我们想要使用的图像，`breath`。然后，我们给它一些尺寸，宽度为`35`，高度为`125`。
- en: After that, the code offsets the image vertically on the *y* axis. Then, when
    the `offsetBreath` variable becomes `true`, the image moves `90` points up, so
    it’s coming out of the flower, and when `offsetBreath` is `false`, the image moves
    back down and is set back to `0`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，代码在`y`轴上垂直偏移图像。然后，当`offsetBreath`变量变为`true`时，图像向上移动`90`点，因此它从花朵中出来，而当`offsetBreath`为`false`时，图像会向下移动并恢复到`0`。
- en: Next, we add the animation to the image and to the `offset` modifier (yes, we
    can animate an `offset` modifier too!). We are using the same `duration` and `delay`
    values as the text labels (2 seconds, respectively) so that the labels and vapor
    animate in sync.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将动画添加到图像和`offset`修饰符中（是的，我们也可以对`offset`修饰符进行动画处理！）。我们使用与文本标签相同的`duration`和`delay`值（分别为2秒），以便标签和蒸汽动画同步进行。
- en: The next line is the `blur` modifier – this is what creates the magic of turning
    the image into a puff of vapor. This modifier has a parameter called `radius`,
    which accepts any integer number; the smaller the number, the less Gaussian blur
    is applied to the image, whereas the larger the number, the more blurred the image
    becomes. The ternary operator oversees the setting of the `radius` value to either
    `1` or `60`, so depending on whether the `diffuseBreath` variable is `true` or
    `false`, we can control the amount of Gaussian blur on the image. When `diffuseBreath`
    becomes `true`, the image gets blurred by only `1` point, but when `diffuseBreath`
    becomes `false`, the code will add `60` points of Gaussian blur to the image.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是`blur`修饰符——这就是将图像变成一团蒸汽的魔法所在。此修饰符有一个名为`radius`的参数，它接受任何整数；数字越小，对图像应用的Gaussian模糊越少，而数字越大，图像就越模糊。三元运算符负责将`radius`值设置为`1`或`60`，因此，根据`diffuseBreath`变量是`true`还是`false`，我们可以控制图像上的Gaussian模糊量。当`diffuseBreath`变为`true`时，图像只会被模糊`1`点，但当`diffuseBreath`变为`false`时，代码将向图像添加`60`点的Gaussian模糊。
- en: Let’s look at the next line of code – this is the `offset` modifier and is responsible
    for positioning the blur. We want to offset the smoke so it moves from inside
    the flower to outside the flower. This is accomplished by checking the `diffuseBreath`
    variable; when it’s `true`, the vapor moves `50` points up, and when it’s `false`,
    the vapor moves `100` points down.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一行代码——这是`offset`修改器，它负责定位模糊。我们希望将烟雾偏移，使其从花内部移动到花外部。这是通过检查`diffuseBreath`变量来实现的；当它是`true`时，蒸汽向上移动`50`点，当它是`false`时，蒸汽向下移动`100`点。
- en: After that, the `animation` modifier will interpolate through all the Gaussian
    blur values, from `1` to `60`. In this interpolation (or looping, if you will),
    these values will act on the image very quickly, so fast that the non-moving still
    image of smoke will be transformed into an actual animation of smoke that will
    move up and disperse, as real smoke does.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`animation`修改器将通过所有高斯模糊值进行插值，从`1`到`60`。在这个插值（或者如果你愿意，循环），这些值会非常快速地作用于图像，以至于非移动的静止烟雾图像将变成一个实际移动并散开的烟雾动画，就像真实的烟雾一样。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may also have noticed that we are using two `animation` modifiers here.
    The reason for this is that the first one is placed right after the `offset` modifier,
    so it is being used to animate the offset of the image up and down; any code we
    add *after* that `animation` modifier will not be animated, hence the use of the
    second `animation` modifier. The second one is used to animate the `blur` modifier
    to make smoke and to animate the offset that moves the smoke. So remember, the
    `animation` modifiers act on the views above them, but if we need to add more
    of them, we can just add them as needed to animate any subsequent views, as we
    have done here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了我们在这里使用了两个`animation`修改器。这样做的原因是第一个修改器紧跟在`offset`修改器之后，因此它被用来动画化图像的上下偏移；任何添加在`animation`修改器之后的代码将不会进行动画化，这就是为什么需要第二个`animation`修改器。第二个修改器用于动画化`blur`修改器以产生烟雾，并动画化移动烟雾的偏移。所以记住，`animation`修改器作用于它们上面的视图，但如果我们需要添加更多的它们，我们只需按需添加以动画化任何后续视图，就像我们在这里所做的那样。
- en: Lastly, we add the `shadow` modifier, which will add a subtle shadow of `20`
    points around the moving breath when it exits the flower.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了`shadow`修改器，它将在移动的呼吸离开花时在其周围添加一个微妙的`20`点阴影。
- en: 'Now, to see the smoke transformation, add the `offsetBreath` and `diffuseBreath`
    variables to the `onAppear` modifier, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到烟雾的转换效果，将`offsetBreath`和`diffuseBreath`变量添加到`onAppear`修改器中，如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is what we can see:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们能看到的内容：
- en: '![Figure 8.3: The smoke in our animation ](img/B18674_08_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：动画中的烟雾](img/B18674_08_03.jpg)'
- en: 'Figure 8.3: The smoke in our animation'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：动画中的烟雾
- en: As the animation starts out, the image of smoke is only being blurred by `1`
    point, but as the `offset` modifier moves the image upward, the blurring increases
    all the way to `60` points. At `60` points, the once still image has now been
    transformed into smoke, mimicking a breath.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画开始时，烟雾的图像仅被`1`点模糊，但随着`offset`修改器将图像向上移动，模糊程度逐渐增加到`60`点。在`60`点时，原本静止的图像已经变成了烟雾，模仿了呼吸的效果。
- en: 'As an aside, something interesting to check out later is that if you want to
    see the process of the smoke image turning into moving vapor at any time, then
    add this line of code beneath the `shadow` modifier:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为补充，稍后值得关注的一个有趣的事情是，如果你想在任何时候看到烟雾图像变成移动蒸汽的过程，那么在`shadow`修改器下面添加这一行代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will move the smoke image to the front of the scene, and you will see it
    being transformed into moving vapor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动烟雾图像到场景的前面，你会看到它被转换成移动的蒸汽。
- en: With the vapor effect added, we can move on to the next step, which is adding
    the bouquet of flowers to the image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了蒸汽效果之后，我们可以继续下一步，即将花束添加到图像中。
- en: Animating flower petals in an arc
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以弧形动画化花瓣
- en: We have a background, text labels, and an inhaling and exhaling breath effect;
    now let’s add the petals to the scene. We can add the petal code in a separate
    file, so press *Command* + *N* to bring up the `PetalView`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个背景，文本标签，以及吸气和呼气的呼吸效果；现在让我们将花瓣添加到场景中。我们可以将花瓣代码放在一个单独的文件中，因此按*Command* +
    *N*来打开`PetalView`。
- en: 'The goal here is to make five petals move in an arc, so they open and close.
    We only need two variables for this, so this will be a very small file: we need
    one Boolean (`Bool`) variable to track the animation, and another variable to
    hold the number of rotations we want for each petal. Let’s add them now:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是让五个花瓣沿着弧线移动，以便它们可以打开和关闭。为此，我们只需要两个变量，所以这将是一个非常小的文件：我们需要一个布尔值（`Bool`）变量来跟踪动画，还需要另一个变量来保存每个花瓣想要的旋转次数。现在让我们添加它们：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Binding` variable called `petal` will handle the animation. We are using
    the `Binding` wrapper because we are in a new struct, and we will need to use
    this variable in another struct, `ContentView`. When we prefix a variable with
    the `Binding` wrapper, we can then use it (bind it) to another struct or view.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `petal` 的 `Binding` 变量将处理动画。我们使用 `Binding` 包装器，因为我们处于一个新的结构体中，并且我们还需要在另一个结构体
    `ContentView` 中使用这个变量。当我们用一个 `Binding` 包装器作为前缀来标记一个变量时，我们就可以将其（绑定）用于另一个结构体或视图。
- en: 'Let’s now move into the `body` property and create a petal. Add the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入 `body` 属性并创建一个花瓣。添加以下代码：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are only three lines of code to look at:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 只需查看三行代码：
- en: First, we add the petal image from the Assets Catalog to the scene and appropriately
    size it.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将从资产目录中添加花瓣图像到场景中，并适当地调整其大小。
- en: 'Next, we use the `rotationEffect` modifier to open and close the petal by choosing
    between two `degree` values: one value for the petal opening and one for its closing.
    We also anchor the rotation point to the bottom of the petal, so the petals will
    open and close in an arc.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `rotationEffect` 修饰符通过选择两个 `degree` 值来打开和关闭花瓣：一个用于花瓣打开，一个用于关闭。我们还把旋转点锚定在花瓣的底部，这样花瓣就可以沿着弧线打开和关闭。
- en: Then, we simply call the `animation` modifier to add the animation. Again, we
    continue to keep `duration` and `delay` at `2` seconds and set `autoreverses`
    to `true`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们简单地调用 `animation` 修饰符来添加动画。同样，我们继续将 `duration` 和 `delay` 设置为 `2` 秒，并将 `autoreverses`
    设置为 `true`。
- en: 'To see the petal image in the previews, let’s modify the `previews` struct
    to look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要在预览中看到花瓣图像，让我们修改 `previews` 结构体，使其看起来像这样：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only change in the `PetalView_Previews` struct is that we use the `petal`
    parameter and pass in the value of `.constant(true)`. This turns the `petal` variable
    to `true`, enabling the previews to display the contents of the `PetalsView` struct.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PetalView_Previews` 结构体中的唯一变化是，我们使用 `petal` 参数并传入 `.constant(true)` 的值。这使
    `petal` 变量变为 `true`，从而启用预览以显示 `PetalsView` 结构体的内容。
- en: 'Let’s now move back into `ContentView`, and call this new `PetalView` struct
    five times to display all five petals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到 `ContentView`，并调用这个新的 `PetalView` 结构体五次来显示所有五个花瓣：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code calls `PetalView` four times to add four petals to the UI, and then
    the fifth petal (the middle one) is added by a call to the `Image` initializer,
    as this petal will not be animated. The result is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用 `PetalView` 四次来在 UI 中添加四个花瓣，然后通过调用 `Image` 初始化器添加第五个花瓣（中间的一个），因为这个花瓣不会进行动画处理。结果如下所示：
- en: '![Figure 8.4: The petals  ](img/B18674_08_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4：花瓣](img/B18674_08_04.jpg)'
- en: 'Figure 8.4: The petals'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：花瓣
- en: 'Notice the dollar sign syntax (`$`) for the `petal` parameter: that is how
    we use the `Binding` variable in another struct. In the `degrees` parameter, we
    have two values: again, one for when the petal is open, and one for when it is
    closed. When the binding `$petal` property is `true`, the `degrees` value on the
    left is used, and when the `$petal` property is `false`, the `degrees` value on
    the right will be used.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `petal` 参数的美元符号语法（`$`）：这是我们如何在另一个结构体中使用 `Binding` 变量的方式。在 `degrees` 参数中，我们有两个值：再次，一个用于花瓣打开时，另一个用于花瓣关闭时。当绑定
    `$petal` 属性为 `true` 时，使用左侧的 `degrees` 值，当 `$petal` 属性为 `false` 时，将使用右侧的 `degrees`
    值。
- en: Again, the middle petal will not be animated, so we only need to call the `Image`
    initializer and then set its size. The remaining petals use the same code; the
    only changes are the values for the `degrees` parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，中间的花瓣不会进行动画处理，所以我们只需要调用 `Image` 初始化器并设置其大小。其余的花瓣使用相同的代码；唯一的变化是 `degrees`
    参数的值。
- en: 'And that completes the petals. Let’s see how they animate by toggling the `petal`
    variable in the `onAppear` method, as we have done with the other variables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了花瓣的设置。让我们通过在 `onAppear` 方法中切换 `petal` 变量来查看它们的动画效果，就像我们处理其他变量一样：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The petals open and close as we have set them up – to a specific point, rotating
    in an arc, and then closing again:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 花瓣按照我们设置的打开和关闭——到一个特定的点，沿着弧线旋转，然后再次关闭：
- en: '![Figure 8.5: The petals animated ](img/B18674_08_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：动画的花瓣](img/B18674_08_05.jpg)'
- en: 'Figure 8.5: The petals animated'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：动画的花瓣
- en: 'There are three components left to add to our project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目中还有三个组件需要添加：
- en: A bouquet of flowers positioned directly over the petals
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接位于花瓣正上方的花束
- en: The moving breath surrounding the flowers
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕着花朵的移动呼吸
- en: Snow falling in the background
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景中下雪
- en: 'In the next section, we will implement the first two points: adding the bouquet
    and the moving breath.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现前两点：添加花束和移动呼吸效果。
- en: Adding the flower bouquet and the animated breath
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加花束和动画呼吸
- en: Adding the first component, the bouquet, is relatively easy, as it is stuff
    we have already done; however, the second component, the moving breath, is a little
    tricky (but not to worry, we will go slow and everything will be explained).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第一个组件，即花束，相对简单，因为我们已经做过类似的事情；然而，第二个组件，即移动呼吸，稍微有点棘手（但不用担心，我们会慢慢来，一切都会解释清楚）。
- en: 'So, first up, the bouquet. In `ContentView`, after the petal group’s closing
    brace, add the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们来添加花束。在 `ContentView` 中，在花瓣组的闭合括号之后，添加以下代码：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This looks like a lot of code, but really, we are creating two bouquets using
    very similar code. The reason why I’m using two bouquets and overlapping them
    is to create the illusion of a full bunch of flowers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像很多代码，但实际上，我们使用非常相似的代码创建了两个花束。我之所以使用两个花束并将它们重叠，是为了创造一束完整花朵的错觉。
- en: Let’s now look at the code. We start with the grouping organizational feature,
    and inside the group, we add the image for both bouquets. I’m setting the aspect
    ratio to `fit`, so the bouquet image keeps its proportional size, and framing
    the image with a value of `300` x `400`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看代码。我们首先使用分组组织功能，并在组内为两个花束添加图片。我将纵横比设置为 `fit`，这样花束图片就能保持其比例大小，并用 `300`
    x `400` 的值来框定图片。
- en: Next, we call the `rotation` modifier on each bouquet, so we can rotate them
    to the proper angle we want in the scene; a `37`-degree rotation for the first
    bouquet looks good, whereas `32` degrees for the second bouquet works better for
    that one. Then, each bouquet gets offset a little bit on the `x` and `y` axes,
    so they’re neatly positioned directly over the breath. This location will help
    hide the breath, as we don’t want to see that until it animates up from the bouquet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对每个花束调用 `rotation` 修改器，这样我们就可以将它们旋转到场景中我们想要的正确角度；第一个花束 `37` 度的旋转看起来不错，而第二个花束的
    `32` 度则更适合。然后，每个花束在 `x` 和 `y` 轴上稍微偏移一点，这样它们就能整齐地位于呼吸的正上方。这个位置将有助于隐藏呼吸，因为我们不希望在动画从花束上升起之前看到它。
- en: 'The next line scales the bouquets up a little. The reason for this is that
    we want to create the effect that the bouquets are breathing as well, along with
    the petals. The top bouquet gets scaled up to `1.04`, and the bottom bouquet gets
    scaled to `1.02`. Notice the top bouquet gets scaled up slightly more than the
    bottom bouquet: this is because we wanted to stagger the two bouquets a little.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将花束稍微放大。这样做的原因是我们想要创建花束和花瓣一起呼吸的效果。顶部花束放大到 `1.04`，底部花束放大到 `1.02`。注意顶部花束放大得比底部花束稍多：这是因为我们想要稍微错开两个花束。
- en: Then, `anchor` is set to `center`, so the two bouquets will expand and contract
    from that point.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`anchor` 被设置为 `center`，这样两个花束就会从这个点开始扩张和收缩。
- en: The next line adds some hue rotation to the color of the bouquets so that they
    will change color along with the animation. We previously used the `hueRotation`
    modifier in [*Chapter 5*](B18674_05.xhtml#_idTextAnchor073), so that’s nothing
    new here, but we are using different values for `hueRotation` to help make the
    bouquets more varied in appearance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行为花束的颜色添加了一些色调旋转，这样它们就会随着动画而改变颜色。我们之前在 [*第五章*](B18674_05.xhtml#_idTextAnchor073)
    中使用过 `hueRotation` 修改器，所以这里没有新内容，但我们使用不同的 `hueRotation` 值来帮助使花束的外观更加多样化。
- en: Also notice that we use the `rotation3DEffect` modifier only on the bottom bouquet.
    This is because the bouquet image for the top and bottom are identical; they are
    simply one image that we’re using in two places, so by using the `rotation3DEffect`
    modifier here and passing in a value of `1` for the `y` parameter, this will flip
    the bouquet image on the *y* axis to the bouquet’s opposite side. This helps give
    the overall look a more symmetrical appearance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们只在底部的花束上使用了`rotation3DEffect`修饰符。这是因为顶部和底部的花束图像是相同的；它们只是我们在两个地方使用的一个图像，所以通过在这里使用`rotation3DEffect`修饰符并传递`y`参数的值为`1`，这将沿着`y`轴翻转花束图像到花束的对面。这有助于使整体外观看起来更加对称。
- en: Finally, we add the animation for both bouquets; this is the same animation
    as we’ve done for the previous views, with a 2-second duration and a 2-second
    delay, so all the animations are in sync.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为两个花束添加动画；这与之前视图所进行的动画相同，持续时间为2秒，延迟时间为2秒，因此所有动画都是同步的。
- en: 'Now, in order to see this animation in action, once again, we need to add the
    animating variable in charge of the bouquet to the `onAppear` modifier. So, add
    the following code to the `onAppear` modifier:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到这个动画的实际效果，我们再次需要将负责花束的动画变量添加到`onAppear`修饰符中。因此，将以下代码添加到`onAppear`修饰符中：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if we run the app, we will see the two bouquets expanding and contracting
    slightly, along with the petals moving too. You will also see the bouquets’ colors
    changing, which is due to the `hueRotation` modifier we used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行应用，我们将看到两个花束轻微地膨胀和收缩，花瓣也在移动。你还会看到花束的颜色变化，这是由于我们使用的`hueRotation`修饰符造成的。
- en: '![Figure 8.6: The bouquet moving ](img/B18674_08_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：花束的移动](img/B18674_08_06.jpg)'
- en: 'Figure 8.6: The bouquet moving'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：花束的移动
- en: The bouquet expanding and contracting is a subtle look (it’s not pronounced
    like the petals opening and closing), which is the look we’re going for here;
    we just want to create a slight expanding effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 花束的膨胀和收缩是一种微妙的外观（它不像花瓣的打开和关闭那样明显），这正是我们在这里追求的外观；我们只想创建一种轻微的膨胀效果。
- en: 'With that done and our app already looking really good, we just need to add
    one more component to the project: snow.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些并使应用看起来已经相当不错之后，我们只需要向项目中添加一个额外的组件：雪。
- en: Creating falling snow in the scene
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在场景中创建下雪效果
- en: 'Making snow fall within your app really makes it come alive: it gives a rather
    magical look to it and sets the right mood for our winter scene. To do this, we
    need to utilize the power of UIKit and the `UIViewRepresentable` protocol, along
    with the `CAEmitter` class.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中添加下雪效果真的能让它栩栩如生：它给应用带来了一种相当神奇的外观，并为我们的冬季场景营造了正确的氛围。为了做到这一点，我们需要利用UIKit的强大功能和`UIViewRepresentable`协议，以及`CAEmitter`类。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you continue through the rest of this chapter, don’t worry if some of the
    UIKit classes and methods look different or unfamiliar to you as compared to the
    SwiftUI classes and methods we’ve been using. That’s because they *are* different,
    and that’s for a whole different book if you’d like to learn about UIKit. However,
    moving forward in this chapter, I will explain the different UIKit properties
    and methods used to make the snow for our animation, so you can get familiar with
    the process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续阅读本章的其余部分，如果你发现一些UIKit类和方法与我们所使用的SwiftUI类和方法看起来不同或陌生，请不要担心。这是因为它们确实不同，如果你想要了解UIKit，那将是另一本书的内容。然而，在本章的后续内容中，我将解释用于制作动画雪花的不同UIKit属性和方法，这样你可以熟悉这个过程。
- en: Adding the UIViewRepresentable protocol
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加UIViewRepresentable协议
- en: The `UIViewRepresentable` protocol is what’s called a **wrapper** for UIKit.
    It allows SwiftUI to work with UIKit and use UIKits classes and methods. If you’ve
    ever coded with UIKit, you’ll know it’s quite different compared to SwiftUI. For
    one thing, it uses something called **Storyboards**, which are a different way
    to design your layout and organize your views by way of dragging and dropping
    objects from an object library, such as buttons and sliders and text, and connecting
    them together on a big storyboard in Xcode. The positioning of all those objects
    is completely different as well and uses a system called **Auto Layout**, which
    is a system of methods and rules to keep your objects spaced apart and located
    on the screen, but it was very complicated and had a big learning curve.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewRepresentable`协议被称为UIKit的**包装器**。它允许SwiftUI与UIKit协同工作，并使用UIKit的类和方法。如果你曾经使用过UIKit进行编码，你会知道它与SwiftUI相当不同。首先，它使用一种称为**Storyboard**的东西，这是一种通过从对象库（如按钮、滑块和文本）拖放对象并连接它们到Xcode中的大Storyboard上来设计布局和组织视图的不同方式。所有这些对象的位置也完全不同，并使用一种称为**Auto
    Layout**的系统，这是一个方法和规则系统，用于保持对象之间的间距并定位在屏幕上，但它非常复杂，学习曲线很大。'
- en: SwiftUI eliminates Storyboards and Auto Layout and is a complete departure from
    UIKit in how you design and build apps. It’s simpler and uses much less code to
    achieve the same results (as you probably already know). But, occasionally, we
    need to access some of the methods and classes that UIKit offers in order to do
    different things in our apps – for example, here, to make snow. That’s why we
    need the `UIViewRepresentable` protocol.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI消除了Storyboard和Auto Layout，并且在设计和应用构建方面与UIKit完全不同。它更简单，并且使用更少的代码就能达到相同的效果（正如你可能已经知道的）。但是，偶尔，我们需要访问UIKit提供的某些方法和类，以便在我们的应用中做不同的事情——例如，在这里，制作雪花。这就是为什么我们需要`UIViewRepresentable`协议的原因。
- en: The `UIViewRepresentable` protocol acts as a bridge between these two different
    frameworks, UIKit and SwiftUI, and lets us access the classes and methods we need.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewRepresentable`协议在UIKit和SwiftUI这两个不同的框架之间充当桥梁，使我们能够访问所需的类和方法。'
- en: 'So, let’s create a new file to contain the snow code. Press *Command* + *N*
    and create a SwiftUIView file called `SnowView`. Then, at the top of the struct,
    we will modify its heading to make it conform to the `UIViewRepresentable` protocol.
    So, change the struct’s heading to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个新的文件来包含雪花代码。按*Command* + *N*创建一个名为`SnowView`的SwiftUIView文件。然后，在结构体的顶部，我们将修改其标题以使其符合`UIViewRepresentable`协议。因此，将结构体的标题更改为以下内容：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we add the `UIViewRepresentable` protocol to the struct’s heading (right
    after the colon), this tells the system that we are now allowed to use the classes
    and methods from the UIKit framework. It also means we have to implement the required
    methods for this protocol. Some protocols only need you to declare them into a
    struct heading, as we have just done, but others also need you to implement some
    methods in order to satisfy the protocol requirements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`UIViewRepresentable`协议添加到结构体的标题（冒号之后）时，这告诉系统我们现在可以允许使用UIKit框架中的类和方法。这也意味着我们必须实现这个协议所需的方法。有些协议只需要你在结构体标题中声明它们，就像我们刚才做的那样，但其他协议还需要你实现一些方法以满足协议的要求。
- en: Dealing with methods and errors
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理方法和错误
- en: '`UIViewRepresentable` requires that we add two methods to the struct: `makeUIView`
    and `updateView`. But because we haven’t added those methods yet, the change we
    just made will break our code and display an error: **SnowView does not conform
    to protocol UIViewRepresentable**. That is true because, as mentioned, we need
    to implement two methods to satisfy this protocol.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewRepresentable`要求我们在结构体中添加两个方法：`makeUIView`和`updateView`。但由于我们还没有添加这些方法，我们刚才所做的更改将破坏我们的代码并显示错误：**SnowView不遵循协议UIViewRepresentable**。这是真的，因为，如前所述，我们需要实现两个方法来满足这个协议。'
- en: 'So, let’s add the first method now, `makeUIView`, by adding the following code
    to the `SnowView` struct:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加第一个方法，`makeUIView`，通过在`SnowView`结构体中添加以下代码来实现：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `makeUIView` method returns `UIView`, which will contain the snow, so we
    can use it in the `ContentView` later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeUIView`方法返回`UIView`，它将包含雪花，因此我们可以在`ContentView`中使用它。'
- en: 'The second method we need to add is called `updateView`, which we can do directly
    under the previous method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的第二个方法被称为`updateView`，我们可以在上一个方法下直接实现它：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method is used when we want to update the view with new data. Since we
    don’t need to do any updating when the snow is made, we can leave this method
    empty. However, it’s a required method so it does have to be here in the `SnowView`
    struct; otherwise, the code won’t work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于我们想要用新数据更新视图时。由于我们不需要在制作雪花时进行任何更新，我们可以留空此方法。然而，它是一个必需的方法，所以它确实必须存在于`SnowView`结构体中；否则，代码将无法工作。
- en: 'Now that we have the two required methods, the protocol should be satisfied.
    However, we still get an error: `makeUIView` method and the fact that it has no
    return code in its body. The `makeUIView` method needs to return `UIView` (or
    simply, a view) in order for the error to go away. So, let’s fill out the `makeUIView`
    method with the code that will return a view, which will, in turn, make our snow.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了两个必需的方法，协议应该得到满足。然而，我们仍然得到一个错误：`makeUIView`方法以及它在体内没有返回代码的事实。为了消除错误，`makeUIView`方法需要返回`UIView`（或者简单地说，一个视图）。所以，让我们在`makeUIView`方法中添加代码，以返回一个视图，这将反过来制作我们的雪花。
- en: 'First, we need to set up the size of the view to fit the screen correctly.
    Remember, we are making a new view using UIKit’s classes and methods, so we have
    to tell it how big the screen dimensions should be for this view. Add the following
    code to the `makeUIView` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置视图的大小以正确适应屏幕。记住，我们正在使用UIKit的类和方法创建一个新的视图，所以我们必须告诉它这个视图的屏幕尺寸应该是多少。将以下代码添加到`makeUIView`方法中：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line of code creates a constant that will hold the bounds of the screen
    – that’s the rectangle of the screen from top to bottom and left to right.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码创建了一个常量，它将保存屏幕的边界——即从上到下和从左到右的屏幕矩形。
- en: The second line of code creates the view that we will need to return when we
    finish writing this method out. We’re setting the view to the size of the screen’s
    width and height so that when we make the snow, we’re using the entire boundaries
    of the iPhone screen, not just a little portion of it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二行创建了一个视图，这是我们完成此方法编写后需要返回的视图。我们将视图设置为屏幕的宽度和高度，这样当我们制作雪花时，我们就会使用iPhone屏幕的整个边界，而不仅仅是其中的一小部分。
- en: The next line of code uses the `masksToBounds` Boolean property and sets it
    to `true`. The `masksToBounds` property indicates to the system whether sublayers
    are clipped to the layer’s bounds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码使用了`masksToBounds`布尔属性并将其设置为`true`。`masksToBounds`属性指示系统是否将子层裁剪到层的边界内。
- en: '`ZStack`, each view you place inside it gets stacked upon the previous view.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZStack`，你放置在其内的每个视图都会堆叠在先前的视图之上。'
- en: So with all this stacking up of views, there may be parts of a view that you
    may not want to show, and other parts of that same view you do want to show. The
    `maskToBounds` property will clip any subviews to the bounds of the screen, which
    is helpful because we only want the snow to fall within the size of the screen;
    we don’t want any snow in any surrounding areas off the screen, only within the
    bounds of the screen, so we set this property to `true` to clip off any excess.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在所有这些视图堆叠起来之后，可能会有一些你不想显示的视图部分，以及你想要显示的同一视图的其他部分。`maskToBounds`属性将裁剪任何子视图到屏幕的边界，这很有帮助，因为我们只想让雪花在屏幕大小内下落；我们不想让任何雪花出现在屏幕外的任何周围区域，只希望在屏幕的边界内，所以我们设置此属性为`true`以裁剪掉任何多余的。
- en: 'Now, we need to return a view in order to silence this error. Remember, the
    `makeUIView` method has a `return` statement in its declaration, so add the following
    code at the end of our previous code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要返回一个视图以消除这个错误。记住，`makeUIView`方法在其声明中有一个`return`语句，所以请在我们之前的代码末尾添加以下代码：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we have our screen size set up, we are returning a view, and we are error-free!
    The next task is to create the snow, which we can do by using UIKit’s `CAEmitter`
    class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了屏幕大小，我们正在返回一个视图，并且没有错误！下一个任务是创建雪花，我们可以通过使用UIKit的`CAEmitter`类来完成。
- en: Adding the CAEmitter class
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加CAEmitter类
- en: '**CAEmitter** (which stands for **Core Animation Emitter**) is a class that
    has methods and properties that let us emit, animate, and render particle systems.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAEmitter**（代表**Core Animation Emitter**）是一个类，它具有让我们发射、动画和渲染粒子系统的方法和属性。'
- en: 'So what’s a particle system? A particle system is just what it sounds like:
    a system that can produce hundreds or thousands of little particles on the iPhone
    screen, in any size that we want, moving at any speed that we set, and in any
    shape that we design.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是粒子系统？粒子系统就是它听起来那样：一个可以在iPhone屏幕上产生数百或数千个小粒子、任何大小、任何速度以及任何形状的系统。
- en: The particle shape that we want has already been designed because we will be
    using the `snowflake` image that we will drop into the assets catalog. However,
    we have to design how many snowflakes to make, how fast to make them move, how
    long to keep them on the screen, and the location on the screen from which they
    are made.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的粒子形状已经设计好了，因为我们将会使用我们将会放入资产目录中的`snowflake`图像。然而，我们必须设计制作多少雪花，它们移动的速度有多快，它们在屏幕上停留的时间有多长，以及它们在屏幕上的起始位置。
- en: 'So, let’s go ahead and create an `emitter` instance, using the `CAEmitter`
    class. Add the following code just underneath the `masksToBounds` line of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续创建一个`emitter`实例，使用`CAEmitter`类。在`masksToBounds`代码行下方添加以下代码：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line creates the `emitter` instance using the `CAEmitter` class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用`CAEmitter`类创建了一个`emitter`实例。
- en: The next line sets the location and size of the emitter. Here, we are locating
    the emitter `200` points along the `x` axis, which is about the middle of the
    iPhone screen, and `-100` points along the `y` axis. This puts the emitter 100
    points up and off from the iPhone screen. We put the emitter above the visible
    portion of the screen because we don’t want to see the snowflakes being created,
    we just want to see them falling.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行设置了发射器的位置和大小。在这里，我们在`x`轴上定位发射器`200`个点，大约是iPhone屏幕的中间位置，以及在`y`轴上`-100`个点。这使得发射器在iPhone屏幕上方100个点处。我们放置发射器在屏幕的可视部分上方，因为我们不想看到雪花被创建的过程，我们只想看到它们下落。
- en: As for the size of the emitter, we’re making it the exact size as the iPhone
    screen, which means using the `frame.width` and `frame.height` values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 至于发射器的大小，我们将其设置为与iPhone屏幕完全相同的大小，这意味着使用`frame.width`和`frame.height`值。
- en: Now that we’ve designed our emitter, let’s design the cell. To explain the difference
    between these two terms, think of the **emitter** as a box that holds thousands
    of confetti particles, and each of those confetti particles is a **cell**. In
    our case, our cell will be a snowflake.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设计好了发射器，让我们来设计细胞。为了解释这两个术语之间的区别，可以把**发射器**想象成一个盒子，里面装着成千上万的纸屑粒子，而每一个这样的纸屑粒子就是一个**细胞**。在我们的例子中，我们的细胞将是一个雪花。
- en: 'To add our cell and make it move on screen, add the following code just under
    the emitter code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的细胞并使其在屏幕上移动，请在发射器代码下方添加以下代码：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we created the `cell` instance using the `CAEmitterCell` class and loaded
    it up with different properties. The following is a list of what these properties
    do:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`CAEmitterCell`类创建了一个`cell`实例，并为其加载了不同的属性。以下是一个列表，说明了这些属性的作用：
- en: '`birthRate`: How fast each cell or particle will be made. Using a value of
    `40` mimics a gentle snowfall.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`birthRate`：每个细胞或粒子被创建的速度有多快。使用`40`的值模仿了轻柔的雪落。'
- en: '`lifetime`: How long to keep the cell on the screen before it’s removed. Using
    a value of `25` ensures that each snowflake stays on the screen long enough to
    make it to the bottom of the screen.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lifetime`：在移除细胞之前，它在屏幕上保持多长时间。使用`25`的值确保每一片雪花在屏幕上停留足够长的时间，以便到达屏幕底部。'
- en: '`velocity`: How fast we want the cell to move on the screen. We’re using a
    value of `60`, which is a speed that’s not too fast or too slow for the snowflake.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`velocity`：我们希望细胞在屏幕上移动多快。我们使用`60`的值，这是一个既不太快也不太慢的速度，适合雪花。'
- en: '`scale`: How big we want to make each cell. A value of `.025` is a nice size
    for the snowflake, as it’s not too big or too small for an iPhone.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`：我们希望每个细胞有多大。对于雪花来说，`.025`是一个很好的大小，因为它既不太大也不太小，适合iPhone。'
- en: '`emissionRange`: How far we want to spread out the cells as they are being
    emitted. For this value, we are using a mathematical expression called Pi (often
    shown as the symbol π), which is defined as the circumference of a circle divided
    by the diameter of the same circle. Without getting too mathematical here, the
    `CGFloat.pi` value equals `180` degrees – imagine a horizontal line drawn from
    the left to the right side of the phone screen; the value sets the snow to fall
    evenly from all areas of that line.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emissionRange`：我们希望细胞在发射时扩散多远。对于这个值，我们使用了一个叫做π的数学表达式（通常用符号π表示），它定义为圆的周长除以同圆的直径。在这里不深入数学的话，`CGFloat.pi`的值等于`180`度——想象一下从手机屏幕的左侧水平画到右侧的水平线；这个值设置了雪花从这条线的所有区域均匀下落。'
- en: '`contents`: Sets the contents of the cell to an image of our choice, which
    was set as the `snow` image (make sure that you’ve added the image into the Assets
    Catalog so it can be accessed with this line of code).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contents`：将单元格的内容设置为我们的选择之一，这里设置为`snow`图像（确保您已经将图像添加到资产目录中，以便可以通过此行代码访问）。'
- en: '`emitterCells`: The cell particles that will become the snow.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emitterCells`：将成为雪的单元格粒子。'
- en: '`addSublayer`: Adds a new layer to the scene. Remember that in SwiftUI, a layer
    is very similar to a view, and everything is a view in SwiftUI (buttons, text,
    colors, and more). In the UIKit world, a layer can also be thought of as a view
    – when the `addSublayer` function is called, it will add whatever layer is in
    its parameter to the scene.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSublayer`：向场景中添加一个新层。记住在SwiftUI中，层非常类似于视图，SwiftUI中的一切都是视图（按钮、文本、颜色等等）。在UIKit世界中，层也可以被视为视图——当调用`addSublayer`函数时，它将参数中的任何层添加到场景中。'
- en: As always, these cell configuration values are completely arbitrary, so go ahead
    and experiment and make the snowflakes as big as you want, design them how you
    want, and make them move on the screen according to what you want them to do.
    There are no hard and fast rules when adding values into a cell; it’s all about
    experimenting and having fun.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，这些单元格配置值完全是任意的，所以您可以继续实验，让雪花变得尽可能大，按照您想要的样式设计它们，并让它们在屏幕上按照您想要的动作移动。在单元格中添加值时没有固定的规则；一切都关于实验和乐趣。
- en: 'And with that, we have completed the snow file. If you want to test the result,
    you can click **Play**; however, as the default background of the preview is white,
    you won’t see our white snow. You can change this by swapping the background color,
    like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经完成了雪文件。如果您想测试结果，可以点击**播放**；然而，由于预览的默认背景是白色，您将看不到我们的白色雪花。您可以通过交换背景颜色来改变这一点，如下所示：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That will change the background color to black so you can see the snow; however,
    as we know, we will be using a winter background for the final animation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以将背景颜色改为黑色，这样您就可以看到雪花；然而，正如我们所知，我们将使用冬季背景作为最终动画。
- en: 'So, to finish things off, we need to call this `SnowView` file inside `ContentView`.
    To do that, head back to `ContentView` and add this final line of code right under
    the background code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了完成整个项目，我们需要在`ContentView`内部调用这个`SnowView`文件。要做到这一点，请回到`ContentView`并在背景代码下方添加这一行代码：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And that completes the project. You can now go ahead and run it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了项目。现在您可以继续运行它：
- en: '![Figure 8.7: The finished project ](img/B18674_08_07.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：完成的项目](img/B18674_08_07.jpg)'
- en: 'Figure 8.7: The finished project'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：完成的项目
- en: The project has a breathing label animation, a breathing petal animation, a
    breathing bouquet animation, and a snow animation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目包含呼吸标签动画、呼吸花瓣动画、呼吸花束动画和雪花动画。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this project, we created the illusion of a bouquet of flowers breathing
    by using a collection of coding modifiers: we used `blur` to create the illusion
    of smoke, and `scale` and `rotationEffect` to make the flowers expand and contract
    in an arc, and we also added labels on the screen. On top of this, we used the
    `UIViewRepresentable` protocol and the `CAEmitter` class, and incorporated particle
    systems to create falling snow.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们通过使用一系列编码修饰符来创造花朵呼吸的错觉：我们使用`blur`来创造烟雾的错觉，使用`scale`和`rotationEffect`使花朵在弧线上膨胀和收缩，我们还添加了屏幕上的标签。在此基础上，我们使用了`UIViewRepresentable`协议和`CAEmitter`类，并整合了粒子系统来创建下落的雪花。
- en: Here are some extra thoughts on how to take this app further, or just practice
    adding some more features, to help stretch your skills with SwiftUI animations.
    How about adding some sound to the project? We did that in [*Chapter 4*](B18674_04.xhtml#_idTextAnchor060)
    with the Record Player project, and it’s very easy to do – you could add some
    guided voice narration that simply says “breathe in, breathe out” or some meditative
    music.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的想法，关于如何进一步开发这个应用，或者只是练习添加更多功能，以帮助您通过SwiftUI动画来扩展您的技能。比如给项目添加一些声音怎么样？我们在[*第4章*](B18674_04.xhtml#_idTextAnchor060)中的留声机项目中就做到了这一点，而且非常简单——您可以添加一些指导性的语音解说，比如“吸气，呼气”，或者一些冥想音乐。
- en: Or how about adding a button or slider that will change the speed of the animation?
    Maybe you want to increase the petal opening and closing speed. If you’re not
    sure how to do that, keep following along in the book because, later, we will
    build a color game with a UI that uses buttons and sliders.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，添加一个按钮或滑块来改变动画的速度怎么样？也许你想增加花瓣的开合速度。如果你不确定如何做到这一点，请继续阅读这本书，因为稍后，我们将构建一个使用按钮和滑块的UI颜色游戏。
- en: Let’s continue to the next chapter, where we will see how to animate a `stroke`
    modifier so it creates a moving line around any shape.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一章，我们将看到如何使一个`stroke`修饰符动画化，使其围绕任何形状创建移动的线条。
