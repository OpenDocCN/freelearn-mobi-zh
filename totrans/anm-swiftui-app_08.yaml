- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating a Bouquet of Flowers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the next project. Here, we will create a bouquet of flowers, animate
    the flower petals so they open and close, and then add a smoke/vapor effect to
    make it look like the flower is breathing by using the `blur` modifier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Behind the flowers, we will place a winter backdrop, and make it snow too by
    using the `CAEmitter` class. The `CAEmitter` class is a UIKit class that was built
    for animation, but to be able to access it, we will need to use a SwiftUI bridging
    protocol called `UIViewRepresentable`. The `UIViewRepresentable` protocol will
    let us bridge the two frameworks, UIKit and SwiftUI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Accompanying this, we will include two labels – **Breathe In** and **Breathe
    Out** – so that you can breathe along with the flowers, similar to a meditation
    app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables and a winter background
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the text labels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `blur` modifier to create a vapor effect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the flower petals in an arc
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the flower bouquet and the animated breath
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating falling snow in the scene
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 8` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables and a winter background
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s get started and create a new SwiftUI project – I have called it `Breathing
    Flower`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Next, go ahead and download the assets for this project. The images are `bouquet`,
    `petal`, `smoke`, `snow`, and `winterNight`. After you download them, drop the
    images into the Assets catalog.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the pictures we need loaded into the project. So, let’s start in
    `ContentView` and add the variables we need to make this flower come alive:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should be familiar with the process of creating animating variables by
    now. Here, we made a variety of variables, including the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`Petal`: To track the petal’s movements'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`breatheInLabel` and `breatheOutLabel`: To track the **Breathe In** and **Breathe**
    **Out** labels'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offsetBreath`: To move the breath from inside the flower to outside the flower'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diffuseBreath`: To track the transformation of the smoke from a still image
    to an animation'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`breatheTheBouquet`: To keep track of the bouquet animation'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we put these variables to use, let’s head into the `body` property and
    add a winter image to the scene. First, create a `ZStack` in order to hold all
    of the views that we will be adding:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is familiar code to us now. Here, we are using the `Image` initializer
    and passing in the background image called `winterNight`, which is in the assets
    catalog. Then, we are resizing the image and using the `aspectRatio` option of
    `fill` to take up the whole screen, before finally giving it some dimensions with
    the `frame` modifier. This is what the scene looks like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The winterNight background ](img/B18674_08_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The winterNight background'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added the background to the scene, our next goal is to add
    some labels: **Breathe In** and **Breathe Out**. What we want to achieve here
    is to make the two labels grow and shrink at the same time as the flower petals
    open and close, so these labels will have the same duration and delay as the flower
    petals in the project, perfectly in sync.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Animating the text labels
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s add two labels that can act as a guide for the user to watch their
    breath. Still working in the `ZStack` and moving directly underneath the previous
    line of code, add another `ZStack`, and fill it with the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s dissect this code a little bit and see what we’re doing. First, we’re
    adding a second `ZStack`, then a group, to help keep the code organized.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `Text` initializer and type in whatever text we’d like to appear
    on the screen. In our case, we are typing in `Breathe In` and `Breathe Out`, and
    just like that, we have text on the screen. Then, using the `font` modifier, you
    can change the font to one of your choosing. Xcode comes with many built-in fonts,
    and I am using one called `papyrus`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to know the names of the fonts that you can use for iOS, you
    can go to the following website: [https://developer.apple.com/fonts/system-fonts/](https://developer.apple.com/fonts/system-fonts/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: As well as choosing the specific font type, we set the font `size` parameter
    to `35`, and use the `foregroundColor` modifier to make the **Breathe In** label
    green and the **Breathe Out** label orange.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Next, the opacity of the text labels is animated here by using the `breatheIn`
    and `breatheOut` variables. When those variables are `true`, their opacity will
    be set to `0`, which makes the label text invisible. But when the `breatheIn`
    and `breatheOut` variables are `false`, the text will be set to `1`, and they
    will become visible again.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: After that, we set the size of the two text labels by using the `scaleEffect`
    modifier. We’re using a ternary operator, which checks whether the `breatheIn`
    and `breatheOut` variables are `true` or not; if so, then we will scale the labels
    down to `0`; otherwise, when the `breatheIn` and `breatheOut` variables are `true`,
    we will scale the text labels back up to full size, which is `35` points.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code positions the label on the screen for the `y` axis, using
    the `offset` modifier. Remember, the *y* axis position views vertically.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we add the `animation` modifier. The animation will start as it usually
    does when the `breatheIn` and `breatheOut` variables become `true`. The animation
    will have a duration of 2 seconds, which means it will take 2 seconds to complete,
    and then it will have a delay of 2 seconds before starting again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'And that completes the animation of the `onAppear` modifier right after the
    closing brace of the first `ZStack`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we’ve seen, `onAppear` will run the code in its body when the view first
    appears – that is, when the user taps on the app to open it. The code we want
    to run is the `breatheIn` and `breatheOut` variables; we want to toggle them to
    their opposite Boolean value to start the animation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this code in the previews or the simulator, you’ll see two labels,
    each with its own color, scaling up and scaling down, and at the same time, fading
    in and out:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: The Breathe In and Breathe Out labels added ](img/B18674_08_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: The Breathe In and Breathe Out labels added'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: That completes the labels. Now, let’s focus our attention on making an image
    that looks like vapor to represent breath.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Using the blur modifier to create a vapor effect
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the project, we will be using the `blur` modifier, which will
    apply a Gaussian blur to an image using a radius value that we specify. If you’re
    not familiar with what a Gaussian blur is, this is a technique that is widely
    used in image editing software (such as Photoshop) and works by reducing the noise
    and detail of an image to create a smooth blurring visual effect.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: We will use an image of smoke, called `breath` (which is in the Assets catalog),
    and apply the `blur` modifier to it, which will create a vapor effect and make
    our flower look like it’s breathing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'There is very little code needed to achieve this effect. Coming out of the
    previous group we made, let’s make a new group and add the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the group, we use the `Image` initializer and pass in the image we want to
    use, `breath`. Then, we give it some dimensions, with a width of `35` and a height
    of `125`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: After that, the code offsets the image vertically on the *y* axis. Then, when
    the `offsetBreath` variable becomes `true`, the image moves `90` points up, so
    it’s coming out of the flower, and when `offsetBreath` is `false`, the image moves
    back down and is set back to `0`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the animation to the image and to the `offset` modifier (yes, we
    can animate an `offset` modifier too!). We are using the same `duration` and `delay`
    values as the text labels (2 seconds, respectively) so that the labels and vapor
    animate in sync.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The next line is the `blur` modifier – this is what creates the magic of turning
    the image into a puff of vapor. This modifier has a parameter called `radius`,
    which accepts any integer number; the smaller the number, the less Gaussian blur
    is applied to the image, whereas the larger the number, the more blurred the image
    becomes. The ternary operator oversees the setting of the `radius` value to either
    `1` or `60`, so depending on whether the `diffuseBreath` variable is `true` or
    `false`, we can control the amount of Gaussian blur on the image. When `diffuseBreath`
    becomes `true`, the image gets blurred by only `1` point, but when `diffuseBreath`
    becomes `false`, the code will add `60` points of Gaussian blur to the image.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the next line of code – this is the `offset` modifier and is responsible
    for positioning the blur. We want to offset the smoke so it moves from inside
    the flower to outside the flower. This is accomplished by checking the `diffuseBreath`
    variable; when it’s `true`, the vapor moves `50` points up, and when it’s `false`,
    the vapor moves `100` points down.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一行代码——这是`offset`修改器，它负责定位模糊。我们希望将烟雾偏移，使其从花内部移动到花外部。这是通过检查`diffuseBreath`变量来实现的；当它是`true`时，蒸汽向上移动`50`点，当它是`false`时，蒸汽向下移动`100`点。
- en: After that, the `animation` modifier will interpolate through all the Gaussian
    blur values, from `1` to `60`. In this interpolation (or looping, if you will),
    these values will act on the image very quickly, so fast that the non-moving still
    image of smoke will be transformed into an actual animation of smoke that will
    move up and disperse, as real smoke does.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`animation`修改器将通过所有高斯模糊值进行插值，从`1`到`60`。在这个插值（或者如果你愿意，循环），这些值会非常快速地作用于图像，以至于非移动的静止烟雾图像将变成一个实际移动并散开的烟雾动画，就像真实的烟雾一样。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may also have noticed that we are using two `animation` modifiers here.
    The reason for this is that the first one is placed right after the `offset` modifier,
    so it is being used to animate the offset of the image up and down; any code we
    add *after* that `animation` modifier will not be animated, hence the use of the
    second `animation` modifier. The second one is used to animate the `blur` modifier
    to make smoke and to animate the offset that moves the smoke. So remember, the
    `animation` modifiers act on the views above them, but if we need to add more
    of them, we can just add them as needed to animate any subsequent views, as we
    have done here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了我们在这里使用了两个`animation`修改器。这样做的原因是第一个修改器紧跟在`offset`修改器之后，因此它被用来动画化图像的上下偏移；任何添加在`animation`修改器之后的代码将不会进行动画化，这就是为什么需要第二个`animation`修改器。第二个修改器用于动画化`blur`修改器以产生烟雾，并动画化移动烟雾的偏移。所以记住，`animation`修改器作用于它们上面的视图，但如果我们需要添加更多的它们，我们只需按需添加以动画化任何后续视图，就像我们在这里所做的那样。
- en: Lastly, we add the `shadow` modifier, which will add a subtle shadow of `20`
    points around the moving breath when it exits the flower.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了`shadow`修改器，它将在移动的呼吸离开花时在其周围添加一个微妙的`20`点阴影。
- en: 'Now, to see the smoke transformation, add the `offsetBreath` and `diffuseBreath`
    variables to the `onAppear` modifier, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到烟雾的转换效果，将`offsetBreath`和`diffuseBreath`变量添加到`onAppear`修改器中，如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is what we can see:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们能看到的内容：
- en: '![Figure 8.3: The smoke in our animation ](img/B18674_08_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：动画中的烟雾](img/B18674_08_03.jpg)'
- en: 'Figure 8.3: The smoke in our animation'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：动画中的烟雾
- en: As the animation starts out, the image of smoke is only being blurred by `1`
    point, but as the `offset` modifier moves the image upward, the blurring increases
    all the way to `60` points. At `60` points, the once still image has now been
    transformed into smoke, mimicking a breath.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画开始时，烟雾的图像仅被`1`点模糊，但随着`offset`修改器将图像向上移动，模糊程度逐渐增加到`60`点。在`60`点时，原本静止的图像已经变成了烟雾，模仿了呼吸的效果。
- en: 'As an aside, something interesting to check out later is that if you want to
    see the process of the smoke image turning into moving vapor at any time, then
    add this line of code beneath the `shadow` modifier:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为补充，稍后值得关注的一个有趣的事情是，如果你想在任何时候看到烟雾图像变成移动蒸汽的过程，那么在`shadow`修改器下面添加这一行代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will move the smoke image to the front of the scene, and you will see it
    being transformed into moving vapor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动烟雾图像到场景的前面，你会看到它被转换成移动的蒸汽。
- en: With the vapor effect added, we can move on to the next step, which is adding
    the bouquet of flowers to the image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了蒸汽效果之后，我们可以继续下一步，即将花束添加到图像中。
- en: Animating flower petals in an arc
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以弧形动画化花瓣
- en: We have a background, text labels, and an inhaling and exhaling breath effect;
    now let’s add the petals to the scene. We can add the petal code in a separate
    file, so press *Command* + *N* to bring up the `PetalView`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个背景，文本标签，以及吸气和呼气的呼吸效果；现在让我们将花瓣添加到场景中。我们可以将花瓣代码放在一个单独的文件中，因此按*Command* +
    *N*来打开`PetalView`。
- en: 'The goal here is to make five petals move in an arc, so they open and close.
    We only need two variables for this, so this will be a very small file: we need
    one Boolean (`Bool`) variable to track the animation, and another variable to
    hold the number of rotations we want for each petal. Let’s add them now:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Binding` variable called `petal` will handle the animation. We are using
    the `Binding` wrapper because we are in a new struct, and we will need to use
    this variable in another struct, `ContentView`. When we prefix a variable with
    the `Binding` wrapper, we can then use it (bind it) to another struct or view.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now move into the `body` property and create a petal. Add the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are only three lines of code to look at:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: First, we add the petal image from the Assets Catalog to the scene and appropriately
    size it.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we use the `rotationEffect` modifier to open and close the petal by choosing
    between two `degree` values: one value for the petal opening and one for its closing.
    We also anchor the rotation point to the bottom of the petal, so the petals will
    open and close in an arc.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we simply call the `animation` modifier to add the animation. Again, we
    continue to keep `duration` and `delay` at `2` seconds and set `autoreverses`
    to `true`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see the petal image in the previews, let’s modify the `previews` struct
    to look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only change in the `PetalView_Previews` struct is that we use the `petal`
    parameter and pass in the value of `.constant(true)`. This turns the `petal` variable
    to `true`, enabling the previews to display the contents of the `PetalsView` struct.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now move back into `ContentView`, and call this new `PetalView` struct
    five times to display all five petals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code calls `PetalView` four times to add four petals to the UI, and then
    the fifth petal (the middle one) is added by a call to the `Image` initializer,
    as this petal will not be animated. The result is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: The petals  ](img/B18674_08_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: The petals'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the dollar sign syntax (`$`) for the `petal` parameter: that is how
    we use the `Binding` variable in another struct. In the `degrees` parameter, we
    have two values: again, one for when the petal is open, and one for when it is
    closed. When the binding `$petal` property is `true`, the `degrees` value on the
    left is used, and when the `$petal` property is `false`, the `degrees` value on
    the right will be used.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Again, the middle petal will not be animated, so we only need to call the `Image`
    initializer and then set its size. The remaining petals use the same code; the
    only changes are the values for the `degrees` parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'And that completes the petals. Let’s see how they animate by toggling the `petal`
    variable in the `onAppear` method, as we have done with the other variables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The petals open and close as we have set them up – to a specific point, rotating
    in an arc, and then closing again:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: The petals animated ](img/B18674_08_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The petals animated'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three components left to add to our project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: A bouquet of flowers positioned directly over the petals
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moving breath surrounding the flowers
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snow falling in the background
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next section, we will implement the first two points: adding the bouquet
    and the moving breath.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Adding the flower bouquet and the animated breath
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding the first component, the bouquet, is relatively easy, as it is stuff
    we have already done; however, the second component, the moving breath, is a little
    tricky (but not to worry, we will go slow and everything will be explained).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first up, the bouquet. In `ContentView`, after the petal group’s closing
    brace, add the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This looks like a lot of code, but really, we are creating two bouquets using
    very similar code. The reason why I’m using two bouquets and overlapping them
    is to create the illusion of a full bunch of flowers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at the code. We start with the grouping organizational feature,
    and inside the group, we add the image for both bouquets. I’m setting the aspect
    ratio to `fit`, so the bouquet image keeps its proportional size, and framing
    the image with a value of `300` x `400`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the `rotation` modifier on each bouquet, so we can rotate them
    to the proper angle we want in the scene; a `37`-degree rotation for the first
    bouquet looks good, whereas `32` degrees for the second bouquet works better for
    that one. Then, each bouquet gets offset a little bit on the `x` and `y` axes,
    so they’re neatly positioned directly over the breath. This location will help
    hide the breath, as we don’t want to see that until it animates up from the bouquet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line scales the bouquets up a little. The reason for this is that
    we want to create the effect that the bouquets are breathing as well, along with
    the petals. The top bouquet gets scaled up to `1.04`, and the bottom bouquet gets
    scaled to `1.02`. Notice the top bouquet gets scaled up slightly more than the
    bottom bouquet: this is because we wanted to stagger the two bouquets a little.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Then, `anchor` is set to `center`, so the two bouquets will expand and contract
    from that point.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The next line adds some hue rotation to the color of the bouquets so that they
    will change color along with the animation. We previously used the `hueRotation`
    modifier in [*Chapter 5*](B18674_05.xhtml#_idTextAnchor073), so that’s nothing
    new here, but we are using different values for `hueRotation` to help make the
    bouquets more varied in appearance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we use the `rotation3DEffect` modifier only on the bottom bouquet.
    This is because the bouquet image for the top and bottom are identical; they are
    simply one image that we’re using in two places, so by using the `rotation3DEffect`
    modifier here and passing in a value of `1` for the `y` parameter, this will flip
    the bouquet image on the *y* axis to the bouquet’s opposite side. This helps give
    the overall look a more symmetrical appearance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the animation for both bouquets; this is the same animation
    as we’ve done for the previous views, with a 2-second duration and a 2-second
    delay, so all the animations are in sync.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to see this animation in action, once again, we need to add the
    animating variable in charge of the bouquet to the `onAppear` modifier. So, add
    the following code to the `onAppear` modifier:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if we run the app, we will see the two bouquets expanding and contracting
    slightly, along with the petals moving too. You will also see the bouquets’ colors
    changing, which is due to the `hueRotation` modifier we used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: The bouquet moving ](img/B18674_08_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The bouquet moving'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The bouquet expanding and contracting is a subtle look (it’s not pronounced
    like the petals opening and closing), which is the look we’re going for here;
    we just want to create a slight expanding effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'With that done and our app already looking really good, we just need to add
    one more component to the project: snow.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Creating falling snow in the scene
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making snow fall within your app really makes it come alive: it gives a rather
    magical look to it and sets the right mood for our winter scene. To do this, we
    need to utilize the power of UIKit and the `UIViewRepresentable` protocol, along
    with the `CAEmitter` class.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: As you continue through the rest of this chapter, don’t worry if some of the
    UIKit classes and methods look different or unfamiliar to you as compared to the
    SwiftUI classes and methods we’ve been using. That’s because they *are* different,
    and that’s for a whole different book if you’d like to learn about UIKit. However,
    moving forward in this chapter, I will explain the different UIKit properties
    and methods used to make the snow for our animation, so you can get familiar with
    the process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Adding the UIViewRepresentable protocol
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIViewRepresentable` protocol is what’s called a **wrapper** for UIKit.
    It allows SwiftUI to work with UIKit and use UIKits classes and methods. If you’ve
    ever coded with UIKit, you’ll know it’s quite different compared to SwiftUI. For
    one thing, it uses something called **Storyboards**, which are a different way
    to design your layout and organize your views by way of dragging and dropping
    objects from an object library, such as buttons and sliders and text, and connecting
    them together on a big storyboard in Xcode. The positioning of all those objects
    is completely different as well and uses a system called **Auto Layout**, which
    is a system of methods and rules to keep your objects spaced apart and located
    on the screen, but it was very complicated and had a big learning curve.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewRepresentable`协议被称为UIKit的**包装器**。它允许SwiftUI与UIKit协同工作，并使用UIKit的类和方法。如果你曾经使用过UIKit进行编码，你会知道它与SwiftUI相当不同。首先，它使用一种称为**Storyboard**的东西，这是一种通过从对象库（如按钮、滑块和文本）拖放对象并连接它们到Xcode中的大Storyboard上来设计布局和组织视图的不同方式。所有这些对象的位置也完全不同，并使用一种称为**Auto
    Layout**的系统，这是一个方法和规则系统，用于保持对象之间的间距并定位在屏幕上，但它非常复杂，学习曲线很大。'
- en: SwiftUI eliminates Storyboards and Auto Layout and is a complete departure from
    UIKit in how you design and build apps. It’s simpler and uses much less code to
    achieve the same results (as you probably already know). But, occasionally, we
    need to access some of the methods and classes that UIKit offers in order to do
    different things in our apps – for example, here, to make snow. That’s why we
    need the `UIViewRepresentable` protocol.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI消除了Storyboard和Auto Layout，并且在设计和应用构建方面与UIKit完全不同。它更简单，并且使用更少的代码就能达到相同的效果（正如你可能已经知道的）。但是，偶尔，我们需要访问UIKit提供的某些方法和类，以便在我们的应用中做不同的事情——例如，在这里，制作雪花。这就是为什么我们需要`UIViewRepresentable`协议的原因。
- en: The `UIViewRepresentable` protocol acts as a bridge between these two different
    frameworks, UIKit and SwiftUI, and lets us access the classes and methods we need.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewRepresentable`协议在UIKit和SwiftUI这两个不同的框架之间充当桥梁，使我们能够访问所需的类和方法。'
- en: 'So, let’s create a new file to contain the snow code. Press *Command* + *N*
    and create a SwiftUIView file called `SnowView`. Then, at the top of the struct,
    we will modify its heading to make it conform to the `UIViewRepresentable` protocol.
    So, change the struct’s heading to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个新的文件来包含雪花代码。按*Command* + *N*创建一个名为`SnowView`的SwiftUIView文件。然后，在结构体的顶部，我们将修改其标题以使其符合`UIViewRepresentable`协议。因此，将结构体的标题更改为以下内容：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we add the `UIViewRepresentable` protocol to the struct’s heading (right
    after the colon), this tells the system that we are now allowed to use the classes
    and methods from the UIKit framework. It also means we have to implement the required
    methods for this protocol. Some protocols only need you to declare them into a
    struct heading, as we have just done, but others also need you to implement some
    methods in order to satisfy the protocol requirements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`UIViewRepresentable`协议添加到结构体的标题（冒号之后）时，这告诉系统我们现在可以允许使用UIKit框架中的类和方法。这也意味着我们必须实现这个协议所需的方法。有些协议只需要你在结构体标题中声明它们，就像我们刚才做的那样，但其他协议还需要你实现一些方法以满足协议的要求。
- en: Dealing with methods and errors
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理方法和错误
- en: '`UIViewRepresentable` requires that we add two methods to the struct: `makeUIView`
    and `updateView`. But because we haven’t added those methods yet, the change we
    just made will break our code and display an error: **SnowView does not conform
    to protocol UIViewRepresentable**. That is true because, as mentioned, we need
    to implement two methods to satisfy this protocol.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewRepresentable`要求我们在结构体中添加两个方法：`makeUIView`和`updateView`。但由于我们还没有添加这些方法，我们刚才所做的更改将破坏我们的代码并显示错误：**SnowView不遵循协议UIViewRepresentable**。这是真的，因为，如前所述，我们需要实现两个方法来满足这个协议。'
- en: 'So, let’s add the first method now, `makeUIView`, by adding the following code
    to the `SnowView` struct:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加第一个方法，`makeUIView`，通过在`SnowView`结构体中添加以下代码来实现：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `makeUIView` method returns `UIView`, which will contain the snow, so we
    can use it in the `ContentView` later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeUIView`方法返回`UIView`，它将包含雪花，因此我们可以在`ContentView`中使用它。'
- en: 'The second method we need to add is called `updateView`, which we can do directly
    under the previous method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的第二个方法被称为`updateView`，我们可以在上一个方法下直接实现它：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method is used when we want to update the view with new data. Since we
    don’t need to do any updating when the snow is made, we can leave this method
    empty. However, it’s a required method so it does have to be here in the `SnowView`
    struct; otherwise, the code won’t work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the two required methods, the protocol should be satisfied.
    However, we still get an error: `makeUIView` method and the fact that it has no
    return code in its body. The `makeUIView` method needs to return `UIView` (or
    simply, a view) in order for the error to go away. So, let’s fill out the `makeUIView`
    method with the code that will return a view, which will, in turn, make our snow.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set up the size of the view to fit the screen correctly.
    Remember, we are making a new view using UIKit’s classes and methods, so we have
    to tell it how big the screen dimensions should be for this view. Add the following
    code to the `makeUIView` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line of code creates a constant that will hold the bounds of the screen
    – that’s the rectangle of the screen from top to bottom and left to right.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code creates the view that we will need to return when we
    finish writing this method out. We’re setting the view to the size of the screen’s
    width and height so that when we make the snow, we’re using the entire boundaries
    of the iPhone screen, not just a little portion of it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code uses the `masksToBounds` Boolean property and sets it
    to `true`. The `masksToBounds` property indicates to the system whether sublayers
    are clipped to the layer’s bounds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`ZStack`, each view you place inside it gets stacked upon the previous view.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: So with all this stacking up of views, there may be parts of a view that you
    may not want to show, and other parts of that same view you do want to show. The
    `maskToBounds` property will clip any subviews to the bounds of the screen, which
    is helpful because we only want the snow to fall within the size of the screen;
    we don’t want any snow in any surrounding areas off the screen, only within the
    bounds of the screen, so we set this property to `true` to clip off any excess.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to return a view in order to silence this error. Remember, the
    `makeUIView` method has a `return` statement in its declaration, so add the following
    code at the end of our previous code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we have our screen size set up, we are returning a view, and we are error-free!
    The next task is to create the snow, which we can do by using UIKit’s `CAEmitter`
    class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CAEmitter class
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CAEmitter** (which stands for **Core Animation Emitter**) is a class that
    has methods and properties that let us emit, animate, and render particle systems.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'So what’s a particle system? A particle system is just what it sounds like:
    a system that can produce hundreds or thousands of little particles on the iPhone
    screen, in any size that we want, moving at any speed that we set, and in any
    shape that we design.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The particle shape that we want has already been designed because we will be
    using the `snowflake` image that we will drop into the assets catalog. However,
    we have to design how many snowflakes to make, how fast to make them move, how
    long to keep them on the screen, and the location on the screen from which they
    are made.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s go ahead and create an `emitter` instance, using the `CAEmitter`
    class. Add the following code just underneath the `masksToBounds` line of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line creates the `emitter` instance using the `CAEmitter` class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The next line sets the location and size of the emitter. Here, we are locating
    the emitter `200` points along the `x` axis, which is about the middle of the
    iPhone screen, and `-100` points along the `y` axis. This puts the emitter 100
    points up and off from the iPhone screen. We put the emitter above the visible
    portion of the screen because we don’t want to see the snowflakes being created,
    we just want to see them falling.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: As for the size of the emitter, we’re making it the exact size as the iPhone
    screen, which means using the `frame.width` and `frame.height` values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve designed our emitter, let’s design the cell. To explain the difference
    between these two terms, think of the **emitter** as a box that holds thousands
    of confetti particles, and each of those confetti particles is a **cell**. In
    our case, our cell will be a snowflake.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our cell and make it move on screen, add the following code just under
    the emitter code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we created the `cell` instance using the `CAEmitterCell` class and loaded
    it up with different properties. The following is a list of what these properties
    do:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`birthRate`: How fast each cell or particle will be made. Using a value of
    `40` mimics a gentle snowfall.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lifetime`: How long to keep the cell on the screen before it’s removed. Using
    a value of `25` ensures that each snowflake stays on the screen long enough to
    make it to the bottom of the screen.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`velocity`: How fast we want the cell to move on the screen. We’re using a
    value of `60`, which is a speed that’s not too fast or too slow for the snowflake.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`: How big we want to make each cell. A value of `.025` is a nice size
    for the snowflake, as it’s not too big or too small for an iPhone.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emissionRange`: How far we want to spread out the cells as they are being
    emitted. For this value, we are using a mathematical expression called Pi (often
    shown as the symbol π), which is defined as the circumference of a circle divided
    by the diameter of the same circle. Without getting too mathematical here, the
    `CGFloat.pi` value equals `180` degrees – imagine a horizontal line drawn from
    the left to the right side of the phone screen; the value sets the snow to fall
    evenly from all areas of that line.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contents`: Sets the contents of the cell to an image of our choice, which
    was set as the `snow` image (make sure that you’ve added the image into the Assets
    Catalog so it can be accessed with this line of code).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contents`：将单元格的内容设置为我们的选择之一，这里设置为`snow`图像（确保您已经将图像添加到资产目录中，以便可以通过此行代码访问）。'
- en: '`emitterCells`: The cell particles that will become the snow.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emitterCells`：将成为雪的单元格粒子。'
- en: '`addSublayer`: Adds a new layer to the scene. Remember that in SwiftUI, a layer
    is very similar to a view, and everything is a view in SwiftUI (buttons, text,
    colors, and more). In the UIKit world, a layer can also be thought of as a view
    – when the `addSublayer` function is called, it will add whatever layer is in
    its parameter to the scene.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSublayer`：向场景中添加一个新层。记住在SwiftUI中，层非常类似于视图，SwiftUI中的一切都是视图（按钮、文本、颜色等等）。在UIKit世界中，层也可以被视为视图——当调用`addSublayer`函数时，它将参数中的任何层添加到场景中。'
- en: As always, these cell configuration values are completely arbitrary, so go ahead
    and experiment and make the snowflakes as big as you want, design them how you
    want, and make them move on the screen according to what you want them to do.
    There are no hard and fast rules when adding values into a cell; it’s all about
    experimenting and having fun.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，这些单元格配置值完全是任意的，所以您可以继续实验，让雪花变得尽可能大，按照您想要的样式设计它们，并让它们在屏幕上按照您想要的动作移动。在单元格中添加值时没有固定的规则；一切都关于实验和乐趣。
- en: 'And with that, we have completed the snow file. If you want to test the result,
    you can click **Play**; however, as the default background of the preview is white,
    you won’t see our white snow. You can change this by swapping the background color,
    like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经完成了雪文件。如果您想测试结果，可以点击**播放**；然而，由于预览的默认背景是白色，您将看不到我们的白色雪花。您可以通过交换背景颜色来改变这一点，如下所示：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That will change the background color to black so you can see the snow; however,
    as we know, we will be using a winter background for the final animation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以将背景颜色改为黑色，这样您就可以看到雪花；然而，正如我们所知，我们将使用冬季背景作为最终动画。
- en: 'So, to finish things off, we need to call this `SnowView` file inside `ContentView`.
    To do that, head back to `ContentView` and add this final line of code right under
    the background code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了完成整个项目，我们需要在`ContentView`内部调用这个`SnowView`文件。要做到这一点，请回到`ContentView`并在背景代码下方添加这一行代码：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And that completes the project. You can now go ahead and run it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了项目。现在您可以继续运行它：
- en: '![Figure 8.7: The finished project ](img/B18674_08_07.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：完成的项目](img/B18674_08_07.jpg)'
- en: 'Figure 8.7: The finished project'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：完成的项目
- en: The project has a breathing label animation, a breathing petal animation, a
    breathing bouquet animation, and a snow animation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目包含呼吸标签动画、呼吸花瓣动画、呼吸花束动画和雪花动画。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this project, we created the illusion of a bouquet of flowers breathing
    by using a collection of coding modifiers: we used `blur` to create the illusion
    of smoke, and `scale` and `rotationEffect` to make the flowers expand and contract
    in an arc, and we also added labels on the screen. On top of this, we used the
    `UIViewRepresentable` protocol and the `CAEmitter` class, and incorporated particle
    systems to create falling snow.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们通过使用一系列编码修饰符来创造花朵呼吸的错觉：我们使用`blur`来创造烟雾的错觉，使用`scale`和`rotationEffect`使花朵在弧线上膨胀和收缩，我们还添加了屏幕上的标签。在此基础上，我们使用了`UIViewRepresentable`协议和`CAEmitter`类，并整合了粒子系统来创建下落的雪花。
- en: Here are some extra thoughts on how to take this app further, or just practice
    adding some more features, to help stretch your skills with SwiftUI animations.
    How about adding some sound to the project? We did that in [*Chapter 4*](B18674_04.xhtml#_idTextAnchor060)
    with the Record Player project, and it’s very easy to do – you could add some
    guided voice narration that simply says “breathe in, breathe out” or some meditative
    music.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的想法，关于如何进一步开发这个应用，或者只是练习添加更多功能，以帮助您通过SwiftUI动画来扩展您的技能。比如给项目添加一些声音怎么样？我们在[*第4章*](B18674_04.xhtml#_idTextAnchor060)中的留声机项目中就做到了这一点，而且非常简单——您可以添加一些指导性的语音解说，比如“吸气，呼气”，或者一些冥想音乐。
- en: Or how about adding a button or slider that will change the speed of the animation?
    Maybe you want to increase the petal opening and closing speed. If you’re not
    sure how to do that, keep following along in the book because, later, we will
    build a color game with a UI that uses buttons and sliders.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，添加一个按钮或滑块来改变动画的速度怎么样？也许你想增加花瓣的开合速度。如果你不确定如何做到这一点，请继续阅读这本书，因为稍后，我们将构建一个使用按钮和滑块的UI颜色游戏。
- en: Let’s continue to the next chapter, where we will see how to animate a `stroke`
    modifier so it creates a moving line around any shape.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一章，我们将看到如何使一个`stroke`修饰符动画化，使其围绕任何形状创建移动的线条。
