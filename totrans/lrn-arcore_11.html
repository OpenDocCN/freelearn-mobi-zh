<html><head></head><body>
        

                            
                    <h1 class="header-title">Performance Tips and Troubleshooting</h1>
                
            
            
                
<p class="mce-root">This will be the end of our journey of exploring <strong>ARCore</strong> and augmented reality. In this chapter, we will look at general performance tips for AR and mobile apps specifically. Then, we will cover a number of troubleshooting solutions to use when and/or if you encounter any problems. We will speak about the possible specific issues you may encounter as well as more general patterns to follow if you encounter problems. Here's a summary of the main topics we will cover in this chapter:</p>
<ul>
<li class="mce-root">Diagnosing performance
<ul>
<li>Chrome DevTools</li>
<li>Android Profiler</li>
<li>Unity editor</li>
</ul>
</li>
<li class="mce-root">Tips for better performance</li>
<li class="mce-root">General troubleshooting</li>
<li class="mce-root">Troubleshooting tips</li>
</ul>
<p>As you likely have already noted many times throughout this book, AR apps require a high level of performance in order to provide a compelling user experience. In the next section, we will look at how we can diagnose performance with each of our platforms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Diagnosing performance</h1>
                
            
            
                
<p>In this section, we will look at the specific steps you will need to take in order to diagnose performance for each of our development platforms (web, Android, and Unity). It is often easy to lose track of performance, especially when working with new or unfamiliar technologies. Therefore, you often want to include some form of performance assessment as part of your development process, perhaps even implementing some minimum frame rate warnings for when your app is rendering at subpar performance or frame rates. Before we get into designing a performance test though, we want to understand how to track performance in each platform, starting with the web using <strong>Chrome DevTools</strong> in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Chrome DevTools</h1>
                
            
            
                
<p>One of the pleasures you will have when developing web projects with ARCore is the ease of debugging with Chrome. In fact, if you were doing a comparison, web project performance tooling would be ranked #2 on our platform list due to the capabilities of Chrome DevTools. Let's open up the <kbd>spawn-at-surface.html</kbd> web example from <a href="3bd45362-4747-4f1c-a313-d6ccf5f6b8fc.xhtml" target="_blank">Chapter 5</a>, <em>Real-World Motion Tracking</em>, and perform the following steps:</p>
<ol>
<li>Start <kbd>http-server</kbd> on port <kbd>9999</kbd> in the <kbd>Android</kbd> folder, just like we did previously.</li>
<li>Pick an <strong>endpoint</strong> that matches your local network and write or copy it for later. Remember that your device and development machine need to be on the same network for this to work.</li>
<li>Launch the WebARCore app on your device and navigate to your selected endpoint. This will often look something like <kbd>http://192.168.*.*:9999</kbd>, where the <kbd>*.*</kbd> will be replaced by your development machine's specific IP.</li>
<li>With WebARCore, navigate to <strong><kbd>http://[YOUR IP]:9999/three.ar.js/examples/spawn-at-surface.html</kbd></strong>.</li>
<li>Connect your device to your dev machine, either remotely or with a USB cable.</li>
<li>Return to your machine and launch Chrome. Open the Developers tools with <em>Ctrl </em>+ <em>Shift </em>+ <em>I</em> (<em>command</em> + <em>option</em> + <em>I</em> on Mac).</li>
<li>Click on the Remote Devices tab and select your device. Then, click on the Inspect button to open another Chrome window with <kbd>WebView</kbd> of the app running on your device.</li>
</ol>
<p> </p>
<ol start="8">
<li>Click on the Performance tab and then select the Record button to start Profiling, as shown in the following screenshot:</li>
</ol>
<div><img src="img/e8451014-ae7d-46f2-af0b-e8dd95e689f2.png"/></div>
<p>Starting performance profiling with DevTools</p>
<ol start="9">
<li>Let the app run in your device with the Profiler running for around 30 seconds and then click on Stop. After you stop capturing the data, a profile session will expand in the Timeline window.</li>
</ol>
<p>If you find that the Profiling session keeps crashing, disable the Screenshots feature by unchecking the box at the top of the window.</p>
<ol start="10">
<li>Click on the Call Tree tab at the top of the Summary window, as follows:</li>
</ol>
<div><img src="img/fefbf502-b106-4207-b3e9-98872567d780.png"/></div>
<p>Profile session timeline</p>
<ol start="11">
<li>The Call Tree tab is where you can quickly identify function calls or sections of code that may be causing performance issues. In our example, we have drilled into the <kbd>update</kbd> function and can see that the bulk of the time spent inside this function is building the projection matrix with a call to <kbd>updateProjectionMatrix</kbd>. Since this call resides within the <kbd>three.ar.js</kbd> library, it is not something we will concern ourselves with.</li>
<li>Feel free to continue testing and profiling. Try setting several Andy models and see what impact this has on performance.</li>
</ol>
<p>With any performance profiling, the thing you will want to quickly identify is spikes or areas where you see data peak. Identifying why these spikes take place will help you understand what activities can impact performance. Placing an Andy, for instance, will cause a spike due to the instantiation of a model into the scene. You will also want to closely watch how the app recovers from a spike. Does the app, for instance, fully recover, or only recover partially?</p>
<p>If you are transferring data or doing <strong>AJAX</strong> calls in your web app, then you will also want to monitor Network performance. The Network tab has a tool interface similar to that of the Performance tab.</p>
<p>After identifying spikes, you will want to expand your view to cover the whole session. Then, you can expand the Call Tree and identify the most time-consuming methods. Chances are that if your app is spending 80% of its time in a single function, then you need to be very careful about what operations take place in that function. Finding and optimizing expensive methods can often get you very quick gains in app performance. While the tools are different, the same principles apply for all our development platforms.</p>
<p>We have just started to scratch the surface for what is possible with the DevTools. If you are doing any amount of web development, you will quickly get up to speed with these tools. In the next section, we will cover the Android profiling tools.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Android Profiler</h1>
                
            
            
                
<p>Android Studio has great performance profiling tools; after all, it provides the closest metal-to-metal interface with your mobile Android device. However, it is not as simple to use as the DevTools and therefore comes a close third in comparison to other profiling tools. We will use one of the sample Android projects we worked with. Open up Android Studio and either of the <kbd>java_arcore_hello_ar</kbd> or <kbd>android (TensorFlow example)</kbd> sample projects, and perform the following steps:</p>
<ol>
<li>Connect your device and build the app to your device. Wait for the app to start running on the device.</li>
</ol>
<p> </p>
<ol start="2">
<li>From the menu, select View | Tool Windows | Android Profiler. This will open a profiling tool window, as shown in the following screenshot:</li>
</ol>
<div><img src="img/fa46e5dc-4bd1-4323-bcf9-438fdbb8b5e2.png"/></div>
<p>Android Profiler capturing a real-time session</p>
<ol start="3">
<li>As the app runs, watch the MEMORY and CPU usage. You can click on any point in the plots in order to expand the view and look at the call stack and various other views of the code execution, as illustrated in the following screenshot:</li>
</ol>
<div><img src="img/8d0747f2-b782-492f-abe7-7280b2b96a52.png"/></div>
<p>Inspecting the real-time profiling session</p>
<ol start="4">
<li>You can also record sessions for later inspection by pressing the Record button at the top of the Profiler window.</li>
</ol>
<p>At this point, you can look for performance spikes or the general overall performance of various function calls using Android Profiler, just like you did with Chrome. The Android tools are more difficult to learn and use, but they're well worth the effort if you are doing any serious Android/Java development. In the next section, we look at our final way to profile performance, with Unity.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity Profiler</h1>
                
            
            
                
<p>Unity is a powerful tool with a very powerful profiler tool that is a pleasure to work with and explore, not just for profiling, but it also provides an insight into the inner workings of Unity. Open up the Unity editor to one of the sample projects we have worked with. For this example, we will use <kbd>HoloCore</kbd> from <a href="6a8f64fb-080f-47a2-9565-4099269831b1.xhtml" target="_blank">Chapter 10</a>, <em>Mixing in Mixed Reality</em>, but feel free to use another app if you prefer. With the editor open, perform the following steps:</p>
<ol>
<li>From the menu, select Window | Profiler. The window will open undocked. Drag the window over by the tab and drop it beside the Game window tab to dock it on the right. Normally, we would dock the Profiler beside the Inspector so that you can watch the profiling while running a game in the editor. Since we can't run ARCore apps in the editor, for now, we will give the Profiler more room by docking it next to the Game window.</li>
</ol>
<ol start="2">
<li>Open the Build Settings dialog and check whether the Development Build and Autoconnect Profiler settings are enabled, as shown in the following screenshot:</li>
</ol>
<div><img src="img/98483f0e-ef93-497c-9c83-2f68d17591d3.png" style="width:37.25em;height:36.00em;"/></div>
<p>Setting Development Build settings</p>
<ol start="3">
<li>Connect your device with a USB, build, and run. Leave the app running on your device.</li>
<li>Return to the editor and open the Active Player dropdown and select AndroidPlayer(ADB@127.0.0.1:someport), as shown here:</li>
</ol>
<div><img src="img/bd08fbe6-b491-496f-ba73-603fa8d5136a.png"/></div>
<p>Unity Profiler capturing session from Android device</p>
<ol start="5">
<li>Click on one of the spikes, as shown in the preceding screenshot. With the CPU panel selected, direct your attention to the bottom Details panel.</li>
<li>Use the dropdown to select Timeline, as follows:</li>
</ol>
<div><img src="img/aa1553c1-4630-42de-9a0e-fb85651a177c.png"/></div>
<p>Inspecting the details of a profiling session</p>
<ol start="7">
<li>There is plethora of useful information here, and it can certainly be overwhelming at first. Fortunately, the Unity interface is self-documenting, and you can quickly get a sense of what is good or bad. We will go over what areas to watch for in more detail later, but for now, pay attention to the Rendering time and Total Allocated Memory. For rendering times, you will usually see a number in ms or milliseconds in time and FPS or frames per second. A good rule is to ensure that your frame rate stays above 30 FPS. A memory can equally be critical when building for mobile apps.</li>
<li>When you are profiling, put the app under stress by changing between reality modes, if you are using <kbd>HoloCore</kbd>, for instance. Then, continue drilling into the various detail panels and watch how values change at various points of the app session.</li>
</ol>
<p>The Unity tools provide the most powerful and intuitive interface for profiling your app. While we barely scraped the power of all the tools we looked at, you will note that they all bear a strong resemblance. Of course, this is not by accident and after you learn the ins and outs of performance profiling an app on one platform, a number of those skills will carry over. In the next section, we will look at a list of tips for better app performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tips for managing better performance</h1>
                
            
            
                
<p>Now that we have a grasp on how to profile our apps, let's take a look at the primary items that will impact performance. The order of these items is ordered by general importance, but the individual requirements of your app may alter these priorities. Feel free to consult the following checklist the next time you need or want to profile your app:</p>
<ul>
<li><strong>Rendering (includes all CPU and memory resources responsible for rendering a frame)</strong>:<strong><br/></strong>
<ul>
<li><strong>Render loop (CPU performance)</strong>: Check the timing of the <kbd>render</kbd> function and watch for any expensive calls. Ensure that you minimize any object instantiation, logging, or inner loops. Remember that the render function, typically called <kbd>Update</kbd>, will be called 30 times per second or more. All the tools we looked at will let you perform this vital task.</li>
<li><strong>Frame rate (render time)</strong>: Outside of optimizing your code, the frame rate will often be dictated by the complexity and number of objects we are rendering. As such, you may want to go as low as optimizing shaders, but many times, you can get great performance gains by reducing the number of triangles or complexity of your models. In a mobile app, this means looking for low poly simple models as assets. Another useful option is to build various <strong>Levels Of Detail</strong> (<strong>LOD</strong>) for your model and use the appropriate version for the appropriate detail level. Unity provides an excellent set of free and paid assets for LOD optimization that can make this task easy.</li>
<li><strong>Lighting</strong> <strong>and materials</strong>: Not only will the complexity of a model impact performance but also the textures or materials (shaders) and lights you are using to render the model. Ensure that you limit the size of textures or ensure that all your shaders have a fallback or simplification. You will also want to simplify lighting where possible.</li>
<li><strong>Memory (graphics)</strong>: As a general rule, the more memory your app is using, the more expensive a frame will be to render. Of course, there are exceptions, but watching the memory can pinpoint potential issues or even memory leaks. A high memory will often point to models, textures, or other assets that may need optimization.</li>
</ul>
</li>
<li><strong>Loading (the process of adding, replacing, or updating new content in the scene)</strong>:
<ul>
<li><strong>Object instantiation</strong>: Large complex meshes with multiple detailed textures will require extra load times. You will often want to cache or preload objects in order to reduce interruptions during loading. For most of our examples, this wasn't an issue, but a good example of where this was a problem was in <a href="6a8f64fb-080f-47a2-9565-4099269831b1.xhtml" target="_blank">Chapter 10</a>, <em>Mixing in Mixed Reality</em>, where we used the 3D map.</li>
<li><strong>Streaming</strong>:<strong> </strong>Streaming is a great way to load media resources such as audio or video to play just the content you need. In Unity, setting a resource to stream instead of loading completely is fairly easy and can be done at the resource definition, as shown in the following screenshot:</li>
</ul>
</li>
</ul>
<div><img src="img/cced39d4-097f-4a5a-bdce-d91f7f0324e8.png" style="width:31.50em;height:25.00em;"/></div>
<p>Enabling streaming on an audio resource</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Garbage collection</strong>: All of our platforms manage object lifetime through some form of garbage collection while the app is running. Keeping the number of objects you create and destroy to a minimum will alleviate pressure on the GC. If the GC fills up quickly, this will often trigger an expensive collection operation, which may freeze your app. You can reduce object instantiation and collection by creating object pooling. Object pooling is where you keep a stock of objects in memory, adding and removing objects from the scene as you need.</li>
</ul>
</li>
<li><strong>Interaction (includes any activity by the user or the environment, be it physical or artificial)</strong>:
<ul>
<li><strong>Environment detection</strong>: This is a requirement more specific to AR apps and crucial to ARCore. If you are planning to augment detection of point clouds or planes, ensure that you optimize this code as much as possible.</li>
<li><strong>Object interaction (physics)</strong>: Limit the number of objects that you need to test for ray casting or collisions. You can do this by tagging your objects and then filter the tags. In Unity, this feature is built in, but it is fairly easy to implement for other platforms.</li>
<li><strong>AI (machine learning)</strong>: If your app needs to do any AI for an <strong>non-player character</strong> (<strong>NPC</strong>) or other agent, then you may want to limit any expensive calls for AI or learning. Instead of running your AI for every frame, you may want to limit it to every fifth or tenth frame, for instance. Often, this has the added benefit of making the AI more realistic or smarter, since it appears to think for a short period before action.</li>
</ul>
</li>
</ul>
<p>The preceding list is a good place to start when looking for possible performance problems, and it should suit you well as a guide for any platform you need to profile. In the next section, we will cover some general troubleshooting tips that you can use for each platform when developing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">General troubleshooting</h1>
                
            
            
                
<p>We learned the basics of the debugging process for each platform, but we never covered any techniques for debugging or troubleshooting. Just like profiling, there is a basic guide or list that you can follow to make you more efficient when troubleshooting. Use the following list of steps to help you troubleshoot your next issue:</p>
<ol>
<li><strong>Console</strong>: The first place to look is for any errors that are being reported to the console. All our platforms provide a console, and you should be familiar with accessing it on your platform of choice. Does the error make sense? Are you able to pinpoint the section of code or item causing the issue?</li>
<li><strong>Google</strong>: If you see an obscure console message and are not quite sure what it does, then Google it. You don't want to Google the entire message, but just extract five or six key words in the phrase and use those. You may also want to add words to cover your platform; for instance, Java, Android, or, Unity C#.</li>
<li><strong>Logging</strong>: Instrument your code by injecting logging statements in key areas of your code. If your code is not reporting errors to the console, put in logging to let you know where the code flows. This can help you determine if and when key sections of code are being run.</li>
<li><strong>Replicate</strong>: Isolate the problem and try to replicate it in a new project or test app. If you are unable to isolate the code, you have a bigger issue, and you should probably refactor. Generally, unless the issue requires a workaround or is something more serious, replicating the project can solidify your understanding of the issues. Replicating an issue cannot only help you solve the problem, but it can also help you refactor and clean your code.</li>
<li><strong>Post it</strong>: If you still don't have a resolution after replicating the problem then look for the appropriate forum and post your issue. Ensure that you provide your replicated sample when you post your issue. It will often be the first thing someone will likely ask you for, especially if the problem is complex. Also, showing that you spent time replicating the problem will make your post more credible and avoid the wasted time of responding to simple questions.</li>
<li><strong>Work around it</strong>: If you can't resolve your issue, then work around it. Sometimes, resolving your issue is not possible or just too expensive and time consuming. Then, you will need to come up with another way to either build the feature or alter it. This will often require going back to the designer or visionary, if your project has one, and consulting them for some possible workarounds.</li>
</ol>
<p>The preceding list is again a good place to start when you encounter an issue. If you have been developing software for some time, you will likely have your own process, but the preceding list is probably not much different from yours.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Troubleshooting code</h1>
                
            
            
                
<p>For those of you with less experience in troubleshooting code, follow this simple exercise:</p>
<ol>
<li>Open the Unity editor to a new blank project and starting scene.</li>
<li>Create a Cube object in the scene.</li>
<li>Select the Cube and in the Inspector window, click on Add Component. Select New Script and the set the name to <kbd>Test</kbd> and then click on Create and Add<strong> </strong>to add the script to the object, as follows:</li>
</ol>
<div><img src="img/5a5550b7-8989-4ee9-ab8e-bbcce08ef624.png"/></div>
<p>Creating a new script with Add Component</p>
<ol start="4">
<li>This will create a script in the root <kbd>Assets</kbd> folder. It's not the best place to drop a script, but this method is useful for creating quick test scripts.</li>
</ol>
<p>Try to avoid writing replication/test or proof of concept code in your main development project. Keep your main project as clean as possible. If you are building anything commercial, you will most certainly want to go through the extra effort of validating every asset or resource in your project or at least the ones you are responsible for. It is a useful team exercise to go through your references and assets on a regular basis, perhaps once a month or more frequently if you are making multiple changes.</p>
<ol start="5">
<li>Open the <kbd>Test</kbd> script in an editor of your choice and add the following highlighted lines of code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>public class Test : MonoBehaviour {<br/>  <strong>public GameObject monster; </strong> //add me<br/>  // Use this for initialization<br/>  void Start () {<br/> <br/>  }<br/> <br/>  // Update is called once per frame<br/>  void Update () {<br/>    <strong>if(monster.transform.position.x &gt; 5) </strong> //and add this section<br/><strong>    {</strong><br/><strong>      Destroy(this);</strong><br/><strong>    }</strong><br/>  }<br/>}</pre>
<ol start="6">
<li>This script simply tracks a <kbd>GameObject</kbd> called <kbd>monster</kbd> and determines when its <kbd>x</kbd> position exceeds <kbd>5</kbd>. When it does, the script destroys its parent object with <kbd>Destroy(this)</kbd>.</li>
<li>Save the file and return to Unity.</li>
<li>Add another Cube to the scene and rename it to <kbd>Monster</kbd>.</li>
<li>Press the Play button at the top of the editor to start the scene.</li>
<li>Click on the Console window to bring it to the top. Watch the stream of errors, as illustrated in the following screenshot:</li>
</ol>
<div><img src="img/bcaded55-5c24-4d27-b033-c7cab761f00f.png"/></div>
<p>Console window showing a stream of errors</p>
<ol start="11">
<li>So, the general error message we are seeing is UnassignedReferenceException. Quickly Google that text to see what comes back in the results. Did that give you any more insights other than the message on the Console?</li>
</ol>
<p>Chances are that you may have already solved the issue, but let's continue as if we are still stumped. Say, for instance, the Google result was far less helpful. Follow along to continue our troubleshooting (debugging) process:</p>
<ol>
<li>Our next step is logging. Add the following line of code just inside the <kbd>Update</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">Debug.LogFormat("Monster is at position ({0})", monster.transform.position);</pre>
<ol start="2">
<li>This line of code outputs a debug message to the Console.</li>
<li>Of course, running the code again will replicate the same issue, which also means that you just replicated the problem, and cover the next step in a single line of code.</li>
</ol>
<p>While logging is good, it can also be bad, for performance and anyone trying to hack your game. You can usually control the level of logging you want to output for each environment. As a general rule though, try to avoid excessive logging unless the information is required or useful.</p>
<p>At this point in our example, it should be self-explanatory as to what the issue is, but of course, this isn't always the case. When that happens, if you have exhausted all other paths, then post the problem to an appropriate forum. If nothing comes back in time, then you may need to move on and work around the problem. Strangely enough, it is often not unusual to be halfway through writing a workaround to realize your mistake. It happens, and the best advice is to just move on. Failure is a great way to learn and the more you fail, the more you learn.</p>
<p class="mce-root">In Canada, you are taught how to winter drive in the ice and snow by going out to a parking lot and spinning around and losing control. While this can certainly be lot of fun, it teaches the driver how to lose control under controlled poor weather conditions. This not only gives the driver more confidence, it also reinforces how to control a vehicle when it loses traction under high speeds. Then, when the driver does lose control, they can attempt to avoid or minimize damage. Unit testing your code is not like learning how to winter drive. It tests the limits of your code so that you can be sure what will happen if something works or fails.</p>
<p>Most developers struggle with the concept of adding unit test code to their game or graphics projects. In fact, the practice is discouraged by the lack of tools or knowledge available. Unit testing or rigorously testing your code is never a waste of time, and using a testing framework for your platform will go a long way to make this an easier task. Now whether you decide to write unit tests for your code or not is up to you, but you should learn how to unit test. The practice of just learning how to test your code will open your eyes to a world of possibilities.</p>
<p>The more you code and develop games or other applications, the better you will get at troubleshooting errors. There is no substitute for practical experience. In the next section, we will look at more specific troubleshooting items that you may have encountered during the course of the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<p>Complete the following exercises on your own:</p>
<ol>
<li>Alter the <kbd>if</kbd> statement that checks the monster's position so that the code avoids the error entirely.</li>
<li>Are you able to fix the unassigned reference issue in code? Hint—check out the <kbd>GameObject.Find</kbd> method.</li>
<li>Write a monster script that moves its block using the keyboard or mouse as input.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Troubleshooting tips</h1>
                
            
            
                
<p>There is a lot that can go wrong when working with any new technology, not only because of your lack of familiarity, but it may also happen that the technology may not be prepared to do all the things it claims it can do. Here's a table of common issues you may encounter while working through the book:</p>
<table>
<tbody>
<tr>
<td><strong>Platform</strong></td>
<td><strong>Issue</strong></td>
<td><strong>Resolution</strong></td>
</tr>
<tr>
<td>Web</td>
<td>Unable to load page or find server</td>
<td>Check whether you are using the correct endpoint for your machine. If you have a few choices, try a different option. Confirm that your system does not have a firewall running that could be blocking the communication. Try disabling your firewall (temporarily) and try again. If this resolves the issue, then make an exception in your firewall for port <kbd>9999</kbd> or whatever port you used.</td>
</tr>
<tr>
<td>Web</td>
<td>ARCore displays an error message on the page</td>
<td>Ensure that the ARCore service is installed and you are using the WebARCore enabled browser for your platform.</td>
</tr>
<tr>
<td>Web</td>
<td>Missing references</td>
<td>Ensure that you check that the path you are using to load content or scripts is correct. You can do this easily in Chrome by checking the Sources tab.</td>
</tr>
<tr>
<td>Android</td>
<td>Unable to build or missing references</td>
<td>Android Studio is very helpful, but it sometimes needs to load a lot of references. In this case, you just need to be patient and load everything the project requires. If you are building your project from scratch, you will need to refer to a good tutorial on Android project setup to do it right. If you find that you are still missing references, then create a new project and try again.</td>
</tr>
<tr>
<td>Android/Unity</td>
<td>Unable to connect to device</td>
<td>This rarely happens anymore, but it can happen on occasion. Unplug and plug your device back in or run <kbd>adb devices</kbd> at a console or shell window. If you are connecting remotely, you may have to reconfigure the device by reconnecting the USB and resetting the connection.</td>
</tr>
<tr>
<td>Unity</td>
<td>All compiler errors have to be fixed before you enter the play mode</td>
<td>Check the console for any red error messages. Double-click on any messages to be taken to the syntax error in the code. Do your best to resolve or remove the syntax error.</td>
</tr>
<tr>
<td>Unity</td>
<td>Unable to build</td>
<td>Check for any compiler errors and ensure that your scenes are added to the build with the Build Settings dialog.</td>
</tr>
<tr>
<td>Unity</td>
<td>Build stalls</td>
<td>
<p class="mce-root">If you are connected to a device and the cable disconnects momentarily, this can cause the build to lock or just stop. Usually, just clicking on Cancel will exit the build process, and you can just start again. On occasion, very rarely, you may need to restart Unity.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">The preceding table should help you resolve more of the common show stopper issues you may encounter while traversing the book. If you encounter something outside this list, certainly consult Google or your other favorite search engine. You will often find that just rebuilding the project will teach you where you went wrong.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This is the last chapter of our book, and we spent our time well, learning about performance and troubleshooting. We first covered the use of the various performance profiling tools you may use for each of our platforms. Then, we covered a set of very basic tips for increasing your app's performance, which covered everything from frame rate to asset size. This led us to cover tips for troubleshooting basic problems and, more specifically, coding issues. We finished off with a table of helpful troubleshooting tips that you can use to consult if you encounter more specific troublesome problems.</p>
<p>Now that you have completed this book, you have just started your journey into discovering AR and MR. There are plenty of more good books from Packt on AR, web development, Android development, and, of course, Unity. Readers are also encouraged to seek out your local meetups on AR/VR or if there is none, create their own. Seeing what others are doing for AR or even VR development can encourage new ideas and best practices. We all, really are, just beginning an exciting journey into a new computing interface that will radically change our lives in the years to come. With the ongoing development of wearable mainstream commercial glasses coming around the corner, you should also be poised for many more changes to come in AR.</p>


            

            
        
    </body></html>