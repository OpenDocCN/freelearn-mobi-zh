- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: GUI Alerts – What’s New in Menus, Dialog, Toast, Snackbars, and More in Modern
    Android Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI警告 - 在现代安卓开发中菜单、对话框、Toast、Snackbar等的新特性
- en: '**Graphic User Interface** (**GUI**) alerts are essential to users because
    they provide critical information about a program or application’s status and
    can help users avoid errors and make informed decisions. Alerts can be triggered
    in various situations, such as when an error occurs, a program performs a critical
    operation, or when a user is about to perform an irreversible action.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**（**GUI**）警告对用户至关重要，因为它们提供了关于程序或应用程序状态的临界信息，并帮助用户避免错误和做出明智的决定。警告可以在各种情况下触发，例如当发生错误、程序执行关键操作或当用户即将执行不可逆操作时。'
- en: One of the main benefits of GUI alerts is that they provide immediate feedback
    to users. For example, if a user enters incorrect information into a form, an
    alert can quickly inform them of the error, allowing them to correct it before
    proceeding. This can help to prevent mistakes and save time in the long run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: GUI警告的主要好处之一是它们为用户提供即时反馈。例如，如果用户在表单中输入了错误信息，警告可以迅速通知他们错误，允许他们在继续之前进行纠正。这有助于防止错误并在长期内节省时间。
- en: Another benefit of GUI alerts is that they can help to prevent accidental actions.
    For example, if a user is about to delete an important file, an alert can warn
    them of the potential consequences of this action, giving them a chance to reconsider
    before proceeding. This chapter will examine how a GUI is implemented in Modern
    Android Development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面（GUI）警告的另一个好处是它们可以帮助防止意外操作。例如，如果用户即将删除一个重要的文件，警告可以提醒他们这一行为的潜在后果，在继续之前给他们一个重新考虑的机会。本章将探讨在现代安卓开发中如何实现GUI。
- en: 'In this chapter, we’ll cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating and displaying a menu in Modern Android Development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代安卓开发中创建和显示菜单
- en: Implementing Toast/Snackbars to alert users
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Toast/Snackbars来提醒用户
- en: Creating an alert dialog
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个警告对话框
- en: Creating a `BottomSheet` dialog
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`BottomSheet`对话框
- en: Creating a radio button
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单选按钮
- en: Creating **Floating Action Buttons** (**FABs**) and extended FABs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**浮动操作按钮**（**FABs**）和扩展FABs
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven)找到。
- en: Creating and displaying a menu in Modern Android Development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现代安卓开发中创建和显示菜单
- en: 'Creating a menu in an Android app can provide several benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓应用中创建菜单可以提供以下好处：
- en: Menus can help users quickly access different features and functionalities within
    an app. A well-designed menu can improve the user experience by making it easy
    to navigate and use the app.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单可以帮助用户快速访问应用内的不同功能和特性。一个设计良好的菜单可以通过简化导航和使用应用来提升用户体验。
- en: A consistent menu across different screens in an app can help users quickly
    find what they’re looking for, making the app feel more polished and professional.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用的不同屏幕上保持一致的菜单可以帮助用户快速找到他们想要的内容，使应用看起来更加精致和专业。
- en: A menu can be used to group related options and functions in one place, reducing
    the need for cluttered screens with many buttons and options.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单可以用来将相关的选项和功能分组在一个地方，减少需要许多按钮和选项的杂乱屏幕。
- en: Menus can also be customized to fit an app’s specific needs, including different
    types of menus, such as context menus, pop-up menus, and navigation drawers.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单也可以根据应用的具体需求进行定制，包括不同类型的菜单，如上下文菜单、弹出菜单和导航抽屉。
- en: Menus should be designed with accessibility in mind, making it easier for users
    with disabilities to navigate the app.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单的设计应考虑可访问性，使有障碍的用户更容易导航应用。
- en: That is to say, creating a menu in an Android app can improve the user experience,
    provide consistency, save space, and increase accessibility.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在安卓应用中创建菜单可以提升用户体验，提供一致性，节省空间，并提高可访问性。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this chapter, we will create a new Material 3 project and call it `GUIAlerts`;
    this is where we will add all our UI components for this chapter, and you can
    take advantage of the project to modify the views to suit your needs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将创建一个新的Material 3项目，命名为`GUIAlerts`；这是我们将在其中添加本章所有UI组件的地方，你也可以利用这个项目来修改视图以满足你的需求。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Follow the following steps to build your first hamburger menu:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建你的第一个汉堡菜单：
- en: Inside our newly created project, `GUIAlerts`, let’s create a package component,
    and inside the package, create a Kotlin file and call it `MenuComponent.kt`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们新创建的项目`GUIAlerts`中，让我们创建一个包组件，并在包内创建一个名为`MenuComponent.kt`的Kotlin文件。
- en: 'Let’s create a composable function, `OurMenu`, in our Kotlin file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在Kotlin文件中创建一个可组合函数`OurMenu`：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s go ahead and create our menu. For our purposes, we will just showcase
    some items, and when someone clicks, nothing will happen since we will not implement
    the `onClick` function. First, we need to ensure it does not start as `expanded`,
    which means users will click to expand the menu and it will change to `true` in
    response:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建我们的菜单。为了我们的目的，我们只展示一些项目，当有人点击时，不会发生任何事情，因为我们不会实现`onClick`函数。首先，我们需要确保它不是以`expanded`开始的，这意味着用户需要点击来展开菜单，并且它将响应地变为`true`：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For our menu items, we will just showcase four items.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的菜单项，我们将只展示四个项目。
- en: 'Next, we must create a `Box()`, align it to the center, and react to the `expanded`
    state in the modifier. We will also need to add an icon, `ArrowDropDown`, to inform
    users they can click and that we have more items:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个`Box()`，将其对齐到中心，并响应修改器中的`expanded`状态。我们还需要添加一个图标`ArrowDropDown`，以通知用户他们可以点击，并且我们还有更多项目：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, we will need to add `DropDownMenu`, which will expand when we click
    the icon, and we will set `onDismissRequest` to `false`; it is called when the
    user requests to dismiss the menu, for instance, when tapping.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加`DropDownMenu`，当点击图标时它会展开，我们将`onDismissRequest`设置为`false`；当用户请求关闭菜单时调用，例如，当轻触时。
- en: 'Then, we will display our items on the `DropdownMenuItem` function so that
    when it is clicked, it performs an action. For our example, we don’t do anything:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将显示我们的项目在`DropdownMenuItem`函数上，以便当它被点击时执行操作。在我们的示例中，我们不做任何事情：
- en: '[PRE20]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, when you run the app, you should see a menu dropdown with items you
    can click.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当你运行应用程序时，你应该看到一个带有可点击项目的菜单下拉菜单。
- en: '![Figure 11.1 – The drop-down menu](img/Figure_11.1_B18827.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 下拉菜单](img/Figure_11.1_B18827.jpg)'
- en: Figure 11.1 – The drop-down menu
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 下拉菜单
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can customize the drop-down menu to fit your needs and style.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要和风格自定义下拉菜单。
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In our example, we first declare a mutable state variable, `expanded`, to keep
    track of whether the menu is expanded or not and another mutable state variable,
    `selectedMenuItem`, to keep track of the currently selected menu item.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们首先声明一个可变状态变量`expanded`，用于跟踪菜单是否展开，以及另一个可变状态变量`selectedMenuItem`，用于跟踪当前选定的菜单项。
- en: We also define a list of `menuItems` which helps us know the menu list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`menuItems`列表，这有助于我们知道菜单列表。
- en: Inside our `Box`, we define a `Column(){}`, which contains the menu title, a
    clickable `Box`, which displays the selected menu item, and a `DropdownMenu`,
    which displays the menu items when expanded. We use the `Box` and `DropdownMenu`
    components to position the menu items relative to the clickable `Box`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Box`中，我们定义了一个`Column()`，它包含菜单标题、一个可点击的`Box`，用于显示选定的菜单项，以及一个`DropdownMenu`，当展开时显示菜单项。我们使用`Box`和`DropdownMenu`组件来定位菜单项相对于可点击的`Box`的位置。
- en: '`DropDownMenu` takes in a couple of inputs, as you can see in *Figure 11**.2*,
    and this helps you customize your drop-down menu based on your needs.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`DropDownMenu`接受一些输入，正如你在*图11.2*中看到的，这有助于你根据需要自定义下拉菜单。'
- en: "![Figure 11.2 – The DropDownMenuItem input param\uFEFFeters](img/Figure_11.2_B18827.jpg)"
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – DropDownMenuItem输入参数](img/Figure_11.2_B18827.jpg)'
- en: Figure 11.2 – The DropDownMenuItem input parameters
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – DropDownMenuItem输入参数
- en: Finally, we use the `DropdownMenuItem` component to display each menu item and
    update the `selectedMenuItem` and `expanded` variables when a menu item is clicked.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`DropdownMenuItem`组件来显示每个菜单项，并在点击菜单项时更新`selectedMenuItem`和`expanded`变量。
- en: Implementing a Toast/Snackbar to alert users
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Toast/Snackbar来提醒用户
- en: In Android development, a Toast/Snackbar is a small pop-up message that appears
    on the screen, usually at the bottom. It’s used to provide brief information or
    feedback to the user. It is a simple way to display short messages to the user
    without interrupting the user’s workflow.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，Toast/Snackbar是一种小型的弹出消息，通常出现在屏幕底部。它用于向用户提供简短的信息或反馈。这是一种在不打断用户工作流程的情况下向用户显示短消息的简单方式。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this section, we will react to the items we created in our `DropMenuItem`,
    so you must have followed the previous recipe to continue with this one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对我们在`DropMenuItem`中创建的项目做出反应，因此你必须遵循之前的食谱才能继续本食谱。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Execute the following steps to add a message when the items are clicked to
    tell the users they’ve picked a particular item:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在点击项目时添加消息，告诉用户他们已选择特定项目：
- en: Creating a Toast is very straightforward in Android; you can simply do that
    using the `Toast` class the Android SDK provides. You can create a new `Toast`
    object by calling the static `makeText()` method of the `Toast` class and passing
    it the context, message, and duration of the Toast.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android中创建Toast非常简单；你可以简单地使用Android SDK提供的`Toast`类来完成。你可以通过调用`Toast`类的静态`makeText()`方法来创建一个新的`Toast`对象，并传递上下文、消息和Toast的持续时间。
- en: 'Once you have created the `Toast` object, you can call the `show()` method
    to display it on the screen:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了`Toast`对象，你可以调用`show()`方法来在屏幕上显示它：
- en: '[PRE29]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In Jetpack Compose, however, to display a `Toast`, we will need to use `coroutineScope`,
    but note you do not need a coroutine to display a Toast in all instances, in our
    example however, we will use the `launch` function to launch a coroutine that
    displays the Toast message:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在Jetpack Compose中，要显示Toast，我们需要使用`coroutineScope`，但请注意，在所有情况下显示Toast并不一定需要协程，在我们的示例中，我们将使用`launch`函数来启动一个显示Toast消息的协程：
- en: '[PRE30]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To hook up `onClick()`, please see the code in the *Technical requirements*
    section to get the entire code. Finally, when you run the app, you should see
    a `Toast` message with the item selected as the message.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接`onClick()`，请参阅*技术要求*部分的代码以获取完整代码。最后，当你运行应用程序时，你应该看到一条包含所选项目作为消息的Toast消息。
- en: '![Figure 11.3 – The Toast message displayed](img/Figure_11.3_B18827.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 显示的Toast消息](img/Figure_11.3_B18827.jpg)'
- en: Figure 11.3 – The Toast message displayed
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 显示的Toast消息
- en: 'In the following example, we will use a Snackbar now instead of a Toast:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用Snackbar而不是Toast：
- en: '[PRE38]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are different ways of using a Snackbar in Jetpack Compose; you can use
    it with a `Scaffold` or without it. However, it is recommended to use a Snackbar
    with a `Scaffold`. In our example, we will use a `Scaffold`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中，使用Snackbar的方式有多种；你可以用它与`Scaffold`一起使用，也可以不使用它。然而，建议使用带有`Scaffold`的Snackbar。在我们的示例中，我们将使用`Scaffold`：
- en: '[PRE45]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, when you run the app, you will see a Snackbar with the selected item
    text and item selected. Both `Toast` and `Snackbar` serve the same purpose.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当你运行应用程序时，你将看到一条包含所选项目文本和所选项目的Snackbar。`Toast`和`Snackbar`都服务于相同的目的。
- en: '![Figure 11.4 – The Snackbar message displayed](img/Figure_11.4_B18827.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 显示的Snackbar消息](img/Figure_11.4_B18827.jpg)'
- en: Figure 11.4 – The Snackbar message displayed
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 显示的Snackbar消息
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Toasts and Snackbars are two types of notification messages that can be used
    in Android applications to display short messages to the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Toasts和Snackbars是两种可以在Android应用程序中使用的通知消息类型，用于向用户显示短消息。
- en: 'The main differences between Toasts and Snackbars are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Toast和Snackbar之间的主要区别如下：
- en: Toast messages are typically displayed in the center of the screen, while Snackbar
    messages are usually displayed at the bottom of the screen.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Toast消息通常在屏幕中央显示，而Snackbar消息通常在屏幕底部显示。
- en: Toast messages typically last for a short period of time, usually around 2-3
    seconds, and then disappear automatically. Snackbar messages are usually displayed
    for a more extended period of time and can be dismissed by the user by swiping
    them away or by tapping on a button.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Toast消息通常持续很短的时间，通常约为2-3秒，然后自动消失。Snackbar消息通常显示更长时间，并且可以通过用户滑动或点击按钮来关闭。
- en: Toast messages are not interactive and cannot be dismissed by the user. Snackbar
    messages, on the other hand, can contain action buttons that allow the user to
    take specific actions in response to the message.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Toast消息是非交互式的，用户无法将其取消。另一方面，Snackbar消息可以包含操作按钮，允许用户对消息做出特定响应。
- en: Toast messages are typically plain text messages that appear in a small pop-up
    window. Snackbar messages, on the other hand, can be styled to include icons,
    colors, and other visual elements to make them more visually appealing and informative.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Toast消息通常是出现在小弹出窗口中的纯文本消息。另一方面，Snackbar消息可以设计成包含图标、颜色和其他视觉元素，使其更具视觉吸引力和信息性。
- en: We modify the `onClick` callback of the `DropdownMenuItem` component to launch
    a coroutine that displays the `Toast` message using the `Toast.makeText` function.
    We pass in the current context using `LocalContext.current`, which gets the current
    context function and the text to display in the `Toast` message as a string. You
    should also specify the duration of your `Toast`, either `Short` or `Long`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了`DropdownMenuItem`组件的`onClick`回调，以启动一个显示`Toast`消息的协程，使用`Toast.makeText`函数。我们通过`LocalContext.current`传入当前上下文，它获取当前上下文函数和要显示在`Toast`消息中的文本作为字符串。您还应该指定`Toast`的持续时间，可以是`Short`或`Long`。
- en: 'When using `Snackbar`, we create a `SnackbarHostState`, which we pass in our
    `Scaffold`. Our composable includes a `snackbarHost` parameter specifying a function
    to display the Snackbar when shown. The `SnackbarHost` function takes two parameters:
    `snackbarData`, which contains the message and action button of the Snackbar,
    and a lambda that specifies how to create the `Snackbar` composable.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Snackbar`时，我们创建一个`SnackbarHostState`，并将其传递给我们的`Scaffold`。我们的可组合组件包括一个`snackbarHost`参数，指定在显示时显示Snackbar的函数。`SnackbarHost`函数接受两个参数：`snackbarData`，它包含Snackbar的消息和操作按钮，以及一个lambda，指定如何创建`Snackbar`可组合组件。
- en: In Android, `Scaffold` is a pre-built UI component or layout that provides an
    essential structure for building screens and UI components. The term **Scaffold**
    is often used interchangeably with the term template or boilerplate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，`Scaffold`是一个预构建的UI组件或布局，它为构建屏幕和UI组件提供了基本结构。术语**Scaffold**通常与模板或样板术语互换使用。
- en: Scaffolds are commonly used in Android app development frameworks such as Flutter
    or Jetpack Compose to provide a starting point for creating new screens or UI
    components.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Scaffold在Android应用程序开发框架（如Flutter或Jetpack Compose）中很常见，用于为创建新屏幕或UI组件提供起点。
- en: For example, the Material Design library in Android provides several pre-built
    scaffolds for common screen types, such as a login screen, a settings screen,
    or a list screen. These scaffolds provide a consistent look and feel and help
    ensure the app follows the Material Design guidelines.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Android中的Material Design库提供了几个预构建的scaffolds，用于常见的屏幕类型，如登录屏幕、设置屏幕或列表屏幕。这些scaffolds提供了一致的外观和感觉，并有助于确保应用程序遵循Material
    Design指南。
- en: Using scaffolds can save time and effort in app development by providing a starting
    point for building screens and UI components. However, developers can also customize
    and extend scaffolds to meet the specific requirements of their app.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用scaffolds可以通过提供构建屏幕和UI组件的起点来节省应用程序开发的时间和精力。然而，开发者也可以自定义和扩展scaffolds以满足他们应用程序的特定要求。
- en: Creating an alert dialog
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建警告对话框
- en: 'Pop-up alert dialogs are an essential component of the UI in Android applications.
    They are used to display important messages, notifications, and warnings to the
    user. Some reasons why using a pop-up alert dialog is essential in Android are
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出警告对话框是Android应用程序UI的一个基本组件。它们用于向用户显示重要消息、通知和警告。使用弹出警告对话框在Android中至关重要的原因如下：
- en: They can help highlight important information the user needs to know. For example,
    if the user is about to perform an action resulting in data loss or damage, the
    app can display a warning message in a pop-up alert dialog to ensure the user
    knows the consequences.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以帮助突出显示用户需要知道的重要信息。例如，如果用户即将执行可能导致数据丢失或损坏的操作，应用程序可以在弹出警告对话框中显示警告消息，以确保用户知道后果。
- en: They can be used to obtain user confirmation for necessary actions, such as
    deleting a file or purchasing something. By displaying a message that asks the
    user to confirm the action, the app can help prevent accidental or unwanted actions.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用来获取用户对必要操作的确认，例如删除文件或购买某物。通过显示一个请求用户确认操作的消息，应用程序可以帮助防止意外或不受欢迎的操作。
- en: They can be used to provide feedback to the user, such as letting them know
    that an action was successful or unsuccessful. For example, if the user tries
    to save a file that already exists, the app can display a pop-up alert dialog
    that informs the user of the issue and provides suggestions on how to proceed.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用来向用户提供反馈，例如让他们知道一个操作是成功还是失败。例如，如果用户尝试保存一个已存在的文件，应用程序可以显示一个弹出警告对话框，告知用户问题并提供如何继续的建议。
- en: They can help improve the overall user experience of an app by providing precise
    and concise messages that help users understand what is happening within the app.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过提供精确且简洁的消息来帮助用户理解应用程序内部正在发生的事情，从而帮助提高应用程序的整体用户体验。
- en: Alert dialogs are an essential component of Android app design. They can be
    used to highlight important information, obtain user confirmation, provide feedback,
    and improve the overall user experience.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 警告对话框是 Android 应用设计的重要组成部分。它们可以用来突出显示重要信息、获取用户确认、提供反馈，并改善整体用户体验。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the same project, so ensure you have completed previous
    recipes. To follow along, please also ensure you get the code in the *Technical*
    *requirements* section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用同一个项目，所以请确保你已经完成了之前的菜谱。为了跟上，请确保你也获得了 *技术要求* 部分的代码。
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to create an alert dialog:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个警告对话框：
- en: Let’s start by creating a Kotlin file and calling it `AlertDialogDemo.kt`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个 Kotlin 文件，并将其命名为 `AlertDialogDemo.kt`。
- en: 'Inside `AlertDialogDemo`, create a composable function and call it `AlertDialogExample()`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AlertDialogDemo` 中创建一个可组合函数，并命名为 `AlertDialogExample()`：
- en: '[PRE46]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There are different ways to implement `AlertDialog()`; in our example, we will
    create a button that will be clicked to start `dialog()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `AlertDialog()` 有不同的方法；在我们的例子中，我们将创建一个按钮，点击该按钮将启动 `dialog()`。
- en: 'Then, we must add the title and text properties to `AlertDialog`. We use the
    `Text` component to define the title and message text and set the `fontWeight`
    and `color` properties as needed:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须向 `AlertDialog` 添加标题和文本属性。我们使用 `Text` 组件来定义标题和消息文本，并根据需要设置 `fontWeight`
    和 `color` 属性：
- en: '[PRE48]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we will add the `confirmButton` and `dismissButton` properties to `AlertDialog`.
    We use the `Button` component to define the buttons and set the `onClick` property
    to a lambda that will perform the appropriate action when the button is clicked:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将向 `AlertDialog` 添加 `confirmButton` 和 `dismissButton` 属性。我们使用 `Button`
    组件来定义按钮，并将 `onClick` 属性设置为 lambda 表达式，当按钮被点击时将执行适当的操作：
- en: '[PRE65]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Finally, when you run the application, you will see a dialog with a title, message,
    and two calls to action, **Confirm** or **Cancel**.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当你运行应用程序时，你将看到一个带有标题、消息和两个操作调用（**确认**或**取消**）的对话框。
- en: '![Figure 11.5 – The alert dialog](img/Figure_11.5_B18827.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 警告对话框](img/Figure_11.5_B18827.jpg)'
- en: Figure 11.5 – The alert dialog
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 警告对话框
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In our example, we first create a `mutableStateOf` variable called `openDialog`
    with a Boolean value indicating whether the dialog should be displayed. We then
    use this variable to render the `AlertDialog` component using an `if` statement
    conditionally.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们首先创建一个名为 `openDialog` 的 `mutableStateOf` 变量，它具有一个布尔值，表示对话框是否应该显示。然后我们使用这个变量，通过一个
    `if` 语句有条件地使用 `AlertDialog` 组件来渲染。
- en: The `AlertDialog` component has several properties that we can set, including
    the title, text, `confirmButton`, and `dismissButton`. We can also set the background
    and content colors using the `backgroundColor` and `contentColor` properties.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlertDialog` 组件有几个我们可以设置的属性，包括标题、文本、`confirmButton` 和 `dismissButton`。我们还可以使用
    `backgroundColor` 和 `contentColor` 属性设置背景和内容颜色。'
- en: Finally, we add a `Button` component that toggles the `openDialog` variable
    when clicked, causing the dialog to be displayed or hidden.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个 `Button` 组件，当点击时切换 `openDialog` 变量，导致对话框显示或隐藏。
- en: Creating a bottom sheet dialog
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建底部对话框
- en: 'Bottom sheet dialogs are a popular design pattern in Android because they provide
    a simple and efficient way to display contextual information or actions without
    taking up too much space on the screen. When developing Android apps, here are
    some of the reasons why bottom sheet dialogs are considered a good choice:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 底部对话框是 Android 中流行的设计模式，因为它们提供了一种简单且高效的方式来显示上下文信息或操作，而不会占用太多屏幕空间。在开发 Android
    应用程序时，以下是为什么底部对话框被认为是好的选择的一些原因：
- en: They are designed to slide up from the bottom of the screen, taking up minimal
    screen space. This makes them an excellent option for displaying supplementary
    information or actions without overwhelming the user.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被设计为从屏幕底部滑动出来，占用最小的屏幕空间。这使得它们在显示补充信息或操作而不让用户感到压倒性时成为一个极好的选择。
- en: They are often used to provide additional information relevant to the current
    context, such as options or settings specific to the current view.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常用于提供与当前上下文相关的附加信息，例如针对当前视图的特定选项或设置。
- en: Because bottom sheet dialogs are designed to slide up from the bottom of the
    screen, they give users a sense of control over the interaction. Users can easily
    dismiss the dialog by swiping it down or tapping outside of the dialog.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于底部面板对话框被设计为从屏幕底部滑动出来，它们给用户一种对交互的控制感。用户可以通过向下滑动对话框或点击对话框外部轻松地关闭对话框。
- en: Overall, bottom sheet dialogs are an excellent choice because they provide a
    space-saving, contextual, and user-friendly way to display additional information
    or actions to the user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，底部面板对话框是一个极好的选择，因为它们提供了一种节省空间、上下文相关且用户友好的方式来向用户显示附加信息或操作。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the same project, so ensure you have completed previous
    recipes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用相同的工程，所以请确保你已经完成了之前的食谱。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Using the same project, follow these steps to build your first `BottomSheet`
    dialog:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的工程，按照以下步骤构建你的第一个`BottomSheet`对话框：
- en: Let’s start by creating a Kotlin file and calling it `BottomSheetDemo.kt`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`BottomSheetDemo.kt`的Kotlin文件开始。
- en: 'Inside `BottomSheetDemo`, create a composable function and call it `BottomSheetExample()`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BottomSheetDemo`内部创建一个可组合函数，并命名为`BottomSheetExample()`：
- en: '[PRE84]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Since we are using Material 3, we will acknowledge that most of the APIs are
    still experimental, meaning a lot might change. Let’s create our state for our
    bottom sheet dialog:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在使用Material 3，我们将承认大多数API仍然是实验性的，这意味着很多东西都可能改变。让我们为我们的底部面板对话框创建状态：
- en: '[PRE86]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `skipPartiallyExpanded` Boolean checks whether the partially expanded state
    should be skipped if the sheet is tall enough.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipPartiallyExpanded`布尔值检查如果面板足够高，是否应该跳过部分展开状态。'
- en: 'Now we need to go ahead and create our `ModalBottomSheet()`, which takes in
    several parameters; we will just use `onDismiss` and `sheetState`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要继续创建我们的`ModalBottomSheet()`，它接受几个参数；我们只需使用`onDismiss`和`sheetState`：
- en: '[PRE87]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Following the *Technical requirements* section, now let’s go ahead and implement
    the two buttons and get the entire code.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“技术要求”部分之后，现在让我们继续实施两个按钮并获取整个代码。
- en: Finally, run the app, and you will have implemented your bottom sheet dialog.
    Note you might want to add more logic based on your needs.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行应用，你将已经实现了你的底部面板对话框。注意你可能需要根据你的需求添加更多逻辑。
- en: "![Figure 11.6 – The \uFEFFbottom sheet dialog](img/Figure_11.6_B18827.jpg)"
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 底部面板对话框](img/Figure_11.6_B18827.jpg)'
- en: Figure 11.6 – The bottom sheet dialog
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 底部面板对话框
- en: How it works…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our example, `ModalBottomSheet` is used as an alternative to inline menus
    or simple dialogs on mobile, especially when offering a long list of action items
    or when items require longer descriptions and icons.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`ModalBottomSheet`被用作移动端内联菜单或简单对话框的替代品，尤其是在提供长列表的操作项或项目需要更长的描述和图标时。
- en: Like any other dialog in Android, modal bottom sheets appear before app content.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Android中的任何其他对话框一样，模态底部面板出现在应用内容之前。
- en: There is more…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Read more about bottom sheet dialogs and the available experimental features
    by going to the following link: [https://m3.material.io/components/bottom-sheets/overview](https://m3.material.io/components/bottom-sheets/overview).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问以下链接了解更多关于底部面板对话框和可用实验性功能的信息：[https://m3.material.io/components/bottom-sheets/overview](https://m3.material.io/components/bottom-sheets/overview)。
- en: Creating a radio button
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单选按钮
- en: In Modern Android Development, `RadioButton` is used similarly to how it is
    used in traditional Android development. `RadioButton` allows users to select
    a single item from a list of mutually exclusive options, meaning only one option
    can be selected at a time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Android开发中，`RadioButton`的使用方式与传统Android开发中的使用方式相似。`RadioButton`允许用户从互斥选项列表中选择一个项目，这意味着一次只能选择一个选项。
- en: In Jetpack Compose, `RadioButton` is part of the Material Design library and
    can be used by importing the `Androidx.compose.Material.RadioButton` package.
    To create a group of `RadioButton` instances, you would typically use the `RadioGroup`
    composable, which is also part of the Material Design library.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 中，`RadioButton` 是 Material Design 库的一部分，可以通过导入 `Androidx.compose.Material.RadioButton`
    包来使用。要创建一组 `RadioButton` 实例，你通常会使用 `RadioGroup` 组合组件，它也是 Material Design 库的一部分。
- en: The `RadioGroup` composable takes a list of options as input, along with a selected
    option and a callback that is called when the selected option changes. The individual
    `RadioButton` instances can be created using the `RadioButton` composable and
    added as children of `RadioGroup`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadioGroup` 组合组件接受一个选项列表作为输入，以及一个选中选项和一个当选中选项改变时被调用的回调。可以使用 `RadioButton`
    组合组件创建单个 `RadioButton` 实例，并将其作为 `RadioGroup` 的子组件添加。'
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will continue using the same project, so ensure you have
    completed previous recipes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用相同的工程，所以请确保你已经完成了之前的菜谱。
- en: How to do it…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Using the same project, follow these steps to build your first `RadioButton`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的工程，按照以下步骤构建你的第一个 `RadioButton`：
- en: Let’s start by creating a Kotlin file and calling it `RadioButtonDemo.kt`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 Kotlin 文件，并将其命名为 `RadioButtonDemo.kt`。
- en: 'Inside `RadioButtonDemo`, create a composable function and call it `RadioButtonExample()`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RadioButtonDemo` 中创建一个组合函数，并命名为 `RadioButtonExample()`：
- en: '[PRE111]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We will start creating a list of choices, and in our example, we can use fruit,
    then keep track of selected choices:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始创建一个选择列表，在我们的例子中，我们可以使用水果，然后跟踪选中的选择：
- en: '[PRE113]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Since we are using the `RadioButton` composable provided by Google, based on
    your needs, you can customize your `RadioButton` however you like:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Google 提供的 `RadioButton` 组合组件，根据你的需求，你可以按自己的喜好自定义 `RadioButton`：
- en: '[PRE116]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Finally, when we run the app, you should see something similar to *Figure 11**.7*.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们运行应用时，你应该能看到类似于 *图 11**.7* 的内容。
- en: "![Figure 11.7 – T\uFEFFhe \uFEFFradio \uFEFFbutton](img/Figure_11.7_B18827.jpg)"
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 单选按钮](img/Figure_11.7_B18827.jpg)'
- en: Figure 11.7 – The radio button
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 单选按钮
- en: How it works…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our example, we create a `RadioButtonExample()` composable that displays
    a group of `RadioButton` instances with the following choices– `Mangoes`, `Avocado`,
    and `Oranges`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们创建了一个 `RadioButtonExample()` 组合组件，它显示了一组具有以下选择的 `RadioButton` 实例 –
    `芒果`、`鳄梨` 和 `橙子`。
- en: The selected option is stored in a `selectedOption` variable using the `remember`
    composable to maintain the state across recomposition. Each `RadioButton` is wrapped
    in a `Row(){...}` that includes the choice text, and the selected property of
    the `RadioButton` is set based on whether the current option matches the selected
    option.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `remember` 组合组件将选中的选项存储在 `selectedOption` 变量中，以在重新组合之间保持状态。每个 `RadioButton`
    都被包裹在一个 `Row(){...}` 中，包括选择文本，并且 `RadioButton` 的选中属性根据当前选项是否与选中选项匹配来设置。
- en: When the user clicks on `RadioButton`, the `selectedOption` variable is updated
    with the newly selected option.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 `RadioButton` 时，`selectedOption` 变量会更新为新选中的选项。
- en: Creating a FAB/extended FAB
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 FAB/扩展 FAB
- en: A **FAB** is a circular button that appears to *float* above the UI of an Android
    application. It is often used to represent a primary action in the app and is
    placed in a visible location for easy access.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**FAB** 是一个圆形按钮，看起来像是在 Android 应用的 UI 上 *浮动*。它通常用来表示应用的主要操作，并放置在易于访问的可见位置。'
- en: An extended FAB is a variation of a FAB in Android that provides users with
    more options and functionality. The extended FAB is a rectangular button that
    can display text and an icon and expands into a menu of related actions when pressed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 FAB 是 Android 中 FAB 的一个变体，为用户提供更多选项和功能。扩展 FAB 是一个可以显示文本和图标的矩形按钮，在按下时展开成相关操作的菜单。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will continue using the same project, so ensure you have
    completed previous recipes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续使用相同的工程，所以请确保你已经完成了之前的菜谱。
- en: How to do it…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Using the same project, follow these steps to build a FAB and extended FAB:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的工程，按照以下步骤构建 FAB 和扩展 FAB：
- en: Let’s start by creating a Kotlin file and calling it `ActionComponentsDemo.kt`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 Kotlin 文件，并将其命名为 `ActionComponentsDemo.kt`。
- en: 'Inside `ActionComponentsDemo`, create a composable function and call it `ActionComponentsExample()`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ActionComponentsDemo` 中创建一个组合函数，并命名为 `ActionComponentsExample()`：
- en: '[PRE130]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Inside `ActionComponentsDemo`, create a composable function and call it `ActionComponentsExample()`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ActionComponentsDemo` 中创建一个组合器函数，并调用它 `ActionComponentsExample()`。
- en: 'We will start by creating a FAB. `FloatingActionButton` is a circular button
    that floats above the UI and is typically used to trigger the primary action in
    an app. You can use `FloatingActionButton` in Jetpack Compose to create a `FloatingActionButton`
    composable:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个 FAB。`FloatingActionButton` 是一个圆形按钮，它浮在 UI 之上，通常用于触发应用中的主要操作。你可以在 Jetpack
    Compose 中使用 `FloatingActionButton` 创建一个 `FloatingActionButton` 组合器：
- en: '[PRE132]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '`ExtendedFloatingActionButton` is a `FloatingActionButton` instance with additional
    text or iconography. It’s often used for secondary actions in an app.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtendedFloatingActionButton` 是一个带有附加文本或图标的 `FloatingActionButton` 实例。它通常用于应用中的次要操作。'
- en: 'To create `ExtendedFloatingActionButton` in Jetpack Compose, you can use the
    `ExtendedFloatingActionButton` composable. This code creates it with a text label
    of `"Add item"` and an plus icon. The `onClick` parameter specifies the action
    to perform when the button is clicked:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 中创建 `ExtendedFloatingActionButton`，你可以使用 `ExtendedFloatingActionButton`
    组合器。此代码使用文本标签 `"Add item"` 和一个加号图标创建它。`onClick` 参数指定当按钮被点击时执行的操作：
- en: '[PRE136]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'When you run the app, you should see two buttons, a floating button and an
    extended button:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行应用时，你应该看到两个按钮，一个浮动按钮和一个扩展按钮：
- en: "![Figu\uFEFFre 11.8 – The FAB and extended FAB](img/Figure_11.8_B18827.jpg)"
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – FAB 和扩展 FAB](img/Figure_11.8_B18827.jpg)'
- en: Figure 11.8 – The FAB and extended FAB
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – FAB 和扩展 FAB
- en: How it works…
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: An extended FAB is similar to a FAB but provides additional space for text and/or
    an icon. It is typically used to provide more context or information about the
    action that will be performed when the button is tapped. For example, an **Extended
    Floating Action Button** (**EFAB**) might display the text **Create new budget**
    along with a pen icon.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 FAB 与 FAB 类似，但为文本和/或图标提供了额外的空间。它通常用于提供更多关于将要执行的操作的上下文或信息。例如，一个 **扩展浮动操作按钮**
    (**EFAB**) 可能会显示文本 **创建新预算** 并附带一个钢笔图标。
- en: Both FABs and EFABs are part of the Material Design guidelines and are available
    as a component in Jetpack Compose.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 FAB 和 EFAB 都是 Material Design 指南的一部分，并在 Jetpack Compose 中作为组件提供。
- en: There more …
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多 …
- en: 'To learn more about Material 3 Components and guidelines, see the following
    links: [https://m3.Material.io/](https://m3.Material.io/) and [https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary](https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Material 3 组件和指南的信息，请参阅以下链接：[https://m3.Material.io/](https://m3.Material.io/)
    和 [https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary](https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary)。
