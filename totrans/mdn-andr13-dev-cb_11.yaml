- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GUI Alerts – What’s New in Menus, Dialog, Toast, Snackbars, and More in Modern
    Android Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Graphic User Interface** (**GUI**) alerts are essential to users because
    they provide critical information about a program or application’s status and
    can help users avoid errors and make informed decisions. Alerts can be triggered
    in various situations, such as when an error occurs, a program performs a critical
    operation, or when a user is about to perform an irreversible action.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main benefits of GUI alerts is that they provide immediate feedback
    to users. For example, if a user enters incorrect information into a form, an
    alert can quickly inform them of the error, allowing them to correct it before
    proceeding. This can help to prevent mistakes and save time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of GUI alerts is that they can help to prevent accidental actions.
    For example, if a user is about to delete an important file, an alert can warn
    them of the potential consequences of this action, giving them a chance to reconsider
    before proceeding. This chapter will examine how a GUI is implemented in Modern
    Android Development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and displaying a menu in Modern Android Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Toast/Snackbars to alert users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an alert dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `BottomSheet` dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a radio button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating **Floating Action Buttons** (**FABs**) and extended FABs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven).
  prefs: []
  type: TYPE_NORMAL
- en: Creating and displaying a menu in Modern Android Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a menu in an Android app can provide several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Menus can help users quickly access different features and functionalities within
    an app. A well-designed menu can improve the user experience by making it easy
    to navigate and use the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A consistent menu across different screens in an app can help users quickly
    find what they’re looking for, making the app feel more polished and professional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A menu can be used to group related options and functions in one place, reducing
    the need for cluttered screens with many buttons and options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus can also be customized to fit an app’s specific needs, including different
    types of menus, such as context menus, pop-up menus, and navigation drawers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus should be designed with accessibility in mind, making it easier for users
    with disabilities to navigate the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is to say, creating a menu in an Android app can improve the user experience,
    provide consistency, save space, and increase accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this chapter, we will create a new Material 3 project and call it `GUIAlerts`;
    this is where we will add all our UI components for this chapter, and you can
    take advantage of the project to modify the views to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the following steps to build your first hamburger menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside our newly created project, `GUIAlerts`, let’s create a package component,
    and inside the package, create a Kotlin file and call it `MenuComponent.kt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create a composable function, `OurMenu`, in our Kotlin file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s go ahead and create our menu. For our purposes, we will just showcase
    some items, and when someone clicks, nothing will happen since we will not implement
    the `onClick` function. First, we need to ensure it does not start as `expanded`,
    which means users will click to expand the menu and it will change to `true` in
    response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For our menu items, we will just showcase four items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must create a `Box()`, align it to the center, and react to the `expanded`
    state in the modifier. We will also need to add an icon, `ArrowDropDown`, to inform
    users they can click and that we have more items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we will need to add `DropDownMenu`, which will expand when we click
    the icon, and we will set `onDismissRequest` to `false`; it is called when the
    user requests to dismiss the menu, for instance, when tapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will display our items on the `DropdownMenuItem` function so that
    when it is clicked, it performs an action. For our example, we don’t do anything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, when you run the app, you should see a menu dropdown with items you
    can click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The drop-down menu](img/Figure_11.1_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The drop-down menu
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can customize the drop-down menu to fit your needs and style.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we first declare a mutable state variable, `expanded`, to keep
    track of whether the menu is expanded or not and another mutable state variable,
    `selectedMenuItem`, to keep track of the currently selected menu item.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a list of `menuItems` which helps us know the menu list.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our `Box`, we define a `Column(){}`, which contains the menu title, a
    clickable `Box`, which displays the selected menu item, and a `DropdownMenu`,
    which displays the menu items when expanded. We use the `Box` and `DropdownMenu`
    components to position the menu items relative to the clickable `Box`.
  prefs: []
  type: TYPE_NORMAL
- en: '`DropDownMenu` takes in a couple of inputs, as you can see in *Figure 11**.2*,
    and this helps you customize your drop-down menu based on your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.2 – The DropDownMenuItem input param\uFEFFeters](img/Figure_11.2_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The DropDownMenuItem input parameters
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `DropdownMenuItem` component to display each menu item and
    update the `selectedMenuItem` and `expanded` variables when a menu item is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Toast/Snackbar to alert users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android development, a Toast/Snackbar is a small pop-up message that appears
    on the screen, usually at the bottom. It’s used to provide brief information or
    feedback to the user. It is a simple way to display short messages to the user
    without interrupting the user’s workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will react to the items we created in our `DropMenuItem`,
    so you must have followed the previous recipe to continue with this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to add a message when the items are clicked to
    tell the users they’ve picked a particular item:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Toast is very straightforward in Android; you can simply do that
    using the `Toast` class the Android SDK provides. You can create a new `Toast`
    object by calling the static `makeText()` method of the `Toast` class and passing
    it the context, message, and duration of the Toast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have created the `Toast` object, you can call the `show()` method
    to display it on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Jetpack Compose, however, to display a `Toast`, we will need to use `coroutineScope`,
    but note you do not need a coroutine to display a Toast in all instances, in our
    example however, we will use the `launch` function to launch a coroutine that
    displays the Toast message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To hook up `onClick()`, please see the code in the *Technical requirements*
    section to get the entire code. Finally, when you run the app, you should see
    a `Toast` message with the item selected as the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The Toast message displayed](img/Figure_11.3_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The Toast message displayed
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will use a Snackbar now instead of a Toast:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are different ways of using a Snackbar in Jetpack Compose; you can use
    it with a `Scaffold` or without it. However, it is recommended to use a Snackbar
    with a `Scaffold`. In our example, we will use a `Scaffold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Finally, when you run the app, you will see a Snackbar with the selected item
    text and item selected. Both `Toast` and `Snackbar` serve the same purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – The Snackbar message displayed](img/Figure_11.4_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The Snackbar message displayed
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Toasts and Snackbars are two types of notification messages that can be used
    in Android applications to display short messages to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main differences between Toasts and Snackbars are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Toast messages are typically displayed in the center of the screen, while Snackbar
    messages are usually displayed at the bottom of the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toast messages typically last for a short period of time, usually around 2-3
    seconds, and then disappear automatically. Snackbar messages are usually displayed
    for a more extended period of time and can be dismissed by the user by swiping
    them away or by tapping on a button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toast messages are not interactive and cannot be dismissed by the user. Snackbar
    messages, on the other hand, can contain action buttons that allow the user to
    take specific actions in response to the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toast messages are typically plain text messages that appear in a small pop-up
    window. Snackbar messages, on the other hand, can be styled to include icons,
    colors, and other visual elements to make them more visually appealing and informative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We modify the `onClick` callback of the `DropdownMenuItem` component to launch
    a coroutine that displays the `Toast` message using the `Toast.makeText` function.
    We pass in the current context using `LocalContext.current`, which gets the current
    context function and the text to display in the `Toast` message as a string. You
    should also specify the duration of your `Toast`, either `Short` or `Long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `Snackbar`, we create a `SnackbarHostState`, which we pass in our
    `Scaffold`. Our composable includes a `snackbarHost` parameter specifying a function
    to display the Snackbar when shown. The `SnackbarHost` function takes two parameters:
    `snackbarData`, which contains the message and action button of the Snackbar,
    and a lambda that specifies how to create the `Snackbar` composable.'
  prefs: []
  type: TYPE_NORMAL
- en: In Android, `Scaffold` is a pre-built UI component or layout that provides an
    essential structure for building screens and UI components. The term **Scaffold**
    is often used interchangeably with the term template or boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolds are commonly used in Android app development frameworks such as Flutter
    or Jetpack Compose to provide a starting point for creating new screens or UI
    components.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Material Design library in Android provides several pre-built
    scaffolds for common screen types, such as a login screen, a settings screen,
    or a list screen. These scaffolds provide a consistent look and feel and help
    ensure the app follows the Material Design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Using scaffolds can save time and effort in app development by providing a starting
    point for building screens and UI components. However, developers can also customize
    and extend scaffolds to meet the specific requirements of their app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an alert dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pop-up alert dialogs are an essential component of the UI in Android applications.
    They are used to display important messages, notifications, and warnings to the
    user. Some reasons why using a pop-up alert dialog is essential in Android are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They can help highlight important information the user needs to know. For example,
    if the user is about to perform an action resulting in data loss or damage, the
    app can display a warning message in a pop-up alert dialog to ensure the user
    knows the consequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used to obtain user confirmation for necessary actions, such as
    deleting a file or purchasing something. By displaying a message that asks the
    user to confirm the action, the app can help prevent accidental or unwanted actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used to provide feedback to the user, such as letting them know
    that an action was successful or unsuccessful. For example, if the user tries
    to save a file that already exists, the app can display a pop-up alert dialog
    that informs the user of the issue and provides suggestions on how to proceed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can help improve the overall user experience of an app by providing precise
    and concise messages that help users understand what is happening within the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alert dialogs are an essential component of Android app design. They can be
    used to highlight important information, obtain user confirmation, provide feedback,
    and improve the overall user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the same project, so ensure you have completed previous
    recipes. To follow along, please also ensure you get the code in the *Technical*
    *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an alert dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a Kotlin file and calling it `AlertDialogDemo.kt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `AlertDialogDemo`, create a composable function and call it `AlertDialogExample()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are different ways to implement `AlertDialog()`; in our example, we will
    create a button that will be clicked to start `dialog()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must add the title and text properties to `AlertDialog`. We use the
    `Text` component to define the title and message text and set the `fontWeight`
    and `color` properties as needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will add the `confirmButton` and `dismissButton` properties to `AlertDialog`.
    We use the `Button` component to define the buttons and set the `onClick` property
    to a lambda that will perform the appropriate action when the button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, when you run the application, you will see a dialog with a title, message,
    and two calls to action, **Confirm** or **Cancel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – The alert dialog](img/Figure_11.5_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – The alert dialog
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we first create a `mutableStateOf` variable called `openDialog`
    with a Boolean value indicating whether the dialog should be displayed. We then
    use this variable to render the `AlertDialog` component using an `if` statement
    conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: The `AlertDialog` component has several properties that we can set, including
    the title, text, `confirmButton`, and `dismissButton`. We can also set the background
    and content colors using the `backgroundColor` and `contentColor` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add a `Button` component that toggles the `openDialog` variable
    when clicked, causing the dialog to be displayed or hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bottom sheet dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bottom sheet dialogs are a popular design pattern in Android because they provide
    a simple and efficient way to display contextual information or actions without
    taking up too much space on the screen. When developing Android apps, here are
    some of the reasons why bottom sheet dialogs are considered a good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: They are designed to slide up from the bottom of the screen, taking up minimal
    screen space. This makes them an excellent option for displaying supplementary
    information or actions without overwhelming the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are often used to provide additional information relevant to the current
    context, such as options or settings specific to the current view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because bottom sheet dialogs are designed to slide up from the bottom of the
    screen, they give users a sense of control over the interaction. Users can easily
    dismiss the dialog by swiping it down or tapping outside of the dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, bottom sheet dialogs are an excellent choice because they provide a
    space-saving, contextual, and user-friendly way to display additional information
    or actions to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the same project, so ensure you have completed previous
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same project, follow these steps to build your first `BottomSheet`
    dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a Kotlin file and calling it `BottomSheetDemo.kt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `BottomSheetDemo`, create a composable function and call it `BottomSheetExample()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are using Material 3, we will acknowledge that most of the APIs are
    still experimental, meaning a lot might change. Let’s create our state for our
    bottom sheet dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `skipPartiallyExpanded` Boolean checks whether the partially expanded state
    should be skipped if the sheet is tall enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to go ahead and create our `ModalBottomSheet()`, which takes in
    several parameters; we will just use `onDismiss` and `sheetState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Following the *Technical requirements* section, now let’s go ahead and implement
    the two buttons and get the entire code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, run the app, and you will have implemented your bottom sheet dialog.
    Note you might want to add more logic based on your needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 11.6 – The \uFEFFbottom sheet dialog](img/Figure_11.6_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – The bottom sheet dialog
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, `ModalBottomSheet` is used as an alternative to inline menus
    or simple dialogs on mobile, especially when offering a long list of action items
    or when items require longer descriptions and icons.
  prefs: []
  type: TYPE_NORMAL
- en: Like any other dialog in Android, modal bottom sheets appear before app content.
  prefs: []
  type: TYPE_NORMAL
- en: There is more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Read more about bottom sheet dialogs and the available experimental features
    by going to the following link: [https://m3.material.io/components/bottom-sheets/overview](https://m3.material.io/components/bottom-sheets/overview).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a radio button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Modern Android Development, `RadioButton` is used similarly to how it is
    used in traditional Android development. `RadioButton` allows users to select
    a single item from a list of mutually exclusive options, meaning only one option
    can be selected at a time.
  prefs: []
  type: TYPE_NORMAL
- en: In Jetpack Compose, `RadioButton` is part of the Material Design library and
    can be used by importing the `Androidx.compose.Material.RadioButton` package.
    To create a group of `RadioButton` instances, you would typically use the `RadioGroup`
    composable, which is also part of the Material Design library.
  prefs: []
  type: TYPE_NORMAL
- en: The `RadioGroup` composable takes a list of options as input, along with a selected
    option and a callback that is called when the selected option changes. The individual
    `RadioButton` instances can be created using the `RadioButton` composable and
    added as children of `RadioGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will continue using the same project, so ensure you have
    completed previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same project, follow these steps to build your first `RadioButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a Kotlin file and calling it `RadioButtonDemo.kt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `RadioButtonDemo`, create a composable function and call it `RadioButtonExample()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will start creating a list of choices, and in our example, we can use fruit,
    then keep track of selected choices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are using the `RadioButton` composable provided by Google, based on
    your needs, you can customize your `RadioButton` however you like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, when we run the app, you should see something similar to *Figure 11**.7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 11.7 – T\uFEFFhe \uFEFFradio \uFEFFbutton](img/Figure_11.7_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – The radio button
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we create a `RadioButtonExample()` composable that displays
    a group of `RadioButton` instances with the following choices– `Mangoes`, `Avocado`,
    and `Oranges`.
  prefs: []
  type: TYPE_NORMAL
- en: The selected option is stored in a `selectedOption` variable using the `remember`
    composable to maintain the state across recomposition. Each `RadioButton` is wrapped
    in a `Row(){...}` that includes the choice text, and the selected property of
    the `RadioButton` is set based on whether the current option matches the selected
    option.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on `RadioButton`, the `selectedOption` variable is updated
    with the newly selected option.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a FAB/extended FAB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **FAB** is a circular button that appears to *float* above the UI of an Android
    application. It is often used to represent a primary action in the app and is
    placed in a visible location for easy access.
  prefs: []
  type: TYPE_NORMAL
- en: An extended FAB is a variation of a FAB in Android that provides users with
    more options and functionality. The extended FAB is a rectangular button that
    can display text and an icon and expands into a menu of related actions when pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will continue using the same project, so ensure you have
    completed previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same project, follow these steps to build a FAB and extended FAB:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a Kotlin file and calling it `ActionComponentsDemo.kt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `ActionComponentsDemo`, create a composable function and call it `ActionComponentsExample()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside `ActionComponentsDemo`, create a composable function and call it `ActionComponentsExample()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start by creating a FAB. `FloatingActionButton` is a circular button
    that floats above the UI and is typically used to trigger the primary action in
    an app. You can use `FloatingActionButton` in Jetpack Compose to create a `FloatingActionButton`
    composable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ExtendedFloatingActionButton` is a `FloatingActionButton` instance with additional
    text or iconography. It’s often used for secondary actions in an app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `ExtendedFloatingActionButton` in Jetpack Compose, you can use the
    `ExtendedFloatingActionButton` composable. This code creates it with a text label
    of `"Add item"` and an plus icon. The `onClick` parameter specifies the action
    to perform when the button is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you run the app, you should see two buttons, a floating button and an
    extended button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figu\uFEFFre 11.8 – The FAB and extended FAB](img/Figure_11.8_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The FAB and extended FAB
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An extended FAB is similar to a FAB but provides additional space for text and/or
    an icon. It is typically used to provide more context or information about the
    action that will be performed when the button is tapped. For example, an **Extended
    Floating Action Button** (**EFAB**) might display the text **Create new budget**
    along with a pen icon.
  prefs: []
  type: TYPE_NORMAL
- en: Both FABs and EFABs are part of the Material Design guidelines and are available
    as a component in Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: There more …
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about Material 3 Components and guidelines, see the following
    links: [https://m3.Material.io/](https://m3.Material.io/) and [https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary](https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary).'
  prefs: []
  type: TYPE_NORMAL
