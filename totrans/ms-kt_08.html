<html><head></head><body><div><div><div><h1 id="_idParaDest-92" class="chapter-number"><a id="_idTextAnchor101"/>8</h1>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor102"/>Persisting Data Locally and Doing Background Work</h1>
			<p>To provide better user experiences, we must ensure that apps don’t fetch data every time the user opens the app. At times, the user can be in areas that do not have internet access, and this can be very frustrating when the user can’t use your app in such situations. For such scenarios, we have to store data locally. We also have to store and update the data in an efficient way that doesn’t drain the device’s battery or block the user from doing other things on the app. In this chapter, we will be exploring how to do so for our apps.</p>
			<p>In this chapter, we will learn how to save data to a local database, <strong class="bold">Room</strong>, which is part of the Jetpack libraries. We will be able to save items and read from the Room database. Additionally, we will learn how to do long-running operations using <strong class="bold">WorkManager</strong> and some of the best practices.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Saving and reading data from a local database</li>
				<li>Handling updates and migrations in the Room database</li>
				<li>Using WorkManager to schedule background tasks</li>
				<li>Testing your workers</li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor103"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight</a>.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor104"/>Saving and reading data from a local database</h1>
			<p>We are going to build up on the Pets app, which displays a list of cute cats. <a id="_idTextAnchor105"/>We will save our cute cats in a local database, Room, which is a part of the Android Jetpack libraries and provides a wrapper and <a id="_idIndexMarker387"/>abstraction layer over SQLite. We <a id="_idIndexMarker388"/>will also use the <code>ViewModel</code>. The Room database provides an abstraction layer over SQLite to allow fluent <a id="_idIndexMarker389"/>database access while harnessing the full power of SQLite. It also has inbuilt support for Kotlin coroutines and flows to allow for asynchronous database access. Room is also compile-time safe and hence any errors in SQL queries are caught at compile time. It allows us to do all this with concise code.</p>
			<p>To use Room in our project, we need to add its dependency to our <code>libs.versions.toml</code> file. Let us start by defining the Room version in the <code>versions</code> section as the following:</p>
			<pre class="source-code">
room = "2.5.2"</pre>			<p>Next, let us add the dependencies in our <code>libraries</code> section:</p>
			<pre class="source-code">
room-runtime = { module = "androidx.room:room-runtime" , version.ref = "room" }
room-compiler = { module = "androidx.room:room-compiler", version.ref = "room" }
room-ktx = { module = "androidx.room:room-ktx", version.ref = "room" }</pre>			<p>Sync the project for the changes to be added. Before we add these dependencies to the app level <code>build.gradle.kts</code> file, we need to set up an annotation processor for the room compiler. Room<a id="_idIndexMarker390"/> uses the <code>build.gradle.kts</code> file:</p>
			<pre class="source-code">
id("com.google.devtools.ksp") version "1.9.0-1.0.13" apply false</pre>			<p>We have added the <code>build.gradle.kts</code> file:</p>
			<pre class="source-code">
id("com.google.devtools.ksp")</pre>			<p>This allows us to use<a id="_idIndexMarker394"/> KSP in our app module. To finalize setting up Room, now let us add the dependencies we declared earlier to the app level <code>build.gradle.kts</code> file:</p>
			<pre class="source-code">
implementation(libs.room.runtime)
implementation(libs.room.ktx)
ksp(libs.room.compiler)</pre>			<p>We have added our Room dependencies and the Room KTX library with the <code>implementation</code> configuration and the Room compiler with the <code>ksp</code> configuration. We are now ready to start using Room in our project. Let us start by creating an entity class for our <code>Cat</code> object. This will be the data class that will be used to store our pets in the database. Inside the <code>data</code> package, create a new file called <code>CatEntity.kt</code> and add the following code:</p>
			<pre class="source-code">
@Entity(tableName = "Cat")
data class CatEntity(
    @PrimaryKey
    val id: String,
    val owner: String,
    val tags: List&lt;String&gt;,
    val createdAt: String,
    val updatedAt: String
)</pre>			<p>This data class represents the Room table for our cats. The <code>@Entity</code> annotation is used to define the table for our cats. We have passed the <code>tableName</code> value to specify the name of our table. The <code>@PrimaryKey</code> annotation is used to define the <code>tags</code>, which is a list of strings. Room provides functionality to save <a id="_idIndexMarker397"/>non-primitive types using the <code>@TypeConverter</code> annotation. Let us create a new file named <code>PetsTypeConverters.kt</code> and add the following code:</p>
			<pre class="source-code">
class PetsTypeConverters {
    @TypeConverter
    fun convertTagsToString(tags: List&lt;String&gt;): String {
        return Json.encodeToString(tags)
    }
    @TypeConverter
    fun convertStringToTags(tags: String): List&lt;String&gt; {
        return Json.decodeFromString(tags)
    }
}</pre>			<p>This class has two functions annotated with the <code>@TypeConverter</code> annotation. The first function converts a list of strings to a string. The second function converts a string to a list of strings. We have used the Kotlinx serialization library to convert the list of strings to a string and vice versa. This class will be referenced in our database class that we will create shortly.</p>
			<p>We are now ready to create our database. We need to create a <code>data</code> package, create a new file called <code>CatDao.kt</code> and add the following code:</p>
			<pre class="source-code">
@Dao
interface CatDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(catEntity: CatEntity)
    @Query("SELECT * FROM Cat")
    fun getCats(): Flow&lt;List&lt;CatEntity&gt;&gt;
}</pre>			<p>The interface is annotated with the <code>@Dao</code> annotation to tell Room that we will use this class as our DAO. We have defined two functions in our DAO. The <code>insert</code> function is used to insert a cat into our database. Notice that this is a <code>suspend</code> function. This is because we will be using coroutines to insert the cats into our database. Inserting items into the database needs to happen on a background thread since it is a resource-intensive operation. We also use the <code>@Insert</code> annotation with the <code>onConflict</code> parameter set to <code>OnConflictStrategy.REPLACE</code>. This tells Room to replace the cat if it already exists in the database. The <code>getCats</code> function is used to get all the cats from our database. It has the <code>@Query</code> annotation, which is used to define a query to get the cats from our database. We are using <code>Flow</code> to return the cats from our database. <code>Flow</code> is a stream of data that can be observed. This means that every time we update the database, the changes will be emitted to the view layers immediately without us doing any extra work. Cool, right?</p>
			<p>We now need to create our database class. Inside the <code>data</code> package, create a new file called <code>CatDatabase.kt</code> and add the following code:</p>
			<pre class="source-code">
@Database(
    entities = [CatEntity::class],
    version = 1
)
@TypeConverters(PetsTypeConverters::class)
abstract class CatDatabase: RoomDatabase() {
    abstract fun catDao(): CatDao
}</pre>			<p>We have defined an abstract class that extends the <code>RoomDatabase</code> class. We passed the <code>entities</code> parameter to specify the entities or tables stored in our database. We have also passed the <code>version</code> parameter to specify the version of our database. We have used the <code>@TypeConverters</code> annotation to specify the type converters that we will be using in our database. We <a id="_idIndexMarker401"/>have also defined an abstract method that returns our <code>CatDao</code>. We need to provide an instance of the database to classes that need it. We will do this by using the<a id="_idIndexMarker402"/> dependency injection pattern we have been using in our project. Let us head over to the <code>di</code> package and in the <code>Module.kt</code> file, add the Room dependency just below the Retrofit dependency:</p>
			<pre class="source-code">
single {
    Room.databaseBuilder(
        androidContext(),
        CatDatabase::class.java,
        "cat-database"
    ).build()
}
single { get&lt;CatDatabase&gt;().carDao() }</pre>			<p>First, we have created a single instance of our database. We have used the <code>databaseBuilder</code> method to create our database. We have passed the <code>androidContext()</code> method from Koin to get the context of our application. We have also passed <code>CatDatabase::class.java</code> to specify the class of our database. We have also passed the <code>name</code> of our database. We have then created a single instance of our <code>CatDao</code>. We are using the <code>get</code> method to get the instance of our database and then calling the <code>catDao</code> function to get our <code>CatDao</code>.</p>
			<p>Our database is now ready to be used in our repository. We are going to modify <code>PetRepository</code> and its implementation to be able to do the following:</p>
			<ul>
				<li>Save items to our database</li>
				<li>Read items from our database</li>
				<li>Change our <code>getPets()</code> function<a id="_idIndexMarker403"/> to return a <code>Flow</code> of pets</li>
			</ul>
			<p>The modified <code>PetRepository.kt</code> file should look like the following:</p>
			<pre class="source-code">
interface PetsRepository {
    suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt;
    suspend fun fet<a id="_idTextAnchor106"/>chRemotePets()
}</pre>			<p>We have modified the <code>getPets</code> function to return a <code>Flow</code> of pets. Room does not allow database access on the main thread, therefore, our queries have to be asynchronous. Room <a id="_idIndexMarker404"/>provides support for observable queries that read data from our database every time data in our database changes and emits new values to reflect the changes. This is the reason we return a <code>Flow</code> instance type from the <code>getPets</code> function. We have also added the <code>fetchRemotePets</code> function to fetch the pets from the remote data source. Let us now modify <code>PetRepositoryImpl.kt</code> with a few changes:</p>
			<pre class="source-code">
class PetsRepositoryImpl(
    private  val catsAPI: CatsAPI,
    private val dispatcher: CoroutineDispatcher,
    private val catDao: CatDao
): PetsRepository {
    override suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt; {
        return withContext(dispatcher) {
           catDao.getCats()
               .map { petsCached -&gt;
                   petsCached.map { catEntity -&gt;
                       Cat(
                           id = catEntity.id,
                           owner = catEntity.owner,
                           tags = catEntity.tags,
                           createdAt = catEntity.createdAt,
                           updatedAt = catEntity.updatedAt
                       ) }
               }
               .onEach {
                     if (it.isEmpty()) {
                          fetchRemotePets()
                     }
               }
        }
    }
    override suspend fun fetchRemotePets() {
        withContext(dispatcher) {
            val response = catsAPI.fetchCats("cute")
            if (response.isSuccessful) {
                response.body()!!.map {
                    catDao.insert(CatEntity(
                        id = it.id,
                        owner = it.owner,
                        tags = it.tags,
                        createdAt = it.createdAt,
                        updatedAt = it.updatedAt
                    ))
                }
            }
        }
    }
}</pre>			<p>We have made the following changes:</p>
			<ul>
				<li>We have added the <code>catDao</code> property to the constructor of the class.</li>
				<li>We have modified the <code>getPets</code> function to return a <code>Flow</code> of pets. Additionally, we<a id="_idIndexMarker405"/> have added a <code>map</code> operator to map <code>CatEntity</code> to a <code>Cat</code> object. We have<a id="_idIndexMarker406"/> also added an <code>onEach</code> operator to check if the list of pets is empty. If it is empty, we call the <code>fetchRemotePets</code> function to fetch the pets from the remote data source. This provides an <strong class="bold">offline first experience</strong> to our<a id="_idIndexMarker407"/> users; that is, we first check if we have the data in our database and if we don’t, we fetch it from the remote data source.</li>
				<li>Lastly, we have modified the <code>fetchRemotePets</code> function that fetches the pets from the remote data source. When the response is successful, we map the response to a <code>CatEntity</code> instance type and insert it into our database.</li>
			</ul>
			<p>We need to update the <code>PetsRepository</code> dependency in our <code>Module.kt</code> file to add the <code>CatDao</code> dependency:</p>
			<pre class="source-code">
single&lt;PetsRepository&gt; { PetsRepositoryImpl(get(), get(), get()) }</pre>			<p>In our <code>PetsRepositoryImpl</code> class, we have been able to read and fetch data from the Room database. Next, we are going to modify the <code>getPets()</code> function in <code>PetsViewModel</code> to <a id="_idIndexMarker408"/>accommodate these new changes. Head<a id="_idIndexMarker409"/> over to the <code>PetsViewModel.kt</code> file and modify the <code>getPets()</code> function to look like the following:</p>
			<pre class="source-code">
private fun getPets() {
    petsUIState.value = PetsUIState(isLoading = true)
    viewModelScope.launch {
        petsRepository.getPets().asResult().collect { result -&gt;
            when (result ) {
                is NetworkResult.Success -&gt; {
                    petsUIState.update {
                        it.copy(isLoading = false, pets = result.data)
                    }
                }
                is NetworkResult.Error -&gt; {
                    petsUIState.update {
                        it.copy(isLoading = false, error = result.error)
                    }
                }
            }
        }
    }
}</pre>			<p>We have made a few minor changes. We have used the <code>asResult()</code> extension function to convert the <code>Flow</code> of pets to a <code>Flow</code> of <code>NetworkResult</code>. This is because we are now returning a <code>Flow</code> of pets from our repository. The rest of the code remains the same as <a id="_idIndexMarker410"/>before. We will get an error since we have not <a id="_idIndexMarker411"/>created the <code>asResult() </code>extension function. Let us create it in our <code>NetworkResult.kt</code> file:</p>
			<pre class="source-code">
fun &lt;T&gt; Flow&lt;T&gt;.asResult(): Flow&lt;NetworkResult&lt;T&gt;&gt; {
    return this
        .map&lt;T, NetworkResult&lt;T&gt;&gt; {
            NetworkResult.Success(it)
        }
        .catch { emit(NetworkResult.Error(it.message.toString())) }
}</pre>			<p>This is an extension function on the <code>Flow</code> class. It maps a <code>Flow</code> of items to the <code>NetworkResult</code> class. We can now head back to our <code>PetsViewModel</code> class and add the extension function imports to resolve the error.</p>
			<p>The last change we need to make is to provide the application context to our Koin instance in the <code>Application</code> class. Head over to the <code>ChapterEightApplication.kt</code> file and modify the <code>startKoin</code> block to the following:</p>
			<pre class="source-code">
startKoin {
    androidContext(applicationContext)
    modules(appModules)
}</pre>			<p>We have provided the application context to our Koin instance. Now, we can run the app. You should see the list of cute cats.</p>
			<div><div><img src="img/B19779_08_01.jpg" alt="Figure 8.1 – Cute cats" width="501" height="1094"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Cute cats</p>
			<p>The app still works as before, but now we are reading items from the Room database. If you turn off your data and Wi-Fi, the app still shows the list of cute cats! Amazing, isn’t it? We have been <a id="_idIndexMarker412"/>able to make the app work offline. One of the benefits of having an architecture in place for our app is that we can change the different layers without necessarily affecting the other layers. We have been able to change the data source from the remote data <a id="_idIndexMarker413"/>source to the local data source without affecting the view layer. This is the power of having a good architecture in place.</p>
			<p>We know how to insert and <a id="_idIndexMarker414"/>read data from our Room database, but what about updating it? In the next section, we will learn how to update the data that is in our Room database. In<a id="_idIndexMarker415"/> the process, we will also learn how to migrate from one<a id="_idIndexMarker416"/> database version to the other using the Room <strong class="bold">automated </strong><strong class="bold">migration</strong> feature.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor107"/>Handling updates and migrations in the Room database</h1>
			<p><code>FavoritePetsScreen</code> doesn’t have any functionality yet. We are going to add the functionality to favorite pets and <a id="_idIndexMarker417"/>update this information in the Room database. To achieve this, we need to do the following:</p>
			<ul>
				<li>Set up a Room schema directory.</li>
				<li>Add a new column to our <code>CatEntity</code> class to store the favorite status of the cat.</li>
				<li>Add a new function to <code>CatDao</code> to update the favorite status of the cat.</li>
				<li>Update our UIs with a favorite icon and, once clicked, update the favorite status of the cat. This means the ViewModel and repository classes will also be updated in the process.</li>
			</ul>
			<p>Let’s get started with the steps:</p>
			<ol>
				<li>Let us start by setting up the schema directory. In our app level <code>build.gradle.kts</code> file, add the following code:<pre class="source-code">
ksp {
    arg("room.schemaLocation", "$projectDir/schemas")
}</pre><p class="list-inset">Do a Gradle sync and then build the project. This generates a <code>schema json</code> file with the name <a id="_idIndexMarker418"/>of the current database version as shown in the following figure:</p></li>			</ol>
			<div><div><img src="img/B19779_08_02.jpg" alt="Figure 8.2 – Room schema directory" width="563" height="470"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Room schema directory</p>
			<p class="list-inset">As shown in the preceding image, you have to switch to the <code>CatEntity</code> interface to store the favorite status of the cat.</p>
			<ol>
				<li value="2">We will add this field to the <code>CatEntity</code> and the <code>Cat</code> data classes. Head over to the <code>CatEntity.kt</code> file and add a new field called <code>isFavorite</code>:<pre class="source-code">
@ColumnInfo(defaultValue = "0")
val isFavorite: Boolean = false</pre><p class="list-inset">This is a Boolean whose default value is <code>false</code>. We have used the <code>@ColumnInfo</code> annotation to<a id="_idIndexMarker419"/> specify the default value of the column in our database, too. We will use this field to store the favorite status of the cat. Ensure you add the <code>val isFavorite: Boolean = false</code> field to the <code>Cat</code> data class, too. We now need to update our <code>CatDao</code> class to be able to update the favorite status of the cat.</p></li>				<li>Let us head over to the <code>CatDao.kt</code> file and add the following functions:<pre class="source-code">
@Update
suspend fun update(catEntity: CatEntity)
@Query("SELECT * FROM Cat WHERE isFavorite = 1")
fun getFavoriteCats(): Flow&lt;List&lt;CatEntity&gt;&gt;</pre><p class="list-inset">We have two functions here. The first function will be used to update the favorite status of the cat. We have used the <code>@Update</code> annotation to tell Room that this function will be used to update the <code>CatEntity</code> class in our database. The second function will be used to get the favorite cats from our database. We have used the <code>@Query</code> annotation to define the query to get the favorite cats from our database. We have used <code>Flow</code> to return the favorite cats from our database. Now, we need to add a migration to our database to add the new column to our database. This ensures that we don’t lose any data when we update our database. <code>CatDatabase</code> to add <code>autoMigration</code> as follows:<pre class="source-code">
@Database(
    entities = [CatEntity::class],
    version = 2,
    autoMigrations = [
        AutoMigration(from = 1, to = 2)
    ]
)</pre><p class="list-inset">We have added the <code>autoMigrations</code> parameter to our database. We have passed a list of <code>AutoMigration</code> objects to the parameter. We have passed the <code>from</code> and <code>to</code> parameters to specify the version of our database. Ensure you add the imports for the <code>AutoMigration</code> class. Notice that we have also increased the <code>version</code> of our database. This is because we have added a new column to our database. Build the project to be able to generate the <code>schema json</code> file. You should see a new schema JSON file with the name of the new database version. Our schema directory should look like the following:</p></li>			</ol>
			<div><div><img src="img/B19779_08_03.jpg" alt="Figure 8.3 – Updated Room schema directory" width="562" height="509"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Updated Room schema directory</p>
			<p class="list-inset">If we open the <code>2.json</code> file, we will notice that the new <code>isFavorite</code> column has been added to our table. That it’s for <a id="_idIndexMarker422"/>automated migration. We are now ready to update our repository to be able to update the favorite status of the cat.</p>
			<ol>
				<li value="5">Let us head over to the <code>PetsRepository.kt</code> file and add the following functions:<pre class="source-code">
suspend fun updatePet(cat: Cat)
suspend fun getFavoritePets(): Flow&lt;List&lt;Cat&gt;&gt;</pre></li>			</ol>
			<p>The <code>updatePet(cat: Cat)</code> and <code>getFavoritePets()</code> functions will be used to update the favorite status <a id="_idIndexMarker423"/>of the cat and get favorite cats.</p>
			<ol>
				<li>Let us add the implementation of the two functions in our <code>PetsRepositoryImpl.kt</code> class:<pre class="source-code">
override suspend fun updatePet(cat: Cat) {
    withContext(dispatcher) {
        catDao.update(CatEntity(
            id = cat.id,
            owner = cat.owner,
            tags = cat.tags,
            createdAt = cat.createdAt,
            updatedAt = cat.updatedAt,
            isFavorite = cat.isFavorite
        ))
    }
}
override suspend fun getFavoritePets(): Flow&lt;List&lt;Cat&gt;&gt; {
    return withContext(dispatcher) {
        catDao.getFavoriteCats()
            .map { petsCached -&gt;
                petsCached.map { catEntity -&gt;
                    Cat(
                        id = catEntity.id,
                        owner = catEntity.owner,
                        tags = catEntity.tags,
                        createdAt = catEntity.createdAt,
                        updatedAt = catEntity.updatedAt,
                        isFavorite = catEntity.isFavorite
                    )
                }
            }
    }
}</pre><p class="list-inset">Here is an explanation of the functions:</p><ul><li>In the <code>updatePet</code> function, we have <a id="_idIndexMarker424"/>used the update method of our <code>CatDao</code> interface to update the favorite status of the cat. We have also used <code>withContext</code> to ensure that the update runs on a background thread. We have created a new <code>CatEntity</code> class from the <code>Cat</code> object that we have passed to the function.</li><li>In the <code>getFavoritePets</code> function, we have used the <code>getFavoriteCats</code> function from our <code>CatDao</code> interface to get the favorite cats from our database. We have also mapped the list of <code>CatEntity</code> to a list of <code>Cat</code>. We then returned a <code>Flow</code> instance type of favorite cats.</li></ul></li>				<li>In the <code>PetsRepositoryImpl.kt</code> file, we need to update the <code>fetchRemotePets</code> and <code>getPets</code> functions<a id="_idIndexMarker425"/> to update the favorite status of the cat as follows:<pre class="source-code">
override suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt; {
    return withContext(dispatcher) {
       catDao.getCats()
           .map { petsCached -&gt;
               petsCached.map { catEntity -&gt;
                   Cat(
                       id = catEntity.id,
                       owner = catEntity.owner,
                       tags = catEntity.tags,
                       createdAt = catEntity.createdAt,
                       updatedAt = catEntity.updatedAt,
                       isFavorite = catEntity.isFavorite
                   )
               }
           }
           .onEach {
               if (it.isEmpty()) {
                   fetchRemotePets()
               }
           }
    }
}
override suspend fun fetchRemotePets() {
    withContext(dispatcher) {
        val response = catsAPI.fetchCats("cute")
        if (response.isSuccessful) {
            response.body()!!.map {
                catDao.insert(CatEntity(
                    id = it.id,
                    owner = it.owner,
                    tags = it.tags,
                    createdAt = it.createdAt,
                    updatedAt = it.updatedAt,
                    isFavorite = it.isFavorite
                ))
            }
        }
    }
}</pre><p class="list-inset">We add the <code>isFavorite</code> parameter to the <code>Cat</code> object when we are mapping the <code>CatEntity</code> class to a <code>Cat</code>. This <a id="_idIndexMarker426"/>will ensure that we have the favorite status of the cat when we are fetching the cats from the remote and local data sources.</p></li>				<li>Let us head over to the <code>PetsViewModel</code> class and add the following variables below the <code>petsUIState</code> variable:<pre class="source-code">
private val _favoritePets = MutableStateFlow&lt;List&lt;Cat&gt;&gt;(emptyList())
val favoritePets: StateFlow&lt;List&lt;Cat&gt;&gt; get() = _favoritePets</pre><p class="list-inset">Here, we have created a private <code>MutableStateFlow</code> of favorite cats and a public <code>StateFlow</code> of favorite cats. We will use the <code>_favoritePets</code> variable to update the favorite cats and the <code>favoritePets</code> variable to observe the favorite cats. This pattern is normally recommended to prevent exposing mutable states to the view layer.</p></li>				<li>Next, let us add these two <a id="_idIndexMarker427"/>functions below the <code>getPets()</code> function in the <code>PetsViewModel</code>:<pre class="source-code">
fun updatePet(cat: Cat) {
    viewModelScope.launch {
        petsRepository.updatePet(cat)
    }
}
fun getFavoritePets() {
    viewModelScope.launch {
        petsRepository.getFavoritePets().collect {
            _favoritePets.value = it
        }
    }
}</pre><p class="list-inset">The <code>updatePet</code> function will be called from the UI to update the favorite status of the cat. The <code>getFavoritePets</code> function will be called from the UI to fetch the favorite cats from our database. We collect the favorite cats from our database and update the <code>_favoritePets</code> variable. With these changes, we are now ready to make changes to our views to be able to favorite a cat and see a list of favorite pets.</p></li>				<li>We will start by adding our favorite icon to the <code>PetListItem</code> composable. Let us head over to the <code>PetList.kt</code> file and update the <code>PetListItem</code> composable to be<a id="_idIndexMarker428"/> the following:<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(
    cat: Cat,
    onPetClicked: (Cat) -&gt; Unit,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
                .clickable {
                    onPetClicked(cat)
                }
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            Row(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
                    .fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                FlowRow(
                    modifier = Modifier
                        .padding(start = 6.dp, end = 6.dp)
                ) {
                    repeat(cat.tags.size) {
                        SuggestionChip(
                            modifier = Modifier
                                .padding(start = 3.dp, end = 3.dp),
                            onClick = { },
                            label = {
                                Text(text = cat.tags[it])
                            }
                        )
                    }
                }
                Icon(
                    modifier = Modifier
                        .clickable {
                            onFavoriteClicked(cat.copy(isFavorite = !cat.isFavorite))
                        },
                    imageVector = if (cat.isFavorite) {
                        Icons.Default.Favorite
                    } else {
                        Icons.Default.FavoriteBorder
                    },
                    contentDescription = "Favorite",
                    tint = if (cat.isFavorite) {
                        Color.Red
                    } else {
                        Color.Gray
                    },
                )
            }
        }
    }
}</pre><p class="list-inset">We have added the <code>Icon</code> composable to the <code>PetListItem</code> composable. We have used the <code>Icons.Default.Favorite</code> icon if the cat is favorited and the <code>Icons.Default.FavoriteBorder</code> icon if the cat is not favorited. We have also used the <code>tint</code> parameter to change the color of the icon depending on the favorite status of the cat. <code>Icon</code> is now inside a <code>Row</code> together with <code>FlowRow</code>, which displays a <a id="_idIndexMarker429"/>list of tags. We have also added the <code>onFavoriteClicked</code> parameter to the <code>PetListItem</code> composable. We have used this parameter to update the favorite status of the cat.</p></li>				<li>Let us update the <code>PetList</code> composable to add a new callback parameter called <code>onFavoriteClicked</code> and pass the parameter to the <code>PetListItem</code> composable:<pre class="source-code">
@Composable
fun PetList(
    onPetClicked: (Cat) -&gt; Unit,
    pets: List&lt;Cat&gt;,
    modifier: Modifier,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    LazyColumn(
        modifier = modifier
    ) {
        items(pets) { pet -&gt;
            PetListItem(
                cat = pet,
                onPetClicked = onPetClicked,
                onFavoriteClicked = onFavoriteClicked
            )
        }
    }
}</pre></li>				<li>Next, we will add the <code>onFavoriteClicked</code> callback <a id="_idIndexMarker430"/>as a parameter to the <code>PetsScreenContent</code>:<pre class="source-code">
@Composable
fun PetsScreenContent(
    modifier: Modifier,
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
    petsUIState: PetsUIState,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    // code
    }</pre></li>				<li>We can now pass the parameter to the <code>PetList</code> composable:<pre class="source-code">
PetList(
    onPetClicked = onPetClicked,
    pets = petsUIState.pets,
    modifier = Modifier
    .fillMaxWidth(),
    onFavoriteClicked = onFavoriteClicked
)</pre></li>				<li>Let us update the <code>PetAndDetails</code> composable<a id="_idIndexMarker431"/> to add the <code>onFavoriteClicked</code> parameter:<pre class="source-code">
@Composable
fun PetListAndDetails(
    pets: List&lt;Cat&gt;,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    // code
    }</pre></li>				<li>We can now pass the parameter to the <code>PetList</code> composable:<pre class="source-code">
PetList(
    onPetClicked = {
    currentPet = it
    },
    pets = pets,
    modifier = Modifier
    .fillMaxWidth()
    .weight(1f),
    onFavoriteClicked = onFavoriteClicked
)</pre></li>				<li>Back in the <code>PetsScreenContent.kt</code> file, we need to pass the <code>onFavoriteClicked</code> parameter<a id="_idIndexMarker432"/> to the <code>PetListAndDetails</code> composable:<pre class="source-code">
PetListAndDetails(
    pets = petsUIState.pets,
    onFavoriteClicked = onFavoriteClicked
)</pre><p class="list-inset">The final <code>PetScreenContent.kt</code> file with all the changes we have made so far should look like this:</p></li>			</ol>
			<div><div><img src="img/B19779_08_04.jpg" alt="Figure 8.4 – Updated PetscreenContent" width="540" height="1014"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Updated PetscreenContent</p>
			<ol>
				<li value="12">Next, in the <code>PetsScreen</code> composable, which<a id="_idIndexMarker433"/> is in the <code>PetsScreen.kt</code> file, we need to add the <code>onFavoriteClicked</code> parameter to the <code>PetsScreenContent</code> composable:<pre class="source-code">
PetsScreenContent(
    modifier = Modifier
        .fillMaxSize(),
    onPetClicked = onPetClicked,
    contentType = contentType,
    petsUIState = petsUIState,
    onFavoriteClicked = {
        petsViewModel.updatePet(it)
    }
)</pre><p class="list-inset">We have passed the <code>onFavoriteClicked</code> callback to the <code>PetsScreenContent</code> composable. We have called the <code>updatePet</code> method of our <code>PetsViewModel</code> class with<a id="_idIndexMarker434"/> the updated cat object. Let us run the app; it now has a new favorite icon. If we click on the icon, the icon changes to a filled heart icon with a red color:</p></li>			</ol>
			<div><div><img src="img/B19779_08_05.jpg" alt="Figure 8.5 – Cute cats with favorite" width="503" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Cute cats with favorite</p>
			<ol>
				<li value="13">Lastly, we are<a id="_idIndexMarker435"/> going to update <code>FavoritePetsScreen</code> to display a list of favorite cats. Let us head over to the <code>FavoritePetsScreen.kt</code> file and update the <code>FavoritePetsScreen</code> composable to be the following:<pre class="source-code">
@Composable
fun FavoritePetsScreen(
    onPetClicked: (Cat) -&gt; Unit
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    LaunchedEffect(Unit) {
        petsViewModel.getFavoritePets()
    }
    val pets by petsViewModel.favoritePets.collectAsStateWithLifecycle()
    if (pets.isEmpty()) {
        Column(
            modifier = Modifier
                .fillMaxSize(),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(text = "No favorite pets")
        }
    } else {
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
        ) {
            items(pets) { pet -&gt;
                PetListItem(
                    cat = pet,
                    onPetClicked = onPetClicked,
                    onFavoriteClicked = {
                        petsViewModel.updatePet(it)
                    }
                )
            }
        }
    }
}</pre><p class="list-inset">Here is an explanation<a id="_idIndexMarker436"/> of the changes:</p><ul><li>We have added a new parameter, <code>onPetClicked</code> to the <code>FavoritePetsScreen</code> composable. We will use this parameter to navigate to the <code>PetDetailsScreen</code> composable.</li><li>We have created a new instance of our <code>PetsViewModel</code> class using the <code>koinViewModel()</code> method.</li><li>We have called the <code>getFavoritePets</code> function from our <code>PetsViewModel</code> class to get the favorite cats from our database. We used <code>LaunchedEffect</code> to call this method when the composable was first launched. This is to ensure that we do not call the function every time the composable recomposes.</li><li>We have a new variable called <code>pets</code>, which is a <code>StateFlow</code> of favorite cats. We have used the <code>collectAsStateWithLifecycle</code> method to collect the favorite cats from our database. This method is lifecycle aware and hence it will only collect the favorite cats when the composable is active.</li><li>We have added a check to see if the list of favorite cats is empty. If it is empty, we display a message<a id="_idIndexMarker437"/> to the user. If it is not empty, we display a list of favorite cats.</li></ul></li>				<li>We need to update the <code>AppNavigation.kt</code> file to pass the <code>onPetClicked</code> callback to the <code>FavoritePetsScreen</code> composable:<pre class="source-code">
FavoritePetsScreen(
    onPetClicked = { cat -&gt;
        navHostController.navigate(
            "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
        )
    }
)</pre><p class="list-inset">This logic is like what we had in the <code>PetsScreen</code> and it handles navigation to <code>PetDetailsScreen</code> when we are in <code>FavoritePetsScreen</code>. Build and run the app. Tap the favorite icon on the bottom bar and you should see a list of your favorite cute cats. If you tap the favorite icon, the cat is immediately removed from the list of favorite cats. This is because the list of favorite cats is a <code>Flow</code> and every time Room updates the data, they are immediately emitted to the view layer.</p></li>			</ol>
			<div><div><img src="img/B19779_08_06.jpg" alt="Figure 8.6 – Favorite Pets Screen" width="505" height="1095"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Favorite Pets Screen</p>
			<p>We have been able to add the functionality to favorite cats and update this information in the Room database. We <a id="_idIndexMarker438"/>have also been able to handle updates and migrations in the Room database. In the next section, we will see how to use WorkManager to schedule background tasks. In this case, we will use WorkManager to fetch the cats from the remote data source and save them to our database. This improves our first offline experience since we will always have the latest data in our database.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor108"/>Using WorkManager to schedule background tasks</h1>
			<p>WorkManager is a Jetpack library<a id="_idIndexMarker439"/> that is best suited for performing long-running tasks in the background. It ensures that background tasks are<a id="_idIndexMarker440"/> completed even when your app restarts or the phone restarts. With WorkManager, you can either schedule one-time jobs or recurring jobs.</p>
			<p>We will start by adding the WorkManager dependency to our project. Follow these steps:</p>
			<ol>
				<li>Let us head over to the <code>libs.versions.toml</code> file and define the work version in our <code>versions</code> section as follows:<pre class="source-code">
work = "2.8.1"</pre></li>				<li>In the libraries section, add the following dependencies:<pre class="source-code">
work-runtime = { module = "androidx.work:work-runtime-ktx", version.ref = "work" }
workmanager-koin = { module = "io.insert-koin:koin-androidx-workmanager", version.ref = "koin" }</pre><p class="list-inset">Here, we have two dependencies: the <code>work-runtime-ktx</code> dependency, which is the core dependency for WorkManager, and the <code>koin-androidx-workmanager</code> dependency, which is used to integrate WorkManager with Koin. Sync the project for the changes to be added.</p></li>				<li>Next, we need to add the dependencies to the app-level <code>build.gradle.kts</code> file:<pre class="source-code">
implementation(libs.work.runtime)
implementation(libs.workmanager.koin)</pre></li>				<li>Do a Gradle sync to add these dependencies to our project.</li>
			</ol>
			<p>We are now ready to start using WorkManager in our project. We will use WorkManager to fetch the cats from the remote data source and save them to our database. We will use the <code>OneTimeWorkRequest</code> class to schedule a one-time job to fetch the cats from the remote data source and save them to our database. Let’s get started with the <a id="_idIndexMarker441"/>steps:</p>
			<ol>
				<li>Let us create a new package named <code>workers</code> and create a new file inside it called <code>PetsSyncWorker.kt</code> and add the following code:<pre class="source-code">
class PetsSyncWorker(
    appContext: Context,
    workerParams: WorkerParameters,
    private val  petsRepository: PetsRepository
): CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result {
        return try {
            petsRepository.fetchRemotePets()
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
}</pre><p class="list-inset">In the preceding code block, we have created a class that implements the <code>CoroutineWorker</code> class. We<a id="_idIndexMarker442"/> implement this class when we want to perform a long-running task in the background. It uses coroutines to perform long-running tasks. We have passed the <code>appContext</code> and <code>workerParams</code> parameters to the constructor of the class. We have also passed the <code>petsRepository</code> parameter to the constructor of the class. We have overridden the <code>doWork</code> method, which is a <code>suspend</code> function that will be called when the work is scheduled. We have called <code>fetchRemotePets</code> from <code>PetsRepository</code> to fetch the cats from the remote data source and save them to our database. We are also returning <code>Result.success()</code> if the work is successful and <code>Result.failure()</code> if the work fails.</p></li>				<li>Next, let us create an instance of <code>PetsSyncWorker</code> in our <code>Module.kt</code> file:<pre class="source-code">
worker { PetsSyncWorker(get(), get(), get()) }</pre><p class="list-inset">We are using the <code>worker</code> Koin DSL to create an instance of <code>PetsSyncWorker</code>. This is from the<a id="_idIndexMarker443"/> Koin WorkManager library that we just added. We have passed the <code>appContext</code>, <code>workerParams</code>, and <code>petsRepository</code> parameters <a id="_idIndexMarker444"/>to the constructor of <code>PetsSyncWorker</code>.</p></li>				<li>Next, let us add this function in our <code>MainActivity.kt</code> file:<pre class="source-code">
private fun startPetsSync() {
    val syncPetsWorkRequest = OneTimeWorkRequestBuilder&lt;PetsSyncWorker&gt;()
        .setConstraints(
            Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .setRequiresBatteryNotLow(true)
                .build()
        )
        .build()
    WorkManager.getInstance(applicationContext).enqueueUniqueWork(
        "PetsSyncWorker",
        ExistingWorkPolicy.KEEP,
        syncPetsWorkRequest
    )
}</pre><p class="list-inset">In the preceding code, we created a new <code>OneTimeWorkRequest</code> using <code>PetSyncWorker</code>. We have also set some constraints o<a id="_idTextAnchor109"/>n our work request. We have set the network type to <code>NetworkType.CONNECTED</code> to ensure that the work request is only executed when the device is connected to the internet. We also have other network types, which are as follows:</p><ul><li><code>NOT_REQUIRED</code>: For this type, a network is not required. This is useful for tasks that do not <a id="_idIndexMarker445"/>need any internet connection to work.</li><li><code>UNMETERED</code>: An unmetered <a id="_idIndexMarker446"/>network connection such as Wi-Fi is required for this type of network. This is suitable for tasks that involve large data transfers.</li><li><code>METERED</code>: A metered network connection is required for this type of network. Tasks that require a significant amount of data might be deferred when the device is on a metered connection to avoid unnecessary costs.</li><li><code>NOT_ROAMING</code>: For this type of work, a non-roaming connection is required. This is relevant for tasks that might incur additional costs when executed when the device is roaming.</li></ul><p class="list-inset">We have also set the <code>BatteryNotLow constraint</code> to <code>true</code> to ensure that the work request is only executed when the battery is not low. We then used <code>WorkManager.getInstance(applicationContext)</code> to get an instance of the WorkManager and then called the <code>enqueueUniqueWork</code> method to enqueue our work request. We have passed the name of our work request, <code>ExistingWorkPolicy</code>, and the work request to the <code>enqueueUniqueWork</code> method. <code>ExistingWorkPolicy</code> is used to specify what should happen if there is already a work request with the same name. We have used <code>ExistingWorkPolicy.KEEP</code> to ensure that the work request is not replaced if there is already a work request with the same name. The following are other available policies:</p><ul><li><code>REPLACE</code>: This cancels existing work with the same unique name and enqueues the new work. This is suitable when we want only the latest version of the work to be<a id="_idIndexMarker447"/> executed, discarding previous instances.</li><li><code>APPEND</code>: Enqueues the <a id="_idIndexMarker448"/>new work even if there is existing work with the same unique name. Both new and existing work will be executed independently. This is appropriate when we want multiple instances of the same work to coexist.</li></ul><p class="list-inset">We are now ready to start our work request. We will start the work request in the <code>onCreate</code> method of <code>MainActivity</code>.</p></li>				<li>In the <code>MainActivity.kt</code> file, add the following code in the <code>onCreate</code> method:<pre class="source-code">
startPetsSync()</pre><p class="list-inset">Since we are using Koin, we need to disable the default WorkManager initialization in our app manifest.</p></li>				<li>Let us head over to the <code>AndroidManifest.xml</code> file and add the following code inside the application tag:<pre class="source-code">
&lt;provider
    android:name="androidx.startup.InitializationProvider"
    android:authorities="${applicationId}.androidx-startup"
    android:exported="false"
    tools:node="merge"&gt;
    &lt;!-- Removing WorkManager Default Initializer--&gt;
    &lt;meta-data
        android:name="androidx.work.WorkManagerInitializer"
        android:value="androidx.startup"
        tools:node="remove" /&gt;
&lt;/provider&gt;</pre><p class="list-inset">Adding the preceding <a id="_idIndexMarker449"/>code prevents WorkManager <a id="_idIndexMarker450"/>from being initialized automatically. Not doing this causes an app to crash once you set up Koin initialization. The crash is caused by a conflict between Koin’s dependency injection and WorkManager’s default initialization. Lastly, we have also removed App Startup (<a href="https://developer.android.com/topic/libraries/app-startup">https://developer.android.com/topic/libraries/app-startup</a>), which is used internally within WorkManager from WorkManager 2.6.</p></li>				<li>To set up a custom WorkManager instance, head over to the <code>ChapterEightApplication.kt</code> file and add the following code inside the <code>startKoin</code> block:<pre class="source-code">
workManagerFactory()</pre></li>				<li>Build and run the app, and nothing changes. However, we have scheduled a background task to fetch the cats from the remote data source and save them to our database.</li>
			</ol>
			<div><div><img src="img/B19779_08_07.jpg" alt="Figure 8.7 – Cute cats" width="499" height="1095"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Cute cats</p>
			<p>We have <a id="_idIndexMarker451"/>created our <code>PetsSyncWorker</code> class and learned how to do <a id="_idIndexMarker452"/>work in the background. In the next section, we are going to write tests for our <code>PetsSyncWorker</code> class.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor110"/>Testing your workers</h1>
			<p>Testing the code is very important. It <a id="_idIndexMarker453"/>ensures that our code works as expected and it also helps us to catch bugs early. We will be writing tests for our workers in this section. To test our workers, we first need to set up WorkManager testing dependencies with the following steps:</p>
			<ol>
				<li>Let us head over to the <code>libs.versions.toml</code> file and add the following dependency to the <code>libraries</code> section:<pre class="source-code">
work-testing = { module = "androidx.work:work-testing", version.ref = "work" }</pre><p class="list-inset">Sync your project. This will add the <code>work-testing</code> artifact that helps in testing workers to our project.</p></li>				<li>Next, we need to add the dependency to our app level <code>build.gradle.kts</code> file:<pre class="source-code">
androidTestImplementation(libs.work.testing)</pre><p class="list-inset">We have used <code>androidTestImplementation</code> because we will be writing our tests in the <code>androidTest</code> folder. Do a Gradle sync to add the dependency to our project. We are now ready to start writing our tests.</p></li>			</ol>
			<p>Since our <code>PetsSyncWorker</code> class requires some dependencies, we will create a test rule that provides the Koin dependencies that we need. Let us head over to the <code>androidTest</code> folder, create a new file called <code>KoinTestRule.kt</code>, and add the following code:</p>
			<pre class="source-code">
class KoinTestRule: TestRule {
    override fun apply(base: Statement?, description: Description?): Statement {
        return object : Statement() {
            override fun evaluate() {
                stopKoin()
                startKoin {
                    androidLogger(Level.ERROR)
                    androidContext(ApplicationProvider.getApplicationContext())
                    modules(appModules)
                }
            }
        }
    }
}</pre>			<p><code>KoinTestRule</code> implements the <code>TestRule</code> interface. We have used this rule to provide the Koin dependencies that we need in our tests. We have used the <code>startKoin</code> method to provide the<a id="_idIndexMarker454"/> Koin dependencies that we need. We have used the <code>androidContext(ApplicationProvider.getApplicationContext())</code> method to get the application context. We have also used the <code>modules(appModules)</code> method to provide the Koin modules that we need. Now, we are ready to start writing our tests. Let us create a new file called <code>PetsSyncWorkerTest.kt</code> and add the following code:</p>
			<pre class="source-code">
@RunWith(AndroidJUnit4::class)
class PetsSyncWorkerTest {
    @get:Rule
    val koinTestRule = KoinTestRule()
    @Before
    fun setUp() {
        val config = Configuration.Builder()
            .setMinimumLoggingLevel(Log.DEBUG)
            .setExecutor(SynchronousExecutor())
            .build()
        // Initialize WorkManager for instrumentation tests.
        WorkManagerTestInitHelper.initializeTestWorkManager(
            ApplicationProvider.getApplicationContext(),
            config
        )
    }
}</pre>			<p>We have created a test class called <code>PetsSyncWorkerTest</code>. We have annotated the class with the <code>@RunWith(AndroidJUnit4::class)</code> annotation. We have also created a <code>KoinTestRule</code> instance and<a id="_idIndexMarker455"/> annotated it with the <code>@get:Rule</code> annotation to provide the <code>KoinTestRule</code> to our test class. We have also created a <code>setup</code> function and annotated it with the <code>@Before</code> annotation. This function will be executed before each test. We are using the <code>WorkManagerTestInitHelper</code> class to initialize WorkManager for instrumentation tests. We are using the <code>SynchronousExecutor</code> class to ensure that the work is executed synchronously. This is to ensure that our tests are deterministic. We are now ready to start writing our tests.</p>
			<p>Follow these steps to create our test:</p>
			<ol>
				<li>We will start by creating a test function that will test the functionality of our worker. Add the following code to the <code>PetsSyncWorkerTest.kt</code> file below the <code>setup</code> function:<pre class="source-code">
@Test
fun testPetsSyncWorker() {
}</pre><p class="list-inset">This is an empty function <a id="_idIndexMarker456"/>annotated with the <code>@</code><code>Test</code> annotation.</p></li>				<li>Create a work request as follows:<pre class="source-code">
val syncPetsWorkRequest = OneTimeWorkRequestBuilder&lt;PetsSyncWorker&gt;()
    .setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()
    )
    .build()</pre><p class="list-inset">In the preceding code, we have created a one-time request using our <code>PetsSyncWorker</code> class. We have also set the constraints to our work request. We have set the network type to <code>NetworkType.CONNECTED</code> to ensure that the work request is only executed when the device is connected to the internet. We have also set the <code>BatteryNotLow</code> constraint to <code>true</code> to ensure that the work request is only executed when the battery is not low.</p></li>				<li>Next, set up the test drivers:<pre class="source-code">
val workManager = WorkManager.getInstance(ApplicationProvider.getApplicationContext())
val testDriver =
    WorkManagerTestInitHelper.getTestDriver(ApplicationProvider.getApplicationContext())!!</pre><p class="list-inset">Here, we have set up the test<a id="_idIndexMarker457"/> drivers that help us simulate conditions needed for our tests. For example, it simulates that constraints are met.</p></li>				<li>Enqueue the work request:<pre class="source-code">
workManager.enqueueUniqueWork(
    "PetsSyncWorker",
    ExistingWorkPolicy.KEEP,
    syncPetsWorkRequest).result.get()</pre><p class="list-inset">We have used the <code>enqueueUniqueWork</code> method to enqueue our work request. We have passed the name of our work request, <code>ExistingWorkPolicy</code>, and the work request to the <code>enqueueUniqueWork</code> method. We have used <code>ExistingWorkPolicy.KEEP</code> to ensure that the work request is not replaced if there is already a work request with the same name. We have also used the <code>result.get()</code> method to get the result of our work request.</p></li>				<li>Get the information about our work request using the <code>WorkInfo</code> class:<pre class="source-code">
val workInfo = workManager.getWorkInfoById(syncPetsWorkRequest.id).get()</pre><p class="list-inset">We are getting <code>WorkInfo</code> for our work request. We have used the <code>getWorkInfoById</code> method to get <code>WorkInfo</code> for our work request. We are using the <code>result.get()</code> method to get the result of our work request.</p></li>				<li>Next, let us get the worker state and assert that our work is enqueued:<pre class="source-code">
assertEquals(WorkInfo.State.ENQUEUED, workInfo.state)</pre><p class="list-inset">We have used the <code>assertEquals</code> method to assert that our work is enqueued. We have <a id="_idIndexMarker458"/>used the <code>WorkInfo.State.ENQUEUED</code> to check if our work is enqueued.</p></li>				<li>Next, let us simulate our constraints being met by using the <code>testDriver</code> instance that we created earlier:<pre class="source-code">
testDriver.setAllConstraintsMet(syncPetsWorkRequest.id)</pre><p class="list-inset">We use <code>testDriver</code> to simulate that the constraints are met. We have used the <code>setAllConstraintsMet function</code> to simulate that the constraints are met. We have passed the <code>id</code> of our work request to the <code>setAllConstraintsMet</code> method. The work request <code>id</code> has an instance type of <code>Universally Unique </code><code>Identifier (UUID)</code>.</p></li>				<li>Lastly, let us get the output and state of our workers:<pre class="source-code">
val postRequirementWorkInfo =
    workManager.getWorkInfoById(syncPetsWorkRequest.id).get()
assertEquals(WorkInfo.State.RUNNING, postRequirementWorkInfo.state)</pre><p class="list-inset">This is the final step of our test. We have used the <code>getWorkInfoById</code> method to get the <code>WorkInfo</code> of our work request. We have used the <code>result.get()</code> method to get the result of our work request. We have used <code>WorkInfo.State.RUNNING</code> to check if our work is running. Our final test function should look like the following:</p></li>			</ol>
			<div><div><img src="img/B19779_08_08.jpg" alt="Figure 8.8 – PetsSyncWorker test" width="835" height="812"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – PetsSyncWorker test</p>
			<ol>
				<li value="9">Click the green run icon on the left of<a id="_idIndexMarker459"/> our test to run the test. The test runs and it’s all green! Our test passes, as seen in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19779_08_09.jpg" alt="Figure 8.9 – Test results" width="890" height="240"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Test results</p>
			<p>Making all these<a id="_idIndexMarker460"/> tests work together is amazing work.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor111"/>Summary</h1>
			<p>In this chapter, we learned how to save data to a local database, Room, which is part of the Jetpack libraries. We also saved items and read from the Room database. In the process, we also learned how to update items in the Room database and how to handle automated migrations in our database. Additionally, we learned how to do long-running operations using WorkManager, its best practices, and how to write tests for our workers.</p>
			<p>In the next chapter, we will learn about runtime permissions and how to request them in our app.</p>
		</div>
	</div></div></body></html>