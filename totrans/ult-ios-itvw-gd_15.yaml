- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design Patterns to Solve Complex Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed different aspects of iOS development. We
    covered UIKit, Swift, reactive programming, SwiftUI, Core Data, and many more.
    These building blocks help us achieve our next level – design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Design patterns are like tools. Each one of them solves a different problem
    or a different need, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to change the behavior of a particular instance? We can use **dependency**
    **injection** (**DI**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have a complex state to manage? We can use **Model-View-ViewModel** (**MVVM**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to define communication between objects? We can use delegation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more we expand our toolbox with design patterns, the more problems we can
    solve. We should remember that design patterns alone are not our goal – they are
    tools to accomplish our tasks. We should remember that we’ll have to pick a particular
    design pattern or talk about it in our interviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover some commonly used design patterns in iOS development.
    We’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss **Model-View-Controller** (**MVC**) and MVVM, including some interview
    questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decouple our code using DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve communication with delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share a state with Singletons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve performance using Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most commonly asked topics in interviews is the first on the list
    – MVC and MVVM. So, let’s dive right into it.
  prefs: []
  type: TYPE_NORMAL
- en: Building a UI with MVC/MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several known design patterns can help us build stable and complex screens,
    but MVC and MVVM are the most common and famous patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Like many development areas, the topic of MVC and MVVM can be subject to personal
    preferences and opinions and may not always align with practical considerations.
    We always need to be careful with that, especially when interviewing for a job.
    Let me explain what I mean.
  prefs: []
  type: TYPE_NORMAL
- en: Solving different problems with MVC and MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I want to go over several sentences I suggest avoiding when having a professional
    discussion with an interviewer or even colleagues:'
  prefs: []
  type: TYPE_NORMAL
- en: “My app is built with MVVM architecture.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “MVC is antique and a horrible architecture. I never use it.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “This is not how MVVM works. Let me show you.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember what I’ve said multiple times throughout the book – we should avoid
    dichotomous thinking as developers. MVC and MVVM solve different problems, and
    we should think of both patterns as different solutions to various issues.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can use different design patterns in the same app, in the same feature,
    or even on the same screen.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there is more than one way to implement MVC and MVVM. What’s more
    important is to follow the different principles and explain them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the more straightforward pattern – MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Learning MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVC stands for Model-View-Controller. When the iOS development era started,
    Apple used MVC to demonstrate best practices for building UI screens, and it was
    the primary design pattern for building apps.
  prefs: []
  type: TYPE_NORMAL
- en: The basic principle of MVC is a separation between the *View,* which is what
    the user sees and interacts with, and the *Model,* which represents the business
    logic and the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: In MVC, there’s no direct connection between the View and the Model, and all
    the data flow is done using the *Controller*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at a classic MVC pattern (*Figure 11**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – MVC design pattern](img/Figure_11.01_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – MVC design pattern
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11**.1*, we can see that the View and the Model communicate with
    each other using the controller. This separation allows us to reuse each component
    in different use cases across our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we implement MVC in the iOS world? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: The View represents the UI displayed on the screen. Therefore, we
    typically implement it with one of the UIKit view elements, such as buttons, labels,
    and text fields (we’ll talk about SwiftUI in a second).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: The Model is our data and business logic. We implement it using
    data structures, persistent storage, different algorithms, and network requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: The controller in iOS development is mostly **UIViewController**
    and its different subclasses, such as **UITableViewController** and **UIAlertController**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing to notice is how Apple implements the MVC pattern in iOS. `UIViewController`
    is not really a pure controller like we saw in *Figure 11**.1*. It has a view
    of its own and is responsible for user interaction. In a way, `UIViewController`
    is part of the UI, not just a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Things are a little different with SwiftUI – the SwiftUI pattern resembles MVVM
    rather than MVC. We'll examine this more closely when we get to MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to implement MVC in iOS. Here is the Model part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Person` represents the data structure and has a logic function (`canVote()`).
    It doesn’t have any reference to the view or even to the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `PersonView` class has nothing to do with logic and focuses
    purely on UI presentation. This allows it to be reusable with other logic and
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `PersonView` has a `configure(with person:Person)` function. This
    common practice helps us load the view with a specific model. We can move this
    code to an extension and increase the code separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move on to the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`PersonViewController` has a reference to both `Person` and `PersonView` and
    is responsible for linking between them and loading the view with data from `Person`.
    Notice that `PersonView` and `Person` don’t have a reference to each other – `PersonViewController`
    acts as the controller and sets up what is needed in the `viewDidLoad` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we discussed how MVC improves our code to make it reusable, as we can
    reuse the Model and View components. In iOS development, we should also consider
    MVC as a self-contained unit we can reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can have a screen that is built upon two embedded view controllers,
    each one of which is an MVC unit. Look at *Figure 11**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Two embedded MVC units](img/Figure_11.02_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Two embedded MVC units
  prefs: []
  type: TYPE_NORMAL
- en: An MVC unit doesn’t have to be a whole screen – this approach can help us reuse
    part of the screen and extend our project’s flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern is excellent for simple screens that don’t require complex state
    and data manipulation. In this case, we must move to a more complex pattern –
    MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I believe this is a critical checkpoint in the chapter (and maybe even in the
    whole book). Developers tend to be attached to a specific pattern, especially
    related to the UI. MVVM is not “better” than “MVC” and vice versa. They are both
    patterns for different use cases, which is crucial to explain in an interview.
    We should never be tied to a specific technology or pattern, especially not in
    interviews.
  prefs: []
  type: TYPE_NORMAL
- en: We said that MVC is not the best pattern for complex state and data management.
    But why?
  prefs: []
  type: TYPE_NORMAL
- en: Complex screens require state management – to show/hide certain UI elements,
    update text, change colors, and present dynamic information on the screen. All
    of this can make our view controller bloated.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why iOS developers used to rely on MVC in the first era of the App Store
    but quickly moved on to a more suitable pattern – MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM stands for Model-View-ViewModel. The idea is that the View is connected
    to the Model using a **ViewModel** – another component that can help us manage
    the state and manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at *Figure 11**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The MVVM design pattern](img/Figure_11.03_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The MVVM design pattern
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11**.3*, we can see that the ViewModel stands between the View and
    Model like the controller in the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: But in MVVM, the responsibilities of the different components are much more
    transparent and intuiitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the different components now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: The View is responsible for presenting the information and responding
    to user interaction. It’s the only component with access to the UIKit framework
    (we’ll talk about SwiftUI shortly), which is a significant difference from the
    MVC pattern we discussed earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**: The ViewModel handles the state and prepares data for presentation.
    Also, the ViewModel decides on user interaction and moves the requests forward
    to the Model layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: The Model layer is the actual business logic and is responsible
    for accessing the persistent store and performing network requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the View and the ViewModel communicate using **data binding**, which
    connects the input field to the corresponding data model. In fact, the ViewModel
    doesn’t even have a reference to the view – the view observes changes in the ViewModel
    and refreshes itself accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where SwiftUI and Combine come in handy. In SwiftUI, for example, the
    ViewModel is usually derived from the `@ObservableObject` class with `@``Published`
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Forgot about SwiftUI and Combine?
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to return to [*Chapter 8*](B18653_08.xhtml#_idTextAnchor249)
    and refresh your memory regarding SwiftUI and Combine. It looks like Apple took
    a close look at how developers develop screens and built a dedicated framework
    for MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see MVVM in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Going over some code examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s see a code example of the MVVM design pattern. In our example, we have
    a screen with a label that shows the status of a loading request (**Loading…**,
    **Ready**, or **Error**). The label is bound to a specific ViewModel that communicates
    with the Model and updates its View.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let’s observe the status change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code example is a bit long, yet simple to understand. The ViewModel observes
    a network request-response and updates its values using a Combine pattern. The
    combine stream starts with the network service and forwards the results to the
    `status` property, which can be observed by the view. Notice that the ViewModel
    doesn’t deal with any UI elements – that’s the View’s job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `StatusLabel` class has a direct reference to the ViewModel, and it observes
    changes to refresh itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is to connect the view with the ViewModel, and that’s
    the only job of the view controller in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewController` injects the ViewModel into the view and `NetworkService` into
    the ViewModel. Imagine doing that with MVC, with several components and complex
    data manipulation; you’d get 3,000 lines of code with a view controller.'
  prefs: []
  type: TYPE_NORMAL
- en: MVVM is a modern design pattern compared to MVC and can help us separate our
    concerns more efficiently and handle much more complex state management and data
    manipulation. We can create a ViewModel for each view that we think needs one
    and organize our presentation logic however we want.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s move on to some questions about MVC/MVVM design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: “How would you implement navigation in an MVVM architecture, considering that
    the ViewModel should not have knowledge of the View?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Learning MVVM is easy in theory. Binding ViewModel properties to UI elements
    is simple, but applying it to *real-world problems is the real challenge*. One
    of the most common real-world problems in iOS and mobile is navigation combined
    with state and logic.
  prefs: []
  type: TYPE_NORMAL
- en: What is the solution to the navigation problem when the ViewModel lacks a direct
    reference to the View and the View cannot handle navigation on its own?
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When discussing navigation, we need to decide on three things:'
  prefs: []
  type: TYPE_NORMAL
- en: How to *trigger* the navigation action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to *choose* where to navigate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to *navigate*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are three different responsibilities that can be separated into various
    components. For example, we can decide that the ViewModel can trigger the navigation
    action and also choose where to go, while the View can handle the navigation action
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to decide that the ViewModel triggers the navigation. Still,
    where to go can be part of the View or another object explicitly dedicated to
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at *Figure 11**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Simple navigation pattern using MVVM](img/Figure_11.04_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Simple navigation pattern using MVVM
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11**.4*, the ViewModel triggers the navigations and notifies the
    View using a delegate pattern or **Combine**. The View then asks the navigation
    controller to navigate to a specific destination, which is part of the reason
    view controllers have a reference to the navigation controller. This simple navigation
    pattern puts the navigation responsibility on the View.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to implement that in code. This is what the ViewModel looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the ViewModel has a `didTapButton()` method and decides to send
    a message using `navigationSubject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go over the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The ViewModel navigation subject triggers the navigation according to its own
    logic, which in this case is tapping the button.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewController` observes the ViewModel navigation publishers and pushes `detailsViewcontroller`
    using the navigation controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, this pattern is simple and puts a lot of responsibility on the
    view controller. If we want to separate our code, we can delegate the navigation
    responsibility to another class (**Coordinator**). See *Figure 11**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – MVVM and coordinator pattern](img/Figure_11.05_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – MVVM and coordinator pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'In the coordinator pattern, the ViewModel notifies the coordinator about a
    navigation intent, which pushes a new screen. See how the ViewModel looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The ViewModel sends a message with the button tap, and the coordinator can
    subscribe to it and respond. This is what the coordinator looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the coordinator creates the ViewModel and the view, then wires
    everything together. In the previous example, the view controller observed the
    ViewModel events and pushed a new view controller. Similarly, in this case, the
    coordinator observes `didTapButtonPublisher` and decides to push a new view controller
    – `DetailsViewController`. The view and ViewModel are unaware of this transition
    as it is managed entirely by the coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: In general, both ways have their pros and cons. Using a coordinator is a powerful
    and complex pattern. Still, there is little overhead for simpler cases, where
    we can connect the navigation controller to the view controller. What’s important
    is to understand the navigation principles and balance the responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: “Why is the MVVM architecture considered good for testability in iOS app development?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: When designing code, tests have become increasingly important in recent years.
    It’s not just about being able to test the code but also about writing high-quality
    code that is well structured and easy to maintain. With this in mind, the interviewer
    wants us to consider the importance of writing testable code in our response.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM design pattern is suitable for testing because it separates the concerns
    in an easy way. The state and the data manipulation code, which is the most important
    part we want to test, is part of the ViewModel. We can set up the ViewModel easily
    without handling the UI and simply test it by mocking the View.
  prefs: []
  type: TYPE_NORMAL
- en: We can also test an MVC unit, but since the state management is part of the
    View Controller or the View, it is more complex than testing an MVVM pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example of how to test a ViewModel. Let’s start with defining
    a standard ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a ViewModel that handles a tap button and updates a label. Notice
    that there is no UIKit-related code here, so it should be reasonably easy to test.
    Now, let’s see the test itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `testLabelValue()` function observes the ViewModel’s `labelValue` to see
    whether it equals `"Ready"` when tapping the button. We did all that without setting
    up the View, which only handles UI logic in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling with Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is a powerful pattern that helps us to create modular and testable code.
    It’s another tool in our toolbox that can help us make our code flexible and decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to implement DI in iOS, which are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Using constructor injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the most common form of DI in iOS. In constructor injection, dependencies
    are passed into an object through its initializer. For example, if we have a view
    controller that depends on a data manager, we can inject the data manager into
    the view controller’s initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we created a custom `init()` function and a
    private variable to hold the injected data manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage of constructor DI is that we have a clear interface with
    the required dependencies for the class, as we must pass them in our `init()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying things with setter injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In setter injection, setter methods pass dependencies into the object. The object
    declares its dependencies as public properties, and the DI framework sets those
    properties with the appropriate dependencies. Setter injection is less common
    than constructor injection but can be helpful when changing the object’s dependencies
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example of setter injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we haven’t changed the `init` function of the view controller.
    After we created the view controller, we passed `dataManager` using the built-in
    setter property method.
  prefs: []
  type: TYPE_NORMAL
- en: The primary advantage of using setter injection is simplicity; we don’t have
    to modify the `init` function and decoupling. On the other hand, this approach
    is not suitable for the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Using pure functions with method injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In method injection, dependencies are passed into an object’s methods as parameters.
    This is similar to constructor injection but allows for more fine-grained control
    over when and how dependencies are injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fetchData()` method is an example of a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we have the same view controller and data manager, but
    this time we don’t have an instance variable for the data manager. We pass the
    data manager as part of the `fetchData` method and make the function pure.
  prefs: []
  type: TYPE_NORMAL
- en: What is a pure function?
  prefs: []
  type: TYPE_NORMAL
- en: A pure function is a function that does not rely on instance variables or any
    state outside of its scope and only operates on its input parameters. It produces
    the same output for the same input and has no side effects on the program or environment.
    A pure function can rely on method injection to use external dependencies, where
    dependencies are passed in as parameters rather than depending on global or instance
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Method injection is excellent for testability as it increases the decoupling
    of the class from the dependency. It also decouples the class from the method
    (that’s part of the “pure” definition we discussed), but it also requires our
    method signatures to be more complex and manage states outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: These three ways of DI are great to improve decoupling and testability. But
    we can make all these ways much more decoupled. How? Easily, using protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling our code using protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed protocols in [*Chapter 5*](B18653_05.xhtml#_idTextAnchor163) when
    we talked about the Swift language features. Protocols play a significant role
    in design patterns, especially in DI.
  prefs: []
  type: TYPE_NORMAL
- en: We can inject different objects with different behavior using protocols as long
    as they conform to the protocol interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using a protocol to inject a different object with a different
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two instances of `MyViewController`. We inject `concreteDataManager`,
    an instance of the `DataManager` protocol, into the first instance, and we inject
    `otherDataManager`, another instance of the `DataManager` protocol, into the second
    `MyViewController` instance. They both have the same interface but different implementations.
    In this case, they return other elements in their `fetchData()` method. This technique
    allows us to inject whatever implementation we want with any object. It is especially
    powerful with testing and helps us to use mocks in our code.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize DI, we can pick any pattern we want out of the three I mentioned
    – constructor, setter, or method – and expand its capabilities with a protocol.
    It all depends on the level of simplicity and coupling we want.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating using delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegation is a simple pattern that allows objects to communicate with each
    other in a loosely coupled interface. Delegation is also based on a protocol that
    allows classes to communicate with different types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a small example of delegation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `MyViewController` class has a view named `MyView` and conforms to a protocol
    named `MyViewDelegate`. This protocol has a method called `didTapButton()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`MyView` needs to communicate with `MyViewController` but doesn’t have a direct
    reference. Instead, it has a delegate property of the `MyViewDelegate` type. This
    delegate property creates a loosely coupled interface between the view and its
    view controller (its “delegate”).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two takeaways from this code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '*We need to create a delegate property*: The object that communicates with
    the delegate needs to have a delegate property, and the delegate property is obtained
    from the type of the protocol we just declared. This ensures a loosely coupled
    relationship; every object can conform to that protocol, even mocks for testing
    purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*We must mark the delegate as weak*: This is a critical point. Based on our
    code, the view controller has a strong reference to the view, and the view has
    a reference to the view controller through the delegate property. This means that
    the delegate property must be weak, and that’s a common mistake many developers
    make. In fact, the weak reference to the delegate property is a common topic in
    interviews, and we should remember that when asked about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though delegation is a widely used pattern, it has some drawbacks compared
    to modern patterns such as Combine, and many developers consider it a little bit
    outdated.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, when using delegation to pass a message between multiple objects,
    the code can become cumbersome and difficult to read. This is especially true
    when each object must act as the delegate of the previous object, as it requires
    the creation of multiple protocols and delegates properties. As a result, the
    code can become boilerplate and challenging to follow and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating protocols can decrease our coupling, but our delegate must conform
    to a specific interface. With reactive programming, the subscriber observes updates
    without being tied to a particular interface, making the communication even more
    loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: So, what can be a reason to choose delegation over Combine? With delegation,
    we can define a clear interface and even a complex one, which is not always true
    with Combine. But more than that – delegation clearly separates concerns and helps
    us keep our code modular and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go over a common interview question about the delegate design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: “How does the delegation pattern differ from other communication patterns, such
    as notifications or closures, in Swift?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: A delegate design pattern is just one way for an object to communicate with
    another object. Over the years, new ways of communication have been added – notifications,
    closures, and, of course, reactive approaches such as Combine and RxSwift.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these options has its pros and cons and we should match the pattern
    to the problem we are trying to solve. Therefore, it is important to understand
    the practical differences between these options.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The delegate design pattern is different from notifications, closures, and
    Combine in several key ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '*One-to-one communication relationship*: While the notifications pattern and
    a Combine publisher can send a message to an unlimited number of instances, the
    delegate pattern typically communicates with a single object. This might initially
    seem like a disadvantage, but it also simplifies complex situations where we need
    more control over our code coupling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Formalized protocol*: In a delegate pattern, there’s a clear interface to
    work with the delegate, thanks to the use of protocols. The protocol formalizes
    the communication and provides clear expectations for both the delegate and the
    owner. This is extremely important when the communication becomes complex – for
    example, several functions to implement with multiple parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*More complex to set up*: Using the delegate pattern becomes more complex to
    set up when we want to pass a value or an event between different layers and components
    of our app. But it’s not just the setup – following the data flow becomes cumbersome,
    as you have to jump between one protocol implementation and another. It’s another
    example of a flexibility versus simplicity use case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the delegate pattern is great for certain use cases and choosing the
    right communication option depends on the specific requirements of our problem.
  prefs: []
  type: TYPE_NORMAL
- en: As for interview questions, especially related to design patterns, we must remember
    that “better” relies on the context.
  prefs: []
  type: TYPE_NORMAL
- en: I think the next topic describes that perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a state using Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two questions that interviewers love to ask:'
  prefs: []
  type: TYPE_NORMAL
- en: “How do we create a Singleton?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Is it good to have singletons in our app?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first question is technical, but the second one is tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the definition of a Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Singleton?
  prefs: []
  type: TYPE_NORMAL
- en: In the Singleton design pattern, there is only one instance of a class that
    can be globally accessed through a **static** property. It is often used to manage
    shared resources or states in a program where multiple instances could cause issues
    with synchronization or consistency. To implement a Singleton, a class typically
    has a private constructor and a static method or property that returns the single
    instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, it is simple to create a Singleton. We use a static property for
    that task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the Singleton is defined with one line only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The critical thing is to always access the Singleton using the `shared` property,
    as seen in the preceding code example. To prevent creating another instance of
    the `MySingleton` class, we can mark the `init()` method as private and ensure
    there is only one instance.
  prefs: []
  type: TYPE_NORMAL
- en: But that was the easy question. The real question is – should we use a Singleton
    in our projects? Is it considered a legit pattern or an anti-pattern?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of reasons why a Singleton can be an anti-pattern for many
    developers. Let’s discuss some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Having a global state*: Singletons provide a global state for the app, and
    multiple app components can manipulate this global state. As a result, it can
    be hard to track down where and when these changes are made. In a way, the main
    problem of having a global state that can be accessed from everywhere in the code,
    is when the app gets more extensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Coupling increasing*: We build a modular app with great code separations.
    But once our different app components access a shared instance (aka Singleton),
    the coupling between these components increases. Tight coupling becomes more of
    a concern as the number of Singletons in a program increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Challenge multithreading*: Because the Singleton can be accessed from everywhere,
    it also means that we can modify and read values from a shared instance from different
    threads. This can lead to race conditions and other synchronization issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what is the answer? Well, there are cases where having a Singleton is perfectly
    legit. For example, there should be only one instance of a particular object in
    the app – a configuration manager or database connection.
  prefs: []
  type: TYPE_NORMAL
- en: But we should try to avoid using a Singleton whenever possible. How? Let’s answer
    that with an interview question.
  prefs: []
  type: TYPE_NORMAL
- en: “How would you avoid using a Singleton in your code? Can you describe some of
    the alternative approaches you might consider?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should already be familiar with the different design patterns
    and can come up with a suitable alternative. And that’s the goal of the question
    – to test the ability to take your experience and knowledge and provide a good,
    acceptable solution.
  prefs: []
  type: TYPE_NORMAL
- en: If finding an alternative is possible, the general guideline regarding Singletons
    is to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: The most common way to avoid a Singleton is using DI to inject services used
    within the class or the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating a static constant (Singleton), we can approach the `Service`
    instance from the `Client` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create an instance and inject it into the `Client` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If a global state is not required, injecting a new instance (or passing an existing
    instance) instead of using a Singleton is better.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can improve that example by converting `Service` into a protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that `Service` is a protocol, it makes our coupling even looser. That’s
    a nice code modification we can make.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you describe the potential issues with using Singletons in a multithreaded
    environment, and how can these be addressed?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: We briefly mentioned multi-threading issues when we discussed Singleton’s disadvantages
    earlier in this section. A Singleton is a shared resource, and as such, we must
    understand how it fits in a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the potential issues we can encounter with Singleton in a
    multithreaded environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Having race conditions*: If multiple threads try to access and modify the
    same Singleton instance simultaneously, it can result in race conditions that
    can cause unpredictable behavior and data corruption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Encountering deadlocks*: If multiple threads try to access a Singleton instance
    in a different order, it can lead to deadlocks where one thread waits for another
    to release a lock on the Singleton'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Having an inconsistent state*: If a Singleton instance is modified by one
    thread while another thread is reading or using it, it can result in an unstable
    state and unexpected behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As developers, unpredictable behavior is one of the most challenging things
    to encounter, making debugging and investigation more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest solution is to assume the Singleton is not a thread-safe object
    and can be accessed only from the same thread. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we assume the Singleton can only be accessed from the main
    thread. We’re using the **Grand Central Dispatch** (**GCD**) API to move to the
    main thread to ensure the Singleton is always accessed from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to make the Singleton a thread-safe object by locking access
    using **NSLock**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we make the shared instance a private property and add a static
    method that ensures locking and unlocking before returning the Singleton instance.
    This is a common practice to lock an object and make it thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize the topic – there is an ongoing debate and discussion in the iOS
    developer community. Some developers find Singleton a helpful tool that simplifies
    sharing states and resources, while others see Singleton as an anti-pattern that
    has the potential to cause problems. The truth, as always, is somewhere in the
    middle.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency is a complex computer science topic, not only in iOS development.
    A bad design can lead to crashes, race conditions, deadlocks, and lags.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry – do you remember what we said about design patterns in this
    chapter’s introduction? They are here to solve our problems. So, let’s review
    some of the design patterns and best practices for concurrency to see what tools
    we can add to our toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GCD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GCD is a powerful concurrency framework that enables the efficient and scalable
    execution of tasks. GCD provides a simple way to create queues of tasks and schedule
    them for execution without managing threads manually. This makes it easy to write
    efficient and responsive code that takes full advantage of the available system
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use GCD to download an image asynchronously in
    the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define a function, `downloadImage`, which takes a URL and
    a completion handler as parameters. The function creates a global background queue
    using the `DispatchQueue.global` method and then calls the async method to add
    a task to the queue. The task downloads the image data from the URL, converts
    it into a an image, and then calls the completion handler with the result. Because
    the task is executed asynchronously in the background, it does not block the main
    thread and allows the app to remain responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Creating advanced queues with OperationQueue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An operation queue is a higher-level concurrency mechanism that manages tasks
    and executes them concurrently, like the GCD API we just discussed. **OperationQueue**
    provides advanced features and a simple interface for managing queues.
  prefs: []
  type: TYPE_NORMAL
- en: The basic unit of `OperationQueue` is `Operation`, which can perform a specific
    task. The operation queue’s job is to take an operation and perform it simultaneously
    or one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: We simply subclass the `Operation` class and implement the `main()` function
    to create an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to download multiple images using Operation Queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we subclassed `Operation` by creating the `ImageDownloadOperation`
    class, which has a `url` property and performs a download operation in its main
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Right after that, we create an operation queue called `queue` and an array of
    download operations. We add the operations array to our created queue and collect
    them by calling the `result` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of Operation Queue’s best features is the ability to configure how it works.
    If we want the queue to perform a maximum of three operations at the same time,
    we can set its `maxConcurrentOperationCount` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If we set that property to `1`, our queue will perform the operations one after
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: Another exciting option is *adding dependencies between the queue operations*
    – we can define that a specific operation cannot start before another operation
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `downloadOp2` cannot start before `downloadOp1` ends.
  prefs: []
  type: TYPE_NORMAL
- en: Operation Queue generally provides advanced capabilities and patterns to perform
    complex background operations with more control.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking threads with NSLock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NSLock` is a synchronization mechanism for managing access to shared resources
    in a multi-threaded environment. `NSLock` provides a simple way to block threads
    that attempt to access a locked resource, allowing only one thread to access the
    resource at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use `NSLock` to protect a shared resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let’s assume that `SharedResource` can be used in different threads. This can
    cause race conditions and deadlocks in trying to access and modify the `count`
    variable simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: To handle that, we “lock” the read and write access with `NSLock` – we call
    `lock()` before the read/write operation and release it by calling `unlock()`
    afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Combine Future publisher to implement async operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already discussed Combine earlier in [*Chapter 8*](B18653_08.xhtml#_idTextAnchor249),
    but now let’s discuss integrating async operations into the Combine stream.
  prefs: []
  type: TYPE_NORMAL
- en: The `Future` publisher for any action whose value is not received immediately.
    For example, the `Future` type can include opening a modal, selecting an item,
    and dismissing it.
  prefs: []
  type: TYPE_NORMAL
- en: But let’s see how we can use `Future` for async operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `Future` publisher has a closure with a `promise` parameter with either
    success or failure depending on the operation result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `loadJSONFile` function returns a `Future` publisher. Inside,
    it creates a background queue and loads a big JSON file. It calls the promise
    type with success and data if everything works fine. If not, it sends a failure
    and an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how to use that function in a Combine stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can integrate the JSON loading operation in one line, decode its data,
    and map and filter it, as part of a Combine stream.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how the `Future` publisher makes it very easy to integrate async
    operations in the Combine stream. We can also include more complex async operations
    in Combine by combining `OperationQueue` and `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: Going over concurrency development best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regardless of the different techniques we just learned, there are some best
    practices we should follow to keep our code safe from race conditions and deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of them are derived from what we’ve learned till now. Also, these best
    practices are excellent for interview discussions about concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avoid blocking the main thread*: The main thread handles UI updates, so blocking
    it can cause the app to become unresponsive. To avoid blocking the main thread,
    use background threads or operation queues to perform long-running or CPU-intensive
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use structs for safety*: Structs are value types, which means they’re thread-safe
    by default. If we need to pass data between threads or queues, using structs can
    help prevent race conditions and other concurrency issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Avoid shared state*: Shared state between threads or queues can lead to race
    conditions and other concurrency issues. Instead, try to keep the state local
    to each thread or queue and use message passing or other communication mechanisms
    to share data between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use Combine*: Combine is a robust framework for reactive programming in iOS
    and can help simplify concurrency by allowing you to define data streams and transformations
    that operate on those streams. By using Combine, you can avoid complex thread
    management and synchronization issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Always return a closure in the same thread*: When performing asynchronous
    operations, it’s essential to ensure that any closures or callbacks are executed
    in the same thread or queue where they were initially created. This helps avoid
    race conditions and other concurrency issues when executing code across multiple
    threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was long, and this topic could be a book of its own. In fact, many
    books focus solely on design patterns, and it’s obvious why – design patterns
    are our toolbox for everything we do in iOS development.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter taught us about MVC/MVVM, DI, delegation, singletons, and concurrency
    patterns and tools. By now, we should have a great understanding of the primary
    design patterns in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge of design patterns is a great foundation to prepare us for the
    next chapter, which will focus on app architecture and development.
  prefs: []
  type: TYPE_NORMAL
