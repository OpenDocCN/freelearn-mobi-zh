- en: Arrow Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrow contains many implementations of conventional functional types such as
    `Option`, `Either`, and `Try`, as well many other types classes, such as functor
    and monad.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Option` to manage null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Either` and `Try` to manage errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combinations and transformers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State` to manage application state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Option<T>` datatype is the representation of a presence or absence of a
    value `T`. In Arrow, `Option<T>` is a sealed class with two sub-types, `Some<T>`,
    a data class that represents the presence of value `T` and `None`, and an object
    that represents the absence of value. Defined as a sealed class, `Option<T>` can't
    have any other sub-types; therefore the compiler can check clauses exhaustively,
    if both cases, `Some<T>` and `None` are covered.
  prefs: []
  type: TYPE_NORMAL
- en: I know (or I pretend to know) what you're thinking at this very moment—why do
    I need `Option<T>` to represent the presence or absence of `T`, if in Kotlin we
    already have `T` for presence and `T?` for absence?
  prefs: []
  type: TYPE_NORMAL
- en: 'And you are right. But `Option` provides a lot more value than nullable types,
    let''s jump directly to an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `division` function takes three parameters—two integers (`a`, `b`) and a
    denominator (`den`) and returns a `Pair<Int, Int>`, if both numbers are divisible
    by `den` or `null` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can express the same algorithm with `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The function, `optionDivide` takes the nullable result from divide and returns
    it as an `Option`, using the `toOption()` extension function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no major changes on `optionDivision` compared to `division`, it is
    the same algorithm expressed with different types. If we stop here, then `Option<T>`
    doesn''t provide extra value on top of nullables. Luckily, that isn''t the case;
    there are more ways to use `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Option` provides several functions to process its internal value, in this
    case, `flatMap` (as a monad) and now our code looks a lot shorter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following short list with some of the `Option<T>` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `exists(p :Predicate<T>): Boolean` | Returns predicate `p` result if value
    `T` exists, otherwise null. |'
  prefs: []
  type: TYPE_TB
- en: '| `filter(p: Predicate<T>): Option<T>` | Returns `Some<T>` if the value `T`
    exists and fulfills the predicate `p`, otherwise `None`. |'
  prefs: []
  type: TYPE_TB
- en: '|  `flatMap(f: (T) -> Option<T>): Option<T>` | A `flatMap` transform function
    (like monad). |'
  prefs: []
  type: TYPE_TB
- en: '| `<R> fold(ifEmpty: () -> R, some: (T) -> R): R<R>` | Returns value transformed
    as `R`, invoking `ifEmpty` for `None` and some for `Some<T>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOrElse(default:() -> T): T` | Returns value `T` if exists, otherwise
    returns `default` result. |'
  prefs: []
  type: TYPE_TB
- en: '| `<R> map(f: (T) -> R):Option<T>` | A transform function (like `functor`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `orNull(): T?` | Returns the value `T` as a nullable `T?`. |'
  prefs: []
  type: TYPE_TB
- en: 'The last implementation of division will use comprehensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Comprehension is a technique to compute sequentially over any type (such as
    `Option`, `List`, and others) that contains a `flatMap` function and can provide
    an instance of monad (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: In Arrow, comprehensions use coroutines. Yes, coroutines are useful outside
    the asynchronous execution domain.
  prefs: []
  type: TYPE_NORMAL
- en: If we outline the continuations from our previous example it will look like
    this (which is a helpful mental model to understand coroutines)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Option.monad().binding` is a coroutine builder and the `bind()` function is
    a suspended function. If you recall correctly from our coroutines chapter, a continuation
    is a representation of any code after a suspension point (that is, when a suspended
    function is invoked). In our example, we have two suspension points and two continuations,
    when we return (in the last block line) we are in the second continuation, and
    we have access to both values, `aDiv` and `bDiv`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading this algorithm as continuations is very similar to our `flatMapDivision`
    function. Behind the scenes, `Option.monad().binding` uses `Option.flatMap` with
    continuations to create the comprehension; once compiled, both `comprehensionDivision`
    and `flatMapDivision` are equivalent, roughly speaking.
  prefs: []
  type: TYPE_NORMAL
- en: The `ev()` method will be explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow's type hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a limitation in Kotlin''s types system—it doesn''t support **Higher-Kinded
    Types** (**HKT**). Without getting too much into type theory, an HKT is a type
    that declares other generic values as type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Lacking HKT is not great for Kotlin concerning functional programming, as many
    advanced functional constructs and patterns use them.
  prefs: []
  type: TYPE_NORMAL
- en: The Arrow team is working on **Kotlin Evolution and Enhancement Process** (**KEEP**)—the
    community process for adding new language features, called Type Classes as extensions
    in Kotlin ([https://github.com/Kotlin/KEEP/pull/87](https://github.com/Kotlin/KEEP/pull/87))
    to support HKT and other features. At this very moment, it isn't clear if this
    KEEP (coded as *KEEP-87*) will be included anytime soon in Kotlin, but right now
    is the most commented proposal and has attracted a lot of attention. Details aren't
    clear now as it is still a work in progress, but there is a glimpse of hope.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow's solution to this problem is to simulate HKT through a technique called
    evidence-based HKTs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at an `Option<T>` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Option<A>` is annotated with `@higherkind` which is similar to `@lenses` from
    our previous chapter; this annotation is used to generate code to support evidence-based
    HKTs. `Option<A>` extends from `OptionKind<A>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`OptionKind<A>` is a type alias for `HK<OptionHK, A>`, all this code is generated
    using the `@higherkind` annotation processor. `OptionHK` is an uninstanciable
    class that is used as a unique tag name for `HK` and `OptionKind` is a kind of
    intermediate representation of HKT. `Option.monad().binding` returns `OptionKind<T>`,
    that is why we need to call `ev()` at the end to return a proper `Option<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`HK` interface (short-hand for **higher-kinded**) is used to represent an HKT
    of arity one up to `HK5` for arity 5\. On `HK<F, A>`, `F` represents the type
    and `A` the generic parameter, so `Option<Int>` is `OptionKind<Int>` value which
    is `HK<OptionHK, Int>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look now at `Functor<F>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Functor<F>` extends `TC`, a marker interface and, as you can guess, it has
    a `map` function. The `map` function receives `HK<F, A>` as the first parameter
    and a lambda `(A) -> B` to transform the value of `A` into `B` and transform it
    into `HK<F, B>.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our basic datatype `Mappable` that can provide instances for
    the `Functor` type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our class, `Mappable<T>` is annotated with `@higherkind` and extends `MappableKind<T>`
    and must have a companion object, it doesn't matter if is empty or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create our implementation of `Functor<F>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our `MappableFunctorInstance` interface extends `Functor<MappableHK>` and is
    annotated with `@instance(Mappable::class)`. Inside the `map` function, we use
    the first parameter, `MappableKind<A>` and use its `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `@instance` annotation will generate an object extending the interface, `MappableFunctorInstance`.
    It will create an `Mappable.Companion.functor()` extension function to get the
    object implementing `MappableFunctorInstance` using `Mappable.functor()` (which
    is how we can use `Option.monad()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative is to let Arrow-derived instances automatically provided
    that your datatypes have the right functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `@deriving` annotation will generate `DerivedMappableFunctorInstance` that
    normally you will write manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a generic function to use our `Mappable` functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `buildBicycle` function will take as parameter any `HK<F, Int>` and apply
    the function `f` using its `Functor` implementation, returned by the function
    `arrow.typeclasses.functor` and returns `HK<F, Bicycle>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `arrow.typeclass.functor` resolves at runtime, instances that
    adhere to the `Functor<MappableHK>` requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can use `buildBicycle` with `Mappeable<Int>`, or any other HKT class such
    as `Option<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem with the Arrows approach to HKTs is that it must resolve its instances
    at runtime. This is because Kotlin does not have support for implicits or can
    solve type class instances at compile time, leaving Arrow with this only alternative
    until *KEEP-87* is approved and included in the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you can have an HKT that has a `map` function but without an instance of
    `Functor` can''t be used, yet isn''t a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Calling `buildBicycle` with a `NotAFunctor<T>` function compiles, but it will
    throw a `ClassNotFoundException` exception at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how Arrow's hierarchy works, we can cover other classes.
  prefs: []
  type: TYPE_NORMAL
- en: Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Either<L, R>` is a representation of one of two possible values `L` or `R`,
    but not both at the same time. `Either` is a sealed class (similar to `Option`)
    with two subtypes `Left<L>` and `Right<R>`. Usually `Either` is used to represent
    results that can fail, using the left side to represent the error and the right
    side to represent a successful result. Because representing operations that can
    fail is a common scenario, Arrow''s `Either` is right biased, in other words,
    unless it is documented otherwise all operations run on the right side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s translate our division example from `Option` to `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now instead of returning a `None` value, we''re returning valuable information
    to our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In `eitherDivision`, we're using Arrow's `Tuple<A, B>` instead of Kotlin's `Pair<A,
    B>`. Tuples provide more features than Pair/Triple, and from now on we'll use
    it. To create a `Tuple2`, you can use the extension `infix` function, `toT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, a short list of the `Either<L, R>` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `bimap(fa:(L) -> T, fb:(R) -> X): Either<T, X>` | Transform using `fa` on
    `Left` and `fb` on `Right` to return `Either<T, X>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `contains(elem:R): Boolean` | Returns `true` if the `Right` value is the
    same as `elem` parameter, `false` for `Left`. |'
  prefs: []
  type: TYPE_TB
- en: '| `exists(p:Predicate<R>):Boolean` | If `Right`, returns Predicate `p` result,
    always `false` for `Left`. |'
  prefs: []
  type: TYPE_TB
- en: '| `flatMap(f: (R) -> Either<L, T>): Either<L, T>` | A `flatMap` function as
    in `Monad`, using the value of  `Right`. |'
  prefs: []
  type: TYPE_TB
- en: '| `fold(fa: (L) -> T, fb: (R) -> T): T` | Returns a `T` value executing `fa`
    for `Left` and `fb` for `Right`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOrElse(default:(L) -> R): R` | Returns `Right` value, or results from
    the `default` function. |'
  prefs: []
  type: TYPE_TB
- en: '| `isLeft(): Boolean` | Returns `true` if is an instance of `Left` and `false`
    for `Right`. |'
  prefs: []
  type: TYPE_TB
- en: '| `isRight(): Boolean` | Returns `true` if is an instance of `Right` and `false`
    for `Left`. |'
  prefs: []
  type: TYPE_TB
- en: '| `map(f: (R) -> T): Either<L, T>` | A `map` function as in `Functor`, if `Right`,
    uses function `f` to transform it to `Right<T>`, if `Left`, returns same value
    without transformation. |'
  prefs: []
  type: TYPE_TB
- en: '| `mapLeft(f: (L) -> T): Either<T, R>` | A `map` function as in `Functor`,
    if `Left`, uses function `f` to transform it to `Left<T>`, if `Right`, returns
    same value without transformation. |'
  prefs: []
  type: TYPE_TB
- en: '| `swap(): Either<R, L>` | Returns `Either` with its types and value swapped.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toOption(): Option<R>` | `Some<T>` for `Right` and `None` for `Left`. |'
  prefs: []
  type: TYPE_TB
- en: 'The `flatMap` version looks as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Either` has a monad implementation, so we can invoke the binding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to `Either.monad<L>()`; for `Either<L, R>` it must define the
    `L` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In our next section, we'll learn about monad transformers.
  prefs: []
  type: TYPE_NORMAL
- en: Monad transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Either` and `Option` are simple to use, but what happens if we combine both?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`UserService.findAge` returns `Either<String, Option<Int>>`; `Left<String>`
    for errors accessing the database or any other infrastructure, `Right<None>` for
    no value found on the database, and `Right<Some<Int>>` for a value found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To print an age, we need two nested folds, nothing too complicated. Problems
    arrive when we need to do operations accessing multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Monads don''t compose, making these operations grow in complexity, very quickly.
    But, we can always count on comprehensions, can''t we? Now, let''s look at the
    following codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is better, the returning type is not that long, and `fold` is more manageable.
    Let''s take a look at the nested comprehensions in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the same type of both values and result. But we still have another
    option, monad transformers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **monad transformer** is a combination of two monads that can be executed
    as one. For our example, we will use `OptionT`, (shorthand for **Option Transformer**)
    as `Option` is the monad type that is nested inside `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use `OptionT.monad<EitherKindPartial<String>>().binding`. The `EitherKindPartial<String>` monad
    means that the wrapper type is an `Either<String, Option<T>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `binding` block, we use `OptionT` on values of type `Either<String,
    Option<T>>` (technically on values of type `HK<HK<EitherHK, String>, Option<T>>`)
    to call `bind(): T`, in our case `T`, is `Int`.'
  prefs: []
  type: TYPE_NORMAL
- en: Previously we used just the `ev()` method, but now we need to use the `value()`
    method to extract the `OptionT` internal value.
  prefs: []
  type: TYPE_NORMAL
- en: In our next section, we'll learn about the `Try` type.
  prefs: []
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Try** is a representation of a computation that may or may not fail. `Try<A>`
    is a sealed class with two possibles sub-classes—`Failure<A>`, representing a
    fail and `Success<T>` representing a successful operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our division example with `Try`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to create a `Try` instance is to use the `Try.invoke` operator.
    If the block inside throws an exception, it will return `Failure`; if everything
    goes well, `Success<Int>`, for example, the `!!` operator will throw `NPE` if
    divide returns a null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at a short list of the `Try<T>` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `exists(p: Predicate<T>): Boolean` | If `Success<T>` returns `p` result,
    on `Failure` always return `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `filter(p:  Predicate<T>): Try<T>` | Returns `Success<T>` if operation is
    successful and pass predicate `p`, otherwise `Failure`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<R> flatMap(f: (T) -> Try<R>): Try<R>` | `flatMap` function as in monad.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<R> fold(fa: (Throwable) -> R, fb:(T) -> R): R` | Returns value transformed
    as `R`, invoking `fa` if `Failure`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOrDefault(default: () -> T): T` | Returns value `T`, invoking default
    if `Failure`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getOrElse(default: (Throwable) -> T): T` | Returns value `T`, invoking default
    if `Failure`. |'
  prefs: []
  type: TYPE_TB
- en: '| `isFailure(): Boolean` | Returns `true` if `Failure`, otherwise `false`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isSuccess(): Boolean` | Returns `true` if `Success`, otherwise `false`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<R> map(f: (T) -> R): Try<R>` | Transforming function as in functor. |'
  prefs: []
  type: TYPE_TB
- en: '| `onFailure(f: (Throwable) -> Unit): Try<T>` | Act on `Failure`. |'
  prefs: []
  type: TYPE_TB
- en: '| `onSuccess(f: (T) -> Unit): Try<T>` | Act on `Success`. |'
  prefs: []
  type: TYPE_TB
- en: '| `orElse(f: () -> Try<T>): Try<T>` | Returns itself on `Success` or `f` result
    on `Failure`. |'
  prefs: []
  type: TYPE_TB
- en: '| `recover(f: (Throwable) -> T): Try<T>` | Transform `map` function for `Failure`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `recoverWith(f: (Throwable) -> Try<T>): Try<T>` | Transform `flatMap` function
    for `Failure`. |'
  prefs: []
  type: TYPE_TB
- en: '| `toEither() : Either<Throwable, T>` | Transform into `Either`—`Failure` to
    `Left<Throwable>` and `Success<T>` to `Right<T>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `toOption(): Option<T>` | Transform into `Option`—`Failure` to `None` and
    `Success<T>` to `Some<T>`. |'
  prefs: []
  type: TYPE_TB
- en: 'The `flatMap` implementation is very similar to `Either` and `Option` and shows
    the value of having a common set of name and behavior conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Monadic comprehensions are available for `Try` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another kind of monadic comprehension using an instance of `MonadError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With `monadError.bindingCatch` any operation that throws an exception is lifted
    to `Failure`, at the end the returns is wrapped into `Try<T>`. `MonadError` is
    also available for `Option` and `Either`.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**State** is a structure that provides a functional approach for handling application
    state. `State<S, A>` is an abstraction over `S -> Tuple2<S, A>`. **S** represents
    the state type, and `Tuple2<S, A>` is the result, with `S` for the newly updated
    state and `A` for the function return.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with a simple example, a function that returns two things, a price
    and the steps to calculate it. To calculate a price, we need to add  `VAT` of
    20% and apply a discount if the `price` value goes above some threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have a type alias `PriceLog` for `MutableList<Tuple2<String, Double>>`. `PriceLog`
    will be our `State` representation; each step represented with `Tuple2<String,
    Double>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first function, `addVat(): State<PriceLog, Unit>` represents the first
    step. We write the function using a `State` builder that receives `PriceLog`,
    the state before applying any step and must return a `Tuple2<PriceLog, Unit>`,
    we use `Unit` because we don''t need the price at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `applyDiscount` function is our second step. The only new element that
    we introduce here are two parameters, one for `threshold` and the other for `discount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is represented by the function `finalPrice()`, and now we return `Double`
    instead of `Unit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent the sequence of steps, we use a monad comprehension and use the
    `State` functions sequentially. From one function to the next one, the `PriceLog`
    state is flowing implicitly (is just some coroutine continuations magic). At the
    end, we yield the final price. Adding new steps or switching existing ones is
    as easy as adding or moving lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To use the `calculatePrice` function, you must provide the threshold and discount
    values and then invoke the extension function `run` with an initial state. If
    you're interested just in the price, you can use `runA` or for just the history, `runS`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid problems using `State`. Don't confuse the extension function `arrow.data.run`
    with the extension function, `kotlin.run` (imported by default).
  prefs: []
  type: TYPE_NORMAL
- en: Corecursion with State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`State` is beneficial on corecursion; we can rewrite our old examples with
    `State`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our original `unfold` function use a function, `f: (S) -> Pair<T,S>?` which
    is very similar to `State<S, T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having a lambda `(S) -> Pair<T, S>?`, we use `State<S, Option<T>>`
    and we use the function fold from `Option`, with an empty `Sequence` for `None`
    or a recursive call for `Some<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our old factorial function uses `unfold` with `Pair<Long, Int>` and a lambda—`(Pair<Long,
    Int>) -> Pair<Long, Pair<Long, Int>>?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The refactored factorial uses `State<Tuple<Long, Int>, Option<Long>>` but internal
    logic is almost the same, although our new factorial doesn''t use null, which
    is a significant improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `fib` uses unfold with `Triple<Long, Long, Int>` and a lambda `(Triple<Long,
    Long. Int>) -> Pair<Long, Triple<Long, Long, Int>>?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And the refactored `fib` uses `State<Tuple3<Long, Long, Int>, Option<Long>>`.
    Pay close attention to the extension operator function `plus`, used with `Tuple2<A,
    B>` and `C` will return `Tuple3<A, B, C>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: And now, we can use our corecursive functions to generate sequences. There are
    many other uses for `State` that we can't cover here, such as *Message History*
    from *Enterprise Integration Patterns* ([http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html](http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html))
    or navigation on forms with multiple steps such as plane checking or long registration
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrow provides many datatypes and type classes that reduce significantly complex
    tasks and provide a standard set of idioms and expressions. In this chapter, we
    learned how to abstract over null values with `Option` and to express computations
    with `Either` and `Try`. We created a datatype class, and we also learned about
    monadic comprehensions and transformations. Last but not least, we used `State`
    to represent the application state.
  prefs: []
  type: TYPE_NORMAL
- en: And with this chapter, we reach the final of this journey, but rest assured,
    this isn't the end of your journey learning functional programming. As we learned
    in the first chapters, functional programming is all about using functions as
    building blocks to create complex programs. In the same way, with all the concepts
    that you learn here, now you can understand and master new, exciting and more
    powerful ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Now a new learning journey begins for you.
  prefs: []
  type: TYPE_NORMAL
