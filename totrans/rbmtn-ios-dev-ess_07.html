<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Interface Builder and WebView – More Goodies!</h1></div></div></div><p>
<em>"Time is precious; waste it wisely."</em>
</p><p>
<em>–<em>Anonymous</em>
</em>
</p><p>In this chapter we will learn about some features of iOS development with RubyMotion. Xcode is a very advanced IDE and has many qualities, which we can exploit to develop faster and better iOS applications. In this chapter we will also learn how to use an <strong>Interface Builder</strong> <a id="id415" class="indexterm"/>for rapid development with RubyMotion. We will also have a look at some key elements of Xcode, such as <code class="literal">.xib</code>, <code class="literal">.nib</code>, and WebView, to create real-life interactive apps.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Interface Builder</h1></div></div></div><p>Xcode's Interface<a id="id416" class="indexterm"/> Builder allows you to create your application's user interface visually, instead of writing code. Interface Builder is a great tool that is very simple to use and is pivotal in making iOS development really fast. Therefore, the Interface Builder used along with RubyMotion further reduces development time. We can say these are two delicious recipes independently, but when used together, it's the ultimate formula to make beautiful iOS apps as quickly as possible.</p><p>Interface Builder comes with Xcode. Before we jump into using Interface Builder, it's important to understand that although Interface Builder creates the UI using the drag-and-drop mechanism, it is however not creating the Objective-C code behind the scene. It's creating an XML description of the GUI you're building, and the Cocoa Touch framework uses that XML to actually create the UI elements, such as label and textbox, for your application at runtime. Everything we do in Interface Builder could be done by writing lines of Ruby code—that's exactly what we have been doing from the beginning of this book—but shortly you will see how things get really easy with a GUI builder.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>XCode uses XML only for the editing stage, which is then compiled to nibs. Cocoa Touch never sees the XML source.</p></div></div><p>Before we <a id="id417" class="indexterm"/>begin using Interface Builder, let's understand some jargon associated with XCode development. The GUI builder provides options to drag-and-drop buttons, table views, and text fields into your app window. The resulting interface is stored as a <code class="literal">.xib</code> file. A <code class="literal">.xib</code> file is an XML representation of your objects and their instance variables, and it is compiled into a <code class="literal">.nib</code> file when your application is built. The <code class="literal">.xib</code> file is easier to work with but the <code class="literal">.nib</code> file is smaller and easier to parse, that's why the file that actually ships with your application is a <code class="literal">.nib</code> file.</p><div><div><h3 class="title"><a id="tip32"/>Tip</h3><p>The <code class="literal">.nib</code> file is short for NeXT Interface Builder.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec64"/>Let's try the Interface Builder</h2></div></div></div><p>So far we have created <a id="id418" class="indexterm"/>the views for our <strong>Restro</strong> application views by writing code in Ruby. In this section, let's create a view using the GUI-based Interface Builder. We will create a <strong>Contact Us</strong> form and use it in our application.</p><p>The Interface Builder is integrated into Xcode, which is a one stop IDE for any Apple-related development, whether it's for iOS devices or Mac. We will create a <code class="literal">.xib</code> file and then use this file in our RubyMotion project by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open Xcode and click on <strong>Create a new Xcode Project</strong>.<div><img src="img/5220OT_07_01.jpg" alt="Let's try the Interface Builder"/></div></li><li class="listitem">Click <a id="id419" class="indexterm"/>on <strong>Single View Application</strong>, as we need only one <code class="literal">.xib</code> file.<div><img src="img/5220OT_07_02.jpg" alt="Let's try the Interface Builder"/></div></li><li class="listitem">Enter this data in the project-creation wizard. Notice that we have selected the device as <strong>iPhone</strong>. We can also see the other options, such as <strong>iPad</strong> and <strong>Universal</strong>. If you want to create a single application to be used on both iPhone and iPad, use<a id="id420" class="indexterm"/> the <strong>Universal</strong> option from the drop-down list. Also, unselect the <strong>Use Storyboards</strong> option.<div><img src="img/5220OT_07_03.jpg" alt="Let's try the Interface Builder"/></div></li><li class="listitem">Save the project in a folder of your choice; your project will then be loaded in XCode. Click on <code class="literal">ViewController.xib</code> and you will be able to see the Interface Builder.<div><img src="img/5220OT_07_04.jpg" alt="Let's try the Interface Builder"/></div></li></ol></div><p>The Interface Builder has a fairly simple layout; it consists of four main windows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">View</li><li class="listitem" style="list-style-type: disc">Library</li><li class="listitem" style="list-style-type: disc">Document browser</li><li class="listitem" style="list-style-type: disc">Inspector</li></ul></div><p>The View window <a id="id421" class="indexterm"/>is where you construct your interface. You will drag-and-drop items from the Library window<a id="id422" class="indexterm"/> onto the View window to place them. The document browser<a id="id423" class="indexterm"/> allows you to browse hierarchically the elements you have placed in your <code class="literal">.nib</code> file. Finally, the Inspector window<a id="id424" class="indexterm"/> shows you all of the different attributes of the selected element and allows you to edit them.</p><p>And now the magic begins; drag <strong>Navigation Bar</strong> from Library to view the section as shown in the following image:</p><div><img src="img/5220OT_07_05.jpg" alt="Let's try the Interface Builder"/></div><p>When you select <strong>Navigation Bar</strong>, you will see many properties in the Inspector window. Change the <a id="id425" class="indexterm"/>tag value to <strong>1</strong> in the Inspector window. Remember that we will use this tag value in the RubyMotion project code. We need to wire our <code class="literal">View Controller</code> elements. The easiest way to do this is to use its <strong>Tag</strong> attribute. <strong>Tag</strong> is an <code class="literal">integer</code> property of the <code class="literal">UIView</code> class that you can use to identify your views. Basically, you have to set a unique integer for each <code class="literal">UIView</code> class you need to access from your <code class="literal">UIViewController</code> element<a id="id426" class="indexterm"/>.</p><div><img src="img/5220OT_07_06.jpg" alt="Let's try the Interface Builder"/></div><p>Similarly, add a text field for e-mail and change the value for the placeholder to <code class="literal">Email</code> as shown in<a id="id427" class="indexterm"/> the following screenshot. There are a lot of properties associated with every Library object; for example, in case of a text field, we have changed the keyboard value to <code class="literal">Email</code> as it suits our requirement; but you are free to go ahead and play with other properties too. Using <code class="literal">Email</code> will show a keyboard customized for entering e-mail addresses.</p><div><img src="img/5220OT_07_07.jpg" alt="Let's try the Interface Builder"/></div><p>Next, we<a id="id428" class="indexterm"/> need a button. Let's drag-and-drop a button onto the View window.</p><div><img src="img/5220OT_07_08.jpg" alt="Let's try the Interface Builder"/></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec13"/>.xib to RubyMotion</h3></div></div></div><p>In this section, we will import our <code class="literal">.xib</code> file into our RubyMotion project. Open the folder of the Xcode project <a id="id429" class="indexterm"/>and locate <code class="literal">ViewController.xib</code>. It's inside a folder named <code class="literal">en.lproj</code>; copy it into the <code class="literal">resources</code> folder of your <strong>Restro</strong> application, which we created in the last chapter.</p><p>Update the <code class="literal">about_controller.rb file</code> in the <code class="literal">restro</code> app, which we created in the last chapter, with the following code:</p><div><pre class="programlisting">def setupNavigationBar
  back= UIBarButtonItem.alloc.initWithTitle("Back", style:UIBarButtonItemStylePlain,target:nil ,action:nil)
  self.navigationItem.backBarButtonItem = back;
  contact_us_button = UIBarButtonItem.alloc.initWithTitle("Contact Us", style:UIBarButtonItemStylePlain ,target:self, action:"contact_us")
  self.navigationItem.rightBarButtonItem = contact_us_button
end
def contact_us
  contact_us_controller = ContactUsController.alloc.initWithNibName("ViewController", bundle:nil)
  presentModalViewController(contact_us_controller, animated:true)
end</pre></div><p>As we have imported the <code class="literal">.xib</code> file from Xcode to the RubyMotion project, RubyMotion creates a <code class="literal">.nib</code> file automatically when we build the code with the <code class="literal">Rake</code> command. Here, we are creating<a id="id430" class="indexterm"/> a <code class="literal">View Controller</code> variable with an initializer <code class="literal">initWithNibName</code> that receives a parameter, which will be the name of the <code class="literal">.nib</code> file. This initializer has the responsibility of instantiating the <code class="literal">.nib</code> file and wiring the <code class="literal">View</code> declared in the <code class="literal">view</code> property of the <code class="literal">View Controller variable</code>.</p><p>Create a file <code class="literal">contact_us_controller.rb</code> inside the app folder as follows:</p><div><pre class="programlisting">class ContactUsController &lt; UIViewController
end</pre></div><p>Let's fire up the terminal and run the application with the following command:</p><div><pre class="programlisting">
<strong>$rake</strong>
</pre></div><p>The following screenshot shows the output of the preceding command:</p><div><img src="img/5220OT_07_09.jpg" alt=".xib to RubyMotion"/></div><p>Next, let's<a id="id431" class="indexterm"/> update <code class="literal">contact_us_controller.rb</code> with the following code:</p><div><pre class="programlisting">class ContactUsController &lt; UIViewController
  HEADER_TAG = 1
  EMAIL_BOX_TAG = 2
  INFORMATION_BOX_TAG = 3
  SUBMIT_BUTTON_TAG = 4
  def viewDidLoad
    @header = self.view.viewWithTag(HEADER_TAG)
    @email_box = self.view.viewWithTag(EMAIL_BOX_TAG)
    @information_box = self.view.viewWithTag(INFORMATION_BOX_TAG)
    @submit_button = self.view.viewWithTag(SUBMIT_BUTTON_TAG)
    @submit_button.addTarget(self,
            action:"send_message", forControlEvents:UIControlEventTouchUpInside) 
    tapGesture = UITapGestureRecognizer.alloc.initWithTarget(self,
action:"hideKeyboard")
    tapGesture.cancelsTouchesInView = false
    view.addGestureRecognizer(tapGesture)
  end 
  
  def send_message
    if form_valid?
      puts "Submitted the button with correct values"
      close
    else
      puts "Invalid Values"
    end
  end
  def close
    dismissModalViewControllerAnimated true
  end 

  #method to hide keyboard when user taps on a scrollview
def hideKeyboard
    @information_box.resignFirstResponder
end

def form_valid?
  not @email_box.text.empty? and not @information_box.text.empty? and not @email_box.text.match(/\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i).nil?
end
end</pre></div><p>Let's start the application by using the following command:</p><div><pre class="programlisting">
<strong>$rake</strong>
</pre></div><p>Enter a<a id="id432" class="indexterm"/> few incorrect values in the form and you will get <strong>Invalid value</strong> printed on the terminal. Once you enter the values correctly in the form and submit it, it will be pulled down.</p><div><img src="img/5220OT_07_10_New.jpg" alt=".xib to RubyMotion"/></div><p>Now let's understand the code. First we have assigned the tags to the attributes that we had created in <a id="id433" class="indexterm"/>Interface Builder. And then we have used these tags to wire our variables to those components.</p><div><pre class="programlisting">
<strong>self.view.viewWithTag(HEADER_TAG)</strong>
</pre></div><p>The preceding command will retrieve a subview of <code class="literal">self.view</code> based on its tag.</p><p>We have also created an <code class="literal">action</code> item for the <strong>Submit</strong> button<a id="id434" class="indexterm"/>. That means when we click on the <strong>Submit</strong> button, it will call the action <code class="literal">send_message</code>.</p><div><pre class="programlisting">    @submit_button.addTarget(self,
      action:"send_message", forControlEvents:UIControlEventTouchUpInside)</pre></div><p>In the <code class="literal">send_message</code> action, we are checking whether the form is valid or not.</p><p>Some developers like to design the user interface using Interface Builder; others prefer to work entirely with code. One of the reasons is that when connecting Interface Builder outlets and actions to your code, it is easy to make a mistake. This often results in an error that is more difficult to debug than if you had simply written the entire code, as you have to debug in two places (Interface Builder and your code) instead of just one (the code).<a id="id435" class="indexterm"/>
</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>UIWebView – embed web content</h1></div></div></div><p>There is a possibility that we have to show<a id="id436" class="indexterm"/> web content in our application. The <code class="literal">UIWebView</code> class helps us to do exactly that. To do this, simply create a <code class="literal">UIWebView</code> object, attach it to a <a id="id437" class="indexterm"/>window, and send a request to load web content. We can also use this class to move back and forth in the history of web pages and you can even set some web content properties programmatically.</p><p>Now let's create a <code class="literal">UIWebView</code> class that displays <a class="ulink" href="http://www.rubymotion.com">www.rubymotion.com</a> in our view.</p><p>Update <code class="literal">about_controller.rb</code> with the following code:</p><div><pre class="programlisting">def submit_button
  @visitButton = UIButton.buttonWithType(UIButtonTypeRoundedRect)
  @visitButton.frame = [[80,10],[180,37]]
  @visitButton.setTitle("Visit", forState:UIControlStateNormal)
  @visitButton.setTitle("You have clicked me", forState:UIControlStateHighlighted)
  @visitButton.addTarget(self, action:"load_some_view", forControlEvents:UIControlEventTouchDown)
  view.addSubview(@visitButton)
end
def load_some_view
      @my_web_view = UIWebView.alloc.initWithFrame([[0,100],[320,220]])
      @my_web_view.delegate = self
      @my_web_view.scalesPageToFit = "YES"
      view.addSubview(@my_web_view)
      url = NSURL.URLWithString("http://www.rubymotion.com")
      request = NSURLRequest.requestWithURL(url)
      @my_web_view.loadRequest(request)
end</pre></div><p>Now let's understand the code. Take the following line:</p><div><pre class="programlisting">url = NSURL.URLWithString("http://www.rubymotion.com")</pre></div><p>Here, <code class="literal">NSURL.URLWithString</code> tells our application that the text passed is a web address or a URL, which is now an <code class="literal">NSURL</code> object called <code class="literal">url</code>.</p><div><pre class="programlisting">request = NSURLRequest.requestWithURL(url)</pre></div><p>
<code class="literal">NSURLRequest.requestWithURL</code> processes the <code class="literal">url</code> variable passed as a request. It is now a request object called <code class="literal">request</code>.</p><div><pre class="programlisting">@my_web_view.loadRequest(request)</pre></div><p>Finally, we load the request into the WebView class, which we have named <code class="literal">@my_web_view</code>.</p><p>Let's fire up the<a id="id438" class="indexterm"/> terminal and run our application as follows to see the <a id="id439" class="indexterm"/>results:</p><div><pre class="programlisting">
<strong>$rake</strong>
</pre></div><p>The following screenshot shows the output of the preceding command:</p><div><img src="img/5220OT_07_11.jpg" alt="UIWebView – embed web content"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Summary</h1></div></div></div><p>Let's recap what we have learned in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Xcode Interface Builder with RubyMotion</li><li class="listitem" style="list-style-type: disc">Using WebView to embed web content in your application with RubyMotion</li></ul></div><p>In the next chapter we will focus on a pivotal part of the software development lifecycle, which is testing. We will learn how to write test cases for the RubyMotion project and test our application on iOS devices.</p></div></body></html>