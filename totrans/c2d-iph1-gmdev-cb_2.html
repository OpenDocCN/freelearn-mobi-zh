<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. User Input</h1></div></div></div><p>In this chapter, we will cover the following points:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tap, hold, and drag input</li><li class="listitem" style="list-style-type: disc">Depth testing input</li><li class="listitem" style="list-style-type: disc">Creating buttons</li><li class="listitem" style="list-style-type: disc">Creating a directional pad</li><li class="listitem" style="list-style-type: disc">Creating an analog stick</li><li class="listitem" style="list-style-type: disc">Using the accelerometer for steering</li><li class="listitem" style="list-style-type: disc">Using the accelerometer for 3D rotation</li><li class="listitem" style="list-style-type: disc">Pinch zooming</li><li class="listitem" style="list-style-type: disc">Performing gestures</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec01"/>Introduction</h1></div></div></div><p>Without user input a video game is merely a tech demo. iOS touch devices allow limitless customization of user input. In this chapter, we will cover the most common input methods using both the<strong> touch screen</strong> and the<strong> accelerometer</strong>.
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec02"/>Tap, hold, and drag input</h1></div></div></div><p>
<strong>Tapping, holding</strong>, and<strong> dragging</strong> are the most commonly used input techniques. They form the basic building blocks of input for user interfaces as well as for interacting with game objects. In this recipe, we subclass<code class="literal"> CCSprite</code> in order to create a sprite which can process touch events and maintain some custom state information. This, plus some logic, allows us to touch, hold, and drag this sprite.<a id="id83" class="indexterm"/>
</p><div><img src="img/4002_02_01.jpg" alt="Tap, hold, and drag input"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec01"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec02"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id84" class="indexterm"/>
</p><div><pre class="programlisting">//ColorTouchSprite.h
enum { TS_NONE, TS_TAP, TS_HOLD, TS_DRAG };
@interface ColorTouchSprite : CCSprite
{
@public
float holdTime; //How long have we held down on this?
int touchedState; //Current touched state
bool isTouched; //Are we touching this currently?
float lastMoved; //How long has it been since we moved this?
CGPoint lastTouchedPoint; //Where did we last touch?
const float releaseThreshold = 1.0f; //How long before we recognize a release
const float holdThreshold = 0.2f; //How long before a tap turns into a hold
const float lastMovedThreshold = 0.5f; //How long before we consider you to be 'not moving'
const int dragThreshold = 3; //We have a drag threshold of 3 pixels.
}
@end
@implementation ColorTouchSprite
@synthesize touchedState;
-(id) init {
holdTime = 0; lastMoved = 0; touchedState = TS_NONE;
isTouched = NO; lastTouchedPoint = ccp(0,0);
[self schedule:@selector(step:)];
return [super init];
}
-(void) step:(ccTime)dt {
//We use holdTime to determine the difference between a tap and a hold
if(isTouched){
holdTime += dt; lastMoved += dt;
}else{
holdTime += dt;
if(holdTime &gt; releaseThreshold){
touchedState = TS_NONE;
}
}
//If you are holding and you haven't moved in a while change the state
if(holdTime &gt; holdThreshold &amp;&amp; isTouched &amp;&amp; lastMoved &gt; lastMovedThreshold){
touchedState = TS_HOLD;
}
}
/* Used to determine whether or not we touched this object */
- (CGRect) rect {
float scaleMod = 1.0f;
float w = [self contentSize].width * [self scale] * scaleMod;
float h = [self contentSize].height * [self scale] * scaleMod;
CGPoint point = CGPointMake([self position].x - (w/2), [self position].y - (h/2));
return CGRectMake(point.x, point.y, w, h);
}
/* Process touches */
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
isTouched = YES; holdTime = 0; touchedState = TS_NONE;
lastTouchedPoint = point;
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
if(!isTouched){ return; }
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
if(touchedState == TS_DRAG || distanceBetweenPoints(lastTouchedPoint, point) &gt; dragThreshold){
touchedState = TS_DRAG;
self.position = point;
lastMoved = 0;
}
lastTouchedPoint = point;
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
if(!isTouched){ return; }
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//A short hold time after a touch ended means a tap.
if(holdTime &lt; 10){
touchedState = TS_TAP;
}
holdTime = 0;
isTouched = NO;
lastTouchedPoint = point;
}
@end
#import "Helpers.h"
@implementation Ch2_TapHoldDragInput
-(CCLayer*) runRecipe {
self.isTouchEnabled = YES;
//Our message sprite
message = [CCLabelBMFont labelWithString:@"Tap, hold or drag the square." fntFile:@"eurostile_30.fnt"];
message.position = ccp(240,260);
message.scale = 0.75f;
[self addChild:message];
//Init the ColorTouchSprite
colorTouchSprite = [ColorTouchSprite spriteWithFile:@"blank.png"];
colorTouchSprite.position = ccp(240,160);
[colorTouchSprite setTextureRect:CGRectMake(0,0,100,100)];
[self addChild:colorTouchSprite];
[self schedule:@selector(step)];
return self;
}
/* Process touch events */
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//Helper function 'pointIsInRect' is defined in Helpers.h
if(pointIsInRect(point, [colorTouchSprite rect])){
[colorTouchSprite ccTouchesBegan:touches withEvent:event];
}
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec03"/>How it works...</h2></div></div></div><p>First, we create the<code class="literal"> ColorTouchSprite</code> class by sub-classing<code class="literal"> CCSprite</code>. Here is where we maintain state variables to let us differentiate between a tap, a hold, and a drag. We also specify a<code class="literal"> (CGRect)rect</code> method. This is used to determine whether or not the sprite was touched. The main recipe layer passes touch event information to this sprite using the following three methods:<a id="id85" class="indexterm"/>
</p><div><pre class="programlisting">-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
</pre></div><p>These methods are fairly straightforward. Whenever we touch the layer we call<code class="literal"> ccTouchesBegan</code>. When we move we call<code class="literal"> ccTouchesMoved</code>. Finally, when we lift a finger up we call<code class="literal"> ccTouchesEnded</code>. Each method does a<code class="literal"> pointIsInRect</code> check and then calls the requisite touches method on the sprite. Finally, the sprite runs some simple logic to determine state and to allow dragging of the sprite.
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec04"/>There's more...</h2></div></div></div><p>The technique used previously is not the only way to capture input. Cocos2d also provides the<code class="literal"> CCTouchDispatcher</code> class. With this you can implement methods in the<code class="literal"> CCTargetedTouchDelegate</code> protocol and assign a delegate object to automatically handle your touch input.<a id="id86" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec05"/>See also...</h2></div></div></div><p>For more information on this method please consult the official Cocos2d documentation and the Cocos2d forum.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Depth testing input</h1></div></div></div><p>Handling input manually like in the previous recipe gives us the opportunity to manage touchable objects at a high level. Using an array of sprites sorted by Z order we can "swallow the input" so that background sprites aren't affected.<a id="id87" class="indexterm"/>
</p><div><img src="img/4002_02_02.jpg" alt="Depth testing input"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec06"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe.<a id="id88" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">#import "ColorTouchSprite.h"
@implementation Ch2_DepthTestingInput
-(CCLayer*) runRecipe {
//Init the ColorTouchSprites
[self initSprites];
return self;
}
-(void) initSprites {
sprites = [[NSMutableArray alloc] init];
//We add 10 randomly colored sprites
for(int x=0; x&lt;10; x++){
CCSprite *sprite = [ColorTouchSprite spriteWithFile:@"blank.png"];
/* CODE OMITTED */
}
}
/* Process touch events */
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//Process input for all sprites
for(id sprite in sprites){
if(pointIsInRect(point, [sprite rect])){
//Swallow the input
[sprite ccTouchesBegan:touches withEvent:event];
return;
}
}
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
//Process input for all sprites
for(id sprite in sprites){
if(pointIsInRect(point, [sprite rect])){
[sprite ccTouchesMoved:touches withEvent:event];
}
}
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
//Process input for all sprites
for(id sprite in sprites){
//End all input when you lift up your finger
[sprite ccTouchesEnded:touches withEvent:event];
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>How it works...</h2></div></div></div><p>Our array of sprites has a<strong> node order</strong> which corresponds directly to their<strong> Z order</strong>. So, looping through these sprites does implicit<strong> depth testing</strong>. When a sprite touch begins we swallow the input allowing only that sprite to be touched.<a id="id89" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Caveats:<p>The only caveat to this technique is that input depth testing is tied to sprite array order. Any modification of sprite <strong>Z</strong> order requires a <strong>re-sorting</strong> of nodes in the array.
<a id="id90" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec04"/>Creating buttons</h1></div></div></div><p>
<strong>Buttons</strong> in one form or another are used in most games. It is easy to implement a simple button solution using Cocos2d but creating one that supports<strong> multiple simultaneous button touches</strong> is more difficult. In this recipe, we will implement a simple but effective solution to this problem.<a id="id91" class="indexterm"/>
</p><div><img src="img/4002_02_03.jpg" alt="Creating buttons"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id92" class="indexterm"/>
</p><div><pre class="programlisting">//TouchableSprite.h
@interface TouchableSprite : CCSprite
{
@public
bool pressed; //Is this sprite pressed
NSUInteger touchHash; //Used to identify individual touches
}
@end
@implementation TouchableSprite
- (bool)checkTouchWithPoint:(CGPoint)point {
if(pointIsInRect(point, [self rect])){
return YES;
}else{
return NO;
}
}
- (CGRect) rect {
//We set our scale mod to make sprite easier to press.
//This also lets us press 2 sprites with 1 touch if they are sufficiently close.
float scaleMod = 1.5f;
float w = [self contentSize].width * [self scale] * scaleMod;
float h = [self contentSize].height * [self scale] * scaleMod;
CGPoint point = CGPointMake([self position].x - (w/2), [self position].y - (h/2));
return CGRectMake(point.x, point.y, w, h);
}
- (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//We use circle collision for our buttons
if(pointIsInCircle(point, self.position, self.rect.size.width/2)){
touchHash = [touch hash];
[self processTouch:point];
}
}
- (void)ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
if(pointIsInCircle(point, self.position, self.rect.size.width/2)){
if(touchHash == [touch hash]){ //If we moved on this sprite
[self processTouch:point];
}else if(!pressed){ //If a new touch moves onto this sprite
touchHash = [touch hash];
[self processTouch:point];
}
}else if(touchHash == [touch hash]){ //If we moved off of this sprite
[self processRelease];
}
}
- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
if(touchHash == [touch hash]){ //If the touch which pressed this sprite ended we release
[self processRelease];
}
}
- (void)processTouch:(CGPoint)point {
pressed = YES;
}
buttonscreating- (void)processRelease {
pressed = NO;
}
@end
//GameButton.h
@interface GameButton : TouchableSprite {
@public
NSString* upSpriteFrame;
NSString* downSpriteFrame;
NSString* name;
}
@end
@implementation GameButton
- (void)processTouch:(CGPoint)point {
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[self setDisplayFrame:[cache spriteFrameByName:downSpriteFrame]];
pressed = true;
[self setColor:ccc3(255,200,200)];
}
- (void)processRelease {
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[self setDisplayFrame:[cache spriteFrameByName:upSpriteFrame]];
pressed = false;
[self setColor:ccc3(255,255,255)];
}
@end
@implementation Ch2_Buttons
-(CCLayer*) runRecipe {
//Init buttons data structure
buttons = [[NSMutableArray alloc] init];
//Create buttons
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[cache addSpriteFramesWithFile:@"dpad_buttons.plist"];
[self createButtonWithPosition:ccp(350,50) withUpFrame:@"b_button_up.png" withDownFrame:@"b_button_down.png" withName:@"B"];
/* CODE OMITTED */
//Schedule step method
[self schedule:@selector(step)];
return self;
}
/* Display pressed buttons */
-(void) step {
[message setString:@"Buttons pressed:"];
for(GameButton *b in buttons){
if(b.pressed){
[message setString:[NSString stringWithFormat:@"%@ %@",message.string,b.name]];
}
}
}
/* Button creation shortcut method */
-(void) createButtonWithPosition:(CGPoint)position withUpFrame:(NSString*)upFrame withDownFrame:(NSString*)downFrame withName:(NSString*)name {
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
GameButton *button = [[GameButton alloc] init];
button.position = position;
[button setUpSpriteFrame:upFrame];
[button setDownSpriteFrame:downFrame];
[button setDisplayFrame:[cache spriteFrameByName:[button upSpriteFrame]]];
button.name = name;
[self addChild:button];
[buttons addObject:button];
}
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//Pass all touchesBegan events to GameButton instances
for(GameButton *b in buttons){
[b ccTouchesBegan:touches withEvent:event];
}
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>How it works...</h2></div></div></div><p>This recipe uses a couple of different classes, all derived from<code class="literal"> CCSprite</code>, to create realistic buttons. These buttons can all be touched independently.<a id="id94" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Touching multiple buttons independently:<a id="id95" class="indexterm"/><p>To get multiple-button touching working, first we call the following method on our main <code class="literal">UIWindow</code> in our <code class="literal">AppDelegate</code> file:
</p><div><pre class="programlisting">[window setMultipleTouchEnabled:YES];
</pre></div><p>Then our <code class="literal">TouchableSprite</code> class uses the hash variable that uniquely identifies each <code class="literal">UITouch</code> object that passes through a <code class="literal">ccTouches</code> method. This way we can keep track of each unique touch. A touch can even be used to touch two buttons at once.
<a id="id96" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Touching two buttons with one touch:<p>Our <code class="literal">(CGRect)rect</code> method uses a <code class="literal">scaleMod</code> of <code class="literal">1.5f</code>. This, along with using <code class="literal">pointInCircle</code> for touch detection, allows us to press two buttons with one well placed touch. This is vital for many games. For example, the original Super Mario Brothers required the user to hold down the B button to run while pressing the A button to jump. This technique allows a similar use of the Y and A buttons.
<a id="id97" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec05"/>Creating a directional pad</h1></div></div></div><p>Another fundamental form of video game input is the<strong> directional pad</strong>. In this recipe, you will see how to create a convincing 3D-ish directional pad and you will see how to properly process directional pad information in a game situation.<a id="id98" class="indexterm"/>
</p><div><img src="img/4002_02_04.jpg" alt="Creating a directional pad"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe. Also, note that some code has been omitted for brevity.<a id="id99" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id100" class="indexterm"/>
</p><div><pre class="programlisting">#import "TouchableSprite.h"
@interface DPad : TouchableSprite {
@public
CGPoint pressedVector;
int direction;
}
@end
@implementation DPad
-(id)init {
self = [super init];
if (self != nil) {
pressedVector = ccp(0,0);
direction = DPAD_NO_DIRECTION;
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[cache addSpriteFramesWithFile:@"dpad_buttons.plist"];
//Set the sprite display frame
[self setDisplayFrame:[cache spriteFrameByName:@"d_pad_normal.png"]];
}
return self;
}
/* Process DPad touch */
- (void)processTouch:(CGPoint)point {
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
//Set a color visual cue if pressed
[self setColor:ccc3(255,200,200)];
pressed = true;
CGPoint center = CGPointMake( self.rect.origin.x+self.rect.size.width/2, self.rect.origin.y+self.rect.size.height/2 );
//Process center dead zone
if(distanceBetweenPoints(point, center) &lt; self.rect.size.width/10){
[self setDisplayFrame:[cache spriteFrameByName:@"d_pad_normal.png"]];
self.rotation = 0;
pressedVector = ccp(0,0);
direction = DPAD_NO_DIRECTION;
return;
}
//Process direction
float radians = vectorToRadians( CGPointMake(point.x-center.x, point.y-center.y) );
float degrees = radiansToDegrees(radians) + 90;
float sin45 = 0.7071067812f;
if(degrees &gt;= 337.5 || degrees &lt; 22.5){
[self setDisplayFrame:[cache spriteFrameByName:@"d_pad_horizontal.png"]];
self.rotation = 180; pressedVector = ccp(-1,0); direction = DPAD_LEFT;
}else if(degrees &gt;= 22.5 &amp;&amp; degrees &lt; 67.5){
[self setDisplayFrame:[cache spriteFrameByName:@"d_pad_diagonal.png"]];
self.rotation = -90; pressedVector = ccp(-sin45,sin45); direction = DPAD_UP_LEFT;
}/* CODE OMITTED */
}
/* Process DPad release */
- (void)processRelease {
[self setColor:ccc3(255,255,255)];
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[self setDisplayFrame:[cache spriteFrameByName:@"d_pad_normal.png"]];
self.rotation = 0;
pressed = false;
pressedVector = ccp(0,0);
direction = DPAD_NO_DIRECTION;
}
@end
@implementation Ch2_DPad
-(CCLayer*) runRecipe {
//Add gunman sprites
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[cache addSpriteFramesWithFile:@"gunman.plist"];
//Initialize gunman
gunman = [SimpleAnimObject spriteWithSpriteFrame:[cache spriteFrameByName:@"gunman_stand_down.png"]];
gunman.position = ccp(240,160);
[self addChild:gunman];
gunmanDirection = DPAD_DOWN;
//Initialize DPad
[cache addSpriteFramesWithFile:@"dpad_buttons.plist"];
dPad = [[DPad alloc] init];
dPad.position = ccp(100,100);
[self addChild:dPad];
[self schedule:@selector(step:)];
return self;
}
-(void) step:(ccTime)delta {
//We reset the animation if the gunman changes direction
if(dPad.direction != DPAD_NO_DIRECTION){
if(gunmanDirection != dPad.direction){
resetAnimation = YES;
gunmanDirection = dPad.direction;
}
}
if(gunman.velocity.x != dPad.pressedVector.x*2 || gunman.velocity.y != dPad.pressedVector.y*2){
gunman.velocity = ccp(dPad.pressedVector.x*2, dPad.pressedVector.y*2);
resetAnimation = YES;
}
//Update gunman position
[gunman update:delta];
//Re-animate if necessary
if(resetAnimation){
[self animateGunman];
}
directional padcreating}
-(void) animateGunman {
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
/* Animate our gunman */
CCAnimation *animation = [[CCAnimation alloc] initWithName:@"gunman_anim" delay:0.15f];
NSString *direction;
bool flipX = NO;
bool moving = YES;
if(gunman.velocity.x == 0 &amp;&amp; gunman.velocity.y == 0){ moving = NO; }
if(gunmanDirection == DPAD_LEFT){ direction = @"right"; flipX = YES; }
else if(gunmanDirection == DPAD_UP_LEFT){ direction = @"up_right"; flipX = YES; }
/* CODE OMITTED */
//Our simple running loop
if(moving){
[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@"gunman_run_%@_01.png",direction]]];
/* CODE OMITTED */
}
directional padcreatinggunman.flipX = flipX;
[gunman runAction:[CCRepeatForever actionWithAction: [CCAnimate actionWithAnimation:animation]]];
}
/* Process touches */
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
[dPad ccTouchesBegan:touches withEvent:event];
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>How it works...</h2></div></div></div><p>This recipe uses a few simple tricks to make a compelling directional pad effect. First, we must look at the<code class="literal"> DPad</code> class.
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal"> DPad</code> class:<a id="id103" class="indexterm"/><p>The <code class="literal">DPad</code> class determines touch direction by first creating a 2D vector from the center of the DPad image to the point where it is touched. It then divides the image into eight directional slices. Each direction corresponds to a different sprite frame. When everything is put together we get a nice looking pseudo-3D effect.
</p></li><li class="listitem" style="list-style-type: disc">Processing DPad state and<code class="literal"> pressedVector:</code><p>The <code class="literal">DPad</code> class maintains both a direction enumeration and a direction vector. This allows us to determine which of the eight directions our "gunman" sprite should be facing and how we should set his <code class="literal">velocity</code> variable to instigate movement.
</p></li><li class="listitem" style="list-style-type: disc">DPad dead zone:<a id="id104" class="indexterm"/><p>Our DPad has a roughly 10 percent <strong>dead zone</strong> right in the middle. This makes the control feel a little more natural to the user. We do this because, on a real directional pad, pressing directly in the middle results in no movement.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec06"/>Creating an analog stick</h1></div></div></div><p>By building on the last recipe, we can create a more sophisticated virtual<strong> analog stick</strong>. This input method measures vector magnitude as well as direction. We've also created a cool looking visual effect for the analog stick.<a id="id105" class="indexterm"/>
</p><div><img src="img/4002_02_05.jpg" alt="Creating an analog stick"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe.<a id="id106" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">#import "TouchableSprite.h"
//AnalogStick.h
@interface AnalogStick : TouchableSprite {
@public
CGPoint _pressedVector; //Internal _pressedVector with no outer dead zone
CCSprite *nub;
CCSprite *bar;
int direction;
}
@property (readonly) CGPoint pressedVector; //External pressedVector with a dead zone
@end
@implementation AnalogStick
-(id)init {
self = [super init];
if (self != nil) {
self.scale = 0.5f;
_pressedVector = ccp(0,0);
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[cache addSpriteFramesWithFile:@"analog_stick.plist"];
//Set the sprite display frame
[self setDisplayFrame:[cache spriteFrameByName:@"analog_pad.png"]];
//Init the bar, set position and display frame
bar = [[CCSprite alloc] init];
[bar setDisplayFrame:[cache spriteFrameByName:@"analog_bar.png"]];
[self repositionBarWithPoint:self.position];
[self addChild:bar];
//Init the nub, set position and display frame
nub = [[CCSprite alloc] init];
[self repositionNub];
[nub setDisplayFrame:[cache spriteFrameByName:@"analog_nub.png"]];
[self addChild:nub];
}
return self;
}
analog stickcreating, steps-(void)dealloc {
[nub release];
[bar release];
[super dealloc];
}
/* Process analog stick touch */
-(void)processTouch:(CGPoint)point {
self.pressed = YES;
[self setColor:ccc3(255,200,200)]; [nub setColor:ccc3(255,200,200)]; [bar setColor:ccc3(255,200,200)];
CGPoint center = CGPointMake( self.rect.origin.x+self.rect.size.width/2, self.rect.origin.y+self.rect.size.height/2 );
_pressedVector = CGPointMake((point.x-center.x)/(self.rect.size.width/2), (point.y-center.y)/(self.rect.size.height/2));
[self repositionNub];
[self repositionBarWithPoint:point];
[self resetDirection];
}
/* Process analog stick release */
-(void)processRelease {
[self setColor:ccc3(255,255,255)]; [nub setColor:ccc3(255,255,255)]; [bar setColor:ccc3(255,255,255)];
self.pressed = NO;
_pressedVector = ccp(0,0);
[self repositionNub];
[self repositionBarWithPoint:self.position];
}
/* Reposition the nub according to the pressedVector */
-(void)repositionNub {
float width = ([self contentSize].width);
float height = ([self contentSize].height);
nub.position = ccp(_pressedVector.x*(width/2)+width/2,
_pressedVector.y*(height/2)+height/2);
}
analog stickcreating, steps/* Reposition the bar according to a pressed point */
-(void)repositionBarWithPoint:(CGPoint)point {
float width = ([self contentSize].width);
float height = ([self contentSize].height);
//Rotation
float radians = vectorToRadians( _pressedVector );
float degrees = radiansToDegrees(radians);
bar.rotation = degrees;
//Set the display frame of the bar
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[bar setDisplayFrame:[cache spriteFrameByName:@"analog_bar.png"]];
//Calculate bar position
float distFromCenter = distanceBetweenPoints(point, self.position);
float sizeMod = distFromCenter / [self contentSize].width;
float oldHeight = bar.textureRect.size.height;
float newHeight = oldHeight * sizeMod * 5;
//Custom fixes
if(newHeight &lt; 100){ newHeight = 100.0f; }
if(distFromCenter &lt; 3){ newHeight = 0.0f; }
bar.textureRect = CGRectMake(bar.textureRect.origin.x,bar.textureRect.origin.y+ (oldHeight-newHeight),
bar.textureRect.size.width,newHeight );
bar.anchorPoint = ccp(0.5f,0);
CGPoint directionVector = radiansToVector(radians-PI/2);
bar.position = ccp(width/2 + directionVector.x*width/4, height/2 + directionVector.y*height/4);
}
/* Reset the direction based on the pressedVector */
-(void) resetDirection {
if(_pressedVector.x == 0 &amp;&amp; _pressedVector.y == 0){
direction = AS_NO_DIRECTION;
return;
}
analog stickcreating, stepsfloat radians = vectorToRadians(_pressedVector);
float degrees = radiansToDegrees(radians) + 90;
if(degrees &gt;= 337.5 || degrees &lt; 22.5){
direction = AS_LEFT;
}else if(degrees &gt;= 22.5 &amp;&amp; degrees &lt; 67.5){
direction = AS_UP_LEFT;
}/* CODE OMITTED */
}
-(float) magnitude {
float m = sqrt( pow(_pressedVector.x,2) + pow(_pressedVector.y,2) );
//25% end deadzone to make it easier to hold highest magnitude
m += 0.25f;
if(m &gt; 1.0f){ m = 1.0f; }
return m;
}
-(CGPoint) pressedVector {
float m = sqrt( pow(_pressedVector.x,2) + pow(_pressedVector.y,2) );
m += 0.25f;
CGPoint pv = ccp(_pressedVector.x*1.25f, _pressedVector.y*1.25f);
//25% end deadzone to make it easier to hold highest magnitude
if(m &gt; 1){
float radians = vectorToRadians(_pressedVector);
pv = radiansToVector(radians + PI/2);
}
return pv;
}
@end
@implementation Ch2_AnalogStick
-(CCLayer*) runRecipe {
self.isTouchEnabled = YES;
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
[cache addSpriteFramesWithFile:@"gunman.plist"];
//Initialize gunman
gunman = [SimpleAnimObject spriteWithSpriteFrame:[cache spriteFrameByName:@"gunman_stand_down.png"]];
gunman.position = ccp(240,160);
[self addChild:gunman];
gunman.velocity = ccp(0,0);
gunmanDirection = AS_DOWN;
//Initialize analog stick
[cache addSpriteFramesWithFile:@"analog_stick.plist"];
analogStick = [[AnalogStick alloc] init];
analogStick.position = ccp(100,100);
[self addChild:analogStick];
[self schedule:@selector(step:)];
//This sets off a chain reaction.
[self animateGunman];
return self;
}
-(void) step:(ccTime)delta {
//Set gunman velocity and animate if necessary
if(analogStick.direction != AS_NO_DIRECTION){
if(analogStick.direction != gunmanDirection){
[gunman stopAllActions];
gunmanDirection = analogStick.direction;
[self animateGunman];
}
}
gunman.velocity = ccp(analogStick.pressedVector.x*4, analogStick.pressedVector.y*4);
[gunman update:delta];
}
-(void) animateGunman {
CCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];
float speed = [analogStick magnitude];
//Animation delay is inverse speed
float delay = 0.075f/speed;
if(delay &gt; 0.5f){ delay = 0.5f; }
CCAnimation *animation = [[CCAnimation alloc] initWithName:@"gunman_anim" delay:delay];
NSString *direction;
bool flipX = NO;
bool moving = YES;
if(gunman.velocity.x == 0 &amp;&amp; gunman.velocity.y == 0){ moving = NO; }
if(gunmanDirection == AS_LEFT){ direction = @"right"; flipX = YES; }
else if(gunmanDirection == AS_UP_LEFT){ direction = @"up_right"; flipX = YES; }
/* CODE OMITTED */
//Our simple animation loop
if(moving){
[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@"gunman_run_%@_01.png",direction]]];
/* CODE OMITTED */
}
gunman.flipX = flipX;
//animateGunman calls itself indefinitely
[gunman runAction:[CCSequence actions: [CCAnimate actionWithAnimation:animation],
[CCCallFunc actionWithTarget:self selector:@selector(animateGunman)], nil ]];
}
/* Process touches */
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
[analogStick ccTouchesBegan:touches withEvent:event];
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>How it works...</h2></div></div></div><p>Using the<code class="literal"> AnalogStick</code> class provides the user with more precise control.<a id="id110" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal"> AnalogStick</code> class:<a id="id111" class="indexterm"/><p>Like the <code class="literal">DPad</code> class the <code class="literal">AnalogStick</code> class determines direction. Unlike <code class="literal">DPad</code> it also determines <strong>magnitude</strong> using the following lines:
</p><div><pre class="programlisting">CGPoint center = CGPointMake( self.rect.origin.x+self.rect.size.width/2, self.rect.origin.y+self.rect.size.height/2 );
_pressedVector = CGPointMake((point.x-center.x)/(self.rect.size.width/2), (point.y-center.y)/(self.rect.size.height/2));
</pre></div><p>This touched position also determines the position and orientation of the "nub" and the "bar". Without going into too much detail, this creates a nice analog stick visual effect. Like our <code class="literal">DPad</code> class from the previous recipe, our <code class="literal">AnalogStick</code> class also includes a dead zone.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">AnalogStick</code> dead zone:<a id="id112" class="indexterm"/><p>This time, the dead zone involves making the outer 25 percent of the touchable area max out the vector's magnitude. To achieve this we store an internal_<code class="literal">pressedVector</code> variable and give <code class="literal">readonly</code> access to a <code class="literal">pressedVector</code> property. This points to a method that does the proper calculations. The reason we provide this zone is so the user can comfortably make the 'gunman' run at top-speed.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec07"/>Using the accelerometer for steering</h1></div></div></div><p>iOS applications also have another form of input: the<strong> accelerometer</strong>. This measures the<strong> orientation</strong> of the iOS device on the<strong> X, Y</strong>, and<strong> Z planes</strong>. Device orientation is a dynamic (if slightly delayed) input mechanism with a variety of uses. One of these uses is steering in racing video games.<a id="id113" class="indexterm"/>
</p><div><img src="img/4002_02_06.jpg" alt="Using the accelerometer for steering"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">@implementation Ch2_AccelerometerSteering
-(CCLayer*) runRecipe {
//Enable the accelerometer and set its updateInterval
self.isAccelerometerEnabled = YES;
[[UIAccelerometer sharedAccelerometer] setUpdateInterval:(1.0 / 60)];
//Init car background
CCSprite *bg = [CCSprite spriteWithFile:@"car_dash.jpg"];
bg.position = ccp(240,160);
bg.opacity = 200;
[self addChild:bg z:0];
//Init steeringWheel sprite
steeringWheel = [CCSprite spriteWithFile:@"car_steering_wheel.png"];
steeringWheel.position = ccp(230,170);
[self addChild:steeringWheel z:1];
return self;
}
/* Handle accelerometer input */
- (void)accelerometer:(UIAccelerometer*)accelerometer didAccelerate:(UIAcceleration*)acceleration{
//Set steeringWheel rotation based on Y plane rotation
steeringWheel.rotation = -acceleration.y * 180;
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>How it works...</h2></div></div></div><p>Rotating your iPhone left or right while looking directly at the screen will result in seeing the steering wheel rotate. The 3D vector contained within the<code class="literal"> UIAcceleration</code> variable goes up or down by 1 for every 90 degrees the iOS device rotates. So, by multiplying this rotation by 180 degrees, we equate a 45-degree tilt with a 90-degree turn of the steering wheel.<a id="id114" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accelerometer delay:<p>Mechanically the accelerometer has a slight delay compared to the touch screen. This makes its application impractical for some gametypes where absolute split second control is required.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec08"/>Using the accelerometer for 3D rotation</h1></div></div></div><p>Using multiple accelerometer values at once can allow the user to manipulate the rotation of a 3D object in space. This is used to great effect in the Super Monkey Ball series of iOS games.<a id="id115" class="indexterm"/>
</p><div><img src="img/4002_02_07.jpg" alt="Using the accelerometer for 3D rotation"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe. Please note that the<code class="literal"> IphoneCube</code> class code was omitted from this example as it is similar to the 3D cube code in<a class="link" href="ch01.html" title="Chapter 1. Graphics"> Chapter 1</a>,
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">#import "IphoneCube.h"
@implementation Ch2_AccelerometerRotation
-(CCLayer*) runRecipe {
//Enable the accelerometer and set its updateInterval
self.isAccelerometerEnabled = YES;
[[UIAccelerometer sharedAccelerometer] setUpdateInterval:(1.0 / 60)];
//Init our textured box
iphoneCube = [[IphoneCube alloc] init];
iphoneCube.translation3D = [Vector3D x:0.0f y:0.0f z:-2.0f];
iphoneCube.rotation3DAxis = [Vector3D x:0.0f y:0.0f z:(PI/2 - 0.075f)];
[self addChild:iphoneCube z:3 tag:0];
return self;
}
/* Handle accelerometer input */
- (void)accelerometer:(UIAccelerometer*)accelerometer didAccelerate:(UIAcceleration*)acceleration{
//Set x and y box orientation
iphoneCube.rotation3DAxis.x = -acceleration.x * 180;
iphoneCube.rotation3DAxis.y = -acceleration.y * 180;
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>How it works...</h2></div></div></div><p>Rotating your device on the<strong> X</strong> or<strong> Y</strong> planes will result in rotating the virtual iPhone onscreen. We multiply the<code class="literal"> acceleration</code> variable by 180 to once again rotate our object twice as much as the device itself. The<code class="literal"> IphoneCube</code> variable<code class="literal"> rotation3DAxis</code> rotates the textured box in 3D space using<code class="literal"> glRotatef</code>.<a id="id116" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Pinch zooming</h1></div></div></div><p>Apple's touch devices popularized using two fingers to zoom in and out and this method remains the most popular way to zoom on any widely available touch screen device. In this recipe, we will see how to zoom a scene in and out by<strong> pinching</strong>.<a id="id117" class="indexterm"/>
</p><div><img src="img/4002_02_08.jpg" alt="Pinch zooming"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe. Also note that the arrow effect shown in the previous screenshot has been omitted from the following code.<a id="id118" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">#import "IphoneCube.h"
@implementation Ch2_PinchZooming
-(CCLayer*) runRecipe {
//Enable touching
self.isTouchEnabled = YES;
//Set initial variables
arrowsIn = NO;
cameraZoom = 1.0f;
lastMultiTouchZoomDistance = 0.0f;
//Init background
bg = [CCSprite spriteWithFile:@"dracula_castle.jpg"];
bg.position = ccp(240,160);
[self addChild:bg];
//Set initial zoom
[self setCameraZoom:1];
return self;
}
/* Check for HUD input */
-(bool) hudPressedWithPoint:(CGPoint)point {
//There is no HUD.
return NO;
}
-(void) setCameraZoom:(float)zoom {
cameraZoom = zoom;
bg.scale = cameraZoom;
}
/* Check touches */
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//If HUD has not been touched we reset lastMultiTouchZoomDistance
if(![self hudPressedWithPoint:point]){
lastMultiTouchZoomDistance = 0.0f;
}
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
CGSize s = [[CCDirector sharedDirector] winSize];
//Check for only 2 touches
if(touches.count == 2){
NSArray *twoTouch = [touches allObjects];
//Get both touches
UITouch *tOne = [twoTouch objectAtIndex:0];
UITouch *tTwo = [twoTouch objectAtIndex:1];
CGPoint firstTouch = [tOne locationInView:[tOne view]];
CGPoint secondTouch = [tTwo locationInView:[tTwo view]];
//If HUD hasn't been touched we use this distance and last distance to calculate zooming
if(![self hudPressedWithPoint:firstTouch] &amp;&amp; ![self hudPressedWithPoint:secondTouch]){
CGFloat currentDistance = distanceBetweenPoints(firstTouch, secondTouch);
if(lastMultiTouchZoomDistance == 0){
lastMultiTouchZoomDistance = currentDistance;
}else{
float difference = currentDistance - lastMultiTouchZoomDistance;
float newZoom = (cameraZoom + (difference*cameraZoom/s.height));
if(newZoom &lt; 1.0f){ newZoom = 1.0f; }
if(newZoom &gt; 4.0f){ newZoom = 4.0f; }
[self setCameraZoom:newZoom];
lastMultiTouchZoomDistance = currentDistance;
}
}
}
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
UITouch *touch = [touches anyObject];
CGPoint point = [touch locationInView: [touch view]];
point = [[CCDirector sharedDirector] convertToGL: point];
//If HUD has not been touched we reset lastMultiTouchZoomDistance
if(![self hudPressedWithPoint:point]){
lastMultiTouchZoomDistance = 0.0f;
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>How it works...</h2></div></div></div><p>This recipe processes two separate touches and determines their respective distance. It maintains this variable to determine whether or not the touches have grown closer or farther apart. Then, this distance is used to calculate the new zoom level. The following line of code does this while also keeping the zoom effect smooth:<a id="id119" class="indexterm"/>
</p><div><pre class="programlisting">float newZoom = (cameraZoom + (difference*cameraZoom/s.height));
</pre></div><p>This achieves the desired effect.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Processing multiple simultaneous touches:<a id="id120" class="indexterm"/><p>As you can see, processing <strong>multiple touches</strong> is similar to processing a single touch. The <code class="literal">touches</code> variable contains every touch at that specific moment. If two touches move together this one method can easily process them.
<a id="id121" class="indexterm"/>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>There's more...</h2></div></div></div><p>If you want to add to this technique, try implementing iPhoto-esque image panning. This pan/zoom combination has become standard on all document and image viewers and is a natural UI enhancement for many iOS games.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Performing gestures</h1></div></div></div><p>
<strong>Gestures</strong> can act as functional input shortcuts. Simple gestures like swiping and scrolling are built into many Apple UI tools. Some games, notably Castlevania: Dawn of Sorrow (DS) and Okami (PS2, Wii) use gestures as core gameplay mechanics. In this recipe, we will implement a simple and admittedly crude gesture system.<a id="id122" class="indexterm"/>
</p><div><img src="img/4002_02_09.jpg" alt="Performing gestures"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection01</em> for full working code of this recipe. Also note that the<code class="literal"> GestureLine</code> and<code class="literal"> GestureShapeLayer</code> classes have been omitted for brevity.<code class="literal"> GestureLine</code> simply contains two<code class="literal"> CGPoint</code> structures.<code class="literal"> GestureShapeLayer</code> draws a circle or an array of lines.
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id123" class="indexterm"/>
</p><div><pre class="programlisting">#import "GestureLine.h"
#import "GestureShapeLayer.h"
@implementation Ch2_Gestures
-(CCLayer*) runRecipe {
//Init message
message = [CCLabelBMFont labelWithString:@"Draw a rectangle, triangle, circle or line" fntFile:@"eurostile_30.fnt"];
message.position = ccp(200,270);
message.scale = 0.65f;
[message setColor:ccc3(255,0,0)];
[self addChild:message z:3];
//Allow touching
self.isTouchEnabled = YES;
//Set font size
[CCMenuItemFont setFontSize:20];
//Add our breadcrumbs node
[self addBreadcrumbs];
//Init GestureShapeLayer
gestureShapeLayer = [[GestureShapeLayer alloc] init];
gestureShapeLayer.position = ccp(0,0);
[self addChild:gestureShapeLayer z:1];
return self;
}
/* Process touches */
-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
//Start a new gesture
[self newGestureWithPoint:point];
}
-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
//Add a point to our current gesture
[self addGesturePoint:point override:NO];
}
-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
/* CODE OMITTED */
//Finish our gesture
[self finishGestureWithPoint:point];
}
-(void) newGestureWithPoint:(CGPoint)point {
[self resetMessage];
//Init gesture variables
gestureShapeLayer.points = [[NSMutableArray alloc] init];
gestureShapeLayer.lines = [[NSMutableArray alloc] init];
firstPoint = point;
lastPoint = point;
vertex = point;
[gestureShapeLayer.points addObject:[NSValue valueWithCGPoint:point]];
gestureShapeLayer.drawCircle = NO;
gestureShapeLayer.drawLines = NO;
}
-(void) addGesturePoint:(CGPoint)point override:(bool)override {
//Set our angle change tolerance to 40 degrees. If it changes more than this we consider this a 'line'
float angleDiffTolerance = 40.0f;
//Check the old angle versus the new one
CGPoint vect = ccp(point.x-lastPoint.x, point.y-lastPoint.y);
float newAngle = radiansToDegrees( vectorToRadians(vect) );
//Add a line if the angle changed significantly
if(gestureShapeLayer.points.count &gt; 1){
float angleDiff = angleDifference(newAngle, angle);
if(override || (angleDiff &gt; angleDiffTolerance &amp;&amp; distanceBetweenPoints(vertex, point) &gt; 15.0f)){
[gestureShapeLayer.lines addObject:[GestureLine point1:vertex point2:point]];
vertex = point;
}
}
//Update values
angle = newAngle;
lastPoint = point;
[gestureShapeLayer.points addObject:[NSValue valueWithCGPoint:point]];
}
-(void) finishGestureWithPoint:(CGPoint)point {
[self addGesturePoint:point override:YES];
gestureShapeLayer.drawCircle = NO;
gestureShapeLayer.drawLines = NO;
//To finish gestures which require the end to be close to the beginning point we supply this distance tolerance
float lastPointTolerance = 100.0f;
//Rectangles, triangles and circles
if(distanceBetweenPoints(firstPoint, lastPoint) &lt;= lastPointTolerance){
if(gestureShapeLayer.lines.count == 4){ //4 lines
[message setString:@"Rectangle"];
gestureShapeLayer.drawLines = YES;
}else if(gestureShapeLayer.lines.count == 3){ //3 lines
[message setString:@"Triangle"];
gestureShapeLayer.drawLines = YES;
}else if(gestureShapeLayer.lines.count &lt;= 1){ //0 or 1 lines
[message setString:@"Circle"];
[gestureShapeLayer setCircleRectFromPoints];
gestureShapeLayer.drawCircle = YES;
}else{
[self resetMessage];
gestureShapeLayer.lines = [[NSMutableArray alloc] init];
}
}else{ //Lines and angles
if(gestureShapeLayer.lines.count == 1){ //1 line
[message setString:@"Line"];
gestureShapeLayer.drawLines = YES;
}else if(gestureShapeLayer.lines.count == 2){ //2 lines
[message setString:@"Angle"];
gestureShapeLayer.drawLines = YES;
}else{
[self resetMessage];
gestureShapeLayer.lines = [[NSMutableArray alloc] init];
}
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>How it works...</h2></div></div></div><p>This gesture system tracks each individual point of user input. Each pair of points creates a<strong> 2D vector</strong>. When the current vector's angle is different enough from the previous one, then we consider that this is a new vertex of a shape the user is drawing. We then take this vertex and the last one, and create a line. By storing every point and line we can determine what the user is attempting to draw.<a id="id124" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>There's more...</h2></div></div></div><p>This system, as implemented, leaves much to be desired. However, it provides the conceptual groundwork for a more complex and functional system. By looking at the succession of points in a certain light we can see patterns emerge. In this example, we looked for successive vectors with vastly different angles to determine drawn lines. Other things like curves, direction, and point distance can lead to the identification of more complex shapes.</p></div></div></body></html>