<html><head></head><body><div><h1 class="header-title">Lambdas and Delegates</h1>
                
            
            
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Click listeners using lambdas</li>
<li>Using lazy delegate in Kotlin</li>
<li>Using the observable delegate</li>
<li>Using vetoable delegate</li>
<li>Writing your own delegates</li>
<li>Using the lateinit modifier</li>
<li>Working with SharedPreferences</li>
<li>Creating a chain of multiple lets in Kotlin</li>
<li>Creating global variables</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, we will explore the functional aspects of Kotlin language. Kotlin has functional programming built in using lambdas. Java was lacking this modern language feature up until now, but it has included lambdas in Java 8. However, since most of the Android devices don't support Java 8, Android developers were not able to use this feature. In this chapter, we will go through them and will also learn about delegates. Delegates are a powerful language feature of Kotlin. So let's get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Click listeners using lambdas</h1>
                
            
            
                
<p>An onclick listener in Android are one of those things that used to take up a lot of lines, even if the important portion of the code was only one line. Kotlin simplifies Android framework a lot, and one of the best improvements is <kbd>onClickListener</kbd>. In this recipe, we will see how we can simplify the traditional lengthy click listeners with the help of lambdas.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by creating a new project in Kotlin with a blank activity in Android Studio 3+, as we won't be using any code from other recipes. You also need an intermediate understanding of Android development.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's follow the given steps to understand how to use click listener using lambdas:</p>
<ol>
<li>Let's start with creating an activity with some view, such as a button on which we can attach an <kbd>onClickListener</kbd>. Check out the following XML layout for one possible activity layout:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.design.widget.CoordinatorLayout<br/>    <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;<br/><br/>    &lt;android.support.design.widget.AppBarLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:theme="@style/AppTheme.AppBarOverlay"&gt;<br/><br/>        &lt;android.support.v7.widget.Toolbar<br/>            android:id="@+id/toolbar"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="?attr/actionBarSize"<br/>            android:background="?attr/colorPrimary"<br/>            app:popupTheme="@style/AppTheme.PopupOverlay" /&gt;<br/><br/>    &lt;/android.support.design.widget.AppBarLayout&gt;<br/><br/>    &lt;LinearLayout<br/>        <br/>        <br/>        <br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:background="@color/white"<br/>        android:orientation="vertical"<br/>        app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt;<br/><br/>        &lt;Button<br/>            android:id="@+id/btn1"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:layout_margin="8dp"<br/>            android:text="@string/button1"/&gt;<br/><br/>        &lt;Button<br/>            android:id="@+id/btn2"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:layout_margin="8dp"<br/>            android:text="@string/button2"/&gt;<br/><br/>        &lt;Button<br/>            android:id="@+id/btn3"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:layout_margin="8dp"<br/>            android:text="@string/button3"/&gt;<br/><br/>    &lt;/LinearLayout&gt;<br/><br/>&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre>
<ol start="2">
<li>The following is how our layout looks, with three buttons on which we need to attach <kbd>onClickListener</kbd>:</li>
</ol>
<div><img height="1282" width="722" src="img/dccf397f-96e8-434c-baf3-37c3b3f64ad8.jpeg"/></div>
<ol start="3">
<li>Now, let's see the code when we attach <kbd>onClickListener</kbd> to the three buttons in Java:</li>
</ol>
<pre style="padding-left: 60px">public class HelloWorldActivity extends AppCompatActivity {<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        setContentView(R.layout.activity_hello_world);<br/>        final Button btn1 = (Button) findViewById(R.id.btn1);<br/>        final Button btn2 = (Button) findViewById(R.id.btn2);<br/>        final Button btn3 = (Button) findViewById(R.id.btn3);<br/>        final Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);<br/>        setSupportActionBar(toolbar);<br/>        getSupportActionBar().setTitle("Let's click");<br/>        <strong>btn1.setOnClickListener(new View.OnClickListener() {</strong><br/><strong>            public void onClick(View v) {</strong><br/><strong>                Toast.makeText(HelloWorldActivity.this, "Button 1 has been clicked by you! One", Toast.LENGTH_SHORT).show();</strong><br/><strong>            }</strong><br/><strong>        });</strong><br/>        <strong>btn2.setOnClickListener(new View.OnClickListener() {</strong><br/><strong>            public void onClick(View v) {</strong><br/><strong>                Toast.makeText(HelloWorldActivity.this, "Button 2 has been clicked by you! Two.", Toast.LENGTH_SHORT).show();</strong><br/><strong>            }</strong><br/><strong>        });</strong><br/><strong>        btn3.setOnClickListener(new View.OnClickListener() {</strong><br/><strong>            public void onClick(View v) {</strong><br/><strong>                Toast.makeText(HelloWorldActivity.this, "Button 3 has been clicked by you! Three", Toast.LENGTH_SHORT).show();</strong><br/><strong>            }</strong><br/><strong>        });</strong><br/>    }<br/>}</pre>
<ol start="4">
<li>Did you note the amount of code we had to write just for attaching click listeners that show toasts? All this code for just three onclick listeners; now, let's see the difference it makes to write the same code in Kotlin:</li>
</ol>
<pre style="padding-left: 60px">class HelloWorldActivity2 : AppCompatActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        setSupportActionBar(toolbar)<br/>        supportActionBar?.title = "Let's click"<br/>        <strong>btn1.setOnClickListener(object : View.OnClickListener {</strong><br/><strong>            override fun onClick(v: View?) {</strong><br/><strong>                toast("Button 1 has been clicked by you! One")</strong><br/><strong>            }</strong><br/><strong>        })</strong><br/><strong>        btn2.setOnClickListener(object : View.OnClickListener {</strong><br/><strong>            override fun onClick(v: View?) {</strong><br/><strong>                toast("Button 2 has been clicked by you! Two")</strong><br/><strong>            }</strong><br/><strong>        })</strong><br/><strong>        btn3.setOnClickListener(object : View.OnClickListener {</strong><br/><strong>            override fun onClick(v: View?) {</strong><br/><strong>                toast("Button 3 has been clicked by you! Three")</strong><br/><strong>            }</strong><br/><strong>        })</strong><br/>    }<br/>}</pre>
<ol start="5">
<li>The code is certainly lesser and cleaner, thanks to Kotlin <strong>synthetic properties</strong> and <strong>Anko</strong> for toast helper function.  Now, let's try to use <strong>lambda</strong> and see what difference it makes:</li>
</ol>
<pre style="padding-left: 60px">class HelloWorldActivity2 : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        setSupportActionBar(toolbar)<br/>        supportActionBar?.title = "Let's click"<br/>        <strong>btn1.setOnClickListener({ toast("Button 1 has been clicked by you! One") })</strong><br/><strong>        btn2.setOnClickListener({ toast("Button 2 has been clicked by you! Two") })</strong><br/><strong>        btn3.setOnClickListener({ toast("Button 3 has been clicked by you! Three") })</strong><br/>    }<br/>}</pre>
<p>Whoa! All hail to the power of lambdas. Note how much code has been reduced, and it looks clean and more readable. This a large amount of boilerplate code reduction, which saves us both time and effort.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>Lambda functions are functions that are not declared but passed as an expression. In Kotlin, if a function receives an interface, we can replace it with a lambda. For example, the <kbd>setOnClickListener</kbd> function receives <kbd>View.OnClickListener</kbd>, so we can use a lambda:</p>
<pre>fun setOnClickListener(listener: (View) -&gt; Unit)<br/>someView.setOnClickListener({ view -&gt; doSomething() })</pre>
<p>Also, if there are no parameters to be passed to the lambda function, we can omit the arrow, and if the last parameter being passed is a function, we can move it outside the parentheses:</p>
<pre>someView.setOnClickListener() { doSomething() }</pre>
<p>Then, if the lambda function being passed is actually the only parameter, you can omit the parentheses completely:</p>
<pre>button.setOnClickListener { doSomething() }</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>We can use <strong>Anko</strong>, a library by Kotlin to reduce the code even further. Anko provides an <kbd>onClick()</kbd> method that accepts a lambda that gets executed <kbd>onClick</kbd> event:</p>
<pre>class HelloWorldActivity2 : AppCompatActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        setSupportActionBar(toolbar)<br/>        supportActionBar?.title = "Let's click"<br/>        <strong>btn1.onClick { toast("Button 1 has been clicked by you! One") }</strong><br/><strong>        btn2.onClick { toast("Button 2 has been clicked by you! Two") }</strong><br/><strong>        btn3.onClick { toast("Button 3 has been clicked by you! Three") }</strong><br/>    }<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Using lazy delegate in Kotlin</h1>
                
            
            
                
<p>The lazy construct is basically used for lazy initialization of properties, which is especially helpful when the object being initialized is a heavy object (takes time to initialize). Instantiating heavy objects at startup can cause visible performance drop in mobile user experience. Lazy initialization can solve our problem. In this recipe, we will learn how to use Kotlin's lazy delegate, so let's get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using Android Studio 3.0 for coding, ensure that you have the latest version downloaded.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn how to use the lazy delegate in Kotlin:</p>
<ol>
<li>First, let's see how to create a property through lazy initialization. The syntax is as follows:</li>
</ol>
<pre style="padding-left: 60px" class="graf graf--pre graf-after--p">val / var &lt;property name&gt;: &lt;Type&gt; <strong>by</strong> &lt;delegate&gt;</pre>
<ol start="2">
<li>While creating a lazy delegate, we use <kbd>by lazy</kbd>, as shown:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity : AppCompatActivity() {<br/>    private val textView : TextView by lazy {<br/>        findViewById&lt;TextView&gt;(R.id.textView) as TextView<br/>    }<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/>        textView.text="ABC"<br/>    }<br/>}</pre>
<p>The lazy delegate initializes the object on its first access and stores the value, which is then returned for subsequent accesses.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>The delegation of a property looks like this:</p>
<pre class="graf graf--pre graf-after--p">class Delegate {<br/>    <strong>operator fun getValue</strong>(<br/>            thisRef: Any?,<br/>            property: KProperty&lt;*&gt;<br/>    ): String {<br/>        // return value<br/>    }<br/><strong>    operator fun setValue</strong>(<br/>            thisRef: Any?,<br/>            property: KProperty&lt;*&gt;, value: String<br/>    ) {<br/>        // assign<br/>    }<br/>}</pre>
<p>The read operation calls the <kbd>getValue</kbd> method, and the write operation calls <kbd>setValue</kbd>.</p>
<p>There are three modes of evaluation of lazy properties:</p>
<ul>
<li><kbd>LazyThreadSafetyMode.SYNCHRONIZED</kbd>: Initialization occurs only on one thread. The rest of the threads see the cached value. It is also the default mode of initialization.</li>
<li><kbd>LazyThreadSafetyMode.PUBLICATION</kbd>: Used when synchronization of initialization delegate is not required. It can then be called from multiple threads at a time, and initialization can be performed on every thread. However, if initialization is done by one thread, it will be returned without performing initialization.</li>
<li><kbd>LazyThreadSafetyMode.NONE</kbd>: No locks are used to synchronize initialization and hence less overhead costs.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the observable delegate</h1>
                
            
            
                
<p>Previously, we saw how to work with delegated properties. In this recipe, we will learn how to work with the observable delegate. This delegate helps us observe any changes to the property. So let's get started.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA for writing code. You can use any IDE where you are able to execute Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>The observable delegates take in a default value and a construct where we have old and new values. Let's take a look at the next example:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    var a:String by Delegates.observable("",{_,oldValue,newValue -&gt;<br/>        println("old value: $oldValue, new value: $newValue ")<br/>    })<br/>    a="a"<br/>    a="b"<br/>&gt;}<br/>//Output:<strong>old value: , new value: a </strong><br/><strong>         old value: a, new value: b</strong></pre>
<p>In the preceding example, we have provided the initial value as an empty string. The construct will be executed every time we try to update the value of the <kbd>a</kbd> property. We have changed the value of <kbd>a</kbd> two times and hence we are seeing two print statements.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>The observable delegate can be especially useful in the case of <kbd>RecyclerView</kbd>, because we can use <kbd>DiffUtils</kbd> to update just the items that are updated, rather than replacing the whole list with a new one. For more information, refer to the recipe in <a href="https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e79a66d5-bec1-4560-b363-2489175de44b.xhtml" target="_blank">Chapter 4</a>, <em>Creating RecyclerView Adapter in Kotlin</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using vetoable delegate</h1>
                
            
            
                
<p><strong>Vetoable delegate</strong> is quite similar to the observable delegate, with the only difference of vetoing the change. In the observable delegate, we could get hold of new and old values whenever the observable property was changed. Let's take a look at the definition provided in Kotlin's documentation:</p>
<p>"Returns a property delegate for a read/write property that calls a specified callback function when changed, allowing the callback to veto the modification."</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for coding purposes. You can use any IDE capable of executing Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's now look at the given steps to understand the <kbd>vetoable</kbd> modifier:</p>
<ol>
<li>Let's take a quick look at an implementation of the <kbd>vetoable</kbd> delegated property:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var student:Student by Delegates.vetoable(Student(10),{property, oldValue, newValue -&gt;<br/>        if(newValue.age&gt;25){<br/>            println("Age can't be greater than 25")<br/>            return@vetoable false<br/>        }<br/>        true<br/>    })<br/>    student=Student(26)<br/>}<br/>class Student(var age:Int)</pre>
<pre style="padding-left: 60px">//Output: <strong>Age can't be greater than 25</strong></pre>
<ol start="2">
<li>As you can see, the modification is "vetoed" by the <kbd>vetoable</kbd> delegate since the age can't be greater than <kbd>25</kbd>. The new object will only be assigned if the age is less than <kbd>25</kbd>.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>Let's take a look at the vetoable delegated property declaration:</p>
<pre>inline fun &lt;T&gt; vetoable(<br/>initialValue: T, <br/>crossinline onChange: (property: KProperty&lt;*&gt;, oldValue: T, newValue: T) -&gt; Boolean<br/>): ReadWriteProperty&lt;Any?, T&gt; (source)</pre>
<p>The <kbd>vetoable()</kbd> takes an initial value, which could be an empty list, and also an <kbd>onChange</kbd> callback, which is called before the change to a property is made. The callback returns true if the change is successful and false if it is vetoed.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>Vetoable can be especially useful if you use it in the <kbd>Recyclerview</kbd> adapter. Generally, you would assign data to the list directly and may call <kbd>notifyDatasetChanged</kbd>, but this is highly inefficient, as it will result in loading all the data again. We can use vetoable to check whether the content is the same by matching the old value and new value and can veto modification if it is the same. Also, we can use <kbd>DiffUtils</kbd> to just update the data that is changed. <kbd>DiffUtils</kbd> was introduced in Android support library 26.01 and later versions, and makes <kbd>RecyclerView</kbd> much more efficient.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Writing your own delegates</h1>
                
            
            
                
<p>Delegated properties are one of the best features of Kotlin language. We have already seen observable and vetoable delegates. In this recipe, we will learn how to create our own custom delegate. As a demo example, we will create a delegate property that can only be initialized once; if done again, it should throw an exception. So let's dive into it and see how we can achieve it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA for coding purposes. You can use any IDE capable of executing Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Now, let's dive in and learn how to create our own delegates:</p>
<ol>
<li>Let's create a custom delegate named as  <kbd>SingleInitializationProperty</kbd>. This custom delegate property will throw an exception if the variable isn't initialized, and it can only be initialized once. Doing it a second time will throw an exception. Let's take a look at our custom delegate class:</li>
</ol>
<pre style="padding-left: 60px">class SingleInitializableProperty&lt;T&gt;() : ReadWriteProperty&lt;Any?, T&gt;{<br/>    private var value: T? = null<br/>    override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T {<br/>        if(value==null){<br/>            throw IllegalStateException("Variable not initialized")<br/>        }else {<br/>            return value!!<br/>        }<br/>    }<br/>    override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {<br/>        if(this.value==null){<br/>            this.value=value<br/>        }else{<br/>            throw IllegalStateException("Cannot be initialized twice")<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Now, that we have created a custom delegate, let's try to use it without initializing it in the following way:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var a:String by SingleInitializableProperty()<br/>    println(a)<br/>}</pre>
<p style="padding-left: 60px">This is the output:</p>
<pre style="padding-left: 60px">Output: <strong>Exception in thread "main" java.lang.IllegalStateException: Variable not initialized</strong></pre>
<ol start="3">
<li>Let's see another example; this time, we will first initialize it, then access it, and then again try to initialize it:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var a:String by SingleInitializableProperty()<br/>    a="first"<br/>    println(a)<br/>    a="second"<br/>}</pre>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px">Output:<strong>first</strong><br/><strong>Exception in thread "main" java.lang.IllegalStateException: Cannot be initialized twice</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>As you can see, we have implemented the <kbd>ReadWriteProperty</kbd> interface in the delegated property, which basically means our variable will be of the <kbd>var</kbd> type. If you want it to be immutable, you can implement the <kbd>ReadOnlyProperty</kbd> interface.</p>
<p>The <kbd>getValue</kbd> function takes a reference to a class and a property's metadata. The <kbd>setValue</kbd> function, in turn, receives a set value. In case of immutable property (<kbd>val</kbd>), there will be only one <kbd>getValue</kbd> function.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the lateinit modifier</h1>
                
            
            
                
<p><strong>Lateinit</strong> is an important initialization property, because if you don't want to initialize your variable in constructor, <kbd>lazy</kbd> and <kbd>lateinit</kbd> can be employed to do so. In this recipe, we will see how to use the <kbd>lateinit</kbd> modifier and how it is different from the <kbd>lazy</kbd> modifier.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for the coding purpose; you can use any IDE that can execute Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's follow the given steps to understand how the <kbd>lateinit</kbd> modifier works:</p>
<ol>
<li>In Java, we could just declare a variable beforehand and initialize it later, but Kotlin requires you to initialize it as soon as you declare it (unless you are using special modifiers). So you can do the following:</li>
</ol>
<pre style="padding-left: 60px">var student:Student?=null</pre>
<p style="padding-left: 60px">Alternatively, you can do this:</p>
<pre style="padding-left: 60px">val student=Student()</pre>
<p style="padding-left: 60px">Both ways have their drawbacks. The first way will require you to check nullability whenever you use it, and the second way of initializing will make it immutable.</p>
<ol start="2">
<li>To overcome limitations, we can use a <kbd>lateinit</kbd> modifier, with which we can declare it beforehand and initialize anywhere we want (but before we first access it). This is especially needed when you use dependency injection. Let's see an example from Kotlin documentation that uses the <kbd>lateinit</kbd> modifier to declare the variable:</li>
</ol>
<pre style="padding-left: 60px">public class MyTest {  <br/>    lateinit var subject: TestSubject<br/>    @SetUp fun setup() {  <br/>        subject = TestSubject()  <br/>    }   <br/>    @Test fun test() {  <br/>        subject.method() // dereference directly  <br/>    } <br/>}</pre>
<ol start="3">
<li>If you try to access the variable before initializing it, you will get <kbd>UninitializedPropertyAccessException</kbd>. If you are using dependency injection, here's how you would use <kbd>lateinit</kbd> with it:</li>
</ol>
<pre>@Inject<br/> lateinit var mPresenter:EducationMvpPresenter</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>Another way of initializing properties is with the <kbd>lazy</kbd> modifier; <kbd>lazy()</kbd> is basically a function that takes a lambda and returns an instance of lazy, which serves as a delegate for implementing a lazy property. Let's take a look at the next example:</p>
<pre>public class Student{ <br/>    val name: String by lazy { <br/>        “Aanand Shekhar Roy” <br/>    }<br/>}</pre>
<p>By <kbd>lazy</kbd> initialization, we postpone initialization until we first use it. The property is initialized only when we first access it, and the same value is returned for subsequent accesses. That's why it is mandatory to mark the variable immutable. This can really help us with initialization of heavy objects, which takes a lot of time. Initializing them <kbd>lazily</kbd> can improve our startup time. The only con is that you won't be able to modify it later since it is a <kbd>val</kbd> property.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with SharedPreferences</h1>
                
            
            
                
<p><strong>SharedPreferences</strong> is a persistent way of data storage in Android devices and is mostly used to save data in key-value pairs, such as the settings of an app. Kotlin makes it easier to work with shared preference using its unique language construct. In this recipe, we will see how Kotlin can help us deal with SharedPreferences easily. So let's get started.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using Android Studio 3.0 for this recipe. If you have an older version of Android Studio, either update it to 3.0 or configure Kotlin in it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To be able to define and use SharedPreferences, we follow particular steps. We will go through each step and implement this together:</p>
<ol>
<li>First, we will create a <kbd>Prefs</kbd> class that will act as a single entry to read/write from our app's SharedPreferences. This will make it easier to handle all SharedPreferences since they all will be in one place. As we know, shared preference requires context to be present, so we will pass context in the primary constructor. We will also create a single SharedPreferences object that we will use throughout the class:</li>
</ol>
<pre style="padding-left: 60px">class Prefs (mContext:Context){<br/>    val sharedPrefences=mContext.getSharedPreferences("com.ankoexamples.app",Context.MODE_PRIVATE)<br/>    val PREF_USERNAME="pref_username"<br/>}</pre>
<ol start="2">
<li>For example, we have defined a <kbd>PREF_USERNAME</kbd> SharedPreferences; here, we will store the username of the user. Now the fun part begins; remember that Kotlin has a property where we can explicitly define how to get and set the property. We will use the same thing here. Let's take a look at the given code:</li>
</ol>
<pre style="padding-left: 60px">var username:String<br/>    get() = sharedPrefences.getString(PREF_USERNAME,null)<br/>   set(value)=sharedPrefences.edit().putString(PREF_USERNAME,value).apply()</pre>
<p style="padding-left: 90px">As you can see, in the setter, we are editing the shared preference and in the getter, we are extracting the value of the shared preference.</p>
<ol start="3">
<li>Now that we have our <kbd>Prefs</kbd> class ready, we can use it in our activities, fragments, and so on. The best way to do it will be by defining it in the <kbd>Application</kbd> class and accessing is from many activities or fragments, because then we will not need to create multiple objects of the <kbd>Prefs</kbd> class. So let's create an <kbd>Application</kbd> class and a singleton instance of the <kbd>Prefs</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class App:Application() {<br/>    companion object {<br/>        var prefs: Prefs? = null<br/>    }<br/><br/>    override fun onCreate() {<br/>        prefs = Prefs(this)<br/>        super.onCreate()<br/>    }<br/>}</pre>
<p style="padding-left: 60px">We have added and placed our <kbd>prefs</kbd> variable inside the companion object to be able to use it statically. Also, now that we have placed it inside the <kbd>Application</kbd> class, we will be dealing only with a single instance of the <kbd>prefs</kbd> object.</p>
<ol start="4">
<li>We can also use the <kbd>lazy</kbd> construct to ensure that we create an object only at its first access. Doing so will also help us avoid null checks. Here's how our <kbd>App</kbd> class will look:</li>
</ol>
<pre style="padding-left: 60px">val prefs: Prefs by lazy {<br/>    App.prefs!!<br/>}<br/>class App:Application() {<br/>    companion object {<br/>        var prefs: Prefs? = null<br/>    }<br/>    override fun onCreate() {<br/>        prefs = Prefs(this)<br/>        super.onCreate()<br/>    }<br/>}</pre>
<ol start="5">
<li>Let's now look at an example to add a value to our SharedPreferences:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/> <strong>       prefs.username=</strong><strong>"Aanand"</strong><br/>    }<br/>}</pre>
<ol start="6">
<li>It looks so simple to work with shared preferences now, as if we are assigning values to a variable. Accessing them is also very easy:</li>
</ol>
<pre style="padding-left: 60px">Log.d(prefs.username) // Aanand</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>As you can see, we have used the <kbd>apply()</kbd> method to save preferences, which commits the changes in the in-memory SharedPreferences immediately, but also starts an asynchronous commit to the disk; <kbd>commit()</kbd>, on the other hand, writes to persistent storage synchronously.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating a chain of multiple lets in Kotlin</h1>
                
            
            
                
<p><kbd>let</kbd> is a pretty useful function provided by Kotlin's <kbd>Standard.kt</kbd> library. It is basically a scoping function that allows you declare the variable in its scope. Let's take a look at the given code:</p>
<pre>someVariable.let{<br/>    // someVariable is present as "<em>it"<br/></em>}</pre>
<p>However, the best thing is that it can be used to avoid null checks. Earlier, you might have used the following:</p>
<pre>if(someVariable!=null){<br/>    // do something <br/>}</pre>
<p>While the preceding code is good, it's not very suited for mutating properties. The alternative is to use <kbd>?.let</kbd> (<kbd>someVariable.?let{}</kbd>), which ensures that the code block runs when the variable is not null. However, what if we have multiple if-not-null chains? Let's see how to deal with those cases in this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA to write code. You can use any IDE that is capable of executing the Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Follow the mentioned steps to understand how to create a chain of multiple lets:</p>
<ol>
<li>When you have to do multiple null-checks, you can obviously use nested <kbd>if-else</kbd>, checking null conditions, as in the following code:</li>
</ol>
<pre style="padding-left: 60px">if(variableA!=null){<br/>    if(variableB!=null){<br/>        if(variableC!=null){<br/>            // do something.<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Since we know that the <kbd>let</kbd> function guarantees that the block will run only when the object is not-null, we need to create a function that will perform the function of <kbd>let</kbd> but on three variable scenarios. Let's take a look at our function:</li>
</ol>
<pre style="padding-left: 60px">fun &lt;T1: Any, T2: Any,T3:Any, R: Any&gt; multiLet(p1: T1?, p2: T2?,p3:T3?, block: (T1, T2,T3)-&gt;R?): R? {<br/>    return if (p1 != null &amp;&amp; p2 != null &amp;&amp;p3!=null) block(p1, p2,p3) else null<br/>}</pre>
<ol start="3">
<li>Now we can use it as illustrated:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var variableA="a"<br/>    var variableB="c"<br/>    var variableC="b"<br/>    multiLet(variableA,variableB,variableC){<br/>        _,_,_-&gt;<br/>        println("Everything not null")<br/>    }<br/>}<br/><br/>//Output: <strong>Everything not null</strong></pre>
<ol start="4">
<li>In a similar way, it can be employed for two variable scenarios. You might be thinking how to do it in a multi-object scenario, like in the case of a list. Let's create a <kbd>whenAllNotNull</kbd> function, which will run the block of code only when all the elements of the list are not null:</li>
</ol>
<pre style="padding-left: 60px">var nonNullList=listOf("a","b","c")<br/>nonNullList.whenAllNotNull {<br/>    println("all not null")<br/>}<br/>fun &lt;T: Any, R: Any&gt; Collection&lt;T?&gt;.whenAllNotNull(block: (List&lt;T&gt;)-&gt;R) {<br/>    if (this.all { it != null }) {<br/>        block(this.filterNotNull())<br/>    }<br/>}<br/><br/>Output:<strong> all not null</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating global variables</h1>
                
            
            
                
<p>In Java, we could create a global variable just by defining the variable at the beginning of class declaration and initializing it afterward. By just declaring it, we could use it as a global variable.</p>
<p>In this recipe, we will learn how to create and use a global variable in Kotin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ for coding purposes. You can use any IDE where you can write and execute Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Now, let's look at how to create global variables in Kotlin. There are two ways to do it. Let's look at them one by one:</p>
<ol>
<li>One way to do it is by declaring it under the class declaration. We can use <kbd>var</kbd> declaration, like this:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var student:Student?=null<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">However, this approach will result in testing for nullability whenever you use it:</p>
<pre style="padding-left: 60px">println(student?.age)</pre>
<ol start="2">
<li class="mce-root">To prevent this, you can declare and initialize it using <kbd>val</kbd>, but that will result in an immutable variable, which might not be the desired behavior.</li>
<li>Another way to declare a global variable is by using the <kbd>lateinit</kbd> modifier. Here's how the preceding code will look:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    lateinit var student:Student<br/>    student=Student()<br/>    println(student.age)<br/>}</pre>
<ol start="4">
<li> The <kbd>lateinit</kbd> modifier is used to first declare the variable, without needing it to be defined either null or immutable. However, we need to initialize it before we use it; otherwise, it will throw an <kbd>UninitializedPropertyAccessException</kbd>.</li>
</ol>
<p>The <kbd>lateinit</kbd> modifier doesn't work with primitive types.</p>
<ol start="5">
<li><kbd>lateinit</kbd> can also be useful when you try to initialize the variables using dependency injection. This way, you avoid null checks when referencing the property inside the body of a class.</li>
</ol>
<p> </p>


            

            
        
    </div>



  </body></html>