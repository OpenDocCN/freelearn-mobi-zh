<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-92"><a id="_idTextAnchor101" class="calibre3 pcalibre pcalibre1"/>8</h1>
<h1 id="_idParaDest-93" class="calibre6"><a id="_idTextAnchor102" class="calibre3 pcalibre pcalibre1"/>Persisting Data Locally and Doing Background Work</h1>
<p class="calibre4">To provide better user experiences, we must ensure that apps don’t fetch data every time the user opens the app. At times, the user can be in areas that do not have internet access, and this can be very frustrating when the user can’t use your app in such situations. For such scenarios, we have to store data locally. We also have to store and update the data in an efficient way that doesn’t drain the device’s battery or block the user from doing other things on the app. In this chapter, we will be exploring how to do so for our apps.</p>
<p class="calibre4">In this chapter, we will learn how to save data to a local database, <strong class="bold">Room</strong>, which is part of the Jetpack libraries. We will be able to save items and read from the Room database. Additionally, we will learn how to do long-running operations using <strong class="bold">WorkManager</strong> and some of the best practices.</p>
<p class="calibre4">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre16">
<li class="calibre15">Saving and reading data from a local database</li>
<li class="calibre15">Handling updates and migrations in the Room database</li>
<li class="calibre15">Using WorkManager to schedule background tasks</li>
<li class="calibre15">Testing your workers</li>
</ul>
<h1 id="_idParaDest-94" class="calibre6"><a id="_idTextAnchor103" class="calibre3 pcalibre pcalibre1"/>Technical requirements</h1>
<p class="calibre4">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1">https://developer.android.com/studio</a>) downloaded.</p>
<p class="calibre4">You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight" class="calibre3 pcalibre pcalibre1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight</a>.</p>
<h1 id="_idParaDest-95" class="calibre6"><a id="_idTextAnchor104" class="calibre3 pcalibre pcalibre1"/>Saving and reading data from a local database</h1>
<p class="calibre4">We are going to build up on the Pets app, which displays a list of cute cats. <a id="_idTextAnchor105" class="calibre3 pcalibre pcalibre1"/>We will save our cute cats in a local database, Room, which is a part of the Android Jetpack libraries and provides a wrapper and <a id="_idIndexMarker387" class="calibre3 pcalibre pcalibre1"/>abstraction layer over SQLite. We <a id="_idIndexMarker388" class="calibre3 pcalibre pcalibre1"/>will also use the <code>ViewModel</code>. The Room database provides an abstraction layer over SQLite to allow fluent <a id="_idIndexMarker389" class="calibre3 pcalibre pcalibre1"/>database access while harnessing the full power of SQLite. It also has inbuilt support for Kotlin coroutines and flows to allow for asynchronous database access. Room is also compile-time safe and hence any errors in SQL queries are caught at compile time. It allows us to do all this with concise code.</p>
<p class="calibre4">To use Room in our project, we need to add its dependency to our <code>libs.versions.toml</code> file. Let us start by defining the Room version in the <code>versions</code> section as the following:</p>
<pre class="source-code">
room = "2.5.2"</pre> <p class="calibre4">Next, let us add the dependencies in our <code>libraries</code> section:</p>
<pre class="source-code">
room-runtime = { module = "androidx.room:room-runtime" , version.ref = "room" }
room-compiler = { module = "androidx.room:room-compiler", version.ref = "room" }
room-ktx = { module = "androidx.room:room-ktx", version.ref = "room" }</pre> <p class="calibre4">Sync the project for the changes to be added. Before we add these dependencies to the app level <code>build.gradle.kts</code> file, we need to set up an annotation processor for the room compiler. Room<a id="_idIndexMarker390" class="calibre3 pcalibre pcalibre1"/> uses the <code>build.gradle.kts</code> file:</p>
<pre class="source-code">
id("com.google.devtools.ksp") version "1.9.0-1.0.13" apply false</pre> <p class="calibre4">We have added the <code>build.gradle.kts</code> file:</p>
<pre class="source-code">
id("com.google.devtools.ksp")</pre> <p class="calibre4">This allows us to use<a id="_idIndexMarker394" class="calibre3 pcalibre pcalibre1"/> KSP in our app module. To finalize setting up Room, now let us add the dependencies we declared earlier to the app level <code>build.gradle.kts</code> file:</p>
<pre class="source-code">
implementation(libs.room.runtime)
implementation(libs.room.ktx)
ksp(libs.room.compiler)</pre> <p class="calibre4">We have added our Room dependencies and the Room KTX library with the <code>implementation</code> configuration and the Room compiler with the <code>ksp</code> configuration. We are now ready to start using Room in our project. Let us start by creating an entity class for our <code>Cat</code> object. This will be the data class that will be used to store our pets in the database. Inside the <code>data</code> package, create a new file called <code>CatEntity.kt</code> and add the following code:</p>
<pre class="source-code">
@Entity(tableName = "Cat")
data class CatEntity(
    @PrimaryKey
    val id: String,
    val owner: String,
    val tags: List&lt;String&gt;,
    val createdAt: String,
    val updatedAt: String
)</pre> <p class="calibre4">This data class represents the Room table for our cats. The <code>@Entity</code> annotation is used to define the table for our cats. We have passed the <code>tableName</code> value to specify the name of our table. The <code>@PrimaryKey</code> annotation is used to define the <code>tags</code>, which is a list of strings. Room provides functionality to save <a id="_idIndexMarker397" class="calibre3 pcalibre pcalibre1"/>non-primitive types using the <code>@TypeConverter</code> annotation. Let us create a new file named <code>PetsTypeConverters.kt</code> and add the following code:</p>
<pre class="source-code">
class PetsTypeConverters {
    @TypeConverter
    fun convertTagsToString(tags: List&lt;String&gt;): String {
        return Json.encodeToString(tags)
    }
    @TypeConverter
    fun convertStringToTags(tags: String): List&lt;String&gt; {
        return Json.decodeFromString(tags)
    }
}</pre> <p class="calibre4">This class has two functions annotated with the <code>@TypeConverter</code> annotation. The first function converts a list of strings to a string. The second function converts a string to a list of strings. We have used the Kotlinx serialization library to convert the list of strings to a string and vice versa. This class will be referenced in our database class that we will create shortly.</p>
<p class="calibre4">We are now ready to create our database. We need to create a <code>data</code> package, create a new file called <code>CatDao.kt</code> and add the following code:</p>
<pre class="source-code">
@Dao
interface CatDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(catEntity: CatEntity)
    @Query("SELECT * FROM Cat")
    fun getCats(): Flow&lt;List&lt;CatEntity&gt;&gt;
}</pre> <p class="calibre4">The interface is annotated with the <code>@Dao</code> annotation to tell Room that we will use this class as our DAO. We have defined two functions in our DAO. The <code>insert</code> function is used to insert a cat into our database. Notice that this is a <code>suspend</code> function. This is because we will be using coroutines to insert the cats into our database. Inserting items into the database needs to happen on a background thread since it is a resource-intensive operation. We also use the <code>@Insert</code> annotation with the <code>onConflict</code> parameter set to <code>OnConflictStrategy.REPLACE</code>. This tells Room to replace the cat if it already exists in the database. The <code>getCats</code> function is used to get all the cats from our database. It has the <code>@Query</code> annotation, which is used to define a query to get the cats from our database. We are using <code>Flow</code> to return the cats from our database. <code>Flow</code> is a stream of data that can be observed. This means that every time we update the database, the changes will be emitted to the view layers immediately without us doing any extra work. Cool, right?</p>
<p class="calibre4">We now need to create our database class. Inside the <code>data</code> package, create a new file called <code>CatDatabase.kt</code> and add the following code:</p>
<pre class="source-code">
@Database(
    entities = [CatEntity::class],
    version = 1
)
@TypeConverters(PetsTypeConverters::class)
abstract class CatDatabase: RoomDatabase() {
    abstract fun catDao(): CatDao
}</pre> <p class="calibre4">We have defined an abstract class that extends the <code>RoomDatabase</code> class. We passed the <code>entities</code> parameter to specify the entities or tables stored in our database. We have also passed the <code>version</code> parameter to specify the version of our database. We have used the <code>@TypeConverters</code> annotation to specify the type converters that we will be using in our database. We <a id="_idIndexMarker401" class="calibre3 pcalibre pcalibre1"/>have also defined an abstract method that returns our <code>CatDao</code>. We need to provide an instance of the database to classes that need it. We will do this by using the<a id="_idIndexMarker402" class="calibre3 pcalibre pcalibre1"/> dependency injection pattern we have been using in our project. Let us head over to the <code>di</code> package and in the <code>Module.kt</code> file, add the Room dependency just below the Retrofit dependency:</p>
<pre class="source-code">
single {
    Room.databaseBuilder(
        androidContext(),
        CatDatabase::class.java,
        "cat-database"
    ).build()
}
single { get&lt;CatDatabase&gt;().carDao() }</pre> <p class="calibre4">First, we have created a single instance of our database. We have used the <code>databaseBuilder</code> method to create our database. We have passed the <code>androidContext()</code> method from Koin to get the context of our application. We have also passed <code>CatDatabase::class.java</code> to specify the class of our database. We have also passed the <code>name</code> of our database. We have then created a single instance of our <code>CatDao</code>. We are using the <code>get</code> method to get the instance of our database and then calling the <code>catDao</code> function to get our <code>CatDao</code>.</p>
<p class="calibre4">Our database is now ready to be used in our repository. We are going to modify <code>PetRepository</code> and its implementation to be able to do the following:</p>
<ul class="calibre16">
<li class="calibre15">Save items to our database</li>
<li class="calibre15">Read items from our database</li>
<li class="calibre15">Change our <strong class="source-inline1">getPets()</strong> function<a id="_idIndexMarker403" class="calibre3 pcalibre pcalibre1"/> to return a <strong class="source-inline1">Flow</strong> of pets</li>
</ul>
<p class="calibre4">The modified <code>PetRepository.kt</code> file should look like the following:</p>
<pre class="source-code">
interface PetsRepository {
    suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt;
    suspend fun fet<a id="_idTextAnchor106" class="calibre19 pcalibre pcalibre1"/>chRemotePets()
}</pre> <p class="calibre4">We have modified the <code>getPets</code> function to return a <code>Flow</code> of pets. Room does not allow database access on the main thread, therefore, our queries have to be asynchronous. Room <a id="_idIndexMarker404" class="calibre3 pcalibre pcalibre1"/>provides support for observable queries that read data from our database every time data in our database changes and emits new values to reflect the changes. This is the reason we return a <code>Flow</code> instance type from the <code>getPets</code> function. We have also added the <code>fetchRemotePets</code> function to fetch the pets from the remote data source. Let us now modify <code>PetRepositoryImpl.kt</code> with a few changes:</p>
<pre class="source-code">
class PetsRepositoryImpl(
    private  val catsAPI: CatsAPI,
    private val dispatcher: CoroutineDispatcher,
    private val catDao: CatDao
): PetsRepository {
    override suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt; {
        return withContext(dispatcher) {
           catDao.getCats()
               .map { petsCached -&gt;
                   petsCached.map { catEntity -&gt;
                       Cat(
                           id = catEntity.id,
                           owner = catEntity.owner,
                           tags = catEntity.tags,
                           createdAt = catEntity.createdAt,
                           updatedAt = catEntity.updatedAt
                       ) }
               }
               .onEach {
                     if (it.isEmpty()) {
                          fetchRemotePets()
                     }
               }
        }
    }
    override suspend fun fetchRemotePets() {
        withContext(dispatcher) {
            val response = catsAPI.fetchCats("cute")
            if (response.isSuccessful) {
                response.body()!!.map {
                    catDao.insert(CatEntity(
                        id = it.id,
                        owner = it.owner,
                        tags = it.tags,
                        createdAt = it.createdAt,
                        updatedAt = it.updatedAt
                    ))
                }
            }
        }
    }
}</pre> <p class="calibre4">We have made the following changes:</p>
<ul class="calibre16">
<li class="calibre15">We have added the <strong class="source-inline1">catDao</strong> property to the constructor of the class.</li>
<li class="calibre15">We have modified the <strong class="source-inline1">getPets</strong> function to return a <strong class="source-inline1">Flow</strong> of pets. Additionally, we<a id="_idIndexMarker405" class="calibre3 pcalibre pcalibre1"/> have added a <strong class="source-inline1">map</strong> operator to map <strong class="source-inline1">CatEntity</strong> to a <strong class="source-inline1">Cat</strong> object. We have<a id="_idIndexMarker406" class="calibre3 pcalibre pcalibre1"/> also added an <strong class="source-inline1">onEach</strong> operator to check if the list of pets is empty. If it is empty, we call the <strong class="source-inline1">fetchRemotePets</strong> function to fetch the pets from the remote data source. This provides an <strong class="bold">offline first experience</strong> to our<a id="_idIndexMarker407" class="calibre3 pcalibre pcalibre1"/> users; that is, we first check if we have the data in our database and if we don’t, we fetch it from the remote data source.</li>
<li class="calibre15">Lastly, we have modified the <strong class="source-inline1">fetchRemotePets</strong> function that fetches the pets from the remote data source. When the response is successful, we map the response to a <strong class="source-inline1">CatEntity</strong> instance type and insert it into our database.</li>
</ul>
<p class="calibre4">We need to update the <code>PetsRepository</code> dependency in our <code>Module.kt</code> file to add the <code>CatDao</code> dependency:</p>
<pre class="source-code">
single&lt;PetsRepository&gt; { PetsRepositoryImpl(get(), get(), get()) }</pre> <p class="calibre4">In our <code>PetsRepositoryImpl</code> class, we have been able to read and fetch data from the Room database. Next, we are going to modify the <code>getPets()</code> function in <code>PetsViewModel</code> to <a id="_idIndexMarker408" class="calibre3 pcalibre pcalibre1"/>accommodate these new changes. Head<a id="_idIndexMarker409" class="calibre3 pcalibre pcalibre1"/> over to the <code>PetsViewModel.kt</code> file and modify the <code>getPets()</code> function to look like the following:</p>
<pre class="source-code">
private fun getPets() {
    petsUIState.value = PetsUIState(isLoading = true)
    viewModelScope.launch {
        petsRepository.getPets().asResult().collect { result -&gt;
            when (result ) {
                is NetworkResult.Success -&gt; {
                    petsUIState.update {
                        it.copy(isLoading = false, pets = result.data)
                    }
                }
                is NetworkResult.Error -&gt; {
                    petsUIState.update {
                        it.copy(isLoading = false, error = result.error)
                    }
                }
            }
        }
    }
}</pre> <p class="calibre4">We have made a few minor changes. We have used the <code>asResult()</code> extension function to convert the <code>Flow</code> of pets to a <code>Flow</code> of <code>NetworkResult</code>. This is because we are now returning a <code>Flow</code> of pets from our repository. The rest of the code remains the same as <a id="_idIndexMarker410" class="calibre3 pcalibre pcalibre1"/>before. We will get an error since we have not <a id="_idIndexMarker411" class="calibre3 pcalibre pcalibre1"/>created the <code>asResult() </code>extension function. Let us create it in our <code>NetworkResult.kt</code> file:</p>
<pre class="source-code">
fun &lt;T&gt; Flow&lt;T&gt;.asResult(): Flow&lt;NetworkResult&lt;T&gt;&gt; {
    return this
        .map&lt;T, NetworkResult&lt;T&gt;&gt; {
            NetworkResult.Success(it)
        }
        .catch { emit(NetworkResult.Error(it.message.toString())) }
}</pre> <p class="calibre4">This is an extension function on the <code>Flow</code> class. It maps a <code>Flow</code> of items to the <code>NetworkResult</code> class. We can now head back to our <code>PetsViewModel</code> class and add the extension function imports to resolve the error.</p>
<p class="calibre4">The last change we need to make is to provide the application context to our Koin instance in the <code>Application</code> class. Head over to the <code>ChapterEightApplication.kt</code> file and modify the <code>startKoin</code> block to the following:</p>
<pre class="source-code">
startKoin {
    androidContext(applicationContext)
    modules(appModules)
}</pre> <p class="calibre4">We have provided the application context to our Koin instance. Now, we can run the app. You should see the list of cute cats.</p>
<div><div><img alt="Figure 8.1 – Cute cats" src="img/B19779_08_01.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Cute cats</p>
<p class="calibre4">The app still works as before, but now we are reading items from the Room database. If you turn off your data and Wi-Fi, the app still shows the list of cute cats! Amazing, isn’t it? We have been <a id="_idIndexMarker412" class="calibre3 pcalibre pcalibre1"/>able to make the app work offline. One of the benefits of having an architecture in place for our app is that we can change the different layers without necessarily affecting the other layers. We have been able to change the data source from the remote data <a id="_idIndexMarker413" class="calibre3 pcalibre pcalibre1"/>source to the local data source without affecting the view layer. This is the power of having a good architecture in place.</p>
<p class="calibre4">We know how to insert and <a id="_idIndexMarker414" class="calibre3 pcalibre pcalibre1"/>read data from our Room database, but what about updating it? In the next section, we will learn how to update the data that is in our Room database. In<a id="_idIndexMarker415" class="calibre3 pcalibre pcalibre1"/> the process, we will also learn how to migrate from one<a id="_idIndexMarker416" class="calibre3 pcalibre pcalibre1"/> database version to the other using the Room <strong class="bold">automated </strong><strong class="bold">migration</strong> feature.</p>
<h1 id="_idParaDest-96" class="calibre6"><a id="_idTextAnchor107" class="calibre3 pcalibre pcalibre1"/>Handling updates and migrations in the Room database</h1>
<p class="calibre4"><code>FavoritePetsScreen</code> doesn’t have any functionality yet. We are going to add the functionality to favorite pets and <a id="_idIndexMarker417" class="calibre3 pcalibre pcalibre1"/>update this information in the Room database. To achieve this, we need to do the following:</p>
<ul class="calibre16">
<li class="calibre15">Set up a Room schema directory.</li>
<li class="calibre15">Add a new column to our <strong class="source-inline1">CatEntity</strong> class to store the favorite status of the cat.</li>
<li class="calibre15">Add a new function to <strong class="source-inline1">CatDao</strong> to update the favorite status of the cat.</li>
<li class="calibre15">Update our UIs with a favorite icon and, once clicked, update the favorite status of the cat. This means the ViewModel and repository classes will also be updated in the process.</li>
</ul>
<p class="calibre4">Let’s get started with the steps:</p>
<ol class="calibre14">
<li class="calibre15">Let us start by setting up the schema directory. In our app level <strong class="source-inline1">build.gradle.kts</strong> file, add the following code:<pre class="source-code">
ksp {
    arg("room.schemaLocation", "$projectDir/schemas")
}</pre><p class="calibre4">Do a Gradle sync and then build the project. This generates a <code>schema json</code> file with the name <a id="_idIndexMarker418" class="calibre3 pcalibre pcalibre1"/>of the current database version as shown in the following figure:</p></li> </ol>
<div><div><img alt="Figure 8.2 – Room schema directory" src="img/B19779_08_02.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Room schema directory</p>
<p class="calibre4">As shown in the preceding image, you have to switch to the <code>CatEntity</code> interface to store the favorite status of the cat.</p>
<ol class="calibre14">
<li value="2" class="calibre15">We will add this field to the <strong class="source-inline1">CatEntity</strong> and the <strong class="source-inline1">Cat</strong> data classes. Head over to the <strong class="source-inline1">CatEntity.kt</strong> file and add a new field called <strong class="source-inline1">isFavorite</strong>:<pre class="source-code">
@ColumnInfo(defaultValue = "0")
val isFavorite: Boolean = false</pre><p class="calibre4">This is a Boolean whose default value is <code>false</code>. We have used the <code>@ColumnInfo</code> annotation to<a id="_idIndexMarker419" class="calibre3 pcalibre pcalibre1"/> specify the default value of the column in our database, too. We will use this field to store the favorite status of the cat. Ensure you add the <code>val isFavorite: Boolean = false</code> field to the <code>Cat</code> data class, too. We now need to update our <code>CatDao</code> class to be able to update the favorite status of the cat.</p></li> <li class="calibre15">Let us head over to the <strong class="source-inline1">CatDao.kt</strong> file and add the following functions:<pre class="source-code">
@Update
suspend fun update(catEntity: CatEntity)
@Query("SELECT * FROM Cat WHERE isFavorite = 1")
fun getFavoriteCats(): Flow&lt;List&lt;CatEntity&gt;&gt;</pre><p class="calibre4">We have two functions here. The first function will be used to update the favorite status of the cat. We have used the <code>@Update</code> annotation to tell Room that this function will be used to update the <code>CatEntity</code> class in our database. The second function will be used to get the favorite cats from our database. We have used the <code>@Query</code> annotation to define the query to get the favorite cats from our database. We have used <code>Flow</code> to return the favorite cats from our database. Now, we need to add a migration to our database to add the new column to our database. This ensures that we don’t lose any data when we update our database. <strong class="bold">Room version 2.4.0-alpha01</strong> introduced <a id="_idIndexMarker420" class="calibre3 pcalibre pcalibre1"/>a new way of handling migrations – automated migrations. This means that we don’t have to write any SQL queries to<a id="_idIndexMarker421" class="calibre3 pcalibre pcalibre1"/> handle migrations; Room will automatically handle the migrations for us.</p></li> <li class="calibre15">Let us modify <strong class="source-inline1">CatDatabase</strong> to add <strong class="source-inline1">autoMigration</strong> as follows:<pre class="source-code">
@Database(
    entities = [CatEntity::class],
    version = 2,
    autoMigrations = [
        AutoMigration(from = 1, to = 2)
    ]
)</pre><p class="calibre4">We have added the <code>autoMigrations</code> parameter to our database. We have passed a list of <code>AutoMigration</code> objects to the parameter. We have passed the <code>from</code> and <code>to</code> parameters to specify the version of our database. Ensure you add the imports for the <code>AutoMigration</code> class. Notice that we have also increased the <code>version</code> of our database. This is because we have added a new column to our database. Build the project to be able to generate the <code>schema json</code> file. You should see a new schema JSON file with the name of the new database version. Our schema directory should look like the following:</p></li> </ol>
<div><div><img alt="Figure 8.3 – Updated Room schema directory" src="img/B19779_08_03.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Updated Room schema directory</p>
<p class="calibre4">If we open the <code>2.json</code> file, we will notice that the new <code>isFavorite</code> column has been added to our table. That it’s for <a id="_idIndexMarker422" class="calibre3 pcalibre pcalibre1"/>automated migration. We are now ready to update our repository to be able to update the favorite status of the cat.</p>
<ol class="calibre14">
<li value="5" class="calibre15">Let us head over to the <strong class="source-inline1">PetsRepository.kt</strong> file and add the following functions:<pre class="source-code">
suspend fun updatePet(cat: Cat)
suspend fun getFavoritePets(): Flow&lt;List&lt;Cat&gt;&gt;</pre></li> </ol>
<p class="calibre4">The <code>updatePet(cat: Cat)</code> and <code>getFavoritePets()</code> functions will be used to update the favorite status <a id="_idIndexMarker423" class="calibre3 pcalibre pcalibre1"/>of the cat and get favorite cats.</p>
<ol class="calibre14">
<li class="calibre15">Let us add the implementation of the two functions in our <strong class="source-inline1">PetsRepositoryImpl.kt</strong> class:<pre class="source-code">
override suspend fun updatePet(cat: Cat) {
    withContext(dispatcher) {
        catDao.update(CatEntity(
            id = cat.id,
            owner = cat.owner,
            tags = cat.tags,
            createdAt = cat.createdAt,
            updatedAt = cat.updatedAt,
            isFavorite = cat.isFavorite
        ))
    }
}
override suspend fun getFavoritePets(): Flow&lt;List&lt;Cat&gt;&gt; {
    return withContext(dispatcher) {
        catDao.getFavoriteCats()
            .map { petsCached -&gt;
                petsCached.map { catEntity -&gt;
                    Cat(
                        id = catEntity.id,
                        owner = catEntity.owner,
                        tags = catEntity.tags,
                        createdAt = catEntity.createdAt,
                        updatedAt = catEntity.updatedAt,
                        isFavorite = catEntity.isFavorite
                    )
                }
            }
    }
}</pre><p class="calibre4">Here is an explanation of the functions:</p><ul class="calibre17"><li class="calibre15">In the <strong class="source-inline1">updatePet</strong> function, we have <a id="_idIndexMarker424" class="calibre3 pcalibre pcalibre1"/>used the update method of our <strong class="source-inline1">CatDao</strong> interface to update the favorite status of the cat. We have also used <strong class="source-inline1">withContext</strong> to ensure that the update runs on a background thread. We have created a new <strong class="source-inline1">CatEntity</strong> class from the <strong class="source-inline1">Cat</strong> object that we have passed to the function.</li><li class="calibre15">In the <strong class="source-inline1">getFavoritePets</strong> function, we have used the <strong class="source-inline1">getFavoriteCats</strong> function from our <strong class="source-inline1">CatDao</strong> interface to get the favorite cats from our database. We have also mapped the list of <strong class="source-inline1">CatEntity</strong> to a list of <strong class="source-inline1">Cat</strong>. We then returned a <strong class="source-inline1">Flow</strong> instance type of favorite cats.</li></ul></li> <li class="calibre15">In the <strong class="source-inline1">PetsRepositoryImpl.kt</strong> file, we need to update the <strong class="source-inline1">fetchRemotePets</strong> and <strong class="source-inline1">getPets</strong> functions<a id="_idIndexMarker425" class="calibre3 pcalibre pcalibre1"/> to update the favorite status of the cat as follows:<pre class="source-code">
override suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt; {
    return withContext(dispatcher) {
       catDao.getCats()
           .map { petsCached -&gt;
               petsCached.map { catEntity -&gt;
                   Cat(
                       id = catEntity.id,
                       owner = catEntity.owner,
                       tags = catEntity.tags,
                       createdAt = catEntity.createdAt,
                       updatedAt = catEntity.updatedAt,
                       isFavorite = catEntity.isFavorite
                   )
               }
           }
           .onEach {
               if (it.isEmpty()) {
                   fetchRemotePets()
               }
           }
    }
}
override suspend fun fetchRemotePets() {
    withContext(dispatcher) {
        val response = catsAPI.fetchCats("cute")
        if (response.isSuccessful) {
            response.body()!!.map {
                catDao.insert(CatEntity(
                    id = it.id,
                    owner = it.owner,
                    tags = it.tags,
                    createdAt = it.createdAt,
                    updatedAt = it.updatedAt,
                    isFavorite = it.isFavorite
                ))
            }
        }
    }
}</pre><p class="calibre4">We add the <code>isFavorite</code> parameter to the <code>Cat</code> object when we are mapping the <code>CatEntity</code> class to a <code>Cat</code>. This <a id="_idIndexMarker426" class="calibre3 pcalibre pcalibre1"/>will ensure that we have the favorite status of the cat when we are fetching the cats from the remote and local data sources.</p></li> <li class="calibre15">Let us head over to the <strong class="source-inline1">PetsViewModel</strong> class and add the following variables below the <strong class="source-inline1">petsUIState</strong> variable:<pre class="source-code">
private val _favoritePets = MutableStateFlow&lt;List&lt;Cat&gt;&gt;(emptyList())
val favoritePets: StateFlow&lt;List&lt;Cat&gt;&gt; get() = _favoritePets</pre><p class="calibre4">Here, we have created a private <code>MutableStateFlow</code> of favorite cats and a public <code>StateFlow</code> of favorite cats. We will use the <code>_favoritePets</code> variable to update the favorite cats and the <code>favoritePets</code> variable to observe the favorite cats. This pattern is normally recommended to prevent exposing mutable states to the view layer.</p></li> <li class="calibre15">Next, let us add these two <a id="_idIndexMarker427" class="calibre3 pcalibre pcalibre1"/>functions below the <strong class="source-inline1">getPets()</strong> function in the <strong class="source-inline1">PetsViewModel</strong>:<pre class="source-code">
fun updatePet(cat: Cat) {
    viewModelScope.launch {
        petsRepository.updatePet(cat)
    }
}
fun getFavoritePets() {
    viewModelScope.launch {
        petsRepository.getFavoritePets().collect {
            _favoritePets.value = it
        }
    }
}</pre><p class="calibre4">The <code>updatePet</code> function will be called from the UI to update the favorite status of the cat. The <code>getFavoritePets</code> function will be called from the UI to fetch the favorite cats from our database. We collect the favorite cats from our database and update the <code>_favoritePets</code> variable. With these changes, we are now ready to make changes to our views to be able to favorite a cat and see a list of favorite pets.</p></li> <li class="calibre15">We will start by adding our favorite icon to the <strong class="source-inline1">PetListItem</strong> composable. Let us head over to the <strong class="source-inline1">PetList.kt</strong> file and update the <strong class="source-inline1">PetListItem</strong> composable to be<a id="_idIndexMarker428" class="calibre3 pcalibre pcalibre1"/> the following:<pre class="source-code">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(
    cat: Cat,
    onPetClicked: (Cat) -&gt; Unit,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
                .clickable {
                    onPetClicked(cat)
                }
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            Row(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
                    .fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                FlowRow(
                    modifier = Modifier
                        .padding(start = 6.dp, end = 6.dp)
                ) {
                    repeat(cat.tags.size) {
                        SuggestionChip(
                            modifier = Modifier
                                .padding(start = 3.dp, end = 3.dp),
                            onClick = { },
                            label = {
                                Text(text = cat.tags[it])
                            }
                        )
                    }
                }
                Icon(
                    modifier = Modifier
                        .clickable {
                            onFavoriteClicked(cat.copy(isFavorite = !cat.isFavorite))
                        },
                    imageVector = if (cat.isFavorite) {
                        Icons.Default.Favorite
                    } else {
                        Icons.Default.FavoriteBorder
                    },
                    contentDescription = "Favorite",
                    tint = if (cat.isFavorite) {
                        Color.Red
                    } else {
                        Color.Gray
                    },
                )
            }
        }
    }
}</pre><p class="calibre4">We have added the <code>Icon</code> composable to the <code>PetListItem</code> composable. We have used the <code>Icons.Default.Favorite</code> icon if the cat is favorited and the <code>Icons.Default.FavoriteBorder</code> icon if the cat is not favorited. We have also used the <code>tint</code> parameter to change the color of the icon depending on the favorite status of the cat. <code>Icon</code> is now inside a <code>Row</code> together with <code>FlowRow</code>, which displays a <a id="_idIndexMarker429" class="calibre3 pcalibre pcalibre1"/>list of tags. We have also added the <code>onFavoriteClicked</code> parameter to the <code>PetListItem</code> composable. We have used this parameter to update the favorite status of the cat.</p></li> <li class="calibre15">Let us update the <strong class="source-inline1">PetList</strong> composable to add a new callback parameter called <strong class="source-inline1">onFavoriteClicked</strong> and pass the parameter to the <strong class="source-inline1">PetListItem</strong> composable:<pre class="source-code">
@Composable
fun PetList(
    onPetClicked: (Cat) -&gt; Unit,
    pets: List&lt;Cat&gt;,
    modifier: Modifier,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    LazyColumn(
        modifier = modifier
    ) {
        items(pets) { pet -&gt;
            PetListItem(
                cat = pet,
                onPetClicked = onPetClicked,
                onFavoriteClicked = onFavoriteClicked
            )
        }
    }
}</pre></li> <li class="calibre15">Next, we will add the <strong class="source-inline1">onFavoriteClicked</strong> callback <a id="_idIndexMarker430" class="calibre3 pcalibre pcalibre1"/>as a parameter to the <strong class="source-inline1">PetsScreenContent</strong>:<pre class="source-code">
@Composable
fun PetsScreenContent(
    modifier: Modifier,
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
    petsUIState: PetsUIState,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    // code
    }</pre></li> <li class="calibre15">We can now pass the parameter to the <strong class="source-inline1">PetList</strong> composable:<pre class="source-code">
PetList(
    onPetClicked = onPetClicked,
    pets = petsUIState.pets,
    modifier = Modifier
    .fillMaxWidth(),
    onFavoriteClicked = onFavoriteClicked
)</pre></li> <li class="calibre15">Let us update the <strong class="source-inline1">PetAndDetails</strong> composable<a id="_idIndexMarker431" class="calibre3 pcalibre pcalibre1"/> to add the <strong class="source-inline1">onFavoriteClicked</strong> parameter:<pre class="source-code">
@Composable
fun PetListAndDetails(
    pets: List&lt;Cat&gt;,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    // code
    }</pre></li> <li class="calibre15">We can now pass the parameter to the <strong class="source-inline1">PetList</strong> composable:<pre class="source-code">
PetList(
    onPetClicked = {
    currentPet = it
    },
    pets = pets,
    modifier = Modifier
    .fillMaxWidth()
    .weight(1f),
    onFavoriteClicked = onFavoriteClicked
)</pre></li> <li class="calibre15">Back in the <strong class="source-inline1">PetsScreenContent.kt</strong> file, we need to pass the <strong class="source-inline1">onFavoriteClicked</strong> parameter<a id="_idIndexMarker432" class="calibre3 pcalibre pcalibre1"/> to the <strong class="source-inline1">PetListAndDetails</strong> composable:<pre class="source-code">
PetListAndDetails(
    pets = petsUIState.pets,
    onFavoriteClicked = onFavoriteClicked
)</pre><p class="calibre4">The final <code>PetScreenContent.kt</code> file with all the changes we have made so far should look like this:</p></li> </ol>
<div><div><img alt="Figure 8.4 – Updated PetscreenContent" src="img/B19779_08_04.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Updated PetscreenContent</p>
<ol class="calibre14">
<li value="12" class="calibre15">Next, in the <strong class="source-inline1">PetsScreen</strong> composable, which<a id="_idIndexMarker433" class="calibre3 pcalibre pcalibre1"/> is in the <strong class="source-inline1">PetsScreen.kt</strong> file, we need to add the <strong class="source-inline1">onFavoriteClicked</strong> parameter to the <strong class="source-inline1">PetsScreenContent</strong> composable:<pre class="source-code">
PetsScreenContent(
    modifier = Modifier
        .fillMaxSize(),
    onPetClicked = onPetClicked,
    contentType = contentType,
    petsUIState = petsUIState,
    onFavoriteClicked = {
        petsViewModel.updatePet(it)
    }
)</pre><p class="calibre4">We have passed the <code>onFavoriteClicked</code> callback to the <code>PetsScreenContent</code> composable. We have called the <code>updatePet</code> method of our <code>PetsViewModel</code> class with<a id="_idIndexMarker434" class="calibre3 pcalibre pcalibre1"/> the updated cat object. Let us run the app; it now has a new favorite icon. If we click on the icon, the icon changes to a filled heart icon with a red color:</p></li> </ol>
<div><div><img alt="Figure 8.5 – Cute cats with favorite" src="img/B19779_08_05.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Cute cats with favorite</p>
<ol class="calibre14">
<li value="13" class="calibre15">Lastly, we are<a id="_idIndexMarker435" class="calibre3 pcalibre pcalibre1"/> going to update <strong class="source-inline1">FavoritePetsScreen</strong> to display a list of favorite cats. Let us head over to the <strong class="source-inline1">FavoritePetsScreen.kt</strong> file and update the <strong class="source-inline1">FavoritePetsScreen</strong> composable to be the following:<pre class="source-code">
@Composable
fun FavoritePetsScreen(
    onPetClicked: (Cat) -&gt; Unit
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    LaunchedEffect(Unit) {
        petsViewModel.getFavoritePets()
    }
    val pets by petsViewModel.favoritePets.collectAsStateWithLifecycle()
    if (pets.isEmpty()) {
        Column(
            modifier = Modifier
                .fillMaxSize(),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(text = "No favorite pets")
        }
    } else {
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
        ) {
            items(pets) { pet -&gt;
                PetListItem(
                    cat = pet,
                    onPetClicked = onPetClicked,
                    onFavoriteClicked = {
                        petsViewModel.updatePet(it)
                    }
                )
            }
        }
    }
}</pre><p class="calibre4">Here is an explanation<a id="_idIndexMarker436" class="calibre3 pcalibre pcalibre1"/> of the changes:</p><ul class="calibre17"><li class="calibre15">We have added a new parameter, <strong class="source-inline1">onPetClicked</strong> to the <strong class="source-inline1">FavoritePetsScreen</strong> composable. We will use this parameter to navigate to the <strong class="source-inline1">PetDetailsScreen</strong> composable.</li><li class="calibre15">We have created a new instance of our <strong class="source-inline1">PetsViewModel</strong> class using the <strong class="source-inline1">koinViewModel()</strong> method.</li><li class="calibre15">We have called the <strong class="source-inline1">getFavoritePets</strong> function from our <strong class="source-inline1">PetsViewModel</strong> class to get the favorite cats from our database. We used <strong class="source-inline1">LaunchedEffect</strong> to call this method when the composable was first launched. This is to ensure that we do not call the function every time the composable recomposes.</li><li class="calibre15">We have a new variable called <strong class="source-inline1">pets</strong>, which is a <strong class="source-inline1">StateFlow</strong> of favorite cats. We have used the <strong class="source-inline1">collectAsStateWithLifecycle</strong> method to collect the favorite cats from our database. This method is lifecycle aware and hence it will only collect the favorite cats when the composable is active.</li><li class="calibre15">We have added a check to see if the list of favorite cats is empty. If it is empty, we display a message<a id="_idIndexMarker437" class="calibre3 pcalibre pcalibre1"/> to the user. If it is not empty, we display a list of favorite cats.</li></ul></li> <li class="calibre15">We need to update the <strong class="source-inline1">AppNavigation.kt</strong> file to pass the <strong class="source-inline1">onPetClicked</strong> callback to the <strong class="source-inline1">FavoritePetsScreen</strong> composable:<pre class="source-code">
FavoritePetsScreen(
    onPetClicked = { cat -&gt;
        navHostController.navigate(
            "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
        )
    }
)</pre><p class="calibre4">This logic is like what we had in the <code>PetsScreen</code> and it handles navigation to <code>PetDetailsScreen</code> when we are in <code>FavoritePetsScreen</code>. Build and run the app. Tap the favorite icon on the bottom bar and you should see a list of your favorite cute cats. If you tap the favorite icon, the cat is immediately removed from the list of favorite cats. This is because the list of favorite cats is a <code>Flow</code> and every time Room updates the data, they are immediately emitted to the view layer.</p></li> </ol>
<div><div><img alt="Figure 8.6 – Favorite Pets Screen" src="img/B19779_08_06.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Favorite Pets Screen</p>
<p class="calibre4">We have been able to add the functionality to favorite cats and update this information in the Room database. We <a id="_idIndexMarker438" class="calibre3 pcalibre pcalibre1"/>have also been able to handle updates and migrations in the Room database. In the next section, we will see how to use WorkManager to schedule background tasks. In this case, we will use WorkManager to fetch the cats from the remote data source and save them to our database. This improves our first offline experience since we will always have the latest data in our database.</p>
<h1 id="_idParaDest-97" class="calibre6"><a id="_idTextAnchor108" class="calibre3 pcalibre pcalibre1"/>Using WorkManager to schedule background tasks</h1>
<p class="calibre4">WorkManager is a Jetpack library<a id="_idIndexMarker439" class="calibre3 pcalibre pcalibre1"/> that is best suited for performing long-running tasks in the background. It ensures that background tasks are<a id="_idIndexMarker440" class="calibre3 pcalibre pcalibre1"/> completed even when your app restarts or the phone restarts. With WorkManager, you can either schedule one-time jobs or recurring jobs.</p>
<p class="calibre4">We will start by adding the WorkManager dependency to our project. Follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Let us head over to the <strong class="source-inline1">libs.versions.toml</strong> file and define the work version in our <strong class="source-inline1">versions</strong> section as follows:<pre class="source-code">
work = "2.8.1"</pre></li> <li class="calibre15">In the libraries section, add the following dependencies:<pre class="source-code">
work-runtime = { module = "androidx.work:work-runtime-ktx", version.ref = "work" }
workmanager-koin = { module = "io.insert-koin:koin-androidx-workmanager", version.ref = "koin" }</pre><p class="calibre4">Here, we have two dependencies: the <code>work-runtime-ktx</code> dependency, which is the core dependency for WorkManager, and the <code>koin-androidx-workmanager</code> dependency, which is used to integrate WorkManager with Koin. Sync the project for the changes to be added.</p></li> <li class="calibre15">Next, we need to add the dependencies to the app-level <strong class="source-inline1">build.gradle.kts</strong> file:<pre class="source-code">
implementation(libs.work.runtime)
implementation(libs.workmanager.koin)</pre></li> <li class="calibre15">Do a Gradle sync to add these dependencies to our project.</li>
</ol>
<p class="calibre4">We are now ready to start using WorkManager in our project. We will use WorkManager to fetch the cats from the remote data source and save them to our database. We will use the <code>OneTimeWorkRequest</code> class to schedule a one-time job to fetch the cats from the remote data source and save them to our database. Let’s get started with the <a id="_idIndexMarker441" class="calibre3 pcalibre pcalibre1"/>steps:</p>
<ol class="calibre14">
<li class="calibre15">Let us create a new package named <strong class="source-inline1">workers</strong> and create a new file inside it called <strong class="source-inline1">PetsSyncWorker.kt</strong> and add the following code:<pre class="source-code">
class PetsSyncWorker(
    appContext: Context,
    workerParams: WorkerParameters,
    private val  petsRepository: PetsRepository
): CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result {
        return try {
            petsRepository.fetchRemotePets()
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
}</pre><p class="calibre4">In the preceding code block, we have created a class that implements the <code>CoroutineWorker</code> class. We<a id="_idIndexMarker442" class="calibre3 pcalibre pcalibre1"/> implement this class when we want to perform a long-running task in the background. It uses coroutines to perform long-running tasks. We have passed the <code>appContext</code> and <code>workerParams</code> parameters to the constructor of the class. We have also passed the <code>petsRepository</code> parameter to the constructor of the class. We have overridden the <code>doWork</code> method, which is a <code>suspend</code> function that will be called when the work is scheduled. We have called <code>fetchRemotePets</code> from <code>PetsRepository</code> to fetch the cats from the remote data source and save them to our database. We are also returning <code>Result.success()</code> if the work is successful and <code>Result.failure()</code> if the work fails.</p></li> <li class="calibre15">Next, let us create an instance of <strong class="source-inline1">PetsSyncWorker</strong> in our <strong class="source-inline1">Module.kt</strong> file:<pre class="source-code">
worker { PetsSyncWorker(get(), get(), get()) }</pre><p class="calibre4">We are using the <code>worker</code> Koin DSL to create an instance of <code>PetsSyncWorker</code>. This is from the<a id="_idIndexMarker443" class="calibre3 pcalibre pcalibre1"/> Koin WorkManager library that we just added. We have passed the <code>appContext</code>, <code>workerParams</code>, and <code>petsRepository</code> parameters <a id="_idIndexMarker444" class="calibre3 pcalibre pcalibre1"/>to the constructor of <code>PetsSyncWorker</code>.</p></li> <li class="calibre15">Next, let us add this function in our <strong class="source-inline1">MainActivity.kt</strong> file:<pre class="source-code">
private fun startPetsSync() {
    val syncPetsWorkRequest = OneTimeWorkRequestBuilder&lt;PetsSyncWorker&gt;()
        .setConstraints(
            Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .setRequiresBatteryNotLow(true)
                .build()
        )
        .build()
    WorkManager.getInstance(applicationContext).enqueueUniqueWork(
        "PetsSyncWorker",
        ExistingWorkPolicy.KEEP,
        syncPetsWorkRequest
    )
}</pre><p class="calibre4">In the preceding code, we created a new <code>OneTimeWorkRequest</code> using <code>PetSyncWorker</code>. We have also set some constraints o<a id="_idTextAnchor109" class="calibre3 pcalibre pcalibre1"/>n our work request. We have set the network type to <code>NetworkType.CONNECTED</code> to ensure that the work request is only executed when the device is connected to the internet. We also have other network types, which are as follows:</p><ul class="calibre17"><li class="calibre15"><code>BatteryNotLow constraint</code> to <code>true</code> to ensure that the work request is only executed when the battery is not low. We then used <code>WorkManager.getInstance(applicationContext)</code> to get an instance of the WorkManager and then called the <code>enqueueUniqueWork</code> method to enqueue our work request. We have passed the name of our work request, <code>ExistingWorkPolicy</code>, and the work request to the <code>enqueueUniqueWork</code> method. <code>ExistingWorkPolicy</code> is used to specify what should happen if there is already a work request with the same name. We have used <code>ExistingWorkPolicy.KEEP</code> to ensure that the work request is not replaced if there is already a work request with the same name. The following are other available policies:</p><ul class="calibre17"><li class="calibre15"><code>onCreate</code> method of <code>MainActivity</code>.</p></li> <li class="calibre15">In the <strong class="source-inline1">MainActivity.kt</strong> file, add the following code in the <strong class="source-inline1">onCreate</strong> method:<pre class="source-code">
startPetsSync()</pre><p class="calibre4">Since we are using Koin, we need to disable the default WorkManager initialization in our app manifest.</p></li> <li class="calibre15">Let us head over to the <strong class="source-inline1">AndroidManifest.xml</strong> file and add the following code inside the application tag:<pre class="source-code">
&lt;provider
    android:name="androidx.startup.InitializationProvider"
    android:authorities="${applicationId}.androidx-startup"
    android:exported="false"
    tools:node="merge"&gt;
    &lt;!-- Removing WorkManager Default Initializer--&gt;
    &lt;meta-data
        android:name="androidx.work.WorkManagerInitializer"
        android:value="androidx.startup"
        tools:node="remove" /&gt;
&lt;/provider&gt;</pre><p class="calibre4">Adding the preceding <a id="_idIndexMarker449" class="calibre3 pcalibre pcalibre1"/>code prevents WorkManager <a id="_idIndexMarker450" class="calibre3 pcalibre pcalibre1"/>from being initialized automatically. Not doing this causes an app to crash once you set up Koin initialization. The crash is caused by a conflict between Koin’s dependency injection and WorkManager’s default initialization. Lastly, we have also removed App Startup (<a href="https://developer.android.com/topic/libraries/app-startup" class="calibre3 pcalibre pcalibre1">https://developer.android.com/topic/libraries/app-startup</a>), which is used internally within WorkManager from WorkManager 2.6.</p></li> <li class="calibre15">To set up a custom WorkManager instance, head over to the <strong class="source-inline1">ChapterEightApplication.kt</strong> file and add the following code inside the <strong class="source-inline1">startKoin</strong> block:<pre class="source-code">
workManagerFactory()</pre></li> <li class="calibre15">Build and run the app, and nothing changes. However, we have scheduled a background task to fetch the cats from the remote data source and save them to our database.</li>
</ol>
<div><div><img alt="Figure 8.7 – Cute cats" src="img/B19779_08_07.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Cute cats</p>
<p class="calibre4">We have <a id="_idIndexMarker451" class="calibre3 pcalibre pcalibre1"/>created our <code>PetsSyncWorker</code> class and learned how to do <a id="_idIndexMarker452" class="calibre3 pcalibre pcalibre1"/>work in the background. In the next section, we are going to write tests for our <code>PetsSyncWorker</code> class.</p>
<h1 id="_idParaDest-98" class="calibre6"><a id="_idTextAnchor110" class="calibre3 pcalibre pcalibre1"/>Testing your workers</h1>
<p class="calibre4">Testing the code is very important. It <a id="_idIndexMarker453" class="calibre3 pcalibre pcalibre1"/>ensures that our code works as expected and it also helps us to catch bugs early. We will be writing tests for our workers in this section. To test our workers, we first need to set up WorkManager testing dependencies with the following steps:</p>
<ol class="calibre14">
<li class="calibre15">Let us head over to the <strong class="source-inline1">libs.versions.toml</strong> file and add the following dependency to the <strong class="source-inline1">libraries</strong> section:<pre class="source-code">
work-testing = { module = "androidx.work:work-testing", version.ref = "work" }</pre><p class="calibre4">Sync your project. This will add the <code>work-testing</code> artifact that helps in testing workers to our project.</p></li> <li class="calibre15">Next, we need to add the dependency to our app level <strong class="source-inline1">build.gradle.kts</strong> file:<pre class="source-code">
androidTestImplementation(libs.work.testing)</pre><p class="calibre4">We have used <code>androidTestImplementation</code> because we will be writing our tests in the <code>androidTest</code> folder. Do a Gradle sync to add the dependency to our project. We are now ready to start writing our tests.</p></li> </ol>
<p class="calibre4">Since our <code>PetsSyncWorker</code> class requires some dependencies, we will create a test rule that provides the Koin dependencies that we need. Let us head over to the <code>androidTest</code> folder, create a new file called <code>KoinTestRule.kt</code>, and add the following code:</p>
<pre class="source-code">
class KoinTestRule: TestRule {
    override fun apply(base: Statement?, description: Description?): Statement {
        return object : Statement() {
            override fun evaluate() {
                stopKoin()
                startKoin {
                    androidLogger(Level.ERROR)
                    androidContext(ApplicationProvider.getApplicationContext())
                    modules(appModules)
                }
            }
        }
    }
}</pre> <p class="calibre4"><code>KoinTestRule</code> implements the <code>TestRule</code> interface. We have used this rule to provide the Koin dependencies that we need in our tests. We have used the <code>startKoin</code> method to provide the<a id="_idIndexMarker454" class="calibre3 pcalibre pcalibre1"/> Koin dependencies that we need. We have used the <code>androidContext(ApplicationProvider.getApplicationContext())</code> method to get the application context. We have also used the <code>modules(appModules)</code> method to provide the Koin modules that we need. Now, we are ready to start writing our tests. Let us create a new file called <code>PetsSyncWorkerTest.kt</code> and add the following code:</p>
<pre class="source-code">
@RunWith(AndroidJUnit4::class)
class PetsSyncWorkerTest {
    @get:Rule
    val koinTestRule = KoinTestRule()
    @Before
    fun setUp() {
        val config = Configuration.Builder()
            .setMinimumLoggingLevel(Log.DEBUG)
            .setExecutor(SynchronousExecutor())
            .build()
        // Initialize WorkManager for instrumentation tests.
        WorkManagerTestInitHelper.initializeTestWorkManager(
            ApplicationProvider.getApplicationContext(),
            config
        )
    }
}</pre> <p class="calibre4">We have created a test class called <code>PetsSyncWorkerTest</code>. We have annotated the class with the <code>@RunWith(AndroidJUnit4::class)</code> annotation. We have also created a <code>KoinTestRule</code> instance and<a id="_idIndexMarker455" class="calibre3 pcalibre pcalibre1"/> annotated it with the <code>@get:Rule</code> annotation to provide the <code>KoinTestRule</code> to our test class. We have also created a <code>setup</code> function and annotated it with the <code>@Before</code> annotation. This function will be executed before each test. We are using the <code>WorkManagerTestInitHelper</code> class to initialize WorkManager for instrumentation tests. We are using the <code>SynchronousExecutor</code> class to ensure that the work is executed synchronously. This is to ensure that our tests are deterministic. We are now ready to start writing our tests.</p>
<p class="calibre4">Follow these steps to create our test:</p>
<ol class="calibre14">
<li class="calibre15">We will start by creating a test function that will test the functionality of our worker. Add the following code to the <strong class="source-inline1">PetsSyncWorkerTest.kt</strong> file below the <strong class="source-inline1">setup</strong> function:<pre class="source-code">
@Test
fun testPetsSyncWorker() {
}</pre><p class="calibre4">This is an empty function <a id="_idIndexMarker456" class="calibre3 pcalibre pcalibre1"/>annotated with the <code>@</code><code>Test</code> annotation.</p></li> <li class="calibre15">Create a work request as follows:<pre class="source-code">
val syncPetsWorkRequest = OneTimeWorkRequestBuilder&lt;PetsSyncWorker&gt;()
    .setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()
    )
    .build()</pre><p class="calibre4">In the preceding code, we have created a one-time request using our <code>PetsSyncWorker</code> class. We have also set the constraints to our work request. We have set the network type to <code>NetworkType.CONNECTED</code> to ensure that the work request is only executed when the device is connected to the internet. We have also set the <code>BatteryNotLow</code> constraint to <code>true</code> to ensure that the work request is only executed when the battery is not low.</p></li> <li class="calibre15">Next, set up the test drivers:<pre class="source-code">
val workManager = WorkManager.getInstance(ApplicationProvider.getApplicationContext())
val testDriver =
    WorkManagerTestInitHelper.getTestDriver(ApplicationProvider.getApplicationContext())!!</pre><p class="calibre4">Here, we have set up the test<a id="_idIndexMarker457" class="calibre3 pcalibre pcalibre1"/> drivers that help us simulate conditions needed for our tests. For example, it simulates that constraints are met.</p></li> <li class="calibre15">Enqueue the work request:<pre class="source-code">
workManager.enqueueUniqueWork(
    "PetsSyncWorker",
    ExistingWorkPolicy.KEEP,
    syncPetsWorkRequest).result.get()</pre><p class="calibre4">We have used the <code>enqueueUniqueWork</code> method to enqueue our work request. We have passed the name of our work request, <code>ExistingWorkPolicy</code>, and the work request to the <code>enqueueUniqueWork</code> method. We have used <code>ExistingWorkPolicy.KEEP</code> to ensure that the work request is not replaced if there is already a work request with the same name. We have also used the <code>result.get()</code> method to get the result of our work request.</p></li> <li class="calibre15">Get the information about our work request using the <strong class="source-inline1">WorkInfo</strong> class:<pre class="source-code">
val workInfo = workManager.getWorkInfoById(syncPetsWorkRequest.id).get()</pre><p class="calibre4">We are getting <code>WorkInfo</code> for our work request. We have used the <code>getWorkInfoById</code> method to get <code>WorkInfo</code> for our work request. We are using the <code>result.get()</code> method to get the result of our work request.</p></li> <li class="calibre15">Next, let us get the worker state and assert that our work is enqueued:<pre class="source-code">
assertEquals(WorkInfo.State.ENQUEUED, workInfo.state)</pre><p class="calibre4">We have used the <code>assertEquals</code> method to assert that our work is enqueued. We have <a id="_idIndexMarker458" class="calibre3 pcalibre pcalibre1"/>used the <code>WorkInfo.State.ENQUEUED</code> to check if our work is enqueued.</p></li> <li class="calibre15">Next, let us simulate our constraints being met by using the <strong class="source-inline1">testDriver</strong> instance that we created earlier:<pre class="source-code">
testDriver.setAllConstraintsMet(syncPetsWorkRequest.id)</pre><p class="calibre4">We use <code>testDriver</code> to simulate that the constraints are met. We have used the <code>setAllConstraintsMet function</code> to simulate that the constraints are met. We have passed the <code>id</code> of our work request to the <code>setAllConstraintsMet</code> method. The work request <code>id</code> has an instance type of <code>Universally Unique </code><code>Identifier (UUID)</code>.</p></li> <li class="calibre15">Lastly, let us get the output and state of our workers:<pre class="source-code">
val postRequirementWorkInfo =
    workManager.getWorkInfoById(syncPetsWorkRequest.id).get()
assertEquals(WorkInfo.State.RUNNING, postRequirementWorkInfo.state)</pre><p class="calibre4">This is the final step of our test. We have used the <code>getWorkInfoById</code> method to get the <code>WorkInfo</code> of our work request. We have used the <code>result.get()</code> method to get the result of our work request. We have used <code>WorkInfo.State.RUNNING</code> to check if our work is running. Our final test function should look like the following:</p></li> </ol>
<div><div><img alt="Figure 8.8 – PetsSyncWorker test" src="img/B19779_08_08.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.8 – PetsSyncWorker test</p>
<ol class="calibre14">
<li value="9" class="calibre15">Click the green run icon on the left of<a id="_idIndexMarker459" class="calibre3 pcalibre pcalibre1"/> our test to run the test. The test runs and it’s all green! Our test passes, as seen in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 8.9 – Test results" src="img/B19779_08_09.jpg" class="calibre5"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Test results</p>
<p class="calibre4">Making all these<a id="_idIndexMarker460" class="calibre3 pcalibre pcalibre1"/> tests work together is amazing work.</p>
<h1 id="_idParaDest-99" class="calibre6"><a id="_idTextAnchor111" class="calibre3 pcalibre pcalibre1"/>Summary</h1>
<p class="calibre4">In this chapter, we learned how to save data to a local database, Room, which is part of the Jetpack libraries. We also saved items and read from the Room database. In the process, we also learned how to update items in the Room database and how to handle automated migrations in our database. Additionally, we learned how to do long-running operations using WorkManager, its best practices, and how to write tests for our workers.</p>
<p class="calibre4">In the next chapter, we will learn about runtime permissions and how to request them in our app.</p>
</div>
</body></html>