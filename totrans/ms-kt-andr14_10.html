<html><head></head><body>
<div id="_idContainer109" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-92"><a id="_idTextAnchor101" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-93" class="calibre6"><a id="_idTextAnchor102" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Persisting Data Locally and Doing Background Work</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.3.1">To provide better user experiences, we must ensure that apps don’t fetch data every time the user opens the app. </span><span class="kobospan" id="kobo.3.2">At times, the user can be in areas that do not have internet access, and this can be very frustrating when the user can’t use your app in such situations. </span><span class="kobospan" id="kobo.3.3">For such scenarios, we have to store data locally. </span><span class="kobospan" id="kobo.3.4">We also have to store and update the data in an efficient way that doesn’t drain the device’s battery or block the user from doing other things on the app. </span><span class="kobospan" id="kobo.3.5">In this chapter, we will be exploring how to do so for </span><span><span class="kobospan" id="kobo.4.1">our apps.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.5.1">In this chapter, we will learn how to save data to a local database, </span><strong class="bold"><span class="kobospan" id="kobo.6.1">Room</span></strong><span class="kobospan" id="kobo.7.1">, which is part of the Jetpack libraries. </span><span class="kobospan" id="kobo.7.2">We will be able to save items and read from the Room database. </span><span class="kobospan" id="kobo.7.3">Additionally, we will learn how to do long-running operations using </span><strong class="bold"><span class="kobospan" id="kobo.8.1">WorkManager</span></strong><span class="kobospan" id="kobo.9.1"> and some of the </span><span><span class="kobospan" id="kobo.10.1">best practices.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.12.1">main topics:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.13.1">Saving and reading data from a </span><span><span class="kobospan" id="kobo.14.1">local database</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.15.1">Handling updates and migrations in the </span><span><span class="kobospan" id="kobo.16.1">Room database</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.17.1">Using WorkManager to schedule </span><span><span class="kobospan" id="kobo.18.1">background tasks</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.19.1">Testing </span><span><span class="kobospan" id="kobo.20.1">your workers</span></span></li>
</ul>
<h1 id="_idParaDest-94" class="calibre6"><a id="_idTextAnchor103" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.21.1">Technical requirements</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.22.1">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (</span><a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.23.1">https://developer.android.com/studio</span></span></a><span><span class="kobospan" id="kobo.24.1">) </span></span><span><span class="kobospan" id="kobo.25.1">downloaded.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.26.1">You can use the previous chapter’s code to follow the instructions in this chapter. </span><span class="kobospan" id="kobo.26.2">You can find the code for this chapter </span><span><span class="kobospan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight" class="calibre3 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.28.1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight</span></span></a><span><span class="kobospan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-95" class="calibre6"><a id="_idTextAnchor104" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.30.1">Saving and reading data from a local database</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.31.1">We are going to build up on the Pets app, which displays a list of cute cats. </span><a id="_idTextAnchor105" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.32.1">We will save our cute cats in a local database, Room, which is a part of the Android Jetpack libraries and provides a wrapper and </span><a id="_idIndexMarker387" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.33.1">abstraction layer over SQLite. </span><span class="kobospan" id="kobo.33.2">We </span><a id="_idIndexMarker388" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.34.1">will also use the </span><strong class="bold"><span class="kobospan" id="kobo.35.1">repository pattern</span></strong><span class="kobospan" id="kobo.36.1"> to abstract away the data source from </span><strong class="source-inline"><span class="kobospan" id="kobo.37.1">ViewModel</span></strong><span class="kobospan" id="kobo.38.1">. </span><span class="kobospan" id="kobo.38.2">The Room database provides an abstraction layer over SQLite to allow fluent </span><a id="_idIndexMarker389" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.39.1">database access while harnessing the full power of SQLite. </span><span class="kobospan" id="kobo.39.2">It also has inbuilt support for Kotlin coroutines and flows to allow for asynchronous database access. </span><span class="kobospan" id="kobo.39.3">Room is also compile-time safe and hence any errors in SQL queries are caught at compile time. </span><span class="kobospan" id="kobo.39.4">It allows us to do all this with </span><span><span class="kobospan" id="kobo.40.1">concise code.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.41.1">To use Room in our project, we need to add its dependency to our </span><strong class="source-inline"><span class="kobospan" id="kobo.42.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.43.1"> file. </span><span class="kobospan" id="kobo.43.2">Let us start by defining the Room version in the </span><strong class="source-inline"><span class="kobospan" id="kobo.44.1">versions</span></strong><span class="kobospan" id="kobo.45.1"> section as </span><span><span class="kobospan" id="kobo.46.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.47.1">
room = "2.5.2"</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.48.1">Next, let us add the dependencies in our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.49.1">libraries</span></strong></span><span><span class="kobospan" id="kobo.50.1"> section:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.51.1">
room-runtime = { module = "androidx.room:room-runtime" , version.ref = "room" }
room-compiler = { module = "androidx.room:room-compiler", version.ref = "room" }
room-ktx = { module = "androidx.room:room-ktx", version.ref = "room" }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.52.1">Sync the project for the changes to be added. </span><span class="kobospan" id="kobo.52.2">Before we add these dependencies to the app level </span><strong class="source-inline"><span class="kobospan" id="kobo.53.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.54.1"> file, we need to set up an annotation processor for the room compiler. </span><span class="kobospan" id="kobo.54.2">Room</span><a id="_idIndexMarker390" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.55.1"> uses the </span><strong class="bold"><span class="kobospan" id="kobo.56.1">annotation processor</span></strong><span class="kobospan" id="kobo.57.1"> to generate the code that will be used to read, write, update, and delete data from the database. </span><span class="kobospan" id="kobo.57.2">To do this, we need to add the following to the plugins section of the project level </span><span><strong class="source-inline"><span class="kobospan" id="kobo.58.1">build.gradle.kts</span></strong></span><span><span class="kobospan" id="kobo.59.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.60.1">
id("com.google.devtools.ksp") version "1.9.0-1.0.13" apply false</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.61.1">We have added the </span><strong class="bold"><span class="kobospan" id="kobo.62.1">Kotlin Symbol Processing</span></strong><span class="kobospan" id="kobo.63.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.64.1">KSP</span></strong><span class="kobospan" id="kobo.65.1">) plugin to our project. </span><span class="kobospan" id="kobo.65.2">This is a new annotation</span><a id="_idIndexMarker391" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.66.1"> processing tool that</span><a id="_idIndexMarker392" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.67.1"> is faster than the </span><strong class="bold"><span class="kobospan" id="kobo.68.1">Kotlin Annotation Processing Tool</span></strong><span class="kobospan" id="kobo.69.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.70.1">KAPT</span></strong><span class="kobospan" id="kobo.71.1">). </span><span class="kobospan" id="kobo.71.2">KSP analyses the Kotlin code directly and has a better understanding of the Kotlin language</span><a id="_idIndexMarker393" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.72.1"> constructs. </span><span class="kobospan" id="kobo.72.2">KSP is now the recommended annotation processing tool for Kotlin. </span><span class="kobospan" id="kobo.72.3">Next, we need to add KSP to our app level </span><span><strong class="source-inline"><span class="kobospan" id="kobo.73.1">build.gradle.kts</span></strong></span><span><span class="kobospan" id="kobo.74.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.75.1">
id("com.google.devtools.ksp")</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.76.1">This allows us to use</span><a id="_idIndexMarker394" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.77.1"> KSP in our app module. </span><span class="kobospan" id="kobo.77.2">To finalize setting up Room, now let us add the dependencies we declared earlier to the app level </span><span><strong class="source-inline"><span class="kobospan" id="kobo.78.1">build.gradle.kts</span></strong></span><span><span class="kobospan" id="kobo.79.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.80.1">
implementation(libs.room.runtime)
implementation(libs.room.ktx)
ksp(libs.room.compiler)</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.81.1">We have added our Room dependencies and the Room KTX library with the </span><strong class="source-inline"><span class="kobospan" id="kobo.82.1">implementation</span></strong><span class="kobospan" id="kobo.83.1"> configuration and the Room compiler with the </span><strong class="source-inline"><span class="kobospan" id="kobo.84.1">ksp</span></strong><span class="kobospan" id="kobo.85.1"> configuration. </span><span class="kobospan" id="kobo.85.2">We are now ready to start using Room in our project. </span><span class="kobospan" id="kobo.85.3">Let us start by creating an entity class for our </span><strong class="source-inline"><span class="kobospan" id="kobo.86.1">Cat</span></strong><span class="kobospan" id="kobo.87.1"> object. </span><span class="kobospan" id="kobo.87.2">This will be the data class that will be used to store our pets in the database. </span><span class="kobospan" id="kobo.87.3">Inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.88.1">data</span></strong><span class="kobospan" id="kobo.89.1"> package, create a new file called </span><strong class="source-inline"><span class="kobospan" id="kobo.90.1">CatEntity.kt</span></strong><span class="kobospan" id="kobo.91.1"> and add the </span><span><span class="kobospan" id="kobo.92.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.93.1">
@Entity(tableName = "Cat")
data class CatEntity(
    @PrimaryKey
    val id: String,
    val owner: String,
    val tags: List&lt;String&gt;,
    val createdAt: String,
    val updatedAt: String
)</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.94.1">This data class represents the Room table for our cats. </span><span class="kobospan" id="kobo.94.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.95.1">@Entity</span></strong><span class="kobospan" id="kobo.96.1"> annotation is used to define the table for our cats. </span><span class="kobospan" id="kobo.96.2">We have passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.97.1">tableName</span></strong><span class="kobospan" id="kobo.98.1"> value to specify the name of our table. </span><span class="kobospan" id="kobo.98.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.99.1">@PrimaryKey</span></strong><span class="kobospan" id="kobo.100.1"> annotation is used to define the </span><strong class="bold"><span class="kobospan" id="kobo.101.1">primary key</span></strong><span class="kobospan" id="kobo.102.1"> for our table. </span><span class="kobospan" id="kobo.102.2">The other properties are the</span><a id="_idIndexMarker395" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.103.1"> columns in our table. </span><span class="kobospan" id="kobo.103.2">One thing to keep in mind is that Room needs </span><a id="_idIndexMarker396" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.104.1">type converters to save fields such as </span><strong class="source-inline"><span class="kobospan" id="kobo.105.1">tags</span></strong><span class="kobospan" id="kobo.106.1">, which is a list of strings. </span><span class="kobospan" id="kobo.106.2">Room provides functionality to save </span><a id="_idIndexMarker397" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.107.1">non-primitive types using the </span><strong class="source-inline"><span class="kobospan" id="kobo.108.1">@TypeConverter</span></strong><span class="kobospan" id="kobo.109.1"> annotation. </span><span class="kobospan" id="kobo.109.2">Let us create a new file named </span><strong class="source-inline"><span class="kobospan" id="kobo.110.1">PetsTypeConverters.kt</span></strong><span class="kobospan" id="kobo.111.1"> and add the </span><span><span class="kobospan" id="kobo.112.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.113.1">
class PetsTypeConverters {
    @TypeConverter
    fun convertTagsToString(tags: List&lt;String&gt;): String {
        return Json.encodeToString(tags)
    }
    @TypeConverter
    fun convertStringToTags(tags: String): List&lt;String&gt; {
        return Json.decodeFromString(tags)
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.114.1">This class has two functions annotated with the </span><strong class="source-inline"><span class="kobospan" id="kobo.115.1">@TypeConverter</span></strong><span class="kobospan" id="kobo.116.1"> annotation. </span><span class="kobospan" id="kobo.116.2">The first function converts a list of strings to a string. </span><span class="kobospan" id="kobo.116.3">The second function converts a string to a list of strings. </span><span class="kobospan" id="kobo.116.4">We have used the Kotlinx serialization library to convert the list of strings to a string and vice versa. </span><span class="kobospan" id="kobo.116.5">This class will be referenced in our database class that we will </span><span><span class="kobospan" id="kobo.117.1">create shortly.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.118.1">We are now ready to create our database. </span><span class="kobospan" id="kobo.118.2">We need to create a </span><strong class="bold"><span class="kobospan" id="kobo.119.1">Data Access Object</span></strong><span class="kobospan" id="kobo.120.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.121.1">DAO</span></strong><span class="kobospan" id="kobo.122.1">) to access our database. </span><span class="kobospan" id="kobo.122.2">A DAO is</span><a id="_idIndexMarker398" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.123.1"> an interface that defines the methods to create, read, update, and</span><a id="_idIndexMarker399" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.124.1"> delete values from our</span><a id="_idIndexMarker400" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.125.1"> database. </span><span class="kobospan" id="kobo.125.2">Inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.126.1">data</span></strong><span class="kobospan" id="kobo.127.1"> package, create a new file called </span><strong class="source-inline"><span class="kobospan" id="kobo.128.1">CatDao.kt</span></strong><span class="kobospan" id="kobo.129.1"> and add the </span><span><span class="kobospan" id="kobo.130.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.131.1">
@Dao
interface CatDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(catEntity: CatEntity)
    @Query("SELECT * FROM Cat")
    fun getCats(): Flow&lt;List&lt;CatEntity&gt;&gt;
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.132.1">The interface is annotated with the </span><strong class="source-inline"><span class="kobospan" id="kobo.133.1">@Dao</span></strong><span class="kobospan" id="kobo.134.1"> annotation to tell Room that we will use this class as our DAO. </span><span class="kobospan" id="kobo.134.2">We have defined two functions in our DAO. </span><span class="kobospan" id="kobo.134.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">insert</span></strong><span class="kobospan" id="kobo.136.1"> function is used to insert a cat into our database. </span><span class="kobospan" id="kobo.136.2">Notice that this is a </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">suspend</span></strong><span class="kobospan" id="kobo.138.1"> function. </span><span class="kobospan" id="kobo.138.2">This is because we will be using coroutines to insert the cats into our database. </span><span class="kobospan" id="kobo.138.3">Inserting items into the database needs to happen on a background thread since it is a resource-intensive operation. </span><span class="kobospan" id="kobo.138.4">We also use the </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">@Insert</span></strong><span class="kobospan" id="kobo.140.1"> annotation with the </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">onConflict</span></strong><span class="kobospan" id="kobo.142.1"> parameter set to </span><strong class="source-inline"><span class="kobospan" id="kobo.143.1">OnConflictStrategy.REPLACE</span></strong><span class="kobospan" id="kobo.144.1">. </span><span class="kobospan" id="kobo.144.2">This tells Room to replace the cat if it already exists in the database. </span><span class="kobospan" id="kobo.144.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.145.1">getCats</span></strong><span class="kobospan" id="kobo.146.1"> function is used to get all the cats from our database. </span><span class="kobospan" id="kobo.146.2">It has the </span><strong class="source-inline"><span class="kobospan" id="kobo.147.1">@Query</span></strong><span class="kobospan" id="kobo.148.1"> annotation, which is used to define a query to get the cats from our database. </span><span class="kobospan" id="kobo.148.2">We are using </span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">Flow</span></strong><span class="kobospan" id="kobo.150.1"> to return the cats from our database. </span><strong class="source-inline"><span class="kobospan" id="kobo.151.1">Flow</span></strong><span class="kobospan" id="kobo.152.1"> is a stream of data that can be observed. </span><span class="kobospan" id="kobo.152.2">This means that every time we update the database, the changes will be emitted to the view layers immediately without us doing any extra work. </span><span><span class="kobospan" id="kobo.153.1">Cool, right?</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.154.1">We now need to create our database class. </span><span class="kobospan" id="kobo.154.2">Inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">data</span></strong><span class="kobospan" id="kobo.156.1"> package, create a new file called </span><strong class="source-inline"><span class="kobospan" id="kobo.157.1">CatDatabase.kt</span></strong><span class="kobospan" id="kobo.158.1"> and add the </span><span><span class="kobospan" id="kobo.159.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.160.1">
@Database(
    entities = [CatEntity::class],
    version = 1
)
@TypeConverters(PetsTypeConverters::class)
abstract class CatDatabase: RoomDatabase() {
    abstract fun catDao(): CatDao
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.161.1">We have defined an abstract class that extends the </span><strong class="source-inline"><span class="kobospan" id="kobo.162.1">RoomDatabase</span></strong><span class="kobospan" id="kobo.163.1"> class. </span><span class="kobospan" id="kobo.163.2">We passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.164.1">entities</span></strong><span class="kobospan" id="kobo.165.1"> parameter to specify the entities or tables stored in our database. </span><span class="kobospan" id="kobo.165.2">We have also passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.166.1">version</span></strong><span class="kobospan" id="kobo.167.1"> parameter to specify the version of our database. </span><span class="kobospan" id="kobo.167.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.168.1">@TypeConverters</span></strong><span class="kobospan" id="kobo.169.1"> annotation to specify the type converters that we will be using in our database. </span><span class="kobospan" id="kobo.169.2">We </span><a id="_idIndexMarker401" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.170.1">have also defined an abstract method that returns our </span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">CatDao</span></strong><span class="kobospan" id="kobo.172.1">. </span><span class="kobospan" id="kobo.172.2">We need to provide an instance of the database to classes that need it. </span><span class="kobospan" id="kobo.172.3">We will do this by using the</span><a id="_idIndexMarker402" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.173.1"> dependency injection pattern we have been using in our project. </span><span class="kobospan" id="kobo.173.2">Let us head over to the </span><strong class="source-inline"><span class="kobospan" id="kobo.174.1">di</span></strong><span class="kobospan" id="kobo.175.1"> package and in the </span><strong class="source-inline"><span class="kobospan" id="kobo.176.1">Module.kt</span></strong><span class="kobospan" id="kobo.177.1"> file, add the Room dependency just below the </span><span><span class="kobospan" id="kobo.178.1">Retrofit dependency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.179.1">
single {
    Room.databaseBuilder(
        androidContext(),
        CatDatabase::class.java,
        "cat-database"
    ).build()
}
single { get&lt;CatDatabase&gt;().carDao() }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.180.1">First, we have created a single instance of our database. </span><span class="kobospan" id="kobo.180.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.181.1">databaseBuilder</span></strong><span class="kobospan" id="kobo.182.1"> method to create our database. </span><span class="kobospan" id="kobo.182.2">We have passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">androidContext()</span></strong><span class="kobospan" id="kobo.184.1"> method from Koin to get the context of our application. </span><span class="kobospan" id="kobo.184.2">We have also passed </span><strong class="source-inline"><span class="kobospan" id="kobo.185.1">CatDatabase::class.java</span></strong><span class="kobospan" id="kobo.186.1"> to specify the class of our database. </span><span class="kobospan" id="kobo.186.2">We have also passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.187.1">name</span></strong><span class="kobospan" id="kobo.188.1"> of our database. </span><span class="kobospan" id="kobo.188.2">We have then created a single instance of our </span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">CatDao</span></strong><span class="kobospan" id="kobo.190.1">. </span><span class="kobospan" id="kobo.190.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.191.1">get</span></strong><span class="kobospan" id="kobo.192.1"> method to get the instance of our database and then calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.193.1">catDao</span></strong><span class="kobospan" id="kobo.194.1"> function to get </span><span><span class="kobospan" id="kobo.195.1">our </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.196.1">CatDao</span></strong></span><span><span class="kobospan" id="kobo.197.1">.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.198.1">Our database is now ready to be used in our repository. </span><span class="kobospan" id="kobo.198.2">We are going to modify </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">PetRepository</span></strong><span class="kobospan" id="kobo.200.1"> and its implementation to be able to do </span><span><span class="kobospan" id="kobo.201.1">the following:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.202.1">Save items to </span><span><span class="kobospan" id="kobo.203.1">our database</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.204.1">Read items from </span><span><span class="kobospan" id="kobo.205.1">our database</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.206.1">Change our </span><strong class="source-inline1"><span class="kobospan" id="kobo.207.1">getPets()</span></strong><span class="kobospan" id="kobo.208.1"> function</span><a id="_idIndexMarker403" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.209.1"> to return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.210.1">Flow</span></strong> <span><span class="kobospan" id="kobo.211.1">of pets</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.212.1">The modified </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">PetRepository.kt</span></strong><span class="kobospan" id="kobo.214.1"> file should look like </span><span><span class="kobospan" id="kobo.215.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.216.1">
interface PetsRepository {
    suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt;
    suspend fun fet</span><a id="_idTextAnchor106" class="calibre19 pcalibre pcalibre1"/><span class="kobospan1" id="kobo.217.1">chRemotePets()
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.218.1">We have modified the </span><strong class="source-inline"><span class="kobospan" id="kobo.219.1">getPets</span></strong><span class="kobospan" id="kobo.220.1"> function to return a </span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">Flow</span></strong><span class="kobospan" id="kobo.222.1"> of pets. </span><span class="kobospan" id="kobo.222.2">Room does not allow database access on the main thread, therefore, our queries have to be asynchronous. </span><span class="kobospan" id="kobo.222.3">Room </span><a id="_idIndexMarker404" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.223.1">provides support for observable queries that read data from our database every time data in our database changes and emits new values to reflect the changes. </span><span class="kobospan" id="kobo.223.2">This is the reason we return a </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">Flow</span></strong><span class="kobospan" id="kobo.225.1"> instance type from the </span><strong class="source-inline"><span class="kobospan" id="kobo.226.1">getPets</span></strong><span class="kobospan" id="kobo.227.1"> function. </span><span class="kobospan" id="kobo.227.2">We have also added the </span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">fetchRemotePets</span></strong><span class="kobospan" id="kobo.229.1"> function to fetch the pets from the remote data source. </span><span class="kobospan" id="kobo.229.2">Let us now modify </span><strong class="source-inline"><span class="kobospan" id="kobo.230.1">PetRepositoryImpl.kt</span></strong><span class="kobospan" id="kobo.231.1"> with a </span><span><span class="kobospan" id="kobo.232.1">few changes:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.233.1">
class PetsRepositoryImpl(
    private  val catsAPI: CatsAPI,
    private val dispatcher: CoroutineDispatcher,
    private val catDao: CatDao
): PetsRepository {
    override suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt; {
        return withContext(dispatcher) {
           catDao.getCats()
               .map { petsCached -&gt;
                   petsCached.map { catEntity -&gt;
                       Cat(
                           id = catEntity.id,
                           owner = catEntity.owner,
                           tags = catEntity.tags,
                           createdAt = catEntity.createdAt,
                           updatedAt = catEntity.updatedAt
                       ) }
               }
               .onEach {
                     if (it.isEmpty()) {
                          fetchRemotePets()
                     }
               }
        }
    }
    override suspend fun fetchRemotePets() {
        withContext(dispatcher) {
            val response = catsAPI.fetchCats("cute")
            if (response.isSuccessful) {
                response.body()!!.map {
                    catDao.insert(CatEntity(
                        id = it.id,
                        owner = it.owner,
                        tags = it.tags,
                        createdAt = it.createdAt,
                        updatedAt = it.updatedAt
                    ))
                }
            }
        }
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.234.1">We have made the </span><span><span class="kobospan" id="kobo.235.1">following changes:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.236.1">We have added the </span><strong class="source-inline1"><span class="kobospan" id="kobo.237.1">catDao</span></strong><span class="kobospan" id="kobo.238.1"> property to the constructor of </span><span><span class="kobospan" id="kobo.239.1">the class.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.240.1">We have modified the </span><strong class="source-inline1"><span class="kobospan" id="kobo.241.1">getPets</span></strong><span class="kobospan" id="kobo.242.1"> function to return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.243.1">Flow</span></strong><span class="kobospan" id="kobo.244.1"> of pets. </span><span class="kobospan" id="kobo.244.2">Additionally, we</span><a id="_idIndexMarker405" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.245.1"> have added a </span><strong class="source-inline1"><span class="kobospan" id="kobo.246.1">map</span></strong><span class="kobospan" id="kobo.247.1"> operator to map </span><strong class="source-inline1"><span class="kobospan" id="kobo.248.1">CatEntity</span></strong><span class="kobospan" id="kobo.249.1"> to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.250.1">Cat</span></strong><span class="kobospan" id="kobo.251.1"> object. </span><span class="kobospan" id="kobo.251.2">We have</span><a id="_idIndexMarker406" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.252.1"> also added an </span><strong class="source-inline1"><span class="kobospan" id="kobo.253.1">onEach</span></strong><span class="kobospan" id="kobo.254.1"> operator to check if the list of pets is empty. </span><span class="kobospan" id="kobo.254.2">If it is empty, we call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.255.1">fetchRemotePets</span></strong><span class="kobospan" id="kobo.256.1"> function to fetch the pets from the remote data source. </span><span class="kobospan" id="kobo.256.2">This provides an </span><strong class="bold"><span class="kobospan" id="kobo.257.1">offline first experience</span></strong><span class="kobospan" id="kobo.258.1"> to our</span><a id="_idIndexMarker407" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.259.1"> users; that is, we first check if we have the data in our database and if we don’t, we fetch it from the remote </span><span><span class="kobospan" id="kobo.260.1">data source.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.261.1">Lastly, we have modified the </span><strong class="source-inline1"><span class="kobospan" id="kobo.262.1">fetchRemotePets</span></strong><span class="kobospan" id="kobo.263.1"> function that fetches the pets from the remote data source. </span><span class="kobospan" id="kobo.263.2">When the response is successful, we map the response to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.264.1">CatEntity</span></strong><span class="kobospan" id="kobo.265.1"> instance type and insert it into </span><span><span class="kobospan" id="kobo.266.1">our database.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.267.1">We need to update the </span><strong class="source-inline"><span class="kobospan" id="kobo.268.1">PetsRepository</span></strong><span class="kobospan" id="kobo.269.1"> dependency in our </span><strong class="source-inline"><span class="kobospan" id="kobo.270.1">Module.kt</span></strong><span class="kobospan" id="kobo.271.1"> file to add the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">CatDao</span></strong></span><span><span class="kobospan" id="kobo.273.1"> dependency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.274.1">
single&lt;PetsRepository&gt; { PetsRepositoryImpl(get(), get(), get()) }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.275.1">In our </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">PetsRepositoryImpl</span></strong><span class="kobospan" id="kobo.277.1"> class, we have been able to read and fetch data from the Room database. </span><span class="kobospan" id="kobo.277.2">Next, we are going to modify the </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">getPets()</span></strong><span class="kobospan" id="kobo.279.1"> function in </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.281.1"> to </span><a id="_idIndexMarker408" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.282.1">accommodate these new changes. </span><span class="kobospan" id="kobo.282.2">Head</span><a id="_idIndexMarker409" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.283.1"> over to the </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">PetsViewModel.kt</span></strong><span class="kobospan" id="kobo.285.1"> file and modify the </span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">getPets()</span></strong><span class="kobospan" id="kobo.287.1"> function to look like </span><span><span class="kobospan" id="kobo.288.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.289.1">
private fun getPets() {
    petsUIState.value = PetsUIState(isLoading = true)
    viewModelScope.launch {
        petsRepository.getPets().asResult().collect { result -&gt;
            when (result ) {
                is NetworkResult.Success -&gt; {
                    petsUIState.update {
                        it.copy(isLoading = false, pets = result.data)
                    }
                }
                is NetworkResult.Error -&gt; {
                    petsUIState.update {
                        it.copy(isLoading = false, error = result.error)
                    }
                }
            }
        }
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.290.1">We have made a few minor changes. </span><span class="kobospan" id="kobo.290.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">asResult()</span></strong><span class="kobospan" id="kobo.292.1"> extension function to convert the </span><strong class="source-inline"><span class="kobospan" id="kobo.293.1">Flow</span></strong><span class="kobospan" id="kobo.294.1"> of pets to a </span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">Flow</span></strong><span class="kobospan" id="kobo.296.1"> of </span><strong class="source-inline"><span class="kobospan" id="kobo.297.1">NetworkResult</span></strong><span class="kobospan" id="kobo.298.1">. </span><span class="kobospan" id="kobo.298.2">This is because we are now returning a </span><strong class="source-inline"><span class="kobospan" id="kobo.299.1">Flow</span></strong><span class="kobospan" id="kobo.300.1"> of pets from our repository. </span><span class="kobospan" id="kobo.300.2">The rest of the code remains the same as </span><a id="_idIndexMarker410" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.301.1">before. </span><span class="kobospan" id="kobo.301.2">We will get an error since we have not </span><a id="_idIndexMarker411" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.302.1">created the </span><strong class="source-inline"><span class="kobospan" id="kobo.303.1">asResult() </span></strong><span class="kobospan" id="kobo.304.1">extension function. </span><span class="kobospan" id="kobo.304.2">Let us create it in our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.305.1">NetworkResult.kt</span></strong></span><span><span class="kobospan" id="kobo.306.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.307.1">
fun &lt;T&gt; Flow&lt;T&gt;.asResult(): Flow&lt;NetworkResult&lt;T&gt;&gt; {
    return this
        .map&lt;T, NetworkResult&lt;T&gt;&gt; {
            NetworkResult.Success(it)
        }
        .catch { emit(NetworkResult.Error(it.message.toString())) }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.308.1">This is an extension function on the </span><strong class="source-inline"><span class="kobospan" id="kobo.309.1">Flow</span></strong><span class="kobospan" id="kobo.310.1"> class. </span><span class="kobospan" id="kobo.310.2">It maps a </span><strong class="source-inline"><span class="kobospan" id="kobo.311.1">Flow</span></strong><span class="kobospan" id="kobo.312.1"> of items to the </span><strong class="source-inline"><span class="kobospan" id="kobo.313.1">NetworkResult</span></strong><span class="kobospan" id="kobo.314.1"> class. </span><span class="kobospan" id="kobo.314.2">We can now head back to our </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.316.1"> class and add the extension function imports to resolve </span><span><span class="kobospan" id="kobo.317.1">the error.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.318.1">The last change we need to make is to provide the application context to our Koin instance in the </span><strong class="source-inline"><span class="kobospan" id="kobo.319.1">Application</span></strong><span class="kobospan" id="kobo.320.1"> class. </span><span class="kobospan" id="kobo.320.2">Head over to the </span><strong class="source-inline"><span class="kobospan" id="kobo.321.1">ChapterEightApplication.kt</span></strong><span class="kobospan" id="kobo.322.1"> file and modify the </span><strong class="source-inline"><span class="kobospan" id="kobo.323.1">startKoin</span></strong><span class="kobospan" id="kobo.324.1"> block to </span><span><span class="kobospan" id="kobo.325.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.326.1">
startKoin {
    androidContext(applicationContext)
    modules(appModules)
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.327.1">We have provided the application context to our Koin instance. </span><span class="kobospan" id="kobo.327.2">Now, we can run the app. </span><span class="kobospan" id="kobo.327.3">You should see the list of </span><span><span class="kobospan" id="kobo.328.1">cute cats.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer100">
<span class="kobospan" id="kobo.329.1"><img alt="Figure 8.1 – Cute cats" src="image/B19779_08_01.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.330.1">Figure 8.1 – Cute cats</span></p>
<p class="calibre4"><span class="kobospan" id="kobo.331.1">The app still works as before, but now we are reading items from the Room database. </span><span class="kobospan" id="kobo.331.2">If you turn off your data and Wi-Fi, the app still shows the list of cute cats! </span><span class="kobospan" id="kobo.331.3">Amazing, isn’t it? </span><span class="kobospan" id="kobo.331.4">We have been </span><a id="_idIndexMarker412" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.332.1">able to make the app work offline. </span><span class="kobospan" id="kobo.332.2">One of the benefits of having an architecture in place for our app is that we can change the different layers without necessarily affecting the other layers. </span><span class="kobospan" id="kobo.332.3">We have been able to change the data source from the remote data </span><a id="_idIndexMarker413" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.333.1">source to the local data source without affecting the view layer. </span><span class="kobospan" id="kobo.333.2">This is the power of having a good architecture </span><span><span class="kobospan" id="kobo.334.1">in place.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.335.1">We know how to insert and </span><a id="_idIndexMarker414" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.336.1">read data from our Room database, but what about updating it? </span><span class="kobospan" id="kobo.336.2">In the next section, we will learn how to update the data that is in our Room database. </span><span class="kobospan" id="kobo.336.3">In</span><a id="_idIndexMarker415" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.337.1"> the process, we will also learn how to migrate from one</span><a id="_idIndexMarker416" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.338.1"> database version to the other using the Room </span><strong class="bold"><span class="kobospan" id="kobo.339.1">automated </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.340.1">migration</span></strong></span><span><span class="kobospan" id="kobo.341.1"> feature.</span></span></p>
<h1 id="_idParaDest-96" class="calibre6"><a id="_idTextAnchor107" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.342.1">Handling updates and migrations in the Room database</span></h1>
<p class="calibre4"><strong class="source-inline"><span class="kobospan" id="kobo.343.1">FavoritePetsScreen</span></strong><span class="kobospan" id="kobo.344.1"> doesn’t have any functionality yet. </span><span class="kobospan" id="kobo.344.2">We are going to add the functionality to favorite pets and </span><a id="_idIndexMarker417" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.345.1">update this information in the Room database. </span><span class="kobospan" id="kobo.345.2">To achieve this, we need to do </span><span><span class="kobospan" id="kobo.346.1">the following:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.347.1">Set up a Room </span><span><span class="kobospan" id="kobo.348.1">schema directory.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.349.1">Add a new column to our </span><strong class="source-inline1"><span class="kobospan" id="kobo.350.1">CatEntity</span></strong><span class="kobospan" id="kobo.351.1"> class to store the favorite status of </span><span><span class="kobospan" id="kobo.352.1">the cat.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.353.1">Add a new function to </span><strong class="source-inline1"><span class="kobospan" id="kobo.354.1">CatDao</span></strong><span class="kobospan" id="kobo.355.1"> to update the favorite status of </span><span><span class="kobospan" id="kobo.356.1">the cat.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.357.1">Update our UIs with a favorite icon and, once clicked, update the favorite status of the cat. </span><span class="kobospan" id="kobo.357.2">This means the ViewModel and repository classes will also be updated in </span><span><span class="kobospan" id="kobo.358.1">the process.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.359.1">Let’s get started with </span><span><span class="kobospan" id="kobo.360.1">the steps:</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.361.1">Let us start by setting up the schema directory. </span><span class="kobospan" id="kobo.361.2">In our app level </span><strong class="source-inline1"><span class="kobospan" id="kobo.362.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.363.1"> file, add the </span><span><span class="kobospan" id="kobo.364.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.365.1">
ksp {
    arg("room.schemaLocation", "$projectDir/schemas")
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.366.1">Do a Gradle sync and then build the project. </span><span class="kobospan" id="kobo.366.2">This generates a </span><strong class="source-inline"><span class="kobospan" id="kobo.367.1">schema json</span></strong><span class="kobospan" id="kobo.368.1"> file with the name </span><a id="_idIndexMarker418" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.369.1">of the current database version as shown in the </span><span><span class="kobospan" id="kobo.370.1">following figure:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer101">
<span class="kobospan" id="kobo.371.1"><img alt="Figure 8.2 – Room schema directory" src="image/B19779_08_02.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.372.1">Figure 8.2 – Room schema directory</span></p>
<p class="calibre4"><span class="kobospan" id="kobo.373.1">As shown in the preceding image, you have to switch to the </span><strong class="bold"><span class="kobospan" id="kobo.374.1">Project</span></strong><span class="kobospan" id="kobo.375.1"> view to see the schema directory. </span><span class="kobospan" id="kobo.375.2">The contents of the file are the table name and the columns in our table. </span><span class="kobospan" id="kobo.375.3">We are now ready to add a new column to our </span><strong class="source-inline"><span class="kobospan" id="kobo.376.1">CatEntity</span></strong><span class="kobospan" id="kobo.377.1"> interface to store the favorite status of </span><span><span class="kobospan" id="kobo.378.1">the cat.</span></span></p>
<ol class="calibre14">
<li value="2" class="calibre15"><span class="kobospan" id="kobo.379.1">We will add this field to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.380.1">CatEntity</span></strong><span class="kobospan" id="kobo.381.1"> and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.382.1">Cat</span></strong><span class="kobospan" id="kobo.383.1"> data classes. </span><span class="kobospan" id="kobo.383.2">Head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.384.1">CatEntity.kt</span></strong><span class="kobospan" id="kobo.385.1"> file and add a new field </span><span><span class="kobospan" id="kobo.386.1">called </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.387.1">isFavorite</span></strong></span><span><span class="kobospan" id="kobo.388.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.389.1">
@ColumnInfo(defaultValue = "0")
val isFavorite: Boolean = false</span></pre><p class="calibre4"><span class="kobospan" id="kobo.390.1">This is a Boolean whose default value is </span><strong class="source-inline"><span class="kobospan" id="kobo.391.1">false</span></strong><span class="kobospan" id="kobo.392.1">. </span><span class="kobospan" id="kobo.392.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.393.1">@ColumnInfo</span></strong><span class="kobospan" id="kobo.394.1"> annotation to</span><a id="_idIndexMarker419" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.395.1"> specify the default value of the column in our database, too. </span><span class="kobospan" id="kobo.395.2">We will use this field to store the favorite status of the cat. </span><span class="kobospan" id="kobo.395.3">Ensure you add the </span><strong class="source-inline"><span class="kobospan" id="kobo.396.1">val isFavorite: Boolean = false</span></strong><span class="kobospan" id="kobo.397.1"> field to the </span><strong class="source-inline"><span class="kobospan" id="kobo.398.1">Cat</span></strong><span class="kobospan" id="kobo.399.1"> data class, too. </span><span class="kobospan" id="kobo.399.2">We now need to update our </span><strong class="source-inline"><span class="kobospan" id="kobo.400.1">CatDao</span></strong><span class="kobospan" id="kobo.401.1"> class to be able to update the favorite status of </span><span><span class="kobospan" id="kobo.402.1">the cat.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.403.1">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.404.1">CatDao.kt</span></strong><span class="kobospan" id="kobo.405.1"> file and add the </span><span><span class="kobospan" id="kobo.406.1">following functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.407.1">
@Update
suspend fun update(catEntity: CatEntity)
@Query("SELECT * FROM Cat WHERE isFavorite = 1")
fun getFavoriteCats(): Flow&lt;List&lt;CatEntity&gt;&gt;</span></pre><p class="calibre4"><span class="kobospan" id="kobo.408.1">We have two functions here. </span><span class="kobospan" id="kobo.408.2">The first function will be used to update the favorite status of the cat. </span><span class="kobospan" id="kobo.408.3">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.409.1">@Update</span></strong><span class="kobospan" id="kobo.410.1"> annotation to tell Room that this function will be used to update the </span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">CatEntity</span></strong><span class="kobospan" id="kobo.412.1"> class in our database. </span><span class="kobospan" id="kobo.412.2">The second function will be used to get the favorite cats from our database. </span><span class="kobospan" id="kobo.412.3">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.413.1">@Query</span></strong><span class="kobospan" id="kobo.414.1"> annotation to define the query to get the favorite cats from our database. </span><span class="kobospan" id="kobo.414.2">We have used </span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">Flow</span></strong><span class="kobospan" id="kobo.416.1"> to return the favorite cats from our database. </span><span class="kobospan" id="kobo.416.2">Now, we need to add a migration to our database to add the new column to our database. </span><span class="kobospan" id="kobo.416.3">This ensures that we don’t lose any data when we update our database. </span><strong class="bold"><span class="kobospan" id="kobo.417.1">Room version 2.4.0-alpha01</span></strong><span class="kobospan" id="kobo.418.1"> introduced </span><a id="_idIndexMarker420" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.419.1">a new way of handling migrations – automated migrations. </span><span class="kobospan" id="kobo.419.2">This means that we don’t have to write any SQL queries to</span><a id="_idIndexMarker421" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.420.1"> handle migrations; Room will automatically handle the migrations </span><span><span class="kobospan" id="kobo.421.1">for us.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.422.1">Let us modify </span><strong class="source-inline1"><span class="kobospan" id="kobo.423.1">CatDatabase</span></strong><span class="kobospan" id="kobo.424.1"> to add </span><strong class="source-inline1"><span class="kobospan" id="kobo.425.1">autoMigration</span></strong> <span><span class="kobospan" id="kobo.426.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.427.1">
@Database(
    entities = [CatEntity::class],
    version = 2,
    autoMigrations = [
        AutoMigration(from = 1, to = 2)
    ]
)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.428.1">We have added the </span><strong class="source-inline"><span class="kobospan" id="kobo.429.1">autoMigrations</span></strong><span class="kobospan" id="kobo.430.1"> parameter to our database. </span><span class="kobospan" id="kobo.430.2">We have passed a list of </span><strong class="source-inline"><span class="kobospan" id="kobo.431.1">AutoMigration</span></strong><span class="kobospan" id="kobo.432.1"> objects to the parameter. </span><span class="kobospan" id="kobo.432.2">We have passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.433.1">from</span></strong><span class="kobospan" id="kobo.434.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.435.1">to</span></strong><span class="kobospan" id="kobo.436.1"> parameters to specify the version of our database. </span><span class="kobospan" id="kobo.436.2">Ensure you add the imports for the </span><strong class="source-inline"><span class="kobospan" id="kobo.437.1">AutoMigration</span></strong><span class="kobospan" id="kobo.438.1"> class. </span><span class="kobospan" id="kobo.438.2">Notice that we have also increased the </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">version</span></strong><span class="kobospan" id="kobo.440.1"> of our database. </span><span class="kobospan" id="kobo.440.2">This is because we have added a new column to our database. </span><span class="kobospan" id="kobo.440.3">Build the project to be able to generate the </span><strong class="source-inline"><span class="kobospan" id="kobo.441.1">schema json</span></strong><span class="kobospan" id="kobo.442.1"> file. </span><span class="kobospan" id="kobo.442.2">You should see a new schema JSON file with the name of the new database version. </span><span class="kobospan" id="kobo.442.3">Our schema directory should look like </span><span><span class="kobospan" id="kobo.443.1">the following:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer102">
<span class="kobospan" id="kobo.444.1"><img alt="Figure 8.3 – Updated Room schema directory" src="image/B19779_08_03.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.445.1">Figure 8.3 – Updated Room schema directory</span></p>
<p class="calibre4"><span class="kobospan" id="kobo.446.1">If we open the </span><strong class="source-inline"><span class="kobospan" id="kobo.447.1">2.json</span></strong><span class="kobospan" id="kobo.448.1"> file, we will notice that the new </span><strong class="source-inline"><span class="kobospan" id="kobo.449.1">isFavorite</span></strong><span class="kobospan" id="kobo.450.1"> column has been added to our table. </span><span class="kobospan" id="kobo.450.2">That it’s for </span><a id="_idIndexMarker422" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.451.1">automated migration. </span><span class="kobospan" id="kobo.451.2">We are now ready to update our repository to be able to update the favorite status of </span><span><span class="kobospan" id="kobo.452.1">the cat.</span></span></p>
<ol class="calibre14">
<li value="5" class="calibre15"><span class="kobospan" id="kobo.453.1">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.454.1">PetsRepository.kt</span></strong><span class="kobospan" id="kobo.455.1"> file and add the </span><span><span class="kobospan" id="kobo.456.1">following functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.457.1">
suspend fun updatePet(cat: Cat)
suspend fun getFavoritePets(): Flow&lt;List&lt;Cat&gt;&gt;</span></pre></li> </ol>
<p class="calibre4"><span class="kobospan" id="kobo.458.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">updatePet(cat: Cat)</span></strong><span class="kobospan" id="kobo.460.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">getFavoritePets()</span></strong><span class="kobospan" id="kobo.462.1"> functions will be used to update the favorite status </span><a id="_idIndexMarker423" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.463.1">of the cat and get </span><span><span class="kobospan" id="kobo.464.1">favorite cats.</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.465.1">Let us add the implementation of the two functions in our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.466.1">PetsRepositoryImpl.kt</span></strong></span><span><span class="kobospan" id="kobo.467.1"> class:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.468.1">
override suspend fun updatePet(cat: Cat) {
    withContext(dispatcher) {
        catDao.update(CatEntity(
            id = cat.id,
            owner = cat.owner,
            tags = cat.tags,
            createdAt = cat.createdAt,
            updatedAt = cat.updatedAt,
            isFavorite = cat.isFavorite
        ))
    }
}
override suspend fun getFavoritePets(): Flow&lt;List&lt;Cat&gt;&gt; {
    return withContext(dispatcher) {
        catDao.getFavoriteCats()
            .map { petsCached -&gt;
                petsCached.map { catEntity -&gt;
                    Cat(
                        id = catEntity.id,
                        owner = catEntity.owner,
                        tags = catEntity.tags,
                        createdAt = catEntity.createdAt,
                        updatedAt = catEntity.updatedAt,
                        isFavorite = catEntity.isFavorite
                    )
                }
            }
    }
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.469.1">Here is an explanation of </span><span><span class="kobospan" id="kobo.470.1">the functions:</span></span></p><ul class="calibre17"><li class="calibre15"><span class="kobospan" id="kobo.471.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.472.1">updatePet</span></strong><span class="kobospan" id="kobo.473.1"> function, we have </span><a id="_idIndexMarker424" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.474.1">used the update method of our </span><strong class="source-inline1"><span class="kobospan" id="kobo.475.1">CatDao</span></strong><span class="kobospan" id="kobo.476.1"> interface to update the favorite status of the cat. </span><span class="kobospan" id="kobo.476.2">We have also used </span><strong class="source-inline1"><span class="kobospan" id="kobo.477.1">withContext</span></strong><span class="kobospan" id="kobo.478.1"> to ensure that the update runs on a background thread. </span><span class="kobospan" id="kobo.478.2">We have created a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.479.1">CatEntity</span></strong><span class="kobospan" id="kobo.480.1"> class from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.481.1">Cat</span></strong><span class="kobospan" id="kobo.482.1"> object that we have passed to </span><span><span class="kobospan" id="kobo.483.1">the function.</span></span></li><li class="calibre15"><span class="kobospan" id="kobo.484.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.485.1">getFavoritePets</span></strong><span class="kobospan" id="kobo.486.1"> function, we have used the </span><strong class="source-inline1"><span class="kobospan" id="kobo.487.1">getFavoriteCats</span></strong><span class="kobospan" id="kobo.488.1"> function from our </span><strong class="source-inline1"><span class="kobospan" id="kobo.489.1">CatDao</span></strong><span class="kobospan" id="kobo.490.1"> interface to get the favorite cats from our database. </span><span class="kobospan" id="kobo.490.2">We have also mapped the list of </span><strong class="source-inline1"><span class="kobospan" id="kobo.491.1">CatEntity</span></strong><span class="kobospan" id="kobo.492.1"> to a list of </span><strong class="source-inline1"><span class="kobospan" id="kobo.493.1">Cat</span></strong><span class="kobospan" id="kobo.494.1">. </span><span class="kobospan" id="kobo.494.2">We then returned a </span><strong class="source-inline1"><span class="kobospan" id="kobo.495.1">Flow</span></strong><span class="kobospan" id="kobo.496.1"> instance type of </span><span><span class="kobospan" id="kobo.497.1">favorite cats.</span></span></li></ul></li> <li class="calibre15"><span class="kobospan" id="kobo.498.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.499.1">PetsRepositoryImpl.kt</span></strong><span class="kobospan" id="kobo.500.1"> file, we need to update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.501.1">fetchRemotePets</span></strong><span class="kobospan" id="kobo.502.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.503.1">getPets</span></strong><span class="kobospan" id="kobo.504.1"> functions</span><a id="_idIndexMarker425" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.505.1"> to update the favorite status of the cat </span><span><span class="kobospan" id="kobo.506.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.507.1">
override suspend fun getPets(): Flow&lt;List&lt;Cat&gt;&gt; {
    return withContext(dispatcher) {
       catDao.getCats()
           .map { petsCached -&gt;
               petsCached.map { catEntity -&gt;
                   Cat(
                       id = catEntity.id,
                       owner = catEntity.owner,
                       tags = catEntity.tags,
                       createdAt = catEntity.createdAt,
                       updatedAt = catEntity.updatedAt,
                       isFavorite = catEntity.isFavorite
                   )
               }
           }
           .onEach {
               if (it.isEmpty()) {
                   fetchRemotePets()
               }
           }
    }
}
override suspend fun fetchRemotePets() {
    withContext(dispatcher) {
        val response = catsAPI.fetchCats("cute")
        if (response.isSuccessful) {
            response.body()!!.map {
                catDao.insert(CatEntity(
                    id = it.id,
                    owner = it.owner,
                    tags = it.tags,
                    createdAt = it.createdAt,
                    updatedAt = it.updatedAt,
                    isFavorite = it.isFavorite
                ))
            }
        }
    }
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.508.1">We add the </span><strong class="source-inline"><span class="kobospan" id="kobo.509.1">isFavorite</span></strong><span class="kobospan" id="kobo.510.1"> parameter to the </span><strong class="source-inline"><span class="kobospan" id="kobo.511.1">Cat</span></strong><span class="kobospan" id="kobo.512.1"> object when we are mapping the </span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">CatEntity</span></strong><span class="kobospan" id="kobo.514.1"> class to a </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">Cat</span></strong><span class="kobospan" id="kobo.516.1">. </span><span class="kobospan" id="kobo.516.2">This </span><a id="_idIndexMarker426" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.517.1">will ensure that we have the favorite status of the cat when we are fetching the cats from the remote and local </span><span><span class="kobospan" id="kobo.518.1">data sources.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.519.1">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.520.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.521.1"> class and add the following variables below the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.522.1">petsUIState</span></strong></span><span><span class="kobospan" id="kobo.523.1"> variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.524.1">
private val _favoritePets = MutableStateFlow&lt;List&lt;Cat&gt;&gt;(emptyList())
val favoritePets: StateFlow&lt;List&lt;Cat&gt;&gt; get() = _favoritePets</span></pre><p class="calibre4"><span class="kobospan" id="kobo.525.1">Here, we have created a private </span><strong class="source-inline"><span class="kobospan" id="kobo.526.1">MutableStateFlow</span></strong><span class="kobospan" id="kobo.527.1"> of favorite cats and a public </span><strong class="source-inline"><span class="kobospan" id="kobo.528.1">StateFlow</span></strong><span class="kobospan" id="kobo.529.1"> of favorite cats. </span><span class="kobospan" id="kobo.529.2">We will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">_favoritePets</span></strong><span class="kobospan" id="kobo.531.1"> variable to update the favorite cats and the </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">favoritePets</span></strong><span class="kobospan" id="kobo.533.1"> variable to observe the favorite cats. </span><span class="kobospan" id="kobo.533.2">This pattern is normally recommended to prevent exposing mutable states to the </span><span><span class="kobospan" id="kobo.534.1">view layer.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.535.1">Next, let us add these two </span><a id="_idIndexMarker427" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.536.1">functions below the </span><strong class="source-inline1"><span class="kobospan" id="kobo.537.1">getPets()</span></strong><span class="kobospan" id="kobo.538.1"> function in </span><span><span class="kobospan" id="kobo.539.1">the </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.540.1">PetsViewModel</span></strong></span><span><span class="kobospan" id="kobo.541.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.542.1">
fun updatePet(cat: Cat) {
    viewModelScope.launch {
        petsRepository.updatePet(cat)
    }
}
fun getFavoritePets() {
    viewModelScope.launch {
        petsRepository.getFavoritePets().collect {
            _favoritePets.value = it
        }
    }
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.543.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.544.1">updatePet</span></strong><span class="kobospan" id="kobo.545.1"> function will be called from the UI to update the favorite status of the cat. </span><span class="kobospan" id="kobo.545.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.546.1">getFavoritePets</span></strong><span class="kobospan" id="kobo.547.1"> function will be called from the UI to fetch the favorite cats from our database. </span><span class="kobospan" id="kobo.547.2">We collect the favorite cats from our database and update the </span><strong class="source-inline"><span class="kobospan" id="kobo.548.1">_favoritePets</span></strong><span class="kobospan" id="kobo.549.1"> variable. </span><span class="kobospan" id="kobo.549.2">With these changes, we are now ready to make changes to our views to be able to favorite a cat and see a list of </span><span><span class="kobospan" id="kobo.550.1">favorite pets.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.551.1">We will start by adding our favorite icon to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.552.1">PetListItem</span></strong><span class="kobospan" id="kobo.553.1"> composable. </span><span class="kobospan" id="kobo.553.2">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.554.1">PetList.kt</span></strong><span class="kobospan" id="kobo.555.1"> file and update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.556.1">PetListItem</span></strong><span class="kobospan" id="kobo.557.1"> composable to be</span><a id="_idIndexMarker428" class="calibre3 pcalibre pcalibre1"/> <span><span class="kobospan" id="kobo.558.1">the following:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.559.1">
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PetListItem(
    cat: Cat,
    onPetClicked: (Cat) -&gt; Unit,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(6.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 10.dp)
                .clickable {
                    onPetClicked(cat)
                }
        ) {
            AsyncImage(
                model = "https://cataas.com/cat/${cat.id}",
                contentDescription = "Cute cat",
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp),
                contentScale = ContentScale.FillWidth
            )
            Row(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
                    .fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                FlowRow(
                    modifier = Modifier
                        .padding(start = 6.dp, end = 6.dp)
                ) {
                    repeat(cat.tags.size) {
                        SuggestionChip(
                            modifier = Modifier
                                .padding(start = 3.dp, end = 3.dp),
                            onClick = { },
                            label = {
                                Text(text = cat.tags[it])
                            }
                        )
                    }
                }
                Icon(
                    modifier = Modifier
                        .clickable {
                            onFavoriteClicked(cat.copy(isFavorite = !cat.isFavorite))
                        },
                    imageVector = if (cat.isFavorite) {
                        Icons.Default.Favorite
                    } else {
                        Icons.Default.FavoriteBorder
                    },
                    contentDescription = "Favorite",
                    tint = if (cat.isFavorite) {
                        Color.Red
                    } else {
                        Color.Gray
                    },
                )
            }
        }
    }
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.560.1">We have added the </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">Icon</span></strong><span class="kobospan" id="kobo.562.1"> composable to the </span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">PetListItem</span></strong><span class="kobospan" id="kobo.564.1"> composable. </span><span class="kobospan" id="kobo.564.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.565.1">Icons.Default.Favorite</span></strong><span class="kobospan" id="kobo.566.1"> icon if the cat is favorited and the </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">Icons.Default.FavoriteBorder</span></strong><span class="kobospan" id="kobo.568.1"> icon if the cat is not favorited. </span><span class="kobospan" id="kobo.568.2">We have also used the </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">tint</span></strong><span class="kobospan" id="kobo.570.1"> parameter to change the color of the icon depending on the favorite status of the cat. </span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">Icon</span></strong><span class="kobospan" id="kobo.572.1"> is now inside a </span><strong class="source-inline"><span class="kobospan" id="kobo.573.1">Row</span></strong><span class="kobospan" id="kobo.574.1"> together with </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">FlowRow</span></strong><span class="kobospan" id="kobo.576.1">, which displays a </span><a id="_idIndexMarker429" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.577.1">list of tags. </span><span class="kobospan" id="kobo.577.2">We have also added the </span><strong class="source-inline"><span class="kobospan" id="kobo.578.1">onFavoriteClicked</span></strong><span class="kobospan" id="kobo.579.1"> parameter to the </span><strong class="source-inline"><span class="kobospan" id="kobo.580.1">PetListItem</span></strong><span class="kobospan" id="kobo.581.1"> composable. </span><span class="kobospan" id="kobo.581.2">We have used this parameter to update the favorite status of </span><span><span class="kobospan" id="kobo.582.1">the cat.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.583.1">Let us update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.584.1">PetList</span></strong><span class="kobospan" id="kobo.585.1"> composable to add a new callback parameter called </span><strong class="source-inline1"><span class="kobospan" id="kobo.586.1">onFavoriteClicked</span></strong><span class="kobospan" id="kobo.587.1"> and pass the parameter to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.588.1">PetListItem</span></strong></span><span><span class="kobospan" id="kobo.589.1"> composable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.590.1">
@Composable
fun PetList(
    onPetClicked: (Cat) -&gt; Unit,
    pets: List&lt;Cat&gt;,
    modifier: Modifier,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    LazyColumn(
        modifier = modifier
    ) {
        items(pets) { pet -&gt;
            PetListItem(
                cat = pet,
                onPetClicked = onPetClicked,
                onFavoriteClicked = onFavoriteClicked
            )
        }
    }
}</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.591.1">Next, we will add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.592.1">onFavoriteClicked</span></strong><span class="kobospan" id="kobo.593.1"> callback </span><a id="_idIndexMarker430" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.594.1">as a parameter to </span><span><span class="kobospan" id="kobo.595.1">the </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.596.1">PetsScreenContent</span></strong></span><span><span class="kobospan" id="kobo.597.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.598.1">
@Composable
fun PetsScreenContent(
    modifier: Modifier,
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
    petsUIState: PetsUIState,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    // code
    }</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.599.1">We can now pass the parameter to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.600.1">PetList</span></strong></span><span><span class="kobospan" id="kobo.601.1"> composable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.602.1">
PetList(
    onPetClicked = onPetClicked,
    pets = petsUIState.pets,
    modifier = Modifier
    .fillMaxWidth(),
    onFavoriteClicked = onFavoriteClicked
)</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.603.1">Let us update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.604.1">PetAndDetails</span></strong><span class="kobospan" id="kobo.605.1"> composable</span><a id="_idIndexMarker431" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.606.1"> to add the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.607.1">onFavoriteClicked</span></strong></span><span><span class="kobospan" id="kobo.608.1"> parameter:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.609.1">
@Composable
fun PetListAndDetails(
    pets: List&lt;Cat&gt;,
    onFavoriteClicked: (Cat) -&gt; Unit
) {
    // code
    }</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.610.1">We can now pass the parameter to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.611.1">PetList</span></strong></span><span><span class="kobospan" id="kobo.612.1"> composable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.613.1">
PetList(
    onPetClicked = {
    currentPet = it
    },
    pets = pets,
    modifier = Modifier
    .fillMaxWidth()
    .weight(1f),
    onFavoriteClicked = onFavoriteClicked
)</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.614.1">Back in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">PetsScreenContent.kt</span></strong><span class="kobospan" id="kobo.616.1"> file, we need to pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.617.1">onFavoriteClicked</span></strong><span class="kobospan" id="kobo.618.1"> parameter</span><a id="_idIndexMarker432" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.619.1"> to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.620.1">PetListAndDetails</span></strong></span><span><span class="kobospan" id="kobo.621.1"> composable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.622.1">
PetListAndDetails(
    pets = petsUIState.pets,
    onFavoriteClicked = onFavoriteClicked
)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.623.1">The final </span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">PetScreenContent.kt</span></strong><span class="kobospan" id="kobo.625.1"> file with all the changes we have made so far should look </span><span><span class="kobospan" id="kobo.626.1">like this:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer103">
<span class="kobospan" id="kobo.627.1"><img alt="Figure 8.4 – Updated PetscreenContent" src="image/B19779_08_04.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.628.1">Figure 8.4 – Updated PetscreenContent</span></p>
<ol class="calibre14">
<li value="12" class="calibre15"><span class="kobospan" id="kobo.629.1">Next, in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.630.1">PetsScreen</span></strong><span class="kobospan" id="kobo.631.1"> composable, which</span><a id="_idIndexMarker433" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.632.1"> is in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.633.1">PetsScreen.kt</span></strong><span class="kobospan" id="kobo.634.1"> file, we need to add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.635.1">onFavoriteClicked</span></strong><span class="kobospan" id="kobo.636.1"> parameter to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.637.1">PetsScreenContent</span></strong></span><span><span class="kobospan" id="kobo.638.1"> composable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.639.1">
PetsScreenContent(
    modifier = Modifier
        .fillMaxSize(),
    onPetClicked = onPetClicked,
    contentType = contentType,
    petsUIState = petsUIState,
    onFavoriteClicked = {
        petsViewModel.updatePet(it)
    }
)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.640.1">We have passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.641.1">onFavoriteClicked</span></strong><span class="kobospan" id="kobo.642.1"> callback to the </span><strong class="source-inline"><span class="kobospan" id="kobo.643.1">PetsScreenContent</span></strong><span class="kobospan" id="kobo.644.1"> composable. </span><span class="kobospan" id="kobo.644.2">We have called the </span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">updatePet</span></strong><span class="kobospan" id="kobo.646.1"> method of our </span><strong class="source-inline"><span class="kobospan" id="kobo.647.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.648.1"> class with</span><a id="_idIndexMarker434" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.649.1"> the updated cat object. </span><span class="kobospan" id="kobo.649.2">Let us run the app; it now has a new favorite icon. </span><span class="kobospan" id="kobo.649.3">If we click on the icon, the icon changes to a filled heart icon with a </span><span><span class="kobospan" id="kobo.650.1">red color:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer104">
<span class="kobospan" id="kobo.651.1"><img alt="Figure 8.5 – Cute cats with favorite" src="image/B19779_08_05.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.652.1">Figure 8.5 – Cute cats with favorite</span></p>
<ol class="calibre14">
<li value="13" class="calibre15"><span class="kobospan" id="kobo.653.1">Lastly, we are</span><a id="_idIndexMarker435" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.654.1"> going to update </span><strong class="source-inline1"><span class="kobospan" id="kobo.655.1">FavoritePetsScreen</span></strong><span class="kobospan" id="kobo.656.1"> to display a list of favorite cats. </span><span class="kobospan" id="kobo.656.2">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.657.1">FavoritePetsScreen.kt</span></strong><span class="kobospan" id="kobo.658.1"> file and update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.659.1">FavoritePetsScreen</span></strong><span class="kobospan" id="kobo.660.1"> composable to be </span><span><span class="kobospan" id="kobo.661.1">the following:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.662.1">
@Composable
fun FavoritePetsScreen(
    onPetClicked: (Cat) -&gt; Unit
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    LaunchedEffect(Unit) {
        petsViewModel.getFavoritePets()
    }
    val pets by petsViewModel.favoritePets.collectAsStateWithLifecycle()
    if (pets.isEmpty()) {
        Column(
            modifier = Modifier
                .fillMaxSize(),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(text = "No favorite pets")
        }
    } else {
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
        ) {
            items(pets) { pet -&gt;
                PetListItem(
                    cat = pet,
                    onPetClicked = onPetClicked,
                    onFavoriteClicked = {
                        petsViewModel.updatePet(it)
                    }
                )
            }
        }
    }
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.663.1">Here is an explanation</span><a id="_idIndexMarker436" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.664.1"> of </span><span><span class="kobospan" id="kobo.665.1">the changes:</span></span></p><ul class="calibre17"><li class="calibre15"><span class="kobospan" id="kobo.666.1">We have added a new parameter, </span><strong class="source-inline1"><span class="kobospan" id="kobo.667.1">onPetClicked</span></strong><span class="kobospan" id="kobo.668.1"> to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.669.1">FavoritePetsScreen</span></strong><span class="kobospan" id="kobo.670.1"> composable. </span><span class="kobospan" id="kobo.670.2">We will use this parameter to navigate to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.671.1">PetDetailsScreen</span></strong></span><span><span class="kobospan" id="kobo.672.1"> composable.</span></span></li><li class="calibre15"><span class="kobospan" id="kobo.673.1">We have created a new instance of our </span><strong class="source-inline1"><span class="kobospan" id="kobo.674.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.675.1"> class using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.676.1">koinViewModel()</span></strong></span><span><span class="kobospan" id="kobo.677.1"> method.</span></span></li><li class="calibre15"><span class="kobospan" id="kobo.678.1">We have called the </span><strong class="source-inline1"><span class="kobospan" id="kobo.679.1">getFavoritePets</span></strong><span class="kobospan" id="kobo.680.1"> function from our </span><strong class="source-inline1"><span class="kobospan" id="kobo.681.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.682.1"> class to get the favorite cats from our database. </span><span class="kobospan" id="kobo.682.2">We used </span><strong class="source-inline1"><span class="kobospan" id="kobo.683.1">LaunchedEffect</span></strong><span class="kobospan" id="kobo.684.1"> to call this method when the composable was first launched. </span><span class="kobospan" id="kobo.684.2">This is to ensure that we do not call the function every time the </span><span><span class="kobospan" id="kobo.685.1">composable recomposes.</span></span></li><li class="calibre15"><span class="kobospan" id="kobo.686.1">We have a new variable called </span><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">pets</span></strong><span class="kobospan" id="kobo.688.1">, which is a </span><strong class="source-inline1"><span class="kobospan" id="kobo.689.1">StateFlow</span></strong><span class="kobospan" id="kobo.690.1"> of favorite cats. </span><span class="kobospan" id="kobo.690.2">We have used the </span><strong class="source-inline1"><span class="kobospan" id="kobo.691.1">collectAsStateWithLifecycle</span></strong><span class="kobospan" id="kobo.692.1"> method to collect the favorite cats from our database. </span><span class="kobospan" id="kobo.692.2">This method is lifecycle aware and hence it will only collect the favorite cats when the composable </span><span><span class="kobospan" id="kobo.693.1">is active.</span></span></li><li class="calibre15"><span class="kobospan" id="kobo.694.1">We have added a check to see if the list of favorite cats is empty. </span><span class="kobospan" id="kobo.694.2">If it is empty, we display a message</span><a id="_idIndexMarker437" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.695.1"> to the user. </span><span class="kobospan" id="kobo.695.2">If it is not empty, we display a list of </span><span><span class="kobospan" id="kobo.696.1">favorite cats.</span></span></li></ul></li> <li class="calibre15"><span class="kobospan" id="kobo.697.1">We need to update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.698.1">AppNavigation.kt</span></strong><span class="kobospan" id="kobo.699.1"> file to pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.700.1">onPetClicked</span></strong><span class="kobospan" id="kobo.701.1"> callback to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.702.1">FavoritePetsScreen</span></strong></span><span><span class="kobospan" id="kobo.703.1"> composable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.704.1">
FavoritePetsScreen(
    onPetClicked = { cat -&gt;
        navHostController.navigate(
            "${Screens.PetDetailsScreen.route}/${Json.encodeToString(cat)}"
        )
    }
)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.705.1">This logic is like what we had in the </span><strong class="source-inline"><span class="kobospan" id="kobo.706.1">PetsScreen</span></strong><span class="kobospan" id="kobo.707.1"> and it handles navigation to </span><strong class="source-inline"><span class="kobospan" id="kobo.708.1">PetDetailsScreen</span></strong><span class="kobospan" id="kobo.709.1"> when we are in </span><strong class="source-inline"><span class="kobospan" id="kobo.710.1">FavoritePetsScreen</span></strong><span class="kobospan" id="kobo.711.1">. </span><span class="kobospan" id="kobo.711.2">Build and run the app. </span><span class="kobospan" id="kobo.711.3">Tap the favorite icon on the bottom bar and you should see a list of your favorite cute cats. </span><span class="kobospan" id="kobo.711.4">If you tap the favorite icon, the cat is immediately removed from the list of favorite cats. </span><span class="kobospan" id="kobo.711.5">This is because the list of favorite cats is a </span><strong class="source-inline"><span class="kobospan" id="kobo.712.1">Flow</span></strong><span class="kobospan" id="kobo.713.1"> and every time Room updates the data, they are immediately emitted to the </span><span><span class="kobospan" id="kobo.714.1">view layer.</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer105">
<span class="kobospan" id="kobo.715.1"><img alt="Figure 8.6 – Favorite Pets Screen" src="image/B19779_08_06.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.716.1">Figure 8.6 – Favorite Pets Screen</span></p>
<p class="calibre4"><span class="kobospan" id="kobo.717.1">We have been able to add the functionality to favorite cats and update this information in the Room database. </span><span class="kobospan" id="kobo.717.2">We </span><a id="_idIndexMarker438" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.718.1">have also been able to handle updates and migrations in the Room database. </span><span class="kobospan" id="kobo.718.2">In the next section, we will see how to use WorkManager to schedule background tasks. </span><span class="kobospan" id="kobo.718.3">In this case, we will use WorkManager to fetch the cats from the remote data source and save them to our database. </span><span class="kobospan" id="kobo.718.4">This improves our first offline experience since we will always have the latest data in </span><span><span class="kobospan" id="kobo.719.1">our database.</span></span></p>
<h1 id="_idParaDest-97" class="calibre6"><a id="_idTextAnchor108" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.720.1">Using WorkManager to schedule background tasks</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.721.1">WorkManager is a Jetpack library</span><a id="_idIndexMarker439" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.722.1"> that is best suited for performing long-running tasks in the background. </span><span class="kobospan" id="kobo.722.2">It ensures that background tasks are</span><a id="_idIndexMarker440" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.723.1"> completed even when your app restarts or the phone restarts. </span><span class="kobospan" id="kobo.723.2">With WorkManager, you can either schedule one-time jobs or </span><span><span class="kobospan" id="kobo.724.1">recurring jobs.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.725.1">We will start by adding the WorkManager dependency to our project. </span><span class="kobospan" id="kobo.725.2">Follow </span><span><span class="kobospan" id="kobo.726.1">these steps:</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.727.1">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.728.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.729.1"> file and define the work version in our </span><strong class="source-inline1"><span class="kobospan" id="kobo.730.1">versions</span></strong><span class="kobospan" id="kobo.731.1"> section </span><span><span class="kobospan" id="kobo.732.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.733.1">
work = "2.8.1"</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.734.1">In the libraries section, add the </span><span><span class="kobospan" id="kobo.735.1">following dependencies:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.736.1">
work-runtime = { module = "androidx.work:work-runtime-ktx", version.ref = "work" }
workmanager-koin = { module = "io.insert-koin:koin-androidx-workmanager", version.ref = "koin" }</span></pre><p class="calibre4"><span class="kobospan" id="kobo.737.1">Here, we have two dependencies: the </span><strong class="source-inline"><span class="kobospan" id="kobo.738.1">work-runtime-ktx</span></strong><span class="kobospan" id="kobo.739.1"> dependency, which is the core dependency for WorkManager, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.740.1">koin-androidx-workmanager</span></strong><span class="kobospan" id="kobo.741.1"> dependency, which is used to integrate WorkManager with Koin. </span><span class="kobospan" id="kobo.741.2">Sync the project for the changes to </span><span><span class="kobospan" id="kobo.742.1">be added.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.743.1">Next, we need to add the dependencies to the app-level </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.744.1">build.gradle.kts</span></strong></span><span><span class="kobospan" id="kobo.745.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.746.1">
implementation(libs.work.runtime)
implementation(libs.workmanager.koin)</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.747.1">Do a Gradle sync to add these dependencies to </span><span><span class="kobospan" id="kobo.748.1">our project.</span></span></li>
</ol>
<p class="calibre4"><span class="kobospan" id="kobo.749.1">We are now ready to start using WorkManager in our project. </span><span class="kobospan" id="kobo.749.2">We will use WorkManager to fetch the cats from the remote data source and save them to our database. </span><span class="kobospan" id="kobo.749.3">We will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.750.1">OneTimeWorkRequest</span></strong><span class="kobospan" id="kobo.751.1"> class to schedule a one-time job to fetch the cats from the remote data source and save them to our database. </span><span class="kobospan" id="kobo.751.2">Let’s get started with </span><span><span class="kobospan" id="kobo.752.1">the </span></span><span><a id="_idIndexMarker441" class="calibre3 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.753.1">steps:</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.754.1">Let us create a new package named </span><strong class="source-inline1"><span class="kobospan" id="kobo.755.1">workers</span></strong><span class="kobospan" id="kobo.756.1"> and create a new file inside it called </span><strong class="source-inline1"><span class="kobospan" id="kobo.757.1">PetsSyncWorker.kt</span></strong><span class="kobospan" id="kobo.758.1"> and add the </span><span><span class="kobospan" id="kobo.759.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.760.1">
class PetsSyncWorker(
    appContext: Context,
    workerParams: WorkerParameters,
    private val  petsRepository: PetsRepository
): CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result {
        return try {
            petsRepository.fetchRemotePets()
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.761.1">In the preceding code block, we have created a class that implements the </span><strong class="source-inline"><span class="kobospan" id="kobo.762.1">CoroutineWorker</span></strong><span class="kobospan" id="kobo.763.1"> class. </span><span class="kobospan" id="kobo.763.2">We</span><a id="_idIndexMarker442" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.764.1"> implement this class when we want to perform a long-running task in the background. </span><span class="kobospan" id="kobo.764.2">It uses coroutines to perform long-running tasks. </span><span class="kobospan" id="kobo.764.3">We have passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.765.1">appContext</span></strong><span class="kobospan" id="kobo.766.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.767.1">workerParams</span></strong><span class="kobospan" id="kobo.768.1"> parameters to the constructor of the class. </span><span class="kobospan" id="kobo.768.2">We have also passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.769.1">petsRepository</span></strong><span class="kobospan" id="kobo.770.1"> parameter to the constructor of the class. </span><span class="kobospan" id="kobo.770.2">We have overridden the </span><strong class="source-inline"><span class="kobospan" id="kobo.771.1">doWork</span></strong><span class="kobospan" id="kobo.772.1"> method, which is a </span><strong class="source-inline"><span class="kobospan" id="kobo.773.1">suspend</span></strong><span class="kobospan" id="kobo.774.1"> function that will be called when the work is scheduled. </span><span class="kobospan" id="kobo.774.2">We have called </span><strong class="source-inline"><span class="kobospan" id="kobo.775.1">fetchRemotePets</span></strong><span class="kobospan" id="kobo.776.1"> from </span><strong class="source-inline"><span class="kobospan" id="kobo.777.1">PetsRepository</span></strong><span class="kobospan" id="kobo.778.1"> to fetch the cats from the remote data source and save them to our database. </span><span class="kobospan" id="kobo.778.2">We are also returning </span><strong class="source-inline"><span class="kobospan" id="kobo.779.1">Result.success()</span></strong><span class="kobospan" id="kobo.780.1"> if the work is successful and </span><strong class="source-inline"><span class="kobospan" id="kobo.781.1">Result.failure()</span></strong><span class="kobospan" id="kobo.782.1"> if the </span><span><span class="kobospan" id="kobo.783.1">work fails.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.784.1">Next, let us create an instance of </span><strong class="source-inline1"><span class="kobospan" id="kobo.785.1">PetsSyncWorker</span></strong><span class="kobospan" id="kobo.786.1"> in our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.787.1">Module.kt</span></strong></span><span><span class="kobospan" id="kobo.788.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.789.1">
worker { PetsSyncWorker(get(), get(), get()) }</span></pre><p class="calibre4"><span class="kobospan" id="kobo.790.1">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.791.1">worker</span></strong><span class="kobospan" id="kobo.792.1"> Koin DSL to create an instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.793.1">PetsSyncWorker</span></strong><span class="kobospan" id="kobo.794.1">. </span><span class="kobospan" id="kobo.794.2">This is from the</span><a id="_idIndexMarker443" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.795.1"> Koin WorkManager library that we just added. </span><span class="kobospan" id="kobo.795.2">We have passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.796.1">appContext</span></strong><span class="kobospan" id="kobo.797.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.798.1">workerParams</span></strong><span class="kobospan" id="kobo.799.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.800.1">petsRepository</span></strong><span class="kobospan" id="kobo.801.1"> parameters </span><a id="_idIndexMarker444" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.802.1">to the constructor </span><span><span class="kobospan" id="kobo.803.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.804.1">PetsSyncWorker</span></strong></span><span><span class="kobospan" id="kobo.805.1">.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.806.1">Next, let us add this function in our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.807.1">MainActivity.kt</span></strong></span><span><span class="kobospan" id="kobo.808.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.809.1">
private fun startPetsSync() {
    val syncPetsWorkRequest = OneTimeWorkRequestBuilder&lt;PetsSyncWorker&gt;()
        .setConstraints(
            Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .setRequiresBatteryNotLow(true)
                .build()
        )
        .build()
    WorkManager.getInstance(applicationContext).enqueueUniqueWork(
        "PetsSyncWorker",
        ExistingWorkPolicy.KEEP,
        syncPetsWorkRequest
    )
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.810.1">In the preceding code, we created a new </span><strong class="source-inline"><span class="kobospan" id="kobo.811.1">OneTimeWorkRequest</span></strong><span class="kobospan" id="kobo.812.1"> using </span><strong class="source-inline"><span class="kobospan" id="kobo.813.1">PetSyncWorker</span></strong><span class="kobospan" id="kobo.814.1">. </span><span class="kobospan" id="kobo.814.2">We have also set some constraints o</span><a id="_idTextAnchor109" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.815.1">n our work request. </span><span class="kobospan" id="kobo.815.2">We have set the network type to </span><strong class="source-inline"><span class="kobospan" id="kobo.816.1">NetworkType.CONNECTED</span></strong><span class="kobospan" id="kobo.817.1"> to ensure that the work request is only executed when the device is connected to the internet. </span><span class="kobospan" id="kobo.817.2">We also have other network types, which are </span><span><span class="kobospan" id="kobo.818.1">as follows:</span></span></p><ul class="calibre17"><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.819.1">NOT_REQUIRED</span></strong><span class="kobospan" id="kobo.820.1">: For this type, a network is not required. </span><span class="kobospan" id="kobo.820.2">This is useful for tasks that do not </span><a id="_idIndexMarker445" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.821.1">need any internet connection </span><span><span class="kobospan" id="kobo.822.1">to work.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.823.1">UNMETERED</span></strong><span class="kobospan" id="kobo.824.1">: An unmetered </span><a id="_idIndexMarker446" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.825.1">network connection such as Wi-Fi is required for this type of network. </span><span class="kobospan" id="kobo.825.2">This is suitable for tasks that involve large </span><span><span class="kobospan" id="kobo.826.1">data transfers.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.827.1">METERED</span></strong><span class="kobospan" id="kobo.828.1">: A metered network connection is required for this type of network. </span><span class="kobospan" id="kobo.828.2">Tasks that require a significant amount of data might be deferred when the device is on a metered connection to avoid </span><span><span class="kobospan" id="kobo.829.1">unnecessary costs.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.830.1">NOT_ROAMING</span></strong><span class="kobospan" id="kobo.831.1">: For this type of work, a non-roaming connection is required. </span><span class="kobospan" id="kobo.831.2">This is relevant for tasks that might incur additional costs when executed when the device </span><span><span class="kobospan" id="kobo.832.1">is roaming.</span></span></li></ul><p class="calibre4"><span class="kobospan" id="kobo.833.1">We have also set the </span><strong class="source-inline"><span class="kobospan" id="kobo.834.1">BatteryNotLow constraint</span></strong><span class="kobospan" id="kobo.835.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.836.1">true</span></strong><span class="kobospan" id="kobo.837.1"> to ensure that the work request is only executed when the battery is not low. </span><span class="kobospan" id="kobo.837.2">We then used </span><strong class="source-inline"><span class="kobospan" id="kobo.838.1">WorkManager.getInstance(applicationContext)</span></strong><span class="kobospan" id="kobo.839.1"> to get an instance of the WorkManager and then called the </span><strong class="source-inline"><span class="kobospan" id="kobo.840.1">enqueueUniqueWork</span></strong><span class="kobospan" id="kobo.841.1"> method to enqueue our work request. </span><span class="kobospan" id="kobo.841.2">We have passed the name of our work request, </span><strong class="source-inline"><span class="kobospan" id="kobo.842.1">ExistingWorkPolicy</span></strong><span class="kobospan" id="kobo.843.1">, and the work request to the </span><strong class="source-inline"><span class="kobospan" id="kobo.844.1">enqueueUniqueWork</span></strong><span class="kobospan" id="kobo.845.1"> method. </span><strong class="source-inline"><span class="kobospan" id="kobo.846.1">ExistingWorkPolicy</span></strong><span class="kobospan" id="kobo.847.1"> is used to specify what should happen if there is already a work request with the same name. </span><span class="kobospan" id="kobo.847.2">We have used </span><strong class="source-inline"><span class="kobospan" id="kobo.848.1">ExistingWorkPolicy.KEEP</span></strong><span class="kobospan" id="kobo.849.1"> to ensure that the work request is not replaced if there is already a work request with the same name. </span><span class="kobospan" id="kobo.849.2">The following are other </span><span><span class="kobospan" id="kobo.850.1">available policies:</span></span></p><ul class="calibre17"><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.851.1">REPLACE</span></strong><span class="kobospan" id="kobo.852.1">: This cancels existing work with the same unique name and enqueues the new work. </span><span class="kobospan" id="kobo.852.2">This is suitable when we want only the latest version of the work to be</span><a id="_idIndexMarker447" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.853.1"> executed, discarding </span><span><span class="kobospan" id="kobo.854.1">previous instances.</span></span></li><li class="calibre15"><strong class="source-inline1"><span class="kobospan" id="kobo.855.1">APPEND</span></strong><span class="kobospan" id="kobo.856.1">: Enqueues the </span><a id="_idIndexMarker448" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.857.1">new work even if there is existing work with the same unique name. </span><span class="kobospan" id="kobo.857.2">Both new and existing work will be executed independently. </span><span class="kobospan" id="kobo.857.3">This is appropriate when we want multiple instances of the same work </span><span><span class="kobospan" id="kobo.858.1">to coexist.</span></span></li></ul><p class="calibre4"><span class="kobospan" id="kobo.859.1">We are now ready to start our work request. </span><span class="kobospan" id="kobo.859.2">We will start the work request in the </span><strong class="source-inline"><span class="kobospan" id="kobo.860.1">onCreate</span></strong><span class="kobospan" id="kobo.861.1"> method </span><span><span class="kobospan" id="kobo.862.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.863.1">MainActivity</span></strong></span><span><span class="kobospan" id="kobo.864.1">.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.865.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.866.1">MainActivity.kt</span></strong><span class="kobospan" id="kobo.867.1"> file, add the following code in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.868.1">onCreate</span></strong></span><span><span class="kobospan" id="kobo.869.1"> method:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.870.1">
startPetsSync()</span></pre><p class="calibre4"><span class="kobospan" id="kobo.871.1">Since we are using Koin, we need to disable the default WorkManager initialization in our </span><span><span class="kobospan" id="kobo.872.1">app manifest.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.873.1">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.874.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.875.1"> file and add the following code inside the </span><span><span class="kobospan" id="kobo.876.1">application tag:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.877.1">
&lt;provider
    android:name="androidx.startup.InitializationProvider"
    android:authorities="${applicationId}.androidx-startup"
    android:exported="false"
    tools:node="merge"&gt;
    &lt;!-- Removing WorkManager Default Initializer--&gt;
    &lt;meta-data
        android:name="androidx.work.WorkManagerInitializer"
        android:value="androidx.startup"
        tools:node="remove" /&gt;
&lt;/provider&gt;</span></pre><p class="calibre4"><span class="kobospan" id="kobo.878.1">Adding the preceding </span><a id="_idIndexMarker449" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.879.1">code prevents WorkManager </span><a id="_idIndexMarker450" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.880.1">from being initialized automatically. </span><span class="kobospan" id="kobo.880.2">Not doing this causes an app to crash once you set up Koin initialization. </span><span class="kobospan" id="kobo.880.3">The crash is caused by a conflict between Koin’s dependency injection and WorkManager’s default initialization. </span><span class="kobospan" id="kobo.880.4">Lastly, we have also removed App Startup (</span><a href="https://developer.android.com/topic/libraries/app-startup" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.881.1">https://developer.android.com/topic/libraries/app-startup</span></a><span class="kobospan" id="kobo.882.1">), which is used internally within WorkManager from </span><span><span class="kobospan" id="kobo.883.1">WorkManager 2.6.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.884.1">To set up a custom WorkManager instance, head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.885.1">ChapterEightApplication.kt</span></strong><span class="kobospan" id="kobo.886.1"> file and add the following code inside the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.887.1">startKoin</span></strong></span><span><span class="kobospan" id="kobo.888.1"> block:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.889.1">
workManagerFactory()</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.890.1">Build and run the app, and nothing changes. </span><span class="kobospan" id="kobo.890.2">However, we have scheduled a background task to fetch the cats from the remote data source and save them to </span><span><span class="kobospan" id="kobo.891.1">our database.</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer106">
<span class="kobospan" id="kobo.892.1"><img alt="Figure 8.7 – Cute cats" src="image/B19779_08_07.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.893.1">Figure 8.7 – Cute cats</span></p>
<p class="calibre4"><span class="kobospan" id="kobo.894.1">We have </span><a id="_idIndexMarker451" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.895.1">created our </span><strong class="source-inline"><span class="kobospan" id="kobo.896.1">PetsSyncWorker</span></strong><span class="kobospan" id="kobo.897.1"> class and learned how to do </span><a id="_idIndexMarker452" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.898.1">work in the background. </span><span class="kobospan" id="kobo.898.2">In the next section, we are going to write tests for our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.899.1">PetsSyncWorker</span></strong></span><span><span class="kobospan" id="kobo.900.1"> class.</span></span></p>
<h1 id="_idParaDest-98" class="calibre6"><a id="_idTextAnchor110" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.901.1">Testing your workers</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.902.1">Testing the code is very important. </span><span class="kobospan" id="kobo.902.2">It </span><a id="_idIndexMarker453" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.903.1">ensures that our code works as expected and it also helps us to catch bugs early. </span><span class="kobospan" id="kobo.903.2">We will be writing tests for our workers in this section. </span><span class="kobospan" id="kobo.903.3">To test our workers, we first need to set up WorkManager testing dependencies with the </span><span><span class="kobospan" id="kobo.904.1">following steps:</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.905.1">Let us head over to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.906.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.907.1"> file and add the following dependency to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.908.1">libraries</span></strong></span><span><span class="kobospan" id="kobo.909.1"> section:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.910.1">
work-testing = { module = "androidx.work:work-testing", version.ref = "work" }</span></pre><p class="calibre4"><span class="kobospan" id="kobo.911.1">Sync your project. </span><span class="kobospan" id="kobo.911.2">This will add the </span><strong class="source-inline"><span class="kobospan" id="kobo.912.1">work-testing</span></strong><span class="kobospan" id="kobo.913.1"> artifact that helps in testing workers to </span><span><span class="kobospan" id="kobo.914.1">our project.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.915.1">Next, we need to add the dependency to our app level </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.916.1">build.gradle.kts</span></strong></span><span><span class="kobospan" id="kobo.917.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.918.1">
androidTestImplementation(libs.work.testing)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.919.1">We have used </span><strong class="source-inline"><span class="kobospan" id="kobo.920.1">androidTestImplementation</span></strong><span class="kobospan" id="kobo.921.1"> because we will be writing our tests in the </span><strong class="source-inline"><span class="kobospan" id="kobo.922.1">androidTest</span></strong><span class="kobospan" id="kobo.923.1"> folder. </span><span class="kobospan" id="kobo.923.2">Do a Gradle sync to add the dependency to our project. </span><span class="kobospan" id="kobo.923.3">We are now ready to start writing </span><span><span class="kobospan" id="kobo.924.1">our tests.</span></span></p></li> </ol>
<p class="calibre4"><span class="kobospan" id="kobo.925.1">Since our </span><strong class="source-inline"><span class="kobospan" id="kobo.926.1">PetsSyncWorker</span></strong><span class="kobospan" id="kobo.927.1"> class requires some dependencies, we will create a test rule that provides the Koin dependencies that we need. </span><span class="kobospan" id="kobo.927.2">Let us head over to the </span><strong class="source-inline"><span class="kobospan" id="kobo.928.1">androidTest</span></strong><span class="kobospan" id="kobo.929.1"> folder, create a new file called </span><strong class="source-inline"><span class="kobospan" id="kobo.930.1">KoinTestRule.kt</span></strong><span class="kobospan" id="kobo.931.1">, and add the </span><span><span class="kobospan" id="kobo.932.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.933.1">
class KoinTestRule: TestRule {
    override fun apply(base: Statement?, description: Description?): Statement {
        return object : Statement() {
            override fun evaluate() {
                stopKoin()
                startKoin {
                    androidLogger(Level.ERROR)
                    androidContext(ApplicationProvider.getApplicationContext())
                    modules(appModules)
                }
            }
        }
    }
}</span></pre> <p class="calibre4"><strong class="source-inline"><span class="kobospan" id="kobo.934.1">KoinTestRule</span></strong><span class="kobospan" id="kobo.935.1"> implements the </span><strong class="source-inline"><span class="kobospan" id="kobo.936.1">TestRule</span></strong><span class="kobospan" id="kobo.937.1"> interface. </span><span class="kobospan" id="kobo.937.2">We have used this rule to provide the Koin dependencies that we need in our tests. </span><span class="kobospan" id="kobo.937.3">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.938.1">startKoin</span></strong><span class="kobospan" id="kobo.939.1"> method to provide the</span><a id="_idIndexMarker454" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.940.1"> Koin dependencies that we need. </span><span class="kobospan" id="kobo.940.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.941.1">androidContext(ApplicationProvider.getApplicationContext())</span></strong><span class="kobospan" id="kobo.942.1"> method to get the application context. </span><span class="kobospan" id="kobo.942.2">We have also used the </span><strong class="source-inline"><span class="kobospan" id="kobo.943.1">modules(appModules)</span></strong><span class="kobospan" id="kobo.944.1"> method to provide the Koin modules that we need. </span><span class="kobospan" id="kobo.944.2">Now, we are ready to start writing our tests. </span><span class="kobospan" id="kobo.944.3">Let us create a new file called </span><strong class="source-inline"><span class="kobospan" id="kobo.945.1">PetsSyncWorkerTest.kt</span></strong><span class="kobospan" id="kobo.946.1"> and add the </span><span><span class="kobospan" id="kobo.947.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.948.1">
@RunWith(AndroidJUnit4::class)
class PetsSyncWorkerTest {
    @get:Rule
    val koinTestRule = KoinTestRule()
    @Before
    fun setUp() {
        val config = Configuration.Builder()
            .setMinimumLoggingLevel(Log.DEBUG)
            .setExecutor(SynchronousExecutor())
            .build()
        // Initialize WorkManager for instrumentation tests.
</span><span class="kobospan1" id="kobo.948.2">        WorkManagerTestInitHelper.initializeTestWorkManager(
            ApplicationProvider.getApplicationContext(),
            config
        )
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.949.1">We have created a test class called </span><strong class="source-inline"><span class="kobospan" id="kobo.950.1">PetsSyncWorkerTest</span></strong><span class="kobospan" id="kobo.951.1">. </span><span class="kobospan" id="kobo.951.2">We have annotated the class with the </span><strong class="source-inline"><span class="kobospan" id="kobo.952.1">@RunWith(AndroidJUnit4::class)</span></strong><span class="kobospan" id="kobo.953.1"> annotation. </span><span class="kobospan" id="kobo.953.2">We have also created a </span><strong class="source-inline"><span class="kobospan" id="kobo.954.1">KoinTestRule</span></strong><span class="kobospan" id="kobo.955.1"> instance and</span><a id="_idIndexMarker455" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.956.1"> annotated it with the </span><strong class="source-inline"><span class="kobospan" id="kobo.957.1">@get:Rule</span></strong><span class="kobospan" id="kobo.958.1"> annotation to provide the </span><strong class="source-inline"><span class="kobospan" id="kobo.959.1">KoinTestRule</span></strong><span class="kobospan" id="kobo.960.1"> to our test class. </span><span class="kobospan" id="kobo.960.2">We have also created a </span><strong class="source-inline"><span class="kobospan" id="kobo.961.1">setup</span></strong><span class="kobospan" id="kobo.962.1"> function and annotated it with the </span><strong class="source-inline"><span class="kobospan" id="kobo.963.1">@Before</span></strong><span class="kobospan" id="kobo.964.1"> annotation. </span><span class="kobospan" id="kobo.964.2">This function will be executed before each test. </span><span class="kobospan" id="kobo.964.3">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.965.1">WorkManagerTestInitHelper</span></strong><span class="kobospan" id="kobo.966.1"> class to initialize WorkManager for instrumentation tests. </span><span class="kobospan" id="kobo.966.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.967.1">SynchronousExecutor</span></strong><span class="kobospan" id="kobo.968.1"> class to ensure that the work is executed synchronously. </span><span class="kobospan" id="kobo.968.2">This is to ensure that our tests are deterministic. </span><span class="kobospan" id="kobo.968.3">We are now ready to start writing </span><span><span class="kobospan" id="kobo.969.1">our tests.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.970.1">Follow these steps to create </span><span><span class="kobospan" id="kobo.971.1">our test:</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.972.1">We will start by creating a test function that will test the functionality of our worker. </span><span class="kobospan" id="kobo.972.2">Add the following code to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.973.1">PetsSyncWorkerTest.kt</span></strong><span class="kobospan" id="kobo.974.1"> file below the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.975.1">setup</span></strong></span><span><span class="kobospan" id="kobo.976.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.977.1">
@Test
fun testPetsSyncWorker() {
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.978.1">This is an empty function </span><a id="_idIndexMarker456" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.979.1">annotated with the </span><strong class="source-inline"><span class="kobospan" id="kobo.980.1">@</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.981.1">Test</span></strong></span><span><span class="kobospan" id="kobo.982.1"> annotation.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.983.1">Create a work request </span><span><span class="kobospan" id="kobo.984.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.985.1">
val syncPetsWorkRequest = OneTimeWorkRequestBuilder&lt;PetsSyncWorker&gt;()
    .setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()
    )
    .build()</span></pre><p class="calibre4"><span class="kobospan" id="kobo.986.1">In the preceding code, we have created a one-time request using our </span><strong class="source-inline"><span class="kobospan" id="kobo.987.1">PetsSyncWorker</span></strong><span class="kobospan" id="kobo.988.1"> class. </span><span class="kobospan" id="kobo.988.2">We have also set the constraints to our work request. </span><span class="kobospan" id="kobo.988.3">We have set the network type to </span><strong class="source-inline"><span class="kobospan" id="kobo.989.1">NetworkType.CONNECTED</span></strong><span class="kobospan" id="kobo.990.1"> to ensure that the work request is only executed when the device is connected to the internet. </span><span class="kobospan" id="kobo.990.2">We have also set the </span><strong class="source-inline"><span class="kobospan" id="kobo.991.1">BatteryNotLow</span></strong><span class="kobospan" id="kobo.992.1"> constraint to </span><strong class="source-inline"><span class="kobospan" id="kobo.993.1">true</span></strong><span class="kobospan" id="kobo.994.1"> to ensure that the work request is only executed when the battery is </span><span><span class="kobospan" id="kobo.995.1">not low.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.996.1">Next, set up the </span><span><span class="kobospan" id="kobo.997.1">test drivers:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.998.1">
val workManager = WorkManager.getInstance(ApplicationProvider.getApplicationContext())
val testDriver =
    WorkManagerTestInitHelper.getTestDriver(ApplicationProvider.getApplicationContext())!!</span></pre><p class="calibre4"><span class="kobospan" id="kobo.999.1">Here, we have set up the test</span><a id="_idIndexMarker457" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1000.1"> drivers that help us simulate conditions needed for our tests. </span><span class="kobospan" id="kobo.1000.2">For example, it simulates that constraints </span><span><span class="kobospan" id="kobo.1001.1">are met.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.1002.1">Enqueue the </span><span><span class="kobospan" id="kobo.1003.1">work request:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1004.1">
workManager.enqueueUniqueWork(
    "PetsSyncWorker",
    ExistingWorkPolicy.KEEP,
    syncPetsWorkRequest).result.get()</span></pre><p class="calibre4"><span class="kobospan" id="kobo.1005.1">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1006.1">enqueueUniqueWork</span></strong><span class="kobospan" id="kobo.1007.1"> method to enqueue our work request. </span><span class="kobospan" id="kobo.1007.2">We have passed the name of our work request, </span><strong class="source-inline"><span class="kobospan" id="kobo.1008.1">ExistingWorkPolicy</span></strong><span class="kobospan" id="kobo.1009.1">, and the work request to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1010.1">enqueueUniqueWork</span></strong><span class="kobospan" id="kobo.1011.1"> method. </span><span class="kobospan" id="kobo.1011.2">We have used </span><strong class="source-inline"><span class="kobospan" id="kobo.1012.1">ExistingWorkPolicy.KEEP</span></strong><span class="kobospan" id="kobo.1013.1"> to ensure that the work request is not replaced if there is already a work request with the same name. </span><span class="kobospan" id="kobo.1013.2">We have also used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1014.1">result.get()</span></strong><span class="kobospan" id="kobo.1015.1"> method to get the result of our </span><span><span class="kobospan" id="kobo.1016.1">work request.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.1017.1">Get the information about our work request using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1018.1">WorkInfo</span></strong></span><span><span class="kobospan" id="kobo.1019.1"> class:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1020.1">
val workInfo = workManager.getWorkInfoById(syncPetsWorkRequest.id).get()</span></pre><p class="calibre4"><span class="kobospan" id="kobo.1021.1">We are getting </span><strong class="source-inline"><span class="kobospan" id="kobo.1022.1">WorkInfo</span></strong><span class="kobospan" id="kobo.1023.1"> for our work request. </span><span class="kobospan" id="kobo.1023.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1024.1">getWorkInfoById</span></strong><span class="kobospan" id="kobo.1025.1"> method to get </span><strong class="source-inline"><span class="kobospan" id="kobo.1026.1">WorkInfo</span></strong><span class="kobospan" id="kobo.1027.1"> for our work request. </span><span class="kobospan" id="kobo.1027.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1028.1">result.get()</span></strong><span class="kobospan" id="kobo.1029.1"> method to get the result of our </span><span><span class="kobospan" id="kobo.1030.1">work request.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.1031.1">Next, let us get the worker state and assert that our work </span><span><span class="kobospan" id="kobo.1032.1">is enqueued:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1033.1">
assertEquals(WorkInfo.State.ENQUEUED, workInfo.state)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.1034.1">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1035.1">assertEquals</span></strong><span class="kobospan" id="kobo.1036.1"> method to assert that our work is enqueued. </span><span class="kobospan" id="kobo.1036.2">We have </span><a id="_idIndexMarker458" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1037.1">used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1038.1">WorkInfo.State.ENQUEUED</span></strong><span class="kobospan" id="kobo.1039.1"> to check if our work </span><span><span class="kobospan" id="kobo.1040.1">is enqueued.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.1041.1">Next, let us simulate our constraints being met by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1042.1">testDriver</span></strong><span class="kobospan" id="kobo.1043.1"> instance that we </span><span><span class="kobospan" id="kobo.1044.1">created earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1045.1">
testDriver.setAllConstraintsMet(syncPetsWorkRequest.id)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.1046.1">We use </span><strong class="source-inline"><span class="kobospan" id="kobo.1047.1">testDriver</span></strong><span class="kobospan" id="kobo.1048.1"> to simulate that the constraints are met. </span><span class="kobospan" id="kobo.1048.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1049.1">setAllConstraintsMet function</span></strong><span class="kobospan" id="kobo.1050.1"> to simulate that the constraints are met. </span><span class="kobospan" id="kobo.1050.2">We have passed the </span><strong class="source-inline"><span class="kobospan" id="kobo.1051.1">id</span></strong><span class="kobospan" id="kobo.1052.1"> of our work request to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1053.1">setAllConstraintsMet</span></strong><span class="kobospan" id="kobo.1054.1"> method. </span><span class="kobospan" id="kobo.1054.2">The work request </span><strong class="source-inline"><span class="kobospan" id="kobo.1055.1">id</span></strong><span class="kobospan" id="kobo.1056.1"> has an instance type of </span><strong class="source-inline"><span class="kobospan" id="kobo.1057.1">Universally Unique </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.1058.1">Identifier (UUID)</span></strong></span><span><span class="kobospan" id="kobo.1059.1">.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.1060.1">Lastly, let us get the output and state of </span><span><span class="kobospan" id="kobo.1061.1">our workers:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1062.1">
val postRequirementWorkInfo =
    workManager.getWorkInfoById(syncPetsWorkRequest.id).get()
assertEquals(WorkInfo.State.RUNNING, postRequirementWorkInfo.state)</span></pre><p class="calibre4"><span class="kobospan" id="kobo.1063.1">This is the final step of our test. </span><span class="kobospan" id="kobo.1063.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1064.1">getWorkInfoById</span></strong><span class="kobospan" id="kobo.1065.1"> method to get the </span><strong class="source-inline"><span class="kobospan" id="kobo.1066.1">WorkInfo</span></strong><span class="kobospan" id="kobo.1067.1"> of our work request. </span><span class="kobospan" id="kobo.1067.2">We have used the </span><strong class="source-inline"><span class="kobospan" id="kobo.1068.1">result.get()</span></strong><span class="kobospan" id="kobo.1069.1"> method to get the result of our work request. </span><span class="kobospan" id="kobo.1069.2">We have used </span><strong class="source-inline"><span class="kobospan" id="kobo.1070.1">WorkInfo.State.RUNNING</span></strong><span class="kobospan" id="kobo.1071.1"> to check if our work is running. </span><span class="kobospan" id="kobo.1071.2">Our final test function should look like </span><span><span class="kobospan" id="kobo.1072.1">the following:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer107">
<span class="kobospan" id="kobo.1073.1"><img alt="Figure 8.8 – PetsSyncWorker test" src="image/B19779_08_08.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1074.1">Figure 8.8 – PetsSyncWorker test</span></p>
<ol class="calibre14">
<li value="9" class="calibre15"><span class="kobospan" id="kobo.1075.1">Click the green run icon on the left of</span><a id="_idIndexMarker459" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1076.1"> our test to run the test. </span><span class="kobospan" id="kobo.1076.2">The test runs and it’s all green! </span><span class="kobospan" id="kobo.1076.3">Our test passes, as seen in the </span><span><span class="kobospan" id="kobo.1077.1">following screenshot:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer108">
<span class="kobospan" id="kobo.1078.1"><img alt="Figure 8.9 – Test results" src="image/B19779_08_09.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1079.1">Figure 8.9 – Test results</span></p>
<p class="calibre4"><span class="kobospan" id="kobo.1080.1">Making all these</span><a id="_idIndexMarker460" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1081.1"> tests work together is </span><span><span class="kobospan" id="kobo.1082.1">amazing work.</span></span></p>
<h1 id="_idParaDest-99" class="calibre6"><a id="_idTextAnchor111" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1083.1">Summary</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.1084.1">In this chapter, we learned how to save data to a local database, Room, which is part of the Jetpack libraries. </span><span class="kobospan" id="kobo.1084.2">We also saved items and read from the Room database. </span><span class="kobospan" id="kobo.1084.3">In the process, we also learned how to update items in the Room database and how to handle automated migrations in our database. </span><span class="kobospan" id="kobo.1084.4">Additionally, we learned how to do long-running operations using WorkManager, its best practices, and how to write tests for </span><span><span class="kobospan" id="kobo.1085.1">our workers.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.1086.1">In the next chapter, we will learn about runtime permissions and how to request them in </span><span><span class="kobospan" id="kobo.1087.1">our app.</span></span></p>
</div>
</body></html>