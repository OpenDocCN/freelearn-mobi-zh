<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Storing Information in a Database</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Storing Information in a Database</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="s1">In the last chapter,&#160; we touched on important topics, such as the use of third party libraries, Android application testing, and how to run background tasks on the Android platform.&#160;</span><span class="s1">In this chapter, we will focus on the storage of data. Over the course of this book, we have stored persistent application data at different instances when necessary. So far, we have made use of</span> <kbd>SharedPreferences</kbd> <span class="s1">to cater to all our data storage needs. This is by no means the only option for data storage the Android application framework provides. In this chapter, we will take an in-depth look at the means of data storage available to us on Android. In the process of doing this, we will learn about the following:</span></p>
<ul>
<li class="li1"><span class="s1">Internal storage</span></li>
<li class="li1"><span class="s1">External storage</span></li>
<li class="li1"><span class="s1">Network storage</span></li>
<li class="li1"><span class="s1">SQLite databases</span></li>
<li class="li1"><span class="s1">Content providers</span></li>
</ul>
<p class="p1"><span class="s1">In addition, we will identify which storage method is best for various use cases. Let's start the chapter off by learning about internal storage.</span></p>
<div class="packt_tip"><span>Ellipses between code signifies more code that will be present in the code files.</span></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with internal storage</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">This is an available storage medium on the Android application framework that empowers developers to store private data on a device's memory. As the word <em>private</em> implies, other applications cannot access the data stored by an app via internal storage. In addition, these files will be removed from storage when that app is uninstalled.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing files to internal storage</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In order to create a private file on internal storage, it is necessary to call <kbd>openFileOutput()</kbd>. The <kbd>openFileOutput()</kbd> function takes two arguments. The first is the name&#160;<span>(in form of a <kbd>String</kbd>)&#160;</span>of the file&#160;to open and the second is the operating mode. Note that <kbd>openFileOutput()</kbd> must be called within an instance of <kbd>Context</kbd>, such as an <kbd>Activity</kbd>.</span></p>
<p class="p1"><span class="s1">The <kbd>openFileOutput()</kbd>&#160;method returns a <kbd>FileOutputStream</kbd>. This can then be used to tell the file it is done with the <kbd>write()</kbd> method. Once writing is done, the <kbd>FileOutputStream</kbd> should be closed by calling its <kbd>close()</kbd> method. The following code snippet demonstrates this process:</span></p>
<pre class="p1"><span class="s1">private fun writeFile(fileName: String) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val content: String = "Hello world"<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val stream: FileOutputStream = openFileOutput(fileName,<br/>                                     Context.MODE_PRIVATE)<br/></span><span class="s1"><span class="Apple-converted-space">  </span>stream.write(content.toByteArray())<br/></span><span class="s1"><span class="Apple-converted-space">  </span>stream.close()<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1"><kbd>MODE_PRIVATE</kbd> is an operating mode that creates a file with a given name (or replaces a file with a corresponding name) and makes it private to your application.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading files from internal storage</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In order to read a private file, get a <kbd>FileInputStream</kbd> by calling <kbd>openFileInput()</kbd>. This method takes a single argument—the name of the file to be read. <kbd>openFileInput()</kbd> must be called within an instance of <kbd>Context</kbd>. After retrieving a <kbd>FileInputStream</kbd>, you read bytes from the file by calling its <kbd>read()</kbd> function. Once you are done reading from the file, close it by invoking <kbd>close()</kbd>.</span></p>
<p class="p1"><span class="s1">Check out the following code:</span></p>
<pre class="p1"><span class="s1">private fun readFile(fileName: String) {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val stream: FileInputStream = openFileInput(fileName)<br/>  val data = ByteArray(1024)<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>stream.read(data)<br/></span><span class="s1"><span class="Apple-converted-space">  </span>stream.close()<br/></span><span class="s1">}</span></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A sample application using internal storage</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As a suitable example generally helps the understanding of a concept, let's create a quick bare bones&#160;<em>file-updater</em> application that utilizes internal storage. The operation of the file updater is simple. It collects text data from the user via an input field and updates a file stored in internal storage. A user can then check the text existing in that file from a view within the application. Simple, right? It's supposed to be! Create a new Android project and name it whatever you want. Just ensure that whatever name you give it reflects the purpose of the application. Once the project is created, create two new packages named <kbd>base</kbd>&#160;and <kbd>main</kbd>, within the&#160;<kbd>src</kbd>&#160;project package.</span></p>
<p class="p1"><span class="s1">Add a <kbd>BaseView</kbd> interface to the <kbd>base</kbd>&#160;package, containing the following code:</span></p>
<pre><span>package </span>com.example.storageexamples.base<br/><span><br/></span><span>interface </span>BaseView {<br/><br/>  <span>fun </span><span>bindViews</span>()<br/><br/>  <span>fun </span><span>setupInstances</span>()<br/>}</pre>
<p class="p1"><span class="s1">You will already be familiar with view interface definitions if you read the previous chapter. If you haven't, this would be a good time to do so. In the <kbd>main</kbd>&#160;package, create a <kbd>MainView</kbd> extending the&#160;<kbd>BaseView</kbd> as follows:</span></p>
<pre><span>package </span>com.example.storageexamples.main<br/><br/><span>import </span>com.example.storageexamples.base.BaseView<br/><span><br/></span><span>interface </span>MainView : BaseView {<br/><br/>  <span>fun </span><span>navigateToHome</span>()<br/>  <span>fun </span><span>navigateToContent</span>()<br/>}</pre>
<p class="p1"><span class="s1">The file-updater application is going to have two distinct views in the form of fragments that can be shown to a user. The first view is the home view from which a user can update the content of the file, and the second a content view from which the user can read the content of the updated file.</span></p>
<p class="p1"><span class="s1">Now, create a new empty activity within <kbd>main</kbd>. Name this activity <kbd>MainActivity</kbd>. Ensure that you make <kbd>MainActivity</kbd> the launcher activity. Once <kbd>MainActivity</kbd> is created, ensure that it extends the&#160;<kbd>MainView</kbd> before proceeding. Open <kbd>activity_main.xml</kbd> and edit it to contain the following content:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;android.support.constraint.ConstraintLayout<br/><br/></span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span> </span><span>tools</span><span>:context=</span><span>"com.example.storageexamples.main.MainActivity"</span><span>&gt;<br/></span><span><br/></span><span>  &lt;LinearLayout<br/></span><span>         </span><span>android</span><span>:id=</span><span>"@+id/ll_container"<br/></span><span>         </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>         </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>         </span><span>android</span><span>:orientation=</span><span>"vertical"</span><span>/&gt;<br/></span><span>&lt;/android.support.constraint.ConstraintLayout&gt;<br/></span></pre>
<p class="p1"><span class="s1">We added a <kbd>LinearLayout</kbd> view group to the root view of the layout file. This layout is going to serve as the container for the home and content fragment of the application. We now need layouts for the home and content fragments. The following is the home fragment layout (<kbd>fragment_home.xml</kbd>):</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:paddingTop=</span><span>"@dimen/padding_default"<br/></span><span> </span><span>android</span><span>:paddingBottom=</span><span>"@dimen/padding_default"<br/></span><span> a</span><span>ndroid</span><span>:paddingStart=</span><span>"@dimen/padding_default"<br/></span><span> </span><span>android</span><span>:paddingEnd=</span><span>"@dimen/padding_default"<br/></span><span> </span><span>android</span><span>:gravity=</span><span>"center_horizontal"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"match_parent"</span><span>&gt;<br/></span><span>  &lt;TextView<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/tv_header"<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:text=</span><span>"@string/header_title"<br/></span><span>       </span><span>android</span><span>:textSize=</span><span>"45sp"<br/></span><span>       </span><span>android</span><span>:textStyle=</span><span>"bold"</span><span>/&gt;<br/></span><span>  &lt;EditText<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/et_input"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_top_large"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/hint_enter_text"</span><span>/&gt;<br/></span><span>  &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/btn_submit"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/submit"</span><span>/&gt;<br/></span><span>  &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/btn_view_file"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/view_file"<br/></span><span>        </span><span>android</span><span>:background=</span><span>"@android:color/transparent"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<p class="p1"><span class="s1">Before you open the design window to view how the layout translates we need to add some value resources. Your project's <kbd>strings.xml</kbd> file should look similar to the following (with the exception of the <kbd>app_name</kbd> string resource):</span></p>
<pre><span>&lt;resources&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"app_name"</span><span>&gt;</span>Storage Examples<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"hint_enter_text"</span><span>&gt;</span>Enter text here…<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"submit"</span><span>&gt;</span>Update file<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"view_file"</span><span>&gt;</span>View file<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"header_title"</span><span>&gt;</span>FILE UPDATER<span>&lt;/string&gt;<br/></span><span>&lt;/resources&gt;<br/></span></pre>
<p class="p1"><span class="s1">In addition, your project should have a <kbd>dimens.xml</kbd> file containing the following code:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;resources&gt;<br/></span><span>  &lt;dimen </span><span>name=</span><span>"padding_default"</span><span>&gt;</span>16dp<span>&lt;/dimen&gt;<br/></span><span>  &lt;dimen </span><span>name=</span><span>"margin_default"</span><span>&gt;</span>16dp<span>&lt;/dimen&gt;<br/></span><span>  &lt;dimen </span><span>name=</span><span>"margin_top_large"</span><span>&gt;</span>64dp<span>&lt;/dimen&gt;<br/></span><span>&lt;/resources&gt;</span></pre>
<p class="p1"><span class="s1">Once you are done adding the preceding resources, you can view the layout design window of <kbd>fragment_home.xml</kbd>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/4d2dc4f3-2dcf-4ca9-b5f0-11a0ae9d4047.jpg" style="width:30.33em;height:24.75em;"/></div>
<p class="p1"><span class="s1">Now for the content fragment layout. Add a <kbd>fragment_content.xml</kbd> layout file to the layout resource directory containing the following code:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:padding=</span><span>"@dimen/padding_default"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"match_parent"</span><span>&gt;<br/></span><span>  &lt;TextView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/tv_content"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:textSize=</span><span>"20sp"<br/></span><span>        </span><span>android</span><span>:textStyle=</span><span>"bold"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<p class="p1"><span class="s1">The layout contains a single <kbd>TextView</kbd>&#160;that will render the text existing in the internal storage file to the user of the application. You can check the layout design window if you want, but there will not be much to see.</span></p>
<p class="p1"><span class="s1">We have reached the point where we need to create appropriate fragment classes to render the fragment layouts we just created. Add the <kbd>HomeFragment</kbd> class to <kbd>MainActivity</kbd>, which is as follows:</span></p>
<pre><span>class </span>HomeFragment : Fragment()<span>, </span>BaseView<span>, </span>View.OnClickListener {<br/><br/>  <span>private lateinit var </span><span>layout</span>: LinearLayout<br/>  <span>private lateinit var </span><span>tvHeader</span>: TextView<br/>  <span>private lateinit var </span><span>etInput</span>: EditText<br/>  <span>private lateinit var </span><span>btnSubmit</span>: Button<br/>  <span>private lateinit var </span><span>btnViewFile</span>: Button<br/><br/>  <span>private var </span><span>outputStream</span>: FileOutputStream? = null<br/><br/><br/>  <span>override fun </span><span>onCreateView</span>(inflater: LayoutInflater<span>,<br/>                            </span>container: ViewGroup?<span>,<br/></span><span>                            </span>savedInstanceState: Bundle?): View {<br/><br/>    <span>// inflate the fragment_home.xml layout<br/></span><span>    </span><span>layout </span>= inflater.inflate(R.layout.<span>fragment_home</span><span>,<br/></span><span>                              </span>container<span>, false</span>) <span>as </span>LinearLayout<br/>    setupInstances()<br/>    bindViews()<br/><br/>    <span>return </span><span>layout<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>bindViews</span>() {<br/>    <span>tvHeader </span>= <span>layout</span>.findViewById(R.id.<span>tv_header</span>)<br/>    <span>etInput </span>= <span>layout</span>.findViewById(R.id.<span>et_input</span>)<br/>    <span>btnSubmit </span>= <span>layout</span>.findViewById(R.id.<span>btn_submit</span>)<br/>    <span>btnViewFile </span>= <span>layout</span>.findViewById(R.id.<span>btn_view_file</span>)<br/><br/>    <span>btnSubmit</span>.setOnClickListener(<span>this</span>)<br/>    <span>btnViewFile</span>.setOnClickListener(<span>this</span>)<br/>  }</pre>
<p><span>The following method is for the instantiation of instance properties:</span></p>
<pre><span>  </span><span>override fun </span><span>setupInstances</span>() {   </pre>
<p><span>Let's open a new <kbd>FileOutputStream</kbd> to a file named <kbd>content_file</kbd>.&#160;</span><span>This file is a private file stored in internal storage</span> <span>and as such is only accessible by your application:</span></p>
<pre><span>    </span><span>outputStream </span>= <span>activity?</span>.openFileOutput(<span>"content_file"</span><span>,<br/>                                            </span>Context.<span>MODE_PRIVATE</span>)<br/>  }</pre>
<p><span>The following function is called to display an error to the user if&#160;</span><span>an invalid input is given:</span></p>
<pre><span>private fun </span><span>showInputError</span>() {<br/>  e<span>tInput</span>.<span>error </span>= <span>"File input cannot be empty."<br/></span><span>  </span><span>etInput</span>.requestFocus()<br/>} </pre>
<p><span>Let's write a string content with the use of file via a</span> <kbd><span>FileOutputStream</span></kbd></p>
<pre><span>private fun </span><span>writeFile</span>(content: String) {<br/>  <span>outputStream?</span>.write(content.<span>toByteArray</span>())<br/>  <span>outputStream?</span>.close()<br/>}</pre>
<p><span>And the function below is called to clear the input in the input field:</span></p>
<pre><span>private fun </span><span>clearInput</span>() {<br/>  <span>etInput</span>.setText(<span>""</span>)<br/>} </pre>
<p><span>The following code snippet shows a success message to the user when invoked:</span></p>
<pre><span>private fun </span><span>showSaveSuccess</span>() {<br/>  Toast.makeText(<span>activity</span><span>, </span><span>"File updated successfully."</span><span>,<br/>                 </span>Toast.<span>LENGTH_LONG</span>).show()<br/>}<br/><br/><span>override fun </span><span>onClick</span>(view: View?) {<br/>  <span>val </span>id = view?.<span>id<br/></span><span><br/></span><span>  </span><span>if </span>(id == R.id.<span>btn_submit</span>) {<br/>    <span>if </span>(TextUtils.isEmpty(<span>etInput</span>.<span>text</span>)) {    </pre>
<p><span>It will display an error message if the user submits a</span><span>n empty value as file content input:</span></p>
<pre><span>  </span>showInputError()<br/>} <span>else </span>{      </pre>
<p><span>Let's write content to the file, clear the input</span> <span><kbd>EditText</kbd> and show a file update success message:</span></p>
<pre><span>     </span>writeFile(<span>etInput</span>.<span>text</span>.toString())<br/>     clearInput()<br/>     showSaveSuccess()<br/>   }<br/>} <span>else if </span>(id == R.id.<span>btn_view_file</span>) {<br/>  <span>// retrieve a reference to MainActivity<br/></span><span>  </span><span>val </span>mainActivity = <span>activity </span><span>as </span>MainActivity</pre>
<p><span>Let's navigate user to the content fragment</span> <span>and display home button on action bar to</span> <span>enable a user go back to the previous fragment:</span></p>
<pre><span>      </span>mainActivity.navigateToContent()<br/>      mainActivity.showHomeNavigation()<br/>    }<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">Read through the comments of <kbd>HomeFragment</kbd> to ensure you understand what’s going on. Now that we have added <kbd>HomeFragment</kbd> to <kbd>MainActivity</kbd>, we must also add a fragment to render the <kbd>fragment_content.xml</kbd> layout to a user. The following is the necessary <kbd>ContentFragment</kbd> class. Add this class to <kbd>MainActivity</kbd>:</span></p>
<pre><span>class </span>ContentFragment : Fragment()<span>, </span>BaseView {<br/><br/>  <span>private lateinit var </span><span>layout</span>: LinearLayout<br/>  <span>private lateinit var </span><span>tvContent</span>: TextView<br/><br/>  <span>private lateinit var </span><span>inputStream</span>: FileInputStream<br/><br/>  <span>override fun </span><span>onCreateView</span>(inflater: LayoutInflater?<span>,<br/>                            </span>container: ViewGroup?<span>,<br/></span><span>                            </span>savedInstanceState: Bundle?): View {<br/><br/>    <span>layout </span>= inflater?.inflate(R.layout.<span>fragment_content</span><span>,<br/></span><span>                               </span>container<span>, false</span>) <span>as </span>LinearLayout<br/>    setupInstances()<br/>    bindViews()<br/><br/>    <span>return </span><span>layout<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>onResume</span>() {</pre>
<p><span>Let's update content rendered in <kbd>TextView</kbd> upon</span> <span>resumption of fragment:</span></p>
<pre><span>  </span>updateContent()<br/>  <span>super</span>.onResume()<br/>}<br/><br/><span>private fun </span><span>updateContent</span>() {<br/>  <span>tvContent</span>.<span>text </span>= readFile()<br/>}<br/><br/><span>override fun </span><span>bindViews</span>() {<br/>  <span>tvContent </span>= <span>layout</span>.findViewById(R.id.<span>tv_content</span>)<br/>}<br/><br/><span>override fun </span><span>setupInstances</span>() {<br/>  <span>inputStream </span>= <span>activity</span>.openFileInput(<span>"content_file"</span>)<br/>}</pre>
<p><span>The following code reads the content of file in internal storage</span> <span>and returns content as a string:</span></p>
<pre><span>  </span><span>private fun </span><span>readFile</span>(): String {<br/>    <span>var </span>c: Int<br/>    <span>var </span>content = <span>""<br/></span><span><br/></span><span>    </span>c = <span>inputStream</span>.read()<br/><br/>    <span>while </span>(c != -<span>1</span>) {<br/>      content += Character.toString(c.toChar())<br/>      c = <span>inputStream</span>.read()<br/>    }<br/><br/>    <span>inputStream</span>.close()<br/><br/>    <span>return </span>content<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>tvContent</kbd>&#160;instance (the <kbd>TextView</kbd> displaying the file content to the user) is updated upon resumption of the <kbd>ContentFragment</kbd> activity. The content of the <kbd>TextView</kbd> is updated by setting the text of the <kbd>TextView</kbd> to the content read from the file with <kbd>readFile()</kbd>. The last thing that is necessary is the completion of <kbd>MainActivity</kbd>.</span></p>
<p class="p1"><span class="s1">Your fully completed <kbd>MainActivity</kbd> class should look similar to the following:</span></p>
<pre><span>package </span>com.example.storageexamples.main<br/><br/><span>import </span>android.aupport.v4.app.Fragment<br/><span>import </span>android.content.Context<br/><span>import </span>android.support.v7.app.AppCompatActivity<br/><span>import </span>android.os.Bundle<br/><span>import </span>android.text.TextUtils<br/><span>import </span>android.view.LayoutInflater<br/><span>import </span>android.view.MenuItem<br/><span>import </span>android.view.View<br/><span>import </span>android.view.ViewGroup<br/><span>import </span>android.widget.*<br/><span>import </span>com.example.storageexamples.R<br/><span>import </span>com.example.storageexamples.base.BaseView<br/><span>import </span>java.io.FileInputStream<br/><span>import </span>java.io.FileOutputStream<br/><br/><span>class </span>MainActivity : AppCompatActivity()<span>, </span>MainView {<br/><br/>  <span>private lateinit var </span><span>llContainer</span>: LinearLayout<br/><br/> </pre>
<p><span>Let's set up fragment instances:</span></p>
<pre><span><br/></span><span>  </span><span>private lateinit var </span><span>homeFragment</span>: HomeFragment<br/>  <span>private lateinit var </span><span>contentFragment</span>: ContentFragment<br/><br/>  <span>override fun </span><span>onCreate</span>(savedInstanceState: Bundle?) {<br/>    <span>super</span>.onCreate(savedInstanceState)<br/>    setContentView(R.layout.<span>activity_main</span>)<br/>    setupInstances()<br/>    bindViews()<br/>    navigateToHome()<br/>  }<br/><br/>  <span>override fun </span><span>bindViews</span>() {<br/>    <span>llContainer </span>= findViewById(R.id.<span>ll_container</span>)<br/>  }<br/><br/>  <span>override fun </span><span>setupInstances</span>() {<br/>    <span>homeFragment </span>= HomeFragment()<br/>    <span>contentFragment </span>= ContentFragment()<br/>  }<br/><br/>  <span>private fun </span><span>hideHomeNavigation</span>() {<br/>    <span>supportActionBar</span>?.setDisplayHomeAsUpEnabled(<span>false</span>)<br/>  }<br/><br/>  <span>private fun </span><span>showHomeNavigation</span>() {<br/>    <span>supportActionBar</span>?.setDisplayHomeAsUpEnabled(<span>true</span>)<br/>  }<br/><br/>  <span>override fun </span><span>navigateToHome</span>() {<br/>    <span>val </span>transaction = supportF<span>ragmentManager</span>.beginTransaction()<br/>    transaction.replace(R.id.<span>ll_container</span><span>, </span><span>homeFragment</span>)<br/>    transaction.commit()<br/><br/>    <span>supportActionBar</span>?.<span>title </span>= <span>"Home"<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>navigateToContent</span>() {<br/>    <span>val </span>transaction = supportF<span>ragmentManager</span>.beginTransaction()<br/>    transaction.replace(R.id.<span>ll_container</span><span>, </span><span>contentFragment</span>)<br/>    transaction.commit()<br/><br/>    <span>supportActionBar</span>?.<span>title </span>= <span>"File content"<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>onOptionsItemSelected</span>(item: MenuItem?): Boolean {<br/>    <span>val </span>id = item?.<span>itemId<br/></span><span><br/>    </span><span>if </span>(id == android.R.id.<span>home</span>) {<br/>      navigateToHome()<br/>      hideHomeNavigation()<br/>    }<br/><br/>    <span>return super</span>.onOptionsItemSelected(item)<br/>  }<br/><br/>  <span>class </span>HomeFragment : Fragment()<span>, </span>BaseView<span>, </span>View.OnClickListener {<br/><br/>    <span>private lateinit var </span><span>layout</span>: LinearLayout<br/>    <span>private lateinit var </span><span>tvHeader</span>: TextView<br/>    <span>private lateinit var </span><span>etInput</span>: EditText<br/>    <span>private lateinit var </span><span>btnSubmit</span>: Button<br/>    <span>private lateinit var </span><span>btnViewFile</span>: Button<br/><br/>    <span>private lateinit var </span><span>outputStream</span>: FileOutputStream<br/><br/><br/>    <span>override fun </span><span>onCreateView</span>(inflater: LayoutInflater?<span>,<br/>                              </span>container: ViewGroup?<span>,<br/></span><span>                              </span>savedInstanceState: Bundle?): View {</pre>
<p><span>Let's create the <kbd>fragment_home.xml</kbd> layout:</span></p>
<pre><span>  </span><span>layout </span>= inflater?.inflate(R.layout.<span>fragment_home</span><span>,<br/></span><span>                             </span>container<span>, false</span>) <span>as </span>LinearLayout<br/>  setupInstances()<br/>  bindViews()<br/><br/>  <span>return </span><span>layout<br/></span>}<br/><br/><span>override fun </span><span>bindViews</span>() {<br/>  <span>tvHeader </span>= <span>layout</span>.findViewById(R.id.<span>tv_header</span>)<br/>  <span>etInput </span>= <span>layout</span>.findViewById(R.id.<span>et_input</span>)<br/>  <span>btnSubmit </span>= <span>layout</span>.findViewById(R.id.<span>btn_submit</span>)<br/>  <span>btnViewFile </span>= <span>layout</span>.findViewById(R.id.<span>btn_view_file</span>)<br/><br/>  <span>btnSubmit</span>.setOnClickListener(<span>this</span>)<br/>  <span>btnViewFile</span>.setOnClickListener(<span>this</span>)<br/>}<br/><br/><span>//</span><span>Method for the instantiation of instance properties</span><span><br/></span><span>override fun </span><span>setupInstances</span>() {</pre>
<p><span>Let's open a new <kbd>FileOutputStream</kbd> to a file named <kbd>content_file</kbd>.&#160;</span><span>This file is a private file stored in internal storage</span> <span>and as such is only accessible by your application:</span></p>
<pre><span><br/></span><span>  </span><span>outputStream </span>= <span>activity</span>.openFileOutput(<span>"content_file"</span><span>,<br/>                                         </span>Context.<span>MODE_PRIVATE</span>)<br/>}<br/><br/>//<span>Called to display an error to the user if </span><span>an invalid input is given<br/></span><span>    <br/></span><span>private fun </span><span>showInputError</span>() {<br/>  <span>etInput</span>.<span>error </span>= <span>"File input cannot be empty."<br/></span><span>  </span><span>etInput</span>.requestFocus()<br/>}<br/><br/><span>// </span><span>Writes string content to a file via a </span><span>[FileOutputStream]</span><span><br/></span><span>private fun </span><span>writeFile</span>(content: String) {<br/>  <span>outputStream</span>.write(content.<span>toByteArray</span>())<br/>}<br/><br/><span>//</span><span>Called to clear the input in the input field<br/></span><span><br/></span><span>private fun </span><span>clearInput</span>() {<br/>  <span>etInput</span>.setText(<span>""</span>)<br/>}<br/><br/><span>//</span><span>Shows a success message to the user when invoked.<br/></span><span>  <br/></span><span>private fun </span><span>showSaveSuccess</span>() {<br/>  Toast.makeText(<span>activity</span><span>, </span><span>"File updated successfully."</span><span>,<br/>                 </span>Toast.<span>LENGTH_LONG</span>).show()<br/>}<br/><br/><span>override fun </span><span>onClick</span>(view: View?) {<br/>  <span>val </span>id = view?.<span>id<br/></span><span><br/>  </span><span>if </span>(id == R.id.<span>btn_submit</span>) {</pre>
<p><span>The following code snippet displays an error message if the user submits</span> <span>an empty value as file content input:</span></p>
<pre><span>  if </span>(TextUtils.isEmpty(<span>etInput</span>.<span>text</span>)) {<br/>    <span>showInputError()<br/></span>  } <span>else </span>{<br/>    //<span>Write content to the file, clear the input<br/></span><span>    //EditText and show a file update success message<br/></span><span>        <br/></span><span>    </span>writeFile(<span>etInput</span>.<span>text</span>.toString())<br/>    clearInput()<br/>    showSaveSuccess()<br/>  }<br/>} <span>else if </span>(id == R.id.<span>btn_view_file</span>) {<br/>  <span>// retrieve a reference to MainActivity<br/></span><span>  </span><span>val </span>mainActivity = <span>activity </span><span>as </span>MainActivity  </pre>
<p><span>We will navigate user to the content fragment</span> <span>and display home button on action bar to</span> <span>enable a user go back to the previous fragment:</span></p>
<pre><span><br/></span><span>       </span>mainActivity.navigateToContent()<br/>      mainActivity.showHomeNavigation()<br/>    }<br/>  }<br/>}<br/><br/><span>class </span>ContentFragment : Fragment()<span>, </span>BaseView {<br/><br/>  <span>private lateinit var </span><span>layout</span>: LinearLayout<br/>  <span>private lateinit var </span><span>tvContent</span>: TextView<br/><br/>  <span>private lateinit var </span><span>inputStream</span>: FileInputStream<br/><br/>  o<span>verride fun </span><span>onCreateView</span>(inflater: LayoutInflater?<span>,<br/>                            </span>container: ViewGroup?<span>,<br/></span><span>                            </span>savedInstanceState: Bundle?): View {<br/><br/>    <span>layout </span>= inflater?.inflate(R.layout.<span>fragment_content</span><span>,<br/></span><span>                         </span>container<span>, false</span>) <span>as </span>LinearLayout<br/>    setupInstances()<br/>    bindViews()<br/><br/>    <span>return </span><span>layout<br/></span>}</pre>
<p><span>Let's update content rendered in <kbd>TextView</kbd> upon</span> <span>resumption of fragment:</span></p>
<pre><span>override fun </span><span>onResume</span>() {<span><br/></span><span>  </span>updateContent()<br/>  <span>super</span>.onResume()<br/>}<br/><br/><span>private fun </span><span>updateContent</span>() {<br/>  <span>tvContent</span>.<span>text </span>= readFile()<br/>}<br/><br/><span>override fun </span><span>bindViews</span>() {<br/>  <span>tvContent </span>= <span>layout</span>.findViewById(R.id.<span>tv_content</span>)<br/>}<br/><br/><span>override fun </span><span>setupInstances</span>() {<br/>  <span>inputStream </span>= <span>activity</span>.openFileInput(<span>"content_file"</span>)<br/>}</pre>
<p><span>Now, we will read the content of file in internal storage</span> <span>and return content as a string:</span></p>
<pre><span>    </span><span>private fun </span><span>readFile</span>(): String {<br/>      <span>var </span>c: Int<br/>      <span>var </span>content = <span>""<br/></span><span><br/>      </span>c = <span>inputStream</span>.read()<br/><br/>      <span>while </span>(c != -<span>1</span>) {<br/>        content += Character.toString(c.toChar())<br/>        c = <span>inputStream</span>.read()<br/>      }<br/><br/>      <span>inputStream</span>.close()<br/><br/>      <span>return </span>content<br/>    }<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">Now that we have completed <kbd>MainActivity</kbd>, the application is ready to be run.&#160;</span></p>
<p class="p1"><span class="s1">Build and run the project on a device of your choice. Upon launch of the application, the home fragment of <kbd>MainActivity</kbd> will be presented on the device's display. Type in any content of your choice within the&#160;<kbd>EditText</kbd>&#160;input:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/eab3fed7-7d1e-46ad-99f4-6fc3eba4f395.jpg" style="width:17.67em;height:31.75em;"/></div>
<p class="p1"><span class="s1">After adding content to the <kbd>EditText</kbd>, click the <span class="packt_screen">UPDATE FILE</span> button. The internal storage file will be updated with the content provided, and you will be notified upon completion of this update with a toast message. Having updated the file, click the <span class="packt_screen">VIEW FILE</span> button:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/f24940a3-9fdf-4e4b-a9cb-23fd51e3750f.jpg" style="width:16.92em;height:30.17em;"/></div>
<div>
<p class="p1"><span class="s1">The content fragment will be displayed with its <kbd>TextView</kbd> containing the updated file content. Though simple, the file-updater application we just created is a good example showing how Android applications work with internal storage.</span></p>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Saving cached files</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In the event that you would rather not store data permanently, but instead cache data within storage, make use of <kbd>cacheDir</kbd> to open a file that represents a directory (within internal storage) where your application should save temporary cache files.</span></p>
<p class="p1"><span class="s1"><kbd>cacheDir</kbd> returns a&#160;<kbd>File</kbd>. As such, you may make use of all methods put at your disposal by the <kbd>File</kbd> class, such as the&#160;<kbd>outputStream()</kbd>, which returns a <kbd>FileOutputStream</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with external storage</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">External storage is used to create and access non-private, shared, world-readable files. Shared external storage is supported by all Android devices. The first thing you need to start using external storage is its permission.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting external storage permission</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The <kbd>READ_EXTERNAL_STORAGE</kbd> and <kbd>WRITE_EXTERNAL_STORAGE</kbd> permissions must be acquired by your application before it can make use of external storage APIs. <kbd>READ_EXTERNAL_STORAGE</kbd> is necessary when you only need to read from external storage. The <kbd>WRITE_EXTERNAL_STORAGE</kbd> permission is necessary when your application requires the ability to write directly to external storage.</span></p>
<p class="p1"><span class="s1">These two permissions can be added with ease to the manifest file, as we have seen in previous chapters:</span></p>
<pre class="p1"><span class="s1">&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;<br/></span><span class="s1">&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;</span></pre>
<p class="p1"><span class="s1">It should be noted that <kbd>WRITE_EXTERNAL_STORAGE</kbd> implicitly includes <kbd>READ_EXTERNAL_STORAGE</kbd>. As such, if both permissions are required, it is only necessary to request the <kbd>WRITE_EXTERNAL_STORAGE</kbd> permission:</span></p>
<pre class="p1">&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Asserting media availability</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Sometimes—for one reason or another, such as<span class="Apple-converted-space">&#160;</span>the storage device being missing—an external storage medium may not be available for access. As a consequence, it is important to check the availability of external storage media before attempting to make use of them.</span></p>
<p class="p1"><span class="s1">The <kbd>getExternalStorageState()</kbd>&#160;method should be called in order to check whether media are available. You can use the following code snippet to check whether external storage is available to be written to in your application:</span></p>
<pre class="p1"><span class="s1">private fun isExternalStorageWritable(): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val state = Environment.getExternalStorageState()<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>return Environment.MEDIA_MOUNTED == state<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Firstly, we retrieve the current state of external storage and then we check whether it is in the <kbd>MEDIA_MOUNTED</kbd> state. If it is in this state, your application can write to it. Hence, true is returned by <kbd>isExternalStorageWritable()</kbd>.</span></p>
<p class="p1"><span class="s1">Checking whether external storage is readable is similarly easy<span>:</span></span></p>
<pre class="p1"><span class="s1">private fun isExternalStorageReadable(): Boolean {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val state = Environment.getExternalStorageState()<br/></span><span class="s1"><span class="Apple-converted-space"><br/>  </span>return Environment.MEDIA_MOUNTED == state ||<br/></span>         <span>Environment.MEDIA_MOUNTED_READ_ONLY == state<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Your application can read data from external storage if it is in either the <kbd>MEDIA_MOUNTED</kbd> or the&#160;<kbd>MEDIA_MOUNTED_READ_ONLY</kbd> state.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Storing sharable files</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Files that a user or other applications may need to access later on should be stored in a shared public directory. Examples of such directories are the <kbd>Pictures/</kbd> and <kbd>Music/</kbd> directories.</span></p>
<p class="p1"><span class="s1">The <kbd>getExternalStoragePulicDirectory()</kbd>&#160;method should be called by your application in order to retrieve a <kbd>File</kbd> representing a required public directory. The type of directory to be retrieved should be passed as the sole argument to the function.</span></p>
<p class="p1"><span class="s1">The following is a function that creates a directory for music to be stored<span>:</span></span></p>
<pre class="p1"><span class="s1">private fun getMusicStorageDir(collectionName: String): File {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val file = File(Environment.getExternalStoragePublicDirectory(<br/></span><span class="s1"><span class="Apple-converted-space">        </span>Environment.DIRECTORY_MUSIC), collectionName)<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>if (!file.mkdir()) {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>Log.d("DIR_CREATION_STATUS", "Directory creation failed.")<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>return file<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">In the case where an error occurs when creating the public directory, an appropriate message is logged to the console.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Caching files with external storage</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Scenarios may arise in which you need to cache files with external storage. You can open a file representing the external storage directory in which your application should save cached files with <kbd>externalCacheDir</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Network storage</h1>
                </header>
            
            <article>
                
<p>This is the storage of data on a remote server. Unlike other means of storage we have talked about, this kind of storage utilizes a network connection to store and retrieve data that exists on a remote server. You utilized this storage medium when you created the messenger Android application in the previous chapter. The messenger application relied heavily on a remote server for the storage and retrieval of information. The client-server architecture is primarily in play when a remote server acts as a data source for a client application. The client sends a request for the data required (typically a GET request) to the server via HTTP, and the server responds by sending the required data as a response, thus completing the HTTP transaction cycle.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with a SQLite database</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">SQLite is a popular <strong>relational database management system</strong> (<strong>RDBMS</strong>) that, unlike many RDBMS systems, is not a client-server database engine. Instead, a SQLite database is embedded directly into an application.</span></p>
<p class="p1"><span class="s1">Android provides full support for SQLite. SQLite databases are accessible throughout an Android project by classes. Note that in Android, a database is only accessible to the application that created it.</span></p>
<p class="p1"><span class="s1">The use of the Room persistence library is the recommended method of working with SQLite in Android. The first step to work with <kbd>room</kbd> in Android<span class="Apple-converted-space">&#160;</span> is the inclusion of its necessary dependencies in a project's <kbd>build.gradle</kbd> script:</span></p>
<pre>implementation <span>"android.arch.persistence.room:runtime:1.0.0-alpha9-1"<br/></span>implementation <span>"android.arch.persistence.room:rxjava2:1.0.0-alpha9-1"<br/></span>implementation <span>"io.reactivex.rxjava2:rxandroid:2.0.1"<br/></span>kapt <span>"android.arch.persistence.room:compiler:1.0.0-alpha9-1"<br/></span></pre>
<p class="p1"><span class="s1">Entities can easily be created with the help of <kbd>Room</kbd>. All entities must be annotated with <kbd>@Entity</kbd>. The following is a simple <kbd>User</kbd> entity:</span></p>
<pre><span>package </span>com.example.roomexample.data<br/><br/><span>import </span>android.arch.persistence.room.<span>ColumnInfo<br/></span><span>import </span>android.arch.persistence.room.<span>Entity<br/></span><span>import </span>android.arch.persistence.room.<span>PrimaryKey<br/></span><span><br/></span><span>@Entity<br/></span><span>data class </span>User(<br/>  <span>@ColumnInfo</span>(<span>name = </span><span>"first_name"</span>)<br/>  <span>var </span><span>firstName</span>: <span>String</span> = <span>""</span><span>,<br/></span><span>  @ColumnInfo</span>(<span>name = </span><span>"surname"</span>)<br/>  <span>var </span><span>surname</span>: <span>String</span> = <span>""</span><span>,<br/></span><span>  @ColumnInfo</span>(<span>name = </span><span>"phone_number"</span>)<br/>  <span>var </span><span>phoneNumber</span>: <span>String</span> = <span>""</span><span>,<br/></span><span>  @PrimaryKey</span>(<span>autoGenerate = </span><span>true</span>)<br/>  <span>var </span><span>id</span>: Long = <span>0<br/></span>)</pre>
<p class="p1"><span class="s1"><kbd>Room</kbd> will create the necessary SQLite table for the <kbd>User</kbd> entity defined. The table will have a name,&#160;<kbd>user</kbd>, and will have four attributes: <kbd>id</kbd>, <kbd>first_name</kbd>, <kbd>surname</kbd>, and <kbd>phone_number</kbd>. The&#160;<kbd>id</kbd>&#160;attribute is the primary of the user table created. We specified that this should be the case by using the <kbd>@PrimaryKey</kbd> annotation. We specified that the primary keys of each record in the user table should be generated by <kbd>Room</kbd>, by setting <kbd>autoGenerate = true</kbd> in the <kbd>@PrimaryKey</kbd> annotation. <kbd>@ColumnInfo</kbd> is an annotation used to specify additional information pertaining to a column in a table. Take the following code snippet, for example:</span></p>
<pre><span>@ColumnInfo</span>(<span>name = </span><span>"first_name"</span>)<br/><span>var </span><span>firstName</span>: String = <span>""</span></pre>
<p class="p1"><span class="s1">The preceding code specifies that there is a <kbd>firstName</kbd> attribute possessed by a <kbd>User</kbd>. <kbd>@ColumnInfo(name ="first_name")</kbd> sets the name of the column in the user table for the <kbd>firstName</kbd> attribute to <kbd>first_name</kbd>.</span></p>
<p class="p1"><span class="s1">In order to read and write records to and from a database, you need a <strong>Data Access Object</strong> (<strong>DAO</strong>). A DAO allows the performance of database operations with the use of annotated methods. The following is a DAO for the <kbd>User</kbd> entity:</span></p>
<pre><span>package </span>com.example.roomexample.data<br/><br/><span>import </span>android.arch.persistence.room.<span>Dao<br/></span><span>import </span>android.arch.persistence.room.<span>Insert<br/></span><span>import </span>android.arch.persistence.room.<span>OnConflictStrategy<br/></span><span>import </span>android.arch.persistence.room.<span>Query<br/></span><span>import </span>io.reactivex.Flowable<br/><span><br/></span><span>@Dao<br/></span><span>interface </span>UserDao {<br/><br/>  <span>@Query</span>(<span>"SELECT * FROM user"</span>)<br/>  <span>fun </span><span>all</span>(): Flowable&lt;List&lt;User&gt;&gt;<br/><br/>  <span>@Query</span>(<span>"SELECT * FROM user WHERE id = :id"</span>)<br/>  <span>fun </span><span>findById</span>(id: Long): Flowable&lt;User&gt;<br/><br/>  <span>@Insert</span>(<span>onConflict = </span><span>OnConflictStrategy</span>.<span>REPLACE</span>)<br/>  <span>fun </span><span>insert</span>(user: User)<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>@Query</kbd> annotation marks a method in a DAO class as a query method. The query that will be run when the method is invoked is passed as a value to the annotation. Naturally, the queries passed to <kbd>@Query</kbd> are SQL queries. The writing of SQL queries is far too vast a topic to cover here, but it is a good idea to take some time to understand how to write them properly.</span></p>
<p class="p1"><span class="s1">The <kbd>@Insert</kbd> annotation is used to insert data into a table. Other important annotations that exist are <kbd>@Update</kbd> and <kbd>@Delete</kbd>. They are used to update and delete data within a database table.</span></p>
<p class="p1"><span class="s1">Lastly, after creating the necessary entities and DAOs, you must define your application's database. In order to do this, you must create a subclass of <kbd>RoomDatabase</kbd> and annotate it with <kbd>@Database</kbd>. At the minimum, the annotation should include a collection of entity class references and a database version number. The following is a sample <kbd>AppDatabase</kbd> abstract class:</span></p>
<pre class="p1"><span class="s1">@Database(entities = [User::class], version = 1)<br/></span><span class="s1">public abstract class AppDatabase : RoomDatabase() {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>abstract fun userDao(): UserDao<br/></span><span class="s1">}Now that we have our DAO and entity created, we must create an AppDatabase class. Add</span></pre>
<p class="p1"><span class="s1">Once your app database class is created, you can get an instance of the database by calling <kbd>databaseBuilder()</kbd>:</span></p>
<pre class="p1"><span class="s1">val db = Room.databaseBuilder(&lt;context&gt;, AppDatabase::class.java, <br/></span><span class="s1"><span class="Apple-converted-space">                              </span>"app-database").build()</span></pre>
<p class="p1"><span class="s1">Once you have an instance of your <kbd>RoomDatabase</kbd>, you can use it to retrieve data access objects that in turn can be used to&#160;read, write, update, query, and delete data from a database.</span></p>
<p class="p1"><span class="s1">Keeping with the practice we have adopted so far, let's create a simple application that shows how to utilize SQLite with the help of <kbd>Room</kbd> in Android. The application we are about to build will let an app user manually input information pertaining to people (users), and view all user information input at a later time.</span></p>
<p class="p1"><span class="s1">Create a new Android project with an empty <kbd>MainActivity</kbd> set as its launcher activity. Add the following dependencies to your application's <kbd>build.gradle</kbd> script:</span></p>
<pre class="p1"><span class="s1">implementation 'com.android.support:design:26.1.0'<br/></span>implementation <span>"android.arch.persistence.room:runtime:1.0.0"<br/></span>implementation <span>"android.arch.persistence.room:rxjava2:1.0.0"<br/></span>implementation <span>"io.reactivex.rxjava2:rxandroid:2.0.1"<br/></span>kapt <span>"android.arch.persistence.room:compiler:1.0.0"</span></pre>
<p>In addition, apply the <kbd>kotlin-kapt</kbd> standalone plugin to your <kbd>build.gradle</kbd> script:</p>
<pre>apply <span>plugin</span>: <span>'kotlin-kapt'</span></pre>
<p class="p1"><span class="s1">Having added the preceding project dependencies, create a <kbd>data</kbd> and a <kbd>ui</kbd> package within the project source package. In the <kbd>ui</kbd> package, add the <kbd>MainView</kbd>, which is as follows:</span></p>
<pre><span>package </span>com.example.roomexample.ui<br/><span><br/></span><span>interface </span>MainView {<br/><br/>  <span>fun </span><span>bindViews</span>()<br/>  <span>fun </span><span>setupInstances</span>()<br/>}</pre>
<p class="p1"><span class="s1">After adding <kbd>MainView</kbd> to the <kbd>ui</kbd> package, relocate <kbd>MainActivity</kbd> to the <kbd>ui</kbd> package as well. Now let's work on the database of our application. As the application is going to be storing user information, we need to create a <kbd>User</kbd> entity. Add the following&#160;<kbd>User</kbd> entity to the <kbd>data</kbd> package:</span></p>
<pre><span>package </span>com.example.roomexample.data<br/><br/><span>import </span>android.arch.persistence.room.<span>ColumnInfo<br/></span><span>import </span>android.arch.persistence.room.<span>Entity</span><br/><span>import </span>android.arch.persistence.room.<span>PrimaryKey<br/></span><span><br/></span><span>@Entity<br/></span><span>data class </span>User(<br/>  <span>@ColumnInfo</span>(<span>name = </span><span>"first_name"</span>)<br/>  <span>var </span><span>firstName</span>: String = <span>""</span><span>,<br/></span><span>  @ColumnInfo</span>(<span>name = </span><span>"surname"</span>)<br/>  <span>var </span><span>surname</span>: String = <span>""</span><span>,<br/></span><span>  @ColumnInfo</span>(<span>name = </span><span>"phone_number"</span>)<br/>  <span>var </span><span>phoneNumber</span>: String = <span>""</span><span>,<br/></span><span>  @PrimaryKey</span>(<span>autoGenerate = </span><span>true</span>)<br/>  <span>var </span><span>id</span>: Long = <span>0<br/></span>)</pre>
<p class="p1"><span class="s1">Now create a <kbd>UserDao</kbd>&#160;within the <kbd>data</kbd> package:</span></p>
<pre><span>package </span>com.example.roomexample.data<br/><br/><span>import </span>android.arch.persistence.room.<span>Dao<br/></span><span>import </span>android.arch.persistence.room.<span>Insert<br/></span><span>import </span>android.arch.persistence.room.<span>OnConflictStrategy<br/></span><span>import </span>android.arch.persistence.room.<span>Query<br/></span><span>import </span>io.reactivex.Flowable<br/><span><br/></span><span>@Dao<br/></span><span>interface </span>UserDao {<br/><br/>  <span>@Query</span>(<span>"SELECT * FROM user"</span>)<br/>  <span>fun </span><span>all</span>(): Flowable&lt;List&lt;User&gt;&gt;<br/><br/>  <span>@Query</span>(<span>"SELECT * FROM user WHERE id = :id"</span>)<br/>  <span>fun </span><span>findById</span>(id: Long): Flowable&lt;User&gt;<br/><br/>  <span>@Insert</span>(<span>onConflict = </span><span>OnConflictStrategy</span>.<span>REPLACE</span>)<br/>  <span>fun </span><span>insert</span>(user: User)<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>UserDao</kbd>&#160;interface has three methods: <kbd>all()</kbd>, <kbd>findById()</kbd>, and <kbd>Insert()</kbd>. The <kbd>all()</kbd> method returns a <kbd>Flowable</kbd> containing a list of all users. The <kbd>findById()</kbd> method finds a <kbd>User</kbd> who has an id matching that which is passed to the method, if any, and returns the <kbd>User</kbd> in a <kbd>Flowable</kbd>. The&#160;<kbd>insert()</kbd>&#160;method is used to insert a user as a record into the <kbd>user</kbd> table.</span></p>
<p class="p1"><span class="s1">Now that we have our DAO and entity created, we must create an <kbd>AppDatabase</kbd> class. Add the following to the <kbd>data</kbd> package:</span></p>
<pre><span>package </span>com.example.roomexample.data<br/><br/><span>import </span>android.arch.persistence.room.<span>Database<br/></span><span>import </span>android.arch.persistence.room.Room<br/><span>import </span>android.arch.persistence.room.RoomDatabase<br/><span>import </span>android.content.Context<br/><span><br/></span><span>@Database</span>(<span>entities = </span><span>arrayOf</span>(User::<span>class</span>)<span>, </span><span>version = </span><span>1</span><span>, </span><span>exportSchema = </span><span>false</span>)<br/><span>internal abstract class </span>AppDatabase : RoomDatabase() {<br/><br/>  <span>abstract fun </span><span>userDao</span>(): UserDao<br/><br/>  <span>companion object </span>Factory {<br/>    <span>private var </span><span>appDatabase</span>: AppDatabase? = <span>null<br/></span><span><br/></span><span>    fun </span><span>create</span>(ctx: Context): AppDatabase {<br/>      <span>if </span>(<span>appDatabase </span>== <span>null</span>) {<br/>        <span>appDatabase </span>= Room.databaseBuilder(ctx.<span>applicationContext</span><span>,<br/>                                           </span>AppDatabase::<span>class</span>.<span>java</span><span>,<br/></span><span>                                           </span><span>"app-database"</span>).build()<br/><br/>      }<br/><br/>      <span>return </span><span>appDatabase </span><span>as </span>AppDatabase<br/>    }<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">We created a <kbd>Factory</kbd> companion object possessing a single <kbd>create()</kbd> function that has the sole job of creating an <kbd>AppDatabase</kbd> instance—if not previously created—and returning that instance for use.</span></p>
<p class="p1"><span class="s1">Creating an&#160;<kbd>AppDatabase</kbd> is the last thing we need to do pertaining to data. Now we must create suitable layouts for our application views. We will make use of two fragments in our <kbd>MainActivity</kbd>. The first will be used to collect input for a new user to be created and the second will display the information of all created users in a <kbd>RecyclerView</kbd>. Firstly, modify the&#160;<kbd>activity_main.xml</kbd> layout to contain the following:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;android.</span><span>support</span><span>.constraint.ConstraintLayout<br/> </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span> </span><span>tools</span><span>:context=</span><span>"com.example.roomexample.ui.MainActivity"</span><span>&gt;<br/></span><span><br/></span><span>  &lt;LinearLayout<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/ll_container"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:orientation=</span><span>"vertical"</span><span>/&gt;<br/></span><span>&lt;/android.</span><span>support</span><span>.constraint.ConstraintLayout&gt;</span></pre>
<p class="p1"><span class="s1">The <kbd>LinearLayout</kbd> in <kbd>activity_main.xml</kbd> will contain the fragments of <kbd>MainActivity</kbd>. Add a <kbd>fragment_create_user.xml</kbd> file to the&#160;<kbd>resource</kbd>&#160;layout directory with the following content:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:gravity=</span><span>"center_horizontal"<br/></span><span> </span><span>android</span><span>:padding=</span><span>"@dimen/padding_default"</span><span>&gt;<br/></span><span>  &lt;TextView<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:textSize=</span><span>"32sp"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/create_user"</span><span>/&gt;<br/></span><span>  &lt;EditText<br/></span><span>        </span><span>android</span><span>:</span><span>id</span><span>=</span><span>"@+id/et_first_name"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/first_name"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"text"</span><span>/&gt;<br/></span><span>  &lt;EditText<br/></span><span>        </span><span>android</span><span>:</span><span>id</span><span>=</span><span>"@+id/et_surname"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/surname"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"text"</span><span>/&gt;<br/></span><span>  &lt;EditText<br/></span><span>        </span><span>android</span><span>:</span><span>id</span><span>=</span><span>"@+id/et_phone_number"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/phone_number"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"phone"</span><span>/&gt;<br/></span><span>  &lt;Button<br/></span><span>        </span><span>android</span><span>:</span><span>id</span><span>=</span><span>"@+id/btn_submit"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/submit"</span><span>/&gt;<br/></span><span>  &lt;Button<br/></span><span>        </span><span>android</span><span>:</span><span>id</span><span>=</span><span>"@+id/btn_view_users"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/view_users"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<p class="p1"><span class="s1">Now add a <kbd>fragment_list_users.xml</kbd> layout resource with the following content:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>android</span><span>:orientation=</span><span>"vertical"<br/> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"match_parent"</span><span>&gt;<br/></span><span>  &lt;android.support.v7.widget.RecyclerView<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/rv_users"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"match_parent"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<p class="p1"><span class="s1">The <kbd>fragment_list_users.xml</kbd>&#160;file has a <kbd>RecyclerView</kbd> that will display the information of each user saved to the database. We must create a view holder layout resource item for this <kbd>RecyclerView</kbd>. We'll call this layout file <kbd>vh_user.xml</kbd>. Create a new <kbd>vh_user.xml</kbd> resource file and add the following content to it:<br/></span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:padding=</span><span>"@dimen/padding_default"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"wrap_content"</span><span>&gt;<br/></span><span>  &lt;TextView<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/tv_first_name"<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"</span><span>/&gt;<br/></span><span>  &lt;TextView<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/tv_surname"<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"</span><span>/&gt;<br/></span><span>  &lt;TextView<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/tv_phone_number"<br/></span><span>       </span><span>android</span><span>:</span><span>layout_width</span><span>=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"</span><span>/&gt;<br/></span><span>  &lt;View<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"1dp"<br/></span><span>       </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/margin_default"<br/></span><span>       </span><span>android</span><span>:background=</span><span>"#e8e8e8"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<p class="p1"><span class="s1">As you might have expected, we must add some string and dimension resources to our project. Open your application's <kbd>strings.xml</kbd> layout file and add the following string resources to it:</span></p>
<pre><span>&lt;resources&gt;<br/></span><span>...<br/></span><span>  &lt;string </span><span>name=</span><span>"first_name"</span><span>&gt;</span>First name<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"surname"</span><span>&gt;</span>Surname<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"phone_number"</span><span>&gt;</span>Phone number<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"submit"</span><span>&gt;</span>Submit<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"create_user"</span><span>&gt;</span>Create User<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"view_users"</span><span>&gt;</span>View users<span>&lt;/string&gt;<br/></span><span>&lt;/resources&gt;<br/></span></pre>
<p class="p1"><span class="s1">Now create the following dimension resources in your project:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;resources&gt;<br/></span><span>  &lt;dimen </span><span>name=</span><span>"padding_default"</span><span>&gt;</span>16dp<span>&lt;/dimen&gt;<br/></span><span>  &lt;dimen </span><span>name=</span><span>"margin_default"</span><span>&gt;</span>16dp<span>&lt;/dimen&gt;<br/></span><span>&lt;/resources&gt;</span></pre>
<p class="p1"><span class="s1">It is now time to work on <kbd>MainActivity</kbd>. As we previously established, we will be using two distinct fragments in our <kbd>MainActivity</kbd> class. The first fragment enables a person to save the data of an individual to a SQL database, and the next will allow a user to view the information of people that has been saved in the database.</span></p>
<p class="p1"><span class="s1">We will create a <kbd>CreateUserFragment</kbd> first. Add the following fragment class to <kbd>MainActivity</kbd>&#160;(located in the <kbd>MainActivity.kt</kbd>) .<br/></span></p>
<pre><span>class </span>CreateUserFragment : Fragment()<span>, </span>MainView<span>, </span>View.OnClickListener {<br/><br/>  <span>private lateinit var </span><span>btnSubmit</span>: Button<br/>  <span>private lateinit var </span><span>etSurname</span>: EditText<br/>  <span>private lateinit var </span><span>btnViewUsers</span>: Button<br/>  <span>private lateinit var </span><span>layout</span>: LinearLayout<br/>  <span>private lateinit var </span><span>etFirstName</span>: EditText<br/>  <span>private lateinit var </span><span>etPhoneNumber</span>: EditText<br/><br/>  <span>private lateinit var </span><span>userDao</span>: UserDao<br/>  <span>private lateinit var </span><span>appDatabase</span>: AppDatabase<br/><br/>  <span>override fun </span><span>onCreateView</span>(inflater: LayoutInflater<span>,<br/>               </span>container: ViewGroup?<span>, </span>savedInstanceState: Bundle?): View {<br/>    <span>layout </span>= inflater.inflate(R.layout.<span>fragment_create_user</span><span>,<br/></span><span>                       </span>container<span>, false</span>) <span>as </span>LinearLayout<br/>    bindViews()<br/>    setupInstances()<br/>    <span>return </span><span>layout<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>bindViews</span>() {<br/>    <span>btnSubmit </span>= <span>layout</span>.findViewById(R.id.<span>btn_submit</span>)<br/>    <span>btnViewUsers </span>= <span>layout</span>.findViewById(R.id.<span>btn_view_users</span>)<br/>    <span>etSurname </span>= <span>layout</span>.findViewById(R.id.<span>et_surname</span>)<br/>    <span>etFirstName </span>= <span>layout</span>.findViewById(R.id.<span>et_first_name</span>)<br/>    <span>etPhoneNumber </span>= <span>layout</span>.findViewById(R.id.<span>et_phone_number</span>)<br/><br/>    <span>btnSubmit</span>.setOnClickListener(<span>this</span>)<br/>    <span>btnViewUsers</span>.setOnClickListener(<span>this</span>)<br/>  }<br/><br/>  <span>override fun </span><span>setupInstances</span>() {<br/>    <span>appDatabase </span>= AppDatabase.create(<span>activity</span>) <br/><span>      // getting an instance of AppDatabase<br/></span><span>    </span><span>userDao </span>= <span>appDatabase</span>.userDao() <span>// getting an instance of UserDao<br/></span><span>  </span>}<br/><br/>  </pre>
<p><span>The following&#160;method validates the inputs submitted in the create&#160;</span><span>a user form:</span></p>
<pre><span>private fun </span><span>inputsValid</span>(): Boolean {<br/>  <span>var </span>inputValid = <span>true<br/></span><span>  val </span>firstName = <span>etFirstName</span>.<span>text<br/></span><span>  </span><span>val </span>surname = <span>etSurname</span>.<span>text<br/></span><span>  </span><span>val </span>phoneNumber = <span>etPhoneNumber</span>.<span>text<br/></span><span><br/></span><span>  </span><span>if </span>(TextUtils.isEmpty(firstName)) {<br/>    <span>etFirstName</span>.<span>error </span>= <span>"First name cannot be empty"<br/></span><span>    </span><span>etFirstName</span>.requestFocus()<br/>    inputValid = <span>false<br/></span><span><br/></span><span>  </span>} <span>else if </span>(TextUtils.isEmpty(surname)) {<br/>    <span>etSurname</span>.<span>error </span>= <span>"Surname cannot be empty"<br/></span><span>    </span><span>etSurname</span>.requestFocus()<br/>    inputValid = <span>false<br/></span><span><br/></span><span>  </span>} <span>else if </span>(TextUtils.isEmpty(phoneNumber)) {<br/>    <span>etPhoneNumber</span>.<span>error </span>= <span>"Phone number cannot be empty"<br/></span><span>    </span><span>etPhoneNumber</span>.requestFocus()<br/>    inputValid = <span>false<br/></span><span><br/></span><span>  </span>} <span>else if </span>(!android.util.Patterns.<span>PHONE<br/></span>                     .matcher(phoneNumber).matches()) {<br/>    <span>etPhoneNumber</span>.<span>error </span>= <span>"Valid phone number required"<br/></span><span>    </span><span>etPhoneNumber</span>.requestFocus()<br/>    inputValid = <span>false<br/></span><span>  </span>}<br/><br/>  <span>return </span>inputValid<br/>}</pre>
<p>The following function shows toast message indicating the u<span>ser successfully created:</span></p>
<pre><span>  private fun </span><span>showCreationSuccess</span>() {<br/>    Toast.makeText(<span>activity</span><span>, </span><span>"User successfully created."</span><span>,<br/>                   </span>Toast.<span>LENGTH_LONG</span>).show()<br/>  }<br/><br/>  <span>override fun </span><span>onClick</span>(view: View?) {<br/>    <span>val </span>id = view?.<span>id<br/></span><span><br/></span><span>    </span><span>if </span>(id == R.id.<span>btn_submit</span>) {<br/>      <span>if </span>(inputsValid()) {<br/>        <span>val </span>user = User(<br/>          <span>etFirstName</span>.<span>text</span>.toString()<span>,<br/></span><span>          e</span><span>tSurname</span>.<span>text</span>.toString()<span>,<br/></span><span>          </span><span>etPhoneNumber</span>.<span>text</span>.toString())<br/><br/>        Observable.just(<span>userDao</span>)<br/>                  .subscribeOn(Schedulers.io())<br/>                  .subscribe( <span>{ </span>dao <span>-&gt;<br/></span><span>          </span>dao.insert(user)  <span>// using UserDao to save user to database.<br/></span><span>          </span><span>activity?</span>.runOnUiThread <span>{ </span>showCreationSuccess() <span>}<br/></span><span>        }</span><span>, </span>Throwable::printStackTrace)<br/>      }<br/>    } <span>else if </span>(id == R.id.<span>btn_view_users</span>) {<br/>      <span>val </span>mainActivity = <span>activity </span><span>as </span>MainActivity<br/><br/>      mainActivity.navigateToList()<br/>      mainActivity.showHomeButton()<br/>    }<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">We have worked with fragments numerous times already. As such, our focus of explanation will be on the parts of this fragment that work with the&#160;<kbd>AppDatabase</kbd>. In <kbd>setupInstances()</kbd>, we set up references to the&#160;<kbd>AppDatabase</kbd> and <kbd>UserDao</kbd>. We retrieved an instance of the&#160;<kbd>AppDatabase</kbd> by invoking the <kbd>create()</kbd> function of the <kbd>Factory</kbd> companion object of the&#160;<kbd>AppDatabase</kbd>. An instance of <kbd>UserDao</kbd> was easily retrieved by calling the&#160;<kbd>appDatabase.userDao()</kbd>.</span></p>
<p class="p1"><span class="s1">Let's move on to the <kbd>onClick()</kbd> method of the fragment class. When the submit button is clicked, the submitted user information will be checked for validity. An appropriate error message is shown if any of the input is invalid. Once it is asserted that all input are valid, a new <kbd>User</kbd> object containing the submitted user information is created and saved to the database. This is done in the following lines:</span></p>
<pre><span>if </span>(inputsValid()) {<br/>  <span>val </span>user = User(<br/>    <span>etFirstName</span>.<span>text</span>.toString()<span>,<br/></span><span>    </span><span>etSurname</span>.<span>text</span>.toString()<span>,<br/></span><span>    </span><span>etPhoneNumber</span>.<span>text</span>.toString())<br/><br/>  Observable.just(<span>userDao</span>)<br/>            .subscribeOn(Schedulers.io())<br/>            .subscribe( <span>{ </span>dao <span>-&gt;<br/></span><span>    </span>dao.insert(user)  <span>// using UserDao to save user to database.<br/></span><span>    </span><span>activity?</span>.runOnUiThread <span>{ </span>showCreationSuccess() <span>}<br/></span><span>  }</span><span>, </span>Throwable::printStackTrace)<br/>}</pre>
<p class="p1"><span class="s1">Creating the <kbd>ListUsersFragment</kbd> is similarly easy to achieve. &#160;Add the following <kbd>ListUsersFragment</kbd> to <kbd>MainActivity</kbd>:</span></p>
<pre><span>class </span>ListUsersFragment : Fragment()<span>, </span>MainView {<br/><br/>  <span>private lateinit var </span><span>layout</span>: LinearLayout<br/>  <span>private lateinit var </span><span>rvUsers</span>: RecyclerView<br/><br/>  <span>private lateinit var </span><span>appDatabase</span>: AppDatabase<br/><br/>  <span>override fun </span><span>onCreateView</span>(inflater: LayoutInflater<span>,<br/>               </span>container: ViewGroup?<span>, </span>savedInstanceState: Bundle?): View {<br/><br/>    <span>layout </span>= inflater.inflate(R.layout.<span>fragment_list_users</span><span>,<br/></span><span>                              </span>container<span>, false</span>) <span>as </span>LinearLayout<br/>    bindViews()<br/>    setupInstances()<br/><br/>    <span>return </span><span>layout<br/></span>  }</pre>
<p>Bind the user recycler view instance to its layout element:</p>
<pre><span> override fun </span><span>bindViews</span>() {<br/>    <span>rvUsers </span>= <span>layout</span>.findViewById(R.id.<span>rv_users</span>)<br/>  }<br/><br/><span>  override fun </span><span>setupInstances</span>() {<br/>    <span>appDatabase </span>= AppDatabase.create(<span>activity</span>)<br/>    <span>rvUsers</span>.<span>layoutManager </span>= LinearLayoutManager(<span>activity</span>)<br/>    <span>rvUsers</span>.<span>adapter </span>= UsersAdapter(<span>appDatabase</span>)<br/>  }<br/><br/><span>  private class </span>UsersAdapter(appDatabase: AppDatabase) : <br/>               RecyclerView.Adapter&lt;UsersAdapter.ViewHolder&gt;() {<br/><br/>    <span>private val </span><span>users</span>: ArrayList&lt;User&gt; = ArrayList()<br/>    <span>private val </span><span>userDao</span>: UserDao = appDatabase.userDao()<br/><br/>    <span>init </span>{<br/>      populateUsers()<br/>    }<br/><br/>    <span>override fun </span><span>onCreateViewHolder</span>(parent: ViewGroup?<span>, </span>viewType: Int):<br/>                 ViewHolder {<br/>      <span>val </span>layout = LayoutInflater.from(parent?.<span>context</span>)<br/>                                 .inflate(R.layout.<span>vh_user</span><span>, </span>parent<span>, false</span>)<br/><br/>      <span>return </span>ViewHolder(layout)<br/>    }<br/><br/>    <span>override fun </span><span>onBindViewHolder</span>(holder: ViewHolder?<span>, </span>position: Int) {<br/>      <span>val </span>layout = holder?.<span>itemView<br/></span><span>      </span><span>val </span>user = <span>users</span>[position]<br/><br/>      <span>val </span>tvFirstName = layout?.findViewById&lt;TextView&gt;(R.id.<span>tv_first_name</span>)<br/>      <span>val </span>tvSurname = layout?.findViewById&lt;TextView&gt;(R.id.<span>tv_surname</span>)<br/>      <span>val </span>tvPhoneNumber = layout?.findViewById&lt;TextView&gt;<br/>                          (R.id.<span>tv_phone_number</span>)<br/><br/>      tvFirstName?.<span>text </span>= <span>"First name: </span><span>${</span>user.<span>firstName</span><span>}</span><span>"<br/></span><span>      </span>tvSurname?.<span>text </span>= <span>"Surname: </span><span>${</span>user.<span>surname</span><span>}</span><span>"<br/></span><span>      </span>tvPhoneNumber?.<span>text </span>= <span>"Phone number: </span><span>${</span>user.<span>phoneNumber</span><span>}</span><span>"<br/></span><span>    </span>}<br/><br/>   //<span>Populates users ArrayList with User objects</span><span> <br/></span><span>    </span><span>private fun </span><span>populateUsers</span>() {<br/>      <span>users</span>.clear()</pre>
<p><span>Let's get all users in the user table of the database.</span> <span>And upon successful retrieval of the list, add all u</span><span>ser objects in the list to users <kbd>ArrayList</kbd>:</span></p>
<pre><span>      </span><span>userDao</span>.all()<br/>             .subscribeOn(Schedulers.io())<br/>             .observeOn(AndroidSchedulers.mainThread())<br/>             .subscribe(<span>{ </span>res <span>-&gt;<br/></span><span>        </span><span>users</span>.addAll(res)<br/>        notifyDataSetChanged()<br/>      <span>}</span><span>, </span>Throwable::printStackTrace)<br/>    }<br/><br/>    <span>override fun </span><span>getItemCount</span>(): Int {<br/>      <span>return </span><span>users</span>.<span>size<br/></span><span>    </span>}<br/><br/>    <span>class </span>ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)<br/>  }<br/>}</pre>
<p class="p1"><span class="s1"><kbd>UsersAdapter</kbd> in the&#160;<kbd>ListUsersFragment</kbd> uses an instance of <kbd>UserDao</kbd> to populate its user list. This population is done within <kbd>populateUsers()</kbd>. When <kbd>populateUsers()</kbd> is invoked, a list of all users that have been saved by the application is retrieved by invoking <kbd>userDao.all()</kbd>. Upon successful retrieval of all users, all <kbd>User</kbd> objects are added to the users <kbd>ArrayList</kbd> of <kbd>UserAdapter</kbd>. The adapter is then notified of the change in data in its dataset by the call to <kbd>notifyDataSetChanged()</kbd>.</span></p>
<p class="p1"><span class="s1"><kbd>MainActivity</kbd> itself requires some minor additions. Your completed <kbd>MainActivity</kbd> should look like this:</span></p>
<pre><span>package </span>com.example.roomexample.ui<br/><br/><span>import </span>android.app.Fragment<br/><span>import </span>android.support.v7.app.AppCompatActivity<br/><span>import </span>android.os.Bundle<br/><span>import </span>android.support.v7.widget.LinearLayoutManager<br/><span>import </span>android.support.v7.widget.RecyclerView<br/><span>import </span>android.text.TextUtils<br/><span>import </span>android.view.LayoutInflater<br/><span>import </span>android.view.MenuItem<br/><span>import </span>android.view.View<br/><span>import </span>android.view.ViewGroup<br/><span>import </span>android.widget.*<br/><span>import </span>com.example.roomexample.R<br/><span>import </span>com.example.roomexample.data.AppDatabase<br/><span>import </span>com.example.roomexample.data.User<br/><span>import </span>com.example.roomexample.data.UserDao<br/><span>import </span>io.reactivex.Observable<br/><span>import </span>io.reactivex.android.schedulers.AndroidSchedulers<br/><span>import </span>io.reactivex.schedulers.Schedulers<br/><br/><span>class </span>MainActivity : AppCompatActivity() {<br/><br/>  <span>override fun </span><span>onCreate</span>(savedInstanceState: Bundle?) {<br/>    <span>super</span>.onCreate(savedInstanceState)<br/>    setContentView(R.layout.<span>activity_main</span>)<br/>    navigateToForm()<br/>  }<br/><br/>  <span>private fun </span><span>showHomeButton</span>() {<br/>    <span>supportActionBar</span>?.setDisplayHomeAsUpEnabled(<span>true</span>)<br/>  }<br/><br/>  <span>private fun </span><span>hideHomeButton</span>() {<br/>    <span>supportActionBar</span>?.setDisplayHomeAsUpEnabled(<span>false</span>)<br/>  }<br/><br/>  <span>private fun </span><span>navigateToForm</span>() {<br/>    <span>val </span>transaction = <span>fragmentManager</span>.beginTransaction()<br/>    transaction.add(R.id.<span>ll_container</span><span>, </span>CreateUserFragment())<br/>    transaction.commit()<br/>  }</pre>
<p>The following function is called when the user click the back button, if the fragments back stack has one or more <span>fragments</span>, the fragments manager pops the <span>fragment</span>&#160;and displays it to the user:</p>
<pre>  <span>override fun </span><span>onBackPressed</span>() {<br/>    <span>if </span>(<span>fragmentManager</span>.<span>backStackEntryCount </span>&gt; <span>0</span>) {<br/>      <span>fragmentManager</span>.popBackStack()<br/>      hideHomeButton()<br/>    } <span>else </span>{<br/>      <span>super</span>.onBackPressed()<br/>    }<br/>  }<br/><br/>  <span>private fun </span><span>navigateToList</span>() {<br/>    <span>val </span>transaction = <span>fragmentManager</span>.beginTransaction()<br/>    transaction.replace(R.id.<span>ll_container</span><span>, </span>ListUsersFragment())<br/>    transaction.addToBackStack(<span>null</span>)<br/>    transaction.commit()<br/>  }<br/><br/>  <span>override fun </span><span>onOptionsItemSelected</span>(item: MenuItem?): Boolean {<br/>    <span>val </span>id = item?.<span>itemId<br/></span><span><br/></span><span>    </span><span>if </span>(id == android.R.id.<span>home</span>) {<br/>      onBackPressed()<br/>      hideHomeButton()<br/>    }<br/><br/>    <span>return super</span>.onOptionsItemSelected(item)<br/>  }<br/><br/>  <span>class </span>CreateUserFragment : Fragment()<span>, </span>MainView<span>, </span>View.OnClickListener {<br/>    ...<br/>  }<br/><br/>  <span>class </span>ListUsersFragment : Fragment()<span>, </span>MainView {<br/>    ...<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">We must now run the application to see if it works as we would like. Build and run the project on a device of your choice. Once the project launches, you will come face to face with the user creation form. Go ahead and input some user information in the form:</span></p>
<div class="p1 CDPAlignCenter CDPAlign"><img src="images/80429a28-c8b2-46b5-8299-978decc32b91.jpg" style="width:18.58em;height:33.83em;"/></div>
<p class="p1"><span class="s1">Once you have input valid information into the create user form, click the <span class="packt_screen">Submit</span> button to save the user to the application's SQLite database. You will be notified once the user has been saved successfully. Having been notified, click <span class="packt_screen">VIEW USERS</span> to see the information of the user you just saved:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="images/c81ed510-be58-4646-b291-b153235ddf8f.jpg" style="width:21.67em;height:38.50em;"/></div>
<div>
<p class="p1"><span class="s1">You can create and view information for as many users as you like. There's no upper limit to the amount of information the database can contain!</span></p>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with content providers</h1>
                </header>
            
            <article>
                
<p><span>We spoke briefly about content providers as Android components in <a href="kt-prog-ex_ch02.html">Chapter 2</a>, <em>Building an Android Application - Tetris</em>. While doing so, we established the fact that&#160;</span><span>content providers help an application control access to data resources stored either within the application or within another app. In addition, we established that a content provider facilitates the sharing of data with another application via an exposed application programming interface.</span></p>
<p>A content provider behaves in a way that is similar to the behavior of a database. A content provider permits the insertion, deletion, editing,&#160;<span>updating, and querying of content. These abilities are permitted by the use of methods such as <kbd>insert()</kbd>, <kbd>update()</kbd>, <kbd>delete()</kbd>, and <kbd>query()</kbd>. In many cases, data controlled by a content provider exists in a SQLite database.</span></p>
<p>A content provider for your application can be created in five easy steps:</p>
<ol>
<li>Create a content provider class that extends <kbd>ContentProvider</kbd>.</li>
<li>Define a content URI address.</li>
<li>Create a datasource that the content provider will interact with.&#160; This datasource is usually in the form of a SQLite database. In cases where SQLite is the datasource, you will need to create a <kbd>SQLiteOpenHelper</kbd> and override its <kbd>onCreate()</kbd> in order to create the database that will be controlled by the content provider.</li>
<li>Implement the required content provider methods.</li>
<li>Register the content provider in your project's manifest file.</li>
</ol>
<p>In all, there are six&#160; methods that must be implemented by a&#160;<span>content provider. These are:</span></p>
<ul>
<li><kbd>onCreate()</kbd>: This method is called to initialize the database</li>
<li><kbd>query()</kbd>:<strong>&#160;</strong>This method returns data to the caller via a <kbd>Cursor</kbd></li>
<li><kbd>insert()</kbd>: This method is called to insert new data into the content provider</li>
<li><kbd>delete()</kbd>:&#160;This method is called to delete data from the content provider</li>
<li><kbd>update()</kbd>:<strong>&#160;</strong>This method is called to update data in the content provider</li>
<li><kbd>getType()</kbd>: This method returns the MIME type of data in the content provider when called</li>
</ul>
<p>In order to ensure you fully understand the workings of a content provider, let's create a quick example project that utilizes a content provider and a SQLite database. Create a new Android studio project named <kbd>ContentProvider</kbd>&#160;and add an empty <kbd>MainActivity</kbd> to it upon creation. Similar to all other applications created in this chapter, this example is simple in nature. The application allows a user to enter the details of a product (a product name and its manufacturer) in text fields and save them to a SQLite database. The user can then view the&#160;<span>information of&#160;</span>products that they previously saved with the click of a button.</p>
<p>Modify <kbd>activity_main.xml</kbd> to contain the following XML:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span> </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span> </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span> </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span> </span><span>android</span><span>:gravity=</span><span>"center_horizontal"<br/></span><span> </span><span>android</span><span>:padding=</span><span>"16dp"<br/></span><span> </span><span>tools</span><span>:context=</span><span>"com.example.contentproviderexample.MainActivity"</span><span>&gt;<br/></span><span>  &lt;TextView<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:gravity=</span><span>"center"<br/></span><span>       </span><span>android</span><span>:text=</span><span>"@string/content_provider_example"<br/></span><span>       </span><span>android</span><span>:textColor=</span><span>"@color/colorAccent"<br/></span><span>       </span><span>android</span><span>:textSize=</span><span>"32sp"</span><span>/&gt;<br/></span><span>  &lt;EditText<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/et_product_name"<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_marginTop=</span><span>"16dp"<br/></span><span>       </span><span>android</span><span>:hint=</span><span>"Product Name"</span><span>/&gt;<br/></span><span>  &lt;EditText<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/et_product_manufacturer"<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_marginTop=</span><span>"16dp"<br/></span><span>       </span><span>android</span><span>:hint=</span><span>"Product Manufacturer"</span><span>/&gt;<br/></span><span>  &lt;Button<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/btn_add_product"<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_marginTop=</span><span>"16dp"<br/></span><span>       </span><span>android</span><span>:text=</span><span>"Add product"</span><span>/&gt;<br/></span><span>  &lt;Button<br/></span><span>       </span><span>android</span><span>:id=</span><span>"@+id/btn_show_products"<br/></span><span>       </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>       </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>       </span><span>android</span><span>:layout_marginTop=</span><span>"16dp"<br/></span><span>       </span><span>android</span><span>:text=</span><span>"Show products"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;<br/></span></pre>
<p>After making the preceding modifications, add the following string resource to your project's <kbd>strings.xml</kbd> file:</p>
<pre><span>&lt;string </span><span>name=</span><span>"content_provider_example"</span><span>&gt;</span>Content Provider Example<span>&lt;/string&gt;<br/></span></pre>
<p>Now create a <kbd>ProductProvider.kt</kbd> file in the <kbd>com.example.contentproviderexample</kbd> package and add the following content:</p>
<pre><span>package </span>com.example.contentproviderexample<br/><br/><span>import </span>android.content.*<br/><span>import </span>android.database.Cursor<br/><span>import </span>android.database.SQLException<br/><span>import </span>android.database.sqlite.SQLiteDatabase<br/><span>import </span>android.database.sqlite.SQLiteOpenHelper<br/><span>import </span>android.database.sqlite.SQLiteQueryBuilder<br/><span>import </span>android.net.Uri<br/><span>import </span>android.text.TextUtils<br/><span><br/></span><span>internal class </span>ProductProvider : ContentProvider() {<br/><br/>  <span>companion object </span>{<br/><br/>    <span>val </span><span>PROVIDER_NAME</span>: String = <span>"com.example.contentproviderexample<br/>                                  .ProductProvider"<br/></span><span>    </span><span>val </span><span>URL</span>: String = <span>"content://</span><span>$</span><span>PROVIDER_NAME</span><span>/products"<br/></span><span>    </span><span>val </span><span>CONTENT_URI</span>: Uri = Uri.parse(<span>URL</span>)<br/><br/>    <span>val </span><span>PRODUCTS </span>= <span>1<br/></span><span>    </span><span>val </span><span>PRODUCT_ID </span>= <span>2<br/></span><span><br/></span><span>    </span><span>// Database and table property declarations<br/></span><span>    </span><span>val </span><span>DATABASE_VERSION </span>= <span>1<br/></span><span>    </span><span>val </span><span>DATABASE_NAME </span>= <span>"Depot"<br/></span><span>    </span><span>val </span><span>PRODUCTS_TABLE_NAME </span>= <span>"products"<br/></span><span><br/></span><span>    </span><span>// 'products' table column name declarations<br/></span><span>    </span><span>val </span><span>ID</span>: String = <span>"id"<br/></span><span>    </span><span>val </span><span>NAME</span>: String = <span>"name"<br/></span><span>    </span><span>val </span><span>MANUFACTURER</span>: String = <span>"manufacturer"<br/></span><span>    </span><span>val </span><span>uriMatcher</span>: UriMatcher = UriMatcher(UriMatcher.<span>NO_MATCH</span>)<br/>    <span>val </span><span>PRODUCTS_PROJECTION_MAP</span>: HashMap&lt;String<span>, </span>String&gt; = HashMap()<br/><br/>    </pre>
<p><span><kbd>SQLiteOpenHelper</kbd> class that creates the</span> <span>content provider's database:</span></p>
<pre><span><br/></span><span>    </span><span>private class </span>DatabaseHelper(context: Context) :<br/>      SQLiteOpenHelper(context<span>, </span><span>DATABASE_NAME</span><span>, null,<br/> </span><span>DATABASE_VERSION</span>) {<br/><br/>      <span>override fun </span><span>onCreate</span>(db: SQLiteDatabase) {<br/>        <span>val </span>query = <span>" CREATE TABLE " </span>+ <span>PRODUCTS_TABLE_NAME </span>+<br/>                    <span>" (id INTEGER PRIMARY KEY AUTOINCREMENT, " </span>+<br/>                    <span>" name VARCHAR(255) NOT NULL, " </span>+<br/>                    <span>" manufacturer VARCHAR(255) NOT NULL);"<br/></span><span><br/></span><span>        </span>db.execSQL(query)<br/>      }<br/><br/>      <span>override fun </span><span>onUpgrade</span>(db: SQLiteDatabase<span>, </span>oldVersion: Int<span>,<br/>                             </span>newVersion: Int) {<br/>        <span>val </span>query = <span>"DROP TABLE IF EXISTS </span><span>$</span><span>PRODUCTS_TABLE_NAME</span><span>"<br/></span><span><br/></span><span>        </span>db.execSQL(query)<br/>        onCreate(db)<br/>      }<br/>    }<br/>  }<br/><br/>  <span>private lateinit var </span><span>db</span>: SQLiteDatabase<br/><br/>  <span>override fun </span><span>onCreate</span>(): Boolean {<br/>    <span>uriMatcher</span>.addURI(<span>PROVIDER_NAME</span><span>, </span><span>"products"</span><span>, </span><span>PRODUCTS</span>)<br/>    <span>uriMatcher</span>.addURI(<span>PROVIDER_NAME</span><span>, </span><span>"products/#"</span><span>, </span><span>PRODUCT_ID</span>)<br/><br/>    <span>val </span>helper = DatabaseHelper(<span>context</span>)    </pre>
<p><span>Let's use the <kbd>SQLiteOpenHelper</kbd> to get a writable database; a</span> <span>new database is created if one does not already exist:</span></p>
<pre><span>    </span><span>db </span>= helper.<span>writableDatabase<br/></span><span><br/></span><span>    </span><span>return true<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>insert</span>(uri: Uri<span>, </span>values: ContentValues): Uri {<br/>   //<span>Insert a new product record into the products table<br/></span><span> <br/></span><span>    </span><span>val </span>rowId = <span>db</span>.insert(<span>PRODUCTS_TABLE_NAME</span><span>, </span><span>""</span><span>, </span>values)<br/><br/>    //<span>If rowId is greater than 0 then the product record </span><span>was added successfully.<br/></span><span>    <br/></span><span>    </span><span>if </span>(rowId &gt; <span>0</span>) {<br/>      <span>val </span>_uri = ContentUris.withAppendedId(<span>CONTENT_URI</span><span>, </span>rowId)<br/>      <span>context</span>.<span>contentResolver</span>.notifyChange(_uri<span>, null</span>)<br/><br/>      <span>return </span>_uri<br/>    }<br/><br/>    <span>// throws an exception if the product was not successfully added.<br/></span><span>    </span><span>throw </span>SQLException(<span>"Failed to add product into " </span>+ uri)<br/>  }<br/><br/>  <span>override fun </span><span>query</span>(uri: Uri<span>, </span>projection: Array&lt;String&gt;?<span>,<br/></span><span>                     </span>selection: String?<span>, </span>selectionArgs: Array&lt;String&gt;?<span>,<br/></span><span>                     </span>sortOrder: String): Cursor {<br/><br/>    <span>val </span>queryBuilder = SQLiteQueryBuilder()<br/>    queryBuilder.<span>tables </span>= <span>PRODUCTS_TABLE_NAME<br/></span><span><br/></span><span>    </span><span>when </span>(<span>uriMatcher</span>.match(uri)) {<br/>      <span>PRODUCTS </span>-&gt; queryBuilder.setProjectionMap(<span>PRODUCTS_PROJECTION_MAP</span>)<br/>      <span>PRODUCT_ID </span>-&gt; queryBuilder.appendWhere(<br/>        <span>"</span><span>$</span><span>ID</span><span> = </span><span>${</span>uri.<span>pathSegments</span>[<span>1</span>]<span>}</span><span>"<br/></span>      )<br/>    }<br/><br/>    <span>val </span>cursor: Cursor = queryBuilder.query(<span>db</span><span>, pr</span>ojection<span>, </span>selection<span>,<br/>                         </span>selectionArgs<span>, </span><span>null, null, </span>sortOrder)<br/><br/>    cursor.setNotificationUri(<span>context</span>.<span>contentResolver</span><span>, </span>uri)<br/>    <span>return </span>cursor<br/>  }<br/><br/>  <span>override fun </span><span>delete</span>(uri: Uri<span>, </span>selection: String<span>, <br/></span>                      selectionArgs: Array&lt;String&gt;): Int {<br/><br/>    <span>val </span>count = <span>when</span>(<span>uriMatcher</span>.match(uri)) {<br/><br/>      <span>PRODUCTS </span>-&gt; <span>db</span>.delete(<span>PRODUCTS_TABLE_NAME</span><span>, </span>selection<span>, </span>selectionArgs)<br/>      <span>PRODUCT_ID </span>-&gt; {<br/>        <span>val </span>id = uri.<span>pathSegments</span>[<span>1</span>]<br/>        <span>db</span>.delete(<span>PRODUCTS_TABLE_NAME</span><span>, </span><span>"</span><span>$</span><span>ID</span><span> = </span><span>$</span>id <span>" </span>+<br/>          <span>if </span>(!TextUtils.isEmpty(selection)) <span>"AND <br/>            (</span><span>$</span>selection<span>)" </span><span>else </span><span>""</span><span>, </span>selectionArgs)<br/>      }<br/>      <span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"Unknown URI: </span><span>$</span>uri<span>"</span>)<br/>    }<br/><br/>    <span>context</span>.<span>contentResolver</span>.notifyChange(uri<span>, null</span>)<br/>    <span>return </span>count<br/>  }<br/><br/>  <span>override fun </span><span>update</span>(uri: Uri<span>, </span>values: ContentValues<span>, </span>selection: String<span>,<br/></span><span>                      </span>selectionArgs: Array&lt;String&gt;): Int {<br/><br/>    <span>val </span>count = <span>when</span>(<span>uriMatcher</span>.match(uri)) {<br/>      <span>PRODUCTS </span>-&gt; <span>db</span>.update(<span>PRODUCTS_TABLE_NAME</span><span>, </span>values<span>,<br/>                            </span>selection<span>, </span>selectionArgs)<br/>      <span>PRODUCT_ID </span>-&gt; {<br/>        <span>db</span>.update(<span>PRODUCTS_TABLE_NAME</span><span>, </span>values<span>,<br/></span><span>                  </span><span>"</span><span>$</span><span>ID</span><span> = </span><span>${</span>uri.<span>pathSegments</span>[<span>1</span>]<span>} </span><span>" </span>+<br/>                  <span>if </span>(!TextUtils.isEmpty(selection)) <span>" AND<br/>                  (</span><span>$</span>selection<span>)" </span><span>else </span><span>""</span><span>, </span>selectionArgs)<br/>      }<br/>      <span>else </span>-&gt; <span>throw  </span>IllegalArgumentException(<span>"Unknown URI: </span><span>$</span>uri<span>"</span>)<br/>    }<br/><br/>    <span>context</span>.<span>contentResolver</span>.notifyChange(uri<span>, null</span>)<br/>    <span>return </span>count<br/>  }<br/><br/>  <span>override fun </span><span>getType</span>(uri: Uri): String {<br/>    <span>//</span><span>Returns the appropriate MIME type of records<br/></span><span><br/></span><span>    </span><span>return when </span>(<span>uriMatcher</span>.match(uri)){<br/>      <span>PRODUCTS </span>-&gt; <span>"vnd.android.cursor.dir/vnd.example.products"<br/></span><span>      </span><span>PRODUCT_ID </span>-&gt; <span>"vnd.android.cursor.item/vnd.example.products"<br/></span><span>      </span><span>else </span>-&gt; <span>throw </span>IllegalArgumentException(<span>"Unpermitted URI: " </span>+ uri)<br/>    }<br/>  }<br/>}</pre>
<p>Having added a suitable <kbd>ProductProvider</kbd> to provide content pertaining to saved products, we must register the new component in the <kbd>AndroidManifest</kbd> file. We have added the provider to the manifest file in the following code snippet:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;manifest </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>package=</span><span>"com.example.contentproviderexample"</span><span>&gt;<br/></span><span><br/></span><span>  &lt;application<br/></span><span>        </span><span>android</span><span>:allowBackup=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:icon=</span><span>"@mipmap/ic_launcher"<br/></span><span>        </span><span>android</span><span>:label=</span><span>"@string/app_name"<br/></span><span>        </span><span>android</span><span>:roundIcon=</span><span>"@mipmap/ic_launcher_round"<br/></span><span>        </span><span>android</span><span>:supportsRtl=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:theme=</span><span>"@style/AppTheme"</span><span>&gt;<br/></span><span>    &lt;activity </span><span>android</span><span>:name=</span><span>".MainActivity"</span><span>&gt;<br/></span><span>      &lt;intent-filter&gt;<br/></span><span>        &lt;action </span><span>android</span><span>:name=</span><span>"android.intent.action.MAIN" </span><span>/&gt;<br/></span><span><br/></span><span>        &lt;category </span><span>android</span><span>:name=</span><span>"android.intent.category.LAUNCHER" </span><span>/&gt;<br/></span><span>      &lt;/intent-filter&gt;<br/></span><span>    &lt;/activity&gt;<br/></span><span>    &lt;provider a</span><span>ndroid</span><span>:authorities=</span><span>"com.example.contentproviderexample<br/>                     .ProductProvider" an</span><span>droid</span><span>:name=</span><span>"ProductProvider"</span><span>/&gt;<br/></span><span>  &lt;/application&gt;<br/></span><span><br/></span><span>&lt;/manifest&gt;</span></pre>
<p>Now, let's modify <kbd>MainActivity</kbd> to exploit this newly registered provider. Modify <kbd>MainActivity.kt</kbd> to contain&#160;the following content:</p>
<pre><span>package </span>com.example.contentproviderexample<br/><br/><span>import </span>android.content.ContentValues<br/><span>import </span>android.net.Uri<br/><span>import </span>android.support.v7.app.AppCompatActivity<br/><span>import </span>android.os.Bundle<br/><span>import </span>android.text.TextUtils<br/><span>import </span>android.view.View<br/><span>import </span>android.widget.Button<br/><span>import </span>android.widget.EditText<br/><span>import </span>android.widget.Toast<br/><br/><span>class </span>MainActivity : AppCompatActivity()<span>, </span>View.OnClickListener {<br/><br/>  <span>private lateinit var </span><span>etProductName</span>: EditText<br/>  <span>private lateinit var </span><span>etProductManufacturer</span>: EditText<br/>  <span>private lateinit var </span><span>btnAddProduct</span>: Button<br/>  <span>private lateinit var </span><span>btnShowProduct</span>: Button<br/><br/>  <span>override fun </span><span>onCreate</span>(savedInstanceState: Bundle?) {<br/>    <span>super</span>.onCreate(savedInstanceState)<br/>    <span>setContentView</span>(R.layout.<span>activity_main</span>)<br/>    bindViews()<br/>    setupInstances()<br/>  }<br/><br/>  <span>private fun </span><span>bindViews</span>() {<br/>    <span>etProductName </span>= findViewById(R.id.<span>et_product_name</span>)<br/>    <span>etProductManufacturer </span>= findViewById(R.id.<span>et_product_manufacturer</span>)<br/>    <span>btnAddProduct </span>= findViewById(R.id.<span>btn_add_product</span>)<br/>    <span>btnShowProduct </span>= findViewById(R.id.<span>btn_show_products</span>)<br/>  }<br/><br/>  <span>private fun </span><span>setupInstances</span>() {<br/>    <span>btnAddProduct</span>.setOnClickListener(<span>this</span>)<br/>    <span>btnShowProduct</span>.setOnClickListener(<span>this</span>)<br/>    <span>supportActionBar</span>?.hide()<br/>  }<br/><br/>  <span>private fun </span><span>inputsValid</span>(): Boolean {<br/>    <span>var </span>inputsValid = <span>true<br/></span><span>    if </span>(TextUtils.isEmpty(<span>etProductName</span>.<span>text</span>)) {<br/>      <span>etProductName</span>.<span>error </span>= <span>"Field required."<br/></span><span>      </span><span>etProductName</span>.requestFocus()<br/>      inputsValid = <span>false<br/></span><span><br/></span><span>    </span>} <span>else if </span>(TextUtils.isEmpty(<span>etProductManufacturer</span>.<span>text</span>)) {<br/>      <span>etProductManufacturer</span>.<span>error </span>= <span>"Field required."<br/></span><span>      </span><span>etProductManufacturer</span>.requestFocus()<br/>      inputsValid = <span>false<br/></span><span>    </span>}<br/><br/>    <span>return </span>inputsValid<br/>  }<br/><br/>  <span>private fun </span><span>addProduct</span>() {<br/>    <span>val </span>contentValues = ContentValues()<br/><br/>    contentValues.put(ProductProvider.<span>NAME</span><span>, </span><span>etProductName</span>.<span>text</span>.toString())<br/>    contentValues.put(ProductProvider.<span>MANUFACTURER</span><span>, <br/></span><span>                      etProductManufacturer</span>.<span>text</span>.toString())<br/>    <span>contentResolver</span>.insert(ProductProvider.<span>CONTENT_URI</span><span>, </span>contentValues)<br/><br/>    showSaveSuccess()<br/>  }</pre>
<p>The following function is called to show products that exist in the database:</p>
<pre><br/>  <span>private fun </span><span>showProducts</span>() {<br/>    <span>val </span>uri = Uri.parse(ProductProvider.<span>URL</span>)<br/>    <span>val </span>cursor = managedQuery(uri<span>, null, null, null, </span><span>"name"</span>)<br/><br/>    <span>if </span>(cursor != <span>null</span>) {<br/>      <span>if </span>(cursor.moveToFirst()) {<br/>        <span>do </span>{<br/>          <span>val </span>res = <span>"ID: </span><span>${</span>cursor.getString(cursor.getColumnIndex<br/>                   (ProductProvider.<span>ID</span>))<span>}</span><span>" </span>+ <span>",<br/>          </span><span>\n</span><span>PRODUCT NAME: </span><span>${</span>cursor.getString(cursor.getColumnIndex<br/>                   ( ProductProvider.<span>NAME</span>))<span>}</span><span>" </span>+ <span>", <br/></span><span>          \n</span><span>PRODUCT MANUFACTURER: </span><span>${</span>cursor.getString(cursor.getColumnIndex<br/>                   (ProductProvider.<span>MANUFACTURER</span>))<span>}</span><span>"<br/></span><span><br/></span><span>          </span>Toast.makeText(<span>this, </span>res<span>, </span>Toast.<span>LENGTH_LONG</span>).show()<br/>        } <span>while </span>(cursor.moveToNext())<br/>      }<br/>    } <span>else </span>{<br/>      Toast.makeText(<span>this, </span><span>"Oops, something went wrong."</span><span>,<br/>                     </span>Toast.<span>LENGTH_LONG</span>).show()<br/>    }<br/>  }<br/><br/>  <span>private fun </span><span>showSaveSuccess</span>() {<br/>    Toast.makeText(<span>this, </span><span>"Product successfully saved."</span><span>,<br/>                   </span>Toast.<span>LENGTH_LONG</span>).show()<br/>  }<br/><br/>  <span>override fun </span><span>onClick</span>(view: View) {<br/>    <span>val </span>id = view.<span>id<br/></span><span><br/></span><span>    </span><span>if </span>(id == R.id.<span>btn_add_product</span>) {<br/>      <span>if </span>(inputsValid()) {<br/>        addProduct()<br/>      }<br/>    } <span>else if </span>(id == R.id.<span>btn_show_products</span>) {<br/>      showProducts()<br/>    }<br/>  }<br/>}</pre>
<p>The two methods you should focus your attention on in the preceding code block are <kbd>addProduct()</kbd> and <kbd>showProducts()</kbd>. <kbd>addProduct()</kbd> stores the product data in a <kbd>contentValues</kbd> instance and then inserts this data into the SQLite database with the help of the&#160;<kbd>ProductProvider</kbd> by invoking <kbd>contentResolver.insert(ProductProvider.CONTENT_URI, contentValues)</kbd>.&#160;<kbd>showProducts()</kbd> uses a <kbd>Cursor</kbd> to display the product information stored in the database in toast messages.</p>
<p>Now that we understand what's going on, let's run the application. Build and run the application as you have done thus far and wait until the application installs and starts. You will be taken straight to <kbd>MainActivity</kbd> and presented with a form to input the&#160;<span>name</span>&#160;and manufacturer of a product:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/385353fc-a1c3-49e3-943c-5fc3f1197780.jpg" style="width:19.17em;height:34.33em;"/></div>
<p>Upon i<span>nputting valid product information, click <span class="packt_screen">ADD PRODUCT</span>. The product will be inserted as a new record in the products table of the application's SQLite database. Add a few more products with the form and click <span class="packt_screen">SHOW PRODUCTS</span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/55aa67c9-45b5-4e78-99c6-7457679229c5.jpg" style="width:20.25em;height:36.33em;"/></div>
<p>Doing this will lead to the invocation of <kbd>showProducts()</kbd> in <kbd>MainActivity</kbd>. All product records will be fetched and displayed in toast messages one after the other.&#160;</p>
<p>That is as much as we need to implement in a sample application to demonstrate how content providers work. Try to make the application even more awesome by implementing functionality for updating and deleting product records. Doing so will be good practice!</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we dived headfirst into the various mediums of data storage that the Android application framework puts at our disposal. We took a look at how we can use internal storage and external storage to store data in private and public files. In addition, we learned how to work with cache files with the help of both internal and external storage.</p>
<p>Further into the chapter, we learned about the SQLite RDBMS and explored how we can make use of it in our Android applications. We learned how to utilize <kbd>Room</kbd> to retrieve and store data in a SQLite database and then went a step further by exploring how to use content providers to control access to data with a SQLite database as an underlying datastore.</p>
<p>In the next chapter, we will conclude our Android application framework exploration by learning how to secure and deploy an Android application.</p>


            </article>

            
        </section>
    </div>
</body>
</html>