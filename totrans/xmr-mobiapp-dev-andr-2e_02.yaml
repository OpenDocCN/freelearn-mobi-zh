- en: Chapter 2. The Xamarin.Android Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an understanding of the Android platform, let''s talk about
    Xamarin. In this chapter, we will take a look at the architecture of Xamarin.Android
    and how it facilitates the development of Android apps using C# and .NET. This
    chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits and drawbacks of adopting Xamarin.Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Mono?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono and Android Runtime side by side (peer objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Xamarin.Android binding libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development of IDE choices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Xamarin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin is a San Francisco, California-based software company, which provides
    commercial software development tools, that leverage the Mono open source project
    in order to allow you to develop applications for Android, iOS, and Mac using
    C# and the .NET framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin brings a wide range of products to simplify the mobile application
    development in a cross-platform way. The following are some of the products offered
    by Xamarin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Xamarin platform**: Xamarin uses the open source implementation of the.NET
    framework called Mono. The Xamarin framework implementation includes its own compiler
    written in C# and the .NET libraries. The Xamarin platform includes the following
    products:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin.iOS**: This is also known as MonoTouch. This is used for building
    native iOS applications using C# and .NET.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin.Android**: This is also known as Mono for Android or formally known
    as MonoDroid. This is used for building native Android applications using C# and
    .NET.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin.Forms**: In both Xamarin.Android and Xamarin.iOS, we cannot build
    a pure cross-platform application. The part of the application that is platform-independent
    can then be isolated and reused across the platform; however, you still need to
    write platform-specific code for designing the application''s interface. This
    is where Xamarin.Forms comes into picture. Xamarin.Forms allows you to write the
    user-interface code that can be compiled for the iPhone, Android, and Windows
    Phone.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin.Mac**: This is also known as Mono for Mac. Xamarin.Mac allows you
    to develop fully native Mac applications in C# and .NET.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xmarin.Windows**: This is also known as Mono for Windows. Xamarin.Windows
    allows you to develop a fully Windows App in C# and .NET.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The product we will use in this book for developing the Android application
    is Xamarin.Android.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Development IDEs**: Along with frameworks, it also brings the required development
    IDEs, such as Xamarin Studio and the Visual Studio plugin. Xamarin Studio is a
    fully integrated IDE, which comes handy with the Xamarin package. Xamarin Studio
    can be used for both Windows and Mac operating systems. Xamarin Studio includes
    some of the rich features, including code completion, a debugging interface, an
    Android layout builder, and integration with Xcode Interface Builder for iOS app
    design. However, if you''re familiar with Visual Studio, you can continue to take
    almost all the benefits mentioned earlier from Visual Studio using the Visual
    Studio support plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin Test Cloud:** Mobile application testing is quite challenging, as
    we have to consider the various form factors, device densities, connectivity types,
    and different OS versions. It is nearly impossible to test your application on
    all the targeted devices. Xamarin Test Cloud is an answer to this problem. Xamarin
    Test Cloud makes it possible to test mobile apps written in any language on collection
    of real devices from around the world. You can write your test scripts using the
    Xamarin testing framework and automate your app testing from CI Systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Xamarin.Android?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we take a dive into the architecture of Xamarin.Android, let's first
    discuss the question of why Xamarin.Android is our choice. Like any significant
    platform decision, one size does not fit all, and there are a number of things
    that should be considered. The following two lists identify some of the key benefits
    and drawbacks of using Xamarin.Android.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using Xamarin.Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**It leverages existing C# and .NET skills**: Developers invest a great deal
    of time and energy in mastering the many features of the C# language and the effective
    use of the .NET framework. Yes, Java and all object-oriented languages have many
    similarities, but there is a real cost associated with going from being proficient
    in C# and .NET to making the same claim in Java. Individuals and groups that have
    made a significant investment in C# and .NET and need to develop Android apps
    would be well served to at least consider Xamarin.Android.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It can be reused in cross-platform development**: While Xamarin will not
    allow you to build a single app that can be deployed to Android, iOS, and Windows,
    it does give you the capability to reuse large portions of your code base across
    all of these platforms. In general, the user interface code and the code that
    deals with the device capabilities tend to be written for each platform, while
    things such as service client logic, client-side validation, data caching, and
    client-side data storage can potentially be shared across multiple platforms.
    This can save a significant amount of time and cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawbacks of using Xamarin.Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**The licensing requirement**: Xamarin.Android as well as Xamarin.iOS and Xamarin.Mac
    are all commercial tools and must be licensed, so there is a tangible cost of
    entry. Check the Xamarin website for current pricing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waiting for updates**: There is some lag time between a new release of the
    Android platform and the corresponding release of Xamarin.Android. However, Xamarin
    is aiming for zero day support for the new version of Android and iOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distribution size**: There are a number of runtime libraries that must be
    distributed with a Xamarin.Android application. We will discuss the actual size
    and strategies for minimizing the distribution size in the last chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the list of drawbacks may seem extensive; in most cases, the impact of
    each can be minimized. If you are a group or individual that places a high value
    on the benefits, you should seriously consider Xamarin.Android.
  prefs: []
  type: TYPE_NORMAL
- en: What is Mono?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mono is an open source, cross-platform implementation of a C# compiler, and
    a **Common Language Runtime** (**CLR**) that is binary compatible with Microsoft
    .NET. The Mono CLR has been ported to many platforms, including Android, most
    Linux distributions, BSD, OS X, Windows, Solaris, and even some game consoles,
    such as Wii and Xbox 360\. In addition, Mono provides a static compiler that allows
    apps to be compiled for environments, such as iOS and PS3.
  prefs: []
  type: TYPE_NORMAL
- en: Mono for Android runs natively and provides almost all the capabilities that
    a typical native Android app can have. It allows developers to reuse a larger
    portion of the code without a major performance trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: Mono and Dalvik side by side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can recall from, Chapter 1, *The Anatomy of an Android App*, Android
    apps run within the Dalvik VM, and we now know that Mono apps run within the Mono
    CLR. So how does a Xamarin.Android app run? A simple answer is that it uses both
    the Mono CLR and the Dalvik VM. The following diagram depicts how the runtimes
    coexist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/UKyr5JC5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xamarin.Android applications use both Mono CLR and the Dalvik VM side by side
    and run on top of the Linux kernel. The .Net API resides as a part of the Mono
    CLR and provides a set of classes (for example, System.Data, System.Net, System.IO,
    and so on.) to access various device OS features. However, with .Net APIs, you
    cannot directly access most of the device-specific features, such as Audio, Telephony,
    OpenGL, and so on. They are made available as a part of the Android SDK or as
    Java API and can be accessed using the Android binding libraries. The following
    section covers more on the Android binding libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Since Android 5.0 (Lollipop) release, the Dalvik VM was replaced by its successor,
    Android Runtime (ART). This means that now Xamarin.Android applications run with
    the Mono VM alongside ART. Both the runtimes work on top of the Linux kernel and
    expose a set of classes to access the device features.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do the Mono CLR and **Android Runtime** (**ART**) work together in a
    Xamarin.Android app? The magic is accomplished through a concept called and a
    framework called the JNI.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Native Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Java Native Interface** (**JNI**) is a framework that allows a non-Java
    code (such as C++ or C#) to call or be called by a Java code running inside a
    JVM. As you can see from the preceding diagram, JNI is a critical component in
    the overall Xamarin.Android architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Peer objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Peer objects are a pair of objects consisting of a managed object residing in
    the Mono CLR and a Java object residing in the Dalvik VM, which work together
    to perform the functions of a Xamarin.Android app.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Android is delivered with a set of assemblies called the Android binding
    libraries. Classes in the Android binding libraries correspond to the Java classes
    in the Android application framework, and the methods in the binding classes act
    as wrappers to call corresponding methods on Java classes. Binding classes are
    referred to as **Managed Callable Wrappers** (**MCW**). Anytime you create a C#
    class that inherits from one of these binding classes, a corresponding Java proxy
    class is generated at build time. The Java proxy contains a generated override
    for each overridden method in your C# class and acts as a wrapper to call the
    corresponding method on the C# class.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of peer objects can be initiated from within the Dalvik VM by the
    Android application framework or from within the Mono CLR by the code you write
    in the overridden methods. A reference between the two peer objects is kept by
    each instance of a MCW and can be accessed through the `Android.Runtime.IJavaObject.Handle`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts how peer objects collaborate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/BtSojYUm.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xamarin.Android application packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Chapter 1, *The Anatomy of an Android App*, we discussed Android packages
    (`.apk` files). Xamarin.Android creates the `.apk` files but also includes the
    following additional types of files:'
  prefs: []
  type: TYPE_NORMAL
- en: The C# code is stored as assemblies (containing IL) in the assembly folder of
    the archive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mono runtime is packaged as native libraries within the apk. The Xamarin.Android
    application must contain the native libraries for the desired Android architectures.
    If it doesn't contain the required libraries, the application will fail to run
    for those architectures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android bindings design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core parts of Xamarin.Android are the bindings for the Android APIs. The
    Xamarin team focused a great deal in developing a consistent approach to create
    the bindings so that a C# .NET developer would feel at home when using them. This
    has resulted in a number of key benefits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Android API feels natural to a C# .NET developer and allows the developer
    to explore the API using the code completion and pop-up documentation from within
    the IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# developers can leverage the vast array of Java/Android examples and documentation
    that can be easily transformed for use with C# and Xamarin.Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the key design principles for the Xamarin.Android
    binding. A complete set of design principles can be found on the Xamarin website:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing developers to subclass Java classes from the Android application framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing a strongly typed API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing JavaBean properties as C# properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing Java event listeners as C# delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JavaBean properties, the getter and setter methods, are transformed to
    C# properties, when appropriate. The following rules are used to determine when
    properties should be created:'
  prefs: []
  type: TYPE_NORMAL
- en: Read/write properties are created for the getter and setter method pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only properties are created for getters without corresponding setter methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No write-only properties are created in the rare case that only a setter exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties are not created when the type would be an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may be aware, Java does not have a property construct but instead follows
    a design pattern defined in the JavaBean specification. In order to define a property,
    a developer simply creates the public getter and setter methods with read-only
    properties that only provide a getter method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android APIs follow the Java pattern for defining and hooking up event
    listeners. The C# developers are more familiar with using delegates and events,
    so the Android bindings attempt to facilitate this using the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: When a `listener` callback has a `void` return, an event is generated based
    on the `EventHandler` delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a `listener` callback does not have a `void` return, a specific delegate
    is generated that supports the appropriate signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These events or properties are only created under the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The Android event handling method has a prefix, for example, `setOnClickListener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android event handler has a `void` return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android event handler has a single parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants to enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common in the Android APIs to see methods that accept or return an `int`
    type that must be mapped to a constant to determine its meaning. When possible,
    the Xamarin team creates a .NET enumeration to replace the constants and adjusts
    the appropriate methods to work with the enumerations. This provides a significant
    productivity gain by being able to use IntelliSense from within the IDE as well
    as enhance the type safety of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Development environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The choice of an appropriate IDE for development is absolutely mandatory, as
    it can greatly ease and speed up your development, if you choose the right one.
    There are two choices when it comes to IDEs: Xamarin Studio or Visual Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: For developing an iOS application, you can use either use Xamarin Studio or
    the Xamarin iOS Visual Studio plugin on Windows machines. However, you cannot
    build and run an iOS application on Windows OS. You must have a Mac computer.
  prefs: []
  type: TYPE_NORMAL
- en: Windows users have two IDE choices for developing the Android application. You
    can either use Xamarin Studio or Visual Studio. If you're on Mac OS, then you
    have to use the Android Studio IDE. All the examples in this book are developed
    using Xamarin Studio on Mac.
  prefs: []
  type: TYPE_NORMAL
- en: The following section lists some of the unique features that come handy with
    both Xamarin Studio and the Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xamarin Studio is a customized version of the MonoDevelop IDE, which can be
    used to develop Android, iOS, and OS X applications. Xamarin Studio is available
    on both OS X and Windows and has many advanced features as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Code completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart syntax highlighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code tooltips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated debugging for mobile apps running on emulators or on devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control integration with Git and subversion built-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Xamarin component store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NuGet package browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows Xamarin Studio on Mac OS with the Android user
    interface designer opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/VHxdSxnb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xamarin for Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xamarin for Visual Studio is an add-in that supports the development of the
    Xamarin.Android and Xamarin.iOS apps. The Visual Studio add-in for Xamarin requires
    at least a business or enterprise license. It is not available for basic Indie
    lenience users. If you already have a license for Visual Studio and are comfortable
    with the environment, the add-in will likely be more appealing than Xamarin Studio
    because of the simplicity of adoption. Apart from the basic features, such as
    code completion, syntax highlighter, smart navigation and tooltip, the Xamarin
    Visual Studio add-in extends the IDE capabilities to make the mobile development
    painless. The following are some of the specialized features from Xamarin for
    Visual Studio that are add-ins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliSense**: This helps developers take a quick look up at the language
    reference for both iOS and Android APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Designer**: With Visual Designers, you don''t necessarily need to
    remember all the properties of a view, while building UI layouts for multiple
    resolutions. This also integrates with a property editor that enables easy property
    configurations such as color, font, size, margin, view ID, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows Visual Studio 2012 with the Android user interface
    designer opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/gZd3WcOH.jpg)'
  prefs: []
  type: TYPE_IMG
- en: IDE comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not a surprise that every IDE provides the basic core functionalities
    for developers and some of the unique features of its own. The following table
    depicts the pros and cons of two different IDE choices available for the Xamarin.Android
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: IDE
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs: []
  type: TYPE_NORMAL
- en: Cons
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin Studio
  prefs: []
  type: TYPE_NORMAL
- en: It comes with Xamarin.Android and no additional license is required. It runs
    on Windows and OS X.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs on both Windows and Mac OS for the Xamairn.Android license.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, it does not support the use of TFS for source control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Most of the C# developers are already familiar and comfortable with Visual Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This comes in handy when using TFS for source control, which is used in many
    .NET shops. No additional third-party tool or configuration is required while
    using TFS in Visual Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires the Xamarin Android business or enterprise licenses for using Visual
    Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs on Windows only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution and project files created and updated by Xamarin Studio are compatible
    with Visual Studio, making it easy to switch between the two environments throughout
    the duration of a project. This also allows the team members to adopt the tool
    that they are most comfortable with or that runs on their platform of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the architecture of Xamarin.Android and the magic
    of how it facilitates the creation of Android apps using C# and .NET. We also
    reviewed a set of benefits and drawbacks of adopting Xamarin.Android. In the next
    chapter, we will install Xamain.Android and create a project that we will build
    for the remainder of the book.
  prefs: []
  type: TYPE_NORMAL
