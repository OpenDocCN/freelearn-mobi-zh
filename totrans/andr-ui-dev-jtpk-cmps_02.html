<html><head></head><body><div><div><h1 id="_idParaDest-16"><a id="_idTextAnchor014"/>Chapter 1: Building Your First Compose App</h1>
			<p>When Android was introduced more than 10 years ago, it quickly gained popularity among developers because it was incredibly easy to write apps. All you had to do was define the user interface (UI) in an XML file and connect it to your <em class="italic">activity</em>. This worked flawlessly because apps were small and developers needed to support just a handful of devices.</p>
			<p>So much has changed since then.</p>
			<p>With every new platform version, Android gained new features. Through the years, device manufacturers introduced thousands of devices with different screen sizes, pixel densities, and form factors. While Google did its best to keep the Android <em class="italic">view</em> system comprehendible, the complexity of apps increased significantly; basic tasks such as implementing scrolling lists or animations require lots of boilerplate code. </p>
			<p>It turned out that these problems were not specific to Android. Other platforms and operating systems faced them as well. Most issues stem from how UI toolkits used to work; they follow a so-called <strong class="bold">imperative approach</strong> (which I will explain in <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>). The solution was a paradigm shift. The web framework React was the first to popularize a declarative approach. Other platforms and frameworks (for example, Flutter and SwiftUI) followed.</p>
			<p><strong class="bold">Jetpack Compose</strong> is<a id="_idIndexMarker000"/> Google's declarative UI framework for Android. It dramatically simplifies the creation of UIs. As you will surely agree after reading this book, using Jetpack Compose is both easy and fun. But before we dive in, please note that Jetpack Compose is Kotlin-only. This means that all your Compose code will have to be written in Kotlin. To follow this book, you should have a basic understanding of the Kotlin syntax and the functional programming model. If you want to learn more about these topics, please refer to the <em class="italic">Further reading</em> section at the end of this chapter.</p>
			<p>This chapter covers three main topics:</p>
			<ul>
				<li>Saying hello to composable functions</li>
				<li>Using the preview</li>
				<li>Running a Compose app</li>
			</ul>
			<p>I will explain how to build a simple UI with Jetpack Compose. Next, you will learn to use the <strong class="bold">preview</strong> feature in Android Studio and how to run a Compose app. By the end of this chapter, you will have a basic understanding of how composable functions work, how they are integrated into your app, and how your project must be configured in order to use Jetpack Compose.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01</a>. Please download the zipped version or clone the repository to an arbitrary location on your computer. The projects require at least Android Studio Arctic Fox. You can download the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. Please follow the detailed installation instructions at <a href="https://developer.android.com/studio/install">https://developer.android.com/studio/install</a>.</p>
			<p>To open this book's project, launch Android Studio, click the <strong class="bold">Open</strong> button in the upper-right area of the <strong class="bold">Welcome to Android Studio</strong> window, and select the base directory of the project in the folder selection dialog. Please make sure to not open the base directory of the repository, because Android Studio would not recognize the projects. Instead, you must pick the directory that contains the project you want to work with.</p>
			<p>To run a sample app, you need a real device or the Android Emulator. Please make sure that developer options and USB debugging are enabled on the real device, and that the device is connected to your development machine via USB or WLAN. Please follow the instructions at <a href="https://developer.android.com/studio/debug/dev-options">https://developer.android.com/studio/debug/dev-options</a>. You can also set up the Android Emulator. You can find detailed instructions at <a href="https://developer.android.com/studio/run/emulator">https://developer.android.com/studio/run/emulator</a>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor016"/>Saying hello to composable functions</h1>
			<p>As you will see shortly, composable functions <a id="_idIndexMarker001"/>are the essential building blocks of Compose apps; these elements make up the UI.</p>
			<p>To take a first look at them, I will walk you through a simple app called <code>chapter_01</code>. Otherwise, please do so now. To follow this section, open the project in Android Studio and open <code>MainActivity.kt</code>. The use case of our first Compose app is very simple. After you have entered your name and clicked on the <strong class="bold">Done</strong> button, you will see a greeting message:</p>
			<p class="figure-caption"><a id="_idTextAnchor017"/></p>
			<div><div><img src="img/B17505_01_01.jpg" alt="Figure 1.1 – The Hello app&#13;&#10;" width="1127" height="509"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The Hello app</p>
			<p>Conceptually, the app consists of the following:</p>
			<ul>
				<li>The welcome text</li>
				<li>A row with an <code>EditText</code> equivalent and a button</li>
				<li>A greeting message</li>
			</ul>
			<p>Let's take a look at<a id="_idIndexMarker003"/> how to create the app.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Showing a welcome text</h2>
			<p>Let's start<a id="_idIndexMarker004"/> with the welcome text, our first composable function:</p>
			<pre>@Composable
fun Welcome() {
  Text(
    text = stringResource(id = R.string.welcome),
    style = MaterialTheme.typography.subtitle1
  )
}</pre>
			<p>Composable functions <a id="_idIndexMarker005"/>can be easily identified by the <code>@Composable</code> annotation. They do not need to have a particular return type but instead emit UI elements. This is usually done by invoking other composables (for the sake of brevity, I will sometimes omit the word "function"). <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, will cover this in greater detail.</p>
			<p>In this example, <code>Welcome()</code> summons a text. <code>Text()</code> is a built-in composable function and belongs to the <code>androidx.compose.material</code> package.</p>
			<p>To invoke <code>Text()</code> just by its name, you need to import it:</p>
			<pre>import androidx.compose.material.Text</pre>
			<p>Please note that you can save <code>import</code> lines by using the <code>*</code> wildcard.</p>
			<p>To use <code>Text()</code> and other Material Design elements, your <code>build.gradle</code> file must include an implementation dependency to <code>androidx.compose.material:material</code>.</p>
			<p>Looking back at the welcome text code, the <code>Text()</code> composable inside <code>Welcome()</code> is configured through two parameters, <code>text</code> and <code>style</code>.</p>
			<p>The first, <code>text</code>, specifies what text will be displayed. <code>R.string</code> may look familiar; it refers to definitions inside the <code>strings.xml</code> files. Just like in view-based apps, you define text for UI elements there. <code>stringResource()</code> is a predefined composable function. It belongs to the <code>androidx.compose.ui.res</code> package.</p>
			<p>The <code>style</code> parameter modifies the visual appearance of a text. In this case, the output will look like a subtitle. I will <a id="_idIndexMarker006"/>show you how to create your own themes in <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>.</p>
			<p>The next composable looks quite similar. Can you spot the differences?</p>
			<pre>@Composable
fun Greeting(name: String) {
  Text(
    text = stringResource(id = R.string.hello, name),
    textAlign = TextAlign.Center,
    style = MaterialTheme.typography.subtitle1
  )
}</pre>
			<p>Here, <code>stringResource()</code> receives an additional parameter. This is very convenient for replacing placeholders with actual texts. The string is defined in <code>strings.xml</code>, as follows:</p>
			<pre>&lt;string name="hello"&gt;Hello, %1$s.\nNice to meet you.&lt;/string&gt;</pre>
			<p>The <code>textAlign</code> parameter specifies how text is positioned horizontally. Here, each line is centered.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Using rows, text fields, and buttons</h2>
			<p>Next, let's turn to <a id="_idIndexMarker007"/>the text input field (<code>Row()</code>, which belongs to the <code>androidx.compose.foundation.layout</code> package. Just like all composable functions, <code>Row()</code> can receive a comma-separated list of parameters inside <code>( )</code> and its children are put inside curly braces:</p>
			<pre>@Composable
fun TextAndButton(name: MutableState&lt;String&gt;, 
                  nameEntered: MutableState&lt;Boolean&gt;) {
  Row(modifier = M<a id="_idTextAnchor020"/>odifier.padding(top = 8.dp)) {
    ...
  }
}</pre>
			<p><code>TextAndButton()</code> requires two parameters, <code>name</code> and <code>nameEntered</code>. You will see what they are used for in the <em class="italic">Showing a greeting message</em> section. For now, please ignore their <code>MutableState</code> type.</p>
			<p><code>Row()</code> receives a <a id="_idIndexMarker009"/>parameter called <code>modifier</code>. Modifiers are a key technique in Jetpack Compose to influence both the look and behavior of composable functions. I will explain them in greater detail in <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>.</p>
			<p><code>padding(top = 8.dp)</code> means<a id="_idIndexMarker010"/> that the row will have a padding of eight density-independent pixels (<code>.dp</code>) at its upper side, thus separating itself from the welcome message above it.</p>
			<p>Now, we will look at the text input field, which allows the user to enter a name:</p>
			<pre>TextField(
  value = <strong class="bold">name.value</strong>,
  onValueChange = {
    <strong class="bold">name.value</strong> = it
  },
  placeholder = {
    Text(text = stringResource(id = R.string.hint))
  },
  modifier = Modifier
    .alignByBaseline()
    .weight<a id="_idTextAnchor021"/>(1.0F),
  singleLine = true,
  keyboardOptions = KeyboardOptions(
    autoCorrect = false,
    capitalization = KeyboardCapitalization.Word<a id="_idTextAnchor022"/>s,
  ),
  keyboardActions = KeyboardActions(onAn<a id="_idTextAnchor023"/>y = {
    nameEntered.value = true
  })
)</pre>
			<p><code>TextField()</code> belongs<a id="_idIndexMarker011"/> to the <code>androidx.compose.material</code> package. The composable can receive quite a few arguments; most of them are optional, though. Please note that the previous code fragment uses both the <code>name</code> and <code>nameEntered</code> parameters, which are passed to <code>TextAndButton()</code>. Their type is <code>MutableState</code>. <code>MutableState</code> objects carry changeable values, which you access as <code>name.value</code> or <code>nameEntered.value</code>.</p>
			<p>The <code>value</code> parameter <a id="_idIndexMarker012"/>of a <code>TextField()</code> composable receives the current value of the text input field, for example, text that has already been input. <code>onValueChange</code> is invoked when changes to the text occur (if the user enters or deletes something). But why is <code>name.value</code> used in both places? I will answer this question in the <em class="italic">Showing a greeting message</em> section.</p>
			<p class="callout-heading">Recomposition</p>
			<p class="callout">Certain types trigger a so-called recomposition. For now, think of this as repainting an associated composable. <code>MutableState</code> is such a type. If we change its value, the <code>TextField()</code> composable is redrawn or repainted. Please note that both terms are not entirely correct. We will cover recomposition in <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>.</p>
			<p>Let's briefly look at the remaining code. With <code>alignByBaseline()</code>, we can nicely align the baselines of other composable functions in a particular <code>Row()</code>. <code>placeholder</code> contains the text that is shown until the user has entered something. <code>singleLine</code> controls whether the user can enter multiple lines of text. Finally, <code>keyboardOptions</code> and <code>keyboardActions</code> describe the behavior of the onscreen keyboard. For example, certain actions will set <code>nameEntered.value</code> to <code>true</code>. I will show you soon why we do this.</p>
			<p>However, we need to <a id="_idIndexMarker013"/>take a look at <a id="_idIndexMarker014"/>the <code>Button()</code> composable first. It also belongs to the <code>androidx.compose.material</code> package:</p>
			<pre>Button(modifier <a id="_idTextAnchor024"/>= Modifier
  .alignByBaseline()
  .padding(8.dp),
  on<a id="_idTextAnchor025"/>Click = {
    nameEntered.value = true
  }) {
  Text(text = stringResource(id = R.string.done))
}</pre>
			<p>Some things will already look familiar. For example, we call <code>alignByBaseline()</code> to align the baseline of the button with the text input field, and we apply a padding of eight density-independent pixels to all sides of the button using <code>padding()</code>. Now, <code>onClick()</code> specifies what to do when the button is clicked. Here, too, we set <code>nameEntered.value</code> to <code>true</code>. The next composable function, <code>Hello()</code>, finally shows you why this is done.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor026"/>Showing a greeting message</h2>
			<p><code>Hello()</code> emits <code>Box()</code>, which (depending on <code>nameEntered.value</code>) contains either the <code>Greeting()</code> or a <code>Column()</code> composable <a id="_idIndexMarker015"/>that, in turn, includes <code>Welcome()</code> and <code>TextAndButton()</code>. The <code>Column()</code> composable is quite similar to <code>Row()</code> but arranges its siblings vertically. Like the latter one and <code>Box()</code>, it belongs to the <code>androidx.compose.foundation.layout</code> package. <code>Box()</code> can contain one or more children. They are positioned inside the box according to the <code>contentAlignment</code> parameter. We will be exploring this in greater detail in the <em class="italic">Combining basic building blocks</em> section of <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>:</p>
			<pre>@Composable
fun Hello() {
  val name = remember { mutableStateOf("") }
  val nameEntered = remember { mutableStateOf(false) }
  Box(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp),
    contentAlignment = Alignment.Center
  ) {
    if (nameEntered.value) {
      Greeting(name.value)
    } else {
      Column(horizontalAlignment =
             Alignment.CenterHorizontally) {
        Welcome()
        TextAndButton(name, nameEntered)
      }
    }
  }
}</pre>
			<p>Have you noticed <code>remember</code> and <code>mutableStateOf</code>? Both are very important for creating <a id="_idIndexMarker016"/>and maintaining state. Generally speaking, state in an app refers to a value that can change over time. While this also applies to domain data (for example, the result of a web service call), state usually refers to something being displayed or used by a UI element. If a composable function has (or relies on) state, it is recomposed (for now, repainted or redrawn) when that state changes. To get an idea of what this means, recall this composable:</p>
			<pre>@Composable
fun Welcome() {
    Text(
        text = stringResource(id = R.string.welcome),
        style = MaterialTheme.typography.subtitle1
    )
}</pre>
			<p><code>Welcome()</code> is said <a id="_idIndexMarker017"/>to be stateless; all values that might trigger a recomposition remain the same for the time being. <code>Hello()</code>, on the other hand, is stateful, because it uses the <code>name</code> and <code>nameEntered</code> variables. They change over time. This may not be obvious if you look at the source code of <code>Hello()</code>. Please recall that both <code>name</code> and <code>nameEntered</code> are passed to <code>TextAndButton()</code> and modified there.</p>
			<p>Do you recall that in the previous section I promised to explain why <code>name.value</code> is used in two places, providing the text to display and receiving changes after the user has entered something? This is a common pattern often used with states; <code>Hello()</code> creates and remembers state by invoking <code>mutableStateOf()</code> and <code>remember</code>. And it passes state to another composable (<code>TextAndButton()</code>), which is <a id="_idIndexMarker018"/>called <strong class="bold">state hoisting</strong>. You will learn more about this in <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>.</p>
			<p>So far, you have seen the source code of quite a few composable functions but not their output. Android Studio has a very importa<a id="_idTextAnchor027"/>nt feature <a id="_idIndexMarker019"/>called <strong class="bold">Compose preview</strong>. It allows you to view a composable function without running the app. In the next section, I will show you how to use this feature.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor028"/>Using the preview</h1>
			<p>The upper-right corner of the Android Studio code editor<a id="_idIndexMarker020"/> contains three buttons, <strong class="bold">Code</strong>, <strong class="bold">Split</strong>, and <strong class="bold">Design</strong> (<em class="italic">Figure 1.2</em>):</p>
			<div><div><img src="img/B17505_01_02.jpg" alt="Figure 1.2 – Compose preview (Split mode)&#13;&#10;" width="1136" height="286"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Compose preview (Split mode)</p>
			<p>They switch between the following different display modes:</p>
			<ul>
				<li>Code only</li>
				<li>Code and preview</li>
				<li>Preview only</li>
			</ul>
			<p>To use the Compose preview, your composable functions must contain an additional annotation, <code>@Preview</code>, which belongs to the <code>androidx.compose.ui.tooling.preview</code> package. This requires an implementation dependency to <code>androidx.compose.ui:ui-tooling-preview</code> in your <code>build.gradle</code> file.</p>
			<p>Unfortunately, if you try to add <code>@Preview</code> to <code>Greeting()</code>, you will see an error message like this:</p>
			<pre>Composable functions with non-default parameters are not supported in Preview unless they are annotated with @PreviewParameter.</pre>
			<p>So, how can you preview composables that take parameters?</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor029"/>Preview parameters</h2>
			<p>The<a id="_idIndexMarker021"/> most obvious solution is a wrapper composable:</p>
			<pre>@Composable
@Preview
fun GreetingWrapper() {
  Greeting("Jetpack Compose")
}</pre>
			<p>This means that you write another composable function that takes no parameters but invokes your existing one and provides the required parameter (in my example, a text). Depending on how many composable functions your source file contains, you might be creating quite a lot of boilerplate code. The wrappers don't add value besides enabling the preview.</p>
			<p>Fortunately, there are other options. You can, for example, add default values to your composable:</p>
			<pre>@Composable
fun AltGreeting(name: String = "Jetpack Compose") {</pre>
			<p>While this looks less hacky, it alters how your composable functions can be invoked (that is, without passing a parameter). This may not be desirable if you had a reason for not defining a default value in the first place.</p>
			<p>With <code>@PreviewParameter</code>, you can pass values to a composable that affect only the preview. Unfortunately, this is a little verbose, though, because you need to write a new class: </p>
			<pre>class HelloProvider : PreviewParameterProvider&lt;String&gt; {
  override val values: Sequence&lt;String&gt;
    get() = listOf("PreviewParameterProvider").asSequence()
}</pre>
			<p>The class must extend <code>androidx.compose.ui.tooling.preview.PreviewParameterProvider</code> because it will provide a parameter for the preview. Now, you can annotate the parameter of the composable with <code>@PreviewParameter</code> and pass your new class:</p>
			<pre>@Composable
@Preview
fun AltGreeting2(@PreviewParameter(HelloProvider::class)
        name: String) {</pre>
			<p>In a way, you <a id="_idIndexMarker022"/>are creating boilerplate code, too. So, which method you choose in the end is a matter of personal taste. The <code>@Preview</code> annotation can receive quite a few parameters. They modify the visual appearance of the preview. Let's explore some of them.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>Configuring previews</h2>
			<p>You can<a id="_idIndexMarker023"/> set a background color for a preview using <code>backgroundColor =</code>. The value is a <code>Long</code> type and represents an ARGB color. Please make sure to also set <code>showBackground</code> to <code>true</code>. The following snippet will produce a solid red background:</p>
			<pre>@Preview(showBackground = true, backgroundColor =
         0xffff0000)</pre>
			<p>By default, preview dimensions are chosen automatically. If you want to set them explicitly, you can pass <code>heightDp</code> and <code>widthDp</code>:</p>
			<pre>@Composable
@Preview(widthDp = 100, heightDp = 100)
fun Welcome() {
  Text(
    text = stringResource(id = R.string.welcome),
    style = MaterialTheme.typography.subtitle1
  )
}</pre>
			<p><em class="italic">Figure 1.3</em> shows the result. Both values are interpreted as density-independent pixels, so you don't need to add <code>.dp</code> as you would do inside your composable function.</p>
			<div><div><img src="img/B17505_01_03.jpg" alt="Figure 1.3 – Setting the width and height of a preview&#13;&#10;" width="262" height="281"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Setting the width and height of a preview</p>
			<p>To test<a id="_idIndexMarker024"/> different user locales, you can add the <code>locale</code> parameter. If, for example, your app contains German strings inside <code>values-de-rDE</code>, you can use them by adding the following:</p>
			<pre>@Preview(locale = "de-rDE")</pre>
			<p>The string matches the directory name after <code>values-</code>. Please recall that the directory is created by Android Studio if you add a language in the Translations Editor.</p>
			<p>If you want to display the status and action bars, you can achieve this with <code>showSystemUi</code>:</p>
			<pre>@Preview(showSystemUi = true)</pre>
			<p>To get an idea of how your composables react to different form factors, aspect ratios, and pixel densities, you can utilize the <code>device</code> parameter. It takes a string. Pass one of the values from <code>Devices</code>, for example, <code>Devices.PIXEL_C</code> or <code>Devices.AUTOMOTIVE_1024p</code>.</p>
			<p>In this section, you have seen how to configure a preview. Next, I will introduce you to preview groups. They are very handy if your source code file contains more than a few composable functions that you want to preview.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor031"/>Grouping previews</h2>
			<p>Android Studio <a id="_idIndexMarker025"/>shows composable functions with a <code>@Preview</code> annotation in the order of their appearance in the source code. You can choose between <strong class="bold">Vertical Layout</strong> and <strong class="bold">Grid Layout</strong> (<em class="italic">Figure 1.4</em>):</p>
			<div><div><img src="img/B17505_01_04.jpg" alt="Figure 1.4 – Switching between Vertical Layout and Grid Layout&#13;&#10;" width="199" height="77"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Switching between Vertical Layout and Grid Layout</p>
			<p>Depending on the number of your composables, the preview pane may at some point feel crowded. If this is the case, just put your composables into different groups by adding a <code>group</code> parameter:</p>
			<pre>@Preview(group = "my-group-1")</pre>
			<p>You can then show either all composable functions or just those that belong to a particular group (<em class="italic">Figure 1.5</em>):</p>
			<div><div><img src="img/B17505_01_05.jpg" alt="Figure 1.5 – Switching between groups&#13;&#10;" width="145" height="82"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Switching between groups</p>
			<p>So far, I have shown you what the source code of composable functions looks like and how you can preview them inside Android Studio. In the next section, we will execute a composable on the Android Emulator or a real device, and you will learn how to connect composable functions to the other parts of an app. But before that, here is one more tip:</p>
			<p class="callout-heading">Export a Preview as an Image</p>
			<p class="callout">If you click on a <a id="_idIndexMarker026"/>Compose preview with the secondary mouse button, you will see a small pop-up menu. Select <strong class="bold">Copy Image</strong> to put a bitmap of the preview on the system clipboard. Most graphics applications allow you to paste it into a new document.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor032"/>Running a Compose app</h1>
			<p>If you <a id="_idIndexMarker027"/>want to see how a composable function looks and feels on the Android Emulator or a real device, you have two options:</p>
			<ul>
				<li>Deploying a composable function</li>
				<li>Running the app</li>
			</ul>
			<p>The first option is useful if you want to focus on a particular composable rather than the whole app. Also, the time needed to deploy a composable may be significantly shorter than deploying a complete app (depending on the app size). So, let's start with this one.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor033"/>Deploying a composable function</h2>
			<p>To deploy a<a id="_idIndexMarker028"/> composable function to a real device or the Android Emulator, click on the <strong class="bold">Deploy Preview</strong> button, which is a small image in the upper-right corner of a p<a id="_idTextAnchor034"/>review (<em class="italic">Figure 1.6</em>):</p>
			<div><div><img src="img/B17505_01_06.jpg" alt="Figure 1.6 – Deploying a composable function&#13;&#10;" width="626" height="156"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Deploying a composable function</p>
			<p>This will automatically create new launch configurations (<em class="italic">Figure 1.7</em>):</p>
			<div><div><img src="img/B17505_01_07.jpg" alt="Figure 1.7 – Launch configurations representing Compose previews&#13;&#10;" width="906" height="410"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Launch configurations representing Compose previews</p>
			<p>You can<a id="_idIndexMarker029"/> modify or delete Compose preview configurations in the <strong class="bold">Run/Debug Configurations</strong> dialog. To access them, open the <strong class="bold">Compose Preview</strong> node. Then you can, for example, change its name or deny parallel runs by unchecking <strong class="bold">Allow parallel run</strong>.</p>
			<p>The goal of this chapter is to deploy and run your first Compose app on a real device or the Android Emulator. You are almost there; in the next section, I will show you how to embed composable functions in an activity, which is a prerequisite. You will finally be running the app in the <em class="italic">Pressing the play button</em> section.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor035"/>Using composable functions in activities</h2>
			<p><strong class="bold">Activities</strong> have<a id="_idIndexMarker030"/> been <a id="_idIndexMarker031"/>one of the basic building blocks of Android apps since the first platform version. Practically every app has at least one activity. They are configured in the manifest file. To launch an activity from the home screen, the corresponding entry looks like this:</p>
			<pre>...
&lt;activity
  android:name=".MainActivity"
  android:exported="true"
  android:label="@string/app_name"&gt;
  &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category
     android:name="android.intent.category.LAUNCHER" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;
...</pre>
			<p>This <a id="_idIndexMarker032"/>is still true for Compose apps. An activity that wishes to show composable functions is set up just like one that <a id="_idIndexMarker033"/>inflates a traditional layout file. But what does its source code look like? The main activity of the <code>Hello</code> app is called <code>MainActivity</code>, shown in the next code block:</p>
			<pre>class MainActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContent {
      Hello()
    }
  }
}</pre>
			<p>As you can see, it is very short. The UI (the <code>Hello()</code> composable function) is displayed by invoking a function called <code>setContent</code>, which is an extension function to <code>androidx.activity.ComponentActivity</code> and belongs to the <code>androidx.activity.compose</code> package.</p>
			<p>To<a id="_idIndexMarker034"/> render composables, your <a id="_idIndexMarker035"/>activity must extend either <code>ComponentActivity</code> or another class that has <code>ComponentActivity</code> as its direct or indirect ancestor. This is the case for <code>androidx.fragment.app.FragmentActivity</code> and <code>androidx.appcompat.app.AppCompatActivity</code>.</p>
			<p>This is an important difference; while Compose apps invoke <code>setContent()</code>, View-based apps call <code>setContentView()</code> and pass either the ID of a layout (<code>R.layout.</code><code>activity_main</code>) or the root view itself (which is usually obtained through some binding mechanism). Let's see how the older mechanism works. The following code snippet is taken from one of my open source apps (you can find it on GitHub at <a href="https://github.com/MATHEMA-GmbH/TKWeek">https://github.com/MATHEMA-GmbH/TKWeek</a> but it won't be discussed any further in this book):</p>
			<pre>class TKWeekActivity : TKWeekBaseActivity() {
  private var backing: TkweekBinding? = null
  private val binding get() = backing!!
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    backing = TkweekBinding.inflate(layoutInflater, null,
              false)
    setContentView(binding.root)
    ...</pre>
			<p>If you compare both approaches, a striking difference is that with Jetpack Compose, there is no need for maintaining references to the UI component tree or individual elements of it. I will explain in <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, why this leads to code that is easily maintainable and less error-prone.</p>
			<p>Let's now return to <code>setContent()</code>. It receives two parameters, a <code>parent</code> (which can be <code>null</code>) and the <code>content</code> (the UI). The <code>parent</code> is an instance of <code>androidx.compose.runtime.CompositionContext</code>. It is used to logically link together two<a id="_idIndexMarker036"/> compositions. This<a id="_idIndexMarker037"/> is an advanced topic that I will be discussing in <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Have you noticed that <code>MainActivity</code> does not contain any composable functions? They do not need to be part of a class. In fact, you should implement them as top-level functions whenever possible. Jetpack Compose provides alternative means to access <code>android.content.Context</code>. You have already seen the <code>stringResource()</code> composable function, which is a replacement for <code>getString()</code>.</p>
			<p>Now that you have seen how to embed composable functions in activities, it is time to look at the structure of Jetpack Compose-based projects. While Android Studio sets everything up for you if you create a Compose app using the project wizard, it is important to know which files are involved under the hood.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor036"/>Looking under the hood</h2>
			<p>Jetpack Compose <a id="_idIndexMarker038"/>heavily relies on Kotlin. This means that your app project must be configured to use Kotlin. It does not imply, though, that you cannot use Java at all. In fact, you can easily mix Kotlin and Java in your project, as long as your composable functions are written in Kotlin. You can also combine traditional views and composables. I will be discussing this topic in <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>.</p>
			<p>First, make sure to configure the Android Gradle plugin that corresponds to your version of Android Studio in the project-level build.gradle file:</p>
			<pre>buildscript {
  ...
  dependencies {
    classpath "com.android.tools.build:gradle:7.0.4"
    classpath "org.jetbrains.kotlin:kotlin-gradle-               plugin:1.5.31"
    ...
  }
}</pre>
			<p>The following code snippets belong in the module-level build.gradle file:</p>
			<pre>plugins {
    id 'com.android.application'
    id 'kotlin-android'
}</pre>
			<p>Next, please <a id="_idIndexMarker039"/>make sure that your app's minimum API level is set to 21 or higher and that Jetpack Compose is enabled. The following code snippet also sets the version for the Kotlin compiler plugin:</p>
			<pre>android {
  defaultConfig {
    ...
    minSdkVersion 21
  }
  buildFeatures {
    compose true
  }
  ...
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_11
    targetCompatibility JavaVersion.VERSION_11
  }
  kotlinOptions {
    jvmTarget = "11"
  }
  composeOptions {
    kotlinCompilerExtensionVersion compose_version
  }
}</pre>
			<p>Finally, declare<a id="_idIndexMarker040"/> dependencies. The following code snippet acts as a good starting point. Depending on which packages your app uses, you may need additional ones:</p>
			<pre>dependencies {
    implementation 'androidx.core:core-ktx:1.7.0'
    implementation 'androidx.appcompat:appcompat:1.4.0'
    Implementation
      "androidx.compose.ui:ui:$compose_version"
    implementation
      "androidx.compose.material:material:$compose_version"
    implementation
      "androidx.compose.ui:ui-tooling-
       preview:$compose_version"
    implementation
      'androidx.lifecycle:lifecycle-runtime-ktx:2.4.0'
    implementation
      'androidx.activity:activity-compose:1.4.0'
    debugImplementation
      "androidx.compose.ui:ui-tooling:$compose_version"
}</pre>
			<p>Once you have configured your project, building and running a Compose app works just like traditional view-based apps.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor037"/>Pressing the play button</h2>
			<p>To run your <a id="_idIndexMarker041"/>Compose app, select your target device, make sure that the <strong class="bold">app</strong> module is selected, and press the green <em class="italic">play</em> button (<em class="italic">Figure 1.8</em>):</p>
			<div><div><img src="img/B17505_01_08.jpg" alt="Figure 1.8 – Android Studio toolbar elements to launch an app&#13;&#10;" width="580" height="36"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Android Studio toolbar elements to launch an app</p>
			<p>Congratulations! Well done. You have now launched your first Compose app, and you have achieved quite a lot. Let's recap.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor038"/>Summary</h1>
			<p>In this chapter, we learned how to write our first composables: Kotlin functions that have been annotated with <code>@Composable</code>. Composable functions are the core building blocks of Jetpack Compose-based UIs. You combined existing library composables with your own to create beautiful app screens. To see a preview, we can add the <code>@Preview</code> annotation. To use Jetpack Compose in a project, both <code>build.gradle</code> files must be configured accordingly.</p>
			<p>In <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, we will take a closer look at the differences between the declarative approach of Jetpack Compose and the imperative nature of traditional UI frameworks such as Android's view-based component library.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor039"/>Further reading</h1>
			<p>This book assumes you have a basic understanding of the syntax of Kotlin and Android development in general. If you would like to learn more about this, I suggest looking at <em class="italic">Android Programming with Kotlin for Beginners</em>, <em class="italic">John Horton</em>, <em class="italic">Packt Publishing</em>, <em class="italic">2019</em>, <em class="italic">ISBN 9781789615401</em>.</p>
		</div>
	</div></body></html>