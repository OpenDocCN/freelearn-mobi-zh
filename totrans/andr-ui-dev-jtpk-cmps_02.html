<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer014">
			<h1 id="_idParaDest-16"><a id="_idTextAnchor014"/>Chapter 1: Building Your First Compose App</h1>
			<p>When Android was introduced more than 10 years ago, it quickly gained popularity among developers because it was incredibly easy to write apps. All you had to do was define the user interface (UI) in an XML file and connect it to your <em class="italic">activity</em>. This worked flawlessly because apps were small and developers needed to support just a handful of devices.</p>
			<p>So much has changed since then.</p>
			<p>With every new platform version, Android gained new features. Through the years, device manufacturers introduced thousands of devices with different screen sizes, pixel densities, and form factors. While Google did its best to keep the Android <em class="italic">view</em> system comprehendible, the complexity of apps increased significantly; basic tasks such as implementing scrolling lists or animations require lots of boilerplate code. </p>
			<p>It turned out that these problems were not specific to Android. Other platforms and operating systems faced them as well. Most issues stem from how UI toolkits used to work; they follow a so-called <strong class="bold">imperative approach</strong> (which I will explain in <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>). The solution was a paradigm shift. The web framework React was the first to popularize a declarative approach. Other platforms and frameworks (for example, Flutter and SwiftUI) followed.</p>
			<p><strong class="bold">Jetpack Compose</strong> is<a id="_idIndexMarker000"/> Google's declarative UI framework for Android. It dramatically simplifies the creation of UIs. As you will surely agree after reading this book, using Jetpack Compose is both easy and fun. But before we dive in, please note that Jetpack Compose is Kotlin-only. This means that all your Compose code will have to be written in Kotlin. To follow this book, you should have a basic understanding of the Kotlin syntax and the functional programming model. If you want to learn more about these topics, please refer to the <em class="italic">Further reading</em> section at the end of this chapter.</p>
			<p>This chapter covers three main topics:</p>
			<ul>
				<li>Saying hello to composable functions</li>
				<li>Using the preview</li>
				<li>Running a Compose app</li>
			</ul>
			<p>I will explain how to build a simple UI with Jetpack Compose. Next, you will learn to use the <strong class="bold">preview</strong> feature in Android Studio and how to run a Compose app. By the end of this chapter, you will have a basic understanding of how composable functions work, how they are integrated into your app, and how your project must be configured in order to use Jetpack Compose.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01</a>. Please download the zipped version or clone the repository to an arbitrary location on your computer. The projects require at least Android Studio Arctic Fox. You can download the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. Please follow the detailed installation instructions at <a href="https://developer.android.com/studio/install">https://developer.android.com/studio/install</a>.</p>
			<p>To open this book's project, launch Android Studio, click the <strong class="bold">Open</strong> button in the upper-right area of the <strong class="bold">Welcome to Android Studio</strong> window, and select the base directory of the project in the folder selection dialog. Please make sure to not open the base directory of the repository, because Android Studio would not recognize the projects. Instead, you must pick the directory that contains the project you want to work with.</p>
			<p>To run a sample app, you need a real device or the Android Emulator. Please make sure that developer options and USB debugging are enabled on the real device, and that the device is connected to your development machine via USB or WLAN. Please follow the instructions at <a href="https://developer.android.com/studio/debug/dev-options">https://developer.android.com/studio/debug/dev-options</a>. You can also set up the Android Emulator. You can find detailed instructions at <a href="https://developer.android.com/studio/run/emulator">https://developer.android.com/studio/run/emulator</a>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor016"/>Saying hello to composable functions</h1>
			<p>As you will see shortly, composable functions <a id="_idIndexMarker001"/>are the essential building blocks of Compose apps; these elements make up the UI.</p>
			<p>To take a first look at them, I will walk you through a simple app called <strong class="bold">Hello</strong> (<em class="italic">Figure 1.1</em>). If you have already cloned or <a id="_idIndexMarker002"/>downloaded the repository of this book, its project folder is located inside <strong class="source-inline">chapter_01</strong>. Otherwise, please do so now. To follow this section, open the project in Android Studio and open <strong class="source-inline">MainActivity.kt</strong>. The use case of our first Compose app is very simple. After you have entered your name and clicked on the <strong class="bold">Done</strong> button, you will see a greeting message:</p>
			<p class="figure-caption"><a id="_idTextAnchor017"/></p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="Images/B17505_01_01.jpg" alt="Figure 1.1 – The Hello app&#13;&#10;" width="1127" height="509"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The Hello app</p>
			<p>Conceptually, the app consists of the following:</p>
			<ul>
				<li>The welcome text</li>
				<li>A row with an <strong class="source-inline">EditText</strong> equivalent and a button</li>
				<li>A greeting message</li>
			</ul>
			<p>Let's take a look at<a id="_idIndexMarker003"/> how to create the app.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Showing a welcome text</h2>
			<p>Let's start<a id="_idIndexMarker004"/> with the welcome text, our first composable function:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Welcome() {</p>
			<p class="source-code">  Text(</p>
			<p class="source-code">    text = stringResource(id = R.string.welcome),</p>
			<p class="source-code">    style = MaterialTheme.typography.subtitle1</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Composable functions <a id="_idIndexMarker005"/>can be easily identified by the <strong class="source-inline">@Composable</strong> annotation. They do not need to have a particular return type but instead emit UI elements. This is usually done by invoking other composables (for the sake of brevity, I will sometimes omit the word "function"). <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, will cover this in greater detail.</p>
			<p>In this example, <strong class="source-inline">Welcome()</strong> summons a text. <strong class="source-inline">Text()</strong> is a built-in composable function and belongs to the <strong class="source-inline">androidx.compose.material</strong> package.</p>
			<p>To invoke <strong class="source-inline">Text()</strong> just by its name, you need to import it:</p>
			<p class="source-code">import androidx.compose.material.Text</p>
			<p>Please note that you can save <strong class="source-inline">import</strong> lines by using the <strong class="source-inline">*</strong> wildcard.</p>
			<p>To use <strong class="source-inline">Text()</strong> and other Material Design elements, your <strong class="source-inline">build.gradle</strong> file must include an implementation dependency to <strong class="source-inline">androidx.compose.material:material</strong>.</p>
			<p>Looking back at the welcome text code, the <strong class="source-inline">Text()</strong> composable inside <strong class="source-inline">Welcome()</strong> is configured through two parameters, <strong class="source-inline">text</strong> and <strong class="source-inline">style</strong>.</p>
			<p>The first, <strong class="source-inline">text</strong>, specifies what text will be displayed. <strong class="source-inline">R.string</strong> may look familiar; it refers to definitions inside the <strong class="source-inline">strings.xml</strong> files. Just like in view-based apps, you define text for UI elements there. <strong class="source-inline">stringResource()</strong> is a predefined composable function. It belongs to the <strong class="source-inline">androidx.compose.ui.res</strong> package.</p>
			<p>The <strong class="source-inline">style</strong> parameter modifies the visual appearance of a text. In this case, the output will look like a subtitle. I will <a id="_idIndexMarker006"/>show you how to create your own themes in <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>.</p>
			<p>The next composable looks quite similar. Can you spot the differences?</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Greeting(name: String) {</p>
			<p class="source-code">  Text(</p>
			<p class="source-code">    text = stringResource(id = R.string.hello, name),</p>
			<p class="source-code">    textAlign = TextAlign.Center,</p>
			<p class="source-code">    style = MaterialTheme.typography.subtitle1</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">stringResource()</strong> receives an additional parameter. This is very convenient for replacing placeholders with actual texts. The string is defined in <strong class="source-inline">strings.xml</strong>, as follows:</p>
			<p class="source-code">&lt;string name="hello"&gt;Hello, %1$s.\nNice to meet you.&lt;/string&gt;</p>
			<p>The <strong class="source-inline">textAlign</strong> parameter specifies how text is positioned horizontally. Here, each line is centered.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Using rows, text fields, and buttons</h2>
			<p>Next, let's turn to <a id="_idIndexMarker007"/>the text input field (<strong class="bold">Your name</strong>) and the <strong class="bold">Done</strong> button, which both appear on the same row. This is a very common pattern, therefore Jetpack Compose provides a composable<a id="_idIndexMarker008"/> named <strong class="source-inline">Row()</strong>, which belongs to the <strong class="source-inline">androidx.compose.foundation.layout</strong> package. Just like all composable functions, <strong class="source-inline">Row()</strong> can receive a comma-separated list of parameters inside <strong class="source-inline">( )</strong> and its children are put inside curly braces:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun TextAndButton(name: MutableState&lt;String&gt;, </p>
			<p class="source-code">                  nameEntered: MutableState&lt;Boolean&gt;) {</p>
			<p class="source-code">  Row(modifier = M<a id="_idTextAnchor020"/>odifier.padding(top = 8.dp)) {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">TextAndButton()</strong> requires two parameters, <strong class="source-inline">name</strong> and <strong class="source-inline">nameEntered</strong>. You will see what they are used for in the <em class="italic">Showing a greeting message</em> section. For now, please ignore their <strong class="source-inline">MutableState</strong> type.</p>
			<p><strong class="source-inline">Row()</strong> receives a <a id="_idIndexMarker009"/>parameter called <strong class="source-inline">modifier</strong>. Modifiers are a key technique in Jetpack Compose to influence both the look and behavior of composable functions. I will explain them in greater detail in <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>.</p>
			<p><strong class="source-inline">padding(top = 8.dp)</strong> means<a id="_idIndexMarker010"/> that the row will have a padding of eight density-independent pixels (<strong class="source-inline">.dp</strong>) at its upper side, thus separating itself from the welcome message above it.</p>
			<p>Now, we will look at the text input field, which allows the user to enter a name:</p>
			<p class="source-code">TextField(</p>
			<p class="source-code">  value = <strong class="bold">name.value</strong>,</p>
			<p class="source-code">  onValueChange = {</p>
			<p class="source-code">    <strong class="bold">name.value</strong> = it</p>
			<p class="source-code">  },</p>
			<p class="source-code">  placeholder = {</p>
			<p class="source-code">    Text(text = stringResource(id = R.string.hint))</p>
			<p class="source-code">  },</p>
			<p class="source-code">  modifier = Modifier</p>
			<p class="source-code">    .alignByBaseline()</p>
			<p class="source-code">    .weight<a id="_idTextAnchor021"/>(1.0F),</p>
			<p class="source-code">  singleLine = true,</p>
			<p class="source-code">  keyboardOptions = KeyboardOptions(</p>
			<p class="source-code">    autoCorrect = false,</p>
			<p class="source-code">    capitalization = KeyboardCapitalization.Word<a id="_idTextAnchor022"/>s,</p>
			<p class="source-code">  ),</p>
			<p class="source-code">  keyboardActions = KeyboardActions(onAn<a id="_idTextAnchor023"/>y = {</p>
			<p class="source-code">    nameEntered.value = true</p>
			<p class="source-code">  })</p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">TextField()</strong> belongs<a id="_idIndexMarker011"/> to the <strong class="source-inline">androidx.compose.material</strong> package. The composable can receive quite a few arguments; most of them are optional, though. Please note that the previous code fragment uses both the <strong class="source-inline">name</strong> and <strong class="source-inline">nameEntered</strong> parameters, which are passed to <strong class="source-inline">TextAndButton()</strong>. Their type is <strong class="source-inline">MutableState</strong>. <strong class="source-inline">MutableState</strong> objects carry changeable values, which you access as <strong class="source-inline">name.value</strong> or <strong class="source-inline">nameEntered.value</strong>.</p>
			<p>The <strong class="source-inline">value</strong> parameter <a id="_idIndexMarker012"/>of a <strong class="source-inline">TextField()</strong> composable receives the current value of the text input field, for example, text that has already been input. <strong class="source-inline">onValueChange</strong> is invoked when changes to the text occur (if the user enters or deletes something). But why is <strong class="source-inline">name.value</strong> used in both places? I will answer this question in the <em class="italic">Showing a greeting message</em> section.</p>
			<p class="callout-heading">Recomposition</p>
			<p class="callout">Certain types trigger a so-called recomposition. For now, think of this as repainting an associated composable. <strong class="source-inline">MutableState</strong> is such a type. If we change its value, the <strong class="source-inline">TextField()</strong> composable is redrawn or repainted. Please note that both terms are not entirely correct. We will cover recomposition in <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>.</p>
			<p>Let's briefly look at the remaining code. With <strong class="source-inline">alignByBaseline()</strong>, we can nicely align the baselines of other composable functions in a particular <strong class="source-inline">Row()</strong>. <strong class="source-inline">placeholder</strong> contains the text that is shown until the user has entered something. <strong class="source-inline">singleLine</strong> controls whether the user can enter multiple lines of text. Finally, <strong class="source-inline">keyboardOptions</strong> and <strong class="source-inline">keyboardActions</strong> describe the behavior of the onscreen keyboard. For example, certain actions will set <strong class="source-inline">nameEntered.value</strong> to <strong class="source-inline">true</strong>. I will show you soon why we do this.</p>
			<p>However, we need to <a id="_idIndexMarker013"/>take a look at <a id="_idIndexMarker014"/>the <strong class="source-inline">Button()</strong> composable first. It also belongs to the <strong class="source-inline">androidx.compose.material</strong> package:</p>
			<p class="source-code">Button(modifier <a id="_idTextAnchor024"/>= Modifier</p>
			<p class="source-code">  .alignByBaseline()</p>
			<p class="source-code">  .padding(8.dp),</p>
			<p class="source-code">  on<a id="_idTextAnchor025"/>Click = {</p>
			<p class="source-code">    nameEntered.value = true</p>
			<p class="source-code">  }) {</p>
			<p class="source-code">  Text(text = stringResource(id = R.string.done))</p>
			<p class="source-code">}</p>
			<p>Some things will already look familiar. For example, we call <strong class="source-inline">alignByBaseline()</strong> to align the baseline of the button with the text input field, and we apply a padding of eight density-independent pixels to all sides of the button using <strong class="source-inline">padding()</strong>. Now, <strong class="source-inline">onClick()</strong> specifies what to do when the button is clicked. Here, too, we set <strong class="source-inline">nameEntered.value</strong> to <strong class="source-inline">true</strong>. The next composable function, <strong class="source-inline">Hello()</strong>, finally shows you why this is done.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor026"/>Showing a greeting message</h2>
			<p><strong class="source-inline">Hello()</strong> emits <strong class="source-inline">Box()</strong>, which (depending on <strong class="source-inline">nameEntered.value</strong>) contains either the <strong class="source-inline">Greeting()</strong> or a <strong class="source-inline">Column()</strong> composable <a id="_idIndexMarker015"/>that, in turn, includes <strong class="source-inline">Welcome()</strong> and <strong class="source-inline">TextAndButton()</strong>. The <strong class="source-inline">Column()</strong> composable is quite similar to <strong class="source-inline">Row()</strong> but arranges its siblings vertically. Like the latter one and <strong class="source-inline">Box()</strong>, it belongs to the <strong class="source-inline">androidx.compose.foundation.layout</strong> package. <strong class="source-inline">Box()</strong> can contain one or more children. They are positioned inside the box according to the <strong class="source-inline">contentAlignment</strong> parameter. We will be exploring this in greater detail in the <em class="italic">Combining basic building blocks</em> section of <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Hello() {</p>
			<p class="source-code">  val name = remember { mutableStateOf("") }</p>
			<p class="source-code">  val nameEntered = remember { mutableStateOf(false) }</p>
			<p class="source-code">  Box(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize()</p>
			<p class="source-code">      .padding(16.dp),</p>
			<p class="source-code">    contentAlignment = Alignment.Center</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    if (nameEntered.value) {</p>
			<p class="source-code">      Greeting(name.value)</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">      Column(horizontalAlignment =</p>
			<p class="source-code">             Alignment.CenterHorizontally) {</p>
			<p class="source-code">        Welcome()</p>
			<p class="source-code">        TextAndButton(name, nameEntered)</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Have you noticed <strong class="source-inline">remember</strong> and <strong class="source-inline">mutableStateOf</strong>? Both are very important for creating <a id="_idIndexMarker016"/>and maintaining state. Generally speaking, state in an app refers to a value that can change over time. While this also applies to domain data (for example, the result of a web service call), state usually refers to something being displayed or used by a UI element. If a composable function has (or relies on) state, it is recomposed (for now, repainted or redrawn) when that state changes. To get an idea of what this means, recall this composable:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Welcome() {</p>
			<p class="source-code">    Text(</p>
			<p class="source-code">        text = stringResource(id = R.string.welcome),</p>
			<p class="source-code">        style = MaterialTheme.typography.subtitle1</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Welcome()</strong> is said <a id="_idIndexMarker017"/>to be stateless; all values that might trigger a recomposition remain the same for the time being. <strong class="source-inline">Hello()</strong>, on the other hand, is stateful, because it uses the <strong class="source-inline">name</strong> and <strong class="source-inline">nameEntered</strong> variables. They change over time. This may not be obvious if you look at the source code of <strong class="source-inline">Hello()</strong>. Please recall that both <strong class="source-inline">name</strong> and <strong class="source-inline">nameEntered</strong> are passed to <strong class="source-inline">TextAndButton()</strong> and modified there.</p>
			<p>Do you recall that in the previous section I promised to explain why <strong class="source-inline">name.value</strong> is used in two places, providing the text to display and receiving changes after the user has entered something? This is a common pattern often used with states; <strong class="source-inline">Hello()</strong> creates and remembers state by invoking <strong class="source-inline">mutableStateOf()</strong> and <strong class="source-inline">remember</strong>. And it passes state to another composable (<strong class="source-inline">TextAndButton()</strong>), which is <a id="_idIndexMarker018"/>called <strong class="bold">state hoisting</strong>. You will learn more about this in <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>.</p>
			<p>So far, you have seen the source code of quite a few composable functions but not their output. Android Studio has a very importa<a id="_idTextAnchor027"/>nt feature <a id="_idIndexMarker019"/>called <strong class="bold">Compose preview</strong>. It allows you to view a composable function without running the app. In the next section, I will show you how to use this feature.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor028"/>Using the preview</h1>
			<p>The upper-right corner of the Android Studio code editor<a id="_idIndexMarker020"/> contains three buttons, <strong class="bold">Code</strong>, <strong class="bold">Split</strong>, and <strong class="bold">Design</strong> (<em class="italic">Figure 1.2</em>):</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="Images/B17505_01_02.jpg" alt="Figure 1.2 – Compose preview (Split mode)&#13;&#10;" width="1136" height="286"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Compose preview (Split mode)</p>
			<p>They switch between the following different display modes:</p>
			<ul>
				<li>Code only</li>
				<li>Code and preview</li>
				<li>Preview only</li>
			</ul>
			<p>To use the Compose preview, your composable functions must contain an additional annotation, <strong class="source-inline">@Preview</strong>, which belongs to the <strong class="source-inline">androidx.compose.ui.tooling.preview</strong> package. This requires an implementation dependency to <strong class="source-inline">androidx.compose.ui:ui-tooling-preview</strong> in your <strong class="source-inline">build.gradle</strong> file.</p>
			<p>Unfortunately, if you try to add <strong class="source-inline">@Preview</strong> to <strong class="source-inline">Greeting()</strong>, you will see an error message like this:</p>
			<p class="source-code">Composable functions with non-default parameters are not supported in Preview unless they are annotated with @PreviewParameter.</p>
			<p>So, how can you preview composables that take parameters?</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor029"/>Preview parameters</h2>
			<p>The<a id="_idIndexMarker021"/> most obvious solution is a wrapper composable:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview</p>
			<p class="source-code">fun GreetingWrapper() {</p>
			<p class="source-code">  Greeting("Jetpack Compose")</p>
			<p class="source-code">}</p>
			<p>This means that you write another composable function that takes no parameters but invokes your existing one and provides the required parameter (in my example, a text). Depending on how many composable functions your source file contains, you might be creating quite a lot of boilerplate code. The wrappers don't add value besides enabling the preview.</p>
			<p>Fortunately, there are other options. You can, for example, add default values to your composable:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun AltGreeting(name: String = "Jetpack Compose") {</p>
			<p>While this looks less hacky, it alters how your composable functions can be invoked (that is, without passing a parameter). This may not be desirable if you had a reason for not defining a default value in the first place.</p>
			<p>With <strong class="source-inline">@PreviewParameter</strong>, you can pass values to a composable that affect only the preview. Unfortunately, this is a little verbose, though, because you need to write a new class: </p>
			<p class="source-code">class HelloProvider : PreviewParameterProvider&lt;String&gt; {</p>
			<p class="source-code">  override val values: Sequence&lt;String&gt;</p>
			<p class="source-code">    get() = listOf("PreviewParameterProvider").asSequence()</p>
			<p class="source-code">}</p>
			<p>The class must extend <strong class="source-inline">androidx.compose.ui.tooling.preview.PreviewParameterProvider</strong> because it will provide a parameter for the preview. Now, you can annotate the parameter of the composable with <strong class="source-inline">@PreviewParameter</strong> and pass your new class:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview</p>
			<p class="source-code">fun AltGreeting2(@PreviewParameter(HelloProvider::class)</p>
			<p class="source-code">        name: String) {</p>
			<p>In a way, you <a id="_idIndexMarker022"/>are creating boilerplate code, too. So, which method you choose in the end is a matter of personal taste. The <strong class="source-inline">@Preview</strong> annotation can receive quite a few parameters. They modify the visual appearance of the preview. Let's explore some of them.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>Configuring previews</h2>
			<p>You can<a id="_idIndexMarker023"/> set a background color for a preview using <strong class="source-inline">backgroundColor =</strong>. The value is a <strong class="source-inline">Long</strong> type and represents an ARGB color. Please make sure to also set <strong class="source-inline">showBackground</strong> to <strong class="source-inline">true</strong>. The following snippet will produce a solid red background:</p>
			<p class="source-code">@Preview(showBackground = true, backgroundColor =</p>
			<p class="source-code">         0xffff0000)</p>
			<p>By default, preview dimensions are chosen automatically. If you want to set them explicitly, you can pass <strong class="source-inline">heightDp</strong> and <strong class="source-inline">widthDp</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview(widthDp = 100, heightDp = 100)</p>
			<p class="source-code">fun Welcome() {</p>
			<p class="source-code">  Text(</p>
			<p class="source-code">    text = stringResource(id = R.string.welcome),</p>
			<p class="source-code">    style = MaterialTheme.typography.subtitle1</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p><em class="italic">Figure 1.3</em> shows the result. Both values are interpreted as density-independent pixels, so you don't need to add <strong class="source-inline">.dp</strong> as you would do inside your composable function.</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="Images/B17505_01_03.jpg" alt="Figure 1.3 – Setting the width and height of a preview&#13;&#10;" width="262" height="281"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Setting the width and height of a preview</p>
			<p>To test<a id="_idIndexMarker024"/> different user locales, you can add the <strong class="source-inline">locale</strong> parameter. If, for example, your app contains German strings inside <strong class="source-inline">values-de-rDE</strong>, you can use them by adding the following:</p>
			<p class="source-code">@Preview(locale = "de-rDE")</p>
			<p>The string matches the directory name after <strong class="source-inline">values-</strong>. Please recall that the directory is created by Android Studio if you add a language in the Translations Editor.</p>
			<p>If you want to display the status and action bars, you can achieve this with <strong class="source-inline">showSystemUi</strong>:</p>
			<p class="source-code">@Preview(showSystemUi = true)</p>
			<p>To get an idea of how your composables react to different form factors, aspect ratios, and pixel densities, you can utilize the <strong class="source-inline">device</strong> parameter. It takes a string. Pass one of the values from <strong class="source-inline">Devices</strong>, for example, <strong class="source-inline">Devices.PIXEL_C</strong> or <strong class="source-inline">Devices.AUTOMOTIVE_1024p</strong>.</p>
			<p>In this section, you have seen how to configure a preview. Next, I will introduce you to preview groups. They are very handy if your source code file contains more than a few composable functions that you want to preview.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor031"/>Grouping previews</h2>
			<p>Android Studio <a id="_idIndexMarker025"/>shows composable functions with a <strong class="source-inline">@Preview</strong> annotation in the order of their appearance in the source code. You can choose between <strong class="bold">Vertical Layout</strong> and <strong class="bold">Grid Layout</strong> (<em class="italic">Figure 1.4</em>):</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="Images/B17505_01_04.jpg" alt="Figure 1.4 – Switching between Vertical Layout and Grid Layout&#13;&#10;" width="199" height="77"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Switching between Vertical Layout and Grid Layout</p>
			<p>Depending on the number of your composables, the preview pane may at some point feel crowded. If this is the case, just put your composables into different groups by adding a <strong class="source-inline">group</strong> parameter:</p>
			<p class="source-code">@Preview(group = "my-group-1")</p>
			<p>You can then show either all composable functions or just those that belong to a particular group (<em class="italic">Figure 1.5</em>):</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="Images/B17505_01_05.jpg" alt="Figure 1.5 – Switching between groups&#13;&#10;" width="145" height="82"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Switching between groups</p>
			<p>So far, I have shown you what the source code of composable functions looks like and how you can preview them inside Android Studio. In the next section, we will execute a composable on the Android Emulator or a real device, and you will learn how to connect composable functions to the other parts of an app. But before that, here is one more tip:</p>
			<p class="callout-heading">Export a Preview as an Image</p>
			<p class="callout">If you click on a <a id="_idIndexMarker026"/>Compose preview with the secondary mouse button, you will see a small pop-up menu. Select <strong class="bold">Copy Image</strong> to put a bitmap of the preview on the system clipboard. Most graphics applications allow you to paste it into a new document.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor032"/>Running a Compose app</h1>
			<p>If you <a id="_idIndexMarker027"/>want to see how a composable function looks and feels on the Android Emulator or a real device, you have two options:</p>
			<ul>
				<li>Deploying a composable function</li>
				<li>Running the app</li>
			</ul>
			<p>The first option is useful if you want to focus on a particular composable rather than the whole app. Also, the time needed to deploy a composable may be significantly shorter than deploying a complete app (depending on the app size). So, let's start with this one.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor033"/>Deploying a composable function</h2>
			<p>To deploy a<a id="_idIndexMarker028"/> composable function to a real device or the Android Emulator, click on the <strong class="bold">Deploy Preview</strong> button, which is a small image in the upper-right corner of a p<a id="_idTextAnchor034"/>review (<em class="italic">Figure 1.6</em>):</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="Images/B17505_01_06.jpg" alt="Figure 1.6 – Deploying a composable function&#13;&#10;" width="626" height="156"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Deploying a composable function</p>
			<p>This will automatically create new launch configurations (<em class="italic">Figure 1.7</em>):</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="Images/B17505_01_07.jpg" alt="Figure 1.7 – Launch configurations representing Compose previews&#13;&#10;" width="906" height="410"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Launch configurations representing Compose previews</p>
			<p>You can<a id="_idIndexMarker029"/> modify or delete Compose preview configurations in the <strong class="bold">Run/Debug Configurations</strong> dialog. To access them, open the <strong class="bold">Compose Preview</strong> node. Then you can, for example, change its name or deny parallel runs by unchecking <strong class="bold">Allow parallel run</strong>.</p>
			<p>The goal of this chapter is to deploy and run your first Compose app on a real device or the Android Emulator. You are almost there; in the next section, I will show you how to embed composable functions in an activity, which is a prerequisite. You will finally be running the app in the <em class="italic">Pressing the play button</em> section.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor035"/>Using composable functions in activities</h2>
			<p><strong class="bold">Activities</strong> have<a id="_idIndexMarker030"/> been <a id="_idIndexMarker031"/>one of the basic building blocks of Android apps since the first platform version. Practically every app has at least one activity. They are configured in the manifest file. To launch an activity from the home screen, the corresponding entry looks like this:</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;activity</p>
			<p class="source-code">  android:name=".MainActivity"</p>
			<p class="source-code">  android:exported="true"</p>
			<p class="source-code">  android:label="@string/app_name"&gt;</p>
			<p class="source-code">  &lt;intent-filter&gt;</p>
			<p class="source-code">    &lt;action android:name="android.intent.action.MAIN" /&gt;</p>
			<p class="source-code">    &lt;category</p>
			<p class="source-code">     android:name="android.intent.category.LAUNCHER" /&gt;</p>
			<p class="source-code">  &lt;/intent-filter&gt;</p>
			<p class="source-code">&lt;/activity&gt;</p>
			<p class="source-code">...</p>
			<p>This <a id="_idIndexMarker032"/>is still true for Compose apps. An activity that wishes to show composable functions is set up just like one that <a id="_idIndexMarker033"/>inflates a traditional layout file. But what does its source code look like? The main activity of the <strong class="source-inline">Hello</strong> app is called <strong class="source-inline">MainActivity</strong>, shown in the next code block:</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">    super.onCreate(savedInstanceState)</p>
			<p class="source-code">    setContent {</p>
			<p class="source-code">      Hello()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As you can see, it is very short. The UI (the <strong class="source-inline">Hello()</strong> composable function) is displayed by invoking a function called <strong class="source-inline">setContent</strong>, which is an extension function to <strong class="source-inline">androidx.activity.ComponentActivity</strong> and belongs to the <strong class="source-inline">androidx.activity.compose</strong> package.</p>
			<p>To<a id="_idIndexMarker034"/> render composables, your <a id="_idIndexMarker035"/>activity must extend either <strong class="source-inline">ComponentActivity</strong> or another class that has <strong class="source-inline">ComponentActivity</strong> as its direct or indirect ancestor. This is the case for <strong class="source-inline">androidx.fragment.app.FragmentActivity</strong> and <strong class="source-inline">androidx.appcompat.app.AppCompatActivity</strong>.</p>
			<p>This is an important difference; while Compose apps invoke <strong class="source-inline">setContent()</strong>, View-based apps call <strong class="source-inline">setContentView()</strong> and pass either the ID of a layout (<strong class="source-inline">R.layout.</strong><strong class="source-inline">activity_main</strong>) or the root view itself (which is usually obtained through some binding mechanism). Let's see how the older mechanism works. The following code snippet is taken from one of my open source apps (you can find it on GitHub at <a href="https://github.com/MATHEMA-GmbH/TKWeek">https://github.com/MATHEMA-GmbH/TKWeek</a> but it won't be discussed any further in this book):</p>
			<p class="source-code">class TKWeekActivity : TKWeekBaseActivity() {</p>
			<p class="source-code">  private var backing: TkweekBinding? = null</p>
			<p class="source-code">  private val binding get() = backing!!</p>
			<p class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">    super.onCreate(savedInstanceState)</p>
			<p class="source-code">    backing = TkweekBinding.inflate(layoutInflater, null,</p>
			<p class="source-code">              false)</p>
			<p class="source-code">    setContentView(binding.root)</p>
			<p class="source-code">    ...</p>
			<p>If you compare both approaches, a striking difference is that with Jetpack Compose, there is no need for maintaining references to the UI component tree or individual elements of it. I will explain in <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, why this leads to code that is easily maintainable and less error-prone.</p>
			<p>Let's now return to <strong class="source-inline">setContent()</strong>. It receives two parameters, a <strong class="source-inline">parent</strong> (which can be <strong class="source-inline">null</strong>) and the <strong class="source-inline">content</strong> (the UI). The <strong class="source-inline">parent</strong> is an instance of <strong class="source-inline">androidx.compose.runtime.CompositionContext</strong>. It is used to logically link together two<a id="_idIndexMarker036"/> compositions. This<a id="_idIndexMarker037"/> is an advanced topic that I will be discussing in <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Have you noticed that <strong class="source-inline">MainActivity</strong> does not contain any composable functions? They do not need to be part of a class. In fact, you should implement them as top-level functions whenever possible. Jetpack Compose provides alternative means to access <strong class="source-inline">android.content.Context</strong>. You have already seen the <strong class="source-inline">stringResource()</strong> composable function, which is a replacement for <strong class="source-inline">getString()</strong>.</p>
			<p>Now that you have seen how to embed composable functions in activities, it is time to look at the structure of Jetpack Compose-based projects. While Android Studio sets everything up for you if you create a Compose app using the project wizard, it is important to know which files are involved under the hood.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor036"/>Looking under the hood</h2>
			<p>Jetpack Compose <a id="_idIndexMarker038"/>heavily relies on Kotlin. This means that your app project must be configured to use Kotlin. It does not imply, though, that you cannot use Java at all. In fact, you can easily mix Kotlin and Java in your project, as long as your composable functions are written in Kotlin. You can also combine traditional views and composables. I will be discussing this topic in <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>.</p>
			<p>First, make sure to configure the Android Gradle plugin that corresponds to your version of Android Studio in the project-level build.gradle file:</p>
			<p class="source-code">buildscript {</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  dependencies {</p>
			<p class="source-code">    classpath "com.android.tools.build:gradle:7.0.4"</p>
			<p class="source-code">    classpath "org.jetbrains.kotlin:kotlin-gradle-               plugin:1.5.31"</p>
			<p class="source-code">    ...</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The following code snippets belong in the module-level build.gradle file:</p>
			<p class="source-code">plugins {</p>
			<p class="source-code">    id 'com.android.application'</p>
			<p class="source-code">    id 'kotlin-android'</p>
			<p class="source-code">}</p>
			<p>Next, please <a id="_idIndexMarker039"/>make sure that your app's minimum API level is set to 21 or higher and that Jetpack Compose is enabled. The following code snippet also sets the version for the Kotlin compiler plugin:</p>
			<p class="source-code">android {</p>
			<p class="source-code">  defaultConfig {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    minSdkVersion 21</p>
			<p class="source-code">  }</p>
			<p class="source-code">  buildFeatures {</p>
			<p class="source-code">    compose true</p>
			<p class="source-code">  }</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  compileOptions {</p>
			<p class="source-code">    sourceCompatibility JavaVersion.VERSION_11</p>
			<p class="source-code">    targetCompatibility JavaVersion.VERSION_11</p>
			<p class="source-code">  }</p>
			<p class="source-code">  kotlinOptions {</p>
			<p class="source-code">    jvmTarget = "11"</p>
			<p class="source-code">  }</p>
			<p class="source-code">  composeOptions {</p>
			<p class="source-code">    kotlinCompilerExtensionVersion compose_version</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Finally, declare<a id="_idIndexMarker040"/> dependencies. The following code snippet acts as a good starting point. Depending on which packages your app uses, you may need additional ones:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    implementation 'androidx.core:core-ktx:1.7.0'</p>
			<p class="source-code">    implementation 'androidx.appcompat:appcompat:1.4.0'</p>
			<p class="source-code">    Implementation</p>
			<p class="source-code">      "androidx.compose.ui:ui:$compose_version"</p>
			<p class="source-code">    implementation</p>
			<p class="source-code">      "androidx.compose.material:material:$compose_version"</p>
			<p class="source-code">    implementation</p>
			<p class="source-code">      "androidx.compose.ui:ui-tooling-</p>
			<p class="source-code">       preview:$compose_version"</p>
			<p class="source-code">    implementation</p>
			<p class="source-code">      'androidx.lifecycle:lifecycle-runtime-ktx:2.4.0'</p>
			<p class="source-code">    implementation</p>
			<p class="source-code">      'androidx.activity:activity-compose:1.4.0'</p>
			<p class="source-code">    debugImplementation</p>
			<p class="source-code">      "androidx.compose.ui:ui-tooling:$compose_version"</p>
			<p class="source-code">}</p>
			<p>Once you have configured your project, building and running a Compose app works just like traditional view-based apps.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor037"/>Pressing the play button</h2>
			<p>To run your <a id="_idIndexMarker041"/>Compose app, select your target device, make sure that the <strong class="bold">app</strong> module is selected, and press the green <em class="italic">play</em> button (<em class="italic">Figure 1.8</em>):</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="Images/B17505_01_08.jpg" alt="Figure 1.8 – Android Studio toolbar elements to launch an app&#13;&#10;" width="580" height="36"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Android Studio toolbar elements to launch an app</p>
			<p>Congratulations! Well done. You have now launched your first Compose app, and you have achieved quite a lot. Let's recap.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor038"/>Summary</h1>
			<p>In this chapter, we learned how to write our first composables: Kotlin functions that have been annotated with <strong class="source-inline">@Composable</strong>. Composable functions are the core building blocks of Jetpack Compose-based UIs. You combined existing library composables with your own to create beautiful app screens. To see a preview, we can add the <strong class="source-inline">@Preview</strong> annotation. To use Jetpack Compose in a project, both <strong class="source-inline">build.gradle</strong> files must be configured accordingly.</p>
			<p>In <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, we will take a closer look at the differences between the declarative approach of Jetpack Compose and the imperative nature of traditional UI frameworks such as Android's view-based component library.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor039"/>Further reading</h1>
			<p>This book assumes you have a basic understanding of the syntax of Kotlin and Android development in general. If you would like to learn more about this, I suggest looking at <em class="italic">Android Programming with Kotlin for Beginners</em>, <em class="italic">John Horton</em>, <em class="italic">Packt Publishing</em>, <em class="italic">2019</em>, <em class="italic">ISBN 9781789615401</em>.</p>
		</div>
	</div></body></html>