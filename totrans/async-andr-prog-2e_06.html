<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Scheduling Work with AlarmManager</h1></div></div></div><p>Maintaining the responsiveness of foreground apps has been our primary focus throughout this book, and we've explored numerous ways to shift work away from the main thread and run work in the background.</p><p>In all of our discussions so far, we wanted to get the work done as soon as possible, so although we moved it to a background thread, we still performed the work concurrently with ongoing main thread operations, such as updating the user interface and responding to user interaction.</p><p>In this chapter we will learn how to defer work with <code class="literal">AlarmManager</code> to run at some distant time in the future, initiating work without user intervention, and even waking up the device from an idle state if it is really necessary. Meanwhile, we will introduce you to some power saving features introduced with Android Marshmallow 6 and explain how to adapt your application to this new paradigm.</p><p>In this chapter we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scheduling alarms with AlarmManager</li><li class="listitem" style="list-style-type: disc">Canceling alarms</li><li class="listitem" style="list-style-type: disc">Scheduling repeating alarms</li><li class="listitem" style="list-style-type: disc">Scheduling alarms in Doze Mode</li><li class="listitem" style="list-style-type: disc">Setting up an alarm clock</li><li class="listitem" style="list-style-type: disc">Debugging AlarmManager alarms</li><li class="listitem" style="list-style-type: disc">Handling alarms with Activities</li><li class="listitem" style="list-style-type: disc">Handling alarms with BroadcastReceivers</li><li class="listitem" style="list-style-type: disc">Staying awake with WakeLocks</li><li class="listitem" style="list-style-type: disc">Restoring alarms on system boot</li><li class="listitem" style="list-style-type: disc">Applications of AlarmManager</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Introducing AlarmManager</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Performing Work with Looper, Handler, and HandlerThread">Chapter 2</a>, <em>Performing Work with Looper, Handler, and HandlerThread,</em> we learned how to schedule <a id="id341" class="indexterm"/>work on a <code class="literal">HandlerThread</code> using <code class="literal">postDelayed</code>, <code class="literal">postAtTime</code>, <code class="literal">sendMessageDelayed</code>, and <code class="literal">sendMessageAtTime</code>. These mechanisms are fine for short-term scheduling of work while our application is running in the foreground.</p><p>However, if we want to schedule an operation to run at some point in the distant future, we'll run into problems. First, our application may be terminated before that time arrives, removing any chance of the Handler running those scheduled operations. Second, the device may be asleep, and with its CPU powered down it cannot run our scheduled tasks.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>The solution to this is to use an alternative scheduling approach, one that is designed to overcome these problems: <code class="literal">AlarmManager</code>.</p></div></div><p>
<code class="literal">android.app.AlarmManager</code> is a class that has been available in the Android SDK since the first version, delivering an advanced API to fire off Intents in the future at one specific time or time window defined by the user. The schedules are managed by the Android system, taking into account the device power cycles and states to keep energy consumption at a low level.</p><p>Moreover, <code class="literal">AlarmManager</code> is a system service that provides scheduling capabilities far beyond those of Handler. Being a system service, AlarmManager cannot be terminated and has the capacity, under certain conditions, to wake the device from sleep to deliver scheduled alarms.</p><p>The leading <a id="id342" class="indexterm"/>features of <code class="literal">android.app.AlarmManager</code> are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Ability to wake up the device from idle states</strong>: The user is able to control how the system should handle your alarm when it is in energy saving mode</li><li class="listitem" style="list-style-type: disc"><strong>Cancel Alarms</strong>: a mechanism to cancel a previously created alarm based on Intent comparison</li><li class="listitem" style="list-style-type: disc"><strong>Update Alarms</strong>: a mechanism to update an existing scheduled alarm</li><li class="listitem" style="list-style-type: disc"><strong>Exact and Inexact Alarms</strong>: an API that is able to control the exactness of our scheduling</li><li class="listitem" style="list-style-type: disc"><strong>Scheduling managed by the Android system</strong>: The alarms will fire even when your <a id="id343" class="indexterm"/>application is not running, and without consuming any application resources to manage the timers</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Scheduling alarms with AlarmManager</h1></div></div></div><p>As we said before, all <a id="id344" class="indexterm"/>the alarm operations are <a id="id345" class="indexterm"/>managed through the singleton object <code class="literal">AlarmManager</code>, an Android global system service that can be retrieved by any class with access to a <code class="literal">Context</code> instance. As an example, in an <code class="literal">Activity</code> we can get the <code class="literal">AlarmManager</code> from any member method by using the following code:</p><div><pre class="programlisting">AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);</pre></div><p>Once we have a reference to the <code class="literal">AlarmManager</code>, we can schedule an alarm to deliver a <code class="literal">PendingIntent</code> object to a <code class="literal">Service</code>, an <code class="literal">Activity</code> or <code class="literal">BroadcastReceiver</code>, at a time of our choosing. The simplest way to do that is using the <code class="literal">set</code> method:</p><div><pre class="programlisting">void set(int type, long triggerAtMillis, PendingIntent operation)</pre></div><p>When we set an alarm, we must also specify a <code class="literal">type</code> flag—the first parameter to the <code class="literal">set</code> method. The <code class="literal">type</code> flag sets the conditions under which the alarm should fire and which clock to use for our schedule.</p><p>There are two conditions and two clocks, resulting in four possible <code class="literal">type</code> settings.</p><p>The first condition specifies whether or not the device will be woken up if it is in a sleeping state at the time of the scheduled alarm—whether the alarm is a <code class="literal">wakeup</code> alarm or not.</p><p>The clocks provide a reference time against which we set our schedules, defining exactly what we mean when we set a value to <code class="literal">triggerAtMillis</code>. We could base our schedules on the following time references:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The elapsed-time system clock—<code class="literal">android.os.SystemClock</code>—measures time as the number of milliseconds that have passed since the device booted, including any time spent in deep sleep. The current time according to the system clock can be found using this code term:<div><pre class="programlisting">SystemClock.elapsedRealtime()</pre></div></li><li class="listitem" style="list-style-type: disc">The real-time clock (Unix Time) - measures time in milliseconds since the Unix epoch. The current time according to the real-time clock can be found as follows:<div><pre class="programlisting">System.currentTimeMillis()</pre></div></li></ul></div><div><div><h3 class="title"><a id="note39"/>Note</h3><p>In Java, <code class="literal">System.currentTimeMillis()</code> returns the number of milliseconds since midnight on January 1, 1970, Coordinated Universal Time (UTC)—a point in time known as the Unix epoch.</p><p>UTC is the internationally recognized successor to <strong>Greenwich Mean Time</strong> (<strong>GMT</strong>) and <a id="id346" class="indexterm"/>forms the basis for expressing international time zones, which are typically defined as positive or negative offsets from UTC.</p></div></div><p>Given these two <a id="id347" class="indexterm"/>conditions and two clocks, these are the four possible <a id="id348" class="indexterm"/><code class="literal">type</code> values we can use when setting alarms:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.AlarmManager.ELAPSED_REALTIME</code>: This schedules the alarm relative to the system clock. If the device is asleep at the scheduled time it will not be delivered immediately; instead, the alarm will be delivered the next time the device wakes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.AlarmManager.ELAPSED_REALTIME_WAKEUP</code>: This schedules the alarm relative to the system clock. If the device is asleep, it will be woken to deliver the alarm at the scheduled time.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.AlarmManager.RTC</code>: This schedules the alarm in UTC relative to the Unix epoch. If the device is asleep at the scheduled time, the alarm will be delivered when the device is next woken.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.AlarmManager.RTC_WAKEUP</code>: This schedules the alarm relative to the Unix epoch. If the device is asleep it will be awoken, and the alarm is delivered at the scheduled time.</li></ul></div><p>We will start setting an alarm at a particular time, to go off 24 hours after the initial boot. We'll use the <code class="literal">TimeUnit</code> class from the <code class="literal">java.lang.concurrent</code> package to calculate times in milliseconds. To set the previous alarm, we need to calculate the number of milliseconds in 24 hours, as shown in the following code:</p><div><pre class="programlisting">long delay = TimeUnit.HOURS.toMillis(24L);
am.set(AlarmManager.ELAPSED_REALTIME, delay, pending);</pre></div><p>We can set an alarm to go off five minutes from now, using the system time, by adding five minutes to the current time. Using the system clock, it looks like this:</p><div><pre class="programlisting">long delay = TimeUnit.MINUTES.toMillis(5L);
long time = System.currentTimeMillis() + delay;
am.set(AlarmManager.RTC, time, pending);</pre></div><p>To set an alarm for 9:00 pm today (or tomorrow, if it's already past 9:00 pm today), we can use the <a id="id349" class="indexterm"/><code class="literal">Calendar</code> class to do some time <a id="id350" class="indexterm"/>calculations:</p><div><pre class="programlisting">Calendar calendar = Calendar.getInstance();
// Tomorrow at 9 if already passed 9pm today
if (calendar.get(Calendar.HOUR_OF_DAY) &gt;= 21) {
    calendar.add(Calendar.DATE, 1);
}
calendar.set(Calendar.HOUR_OF_DAY, 21);
calendar.set(Calendar.MINUTE, 0);
calendar.set(Calendar.SECOND, 0);
am.set(AlarmManager.RTC, calendar.getTimeInMillis(), pending);</pre></div><p>None of the examples so far will wake the device if it is sleeping at the time of the alarm. To do that, we need to use one of the <code class="literal">WAKEUP</code> alarm conditions, for example:</p><div><pre class="programlisting">am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, delay, pending);
am.set(AlarmManager.RTC_WAKEUP, time, pending);</pre></div><p>It is also important to understand that when the alarm clock time is in the past, the alarm will sound immediately after we invoke the <code class="literal">AlarmManager</code> set alarm functions.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Setting alarms in recent Android versions</h2></div></div></div><p>If our <a id="id351" class="indexterm"/>application targets an API level below 19 (KitKat), scheduled alarms will run exactly at the alarm time. For applications targeting KitKat or later, the schedule is considered inexact and the system may re-order or group alarms to minimize wake-ups and save battery.</p><p>After API Level 23, the Android Development team went a little further and Doze mode was introduced on the Android System to reduce battery consumption when the device is unplugged from the power adapter, motionless, and not used by the user for a long period of time.</p><p>The Doze system will try to decrease the device's wake-up frequency deferring background jobs, network updates, syncs, and our precious alarm until the device exits Doze mode or a recurring maintenance window runs to execute pending jobs, certain alarms, or synchronization with the network. After the maintenance window finishes, the device would enter Doze mode again if it was not used in the meantime:</p><div><img src="img/Image_B05062_06_02.jpg" alt="Setting alarms in recent Android versions"/><div><p>Figure 6.1: Doze Mode Timeline</p></div></div><p>Doze mode is <a id="id352" class="indexterm"/>likely to impact your application and will defer your alarms until a maintenance window comes in, unless you use the methods <code class="literal">setAndAllowWhileIdle()</code> and <code class="literal">setExactAndAllowWhileIdle()</code> to allow the execution of your alarms in a deep idle state.</p><p>Moreover, the number of times that the Doze Mode maintenance window runs will be less frequent in cases of long-term inactivity, so the impact of this new mechanism on our scheduling will increase, hence causing more unpredictable jitters at the alarm time.</p><p>During the doze mode the applications are also not allowed to access the network, the WakeLocks are ignored and Wi-Fi scans are not executed.</p><p>If we need precision scheduling and you are targeting Marshmallow or later, we shall use the new <code class="literal">setExactAndAllowWhileIdle()</code> method introduced at API level 23:</p><div><pre class="programlisting">am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pending);</pre></div><div><div><h3 class="title"><a id="note40"/>Note</h3><p>The Android system has protection that prevents abuse for exact alarms that fire off too frequently. <code class="literal">AlarmManager</code> only wakes up the device and dispatches one alarm per minute, and in low power mode it can be as low as one every 15 mins.</p></div></div><p>If your application targets a version between KitKat (API Level 19) and Marshmallow (API Level 23), the <code class="literal">setExact</code> method is enough for timing precision:</p><div><pre class="programlisting">am.setExact(AlarmManager.RTC_WAKEUP, time, pending);</pre></div><p>But we'll need to check that the methods exist before we try to call it; otherwise, our app will crash when run under earlier API levels. Lets sketch out our new exact alarm code:</p><div><pre class="programlisting">if (Build.VERSION.SDK_INT &gt;= 23) {
  // Wakes up the device in Doze Mode
  am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pending);
} else if (Build.VERSION.SDK_INT &gt;= 19) {
  // Wakes up the device in Idle Mode
  am.setExact(AlarmManager.RTC_WAKEUP, time, pending);
} else {
  // Old APIs
  am.set(AlarmManager.RTC_WAKEUP, time, pending);
}</pre></div><p>This will deliver our alarm at exactly the specified time on all platforms.</p><p>Don't forget that you should only use exact scheduling when you really need it, for example, to deliver <a id="id353" class="indexterm"/>alerts to the user at a specific time. For most other cases, allowing the system to adjust our schedule a little to preserve battery life is usually acceptable.</p><p>Android Marshmallow API Level 23 also comes with the <code class="literal">setAndAllowWhileIdle</code> function, which allows us to create an alarm to sound in Doze mode, but with less exactness compared to <code class="literal">setExactAndAllowWhileIdle()</code>.</p><p>The system will try to batch these kinds of alarm across the entire system, minimizing the number of times the device wakes up, and hence reducing the energy consumption of the system. Here is the code to create an alarm that triggers, even in Doze mode, 10 hours from now:</p><div><pre class="programlisting">long delay = TimeUnit.HOURS.toMillis(10L);
long time = System.currentTimeMillis() + delay;

if (Build.VERSION.SDK_INT &gt;= 23) {
     am.setAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pending);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Testing your alarms in Doze Mode</h2></div></div></div><p>In order to <a id="id354" class="indexterm"/>test your application's behavior in doze mode, the <a id="id355" class="indexterm"/>Android SDK team added some new commands to the dumpsys tool to manually change the device's power state from the command line.</p><p>It is also important to remember that Doze mode requires that your device is unplugged from the charger. To force the device to a state where it is disconnected from the charger, we should run the following command on a command line with access to SDK Tools:</p><div><pre class="programlisting"># Emulate a charger unplug
adb shell dumpsys battery unplug
# Emulate a charger plug in
adb shell dumpsys battery set ac 1</pre></div><p>Then, to enter idle mode, we should turn off the screen and run the following commands:</p><div><pre class="programlisting">// Enable the doze mode, step required on Android Emulator
adb shell dumpsys deviceidle enable
// To goes directly go IDLE mode
adb shell dumpsys deviceidle force-idle</pre></div><p>After the device is put in idle mode, we can enable the maintenance window by running the following command:</p><div><pre class="programlisting">// Goes from IDLE -&gt; IDLE_MAINTENANCE state
adb shell dumpsys deviceidle step</pre></div><p>If we run the same step again the device goes back to an idle state; however, if we want to go back to an active state, we should run the next command:</p><div><pre class="programlisting">// Goes from IDLE,IDLE_MAINTENANCE -&gt; ACTIVE state
adb shell dumpsys deviceidle disable</pre></div><p>With these handy commands we are able to verify that the alarm sounds even in deep idle states.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Setting a Window alarm</h2></div></div></div><p>One more addition in <a id="id356" class="indexterm"/>KitKat is <code class="literal">setWindow()</code>, which introduces a <a id="id357" class="indexterm"/>compromise between exact and inexact alarms by allowing us to specify the time window within which the alarm must be delivered. This still allows the system some freedom to play with the schedules for efficiency, but lets us <a id="id358" class="indexterm"/>choose just how much freedom to allow.</p><p>Here's how we would use <code class="literal">sentindo()</code> to schedule an alarm to be delivered within a 3 minute window—at the earliest 5 minutes from now and at the latest 8 minutes from now—using the <a id="id359" class="indexterm"/>real-time clock:</p><div><pre class="programlisting">if (Build.VERSION.SDK_INT &gt;= 19) {
  long delay = TimeUnit.MINUTES.toMillis(5L);
  long window = TimeUnit.MINUTES.toMillis(3L);
  long time = System.currentTimeMillis() + delay; 
  am.setWindow(AlarmManager.RTC_WAKEUP, time, window, pending);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Debugging AlarmManager alarms</h2></div></div></div><p>The Android <a id="id360" class="indexterm"/>System comes with a handy diagnostic tool <a id="id361" class="indexterm"/>that outputs to the developer a list of registered alarms on the device. To get a list, we run the following command from the command line:</p><div><pre class="programlisting">
<strong>adb shell dumpsys alarm</strong>
</pre></div><p>After we have created the exact 5 minute alarm on Android API Level 23, the system will output our registered alarm on the command output:</p><div><pre class="programlisting">...
Batch{bfce57 num=1 start=6199180 end=6199180 flgs=0x5}:
RTC_WAKEUP #0: Alarm{
 d38d44 type 0 when 1449181419460  
    com.packpublishing.asynchronousandroid}
 tag=*walarm*:my_alarm
 type=0 whenElapsed=+58s670ms when=2015-12-03 22:23:39
    window=0 repeatInterval=0 count=0 flags=0x5
    operation=PendingIntent{a58bbe0: PendingIntentRecord{
     466e99 android broadcastIntent}}</pre></div><p>The Alarm system tries to organize the alarm execution in batches for battery saving purposes, so in the first line we have information about the alarm batch that our alarm belongs to.</p><p>The details of the batch output format are shown in the following list:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bfce57</code>: Batch internal identifier number</li><li class="listitem" style="list-style-type: disc"><code class="literal">num=1</code>: Number of alarms in this batch</li><li class="listitem" style="list-style-type: disc"><code class="literal">start=6199180</code>: It refers to the time, in terms of elapsed milliseconds since system boot, at which the batch should be started</li><li class="listitem" style="list-style-type: disc"><code class="literal">end=6199180</code>: It refers to the time, in terms of elapsed milliseconds since system boot, at which the batch will end</li></ul></div><p>Inside the batch, our <a id="id362" class="indexterm"/>alarm gets detailed over the <a id="id363" class="indexterm"/>following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d38d44</code>: An internal identifier number used by the system</li><li class="listitem" style="list-style-type: disc"><code class="literal">type 0 (RTC_WAKEUP)</code>: Alarm type </li><li class="listitem" style="list-style-type: disc"><code class="literal">when</code>: Alarm time based on the clock time (milliseconds since epoch)</li><li class="listitem" style="list-style-type: disc"><code class="literal">tag=*walarm*:my_alarm</code>: Action specified on Intent</li><li class="listitem" style="list-style-type: disc"><code class="literal">com.packpublishing.asynchronousandroid</code>: Application package that created the alarm</li><li class="listitem" style="list-style-type: disc"><code class="literal">whenElapsed=+58s670ms</code>: Refers to the time since the system started at which this alarm will be triggered</li><li class="listitem" style="list-style-type: disc"><code class="literal">when= 2015-12-03 22:23:39</code>: The date/time at which this alarm will be triggered</li><li class="listitem" style="list-style-type: disc"><code class="literal">window= 180000</code>: Refers to the value specified in the window field when the <code class="literal">setWindow()</code> method is used</li><li class="listitem" style="list-style-type: disc"><code class="literal">repeatInterval=0</code>: Used in repeating alarms to specify the interval between repeats</li><li class="listitem" style="list-style-type: disc"><code class="literal">count=0</code>: Number of times the alarm sounded</li><li class="listitem" style="list-style-type: disc"><code class="literal">operation= PendingIntent...</code>: Pending intent that will be triggered</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Canceling alarms</h1></div></div></div><p>Once the alarm is <a id="id364" class="indexterm"/>set, it can be canceled very easily by invoking the <code class="literal">AlarmManger.cancel</code> method with an intent that matches the alarm that we want to cancel.</p><p>The process of matching uses the <code class="literal">filterEquals</code> method of Intent, which compares the action, data, type, class, component, package, and categories of both <code class="literal">Intent</code> to test for equivalence. Any extras we may have set in the Intent are not taken into account.</p><p>In the following code, we will show you how to create an alarm that fires off in 1 hour and the cancel code to dismiss it using different intent instances:</p><div><pre class="programlisting">// Function to set the Alarm
void set1HourAlarm(long time) {
  AlarmManager am= (AlarmManager) getSystemService(ALARM_SERVICE);
  long time = in1HourTime();
  am.set(AlarmManager.RTC, time, createPendingIntent(time));
}

// Cancel the alarm
void cancel1HourAlarm(long time) {
  AlarmManager am= (AlarmManager) getSystemService(ALARM_SERVICE);
  // Remove the alarms matching the Intent
  am.cancel(createPendingIntent(time));
}

// Creates the Pending Intent to set and cancel the alarm
PendingIntent createPendingIntent(long time) {
  Intent intent = new Intent("my_alarm");
  PendingIntent pending = PendingIntent.
    getBroadcast(this, ALARM_CODE, intent,
                 PendingIntent.FLAG_UPDATE_CURRENT);
  // extras don't affect matching
  intent.putExtra("exactTime", time);
  return pending;
}
// Calculate the Time
long in1HourTime() {
  long delay = TimeUnit.MINUTES.toMillis(5L);
  long time = System.currentTimeMillis() + delay;
  return time;
}</pre></div><p>Since in our example we <a id="id365" class="indexterm"/>use the same method to construct the set and cancel <code class="literal">PendingIntent</code>, both will have the same action and match, so if the <code class="literal">AlarmManager.cancel</code> runs and it finds a match, the Android system will remove the alarm previously set from the list of enabled alarms.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>To debug the cancellation of your alarm you could verify again with an <code class="literal">adb shell dumpsys</code> alarm that the alarm disappeared from the system alarm batches.</p></div></div><p>It is important to realize that whenever we create alarm using a pending intent with the <code class="literal">FLAG_UPDATE_CURRENT</code>, we <a id="id366" class="indexterm"/>implicitly update any existing alarm with the new Intent and its extras.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Scheduling repeating alarms</h1></div></div></div><p>As well as setting a <a id="id367" class="indexterm"/>one-off alarm, we have the option to schedule repeating alarms using <code class="literal">setRepeating()</code> and <code class="literal">setInexactRepeating()</code>. Both methods take an additional parameter that defines the interval in milliseconds at which to repeat the alarm.  Generally, it is advisable to avoid <code class="literal">setRepeating()</code> and always use <code class="literal">setInexactRepeating()</code>, allowing the system to optimize device wake-ups and giving more consistent behavior on devices running different Android versions:</p><div><pre class="programlisting">   void setRepeating(
       int type, long triggerAtMillis,
       long intervalMillis, PendingIntent operation);

   void setInexactRepeating(
       int type, long triggerAtMillis,
       long intervalMillis, PendingIntent operation)</pre></div><p>
<code class="literal">AlarmManager</code> provides some handy constants for typical repeat intervals:</p><div><pre class="programlisting">   AlarmManager.INTERVAL_FIFTEEN_MINUTES
   AlarmManager.INTERVAL_HALF_HOUR
   AlarmManager.INTERVAL_HOUR
   AlarmManager.INTERVAL_HALF_DAY
   AlarmManager.INTERVAL_DAY</pre></div><p>Let's now build up an example that creates a repeating alarm to be delivered approximately 2 hours from now, then repeating every 15 minutes or so thereafter like this:</p><div><pre class="programlisting">Intent intent = new Intent("my_alarm");
PendingIntent broadcast = PendingIntent.getBroadcast(
  this, 0, intent,PendingIntent.FLAG_UPDATE_CURRENT);
long start = System.currentTimeMillis() +
             TimeUnit.HOURS.toMillis(2L);
AlarmManager am = (AlarmManager)
                  getSystemService(ALARM_SERVICE);
am.setRepeating(
  AlarmManager.RTC_WAKEUP, start,
  AlarmManager.INTERVAL_FIFTEEN_MINUTES, broadcast);</pre></div><p>From API level 19, all repeating alarms are inexact—that is, if our application targets KitKat or above, our <a id="id368" class="indexterm"/>repeat alarms will be inexact even if we use <code class="literal">setRepeating()</code>. To have similar inexact behavior across all the Android versions you should use the <code class="literal">setInexactRepeating()</code>(API Level 3) rather than <code class="literal">setRepeating()</code>:</p><div><pre class="programlisting">am.setInexactRepeating(
  AlarmManager.RTC_WAKEUP, start,
  AlarmManager.INTERVAL_FIFTEEN_MINUTES, broadcast);</pre></div><p>The inexact repeating tells the system that your alarm time could be adjusted to reduce the device waking up frequently and increase the system's overall power efficiency.</p><p>If we really need exact repeat alarms, we can use <code class="literal">setExact()</code>/<code class="literal">setExactAndAllowWhileIdle()</code>, instead, and schedule the next alarm while handling the current one.</p><p>Later, we might increase the repeating alarm interval and even change the <code class="literal">Intent</code> Extras by calling the <code class="literal">setRepeating()</code> with an Intent that matches the previous Intent and the flag <code class="literal">FLAG_UPDATE_CURRENT</code>, as shown in the following code:</p><div><pre class="programlisting">Intent intent = new Intent("my_alarm");
PendingIntent broadcast = PendingIntent.getBroadcast(
  this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
// Updates the delivery intent extras
intent.putExtra("my_int",3);
am.setRepeating(
  AlarmManager.RTC_WAKEUP, System.currentTimeMillis(),
  AlarmManager.INTERVAL_HALF_HOUR, broadcast);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Scheduling an alarm clock</h1></div></div></div><p>From API <a id="id369" class="indexterm"/>Level 21, <code class="literal">setAlarmClock</code>, which sets a new alarm and displays a status bar alarm icon, was introduced in the <code class="literal">AlarmManager</code> class:</p><div><pre class="programlisting"> void setAlarmClock(AlarmClockInfo info, PendingIntent operation)</pre></div><p>In the next example we are going to create an alarm clock that goes off tomorrow at 10:00 pm:</p><div><pre class="programlisting">Intent intent = new Intent("my_clock_alarm");
Calendar calendar = Calendar.getInstance();
calendar.add(Calendar.DATE, 1);
calendar.set(Calendar.HOUR_OF_DAY, 22);
calendar.set(Calendar.MINUTE, 0);
calendar.set(Calendar.SECOND, 0);

PendingIntent broadcast = PendingIntent.getBroadcast(
                                   AlarmClockActivity.this, 0, intent, 
                                   PendingIntent.FLAG_UPDATE_CURRENT);

// Only applies to newer versions
If ( Build.VERSION.SDK_INT &gt;= 21 ) {

  AlarmClockInfo alarmInfo = new AlarmClockInfo(          
     calendar.getTimeInMillis(),    
     // Create a Pending intent to show Alarm Details
     createShowDetailsPI());
  am.setAlarmClock(alarmInfo, broadcast);

} else {

  am.set(AlarmManager.RTC_WAKEUP,
         calendar.getTimeInMillis(), broadcast);
}
...
PendingIntent createShowDetailsPI() {
    ntent showIntent = new Intent(AlarmClockActivity.this,
                                  ShowAlarmActivity.class);
    return PendingIntent.getActivity(AlarmClockActivity.this, 0,
                                     showIntent,                                                 
                                     PendingIntent.
                                       FLAG_UPDATE_CURRENT);
}</pre></div><p>If you are using a recent device, once we set the previous alarm we see the clock icon on the system status bar:</p><div><img src="img/Image_B05062_06_01.jpg" alt="Scheduling an alarm clock"/></div><p>To cancel the <a id="id370" class="indexterm"/>alarm clock, we have to invoke the <code class="literal">cancel</code> method with a matching intent:</p><div><pre class="programlisting">Intent intent = new Intent("my_clock_alarm");
PendingIntent broadcast = PendingIntent.getBroadcast(
  this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
am.cancel(broadcast);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Handling alarms</h1></div></div></div><p>So far we have learned <a id="id371" class="indexterm"/>how to schedule exact and inexact alarms over the <code class="literal">AlarmManager Service</code> singleton, so at this point we are ready to take a look at how to handle the alarm in any Android application component.</p><p>Essentially, we can schedule anything that can be started with a <code class="literal">PendingIntent</code>, which means we can use alarms to start Activities, Services, and <code class="literal">BroadcastReceivers</code>. To specify the target of our alarm, we need to use the static factory methods of <code class="literal">PendingIntent</code>:</p><div><pre class="programlisting">PendingIntent.getActivities(Context, int,Intent[],int)
PendingIntent.getActivity(Context,int, Intent, int)
PendingIntent.getService(Context,int, Intent, int)
PendingIntent.getBroadcast(Context,int, Intent, int)</pre></div><p>All static methods offered to create a pending intent, receiving as arguments a Context object, an integer request code to identify the pending intent, an Intent or an array of Intents that will be delivered to the component, and finally an integer to specify the <code class="literal">PendingIntent</code> flags.</p><p>The <code class="literal">PendingIntent</code> flags used on the factory method play an important role in Intent handling, so it is crucial to understand the flags that we can use to indicate how the system should process an intent that already exists, to make an Intent immutable or to set an intent that is only delivered once:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FLAG_CANCEL_CURRENT</code>: Indicates that the system should invalidate and generates a new Intent.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FLAG_NO_CREATE</code>: If the <code class="literal">PendingIntent</code> does not already exist, a new intent is not created and factory method returns <code class="literal">null</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FLAG_ONE_SHOT</code>: Indicates that the pending intent created can only be used once.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FLAG_UPDATE_CURRENT</code>: Indicates that if the pending intent already exists, the Pending Intent is replaced <a id="id372" class="indexterm"/>with this one, including all the extras.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FLAG_IMMUTABLE</code>: Indicates that the pending intent created cannot be modified afterwards. This flag is only available since API Level 23.</li></ul></div><p>In most cases we want to completely replace an existing Intent with a new one, so using <code class="literal">FLAG_UPDATE_CURRENT</code> is the right flag value to use.</p><p>In the following sections, we'll see build up examples for each type of <code class="literal">PendingIntent</code> that can be used with <code class="literal">AlarmManager</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Handling alarms with Activities</h1></div></div></div><p>Starting an <code class="literal">Activity</code> <a id="id373" class="indexterm"/>from an alarm is as simple as registering the alarm with a <code class="literal">PendingIntent</code> created by invoking the static <code class="literal">getActivity</code> method of <code class="literal">PendingIntent</code>.</p><p>When the alarm is <a id="id374" class="indexterm"/>delivered, the <code class="literal">Activity</code> will be started and brought to the foreground, displacing any app that was currently in use. Keep in mind that this is likely to surprise and perhaps annoy users!</p><p>When starting Activities with alarms, we will probably want to set <code class="literal">Intent.FLAG_ACTIVITY_CLEAR_TOP</code>; so that if the application is already running, and our target <code class="literal">Activity</code> is already on the back stack, the new intent will be delivered to the old <code class="literal">Activity</code> and all the other activities on top of it will be closed:</p><div><pre class="programlisting">   Intent intent = new Intent(context, HomeActivity.class);
   intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
   PendingIntent pending = PendingIntent.getActivity(
       Context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);</pre></div><p>Not all Activities are suited to being started with <code class="literal">getActivity</code>. We might need to start an <code class="literal">Activity</code> that normally appears deep within the app, where pressing back does not exit to the home screen, but returns to the next <code class="literal">Activity</code> on the back-stack.</p><p>Let's imagine a situation where we want to start an <code class="literal">Activity</code> that is going to display the details about the model, and we want have an <code class="literal">Activity</code> that lists the models on the backstack.</p><p>This is where <a id="id375" class="indexterm"/><code class="literal">getActivities</code> comes in. With <code class="literal">getActivities</code>, we <a id="id376" class="indexterm"/>can push more than one <code class="literal">Activity</code> onto the back-stack of the application, allowing us to populate the back-stack to create the desired navigation flow when the user presses "back". To do this, we create our <code class="literal">PendingIntent</code> by sending an array of Intents to <code class="literal">getActivities</code>:</p><div><pre class="programlisting">   Intent first = new Intent(context, ListActivity.class);
   Intent second = new Intent(context, DetailActivity.class);
   first.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);

   PendingIntent pending = PendingIntent.getActivities(
       context, 0,
       new Intent[]{first, second},
       PendingIntent.FLAG_UPDATE_CURRENT);</pre></div><p>The array of Intents specifies the <code class="literal">Activity</code> to launch, in order. The logical sequence of events when this alarm is delivered is as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">If the application is already running, any Activities on the back-stack above <code class="literal">ListActivity</code> are finished and removed, because we set the <code class="literal">Intent.FLAG_ACTIVITY_CLEAR_TOP</code> flag.</li><li class="listitem"><code class="literal">ListActivity</code> is (re)started.</li><li class="listitem"><code class="literal">DetailActivity</code> is started and placed on the back-stack above <code class="literal">ListActivity</code>. The <code class="literal">DetailActivity</code> becomes the foreground <code class="literal">Activity</code>.</li></ol></div><p>Handling alarms with <code class="literal">Activity</code> is good to know about, but is not a technique we will use often, since it is so intrusive. We are much more likely to want to handle alarms in the background, which we'll look at next.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Handling alarms with BroadcastReceiver</h1></div></div></div><p>We met <a id="id377" class="indexterm"/><code class="literal">BroadcastReceiver</code> already in <a class="link" href="ch05.html" title="Chapter 5. Interacting with Services">Chapter 5</a>, <em>Interacting with Services</em>, where we used it in an <code class="literal">Activity</code> to receive broadcasts from a <a id="id378" class="indexterm"/><code class="literal">Service</code>. In this section, we'll use <code class="literal">BroadcastReceiver</code> to handle alarms set on the <code class="literal">AlarmManager</code>.</p><p>
<code class="literal">BroadcastReceivers</code> can be registered and unregistered dynamically at runtime like we did in <a class="link" href="ch05.html" title="Chapter 5. Interacting with Services">Chapter 5</a>, <em>Interacting with Services</em>, with <code class="literal">Service</code>, or statically in the Android manifest file with a <code class="literal">&lt;receiver&gt;</code> element, and can receive alarms regardless of how they are registered.</p><p>It is more common to use a statically registered receiver for alarms, because these are known to the system and can be invoked by alarms to start an application if it is not currently running.</p><p>Let's implement a <a id="id379" class="indexterm"/>static defined <code class="literal">BroadcastReceiver</code> that is able to dispatch an SMS to a phone number when an alarm sounds. First we will define our <code class="literal">BroadcastReceiver</code> in the manifest file:</p><div><pre class="programlisting">&lt;receiver android:name=".chapter6.SMSDispacther"&gt;
  &lt;intent-filter&gt;
    &lt;action android:name="sms_dispacther"/&gt;
  &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre></div><p>The <code class="literal">&lt;intent-filter&gt;</code> element gives us the opportunity to say which Intents we want to receive by specifying the action, data, and categories that should match.</p><p>Now its time to write the code to set up the schedule. To do that, we will create an Activity that is going to provide a form to set the destination number, the number of hours to defer the message dispatch, and the message text to send.</p><p>On the <code class="literal">SMSDispatchActivity</code> activity we will build a <code class="literal">PendingIntent</code> for the <code class="literal">sms_dispatcher</code> action, passing the arguments required over the Intent extras:</p><div><pre class="programlisting">public class SMSDispatchActivity extends Activity {
  // UI Code omitted for brevity
  …
  private OnClickListener mSubmit = new OnClickListener() {
    ...
    // Calculate the scheduled time
    // time = now + N*hours
    long delay = TimeUnit.HOURS.toMillis(hours);
    long time = System.currentTimeMillis() + delay;
   
    // Store the UI Form on the Intent
    intent.putExtra(SMSDispatcher.TO_KEY, phoneMumber);
    intent.putExtra(SMSDispatcher.TEXT_KEY, text);

    // Create the Broadcast Pending Intent
    PendingIntent broadcast = PendingIntent.getBroadcast(
      getBaseContext(), 0, intent,
      PendingIntent.FLAG_UPDATE_CURRENT);  
   
    // Set an exact Alarm
    if (Build.VERSION.SDK_INT &gt;= 23) {
      am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time,
                                   broadcast);
    } else if (Build.VERSION.SDK_INT &gt;= 19) {
      am.setExact(AlarmManager.RTC_WAKEUP, time, broadcast);
    } else {
      am.set(AlarmManager.RTC_WAKEUP, time, broadcast);
    }
  }
}</pre></div><p>When this alarm is due, <code class="literal">AlarmManager</code> will wake the device even in deep idle states—if it isn't <a id="id380" class="indexterm"/>already awake—and deliver the Intent to <a id="id381" class="indexterm"/>the <code class="literal">BroadcastReceiver</code> is <code class="literal">onReceive</code> method. The Alarm Manager will hold a wake lock as long as the alarm receiver's <code class="literal">onReceive()</code> runs. Therefore, it guarantees that the device will remain awake at least until <code class="literal">onReceive</code> completes, which means we can be sure of getting some work done before the device will be allowed to return to sleep.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Working with BroadcastReceiver</h2></div></div></div><p>When the system <a id="id382" class="indexterm"/>delivers an alarm to our <code class="literal">BroadcastReceiver</code> it does so on the main thread, so the usual main thread limitations apply; we cannot perform networking and we should not perform heavy processing or use blocking operations.</p><p>In addition, a statically registered <code class="literal">BroadcastReceiver</code> has a very limited lifecycle. It cannot create user interface elements other than toasts or notifications posted via <code class="literal">NotificationManager</code>, the <code class="literal">onReceive</code> method must complete within 10 seconds or its process may be killed, and once <code class="literal">onReceive</code> completes, the receiver's life is over.</p><p>Since the work that we need in response is not intensive, we can simply complete it during <code class="literal">onReceive</code>:</p><div><pre class="programlisting">public class SMSDispatcher extends BroadcastReceiver {

  public static final String TO_KEY = "to";
  public static final String TEXT_KEY = "text";

  @Override
  public void onReceive(Context context, Intent intent) {
     // Retrieve the Destination number and the
    // message from the intent extras
    String to = intent.getStringExtra(TO_KEY);
    String text = intent.getStringExtra(TEXT_KEY);

    Log.i("SMS Dispatcher", "Delivering message to " + to);
    SmsManager sms = SmsManager.getDefault();   
    sms.sendTextMessage(to, null, text, null, 0), null);
  }
}</pre></div><p>That's it; once the alarm fires off, the <code class="literal">BroadcastReceiver.onReceive</code> gets called dispatching an SMS to the destination number with the text specified on the UI Form.</p><p>We can make this more useful by delivering a notification to the user when we receive the message delivery report <a id="id383" class="indexterm"/>from the mobile network.</p><p>First, we will add a new action on the <code class="literal">AndroidManifest.xml</code> to be processed by our <code class="literal">BroadcastReceiver</code>:</p><div><pre class="programlisting">&lt;receiver android:name=".chapter6.SMSDispatcher"&gt;
  &lt;intent-filter&gt;
      &lt;action android:name="sms_dispatch"/&gt;
  &lt;/intent-filter&gt;
  &lt;intent-filter&gt;
      &lt;action android:name="sms_delivered"/&gt;
  &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre></div><p>Next, we will change the <code class="literal">onReceive</code> method to process both kinds of <code class="literal">Intent</code>:</p><div><pre class="programlisting">@Override
public void onReceive(Context context, Intent intent) {
   
    if ( intent.getAction().equals(DELIVERED_ACTION) ) {
      processDispatch(context, intent);
    } else if (intent.getAction().equals(DISPATCH_ACTION)) {
      processDelivered(context, intent);
    }
}</pre></div><p>Next, update the code to <a id="id384" class="indexterm"/>dispatch the message to set up a new <code class="literal">PendingIntent</code> for the message delivery report:</p><div><pre class="programlisting">void processDispatch(Context context, Intent intent) {
  ...
  Intent deliveredIntent = new Intent("sms_delivered");
  deliveredIntent.putExtra(SMSDispatcher.TO_KEY, to);
  deliveredIntent.putExtra(SMSDispatcher.TEXT_KEY, text);
  sms.sendTextMessage(to, null, text, null,
    PendingIntent.getBroadcast(context,
      DISPATCH_ACTION.hashCode(), deliveredIntent, 0));
}</pre></div><p>Finally, we add the code to process the message delivery report intent and inform the user, in the notification drawer, if the message was delivered with success:</p><div><pre class="programlisting">void processDelivered(Context context, Intent intent) {
  String to = intent.getStringExtra(TO_KEY);
  String text = intent.getStringExtra(TEXT_KEY);
  String title = null;
  switch (getResultCode()) {
  case Activity.RESULT_OK:
    title = "Message Delivered to " + to;
    break;
  default:
    title = "Message Delivery failed to " + to;
    break;
  }
  NotificationCompat.Builder builder = new
    NotificationCompat.Builder(context)
      .setContentTitle(title)
      .setContentText(text)
      .setSmallIcon(android.R.drawable.stat_notify_chat)
      .setStyle(new NotificationCompat.BigTextStyle()
         .bigText(text));
  NotificationManager nm = (NotificationManager)
                           context.getSystemService(
                             Context.NOTIFICATION_SERVICE);
  nm.notify(intent.hashCode(), builder.build());
}</pre></div><p>Although we can spend up to 10 seconds doing work in our <code class="literal">BroadcastReceiver</code>, we really shouldn't—if the app is in the foreground when the alarm is triggered the user will suffer noticeable lag if <code class="literal">onReceive</code> takes more than a hundred milliseconds to complete on the main Thread. Exceeding the 10 second budget will cause the system to kill the application and report a background ANR.</p><p>Moreover, if we try to execute <a id="id385" class="indexterm"/>the <code class="literal">onReceive</code> work in a background thread and the <code class="literal">onReceive</code> returns, the Android system is allowed to recycle the component. Whenever no other Android component is running, the system could consider the process to be empty and aggressively kill it, stopping our background work immediately.</p><p>To avoid the UI glitching, and the <code class="literal">BroadcastReceiver</code> recycling, on Android API Level 11, the <code class="literal">BroacastReceiver.goAsync</code> method was announced to delegate work to a background thread for up to 10 seconds – we'll discuss this in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Asynchronous work with goAsync</h2></div></div></div><p>If our application <a id="id386" class="indexterm"/>targets a minimum API level of 11, we can use a feature of <code class="literal">BroadcastReceiver.goAsync</code> to handle the <code class="literal">onReceive</code> execution in a parallel line of execution:</p><div><pre class="programlisting">public final PendingResult goAsync()</pre></div><p>With <code class="literal">goAsync</code> we can extend the lifetime of a <code class="literal">BroadcastReceiver</code> instance beyond the completion of its <code class="literal">onReceive</code> method, provided the whole operation still completes within the 10 second budget.</p><p>If we invoke <code class="literal">goAsync</code>, the system will not consider the <code class="literal">BroadcastReceiver</code> to have finished when <code class="literal">onReceive</code> completes. Instead, the <code class="literal">BroadcastReceiver</code> lives on until we call finish on the <code class="literal">PendingResult</code> returned to us by <code class="literal">goAsync</code>. We must ensure that finish is called within the 10 second budget, otherwise the system will kill the process with a background ANR.</p><p>Using <code class="literal">goAsync</code>, we can offload work to background threads using any appropriate concurrency construct—for example, an <code class="literal">AsyncTask</code>—and the device is guaranteed to remain awake until we call finish on the <code class="literal">PendingResult</code>.</p><p>Let's update our <a id="id387" class="indexterm"/>SMS dispatcher to send the message asynchronously:</p><div><pre class="programlisting">public void onReceive(final Context context, final Intent intent) {
   ...
   final PendingResult result = goAsync();
   AsyncTaskCompat.executeParallel(
    new AsyncTask&lt;Void, Void, Void&gt;() {
      @Override
      protected Void doInBackground(Void... params) {
        try {
          // ... do some work here, for up to 10 seconds
          processDispatch(context, intent);
        } finally {
          result.setResultCode(Activity.RESULT_OK);
         result.finish();
        }
        return null;
      }
    });
   ...
}</pre></div><div><div><h3 class="title"><a id="note42"/>Note</h3><p>
<code class="literal">AsyncTaskCompat</code> has been available in the Android Support Library since version 21.0.0 and allows the developer to execute multiple <code class="literal">AsyncTask</code> in parallel on a pool of threads in a backward compatible fashion.</p></div></div><p>This is nice, though its utility is limited by the 10 second budget and the effects of fragmentation (it is only available to API level 11 or above). In the next section, we'll look at scheduling long-running operations with services.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Handling alarms with Services</h1></div></div></div><p>Just like starting <a id="id388" class="indexterm"/>Activities, starting a Service from an alarm involves scheduling an appropriate <code class="literal">PendingIntent</code> instance, this time using the static <code class="literal">getService</code> method:</p><div><pre class="programlisting">Intent intent = new Intent(this,SMSDispatcherIntentService.class);
intent.putExtra(SMSDispatcherIntentService.TO_KEY, phoneNumber);
intent.putExtra(SMSDispatcherIntentService.TEXT_KEY, text);
PendingIntent service = PendingIntent.getService(
   context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
am.set(AlarmManager.RTC_WAKEUP, time, service);</pre></div><p>As you already know, the Service should be globally defined on the Android Manifest with a service element. Given that we are calling it explicitly using the class name, we only need to define the service class:</p><div><pre class="programlisting">&lt;service android:name=".chapter6.SMSDispatcherIntentService" &gt;
&lt;/service&gt;</pre></div><p>We almost certainly <a id="id389" class="indexterm"/>want our Service to do its work off the main thread, so sending work to an <code class="literal">IntentService</code> this way seems ideal, and an <code class="literal">IntentService</code> will also stop itself when the work is finished. This works reliably if the device is awake.</p><p>However, if the device is asleep we have a potential problem. <code class="literal">AlarmManager</code> documentation tells us that the only guarantee we have about the wakefulness of the device is that it will remain awake until a <code class="literal">BroadcastReceiver</code> is <code class="literal">onReceive</code> method completes.</p><p>Since directly starting a <code class="literal">Service</code> does not involve a <code class="literal">BroadcastReceiver</code>, and in any case is an asynchronous operation, there is no guarantee that the <code class="literal">Service</code> will have started up before the device returns to sleep, so the work may not get done until the device is next awakened.</p><p>This is almost certainly not the behavior we want. We want to ensure that the Service starts up and completes its work, regardless of whether the device was awake when the alarm was delivered. To do that, we'll need a <code class="literal">BroadcastReceiver</code> and a little explicit power management, as we'll see next.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec59"/>Staying awake with WakeLocks</h2></div></div></div><p>Earlier in this <a id="id390" class="indexterm"/>chapter we learned that we can use a <code class="literal">BroadcastReceiver</code> to handle alarms, and even do work in the background for up to 10 seconds, though only on devices running API level 11 or greater.</p><p>In the previous <a id="id391" class="indexterm"/>section, we saw that handling alarms directly with services is not a reliable solution for scheduling long-running work, since there is no guarantee that our <code class="literal">Service</code> will start up before the device returns to sleep.</p><p>We have a problem! If we want to perform long-running work in response to alarms, we need a solution that overcomes these limitations.</p><p>What we really want is to start a <code class="literal">Service</code> to handle the work in the background, and to keep the device awake until the <code class="literal">Service</code> has finished its work. Fortunately, we can do that by combining the waking guarantees of <code class="literal">BroadcastReceiver</code> to get the <code class="literal">Service</code> started, then keep the device awake with explicit power management using <code class="literal">PowerManager</code> and <code class="literal">WakeLock</code>.</p><p>As you might <a id="id392" class="indexterm"/>guess, <code class="literal">WakeLock</code> is a way to force the device to stay awake. <code class="literal">WakeLocks</code> come in various flavors, allowing apps to keep the screen on at varying brightness levels or just to keep the CPU powered up in order to do background work. To use <code class="literal">WakeLocks</code>, our application must request an additional permission in the manifest:</p><div><pre class="programlisting">  &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;</pre></div><p>There are four different kinds of wakelock that may affect the system power management differently:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PowerManager.PARTIAL_WAKE_LOCK</code>: Ensures that the CPU is on, leaving the screen and the keyboard in the current state (idle or awake).</li><li class="listitem" style="list-style-type: disc"><code class="literal">PowerManager.SCREEN_DIM_WAKE_LOCK</code>: Ensures that the CPU is on, the screen is on and may be in a dimmed state, and the keyboard could remain off.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PowerManager.SCREEN_BRIGHT_WAKE_LOCK</code>: Ensures that the CPU is on, the screen is on full brightness, and the keyboard could remain off.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PowerManager.FULL_WAKE_LOCK</code>: Ensures that the CPU is on and the screen and keyboard backlight are at full brightness.</li></ul></div><p>To keep the CPU powered up while we do background work in a <code class="literal">Service</code>, we only need <code class="literal">PARTIAL_WAKE_LOCK</code>, which won't keep the screen on, and which we can request from the <code class="literal">PowerManager</code> like this:</p><div><pre class="programlisting">PowerManager pm = (PowerManager)ctx.getSystemService(
                     Context.POWER_SERVICE);
WakeLock lock = pm.newWakeLock(
  PowerManager.PARTIAL_WAKE_LOCK, "my_app");

// Acquire the Power Lock
lock.acquire();

// Do your work here while CPU will stay on …

// Release the Power lock
lock.release();</pre></div><p>We'll need to acquire a <code class="literal">WakeLock</code> during our <code class="literal">BroadcastReceiver</code> is <code class="literal">onReceive</code> method, and find some way to hand it to our <code class="literal">Service</code> so that the <code class="literal">Service</code> can release the lock once its work is done.</p><p>Unfortunately, <code class="literal">WakeLock</code> instances are not parcelable, so we can't just send them to the <code class="literal">Service</code> in an Intent. The simplest <a id="id393" class="indexterm"/>solution is to manage the <code class="literal">WakeLock</code> instance as a static property that both the <code class="literal">BroadcastReceiver</code> and the target Service can reach.</p><p>This is not difficult to implement, but we don't actually need to implement it ourselves—we can use the handy v4 support library class, <code class="literal">WakefulBroadcastReceiver</code>.</p><p>
<code class="literal">WakefulBroadcastReceiver</code> exposes two static methods that take care of acquiring and releasing a partial <code class="literal">WakeLock</code>. We can acquire the <code class="literal">WakeLock</code> and start the <code class="literal">Service</code> with a single call to <code class="literal">startWakefulService</code>:</p><div><pre class="programlisting">ComponentName startWakefulService(Context context, Intent intent);</pre></div><p>And when our Service has finished its work, it can release the <code class="literal">WakeLock</code> with the corresponding call to <code class="literal">completeWakefulIntent</code>:</p><div><pre class="programlisting">boolean completeWakefulIntent(Intent intent);</pre></div><p>Now, we will update our SMS schedule <code class="literal">BroadcastReceiver</code> to acquire the <code class="literal">wakelock</code> and dispatch the intent over the <code class="literal">startWakefulService</code>:</p><div><pre class="programlisting">public class WakefulSMSDispatcher extends BroadcastReceiver {

  @Override
  public void onReceive(Context context, Intent intent) {
    // Forward intent to SMSDispatcherIntentService class,
    // the wakeful receiver is needed in case the
    // schedule is triggered while the device
    // is asleep otherwise the service may not have time to
    // receive the intent.
    intent.setClass(context, SMSDispatcherIntentService.class);
    WakefulBroadcastReceiver.startWakefulService(context, intent);
  }
}</pre></div><p>We must make sure to release the <code class="literal">WakeLock</code> once the Service has finished its work, otherwise we'll drain the battery by keeping the CPU powered up unnecessarily. Let's implement the <code class="literal">IntentService</code> that receives the intent from the wakeful <code class="literal">BroadcastReceiver</code> and <a id="id394" class="indexterm"/>sends the message in the service background thread:</p><div><pre class="programlisting">public class SMSDispatcherIntentService extends IntentService {

  @Override
  protected void onHandleIntent(Intent intent) {
    try {
      ...
      sms.sendTextMessage(to, null, text, null, null);
    } finally {
      WakefulBroadcastReceiver.completeWakefulIntent(intent);
    }
  }
}</pre></div><p>This is great—by using a statically registered <code class="literal">BroadcastReceiver</code> we've ensured that we receive the alarm, even if our application is not running when the alarm is due. When we receive the alarm, we acquire a <code class="literal">WakeLock</code>, keeping the device awake while our <code class="literal">Service</code> starts up and does its potentially long-running work.</p><p>Once our work is done, we release the <code class="literal">WakeLock</code> to allow the device to sleep again and conserve power.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Resetting alarms after a system reboot</h1></div></div></div><p>The <a id="id395" class="indexterm"/><code class="literal">AlarmManager</code> service is a convenient class to schedule working on your Android application; however, when the device shuts down or reboots, all your alarms will be lost since the system does not retain them between system restarts.</p><p>To reset the alarm, we should persist your alarms and create a <code class="literal">BroadcastReceiver</code> that sets our alarms whenever a system boot happens:</p><div><pre class="programlisting">public class BootBroadcastReceiver extends BroadcastReceiver {

  @Override
  public void onReceive(Context context, Intent intent) {
    // Retrieve the persisted alarms
    List&lt;SMSSchedule&gt; persistedAlarms = getStoredSchedules();
    // Set again the alarms
    ...
  }
  List&lt;SMSSchedule&gt; getStoredSchedules() {...}
}</pre></div><p>In order to store our alarms, we created a <code class="literal">POJO</code> class <code class="literal">SMSSchedule</code> as the model for our schedules.</p><p>Second, in the <a id="id396" class="indexterm"/>Android Manifest we have to register our <code class="literal">BroadcastReceiver</code> to receive the boot event:</p><div><pre class="programlisting">&lt;receiver
    android:name=".chapter6.BootBroadcastReceiver"
    android:enabled="true" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre></div><p>Finally, we will add the permission to receive the boot complete event:</p><div><pre class="programlisting">&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;</pre></div><p>Now after a system reboot, we re-create our alarms and they fire off even after a system reboot. We also advise that the alarms using <code class="literal">ELAPSED_REALTIME</code> should be adjusted after a system reboot since the the clock where those alarms are based is going to be restarted.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Applications of AlarmManager</h1></div></div></div><p>
<code class="literal">AlarmManager</code> <a id="id397" class="indexterm"/>allows us to schedule work to run without user intervention.</p><p>This means that we can arrange to do work pre-emptively, for example, to prepare data that our application will need to present to the user when they next open the application, or to alert the user to new or updated information with notifications.</p><p>Ideal use cases include things like periodically checking for new e-mails, SMS scheduling, time notifications, periodic data processing, downloading new editions of periodical publications (for example, daily newspapers and magazines), or uploading data from the device to a cloud backup service.</p><p>The <code class="literal">AlarmManager</code> is able to start future work effectively but the API should be used carefully to keep your application battery power consumption at low levels. To achieve that, the developer should <a id="id398" class="indexterm"/>try to keep the alarm frequency under certain levels and use the exact set functions that force the device to wake up only in cases where it is really necessary.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, we learned to schedule work for our applications to perform at some time in the distant future, either as a one-shot operation or at regular intervals.</p><p>We learned to set alarms relative to the system clock or real time, how to wake the device up from a deep sleep and doze mode, how to cancel alarms when we no longer need them, and how to set exact alarms on the most recent Android versions.</p><p>In the meantime, we introduced the reader to Doze Mode, a new power management feature that saves battery cycles by deferring jobs and tasks to a maintenance window. We learned how to test our alarms taking into account the new power management states introduced by the doze mode.</p><p>We learned how to debug alarms created with <code class="literal">AlarmManager</code> and how to analyze the information printed from the <code class="literal">dumpsys</code> commands.</p><p>Our exploration covered various options for responding to alarms, including bringing an <code class="literal">Activity</code> to the foreground or doing work directly in a <code class="literal">BroadcastReceiver</code>, synchronously or asynchronously.</p><p>Finally, we arranged for an <code class="literal">IntentService</code> to be launched with a <code class="literal">WakeLock</code> to keep the CPU from powering down while our long-running background work is completed, and to finish we learned how to re-create the alarms after a system boot using a boot <code class="literal">BroadcastReceiver</code>.</p><p>The <code class="literal">AlarmManager</code> is a very useful class to schedule work in the background but it has some major disadvantages. First, it does not take into account the device current context, like if the device is connected to the charger, or whether the device is connected to a Wi-Fi network. Second, we can only schedule our background work based on the time condition.</p><p>To solve these issues, the Android team introduced in Android Lollipop API Level 5.0 the <code class="literal">JobScheduler</code> API; an API that allows the execution of background work based on a number of time and context criteria.</p><p>In the next chapter we are going to explain how to exercise the <code class="literal">JobScheduler</code> API to schedule tasks that will only run when the appropriate energy and environment device conditions are met.</p></div></body></html>