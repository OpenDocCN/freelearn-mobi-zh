<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Thumping Moles for Fun</h1></div></div></div><p>We will be continuing our journey through classic gameplay styles in this chapter. We will talk a little about different approaches to solve the design challenges in this chapter. In game programming, there are always many ways to solve the same problem, there is no single right answer.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tricking the eye with Z-ordering</li><li class="listitem" style="list-style-type: disc">Reusing objects</li><li class="listitem" style="list-style-type: disc">Detecting touch on the part of a sprite</li><li class="listitem" style="list-style-type: disc">Animations and movement actions</li><li class="listitem" style="list-style-type: disc">Randomized objects</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>The project is…</h1></div></div></div><p>In this chapter, we will be building a mole thumping <a id="id481" class="indexterm"/>game. Inspired by mechanical games of the past, we will <a id="id482" class="indexterm"/>build molehills on the screen and randomly cause animated moles to pop their heads out. The player taps them to score. Simple in concept, but there are a few challenging design considerations in this deceptively easy game. To make this game a little unusual, we will be using a penguin instead of a mole for the graphics, but we will continue to use the mole terminology throughout, since a molehill is easier to consider than a penguin-hill.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Design approach</h2></div></div></div><p>Before diving into the code, let's start with a discussion of the design of the game. First, we will need to have molehills on the screen. To be aesthetically <a id="id483" class="indexterm"/>pleasing, the molehills will be in a 3 x 4 grid. Another approach would be to use random molehill positions, but that doesn't really work well on the limited screen space of the iPhone. Moles will randomly spawn from the molehills. Each mole will rise up, pause, and drop down. We will need touch handling to detect when a mole has been touched, and that mole will need to increase the player's score and then go away.</p><p>How do we make the mole come up from underground? If we assume the ground is a big sprite with the molehills drawn on it, we would need to determine where to make the "slot" from which the mole emerges, and somehow make the mole disappear when it is below that slot. One approach is to adjust the size of the mole's displayed frame by clipping the bottom of the image so that the part below the ground is not visible. This needs to be done as a part of every update cycle for every mole for the entire game. From a programming standpoint this will work, but you may experience performance issues. Another consideration is that this usually means the hole in the molehill will always appear to be a straight-edged hole, if we trim the sprite with a straight line. This lacks the organic feel we want for this game.</p><p>The approach we will take is to use Z-ordering to trick the eye into <a id="id484" class="indexterm"/>seeing a flat playfield when everything is really on staggered Z-orders. We will create a "stair step" board, with multiple "sandwiches" of graphics for every row of molehills on the board.</p><div><img src="img/9007_03_01.jpg" alt="Design approach"/></div><p>For each "step" of the "stair step", we have a sandwich of Z-ordered elements in this order, from back to front: molehill top, mole, ground, and molehill bottom. We need to have everything aligned so that the molehill top graphic overlaps the ground of the next "step" further towards the top of the screen. This will visually contain the mole, so it appears to be emerging from inside the molehill.</p><p>We intentionally skipped the Z value of 1, to provide an extra expansion space if we later decide that we need another element in the "sandwich". It is easier to leave little holes like this than to worry about changing everything later, if we enhance our design. So throughout our layout, we will consider it as a sandwich of five Z values, even though we only use four elements in the sandwich.</p><p>As we said, we need this to be a "stair step" board. <a id="id485" class="indexterm"/>So for each row of molehills, from the top of the screen to the bottom, we will need to increase the Z-ordering between layers to complete the illusion. This is needed so that each mole will actually pass in front of the ground layer that is closer to the top of the screen, yet will hide completely behind the ground layer in its own sandwich of layers.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Designing the spawn</h2></div></div></div><p>That covers the physical design of the game, but there is one additional design aspect we need to discuss: spawning moles. We need to spawn the moles whenever we need one to be put into the play. Just as we reviewed two <a id="id486" class="indexterm"/>approaches to the hiding mole problem earlier, we will touch on two approaches to mole spawning.</p><p>The first approach (and most common) is to create a new <a id="id487" class="indexterm"/>mole from scratch each time you need one. When you are done with it, you destroy it. This works fine for games with a small number of objects or games of more limited complexity, but there is a performance penalty to create and destroy a lot of objects in a short amount of time. Strictly speaking, our mole thumping game would likely work fine with this approach. Even though we will be creating and destroying quite a few moles all the time, we only have a dozen possible moles, not hundreds.</p><p>The other approach is to create a spawning pool. This is basically a set number of the objects that are created when you start up. When you need a mole, in our case, you ask the pool for an unused "blank mole", set any parameters that are needed, and use it. When you are done with it, you reset it back to the "blank mole" state, and it goes back into the pool.</p><p>For our game the spawning pool might be a little more heavily coded than needed, as it is doubtful that we would run into any performance issues with this relatively simple game. Still, if you are willing to build the additional code as we are doing here, it does provide a strong foundation to add more performance-heavy effects later on.</p><p>To clarify our design approach, we will actually implement a variation of the traditional spawning pool. Instead of a general pool of moles, we will build our "blank mole" objects attached to their molehills. A more traditional spawning pool might have six "blank moles" in the pool, and they are assigned to a molehill when they are <a id="id488" class="indexterm"/>needed. Both <a id="id489" class="indexterm"/>approaches are perfectly valid.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Portrait mode</h2></div></div></div><p>The default orientation supported by cocos2d is landscape mode, which is more commonly used in games. However, we want our game to be in portrait mode. The changes are very simple to make this work. If you <a id="id490" class="indexterm"/>click <a id="id491" class="indexterm"/>once on the project name (and blue icon) in the <a id="id492" class="indexterm"/>
<a id="id493" class="indexterm"/>
<strong>Project Navigator</strong> pane (where all your files are listed), and then click on the name of your game under <strong>TARGETS</strong>, you will see the <strong>Summary</strong> pane. Under the <strong>Supported Interface Orientations</strong>, select <strong>Portrait</strong>, and deselect <strong>Landscape Left</strong> and <strong>Landscape Right</strong>. That will change your project to portrait. The one adjustment to the cocos2d template code we need is in the <code class="literal">IntroLayer.m</code>. After it sets the background to <code class="literal">Default.png</code>, there is a command to rotate the background. Remove, or comment out this line, and everything will work correctly.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Custom TTF fonts</h2></div></div></div><p>In this project we will be using a custom TTF font. In cocos2d 1.x, you could simply add the font to your project and use it. Under cocos2d 2.0, <a id="id494" class="indexterm"/>which we are using, we have to <a id="id495" class="indexterm"/>approach this a little differently. We add the font to our project (we are using <code class="literal">anudrg.ttf</code>). Then we edit the <a id="id496" class="indexterm"/>
<a id="id497" class="indexterm"/>
<code class="literal">Info.plist</code> for our project, and add a new key to the list, like this:</p><div><img src="img/9007_03_02.jpg" alt="Custom TTF fonts"/></div><p>This tells the project that we need to know about this font. To actually use the font, we need to call it by the proper name for the font, not the filename. To find out this name, in <strong>Finder</strong>, select the file and choose <strong>File Info</strong>. In the info box, there is an entry for <strong>Full Name</strong>. In our case, the file name is <code class="literal">AnuDaw</code>. Any time we create a label with <code class="literal">CCLabelTTF</code>, we simply need to use this as the font name, and everything works perfectly.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Defining a molehill</h1></div></div></div><p>We have created a new subclass of <code class="literal">CCNode</code> to represent the <a id="id498" class="indexterm"/>
<a id="id499" class="indexterm"/>
<code class="literal">MXMoleHill</code> object. Yes, we will be using a subclass of <code class="literal">CCNode</code>, not a subclass of <code class="literal">CCSprite</code>. Even though we initially would consider the molehill to be a sprite, referring back to our design, it is actually made up of <em>two</em> sprites, one for the top of the hill and one <a id="id500" class="indexterm"/>for the bottom. <a id="id501" class="indexterm"/>We will use <code class="literal">CCNode</code> as a container that will then contain two <code class="literal">CCSprite</code> objects as variables inside the <a id="id502" class="indexterm"/>
<a id="id503" class="indexterm"/>
<code class="literal">MXMoleHill</code> class.</p><p>
<strong>Filename:</strong> <code class="literal">MXMoleHill.h</code>
</p><div><pre class="programlisting">@interface MXMoleHill : CCNode {

  NSInteger moleHillID;
  CCSprite *moleHillTop;
  CCSprite *moleHillBottom;
  NSInteger moleHillBaseZ;
  MXMole *hillMole;
  BOOL isOccupied;
}

@property (nonatomic, assign) NSInteger moleHillID;
@property (nonatomic, retain) CCSprite *moleHillTop;
@property (nonatomic, retain) CCSprite *moleHillBottom;
@property (nonatomic, assign) NSInteger moleHillBaseZ;
@property (nonatomic, retain) MXMole *hillMole;
@property (nonatomic, assign) BOOL isOccupied;

@end</pre></div><p>If this seems rather sparse to you, it is. As we will be using this as a container for everything that defines the hill, we don't need to override any methods from the standard <code class="literal">CCNode</code> class. Likewise, the <a id="id504" class="indexterm"/>
<a id="id505" class="indexterm"/>
<code class="literal">@implementation</code> file contains nothing but the <code class="literal">@synthesize</code> statements for these variables.</p><p>It is worth pointing out that we could have used a <a id="id506" class="indexterm"/>
<a id="id507" class="indexterm"/>
<code class="literal">CCSprite</code> object for the <a id="id508" class="indexterm"/>
<a id="id509" class="indexterm"/>
<code class="literal">hillTop</code> sprite, with the <code class="literal">hillBottom</code> object as a <a id="id510" class="indexterm"/>
<a id="id511" class="indexterm"/>child of that sprite, and achieved the same effect. However, we prefer consistency in our object structure, so we have opted to use the structure noted previously. This allows us to refer to the two sprites in exactly the same fashion, as <a id="id512" class="indexterm"/>they are both children of the same parent.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Building the mole</h2></div></div></div><p>When we start building the playfield, we will be <a id="id513" class="indexterm"/>creating "blank mole" objects for each hill, so we need to look at the <code class="literal">MXMole</code> class before we build the playfield. Following the same <a id="id514" class="indexterm"/>design decision as we did with the <a id="id515" class="indexterm"/>
<a id="id516" class="indexterm"/>
<code class="literal">MXMoleHill</code> class, the <a id="id517" class="indexterm"/>
<a id="id518" class="indexterm"/>
<code class="literal">MXMole</code> class is also a subclass of <code class="literal">CCNode</code>.</p><p>
<strong>Filename:</strong> <code class="literal">MXMole.h</code>
</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "cocos2d.h"
#import "MXDefinitions.h"
#import "SimpleAudioEngine.h"

// Forward declaration, since we don't want to import it here
@class MXMoleHill;

@interface MXMole : CCNode &lt;CCTargetedTouchDelegate&gt; {
  CCSprite *moleSprite;  // The sprite for the mole
    MXMoleHill *parentHill;  // The hill for this mole
  float moleGroundY;  // Where "ground" is
    MoleState _moleState; // Current state of the mole
    BOOL isSpecial; // Is this a "special" mole?
}

@property (nonatomic, retain) MXMoleHill *parentHill;
@property (nonatomic, retain) CCSprite *moleSprite;
@property (nonatomic, assign) float moleGroundY;
@property (nonatomic, assign) MoleState moleState;
@property (nonatomic, assign) BOOL isSpecial;

-(void) destroyTouchDelegate;

@end</pre></div><p>We see a forward declaration here (the <code class="literal">@class</code> statement). Use of forward declaration avoids creating a circular loop, because the <code class="literal">MXMoleHill.h</code> file needs to import <code class="literal">MXMole.h</code>. In our case, <code class="literal">MXMole</code> needs to know there is a valid class called <code class="literal">MXMoleHill</code>, so we can store a reference to an <a id="id519" class="indexterm"/>
<a id="id520" class="indexterm"/>
<code class="literal">MXMoleHill</code> object in the <code class="literal">parentHill</code> instance variable, but we don't actually need to import the class. The <a id="id521" class="indexterm"/>
<a id="id522" class="indexterm"/>
<code class="literal">@class</code> declaration is an instruction to the compiler that there is a valid class called <code class="literal">MXMoleHill</code>, but doesn't actually import the header while compiling the <code class="literal">MXMole</code> class. If we needed to call the methods of <code class="literal">MXMoleHill</code> from the <code class="literal">MXMole</code> class, we could then put the actual <code class="literal">#import "MXMoleHill.h"</code> line in the <code class="literal">MXMole.m</code> file. For our current project, we only need to know the class exists, so we don't need that additional line in the <code class="literal">MXMole.m</code> file.</p><p>We have built a simple state machine for <code class="literal">MoleState</code>. Now <a id="id523" class="indexterm"/>that we have reviewed the <code class="literal">MXMole.h</code> file, we have a basic idea of what makes up a mole. It tracks the state of the mole <a id="id524" class="indexterm"/>(dead, alive, and so on), it keeps a reference to its parent hill, and it has <code class="literal">CCSprite</code> as a child where the actual mole sprite variable will be held. There are a couple of other variables (<code class="literal">moleGroundY</code> and <code class="literal">isSpecial</code>), but we will deal with these later.</p><p>
<strong>Filename:</strong> <a id="id525" class="indexterm"/>
<a id="id526" class="indexterm"/>
<code class="literal">MXDefinitions.h</code>
</p><div><pre class="programlisting">typedef enum {
    kMoleDead = 0,
    kMoleHidden,
    kMoleMoving,
    kMoleHit,
    kMoleAlive
} MoleState;

#define SND_MOLE_NORMAL @"penguin_call.caf"
#define SND_MOLE_SPECIAL @"penguin_call_echo.caf"
#define SND_BUTTON @"button.caf"</pre></div><p>Unlike in the previous chapter, we do not have <code class="literal">typedef enum</code> that defines the <code class="literal">MoleState</code> type inside this header file. We have moved our definitions to the <code class="literal">MXDefinitions.h</code> file, which helps to maintain slightly cleaner code. You can store these "universal" definitions in a single header file, and include the header in any <code class="literal">.h</code> or <code class="literal">.m</code> files where they are needed, without needing to import classes just to gain <a id="id527" class="indexterm"/>access to these definitions. The <a id="id528" class="indexterm"/>
<a id="id529" class="indexterm"/>
<code class="literal">MXDefinitions.h</code> file only includes the definitions; there are no <code class="literal">@interface</code> or <code class="literal">@implementation</code> sections, nor a related <code class="literal">.m</code> file.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Making a molehill</h1></div></div></div><p>We have our molehill class and we've seen the mole class, so now <a id="id530" class="indexterm"/>we can look at how we <a id="id531" class="indexterm"/>actually build the molehills in the <a id="id532" class="indexterm"/>
<a id="id533" class="indexterm"/>
<code class="literal">MXPlayfieldLayer</code> class:</p><p>
<strong>Filename:</strong> <code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) drawHills {
    NSInteger hillCounter = 0;
    NSInteger newHillZ = 6;
    
    // We want to draw a grid of 12 hills
    for (NSInteger row = 1; row &lt;= 4; row++) {
        // Each row reduces the Z order
        newHillZ--;
        for (NSInteger col = 1; col &lt;= 3; col++) {
            hillCounter++;

            // Build a new MXMoleHill
            MXMoleHill *newHill = [[MXMoleHill alloc] init];
            [newHill setPosition:[self
                hillPositionForRow:row andColumn:col]];
            [newHill setMoleHillBaseZ:newHillZ];
            [newHill setMoleHillTop:[CCSprite
                spriteWithSpriteFrameName:@"pileTop.png"]];
            [newHill setMoleHillBottom:[CCSprite
                spriteWithSpriteFrameName:@"pileBottom.png"]];
            [newHill setMoleHillID:hillCounter];
            
            // We position the two moleHill sprites so 
            // the "seam" is at the edge.  We use the
            // size of the top to position both, 
            // because the bottom image
            // has some overlap to add texture
            [[newHill moleHillTop] setPosition:
                ccp(newHill.position.x, newHill.position.y +
                [newHill moleHillTop].contentSize.height
                    / 2)];
            [[newHill moleHillBottom] setPosition:
                ccp(newHill.position.x, newHill.position.y - 
                [newHill moleHillTop].contentSize.height
                    / 2)];

            //Add the sprites to the batch node
            [molesheet addChild:[newHill moleHillTop]
                              z:(2 + (newHillZ * 5))];
            [molesheet addChild:[newHill moleHillBottom]
                              z:(5 + (newHillZ * 5))];
            
            //Set up a mole in the hill
            MXMole *newMole = [[MXMole alloc] init];
            [newHill setHillMole:newMole]; 
            [[newHill hillMole] setParentHill:newHill]; 
            [newMole release];

            // This flatlines the values for the new mole
            [self resetMole:newHill];

            [moleHillsInPlay addObject:newHill];
            [newHill release];
        }
    }
}</pre></div><p>This is a pretty dense method, so we'll walk through it one section at a time. We start by creating two nested <code class="literal">for</code> loops so we can iterate over every possible row and column position. For clarity, we named our loop variables as <code class="literal">row</code> and <code class="literal">column</code>, so we know what each represents. If you recall from the design, we decided to use a 3 x 4 grid, so we will have three columns and four rows of molehills. We create a <a id="id534" class="indexterm"/>new hill using an <code class="literal">alloc</code>/<code class="literal">init</code>, and <a id="id535" class="indexterm"/>then we begin filling in the variables. We set an ID number (1 through 12), and we build <code class="literal">CCSprite</code> objects to fill in the <a id="id536" class="indexterm"/>
<a id="id537" class="indexterm"/>
<code class="literal">moleHillTop</code> and <a id="id538" class="indexterm"/>
<a id="id539" class="indexterm"/>
<code class="literal">moleHillBottom</code> variables.</p><p>
<strong>Filename:</strong> <code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(CGPoint) hillPositionForRow:(NSInteger)row
                    andColumn:(NSInteger)col {
    float rowPos = row * 82;
    float colPos = 54 + ((col - 1) * 104);
    return ccp(colPos,rowPos); 
}</pre></div><p>We also set the position using the helper method, <code class="literal">hillPositionForRow:andColumn:</code>, that returns a <code class="literal">CGPoint</code> for each molehill. (It is important to remember that <code class="literal">ccp</code> is a cocos2d shorthand term for a <code class="literal">CGPoint</code>. They are interchangeable in your code.) These calculations are based on experimentation with the layout, to create a grid that is both easy to draw as well as being visually appealing.</p><p>The one variable that needs a little extra explaining is <code class="literal">moleHillBaseZ</code>. This represents which "step" of the Z-order stair-step design this hill belongs to. We use this to aid in the calculations to determine the proper Z-ordering across the entire playfield. If you recall, we used Z-orders from 2 to 5 in the illustration of the stack of elements. When we add the <code class="literal">moleHillTop</code>
<a id="id540" class="indexterm"/>
<a id="id541" class="indexterm"/> and <a id="id542" class="indexterm"/>
<a id="id543" class="indexterm"/>
<code class="literal">moleHillBottom</code> as children of the <code class="literal">moleSheet</code> (our <code class="literal">CCSpriteBatchNode</code>), we add the Z-order of the piece of the sandwich to the "base Z" times 5. We will use a "base Z" of 5 for the stack at the bottom of the screen, and a "base Z" of 2 at the top of the screen. This will be easier to understand the reason if we look at the following chart, which shows the calculations we use <a id="id544" class="indexterm"/>for each row of molehills:</p><div><img src="img/9007_03_03.jpg" alt="Making a molehill"/></div><p>As we start building our molehills at the bottom of the screen, we start with a higher Z-order first. In the preceding chart, you will see that the mole in hole 4 (second row of molehills from the bottom) will have a Z-order of 23. This will put it behind its own ground layer, which is at a Z-order of 24, but in front of the ground higher on the screen, which would be at a Z-order of 19.</p><p>It is worth calling out that since we have a grid of molehills in our design, all Z-ordering will be identical for all molehills in the same row. This is why the decrement of the <code class="literal">baseHillZ</code> variable occurs only when we are iterating through a new row.</p><p>If we refer back to the <code class="literal">drawHills</code> method itself, we also see a big calculation for the actual position of the <code class="literal">moleHillTop</code> and <code class="literal">moleHillBottom</code> sprites. We want the "seam" between these two sprites to be at the top edge of the ground image of their stack, so we set the <code class="literal">y</code> position based on the position of the <a id="id545" class="indexterm"/>
<a id="id546" class="indexterm"/>
<code class="literal">MXMoleHill</code> object. At first it may look like an error, because both <code class="literal">setPosition</code> statements use <code class="literal">contentSize</code> of the <code class="literal">moleHillTop</code> sprite as a part of the calculation. This is intentional, because we have a little jagged overlap between those two sprites to give it a more organic feel.</p><p>To wrap up the <a id="id547" class="indexterm"/>
<a id="id548" class="indexterm"/>
<code class="literal">drawHills</code> method, we allocate a new <code class="literal">MXMole</code>, assign it to the molehill that was just created, and set the cross-referencing <code class="literal">hillMole</code> and <code class="literal">parentHill</code> variables in the objects themselves. We add the molehill to our <a id="id549" class="indexterm"/>
<a id="id550" class="indexterm"/>
<code class="literal">moleHillsInPlay</code> array, and we clean everything up by releasing both the <code class="literal">newHill</code> and the <code class="literal">newMole</code> objects. Because the array retains a reference to the <a id="id551" class="indexterm"/>molehill, and the molehill retains a reference to the mole, we can safely release both the <a id="id552" class="indexterm"/>
<a id="id553" class="indexterm"/>
<code class="literal">newHill</code> and <a id="id554" class="indexterm"/>
<a id="id555" class="indexterm"/>
<code class="literal">newMole</code> objects in this method.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Drawing the ground</h2></div></div></div><p>Now that we have gone over the Z-ordering "trickery", we <a id="id556" class="indexterm"/>should look at the <code class="literal">drawGround</code> method to see how we accomplish the Z-ordering in a similar fashion:</p><p>
<strong>Filename:</strong> <a id="id557" class="indexterm"/>
<a id="id558" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) drawGround {
    // Randomly select a ground image
    NSString *groundName;
    NSInteger groundPick = CCRANDOM_0_1() * 2;
    
    switch (groundPick) {
        case 1:
            groundName = @"ground1.png";
            break;
        default: // Case 2 also falls through here
            groundName = @"ground2.png";
            break;
    }
    
    // Build the strips of ground from the selected image
    for (int i = 0; i &lt; 5; i++) {
        CCSprite *groundStrip1 = [CCSprite
                spriteWithSpriteFrameName:groundName];
        [groundStrip1 setAnchorPoint:ccp(0.5,0)];
        [groundStrip1 setPosition:ccp(size.width/2,i*82)];
        [molesheet addChild:groundStrip1 z:4+((5-i) * 5)];
    }
    
    // Build a skybox
    skybox = [CCSprite
              spriteWithSpriteFrameName:@"skybox1.png"];
    [skybox setPosition:ccp(size.width/2,5*82)];
    [skybox setAnchorPoint:ccp(0.5,0)];
    [molesheet addChild:skybox z:1];
}</pre></div><p>This format should look familiar to you. We create five <code class="literal">CCSprite</code> objects for the five stripes of ground, tile them from the bottom of the screen to the top, and assign the Z-order as <code class="literal">z:4+((5-i) * 5)</code>. We do include a randomizer with two different background images, and we also include a skybox image at the top of the screen, because we want some sense of a horizon line above the mole-thumping area.</p><p>We saw <code class="literal">anchorPoints</code> briefly in <a class="link" href="ch01.html" title="Chapter 1. Thanks for the Memory Game">Chapter 1</a>, <em>Thanks for the Memory Game</em> but we should revisit them here, as they will become more important in later projects. <code class="literal">anchorPoint</code> is the point that is basically "center" for the sprite. The acceptable values are floats between 0 and 1. For the x axis, an <code class="literal">anchorPoint</code> of 0 is the left edge, and 1 is the right edge (0.5 is centered). For the y axis, an <a id="id559" class="indexterm"/>
<a id="id560" class="indexterm"/>
<code class="literal">anchorPoint</code> of 0 is the bottom edge, and 1 is the top edge. This <code class="literal">anchorPoint</code> is important here because that <code class="literal">anchorPoint</code> is the point on the object to which the <a id="id561" class="indexterm"/>
<a id="id562" class="indexterm"/>
<code class="literal">setPosition</code> method will refer. So in our code, the first <code class="literal">groundStrip1</code> created will be anchored at the bottom center. When we call <code class="literal">setPosition</code>, the coordinate passed to <code class="literal">setPosition</code> needs to relate to that <code class="literal">anchorPoint</code>; the position set will be the bottom center of the sprite. <a id="id563" class="indexterm"/>If this is still fuzzy for you, it is a great exercise to change <code class="literal">anchorPoint</code> of your own <code class="literal">CCSprite</code> objects and see what happens on the screen.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Mole spawning</h1></div></div></div><p>The only piece of the "sandwich" of elements we haven't seen in <a id="id564" class="indexterm"/>detail is the mole itself, so <a id="id565" class="indexterm"/>let's visit the mole spawning method to see how the mole fits in with our design:</p><p>
<strong>Filename:</strong> <a id="id566" class="indexterm"/>
<a id="id567" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) spawnMole:(id)sender {
  // Spawn a new mole from a random, unoccupied hill
  NSInteger newMoleHill;
  BOOL isApprovedHole = FALSE;
  NSInteger rand;
  if (molesInPlay == [moleHillsInPlay count] ||
        molesInPlay == maxMoles) {
    // Holes full, cannot spawn a new mole
  } else {
    // Loop until we pick a hill that isn't occupied
    do {
      rand = CCRANDOM_0_1() * maxHills;
      
      if (rand &gt; maxHills) { rand = maxHills; }
      
            MXMoleHill *testHill = [moleHillsInPlay
                                    objectAtIndex:rand];
            
            // Look for an unoccupied hill
      if ([testHill isOccupied] == NO) {
        newMoleHill = rand;
        isApprovedHole = YES;
        [testHill setIsOccupied:YES];
      }
    } while (isApprovedHole == NO);
        
    // Mark that we have a new mole in play
    molesInPlay++;

    // Grab a handle on the mole Hill 
    MXMoleHill *thisHill = [moleHillsInPlay
                        objectAtIndex:newMoleHill];
    
    NSInteger hillZ = [thisHill moleHillBaseZ];
        
    // Set up the mole for this hill
    CCSprite *newMoleSprite = [CCSprite
             spriteWithSpriteFrameName:@"penguin_forward.png"];
        
    [[thisHill hillMole] setMoleSprite:newMoleSprite];		
    [[thisHill hillMole] setMoleState:kMoleAlive];
      
    // We keep track of where the ground level is
    [[thisHill hillMole] setMoleGroundY:
                                thisHill.position.y];
        
    // Set the position of the mole based on the hill
    float newMolePosX = thisHill.position.x;
    float newMolePosY = thisHill.position.y - 
        (newMoleSprite.contentSize.height/2);
        
    [newMoleSprite setPosition:ccp(newMolePosX,
                                       newMolePosY)];
        
    // See if we need this to be a "special" mole
    NSInteger moleRandomizer = CCRANDOM_0_1() * 100;
        
    // If we randomized under 5, make this special
    if (moleRandomizer &lt; 5) {
            [[thisHill hillMole] setIsSpecial:YES];
    }
        
    //Trigger the new mole to raise
    [molesheet addChild:newMoleSprite
                          z:(3 + (hillZ * 5))];
    [self raiseMole:thisHill];
  }
}</pre></div><p>The first thing we check is to make sure we don't have active moles in every molehill, and that we haven't reached the maximum number of simultaneous moles we want on screen at the same time (the <a id="id568" class="indexterm"/>
<a id="id569" class="indexterm"/>
<code class="literal">maxMoles</code> variable). If we have enough moles, we skip the rest of the loop. If we need a new mole, we enter a <code class="literal">do…while</code> loop that will randomly pick a molehill and check if it has the <a id="id570" class="indexterm"/>
<a id="id571" class="indexterm"/>
<code class="literal">isOccupied</code> variable set to <code class="literal">NO</code> (that is, no active mole in this molehill). If the randomizer picks a molehill that is already occupied, the <code class="literal">do…while</code> loop will pick another molehill and try again. When we <a id="id572" class="indexterm"/>find an unoccupied molehill, the code breaks out of the loop and starts to set up the mole.</p><p>As we saw earlier, there is already a "blank mole" attached to every molehill. At this point we build a new sprite to attach to the <a id="id573" class="indexterm"/>
<a id="id574" class="indexterm"/>
<code class="literal">moleSprite</code> variable of <code class="literal">MXMole</code>, change the <code class="literal">moleState</code> to <code class="literal">kMoleAlive</code>, and set up the coordinates for the mole to start. We want the mole to start from underground (hidden by the ground image), so we set the mole's <code class="literal">y</code> position as the position of the molehill minus the height of the mole.</p><p>Once we have set up the mole, we assign our calculated <a id="id575" class="indexterm"/>Z-order for this mole (based on the <code class="literal">moleHillBaseZ</code> variable we stored earlier for each molehill), and call the <a id="id576" class="indexterm"/>
<a id="id577" class="indexterm"/>
<code class="literal">raiseMole</code> method, which controls the animation and movement of the mole.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Special moles</h2></div></div></div><p>We have seen two references to the <a id="id578" class="indexterm"/>
<a id="id579" class="indexterm"/>
<code class="literal">isSpecial</code> variable from the <a id="id580" class="indexterm"/>
<a id="id581" class="indexterm"/>
<code class="literal">MXMole</code> class, so now is a good time to explain how it is used. In order to break the repetitive nature of the game, we have added a "special mole" feature. When a new mole is requested to spawn in the <code class="literal">spawnMole</code> method, we generate a random number between 1 and 100. If the resulting number is less than five, then we set the <a id="id582" class="indexterm"/>
<a id="id583" class="indexterm"/>
<code class="literal">isSpecial</code> flag for that mole. This means that <a id="id584" class="indexterm"/>roughly 5 percent of the time the player will get a special mole. Our special moles use the same graphics as the standard mole, but we will make them flash a rainbow of colors when they are in the play. It is a small difference, but enough to set up the scoring to give extra points for the "special mole". To implement this special mole, we only need to adjust coding in three logic areas:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When <code class="literal">raiseMole</code> is setting the mole's actions (to make it flashy)</li><li class="listitem" style="list-style-type: disc">When we hit the mole (to play a different sound effect)</li><li class="listitem" style="list-style-type: disc">When we score the mole (to score more points)</li></ul></div><p>This is a very small task, but it is the small variations in the gameplay that will draw the players in further. Let's see the game with a special mole in the play:</p><div><img src="img/9007_03_04.jpg" alt="Special moles"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Moving moles</h2></div></div></div><p>When we call the <a id="id585" class="indexterm"/>
<a id="id586" class="indexterm"/>
<code class="literal">raiseMole</code> method, we build all of the <a id="id587" class="indexterm"/>mole's behavior. The absolute minimum we <a id="id588" class="indexterm"/>need is to raise the mole from the hill and lower it again. For our game, we want to add a little randomness to the behavior, so that we don't see exactly the same motions for every mole. We use a combination of pre-built animations with actions to achieve our result. As we haven't used any <code class="literal">CCAnimate</code> calls before, we should talk about them first.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>The animation cache</h2></div></div></div><p>Cocos2d has many useful caches to store frequently used data. When we use a <code class="literal">CCSpriteBatchNode</code>
<a id="id589" class="indexterm"/>
<a id="id590" class="indexterm"/>, we are using the <a id="id591" class="indexterm"/>
<a id="id592" class="indexterm"/>
<code class="literal">CCSpriteFrameCache</code> to store all of the sprites we need by name. There is an equally useful <code class="literal">CCAnimationCache</code> as well. It is simple to <a id="id593" class="indexterm"/>use. You build your animation as a <code class="literal">CCAnimation</code>, and then load it to the <code class="literal">CCAnimationCache</code> by whatever name you would like.</p><p>When you want to use your named animation, you can create a <code class="literal">CCAnimate</code> action that loads directly from <code class="literal">CCAnimationCache</code>. The only caution is that if you load two animations with the same name to the cache, they will collide in the cache, and the second one will replace the first.</p><p>For our project, we preload the animation during the <code class="literal">init</code> method by calling the <code class="literal">buildAnimations</code> <a id="id594" class="indexterm"/>
<a id="id595" class="indexterm"/>method. We only use one animation here, but you could preload as many as you need to the cache ahead of time.</p><p>
<strong>Filename:</strong> <a id="id596" class="indexterm"/>
<a id="id597" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) buildAnimations {
    // Load the Animation to the CCSpriteFrameCache
    NSMutableArray *frameArray = [NSMutableArray array];
    
    // Load the frames
    [frameArray addObject:[[CCSpriteFrameCache
            sharedSpriteFrameCache]
            spriteFrameByName:@"penguin_forward.png"]];
    [frameArray addObject:[[CCSpriteFrameCache
            sharedSpriteFrameCache]
            spriteFrameByName:@"penguin_left.png"]];
    [frameArray addObject:[[CCSpriteFrameCache
            sharedSpriteFrameCache]
            spriteFrameByName:@"penguin_forward.png"]];
    [frameArray addObject:[[CCSpriteFrameCache
            sharedSpriteFrameCache]
            spriteFrameByName:@"penguin_right.png"]];
    [frameArray addObject:[[CCSpriteFrameCache
            sharedSpriteFrameCache]
            spriteFrameByName:@"penguin_forward.png"]];
    [frameArray addObject:[[CCSpriteFrameCache
            sharedSpriteFrameCache]
            spriteFrameByName:@"penguin_forward.png"]];
    
    // Build the animation
    CCAnimation *newAnim = [CCAnimation
            animationWithSpriteFrames:frameArray delay:0.4];

    // Store it in the cache
    [[CCAnimationCache sharedAnimationCache]
            addAnimation:newAnim name:@"penguinAnim"];
}</pre></div><p>We only have three unique frames of animation, but we load them multiple times into the <code class="literal">frameArray</code> to fit our desired animation. We create a <a id="id598" class="indexterm"/>
<a id="id599" class="indexterm"/>
<code class="literal">CCAnimation</code> object from the <code class="literal">frameArray</code>, and then commit it to <code class="literal">CCAnimationCache</code> under the name <code class="literal">penguinAnim</code>. Now that we have loaded it to the cache, we can reference it <a id="id600" class="indexterm"/>anywhere we want it, just by requesting it from <code class="literal">CCAnimationCache</code>, like this:</p><div><pre class="programlisting">[[CCAnimationCache sharedAnimationCache]
                  animationByName:@"penguinAnim"]]</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Combining actions and animation</h1></div></div></div><p>For the behavior of the moles, we will be combining actions and animation at the same time to give more of a feeling of life to the <a id="id601" class="indexterm"/>
<a id="id602" class="indexterm"/>game. In all, we define six behaviors for a normal mole, and one specific behavior for a special mole.</p><p>
<strong>Filename:</strong> <a id="id603" class="indexterm"/>
<a id="id604" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) raiseMole:(MXMoleHill*)aHill {
  // Grab the mole sprite
  CCSprite *aMole = [[aHill hillMole] moleSprite];
  
    float moleHeight = aMole.contentSize.height;
    
  // Define the hole wobble/jiggle
  CCMoveBy *wobbleHillLeft = [CCMoveBy
            actionWithDuration:.1 position:ccp(-3,0)];
  CCMoveBy *wobbleHillRight =[CCMoveBy
            actionWithDuration:.1 position:ccp(3,0)];
  // Run the actions for the hill
  [[aHill moleHillBottom] runAction:
            [CCSequence actions:wobbleHillLeft,
             wobbleHillRight, wobbleHillLeft,
             wobbleHillRight, nil]];

  // Define some mole actions.
    // We will only use some of them on each mole
  CCMoveBy *moveUp = [CCMoveBy
            actionWithDuration:moleRaiseTime
            position:ccp(0,moleHeight*.8)];
  CCMoveBy *moveUpHalf = [CCMoveBy
            actionWithDuration:moleRaiseTime
            position:ccp(0,moleHeight*.4)];
  CCDelayTime *moleDelay = [CCDelayTime
            actionWithDuration:moleDelayTime];
  CCMoveBy *moveDown = [CCMoveBy
            actionWithDuration:moleDownTime
            position:ccp(0,-moleHeight*.8)];
  CCCallFuncND *delMole = [CCCallFuncND
            actionWithTarget:self
            selector:@selector(deleteMole:data:)
            data:(MXMoleHill*)aHill];
    CCAnimate *anim = [CCAnimate
            actionWithAnimation:[[CCAnimationCache
            sharedAnimationCache]
            animationByName:@"penguinAnim"]];
    CCRotateBy *rot1 = [CCRotateBy
            actionWithDuration:moleDelayTime/3 angle:-20];
    CCRotateBy *rot2 = [CCRotateBy
            actionWithDuration:moleDelayTime/3 angle:40];
    CCRotateBy *rot3 = [CCRotateBy
            actionWithDuration:moleDelayTime/3 angle:-20];

    // We have 6 behaviors to choose from. Randomize.
    NSInteger behaviorPick = CCRANDOM_0_1() * 6;
    
    // If this is a special mole, let's control him better
    if ([aHill hillMole].isSpecial) {

        // Build some more actions for specials
        CCTintTo *tintR = [CCTintTo actionWithDuration:0.2
                        red:255.0 green:0.2 blue:0.2];
        CCTintTo *tintB = [CCTintTo actionWithDuration:0.2
                        red:0.2 green:0.2 blue:255.0];
        CCTintTo *tintG = [CCTintTo actionWithDuration:0.2
                        red:0.2 green:255.0 blue:0.2];
        
        // Set a color flashing behavior
        [aMole runAction:[CCRepeatForever
                actionWithAction:[CCSequence actions:
                tintR, tintB, tintG, nil]]];
        // Move up and down and rotate/wobble
        [aMole runAction:[CCSequence actions:moveUp, rot1,
                rot2, rot3, rot1, rot2, rot3, moveDown,
                delMole, nil]];
    } else {
        switch (behaviorPick) {
            case 1:
                // Move up and down and rotate/wobble
                [aMole runAction:[CCSequence actions:
                    moveUp, rot1, rot2, rot3, moveDown,
                    delMole, nil]];
                break;
            case 2:
                // Move up and then down without pausing
                [aMole runAction:[CCSequence actions:
                    moveUp, moveDown, delMole, nil]];
                break;
            case 3:
                // Move up halfway and then down
                [aMole runAction:[CCSequence actions:
                    moveUpHalf, moleDelay, moveDown,
                    delMole, nil]];
                break;
            case 4:
                // Move up halfway and then down, no pause
                [aMole runAction:[CCSequence actions:
                    moveUpHalf, moveDown, delMole, nil]];
                break;
            case 5:
                // Move up halfway, look around, then down
                [aMole runAction:[CCSequence actions:
                    moveUpHalf, anim, moveDown, delMole,
                    nil]];
                break;
            default:
                // Play the look around animation
                [aMole runAction:anim];
                // Move up and down
                [aMole runAction:[CCSequence actions:
                    moveUp, moleDelay, moveDown, delMole,
                    nil]];
                break;
        }
    }
}</pre></div><p>This method takes one big shortcut to keep from repeating code. We define nine separate actions for a standard mole, even though we will not use them all on the same mole. We do this because there is a lot of overlap between the different behaviors, and we don't want to repeat the same line of code again and again. If we look at just two of the actions, <code class="literal">moveUp</code> and <code class="literal">moveUpHalf</code>, half of the mole behaviors use the first, and half use the second. Instead of the path we have taken here, the alternative would be to include seven individual <a id="id605" class="indexterm"/>
<a id="id606" class="indexterm"/>
<code class="literal">CCMoveBy</code> definitions in this method to accommodate the six normal mole move up behaviors plus the special mole behavior. On the surface this isn't a big concern, but it does matter if we wanted to alter the behavior of how far a mole is raised up from the <a id="id607" class="indexterm"/>
<a id="id608" class="indexterm"/>
<code class="literal">moveUp</code> action, we would have to change that in four places. If we only defined the necessary actions after the behavior was determined, this would mean 31 lines to maintain instead of our current 9 lines. If performance is not negatively affected, it is a good idea to always take the maintainable approach.</p><p>We also define the special mole behavior <a id="id609" class="indexterm"/>
<a id="id610" class="indexterm"/>in this method. If the <code class="literal">isSpecial</code> flag is set, we use one set behavior, in two distinct actions. The <code class="literal">CCRepeatForever</code> action loops <a id="id611" class="indexterm"/>
<a id="id612" class="indexterm"/>over our tinting, which tints the mole to red, then blue, and then green. At the same time, we are also running <code class="literal">CCSequence</code> of <code class="literal">moveUp</code>, rotating side to side a couple of times, and then moving it down again.</p><p>For a standard mole, we use a similar parallel action in the default section of the <code class="literal">switch</code> statement. We play the animation (named <code class="literal">anim</code>), which does not impact the moving up and down run by the second <a id="id613" class="indexterm"/>
<a id="id614" class="indexterm"/>
<code class="literal">runAction</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Simultaneous actions</h2></div></div></div><p>This running of multiple simultaneous actions is a source of confusion for new developers. Some actions cannot be run in parallel in this fashion. For example, trying to run <a id="id615" class="indexterm"/>
<a id="id616" class="indexterm"/>
<code class="literal">CCMoveTo</code> and <a id="id617" class="indexterm"/>
<a id="id618" class="indexterm"/>
<code class="literal">CCMoveBy</code> at the same time will result in only the second run action being run. Why? Both are affecting the position of the sprite, and are therefore incompatible. The last one that is run "wins" and the former is discarded. Earlier we were able to run <a id="id619" class="indexterm"/>
<a id="id620" class="indexterm"/>
<code class="literal">CCTintTo</code> at the same time as a full <code class="literal">CCSequence</code> of movement and rotation actions. None of these other commands affected the color of the sprite, so they were able to be run in parallel.</p><p>When developing more complex sets of actions, it is important to evaluate what the desired outcome is, and which actions could conflict. A good rule of thumb is that you cannot run two of the "same" action on the "same" sprite at the "same" time. If you need to use two <code class="literal">CCMoveBy</code> statements, for example, you either need to chain them with <code class="literal">CCSequence</code> <a id="id621" class="indexterm"/>
<a id="id622" class="indexterm"/>so they will run in order, or you need to revise your logic to combine the parameters so you can make a single <code class="literal">CCMoveBy</code> action that integrates both.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>The final level of complexity would be to abandon actions for that behavior and instead manually change the positioning in your <code class="literal">update</code> method. This is powerful, but nothing we need to delve into at this time.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Deleting moles</h2></div></div></div><p>At the end of all of the mole actions, there was a <a id="id623" class="indexterm"/>
<a id="id624" class="indexterm"/>
<code class="literal">CCCallFuncND</code> action named <a id="id625" class="indexterm"/>
<a id="id626" class="indexterm"/>
<code class="literal">delMole</code> called. <code class="literal">CCCallFuncND</code> is a very powerful action, yet it is extremely simple at the same time. This action is used to call any selector and pass <a id="id627" class="indexterm"/>any data object to it. In our case, <a id="id628" class="indexterm"/>we call the <code class="literal">deleteMole:data:</code> method, and pass it a pointer to the current <code class="literal">MXMoleHill</code>. Using <code class="literal">CCCallFuncND</code> (and its similar brethren <code class="literal">CCCallFunc</code> and <code class="literal">CCCallFuncN</code>), you can integrate other methods into an action sequence.</p><p>
<strong>Filename:</strong> <a id="id629" class="indexterm"/>
<a id="id630" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void)deleteMole:(id)sender data:(MXMoleHill*)moleHill {
  molesInPlay--;
  [self resetMole:moleHill];
}</pre></div><p>Because we implemented the "blank mole" model into our design, we aren't actually deleting the moles. We reduce the counter <a id="id631" class="indexterm"/>
<a id="id632" class="indexterm"/>
<code class="literal">molesInPlay</code> and call the method to reset the mole to become a "blank mole". This is the same <a id="id633" class="indexterm"/>
<a id="id634" class="indexterm"/>
<code class="literal">resetMole</code> we called when we first created the "blank moles" in the beginning.</p><p>
<strong>Filename:</strong> <a id="id635" class="indexterm"/>
<a id="id636" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) resetMole:(MXMoleHill*)moleHill {
  // Reset all mole-related values.
  // This allows us to keep reusing moles in the hills
  [[moleHill hillMole] stopAllActions];
  [[[moleHill hillMole] moleSprite]
                        removeFromParentAndCleanup:NO];
  [[moleHill hillMole] setMoleGroundY:0.0f];	  
  [[moleHill hillMole] setMoleState:kMoleDead];
  [[moleHill hillMole] setIsSpecial:NO];
  [moleHill setIsOccupied:NO];
}</pre></div><p>That's all it takes to completely clean a mole when we're ready to make a "blank mole" out of it. We reset everything to default values, and we <a id="id637" class="indexterm"/>remove the sprite <a id="id638" class="indexterm"/>attached to it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Touching moles</h1></div></div></div><p>By this point, we have moles that can be <a id="id639" class="indexterm"/>spawned, <a id="id640" class="indexterm"/>animated, and reset. What about the real fun, the mole thumping? For that, we look at the <a id="id641" class="indexterm"/>
<a id="id642" class="indexterm"/>
<code class="literal">MXMole.m</code> file, where all of the mole touch handling is coded:</p><p>
<strong>Filename:</strong> <code class="literal">MXMole.m</code>
</p><div><pre class="programlisting">#import "MXMole.h"

@implementation MXMole

@synthesize parentHill;
@synthesize moleSprite;
@synthesize moleGroundY;
@synthesize moleState = _moleState;
@synthesize isSpecial;

-(id) init {
    if(self = [super init]) {
            self.moleState = kMoleDead;
            [[[CCDirector sharedDirector] touchDispatcher]
                    addTargetedDelegate:self priority:0
                    swallowsTouches:NO];
    }
  return self;  
}

- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {
    CGPoint location = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:location];
    
    if (self.moleState == kMoleDead) {
        return NO;
    } else if (self.moleSprite.position.y +
               (self.moleSprite.contentSize.height/2)
               &lt;= moleGroundY) {
    self.moleState = kMoleHidden;
    return NO;
  } else  {
        // Verify touch was on this mole and above ground
        if (CGRectContainsPoint(self.moleSprite.boundingBox,
                                convLoc) &amp;&amp;
            convLoc.y &gt;= moleGroundY)
        {
            // Set the mole's state
            self.moleState = kMoleHit;
            
            // Play the "hit" sound
            if (isSpecial) {
                [[SimpleAudioEngine sharedEngine]
                        playEffect:SND_MOLE_SPECIAL];
            } else {
                [[SimpleAudioEngine sharedEngine]
                        playEffect:SND_MOLE_NORMAL];
            }
        }
        return YES;
    }
}

-(void) destroyTouchDelegate {
    [[[CCDirector sharedDirector] touchDispatcher]
                        removeDelegate:self];
}

@end</pre></div><p>We have registered the <a id="id643" class="indexterm"/>
<a id="id644" class="indexterm"/>
<code class="literal">MXMole</code> class with the <a id="id645" class="indexterm"/>
<a id="id646" class="indexterm"/>
<code class="literal">CCTouchDispatcher</code> as a Targeted Delegate. This means that the mole will be notified of every touch individually. As we are looking for a single touch per mole, this is perfect for our needs. We registered with the dispatcher in the <code class="literal">init</code> method, and we built the matching <a id="id647" class="indexterm"/>
<a id="id648" class="indexterm"/>
<code class="literal">destroyTouchDelgate</code> method, which is called in the <a id="id649" class="indexterm"/>
<a id="id650" class="indexterm"/>
<code class="literal">dealloc</code> method of <code class="literal">MXPlayfieldLayer</code>. If we don't remove the delegate, the mole will be a leaked object and will cause memory issues.</p><p>When the game design was reviewed at the beginning <a id="id651" class="indexterm"/>of the chapter, we discussed the approach we would take with the Z-order "trick" to make the mole disappear when it went <a id="id652" class="indexterm"/>behind the ground image. If we left it at that, there would be a serious gameplay flaw. The normal touch handling would also accept the touch when the mole was touched below the ground level. How do we fix this?</p><p>Correcting this issue is the reason we created the <a id="id653" class="indexterm"/>
<a id="id654" class="indexterm"/>
<code class="literal">moleGroundY</code> variable. When we spawn a new mole, we set this variable to match the molehill's <code class="literal">y</code> position. Since we also use the molehill's <code class="literal">y</code> value in the placement of the molehill graphics, this represents the exact <code class="literal">y</code> position where the mole emerges from the ground. In our <code class="literal">ccTouchBegan</code> <a id="id655" class="indexterm"/>
<a id="id656" class="indexterm"/>method inside the <code class="literal">MXMole</code> class, we only accept the touch if the mole is being touched and the touch has a <code class="literal">y</code> value greater than or equal to the <code class="literal">moleGroundY</code> position. This will effectively limit the touched mole parts to those above ground level. (It's not pixel-perfect, because the <a id="id657" class="indexterm"/>
<a id="id658" class="indexterm"/>
<code class="literal">moleHillBottom</code> sprite has a few pixels above this "horizon" line, but it is so small a coordinate variation that it does not affect the playability of the game).</p><p>When the mole is touched, it changes the <a id="id659" class="indexterm"/>
<a id="id660" class="indexterm"/>
<code class="literal">moleState</code> variable to a <a id="id661" class="indexterm"/>value of <a id="id662" class="indexterm"/>
<a id="id663" class="indexterm"/>
<code class="literal">kMoleHit</code> and plays a sound.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Tying it together</h1></div></div></div><p>There are only two important methods left to review to tie this all together. First is the <code class="literal">update</code> method. Let's look at the applicable portions of the <code class="literal">update</code> method (we have left placeholders for the other portions of the <a id="id664" class="indexterm"/>
<a id="id665" class="indexterm"/>
<code class="literal">update</code> method, but those will not be <a id="id666" class="indexterm"/>addressed here. Please refer the code bundle for this book to see those details):</p><p>
<strong>Filename:</strong> <a id="id667" class="indexterm"/>
<a id="id668" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void)update:(ccTime)dt {
  
  for (MXMoleHill *aHill in moleHillsInPlay) {
        
    if (aHill.hillMole.moleState == kMoleHit) {
            [[aHill hillMole] setMoleState:kMoleMoving];
      [self scoreMole:[aHill hillMole]];
    }
  }
    
    if (molesInPlay &lt; maxMoles &amp;&amp; spawnRest &gt; 10) {
        [self spawnMole:self];
        spawnRest = 0;
    } else {
        spawnRest++;
    }
    
    // Update the timer value &amp; display
    // Protection against overfilling the timer

    // Update the timer visual

    // Game Over / Time's Up
}</pre></div><p>On every loop of the <code class="literal">update</code> method, we iterate through the <a id="id669" class="indexterm"/>
<a id="id670" class="indexterm"/>
<code class="literal">moleHillsInPlay</code> array. We check each mole to see if we have one in the <code class="literal">kMoleHit</code> state. If a hit mole is found, we change the state of that mole to <code class="literal">kMoleMoving</code>, and call the <code class="literal">scoreMole</code> method. As we only set the <code class="literal">moleState</code> to <code class="literal">kMoleHit</code> within the touch handler, and then immediately change it to <code class="literal">kMoleMoving</code> when we first trap it in this loop, we can be assured that this is the first (and only) time we have seen this particular scoring event. If we did not change the <code class="literal">moleState</code> here, we would trigger <code class="literal">scoreMole</code> every time the <code class="literal">update</code> method ran, and the game would grind to a halt.</p><p>The second section of the <code class="literal">update</code> method controls the spawning of new moles. As we want to have a little delay between new moles being created, we use the <a id="id671" class="indexterm"/>
<a id="id672" class="indexterm"/>
<code class="literal">spawnRest</code> variable to act as a timer to leave at least 10 update loops between calls to <a id="id673" class="indexterm"/>
<a id="id674" class="indexterm"/>
<code class="literal">spawnMole</code>. We also make sure we don't have the maximum number of desired moles in the play already. Combined, these two simple checks provide a very natural spawn feeling. The <a id="id675" class="indexterm"/>player is never bored waiting for moles to spawn, and the moles themselves don't appear in any synchronized pattern.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Scoring the mole</h2></div></div></div><p>We haven't addressed the details of the scoring system <a id="id676" class="indexterm"/>because it is trivially simple. <a id="id677" class="indexterm"/>There is a variable called <a id="id678" class="indexterm"/>
<a id="id679" class="indexterm"/>
<code class="literal">playerScore</code>, and a label that displays that score. (For details on the scoring, please see the code bundle for this book.) In this game, the more interesting aspect of "scoring the mole" is the visual way we show that it was scored.</p><p>
<strong>Filename:</strong> <a id="id680" class="indexterm"/>
<a id="id681" class="indexterm"/>
<code class="literal">MXPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) scoreMole:(MXMole*)aMole {
  // Make sure we don't have a dead mole
  if (aMole.moleState == kMoleDead) {
    return;
  }
    
  // Get the hill
  MXMoleHill *aHill = [aMole parentHill];
  
    // Add the score
    if (aMole.isSpecial) {
        // Specials score more points
        playerScore = playerScore + 5;
        // You get 5 extra seconds, too
        [self addTimeToTimer:5];
    } else {
        // Normal mole.  Add 1 point.
        playerScore++;
    }

    // Update the score display
    [self updateScore];

    // Set up the mole's move to the score
    CCMoveTo *moveMole = [CCMoveTo actionWithDuration:0.2f
            position:[self scorePosition]];
    CCScaleTo *shrinkMole = [CCScaleTo
            actionWithDuration:0.2f scale:0.5f];
    CCSpawn *shrinkAndScore = [CCSpawn
            actionOne:shrinkMole two:moveMole];
    CCCallFuncND *delMole = [CCCallFuncND
            actionWithTarget:self
            selector:@selector(deleteMole:data:)
            data:(MXMoleHill*)aHill];
    
    [aHill.hillMole.moleSprite stopAllActions];
    [aHill.hillMole.moleSprite runAction:[CCSequence
            actions: shrinkAndScore, delMole,  nil]];
}</pre></div><p>Most of this code should look familiar by now. After a "safety net" check to prevent scoring a dead mole, we increment the score itself. After we update the score, we build some new actions to move the mole to the score location, scale it down, and then delete it when we're done.</p><p>Here we see one type of action we haven't touched on before: <a id="id682" class="indexterm"/>
<a id="id683" class="indexterm"/>
<code class="literal">CCSpawn</code>. Despite the name, it is completely unrelated to the mole spawning we built in this game. Instead, a <code class="literal">CCSpawn</code> action allows two actions to be performed on the same target at the same time. This is an alternate behavior compared to <a id="id684" class="indexterm"/>
<a id="id685" class="indexterm"/>
<code class="literal">CCSequence</code>, which will run the actions one at a time. For our use, we want the sprite to move and scale down by 50 percent at the same time. There are a couple of limitations of <code class="literal">CCSpawn</code>. The first is that <a id="id686" class="indexterm"/>it must be a finite interval action. No <a id="id687" class="indexterm"/>
<a id="id688" class="indexterm"/>
<code class="literal">CCRepeatForever</code> actions can be used inside a <code class="literal">CCSpawn</code>, for example. The other limitation is that both actions inside the <code class="literal">CCSpawn</code> action should have the same duration. If their duration is different, it will run until the longer of the two actions is complete. With that in mind, we set the duration for both the <code class="literal">CCMoveTo</code> and <code class="literal">CCScaleTo</code> actions to <code class="literal">0.2f</code> so the move and scale is quick and pleasant.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Summary</h1></div></div></div><p>We have navigated the challenges of a mole thumping game, and survived intact. In this chapter we have covered a few interesting concepts. We learned how to use Z-ordering to trick the eye. We created persistent objects that can be reused (the moles). We have also worked with using instances of <code class="literal">CCNode</code> as containers for other objects for both the molehills and the moles. We have spent considerable time discussing actions and animations, both of which are core to a successful cocos2d game design.</p><p>In the next chapter, we will explore a snake game. From snakes eating mice to scaling difficulty levels, the chapter will cover some familiar ground and some new terrain.</p></div></body></html>