<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Web Programming with Spring for Kotlin Developers</h1>
                </header>
            
            <article>
                
<p>Kotlin is a powerful language, and its power increases, even more, when the Spring Framework is used with it. Up until this point, you've learned the concepts of reactive programming and how to apply these concepts to Kotlin. So far, we developed and wrote code that interacts with the console, but that's not what we will do while developing professional apps. We will either build apps that will run on mobile devices or we will build web applications or REST APIs. At least those are the most commonly built professional software solutions.</p>
<p>So, how to build them? How to create RESTful web APIs and Android apps? Let's discover. The last three chapters of this book are dedicated to building REST APIs and Android apps and, most importantly, making them reactive. Spring is such a vast topic that covering it in a single chapter is simply not possible, so we will have two chapters on Spring.</p>
<p>This chapter will start by introducing you to Spring, and, by the end of this chapter, you should be proficient enough to write REST APIs in Kotlin with Spring. We will not add reactive features in this chapter because we don't want to distract you from the concepts and ideas of Spring. We want you to grasp the concepts and knowledge of Spring itself well enough before moving ahead with making them reactive.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to Spring, history, and origin of Spring</li>
<li>Spring IoC and dependency injection</li>
<li>Aspect-oriented programming in Spring</li>
<li>Introduction to Spring Boot</li>
<li>Building REST APIs with Spring Boot</li>
</ul>
<p>So, what are we waiting for? Let's get started and get familiar with Spring.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring, history, and origin of Spring</h1>
                </header>
            
            <article>
                
<p>What is Spring? We cannot give a short answer. It's really tough to define Spring in a sentence or two. Many people may say Spring is a framework, but this would be also an understatement for Spring, as it may also be called a <strong>framework of frameworks</strong>. Spring provides you with a lot of tools, such as <strong>DI</strong> (<strong>dependency injection</strong>), <strong>IoC</strong> (<strong>Inversion of Control</strong>), and <strong>AOP</strong> (<strong>Aspect-oriented programming</strong>). While we can use Spring in almost any type of Java or Kotlin JVM application, it is most useful while developing web applications on top of the Java EE platform. Before moving into the details of Spring, we should first understand from where and why Spring originated and how it has evolved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The origin and history of Spring</h1>
                </header>
            
            <article>
                
<p>It has been more than two decades (around 22 years) since Java has been around. For enterprise application development, Java introduced a few technologies that were heavyweight and were very complex enough.</p>
<p>In 2003, Rod Johnson created Spring as an alternative to the heavyweight and complex Enterprise Java Technologies and EJB to make it easy to develop enterprise applications in Java. Being lightweight, flexible, and easy to use, Spring gained popularity soon. Over time, EJB and Java Enterprise Edition (then J2EE) evolved to support POJO-oriented programming models such as Spring. Not only that, arguably inspired by Spring, EJB also started offering AOP, DI, and IoC.</p>
<p>However, Spring never looked back. As EJB and Java EE started including ideas inspired by Spring, Spring started exploring more unconventional and unexplored technology areas, such as Big Data, Cloud Computing, Mobile App Development, and even reactive programming, leaving EJB and Java EE far behind.</p>
<p>During the start of the year, on the month of January 2017, Spring surprised everyone by announcing its support for Kotlin (yes, they announced Kotlin support even before Google) and released a few Kotlin APIs. And, when the power of Kotlin was combined with an already powerful Spring Framework, both got even more powerful. As a reason behind adding Kotlin support, they stated:</p>
<div class="packt_quote">One of the key strengths of Kotlin is that it provides a very good interoperability with libraries written in Java. But there are ways to go even further and allow writing fully idiomatic Kotlin code when developing your next Spring application. In addition to Spring Framework support for Java 8 that Kotlin applications can leverage like functional web or bean registration APIs, there are additional Kotlin dedicated features that should allow you to reach a new level of productivity.<br/>
That's why we are introducing a dedicated Kotlin support in Spring Framework 5.0.</div>
<p style="padding-left: 30px">By Pivotal Spring Team <span class="URLPACKT"><a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0</a>.</span></p>
<p>So, let's start by creating and setting up our Spring project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection and IoC</h1>
                </header>
            
            <article>
                
<p><strong>Inversion of Control</strong> (<strong>IoC</strong>) is a programming technique in which object coupling is bound at runtime by an assembler object and is typically not known at compile time using static analysis. IoC can be achieved using dependency injection. We can say that IoC is the idea and dependency injection is its implementation. Now, what is dependency injection? Let's find out.</p>
<p>Dependency injection is a technique where one component supplies dependencies for another component during the instantiation time. The definition sounds confusing, right? Let's explain it with an example. Consider the following interfaces:</p>
<pre>    interface Employee { 
      fun executeTask() 
    } 
    interface Task { 
      fun execute() 
    } </pre>
<p>A common implementation of the preceding program will be as follows.</p>
<p>The <kbd>Employee</kbd> class is as follows:</p>
<pre>    class RandomEmployee: Employee { 
      val task = RandomTask() 
      override fun executeTask() { 
        task.execute() 
      } 
    } </pre>
<p>And the <kbd>Task</kbd> interface <span>is imp</span><span>lemented as follows</span>:</p>
<pre>    class RandomTask : Task { 
      override fun execute() { 
        println("Executing Random Task") 
      } 
    } </pre>
<p>Then, we will create and use the instance of the <kbd>RandomEmployee</kbd> class in the <kbd>main</kbd> method as follows:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      RandomEmployee().executeTask() 
    } </pre>
<p>The <kbd>RandomTask</kbd> class is a simple class implementing an interface <kbd>Task</kbd>, which has a function named <kbd>execute</kbd>. The <kbd>RandomEmployee</kbd> class on the other hand depends on the <kbd>Task</kbd> class. Now, what do we mean by depends? By depends, we mean that the output of an instance of <kbd>Employee</kbd> class is dependent on the <kbd>Task</kbd> class.</p>
<p>Let's take a look at the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="94" width="428" src="assets/a2d67e5c-78c5-46bb-b82c-5e6c33cfb86f.jpg"/></div>
<p>The preceding program would work fine, and actually, it is a text book program. In colleges/institutes, when we learned coding for the first time, we learned the way to initialize variables and/or properties inside constructors or during construction time.</p>
<p>Now, just try to remember what you learned a few chapters earlier. We should test everything we write. Now, take a look at the code again—is this piece of code testable? Or even maintainable? How would you assure that the right <em>Employee</em> is given the right <em>Task</em>? It's a tightly coupled code.</p>
<p>You should always use coupling concisely. It's true that we cannot achieve much without coupling. Tightly coupled code, on the other hand, makes it difficult to test and maintain.</p>
<p>Rather than letting the objects create their dependencies at the construction time, dependency injection provides objects with their dependencies at creation time with some third-party class. That third-party class will also coordinate with each object in the system. The following diagram shows the general idea behind dependency injection:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="389" width="535" src="assets/d639a1d5-8324-4935-ad92-01867c099882.jpg"/></div>
<p>This image clearly depicts the flow of dependency injection. There will be a <span class="packt_screen">Config</span> class (in Spring, there can be an XML <span class="packt_screen">Config</span> file or there can be a <span class="packt_screen">Config</span> class as well) that will create and drive a <span class="packt_screen">Bean Container</span>. That <span class="packt_screen">Bean Container</span> will control the creation of beans or POJOs and will pass them where required.</p>
<p>Confused? Let's get our hands-on code and implement the preceding concept. Let's get started with a brand new implementation of the <kbd>Employee</kbd> interface as follows:</p>
<pre>    class SoftwareDeveloper(val task: ProgrammingTask) : Employee { 
      override fun executeTask() { 
        task.execute() 
      } 
    } </pre>
<p>A <kbd>SoftwareDeveloper</kbd> class  can only execute <kbd>ProgrammingTask</kbd>. Now, take a look at the XML <kbd>config</kbd> file shown next:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
        
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 
 
      &lt;bean id="employee"  <br/>       class="com.rivuchk.reactivekotlin.springdi.SoftwareDeveloper"&gt; 
       &lt;constructor-arg ref="task"/&gt; 
      &lt;/bean&gt; 
 
      &lt;bean id="task" class="com.rivuchk.reactivekotlin.<br/>      springdi.ProgrammingTask"/&gt; 
 
   &lt;/beans&gt; </pre>
<p>The <kbd>ProgrammingTask</kbd> class, a new implementation of the <kbd>Task</kbd> interface, looks like as follows:</p>
<pre>class ProgrammingTask: Task {<br/>    override fun execute() {<br/>        println("Writing Programms")<br/>    }<br/>}</pre>
<p>This file should be located at <kbd>\src\main\resources\META-INF\employee.xml</kbd>. Now, let's try to understand the <kbd>config</kbd> file. We declared each bean using the <kbd>bean</kbd> tag. Then, we used the <kbd>constructor-arg</kbd> tag to indicate a constructor argument in that bean.</p>
<p>If you want to pass another object as a <kbd>constructor-argref</kbd> in a bean, you have to declare that reference object as a bean as well. Alternatively, you can pass <kbd>constructor-arg value</kbd>, as discussed later in this chapter.</p>
<p>The updated <kbd>main</kbd> function will look like this:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
<strong>      val context = ClassPathXmlApplicationContext(</strong><strong> <br/>        "META-INF/spring/employee.xml")//(1)</strong><strong>    val employee =  <br/>        context.getBean(Employee::class.java)//(2)</strong> 
        employee.executeTask() 
<strong>        context.close()//(3)</strong> 
    } </pre>
<p>Before moving into the details of the preceding program, let's take a look at its output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="183" width="281" src="assets/d986c93d-2532-4879-87d2-80aeff45e8b8.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Cropped output of DI with XML Configuration program</div>
<p>The first few red-lined outputs are logs of the Spring Framework. Then, we can spot the output as <span class="packt_screen">Writing Programms</span>.</p>
<p>Now, let's try to understand the program. The <kbd>ClassPathXmlApplicationContext</kbd> is the <span class="packt_screen">Bean Container</span> we mentioned in the figure. It creates and keeps record of all the beans mentioned in the XML file and provides them to us when asked for. The <kbd>String</kbd> passed in the constructor of <kbd>ClassPathXmlApplicationContext</kbd> is the relative path to the XML configuration file.</p>
<p>On comment <kbd>(2)</kbd>, we used <kbd>context.getBean()</kbd> to get the <kbd>Employee</kbd> instance. This function takes a class name as a parameter and creates an instance of that class based on the XML configuration.</p>
<p>On comment <kbd>(3)</kbd>, we closed the <kbd>context</kbd>. The <kbd>context</kbd>, as a <span class="packt_screen">Bean Container</span>, always carries the configuration for you, which keeps the memory blocked. In order to clean the memory, we should close the <kbd>context</kbd>.</p>
<p>Now, as we have some idea about dependency injection via XML configuration file, we should move toward the annotation-based configuration class and take a look at how it works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Annotation configuration</h1>
                </header>
            
            <article>
                
<p>Other than XML, we can also define Spring configuration through annotations in a POJO class, which will not be used as a bean. In the previous section, we took <kbd>Employee</kbd> task example; let's now take the <kbd>Student</kbd>-<kbd>Assignment</kbd> example, a similar one. However, this time, we will not use interfaces; instead, we will directly use classes.</p>
<p>So, here is the <kbd>Assignment</kbd> class that takes a lambda as a constructor parameter:</p>
<pre>    class Assignment(val task:(String)-&gt;Unit) { 
      fun performAssignment(assignmentDtl:String) { 
        task(assignmentDtl) 
      } 
    } </pre>
<p>This class takes a lambda as <kbd>task</kbd>, to execute it later, inside the <kbd>performAssignment()</kbd> method. Here is the <kbd>Student</kbd> class that takes <kbd>Assignment</kbd> as a property:</p>
<pre>    class Student(val assignment: Assignment) { 
      fun completeAssignment(assignmentDtl:String) { 
        assignment.performAssignment(assignmentDtl) 
      } 
    } </pre>
<p>So, <kbd>Student</kbd> would depend on its <kbd>Assignment</kbd> and an <kbd>Assignment</kbd> would depend on its task definition (Lambda). The following diagram describes the dependency flow for this example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="249" width="381" src="assets/7d938d44-b837-40cc-b715-ee0d9190c556.png"/></div>
<p>How to depict this dependency flow in code? It's easy with Annotation Config. Here is the <kbd>Configuration</kbd> class that we used:</p>
<pre>    @Configuration 
    class Configuration { 
 
      @Bean 
      fun student() = Student(assignment()) 
 
      @Bean 
      fun assignment()  
        = Assignment { assignmentDtl -&gt; println<br/>        ("Performing Assignment $assignmentDtl") } 
   } </pre>
<p>Simple and straightforward, isn't it? The class is annotated with <kbd>@Configuration</kbd>, and the function to return the <kbd>Student</kbd> and <kbd>Assignment</kbd> beans is annotated with <kbd>@Bean</kbd>.</p>
<p>Now, how to use this class? Simple, like the previous one, take a look at the <kbd>main</kbd> function here:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val context = AnnotationConfigApplicationContext   <br/>      (Configuration::class.java) 
      val student = context.getBean(Student::class.java) 
      student.completeAssignment("One") 
      student.completeAssignment("Two") 
      student.completeAssignment("Three") 
 
      context.close() 
    } </pre>
<p>Instead of <kbd>ClassPathXmlApplicationContext</kbd>, we used <kbd>AnnotationConfigApplicationContext</kbd> and passed the <kbd>Configuration</kbd> class. The rest of the program is the same.</p>
<p>This is the output of the program:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="205" width="321" src="assets/c62a0eb0-8c8e-46fc-8bd2-93ccd9dce3ae.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Cropped output of DI with Annotation Configuration program</div>
<p>So, we learned dependency injection with Spring. It's really easy, isn't it? Actually, the Spring Framework makes everything easy; whatever feature they offer, they make it as easy as calling a method from a POJO class. Spring truly utilizes the power of a POJO.</p>
<p>So, as we got our hands on dependency injection, let's move forward with Aspect-oriented programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring – AOP</h1>
                </header>
            
            <article>
                
<p>Before learning how to implement Aspect-oriented programming with Spring, we should first learn what Aspect-oriented programming is. The definition of Aspect-oriented programming says it is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself.</p>
<p>Now, what did we mean by cross-cutting concerns? Let's explore.</p>
<p>In a real-life project, multiple components play their own role. For example, if we take our previous scenario into account, the <kbd>Student</kbd> class itself is a component, similarly there could be a faculty component who would evaluate the student based on his/her performance. So, let's add a faculty to our program.</p>
<p>The <kbd>Faculty</kbd> class should be simple enough, with just a method to evaluate a student. Just as follows:</p>
<pre>    class Faculty { 
      fun evaluateAssignment() { 
        val marks = Random().nextInt(10) 
        println("This assignment is evaluated and given $marks points") 
      } 
    } </pre>
<p>Now, how should the faculty grade a student? He/she must somehow know that the student has completed an assignment. A common implementation of this business logic would be by modifying the <kbd>Student</kbd> class, as follows:</p>
<pre>    class Student(val assignment: Assignment, 
      val faculty: Faculty) { 
        fun completeAssignment(assignmentDtl:String) { 
          assignment.performAssignment(assignmentDtl) 
          faculty.evaluateAssignment() 
        } 
      } </pre>
<p>The <kbd>Faculty</kbd> instance will be passed to a <kbd>Student</kbd> instance, and, once the student is done with performing the assignment, it will call the <kbd>Faculty</kbd> instance and instruct it to evaluate the assignment. However, think again. Is this a proper implementation? Why should a student instruct his/her faculty? It's the faculty's job to evaluate assignments of a student; it just needs to get notified somehow.</p>
<p>That very thing is known as a cross-cutting concern. <kbd>Faculty</kbd> and <kbd>Student</kbd> are different components of the program. They shouldn't have direct interaction at the time of the assignment review.</p>
<p>AOP let's implement the same. So, here, the <kbd>Student</kbd> class will be back to almost its original state:</p>
<pre>    open class Student(public val assignment: Assignment) { 
      open public fun completeAssignment(assignmentDtl:String) { 
        assignment.performAssignment(assignmentDtl) 
      } 
    } </pre>
<p>Did you notice the differences in the actual code for the <kbd>Student</kbd> class in the previous section? Yes, here we added <kbd>open</kbd> keyword to the class declaration and all the properties and functions of the class. The reason is that, to implement AOP, Spring sub-classes our beans and overrides methods (including getters of our properties). However, with Kotlin, everything is final unless you specify it as open, and that will block Spring AOP to accomplish its purpose. So, in order to make Spring work, we have to mention each property and method as open.</p>
<p>The <kbd>main</kbd> method will be similar, except that we are back to XML-based configuration. Take a look at the following piece of code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val context = ClassPathXmlApplicationContext( 
            "META-INF/spring/student_faculty.xml" 
      ) 
      val student = context.getBean(Student::class.java) 
      student.completeAssignment("One") 
      student.completeAssignment("Two") 
      student.completeAssignment("Three") 
 
      context.close() 
    } </pre>
<p>The only file with new things is the configuration file. Take a look at the configuration file <span>here </span>before we explain it:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
          <br/>        
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd <br/>       http://www.springframework.org/schema/aop <br/>       http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; 
 
    &lt;bean id="student" class="com.rivuchk.reactivekotlin.<br/>      springdi.aop_student_assignment.Student"&gt; 
      &lt;constructor-arg ref="assignment"/&gt; 
    &lt;/bean&gt; 
 
    &lt;bean id="assignment" class="com.rivuchk.reactivekotlin.springdi.<br/>     aop_student_assignment.Assignment" /&gt; 
 
<strong>    &lt;bean id="faculty"    <br/>    class="com.rivuchk.reactivekotlin.springdi.aop_student_assignment.<br/>    Faculty" /&gt;&lt;!--1--&gt;</strong><strong>    &lt;aop:config&gt;&lt;!--2--&gt;</strong><strong>        &lt;aop:aspect  <br/>    ref="faculty"&gt;&lt;!--3--&gt;</strong><strong>            &lt;aop:pointcut </strong><strong>                     <br/>    id="assignment_complete" </strong><strong>                     <br/>    expression="execution(* *.completeAssignment(..))"/&gt;&lt;!--4--&gt;</strong><strong>              <br/>    &lt;aop:after</strong><strong>                    pointcut-ref="assignment_complete"</strong><strong>                    <br/>    method="evaluateAssignment" /&gt;&lt;!--5--&gt;</strong> 
    &lt;/aop:aspect&gt; 
    &lt;/aop:config&gt; 
 
   &lt;/beans&gt; </pre>
<p>So, let's explain the configuration. On comment <kbd>(1)</kbd>, we declared a new bean named <kbd>faculty</kbd>, although it really isn't a new thing to you and you may have already expected it. I mentioned it in order to prepare you for the next few lines.</p>
<p>On comment <kbd>(2)</kbd>, we indicated that the AOP configuration begins. On comment <kbd>(3)</kbd>, we indicated that this AOP is regarding the <kbd>Faculty</kbd> class, as the <kbd>Faculty</kbd> class is the class that should be notified.</p>
<p>On comment <kbd>(4)</kbd>, we declared <kbd>pointcut</kbd>. A <kbd>pointcut</kbd> is like a bookmark on a method, so whenever that method is called, your class should get notified. The <kbd>id</kbd> field denotes the <kbd>id</kbd> for that <kbd>pointcut</kbd>, so that you can refer to it in your code. The expression field denotes the expression for which we should create the <kbd>pointcut</kbd>. Here, with the execution expression, we stated that the <kbd>pointcut</kbd> should be on execution of the <kbd>completeAssignment</kbd> method.</p>
<p>On comment <kbd>(5)</kbd>, we declared the method in <kbd>Faculty</kbd> class that should get called after the <kbd>pointcut</kbd> expression is executed. We can also declare a method to execute before <kbd>pointcut</kbd> by using <kbd>aop:before</kbd>.</p>
<p>So, now, let's take a look at the following output:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="270" width="333" src="assets/a19345db-f043-4316-ad37-e7c8f6ee1d73.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Cropped output of DI with Spring AOP program</div>
<p>As you can see, the <kbd>evaluateAssignment</kbd> method is called from the <kbd>Faculty</kbd> class every time we call the <kbd>completeAssignment</kbd> method, apparently, with no code, but only with configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Spring Boot</h1>
                </header>
            
            <article>
                
<p>So, we are now familiar with Spring, especially with Spring DI and AOP. Spring Boot makes a developer's life easier. So far, we've seen how to perform various operations just by using POJO classes and Spring configurations. What would be your reaction if I tell you that we can even minimize this configuration? Will you be shocked? Then brace yourself, because it's true. With Spring Boot, you can get your code ready with minimal configuration and in just a few steps.</p>
<p>So, what is Spring Boot? It is a Spring module that provides <strong>RAD</strong> (<strong>Rapid application development</strong>) features to the Spring Framework. It is designed to simplify the bootstrapping and development of new Spring applications. The framework takes an opinionated approach to configuration, freeing developers from the requirement to define boilerplate configurations, further reducing your development time.</p>
<p>So, let's get started. If you are using the IntelliJ IDEA Ultimate edition, you can follow these steps to create a Spring Boot application:</p>
<ol>
<li>Start a <span class="packt_screen">New Project</span>.</li>
<li>From the <span class="packt_screen">New Project</span> dialog, select <span class="packt_screen">Spring Initializr</span>, define <span class="packt_screen">Project SDK</span>, and click on <span class="packt_screen">Next</span>, as shown in the following screenshot:</li>
</ol>
<div style="color: black;font-size: 1em" class="CDPAlignCenter CDPAlign"><img src="assets/1e14e69a-b5a2-45d1-87d7-487f052952ab.jpg"/></div>
<ol start="3">
<li>On the next screen, define the <span class="packt_screen">Group</span>, <span class="packt_screen">Artifact</span>, <span class="packt_screen">Type</span> (Gradle or Maven), <span class="packt_screen">Language</span> (<span class="packt_screen">Java</span>/<span class="packt_screen">Kotlin</span>), <span class="packt_screen">Packaging</span> (<span class="packt_screen">Jar</span>/<span class="packt_screen">War</span>), <span class="packt_screen">Java Version</span>, <span class="packt_screen">Name</span>, and root package for the project, as shown in the following screenshot:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;color: black;font-size: 1em" src="assets/a5e6b338-6453-455e-ae70-13b215a68658.jpg"/></div>
<ol start="4">
<li>The next screen lets you select multiple Spring dependencies. Make sure to set the Spring Boot version to 2.0.0 M6 and above in this screen. For AOP and DI, you need to select <span class="packt_screen">Aspects</span> under <span class="packt_screen">Core</span>, as shown in the screenshot:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;color: black;font-size: 1em" src="assets/c0a487cd-5222-446e-ad38-0f2c3ec482f3.jpg"/></div>
<ol start="5">
<li>Provide <span class="packt_screen">Project name</span> and <span class="packt_screen">location</span> and click on <span class="packt_screen">Finish</span>.</li>
</ol>
<p>Wasn't it quite easy? Don't get upset if you don't have IntelliJ IDEA Ultimate. Spring Boot is for everyone. Follow these steps to create a new Spring Boot project for whatever IDE you have:</p>
<ol>
<li>Go to <a href="http://start.spring.io/">http://start.spring.io/</a>.</li>
<li>Provide the following details, which are similar to IntelliJ IDEA:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;color: black;font-size: 1em" src="assets/ef1f3344-e47a-4e47-857b-51e2d305ffb7.jpg"/></div>
<ol start="3">
<li>Click on <span class="packt_screen">Generate Project</span>. The project will get downloaded to your machine.</li>
</ol>
<p>Wasn't it simple enough? Let's try our hands at creating APIs with Spring.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Rest API with Spring Boot</h1>
                </header>
            
            <article>
                
<p>We've seen the power of Spring and Spring Boot. So, let's use it without any further delay. We will build a RESTful web service that will return a <kbd>Todo</kbd> object. We will further enhance this project in the next chapter, where we will add <kbd>Todo</kbd> and fetch a list of <kbd>Todo</kbd> from the database. We will use JPA and Hibernate along with Spring for that purpose.</p>
<p>When we are done with this example, we should get the following response:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0d225d4c-79ae-4b5e-9211-07c844f9b455.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Cropped screenshot of browser output</div>
<p>So, let's start by creating a new project. You can use <a href="http://start.spring.io/"><span class="URLPACKT">http://start.spring.io/</span></a> or you can use IntelliJ IDEA as well to create a new project.</p>
<p>After you have created the new project, you will see that there's an <kbd>Application</kbd> class; don't give much focus to it, it's there in almost all Spring Boot applications. We need to create a new class for <kbd>Todo</kbd>, as follows:</p>
<pre>    data class Todo ( 
        var id:Int = 0, 
        var todoDescription:String, 
        var todoTargetDate:String, 
        var status:String 
    ) </pre>
<p>A REST API requires us to create <kbd>RestController</kbd>, which would be the endpoint for API requests, so here's our <kbd>RestController</kbd>:</p>
<pre><strong>    @RestController</strong><strong>@RequestMapping("/api")</strong> 
    class TodoController { 
<strong>      @RequestMapping("/get_todo")</strong> 
      fun getTodo() = Todo(1,"TODO Project","31/11/2017","Running") 
   } </pre>
<p>Study this small class carefully. First, we annotated our class with <kbd>@RestController</kbd> and <kbd>@RequestMapping</kbd>. The purpose of them is simple <kbd>@RestController</kbd> denotes that this class will act as a <kbd>Controller</kbd>, that is, all API requests should pass through this class, <kbd>@RequestMapping("/api")</kbd> denotes that the URL of this class will have an <kbd>/api</kbd> suffix after your base URL (note that the URL in the screenshot is <kbd><span class="URLPACKT">http://127.0.0.1:8080/api/get_todo</span></kbd>). We can skip the second annotation if we want for this class.</p>
<p>Then, we have the <kbd>getTodo()</kbd> function; the <kbd>@RequestMapping</kbd> annotation is required for this method as it will define the endpoint. This method is also simple—it just returns a new object of <kbd>Todo</kbd>, statically created.</p>
<p>What? Are you expecting anything more? Sorry to disappoint you, but we are done with the API. You can just run the project and hit <kbd><span class="URLPACKT">http://127.0.0.1:8080/api/get_todo</span></kbd> to get the following JSON response:</p>
<pre>    {"id":1,"todoDescription":"TODO   <br/>    Project","todoTargetDate":"31/11/2017","status":"Running"} </pre>
<p>Isn't it simple enough?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you were introduced to Spring with Kotlin. We learned about dependency injection and Aspect-oriented programming. We learned how a simple POJO class can show great power with the help of the Spring Framework. In this chapter, we also learned to create a simple API with Spring.</p>
<p>In the next chapter, we will focus on enhancing our API to a fully functional one with the help of JPA and Hibernate to work with MySQL database. We will also learn to implement reactive programming with Spring.</p>
<p>So, don't wait! Head over to the next chapter right now. Our API is still incomplete.</p>


            </article>

            
        </section>
    </body></html>