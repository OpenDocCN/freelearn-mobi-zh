- en: Chapter 9. Improving Your Code with Xcode Server and LLDB Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest skills you can learn to improve in your code is by learning
    how to test it. Adding unit tests to your code with the `XCTest` Testing framework
    will help you improve the quality of your code and will provide a secondary benefit
    of documenting how your code works. As you move from solo developer projects to
    multi-member teams, it becomes harder to maintain tests that are written in isolation.
    Automated testing, added to a continuous integration pipeline on a server, helps
    to address these pain points in the same way that source repositories help to
    manage code over larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this chapter, we will cover Xcode Server's capabilities
    as a continuous integration server and how automated testing can be included to
    improve your testing workflow. In the second half, we will describe how to use
    LLDB for debugging your code on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration overview with Xcode server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using server-based testing has several benefits that could justify the time
    investment for your team. If you''re on the fence about whether going this route
    works for your team, make sure to consider the following in your evaluations:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving your builds and unit tests to a server frees your local box to keep working
    on features and debugging, while your builds and test suites run remotely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build triggers can run your tests on code check-ins and alert your team when
    things change expectantly due to tests failing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tests on your server are consistent and run the same way each time; meaning
    that individual developer environment and project tweaks won't affect test runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can schedule full test suites to run at your convenience and short running
    tests to execute on every code check-in as an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can have your tests executed against multiple development environments and
    hardware. For example, you could have your test run on multiple iPad models and
    OS versions along with several iPhones with ease using a server environment. This
    would be a time-consuming task to do manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A continuous integration workflow is a process that starts with developing locally
    on a development machine and then checking your code into a repository. Next,
    you migrate your project to Xcode server for processing. In order for Xcode Server
    to process your code, you have to provide it with some instructions in the form
    of *bots*. On your development box, you create *bots* with your processing rules
    that run on Xcode Server. The execution of a *bot* is called an *integration*,
    which can be run manually or according to a schedule. Once an *integration* finishes,
    the activity is reported back to your development Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Bot features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without *bots*, you can't do anything useful with Xcode Server. *Bots* build
    your code and run your tests, using a supplied Xcode project scheme. A well-crafted
    *bot* can control when it runs and how it communicates its activity to you and
    your team. For instance, you could have the *bot* run when a new commit has occurred
    and have it e-mail the *integration* status (for example, success or failure)
    to you and/or your development team. You can also add pre and post *integration*
    triggers that can execute scripts to communicate with web services or to run additional
    performance tests based on initial *integration* outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and managing bots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have created your *bots*, you can manage and monitor them in Xcode
    Server. Xcode Server can be configured to push *bot* statuses to your development
    Mac, provide a web hook to view activity in a browser or third-party app (for
    example, Slack/HipChat), or send you an e-mail report. On your development Mac,
    you can see very detailed reports using the report navigator in Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Xcode server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Xcode server, you have to download and install macOS Server (formerly
    known as OS X Server) from the App Store on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing is straightforward, and you can find detailed instructions at [https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html
    - //apple_ref/doc/uid/TP40013292-CH3-SW1](https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1).
  prefs: []
  type: TYPE_NORMAL
- en: Adding repositories for the Xcode server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Xcode Server needs a code repository to do work and is compatible with either
    Git or Subversion. Any *bots* that you create will need access to a repository.
    A bot will try to connect to a repository via SSH or HTTPS. Apple does a really
    good job of describing your repository setup options.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can refer to the following section of their setup guide for step-by-step
    instructions on how to configure your repos to give access to Xcode Server and
    your *bot*: [https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html
    - //apple_ref/doc/uid/TP40013292-CH8-SW1](https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html#//apple_ref/doc/uid/TP40013292-CH8-SW1).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring bots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *bot* is a process, run by the Xcode Server to build and test code from a
    source repository. Each time you run an instance of your bot, you are performing
    what's known as *integration*. You create a *bot* and add an associated scheme
    to the *bot* that references your development box. The *bot* creation wizard walks
    you through options for choosing the scheme to use, setting the frequency to run,
    and providing any shell scripts to run before or after an *integration*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about how to setup a bot at [https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html
    - //apple_ref/doc/uid/TP40013292-CH9-SW1](https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1).
  prefs: []
  type: TYPE_NORMAL
- en: Last year, Xcode Server introduced a new feature that allows us to add custom
    environment variables that our *bots* can access. This year Xcode Server allows
    us to add pre and post scripts that will run on each *integration*. This feature
    could allow you to pre-load your environment with external files or data for unit
    testing before your *bot* builds and executes tests. Another example might be
    to have a post *integration* script communicate with a Rest API to send the success
    or failure status.
  prefs: []
  type: TYPE_NORMAL
- en: Managing and monitoring your integration runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access detailed reports on *integration* runs for each *bot* in Xcode's
    Report Navigator (**View** | **Navigators** | **Show Report Navigator**). This
    view also gives you the ability to create additional *bots* or edit existing ones.
    Selecting any of the *bots* listed in the sidebar gives you a summary report of
    the integration results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing and monitoring your integration runs](img/B05719_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Report Navigator
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with LLDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*LLDB* is the debugger that powers Xcode. In Xcode''s debug console, you can
    find a console window that gives you access to an *LLDB* prompt. On Linux or from
    the command line, you can access *LLDB* from the Swift *REPL*. Let''s explore
    how we can use *LLDB* to debug our programs using some of the commands of which
    you may or may not already be aware.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about debugging with LLDB in the LLDB Debugging Guide: [https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html
    - //apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html#//apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42).'
  prefs: []
  type: TYPE_NORMAL
- en: LLDB command syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interacting with *LLDB* is as easy as entering a command into the prompt. The
    command structure contains zero or more subcommands followed by zero or more options
    or arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Subcommands and arguments are space-delimited tokens; while options are space
    delimited, but use double dashes (and sometimes single dash) as a prefix. An example
    *LLDB* command would be to set a breakpoint on a function. In the following example,
    we would set a `breakpoint` for the `speakToMe()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can always get help by typing help at the *LLDB* prompt. Typing help without
    arguments will list all of the commands available with short descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can get help on a specific command by typing help along with the command
    name or the command name and subcommand name for even more specialized results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Managing breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breakpoints are the main way to interrupt your running program for inspection
    at specific points. We can create, modify, delete, or list breakpoints through
    *LLDB*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `breakpoint set` command to create a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Listing breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `breakpoint list` command to list the names and locations of breakpoints
    in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Modifying a breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another interesting thing you can do with breakpoints is to add conditions on
    activation. Using the `breakpoint modify` command, you can use any of the following
    options to change the target breakpoint's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Enabling and disabling a breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can enable and disable a breakpoint using either the breakpoint ID or the
    location. You pass the ID to the `enable` or `disable` subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you no longer need your breakpoint, you can simply remove it using the
    delete subcommand with the breakpoint ID or location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Command aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command aliases allow you to create a shorter syntax for commands that you use
    often. You can also provide help text to accompany your alias. You can see additional
    details on how to manage a command alias by typing `help command`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Command aliases](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we create a command alias to execute a command we
    pass to our alias using the Unix shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Command aliases](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of a continuous integration workflow
    using Xcode Server. You learned what a bot is and how they are used to build and
    test your code on Xcode Server. With the addition of Swift on Linux, we needed
    to explore other options outside Xcode for testing code. LLDB is extremely powerful
    and even has customization options for your debugging sessions. In our next and
    final chapter, we will discuss writing Swift on a Linux server.
  prefs: []
  type: TYPE_NORMAL
