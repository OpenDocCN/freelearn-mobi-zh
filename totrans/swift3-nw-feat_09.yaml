- en: Chapter 9. Improving Your Code with Xcode Server and LLDB Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：使用 Xcode 服务器和 LLDB 调试改进您的代码
- en: One of the biggest skills you can learn to improve in your code is by learning
    how to test it. Adding unit tests to your code with the `XCTest` Testing framework
    will help you improve the quality of your code and will provide a secondary benefit
    of documenting how your code works. As you move from solo developer projects to
    multi-member teams, it becomes harder to maintain tests that are written in isolation.
    Automated testing, added to a continuous integration pipeline on a server, helps
    to address these pain points in the same way that source repositories help to
    manage code over larger projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过学习如何测试代码来提高代码质量的最大技能之一。使用 `XCTest` 测试框架将单元测试添加到您的代码中，将帮助您提高代码质量，并提供了记录代码工作方式的额外好处。当您从个人开发者项目过渡到多成员团队时，维护独立编写的测试变得更加困难。将自动化测试添加到服务器上的持续集成管道中，可以帮助解决这些问题，就像源代码库帮助管理大型项目中的代码一样。
- en: In the first part of this chapter, we will cover Xcode Server's capabilities
    as a continuous integration server and how automated testing can be included to
    improve your testing workflow. In the second half, we will describe how to use
    LLDB for debugging your code on Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将介绍 Xcode 服务器作为持续集成服务器的能力，以及如何将自动化测试包含进来以改进您的测试工作流程。在第二部分，我们将描述如何使用
    LLDB 在 Linux 上调试您的代码。
- en: Continuous integration overview with Xcode server
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Xcode 服务器进行持续集成概述
- en: 'Using server-based testing has several benefits that could justify the time
    investment for your team. If you''re on the fence about whether going this route
    works for your team, make sure to consider the following in your evaluations:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于服务器的测试具有几个好处，这些好处可能足以证明您团队在时间投资上的合理性。如果您对是否走这条路适合您的团队持怀疑态度，请确保在评估时考虑以下因素：
- en: Moving your builds and unit tests to a server frees your local box to keep working
    on features and debugging, while your builds and test suites run remotely.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建和单元测试移至服务器可以释放您的本地机器继续工作在功能开发和调试上，同时您的构建和测试套件在远程运行。
- en: Build triggers can run your tests on code check-ins and alert your team when
    things change expectantly due to tests failing.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建触发器可以在代码提交时运行测试，并在测试失败导致意外变化时通知您的团队。
- en: Tests on your server are consistent and run the same way each time; meaning
    that individual developer environment and project tweaks won't affect test runs.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器上的测试是一致的，每次都以相同的方式运行；这意味着个人开发环境和项目调整不会影响测试运行。
- en: You can schedule full test suites to run at your convenience and short running
    tests to execute on every code check-in as an example.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以安排完整的测试套件在您方便的时候运行，以及短运行测试在每次代码提交时执行，例如。
- en: You can have your tests executed against multiple development environments and
    hardware. For example, you could have your test run on multiple iPad models and
    OS versions along with several iPhones with ease using a server environment. This
    would be a time-consuming task to do manually.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以让您的测试在多个开发环境和硬件上执行。例如，您可以使用服务器环境轻松地在多个 iPad 模型和操作系统版本以及几部 iPhone 上运行测试。这将是手动执行耗时的工作。
- en: A continuous integration workflow is a process that starts with developing locally
    on a development machine and then checking your code into a repository. Next,
    you migrate your project to Xcode server for processing. In order for Xcode Server
    to process your code, you have to provide it with some instructions in the form
    of *bots*. On your development box, you create *bots* with your processing rules
    that run on Xcode Server. The execution of a *bot* is called an *integration*,
    which can be run manually or according to a schedule. Once an *integration* finishes,
    the activity is reported back to your development Mac.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成工作流程是一个从在开发机器上本地开发开始，然后将您的代码提交到仓库的过程。接下来，您将项目迁移到 Xcode 服务器进行处理。为了使 Xcode
    服务器能够处理您的代码，您必须以 *bots* 的形式提供一些指令。在您的开发机器上，您创建带有在 Xcode 服务器上运行的规则 *bots*。*bot*
    的执行称为 *integration*，可以手动运行或根据计划运行。一旦 *integration* 完成，活动将报告回您的开发 Mac。
- en: Bot features
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器人功能
- en: Without *bots*, you can't do anything useful with Xcode Server. *Bots* build
    your code and run your tests, using a supplied Xcode project scheme. A well-crafted
    *bot* can control when it runs and how it communicates its activity to you and
    your team. For instance, you could have the *bot* run when a new commit has occurred
    and have it e-mail the *integration* status (for example, success or failure)
    to you and/or your development team. You can also add pre and post *integration*
    triggers that can execute scripts to communicate with web services or to run additional
    performance tests based on initial *integration* outputs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用*机器人*，您无法利用Xcode服务器做任何有用的事情。*机器人*构建您的代码并运行您的测试，使用提供的Xcode项目方案。一个精心制作的*机器人*可以控制其运行的时间和如何与您和您的团队沟通其活动。例如，您可以让*机器人*在发生新的提交时运行，并通过电子邮件将*集成*状态（例如，成功或失败）发送给您和/或您的开发团队。您还可以添加预集成和后集成触发器，这些触发器可以执行脚本以与Web服务通信或基于初始集成输出运行额外的性能测试。
- en: Monitoring and managing bots
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控和管理机器人
- en: Once you have created your *bots*, you can manage and monitor them in Xcode
    Server. Xcode Server can be configured to push *bot* statuses to your development
    Mac, provide a web hook to view activity in a browser or third-party app (for
    example, Slack/HipChat), or send you an e-mail report. On your development Mac,
    you can see very detailed reports using the report navigator in Xcode.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了您的*机器人*，您就可以在Xcode Server中管理和监控它们。Xcode服务器可以被配置为将*机器人*的状态推送到您的开发Mac，提供一个web钩子以在浏览器或第三方应用程序（例如，Slack/HipChat）中查看活动，或者发送电子邮件报告。在您的开发Mac上，您可以使用Xcode中的报告导航器查看非常详细的报告。
- en: Configuring Xcode server
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Xcode服务器
- en: To use Xcode server, you have to download and install macOS Server (formerly
    known as OS X Server) from the App Store on a Mac.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Xcode服务器，您必须从Mac的App Store下载并安装macOS Server（以前称为OS X Server）。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Installing is straightforward, and you can find detailed instructions at [https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html
    - //apple_ref/doc/uid/TP40013292-CH3-SW1](https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程简单，您可以在[https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html
    - //apple_ref/doc/uid/TP40013292-CH3-SW1](https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1)找到详细的说明。
- en: Adding repositories for the Xcode server
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Xcode服务器添加仓库
- en: The Xcode Server needs a code repository to do work and is compatible with either
    Git or Subversion. Any *bots* that you create will need access to a repository.
    A bot will try to connect to a repository via SSH or HTTPS. Apple does a really
    good job of describing your repository setup options.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode Server需要一个代码仓库来执行工作，并且与Git或Subversion兼容。你创建的任何*机器人*都需要访问仓库。机器人会尝试通过SSH或HTTPS连接到仓库。苹果公司对您的仓库设置选项做了很好的描述。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can refer to the following section of their setup guide for step-by-step
    instructions on how to configure your repos to give access to Xcode Server and
    your *bot*: [https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html
    - //apple_ref/doc/uid/TP40013292-CH8-SW1](https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html#//apple_ref/doc/uid/TP40013292-CH8-SW1).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考他们设置指南的以下部分，以获取如何配置您的仓库以供Xcode Server和您的*机器人*访问的逐步说明：[https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html
    - //apple_ref/doc/uid/TP40013292-CH8-SW1](https://developer.apple.com/library/prerelease/content/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/PublishYourCodetoaSourceRepository.html#//apple_ref/doc/uid/TP40013292-CH8-SW1)。
- en: Configuring bots
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置机器人
- en: A *bot* is a process, run by the Xcode Server to build and test code from a
    source repository. Each time you run an instance of your bot, you are performing
    what's known as *integration*. You create a *bot* and add an associated scheme
    to the *bot* that references your development box. The *bot* creation wizard walks
    you through options for choosing the scheme to use, setting the frequency to run,
    and providing any shell scripts to run before or after an *integration*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “机器人”是由Xcode Server运行以从源代码库构建和测试代码的过程。每次你运行你的“机器人”实例时，你都在执行所谓的“集成”。你创建一个“机器人”，并将一个关联的方案添加到“机器人”中，该方案引用你的开发机器。创建“机器人”向导会引导你选择要使用的方案、设置运行频率以及提供在集成前后运行的任何shell脚本。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about how to setup a bot at [https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html
    - //apple_ref/doc/uid/TP40013292-CH9-SW1](https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[如何设置机器人](https://developer.apple.com/library/tvos/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html
    - //apple_ref/doc/uid/TP40013292-CH9-SW1)中了解更多信息。
- en: Last year, Xcode Server introduced a new feature that allows us to add custom
    environment variables that our *bots* can access. This year Xcode Server allows
    us to add pre and post scripts that will run on each *integration*. This feature
    could allow you to pre-load your environment with external files or data for unit
    testing before your *bot* builds and executes tests. Another example might be
    to have a post *integration* script communicate with a Rest API to send the success
    or failure status.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 去年，Xcode Server引入了一个新功能，允许我们添加自定义环境变量，我们的“机器人”可以访问。今年Xcode Server允许我们添加在每次“集成”前后运行的预和后脚本。此功能可能允许你在“机器人”构建和执行测试之前，预先加载外部文件或数据以进行单元测试。另一个例子可能是后“集成”脚本与Rest
    API通信，以发送成功或失败状态。
- en: Managing and monitoring your integration runs
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理和监控你的集成运行
- en: You can access detailed reports on *integration* runs for each *bot* in Xcode's
    Report Navigator (**View** | **Navigators** | **Show Report Navigator**). This
    view also gives you the ability to create additional *bots* or edit existing ones.
    Selecting any of the *bots* listed in the sidebar gives you a summary report of
    the integration results.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Xcode的“报告导航器”中访问每个“机器人”的详细报告（**视图** | **导航器** | **显示报告导航器**）。此视图还允许你创建额外的“机器人”或编辑现有的“机器人”。选择侧边栏中列出的任何“机器人”都会给你一个集成结果的摘要报告。
- en: '![Managing and monitoring your integration runs](img/B05719_09_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![管理和监控你的集成运行](img/B05719_09_01.jpg)'
- en: Report Navigator
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 报告导航器
- en: Debugging with LLDB
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLDB进行调试
- en: '*LLDB* is the debugger that powers Xcode. In Xcode''s debug console, you can
    find a console window that gives you access to an *LLDB* prompt. On Linux or from
    the command line, you can access *LLDB* from the Swift *REPL*. Let''s explore
    how we can use *LLDB* to debug our programs using some of the commands of which
    you may or may not already be aware.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*LLDB*是驱动Xcode的调试器。在Xcode的调试控制台中，你可以找到一个控制台窗口，它为你提供了访问*LLDB*提示符的权限。在Linux或从命令行中，你可以从Swift
    *REPL*访问*LLDB*。让我们探索如何使用*LLDB*通过一些你可能已经知道或不知道的命令来调试我们的程序。'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about debugging with LLDB in the LLDB Debugging Guide: [https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html
    - //apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html#//apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在LLDB调试指南中了解更多关于使用LLDB进行调试的信息：[LLDB调试指南](https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/lldb-guide/chapters/Introduction.html
    - //apple_ref/doc/uid/TP40016717-CH1-DontLinkElementID_42).
- en: LLDB command syntax
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLDB命令语法
- en: Interacting with *LLDB* is as easy as entering a command into the prompt. The
    command structure contains zero or more subcommands followed by zero or more options
    or arguments.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与*LLDB*交互就像在提示符中输入一个命令一样简单。命令结构包含零个或多个子命令，后跟零个或多个选项或参数。
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Subcommands and arguments are space-delimited tokens; while options are space
    delimited, but use double dashes (and sometimes single dash) as a prefix. An example
    *LLDB* command would be to set a breakpoint on a function. In the following example,
    we would set a `breakpoint` for the `speakToMe()` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 子命令和参数是空格分隔的标记；而选项也是空格分隔的，但使用双横线（有时是单横线）作为前缀。一个示例 *LLDB* 命令是设置一个函数的断点。在以下示例中，我们将为`speakToMe()`函数设置一个`breakpoint`：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can always get help by typing help at the *LLDB* prompt. Typing help without
    arguments will list all of the commands available with short descriptions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在*LLDB*提示符下输入`help`来始终获得帮助。不带参数输入`help`将列出所有可用命令及其简短描述：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can get help on a specific command by typing help along with the command
    name or the command name and subcommand name for even more specialized results.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入`help`加上命令名称或命令名称和子命令名称来获取特定命令的帮助，以获得更专业化的结果。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Managing breakpoints
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理断点
- en: Breakpoints are the main way to interrupt your running program for inspection
    at specific points. We can create, modify, delete, or list breakpoints through
    *LLDB*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是中断正在运行的程序以在特定点进行检查的主要方式。我们可以通过*LLDB*创建、修改、删除或列出断点。
- en: Creating a breakpoint
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建断点
- en: 'We use the `breakpoint set` command to create a breakpoint:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`breakpoint set`命令来创建断点：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing breakpoints
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出断点
- en: 'We use the `breakpoint list` command to list the names and locations of breakpoints
    in a program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`breakpoint list`命令来列出程序中断点的名称和位置：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Modifying a breakpoint
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改断点
- en: Another interesting thing you can do with breakpoints is to add conditions on
    activation. Using the `breakpoint modify` command, you can use any of the following
    options to change the target breakpoint's behavior.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用断点添加激活条件。使用`breakpoint modify`命令，你可以使用以下任何选项来更改目标断点的行为。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Enabling and disabling a breakpoint
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和禁用断点
- en: 'You can enable and disable a breakpoint using either the breakpoint ID or the
    location. You pass the ID to the `enable` or `disable` subcommands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用断点ID或位置来启用和禁用断点。你将ID传递给`enable`或`disable`子命令：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Deleting a breakpoint
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除断点
- en: 'When you no longer need your breakpoint, you can simply remove it using the
    delete subcommand with the breakpoint ID or location:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再需要你的断点时，你可以简单地使用带有断点ID或位置的删除子命令来移除它：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Command aliases
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令别名
- en: Command aliases allow you to create a shorter syntax for commands that you use
    often. You can also provide help text to accompany your alias. You can see additional
    details on how to manage a command alias by typing `help command`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 命令别名允许你为常用命令创建更短的语法。你还可以提供帮助文本来伴随你的别名。你可以通过输入`help command`来查看如何管理命令别名的更多详细信息。
- en: '![Command aliases](img/image_09_002.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![命令别名](img/image_09_002.jpg)'
- en: 'In the following example, we create a command alias to execute a command we
    pass to our alias using the Unix shell:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建一个命令别名来执行我们传递给别名的命令，使用Unix shell：
- en: '![Command aliases](img/image_09_003.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![命令别名](img/image_09_003.jpg)'
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of a continuous integration workflow
    using Xcode Server. You learned what a bot is and how they are used to build and
    test your code on Xcode Server. With the addition of Swift on Linux, we needed
    to explore other options outside Xcode for testing code. LLDB is extremely powerful
    and even has customization options for your debugging sessions. In our next and
    final chapter, we will discuss writing Swift on a Linux server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Xcode Server的持续集成工作流程的基本知识。你学习了什么是机器人以及它们是如何在Xcode Server上构建和测试你的代码的。随着Swift在Linux上的加入，我们需要探索Xcode之外的其他测试代码的选项。LLDB功能非常强大，甚至为你的调试会话提供了定制选项。在我们下一章和最后一章中，我们将讨论在Linux服务器上编写Swift。
