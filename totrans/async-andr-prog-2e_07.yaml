- en: Chapter 7. Exploring the JobScheduler API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 探索 JobScheduler API
- en: So far, we have been scheduling background work using a time condition in the
    Handler facilities for the short-term future, and the Android Alarm Manager for
    the long-term future.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Handler 中的时间条件来安排短期未来的后台工作，以及使用 Android Alarm Manager 来安排长期未来的工作。
- en: Those APIs that are able to execute future tasks at an exact and inexact time
    in the future are used to trigger events, refresh data in the background, or execute
    tasks without user intervention. AlarmManager, which we covered in detail in the
    previous chapter, is able to wake up the device from deep idle states and execute
    work even without considering the device's battery state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那些能够在未来确切和不确切的时间执行未来任务的 API 用于触发事件、在后台刷新数据或执行无需用户干预的任务。我们在上一章中详细介绍的 AlarmManager
    能够唤醒设备从深度空闲状态，并在不考虑设备电池状态的情况下执行工作。
- en: In this chapter, we will learn how to work with JobScheduler to execute jobs
    in the background when several prerequisites are fulfilled and taking into account
    the energy consumption context of the device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何与 JobScheduler 一起工作，在满足多个前提条件并考虑设备能耗环境的情况下在后台执行任务。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Introduction to JobScheduler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JobScheduler 简介
- en: Setting the JobScheduler running criteria
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 JobScheduler 运行标准
- en: Controlling the execution of your job with criteria
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准控制你的任务执行
- en: How to schedule work with JobService
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 JobService 安排工作
- en: Executing repeating tasks with JobScheduler
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JobScheduler 执行重复任务
- en: Retrieving the list of pending JobScheduler schedules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取待处理的 JobScheduler 计划列表
- en: How to cancel a task in JobScheduler
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 JobScheduler 中取消任务
- en: Introduction to JobScheduler
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JobScheduler 简介
- en: The Android development team, under the project Volta umbrella, introduced in
    the API Level 21 Lollipop release some enhancements and features in order to improve
    the power usage on the Android platform. Apart from the tools introduced to monitor
    and follow the battery usage in the Android platform, a new API for scheduling
    background was officially released to help the developer. It saves extra power
    cycles when the jobs used to support the developer's application do not need a
    time of execution, and can be deferred until the device has better battery and
    network context.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目 Volta 的伞形项目下，Android 开发团队在 API 级别 21 的 Lollipop 版本中引入了一些增强功能和特性，旨在提高 Android
    平台上的功耗。除了引入用于监控和跟踪 Android 平台电池使用的工具外，还正式发布了一个用于调度后台任务的新 API，以帮助开发者。当用于支持开发者应用程序的任务不需要执行时间时，它可以节省额外的电力周期，并且可以推迟到设备具有更好的电池和网络环境时再执行。
- en: The API was not created to completely replace `AlarmManager`; however, the `JobScheduler`
    API is able to perform a better battery management and supply extra behaviors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: API 的创建并非为了完全替代 `AlarmManager`；然而，`JobScheduler` API 能够执行更好的电池管理并提供额外的行为。
- en: 'The main features introduced with Scheduler API are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Scheduler API 一起引入的主要功能如下：
- en: '**Less power consumption**: The job task could be delayed until the device
    is powered to the charger or they are grouped to run in batches on a regular basis'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少功耗**：作业任务可以延迟，直到设备充电或有规律地批量运行'
- en: '**Persistent jobs across reboots**: We are able to install job schedules that
    persistent task across device reboots'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重启后持久化任务**：我们能够安装跨设备重启持久化任务的作业计划'
- en: '**Better network bandwidth management**: The job could be delayed until a higher
    bandwidth network is available, such as when a Wi-Fi network connection is available'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的网络带宽管理**：作业可以延迟，直到有更高带宽的网络可用，例如当 Wi-Fi 网络连接可用时'
- en: '**Less intrusive execution**: The job could be delayed until the user is not
    interacting with the device'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少侵入性执行**：作业可以延迟，直到用户不再与设备交互'
- en: '`JobScheduler` is a singleton system service that we can retrieve via a `Context`
    object instance, using a code similar to the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobScheduler` 是一个单例系统服务，我们可以通过一个 `Context` 对象实例来检索，使用类似于以下代码的方式：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `JobScheduler` singleton service instance object helps us to manage our
    running jobs and provides us with member functions to schedule, cancel, and retrieve
    a list of deferred jobs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobScheduler` 单例服务实例对象帮助我们管理正在运行的任务，并提供成员函数来安排、取消和检索延迟作业的列表。'
- en: 'Once we have a reference to the `JobScheduler` service, we can schedule a job
    by passing `JobInfo` to the `JobScheduler.schedule` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`JobScheduler`服务的引用，我们可以通过将`JobInfo`传递给`JobScheduler.schedule`函数来安排一个作业：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`JobInfo` is the object used in this framework where we specify all the information
    about the job itself, all the conditions that should be fulfilled to initiate
    the job execution, and the unit of work called `JobService` that will be started
    to execute the work required.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobInfo`是框架中使用的对象，其中我们指定了关于作业本身的所有信息，以及应满足以启动作业执行的所有条件，以及将被启动以执行所需工作的单元`JobService`。'
- en: To build a `JobInfo` object, a common factory pattern, known Software Engineering
    as `Builder` and materialized in the static inner-class `JobInfo.Builder`, is
    available to construct the `JobInfo` object passed to `JobScheduler`. The pattern
    provides us with a way to construct a multi-parameter `JobInfo` on a clean, step-by-step
    basis and by using the `Builder` setter functions to define the `JobInfo` parameters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个`JobInfo`对象，一个常见的工厂模式，被称为软件工程中的`Builder`模式，并在静态内部类`JobInfo.Builder`中实现，可用于构建传递给`JobScheduler`的`JobInfo`对象。该模式为我们提供了一种在干净、逐步的基础上构建多参数`JobInfo`的方法，并使用`Builder`设置函数来定义`JobInfo`参数。
- en: 'First, we will have to build a `JobInfo.Builder` object using the following
    constructor:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将必须使用以下构造函数来构建一个`JobInfo.Builder`对象：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`jobId` is an internal number used to identify your job in the `JobScheduler`
    service and the second argument is used to set the `JobService` derived class
    that will be invoked when the system verifies that all the pre-requisites are
    met to execute the job.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobId`是一个内部数字，用于在`JobScheduler`服务中识别您的作业，第二个参数用于设置当系统验证所有先决条件都已满足以执行作业时将被调用的`JobService`派生类。'
- en: 'Let''s write some code to show this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来展示这一点：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Setting running criteria
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置运行标准
- en: With the `Builder` object reference, we can start setting up the job parameters
    and the pre-requisites using the member function available in the `Builder` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Builder`对象引用，我们可以开始设置作业参数和先决条件，使用`Builder`对象中可用的成员函数。
- en: 'Let''s consider a couple of examples. In our first example, the job should
    only start when there is a Wi-Fi network available, so to achieve that, we have
    to use the following code to set the network availability pre-requisite:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑几个例子。在我们的第一个例子中，作业应该只在有Wi-Fi网络可用时启动，因此为了实现这一点，我们必须使用以下代码来设置网络可用性先决条件：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An unmetered network connection means that you have a connection where you don't
    have a limited amount of data usage per month and you are not charged when you
    go over the usage limit. When a network type is not specified, as a condition,
    the default value is `NETWORK_TYPE_NONE`, meaning that the job will run in any
    network context and even without any network connection. Apart from the previous
    network type criteria, there is `NETWORK_TYPE_ANY`, which determines that the
    job could run when there is network connectivity available.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无计量网络连接意味着您有一个没有每月数据使用限制的连接，并且当您超过使用限制时不会收费。当未指定网络类型时，作为条件，默认值是`NETWORK_TYPE_NONE`，这意味着作业将在任何网络上下文中运行，甚至在没有网络连接的情况下。除了之前的网络类型标准之外，还有`NETWORK_TYPE_ANY`，它确定作业可以在有网络连接可用时运行。
- en: 'To specify a job to run only when the device is plugged in and charging:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定仅在设备插入并充电时运行的作业：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When a job should only run when the device is in idle mode:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当作业仅在设备处于空闲模式时运行：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Idle mode means that the job should only run when the device is not in use and
    has not been used for some time. This could be the best time to execute heavier
    computations because the user will not notice that the device resources have been
    allocated to your job, thereby the computation does not interfere with the user
    interactions. By default, any job will not require idle mode to run.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲模式意味着作业仅在设备未被使用并且有一段时间未被使用时运行。这可能是在执行更重的计算的最佳时间，因为用户不会注意到设备资源已被分配给您的作业，因此计算不会干扰用户交互。默认情况下，任何作业都不需要空闲模式来运行。
- en: 'Persist your job execution across device reboots as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如此持久化您的作业执行，以跨设备重启：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Such as an `AlarmManager` job, the job schedule will only survive a reboot
    if your application holds the permissions to receive the completed boot. To achieve
    that, add the following line to the `Android Manifest` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于`AlarmManager`作业，如果您的应用程序有权接收完成的启动权限，作业计划将仅在重启后幸存。为了实现这一点，请将以下行添加到`Android
    Manifest`文件中：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In those cases where you want to schedule a periodic task, you can set the
    interval in milliseconds between subsequent executions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想要安排周期性任务的情况下，您可以设置后续执行之间的毫秒间隔：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is an inexact interval since the Android system will try to group the jobs
    in batches in order to save some battery cycles.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不精确的间隔，因为Android系统会尝试将任务分批处理以节省一些电池周期。
- en: 'When you want to define a maximum defer time to run your job, we can specify
    a time deadline where the job has to run, then it will run regardless of whether
    or not the other criteria are met:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想定义一个最大延迟时间来运行您的任务时，我们可以指定一个时间截止点，任务必须在此时间运行，然后它将运行，无论其他准则是否满足：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the following code, we set one hour as the maximum time to defer this job,
    so, if the other pre-requisites are not fulfilled, after one hour the job is going
    to run by the system independently of the other criteria:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将一个小时设置为延迟执行这个任务的最大时间，因此，如果其他先决条件未满足，一个小时后，系统将独立于其他准则运行这个任务：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the other hand, we can also specify a minimum defer time to this job as
    a criterion:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们也可以将一个最小延迟时间指定为这个任务的准则：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the values used above, our job will never run on the next `120` seconds
    since we set a maximum latency time as a prerequisite to our job.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述值，我们的任务将不会在接下来的`120`秒内运行，因为我们已经将最大延迟时间作为任务的先决条件。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`setMinimumLatency` and `setOverrideDeadline` are not applicable for periodic
    jobs criteria shall be avoided that it is in your recurrent jobs schedules. If
    any one of these criteria are used on recurrent jobs, an `IllegalArgumentException`
    exception will be thrown when the build is called.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMinimumLatency`和`setOverrideDeadline`不适用于周期性任务，应避免在周期性任务计划中使用这些准则。如果这些准则中的任何一个在周期性任务中使用，当调用构建时将抛出`IllegalArgumentException`异常。'
- en: 'When the job fails, in order to specify a retry policy, we have to specify
    the `backoff` initial value that determines the interval between retries and the
    retry increase policy. The `JobScheduler` API provides two policies that define
    the way in which the retry time increases between subsequent tries:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务失败时，为了指定重试策略，我们必须指定`backoff`初始值，该值决定了重试之间的间隔和重试增加策略。`JobScheduler` API提供了两种策略，定义了重试时间在后续尝试之间增加的方式：
- en: '`BACKOFF_POLICY_LINEAR`: The interval time between retries increases linearly—`initial_backoff_millis
    * num_retries`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BACKOFF_POLICY_LINEAR`: 重试之间的间隔时间呈线性增长—`initial_backoff_millis * num_retries`'
- en: '`BACKOFF_POLICY_EXPONENTIAL`: The interval time between retries increases exponentially—`initial_backoff_millis
    * 2 ^ (num_retries)`![Setting running criteria](img/Image_B05062_07_01.jpg)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BACKOFF_POLICY_EXPONENTIAL`: 重试之间的间隔时间呈指数增长—`initial_backoff_millis * 2 ^
    (num_retries)`![设置运行标准](img/Image_B05062_07_01.jpg)'
- en: The `backoff` interval will increase until we reach a backoff of five hours
    (`JobInfo. MAX_BACKOFF_DELAY_MILLIS`) and the initial default value is `30` seconds
    (`JobInfo .DEFAULT_INITIAL_BACKOFF_MILLIS`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 退避间隔将增加，直到达到五小时的退避时间（`JobInfo. MAX_BACKOFF_DELAY_MILLIS`），初始默认值是`30`秒（`JobInfo
    .DEFAULT_INITIAL_BACKOFF_MILLIS`）。
- en: 'Now, in the following examples we are going to show you how to create a linear
    and an exponential backoff policy for our `jobInfo` object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下面的示例中，我们将向您展示如何为我们的`jobInfo`对象创建线性退避策略和指数退避策略：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `builder` class also provides us a method to set some parameters to forward
    the job over a `PersistableBundle` object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder`类还提供了一个方法，用于设置一些参数，以便通过`PersistableBundle`对象传递任务：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `PersistableBundle` is a special kind of bundle that can be saved and restored
    later. Its main purpose is to pass arguments to the deferred job execution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistableBundle`是一种特殊类型的包，可以保存和稍后恢复。其主要目的是将参数传递给延迟任务执行。'
- en: 'As soon as we have all the criteria to schedule our defined job, we are able
    to construct our `JobInfo` and use it to incorporate the job execution in our
    application:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了安排我们定义的任务的所有准则，我们就能构建我们的`JobInfo`并使用它将任务执行纳入我们的应用程序：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Scheduling a job
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排任务
- en: With the criteria already defined and the `JobInfo` object, we have all the
    entities required to set up the job for our application. So now let's show you
    how to create a job with a real example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了准则并且有了`JobInfo`对象，我们就拥有了设置我们应用程序任务所需的所有实体。所以现在让我们通过一个真实示例向您展示如何创建一个任务。
- en: Our example will synchronize the user account information stored in a device
    file with an HTTP web service over a job scheduled using the Scheduler API. The
    user interface will provide us a UI where we can update the user information,
    a button to save the information on an internal file, and a button to set up the
    synchronization job that will upload the account information to the web service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将使用调度器API安排的作业同步存储在设备文件中的用户账户信息与HTTP Web服务。用户界面将提供一个UI，我们可以在此处更新用户信息，一个按钮用于将信息保存到内部文件，以及一个按钮用于设置同步作业，该作业将上传账户信息到Web服务。
- en: 'First, let''s start by defining our job pre-requisites and parameters:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的作业先决条件和参数：
- en: Our job should only run when the device is charging to save the battery
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的作业应该在设备充电时运行以节省电池
- en: Our job should only run when an unmetered network is available to save mobile
    network bandwidth
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的作业应该在未计费的网络可用时运行以节省移动网络带宽
- en: Our job should only run when the device is idle because we don't want to slow
    down the UI responsiveness
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的作业应该在设备空闲时运行，因为我们不希望降低UI的响应速度
- en: Our job must run at least once within eight hours of being scheduled
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的作业必须在安排后至少运行一次，在八小时内
- en: Our job should run even after device reboot
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的作业应该在设备重启后仍然运行
- en: 'The `JobInfo` object requires an `ID` to identify the job in all the `JobSchedule`
    methods, so it is a good idea, in order to ensure consistency, to use a `public
    static int` to identify it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobInfo`对象需要一个`ID`来在所有`JobSchedule`方法中标识作业，因此为了确保一致性，使用一个`public static int`来标识它是一个好主意：'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Subsequent calls to cancel or list jobs created must use the same `jobId` defined
    here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 后续调用取消或列出作业创建必须使用在此处定义的相同`jobId`。
- en: Since we use a file to store the account information internally on the device,
    the filename used to retrieve account information needs to be passed to the job
    as an argument. The same principle applies to the remote web service endpoint.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在设备内部使用文件存储账户信息，因此用于检索账户信息的文件名需要作为参数传递给作业。同样的原则也适用于远程Web服务端点。
- en: 'To forward the required parameters, we have to build `PersistableBundle`, passing
    the filename and endpoint path as bundle parameters:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了转发所需的参数，我们必须构建`PersistableBundle`，将文件名和端点路径作为包参数传递：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the criteria are stated and we have the identifier and the class name
    of our service, we are able to create our `JobInfo` using the `Builder` inner
    class, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了标准并且我们有了服务的标识符和类名，我们就能够使用`Builder`内部类创建我们的`JobInfo`，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we are ready to schedule the job with the `JobScheduler` service:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用`JobScheduler`服务来安排作业：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The JobScheduler's `schedule` method will return `RESULT_FAILURE` in the case
    of failure and in the case of success will return the job identifier that we defined
    in the `JobInfo.Builder` constructor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，JobScheduler的`schedule`方法将返回`RESULT_FAILURE`，在成功的情况下将返回我们在`JobInfo.Builder`构造函数中定义的作业标识符。
- en: Now, since we have just scheduled our job, it's time to write the backup behavior
    in the `JobService` subclass. In the next section, we will detail how to implement
    a `JobService` that plays well with the `JobScheduler` framework.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经安排了我们的作业，是时候在`JobService`子类中编写备份行为。在下一节中，我们将详细介绍如何实现一个与`JobScheduler`框架良好协作的`JobService`。
- en: Implementing the JobService
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`JobService`
- en: 'Our `JobService` subclass is the entity that is going to do the hard work and
    receive the callbacks as soon as all the criteria specified in the `JobInfo` are
    met. To implement our own service, we have to extend from `JobService` and override
    the start and stop callbacks, as shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`JobService`子类是即将执行艰苦工作并接收回调的实体，一旦满足`JobInfo`中指定的所有标准。为了实现我们自己的服务，我们必须从`JobService`扩展并重写启动和停止回调，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `onStartJob` callback function runs on the main thread, and if the job needs
    to do asynchronous processing then it should return `true` to indicate it's still
    doing work on a background thread. The `callback` function also receives the extra
    parameters specified in the `JobInfo` bundle.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStartJob`回调函数在主线程上运行，如果作业需要进行异步处理，则应返回`true`以指示它仍在后台线程上执行工作。`callback`函数还接收`JobInfo`包中指定的额外参数。'
- en: '`onStopJob` is automatically invoked by the system when it requires to cancel
    the job execution because the criteria specified in the `jobInfo` are no longer
    fulfilled.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStopJob`在系统需要取消作业执行，因为`jobInfo`中指定的标准不再满足时自动调用。'
- en: For example, our job requires to run the work while the device is in an idle
    state, so, if the device leaves the idle mode because the user started to interact
    with the device, `onStopJob` will get called to abandon the execution for the
    meantime.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的任务需要在设备处于空闲状态时运行，因此，如果设备因为用户开始与设备交互而离开空闲模式，`onStopJob`将被调用以暂时放弃执行。
- en: In this function, we should release any resources allocated to our job and stop
    any background processing in place. This function returning `boolean` would indicate
    whether you'd like to retry this job following the same criteria specified in
    the job creation or abandon the job execution. You should use `true` to reschedule
    this job based on the retry criteria specified during the job creation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们应该释放分配给我们的任务的任何资源，并停止任何正在进行的后台处理。这个返回`boolean`类型的函数将指示你是否希望根据在任务创建时指定的相同标准重试此任务，或者放弃任务执行。你应该使用`true`来根据在任务创建期间指定的重试标准重新安排此任务。
- en: 'Before we add our Service business logic, we must add our `Service` class to
    `AndroidManifest.xml` and we must protect our service with the `android.permission.BIND_JOB_SERVICE`
    permission:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加服务业务逻辑之前，我们必须将我们的`Service`类添加到`AndroidManifest.xml`中，并且我们必须使用`android.permission.BIND_JOB_SERVICE`权限保护我们的服务：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are two important things to recall about your `JobService` implementation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于你的`JobService`实现有两个重要的事情需要记住：
- en: One, the `onStartJob` and `onStopJob` callbacks will run on the main thread,
    and it is your responsibility to hand over your service's long running executions
    to separate threads to prevent the appearance of any ANR dialog in your application
    due to a blocking operation in the main thread.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一、`onStartJob`和`onStopJob`回调将在主线程上运行，你有责任将你的服务的长时间运行执行转移到单独的线程上，以防止由于主线程中的阻塞操作而在你的应用程序中出现任何ANR对话框。
- en: Second, the Android system will acquire and hold a `WakeLock` for you while
    your `JobService` callbacks are running or until you explicitly call the `jobFinished`
    method in the case that you return `true` in the `onStartJob` function. If you
    don't, tell the system that your job execution is finished. The `WakeLock` will
    keep your device awake and burn your device's battery in vain. This could make
    your user angry and create a reason to uninstall your application, because your
    application will waste resources and battery and affect the user experience.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，当你的`JobService`回调正在运行或直到你明确调用`jobFinished`方法（在这种情况下，你在`onStartJob`函数中返回`true`）时，Android系统将为你获取并保持一个`WakeLock`。如果你不这样做，告诉系统你的任务执行已完成。`WakeLock`将保持你的设备唤醒，并浪费你的设备电池。这可能会让用户生气，并成为用户卸载应用程序的原因，因为你的应用程序会浪费资源、电池，并影响用户体验。
- en: Now that we have learned the theory about the `JobService`, let's write the
    code to execute the account synchronization with the remote server away from the
    main thread on a background processing line.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了关于`JobService`的理论，让我们编写代码，在后台处理线程上执行与远程服务器的账户同步操作，而不是在主线程上。
- en: 'Considering the Android constructs learned until now, we will use the `AsyncTask`
    construct learned in [Chapter 3](ch03.html "Chapter 3. Exploring the AsyncTask"),
    *Exploring the AsyncTask*, for its simplicity, and create an `AsyncTask` subclass
    to upload the account information using the created for this purpose:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到到目前为止学习的Android结构，我们将使用在[第3章](ch03.html "第3章。探索AsyncTask")中学习的`AsyncTask`结构，*探索AsyncTask*，因为它简单，并创建一个用于上传账户信息的`AsyncTask`子类：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As a starting point, we specified the generic `AsyncTask` class parameter types,
    setting `JobParameters` as the parameter for `doInBackground` and `Result` as
    the type returned from `doInBackground` and passed to the `onPostExecute` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我们指定了通用的`AsyncTask`类参数类型，将`JobParameters`设置为`doInBackground`的参数，将`Result`设置为从`doInBackground`返回的类型，并将其传递给`onPostExecute`函数。
- en: Later, we create the final constant keys used to pass information in the bundle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建用于在bundle中传递信息的最终常量键。
- en: The `Result` type is also recovered from previous sessions to return an error
    when something wrong happens during the background execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`类型也会从之前的会话中恢复，以便在后台执行过程中发生错误时返回错误。'
- en: 'Without going into too much detail, we will implement the `doInBackground`
    code responsible for uploading the data to the remote web service:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，我们将实现负责将数据上传到远程Web服务的`doInBackground`代码：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Some implementation details are elided here for brevity, but we have implemented
    the `doInBackground` function to read the JSON data stored internally on a device
    file and we uploaded it over an `HttpURLConnection`. The Android `Activity` that
    displays the form saves and syncs the button to the final user. The **save** button,
    once pressed, stores the account information in the `account.json` local file
    when the **save** button is clicked.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，这里省略了一些实现细节，但我们已经实现了`doInBackground`函数来读取存储在设备文件上的内部JSON数据，并通过`HttpURLConnection`上传它。显示表单的Android
    `Activity`会将按钮保存并同步到最终用户。当按下**保存**按钮时，会将账户信息存储在`account.json`本地文件中。
- en: The **sync** button, once clicked, will schedule the job for synchronizing the
    data with our remote HTTP server. When the job criteria defined by us are fulfilled,
    `doInBackground` is called to execute the sync procedure in the background.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**同步**按钮时，将安排与我们的远程HTTP服务器同步数据的任务。当我们定义的作业标准得到满足时，`doInBackground`会被调用以在后台执行同步过程。
- en: 'Now that we have the code to upload the data to our server, let''s finish it
    by processing the response and server errors:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了上传数据到我们服务器的代码，让我们通过处理响应和服务器错误来完成它：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When an exception occurs, such as the server being down or a server internal
    error happening, the exception is propagated over our `Result` object to `onPostExecute`
    for further processing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，例如服务器宕机或发生服务器内部错误，异常会通过我们的`Result`对象传播到`onPostExecute`以进行进一步处理。
- en: 'Note that we are being careful to handle the error situations, so, to notify
    the result of the background work to the user, we will write an `onPostExecute`
    function that runs on the main thread that is going to publish a system notification
    that informs the user whether the task was completed successfully or failed miserably:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在小心处理错误情况，因此，为了将后台工作的结果通知用户，我们将编写一个在主线程上运行的`onPostExecute`函数，该函数将发布一个系统通知，告知用户任务是否成功完成或彻底失败：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the task is done, we invoke `jobFinished(JobParameters params, boolean
    needsRescheduled)` to let the system know that we are finished with that task;
    however, when an exception happens, we inform the system that we were unable to
    finish the task with success passing `true` on the second `jobFinished` argument.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务完成时，我们调用`jobFinished(JobParameters params, boolean needsRescheduled)`来让系统知道我们已完成该任务；然而，当发生异常时，我们通过将第二个`jobFinished`参数设置为`true`来通知系统我们未能成功完成任务。
- en: When a finished job failed and needs to be rescheduled, we pass `false` as the
    second `jobService.jobFinished` argument, and the Scheduler API will reschedule
    our job using the back-off time specified in the `JobInfo` object. However, since
    our job only executes on idle mode, the failed job will be added to the scheduler
    queue and re-executed within a future idle maintenance window without using the
    back-off times specified in the `JobInfo`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个完成的作业失败并需要重新安排时，我们将第二个`jobService.jobFinished`参数传递为`false`，调度器API将使用`JobInfo`对象中指定的回退时间重新安排我们的作业。然而，由于我们的作业仅在空闲模式下执行，失败的作业将被添加到调度器队列，并在未来的空闲维护窗口中重新执行，而不使用`JobInfo`中指定的回退时间。
- en: It is important to always call `jobFinished` to release the `WakeLock` assigned
    to the job and to inform the system that it can process additional jobs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总是调用`jobFinished`来释放分配给作业的`WakeLock`，并通知系统它可以处理额外的作业。
- en: If everything goes well, a notification should appear in the notification drawer
    presenting the success message and the time when the last synchronization happened
    successfully.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，通知抽屉中应该会出现一个通知，显示成功消息和上次成功同步的时间。
- en: 'Finally, we can update the `SyncJobService` code to start and stop the `SyncTask`
    execution:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新`SyncJobService`代码以启动和停止`SyncTask`的执行：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing pending jobs
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出挂起的作业
- en: Unlike the `AlarmManager` API, the Scheduler API provides the ability to list
    all the pending schedules for your application. This handy feature could help
    us to recognize the jobs that are going to be executed in the future and react
    accordingly with that list. The list retrieved could help us to pinpoint a pending
    job that we would like to cancel.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与`AlarmManager` API不同，调度器API提供了列出您应用程序所有挂起计划的能力。这个实用的功能可以帮助我们识别将要执行的作业，并相应地处理该列表。检索到的列表可以帮助我们定位我们想要取消的挂起作业。
- en: 'The `JobScheduler` service class has an `instance` method with the following
    signature:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobScheduler`服务类有一个具有以下签名的`instance`方法：'
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The method will return a list of `JobInfo` objects that we can use to observe
    job parameter sets during the job build:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将返回一个`JobInfo`对象列表，我们可以使用它来观察在构建工作期间的工作参数集：
- en: 'Job criteria for each job:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个工作的工作标准：
- en: '`getNetworkType()`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNetworkType()`'
- en: '`isRequireDeviceIdle()`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isRequireDeviceIdle()`'
- en: '`isRequireCharging()`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isRequireCharging()`'
- en: '`getMinLatencyMillis()`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMinLatencyMillis()`'
- en: '`isPeriodic()`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPeriodic()`'
- en: '`getIntervalMillis()`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getIntervalMillis()`'
- en: '`isPersisted()`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPersisted()`'
- en: '`getMaxExecutionDelayMillis()`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMaxExecutionDelayMillis()`'
- en: The `JobService` subclass that will be called back by the `JobScheduler` to
    execute the job—`getService()`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将由`JobScheduler`回调以执行作业的`JobService`子类——`getService()`
- en: 'Job arguments: `getExtras()`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业参数：`getExtras()`
- en: 'Retry policy: `getInitialBackoffMillis()` and `getBackoffPolicy()`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试策略：`getInitialBackoffMillis()`和`getBackoffPolicy()`
- en: 'Okay, now we are ready to create an Activity that prints a list of pending
    jobs for our application:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们准备好创建一个Activity来打印我们应用程序的待处理工作列表：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To list the pending jobs in the UI, we have used the support library `RecyclerView`
    class, a more advanced version of `ListView`, which simplifies the creation of
    a large set of `Views`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在UI中列出待处理的工作，我们使用了支持库的`RecyclerView`类，它是`ListView`的一个更高级版本，简化了创建大量`Views`的过程。
- en: 'First, we will build up our `ViewHolder` to hold the references to the row
    views that will display the `jobId` and the `Service` endpoint:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建我们的`ViewHolder`来保存将显示`jobId`和`Service`端点的行视图的引用：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To bind the `jobInfo` parameters to the current `ViewHolder`, we will write
    the `RecyclerView.onBindViewHolder` to set the information based on the current
    `JobInfo`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`jobInfo`参数绑定到当前的`ViewHolder`，我们将编写`RecyclerView.onBindViewHolder`来根据当前的`JobInfo`设置信息：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Yes, thanks to `getAllPendingJobs`, we have a list of our jobs, and moreover,
    we can analyze that programmatically to create behavior around the current application
    situation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，多亏了`getAllPendingJobs`，我们有了我们工作列表，而且我们还可以通过编程方式分析它，以创建围绕当前应用程序情况的行为。
- en: Some code is omitted on purpose; however, the full source code is available
    on Packt Publishing website. Take a look at the complete source code to appreciate
    how the recycler view and the card view was used to build up the job list UI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 故意省略了一些代码；然而，完整的源代码可以在Packt Publishing网站上找到。查看完整的源代码，可以欣赏到如何使用recycler view和card
    view构建工作列表UI。
- en: To fully manipulate the jobs at will, there is only one CRUD (create, read,
    update, delete) operation that we need to cover in this chapter - the delete operation.
    The delete job operation is delivered by the `cancel` functions and is going to
    be covered in detail in the next section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全随意地操作作业，我们只需要在本章中覆盖一个CRUD（创建、读取、更新、删除）操作——即删除操作。删除作业操作由`cancel`函数提供，将在下一节中详细介绍。
- en: Canceling a job
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消作业
- en: 'There are some situations where we want to provide for the users an ability
    to cancel the job because the environment situation has changed or it does not
    make sense to execute the job anymore—for example, the user changed a piece of
    information that the job depends on and the job is no longer applicable. The `JobScheduler`
    service offers us the support for job cancellation with the following `cancel`
    and `cancelAll` methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，我们希望为用户提供取消作业的能力，因为环境情况已经改变或者执行作业不再有意义——例如，用户更改了作业依赖的信息，作业就不再适用。`JobScheduler`服务通过以下`cancel`和`cancelAll`方法为我们提供了作业取消的支持：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first method, `cancel(jobId)`, allows us to cancel a specific job using
    the job identifier returned from the `schedule(JobInfo job)` function or the `jobId`
    available on `JobInfo` objects returned by the `getAllPendingJobs` function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`cancel(jobId)`允许我们使用从`schedule(JobInfo job)`函数返回的作业标识符或`JobInfo`对象上的`jobId`取消一个特定的作业。
- en: The `cancelAll()` method allows us to cancel the scheduled jobs that have been
    registered with the `JobScheduler` by the current application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancelAll()`方法允许我们取消由当前应用程序通过`JobScheduler`注册的已安排的任务。'
- en: 'With `JobInfo` from the previous example we are able to cancel a specific job
    passing the job identifier:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个示例中的`JobInfo`，我们可以通过传递作业标识符来取消一个特定的作业：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Whenever we cancel a schedule, the job will be removed from the `JobScheduler`
    future execution queue and will no longer be executed by the `SyncJobService`
    or any other `JobService`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们取消一个安排时，该任务将从`JobScheduler`未来执行队列中删除，并且将不再由`SyncJobService`或任何其他`JobService`执行。
- en: Scheduling a periodic job
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排周期性工作
- en: So far, we have scheduled one-shot jobs, but do you know there is an option
    to schedule the execution of a job at periodic internals. These kinds of jobs
    might be the perfect construct to performing repeating backups or repeating network
    operations such as application user data backup.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经安排了一次性作业，但你是否知道还有一个选项可以安排在周期性间隔内执行作业。这类作业可能是执行重复备份或重复网络操作（如应用程序用户数据备份）的完美结构。
- en: Let's update our `AccountInfoActivity` to schedule the periodic execution of
    the account synchronization job.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的 `AccountInfoActivity` 以安排定期执行账户同步作业。
- en: 'We''ll start by defining a new job identifier for our periodic job:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为我们的周期性作业定义一个新的作业标识符：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can schedule a periodic job to be executed approximately every 12 hours
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样安排一个周期性作业，大约每 12 小时执行一次：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we are able to schedule the synchronization job to run periodically in the
    background while the device is idle and the Wi-Fi network is available. The job
    schedule will be persisted by the system and re-enabled after the device boots
    up until we explicitly cancel the job or all the jobs are cancelled through `cancelAll()`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够安排在设备空闲且 Wi-Fi 网络可用的情况下定期在后台运行同步作业。作业调度将由系统持久化，并在设备启动后重新启用，直到我们明确取消作业或通过
    `cancelAll()` 取消所有作业。
- en: Applications of the JobScheduler
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`JobScheduler` 的应用'
- en: The `JobScheduler` API allows us to schedule work that runs asynchronously without
    user intervention in the future under certain conditions. This API is also able
    to reduce the energy consumption by deferring the job execution until the device
    is charging or connected to an unmetered network, such as the Wi-Fi network.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobScheduler` API 允许我们在满足某些条件下，在未来无需用户干预的情况下异步调度工作。此 API 还能够通过推迟作业执行直到设备充电或连接到非计费网络（如
    Wi-Fi 网络）来减少能耗。'
- en: Ideal cases include things such as application database backup that could be
    deferred and do not require exact time execution, a periodic upload of user data
    to the network, and download of configuration parameters. So, typically jobs that
    don't have to run immediately and which data doesn't have to be ready for user
    consumption. Reducing your application energy consumption without compromising
    the user experience will increase the device battery lifetime and therefore improve
    the user experience.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况包括诸如可以推迟且不需要精确时间执行的数据库备份、定期上传用户数据到网络以及配置参数的下载等。因此，通常不需要立即运行且数据不需要为用户消费准备好的作业。在不影响用户体验的情况下减少应用程序的能耗将增加设备电池寿命，从而提高用户体验。
- en: The `JobScheduler` could cover most of the `AlarmManager` use cases, notwithstanding
    it provides advanced features to optimize device resources acquisition. As an
    additional feature, this API provides a way to create schedule that survive the
    device shutdown and restart.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobScheduler` 可以覆盖大多数 `AlarmManager` 的用例，尽管它提供了优化设备资源获取的高级功能。作为附加功能，此 API
    提供了一种创建在设备关闭和重启后仍然有效的调度方式。'
- en: The only big drawback is that `JobScheduler` was only introduced with Android
    5.0 (Lollipop). Therefore, you need to target your application to an API Version
    21 or higher to interact with this API.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是 `JobScheduler` 仅在 Android 5.0（Lollipop）中引入。因此，您需要将应用程序的目标设置为 API 版本 21
    或更高版本，以与该 API 交互。
- en: At the time of writing in July 2016, 45 percent of Android devices run a version
    of Android that supports `JobScheduler`. To get up-to-date information about the
    Android market share by version, please check the Android Developer Dashboard.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2016 年 7 月撰写本文时，45% 的 Android 设备运行支持 `JobScheduler` 的 Android 版本。要获取关于按版本划分的
    Android 市场份额的最新信息，请查看 Android 开发者仪表板。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the `JobSheduler` API, putting it to use to schedule
    background work that starts when a group of conditions defined by us are met.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 `JobSheduler` API，并展示了如何使用它来安排在满足我们定义的一组条件时启动的后台工作。
- en: We learned in detail how to set the different criteria supported by the API
    and how to schedule based on the `JobInfo` object that starts a job when the device
    is charging and not in use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细学习了如何设置 API 支持的不同标准，以及如何根据 `JobInfo` 对象进行调度，该对象在设备充电且未使用时启动作业。
- en: In the meantime, we learned how to implement an asynchronous `JobService` that
    is able to run in a background execution line and finish the job execution properly
    by releasing all the acquired resources (`WakeLock`, `...`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们学习了如何实现一个异步的`JobService`，它能够在后台执行行中运行，并通过释放所有获取的资源（`WakeLock`，`...`）来正确完成作业执行。
- en: Later, we used the `getAllPendingJobs` to create a sample code to list all the
    pending Scheduler API jobs within our application. From the example, we learned
    how to cancel a specific job or all the pending jobs in our applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`getAllPendingJobs`创建了一个示例代码，用于列出我们应用程序中所有挂起的调度器API作业。从示例中，我们学习了如何在我们的应用程序中取消特定作业或所有挂起的作业。
- en: To finish, we built a persistent and recurrent schedule using the `JobSheduler`
    API, which wakes up the device and executes our job every 12 hours.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`JobSheduler` API构建了一个持久和周期性的调度，它每隔12小时唤醒设备并执行我们的作业。
- en: In the next chapter, we will learn how to transfer data from and to the network
    using effective asynchronous libraries and protocols, without even draining the
    battery.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用有效的异步库和协议从网络传输数据，而不会耗尽电池。
