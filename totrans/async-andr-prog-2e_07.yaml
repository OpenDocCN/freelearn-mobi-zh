- en: Chapter 7. Exploring the JobScheduler API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been scheduling background work using a time condition in the
    Handler facilities for the short-term future, and the Android Alarm Manager for
    the long-term future.
  prefs: []
  type: TYPE_NORMAL
- en: Those APIs that are able to execute future tasks at an exact and inexact time
    in the future are used to trigger events, refresh data in the background, or execute
    tasks without user intervention. AlarmManager, which we covered in detail in the
    previous chapter, is able to wake up the device from deep idle states and execute
    work even without considering the device's battery state.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work with JobScheduler to execute jobs
    in the background when several prerequisites are fulfilled and taking into account
    the energy consumption context of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JobScheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the JobScheduler running criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the execution of your job with criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to schedule work with JobService
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing repeating tasks with JobScheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the list of pending JobScheduler schedules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to cancel a task in JobScheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to JobScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android development team, under the project Volta umbrella, introduced in
    the API Level 21 Lollipop release some enhancements and features in order to improve
    the power usage on the Android platform. Apart from the tools introduced to monitor
    and follow the battery usage in the Android platform, a new API for scheduling
    background was officially released to help the developer. It saves extra power
    cycles when the jobs used to support the developer's application do not need a
    time of execution, and can be deferred until the device has better battery and
    network context.
  prefs: []
  type: TYPE_NORMAL
- en: The API was not created to completely replace `AlarmManager`; however, the `JobScheduler`
    API is able to perform a better battery management and supply extra behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features introduced with Scheduler API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Less power consumption**: The job task could be delayed until the device
    is powered to the charger or they are grouped to run in batches on a regular basis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent jobs across reboots**: We are able to install job schedules that
    persistent task across device reboots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better network bandwidth management**: The job could be delayed until a higher
    bandwidth network is available, such as when a Wi-Fi network connection is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less intrusive execution**: The job could be delayed until the user is not
    interacting with the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JobScheduler` is a singleton system service that we can retrieve via a `Context`
    object instance, using a code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `JobScheduler` singleton service instance object helps us to manage our
    running jobs and provides us with member functions to schedule, cancel, and retrieve
    a list of deferred jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a reference to the `JobScheduler` service, we can schedule a job
    by passing `JobInfo` to the `JobScheduler.schedule` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`JobInfo` is the object used in this framework where we specify all the information
    about the job itself, all the conditions that should be fulfilled to initiate
    the job execution, and the unit of work called `JobService` that will be started
    to execute the work required.'
  prefs: []
  type: TYPE_NORMAL
- en: To build a `JobInfo` object, a common factory pattern, known Software Engineering
    as `Builder` and materialized in the static inner-class `JobInfo.Builder`, is
    available to construct the `JobInfo` object passed to `JobScheduler`. The pattern
    provides us with a way to construct a multi-parameter `JobInfo` on a clean, step-by-step
    basis and by using the `Builder` setter functions to define the `JobInfo` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will have to build a `JobInfo.Builder` object using the following
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`jobId` is an internal number used to identify your job in the `JobScheduler`
    service and the second argument is used to set the `JobService` derived class
    that will be invoked when the system verifies that all the pre-requisites are
    met to execute the job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code to show this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setting running criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `Builder` object reference, we can start setting up the job parameters
    and the pre-requisites using the member function available in the `Builder` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a couple of examples. In our first example, the job should
    only start when there is a Wi-Fi network available, so to achieve that, we have
    to use the following code to set the network availability pre-requisite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An unmetered network connection means that you have a connection where you don't
    have a limited amount of data usage per month and you are not charged when you
    go over the usage limit. When a network type is not specified, as a condition,
    the default value is `NETWORK_TYPE_NONE`, meaning that the job will run in any
    network context and even without any network connection. Apart from the previous
    network type criteria, there is `NETWORK_TYPE_ANY`, which determines that the
    job could run when there is network connectivity available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a job to run only when the device is plugged in and charging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When a job should only run when the device is in idle mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Idle mode means that the job should only run when the device is not in use and
    has not been used for some time. This could be the best time to execute heavier
    computations because the user will not notice that the device resources have been
    allocated to your job, thereby the computation does not interfere with the user
    interactions. By default, any job will not require idle mode to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Persist your job execution across device reboots as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Such as an `AlarmManager` job, the job schedule will only survive a reboot
    if your application holds the permissions to receive the completed boot. To achieve
    that, add the following line to the `Android Manifest` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In those cases where you want to schedule a periodic task, you can set the
    interval in milliseconds between subsequent executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is an inexact interval since the Android system will try to group the jobs
    in batches in order to save some battery cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to define a maximum defer time to run your job, we can specify
    a time deadline where the job has to run, then it will run regardless of whether
    or not the other criteria are met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we set one hour as the maximum time to defer this job,
    so, if the other pre-requisites are not fulfilled, after one hour the job is going
    to run by the system independently of the other criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can also specify a minimum defer time to this job as
    a criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the values used above, our job will never run on the next `120` seconds
    since we set a maximum latency time as a prerequisite to our job.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`setMinimumLatency` and `setOverrideDeadline` are not applicable for periodic
    jobs criteria shall be avoided that it is in your recurrent jobs schedules. If
    any one of these criteria are used on recurrent jobs, an `IllegalArgumentException`
    exception will be thrown when the build is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the job fails, in order to specify a retry policy, we have to specify
    the `backoff` initial value that determines the interval between retries and the
    retry increase policy. The `JobScheduler` API provides two policies that define
    the way in which the retry time increases between subsequent tries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BACKOFF_POLICY_LINEAR`: The interval time between retries increases linearly—`initial_backoff_millis
    * num_retries`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BACKOFF_POLICY_EXPONENTIAL`: The interval time between retries increases exponentially—`initial_backoff_millis
    * 2 ^ (num_retries)`![Setting running criteria](img/Image_B05062_07_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `backoff` interval will increase until we reach a backoff of five hours
    (`JobInfo. MAX_BACKOFF_DELAY_MILLIS`) and the initial default value is `30` seconds
    (`JobInfo .DEFAULT_INITIAL_BACKOFF_MILLIS`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the following examples we are going to show you how to create a linear
    and an exponential backoff policy for our `jobInfo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `builder` class also provides us a method to set some parameters to forward
    the job over a `PersistableBundle` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `PersistableBundle` is a special kind of bundle that can be saved and restored
    later. Its main purpose is to pass arguments to the deferred job execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we have all the criteria to schedule our defined job, we are able
    to construct our `JobInfo` and use it to incorporate the job execution in our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling a job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the criteria already defined and the `JobInfo` object, we have all the
    entities required to set up the job for our application. So now let's show you
    how to create a job with a real example.
  prefs: []
  type: TYPE_NORMAL
- en: Our example will synchronize the user account information stored in a device
    file with an HTTP web service over a job scheduled using the Scheduler API. The
    user interface will provide us a UI where we can update the user information,
    a button to save the information on an internal file, and a button to set up the
    synchronization job that will upload the account information to the web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start by defining our job pre-requisites and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Our job should only run when the device is charging to save the battery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our job should only run when an unmetered network is available to save mobile
    network bandwidth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our job should only run when the device is idle because we don't want to slow
    down the UI responsiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our job must run at least once within eight hours of being scheduled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our job should run even after device reboot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `JobInfo` object requires an `ID` to identify the job in all the `JobSchedule`
    methods, so it is a good idea, in order to ensure consistency, to use a `public
    static int` to identify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Subsequent calls to cancel or list jobs created must use the same `jobId` defined
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Since we use a file to store the account information internally on the device,
    the filename used to retrieve account information needs to be passed to the job
    as an argument. The same principle applies to the remote web service endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To forward the required parameters, we have to build `PersistableBundle`, passing
    the filename and endpoint path as bundle parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the criteria are stated and we have the identifier and the class name
    of our service, we are able to create our `JobInfo` using the `Builder` inner
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to schedule the job with the `JobScheduler` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The JobScheduler's `schedule` method will return `RESULT_FAILURE` in the case
    of failure and in the case of success will return the job identifier that we defined
    in the `JobInfo.Builder` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we have just scheduled our job, it's time to write the backup behavior
    in the `JobService` subclass. In the next section, we will detail how to implement
    a `JobService` that plays well with the `JobScheduler` framework.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the JobService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `JobService` subclass is the entity that is going to do the hard work and
    receive the callbacks as soon as all the criteria specified in the `JobInfo` are
    met. To implement our own service, we have to extend from `JobService` and override
    the start and stop callbacks, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `onStartJob` callback function runs on the main thread, and if the job needs
    to do asynchronous processing then it should return `true` to indicate it's still
    doing work on a background thread. The `callback` function also receives the extra
    parameters specified in the `JobInfo` bundle.
  prefs: []
  type: TYPE_NORMAL
- en: '`onStopJob` is automatically invoked by the system when it requires to cancel
    the job execution because the criteria specified in the `jobInfo` are no longer
    fulfilled.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, our job requires to run the work while the device is in an idle
    state, so, if the device leaves the idle mode because the user started to interact
    with the device, `onStopJob` will get called to abandon the execution for the
    meantime.
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we should release any resources allocated to our job and stop
    any background processing in place. This function returning `boolean` would indicate
    whether you'd like to retry this job following the same criteria specified in
    the job creation or abandon the job execution. You should use `true` to reschedule
    this job based on the retry criteria specified during the job creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add our Service business logic, we must add our `Service` class to
    `AndroidManifest.xml` and we must protect our service with the `android.permission.BIND_JOB_SERVICE`
    permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important things to recall about your `JobService` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: One, the `onStartJob` and `onStopJob` callbacks will run on the main thread,
    and it is your responsibility to hand over your service's long running executions
    to separate threads to prevent the appearance of any ANR dialog in your application
    due to a blocking operation in the main thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, the Android system will acquire and hold a `WakeLock` for you while
    your `JobService` callbacks are running or until you explicitly call the `jobFinished`
    method in the case that you return `true` in the `onStartJob` function. If you
    don't, tell the system that your job execution is finished. The `WakeLock` will
    keep your device awake and burn your device's battery in vain. This could make
    your user angry and create a reason to uninstall your application, because your
    application will waste resources and battery and affect the user experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have learned the theory about the `JobService`, let's write the
    code to execute the account synchronization with the remote server away from the
    main thread on a background processing line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the Android constructs learned until now, we will use the `AsyncTask`
    construct learned in [Chapter 3](ch03.html "Chapter 3. Exploring the AsyncTask"),
    *Exploring the AsyncTask*, for its simplicity, and create an `AsyncTask` subclass
    to upload the account information using the created for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As a starting point, we specified the generic `AsyncTask` class parameter types,
    setting `JobParameters` as the parameter for `doInBackground` and `Result` as
    the type returned from `doInBackground` and passed to the `onPostExecute` function.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we create the final constant keys used to pass information in the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: The `Result` type is also recovered from previous sessions to return an error
    when something wrong happens during the background execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going into too much detail, we will implement the `doInBackground`
    code responsible for uploading the data to the remote web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Some implementation details are elided here for brevity, but we have implemented
    the `doInBackground` function to read the JSON data stored internally on a device
    file and we uploaded it over an `HttpURLConnection`. The Android `Activity` that
    displays the form saves and syncs the button to the final user. The **save** button,
    once pressed, stores the account information in the `account.json` local file
    when the **save** button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: The **sync** button, once clicked, will schedule the job for synchronizing the
    data with our remote HTTP server. When the job criteria defined by us are fulfilled,
    `doInBackground` is called to execute the sync procedure in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the code to upload the data to our server, let''s finish it
    by processing the response and server errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When an exception occurs, such as the server being down or a server internal
    error happening, the exception is propagated over our `Result` object to `onPostExecute`
    for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are being careful to handle the error situations, so, to notify
    the result of the background work to the user, we will write an `onPostExecute`
    function that runs on the main thread that is going to publish a system notification
    that informs the user whether the task was completed successfully or failed miserably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When the task is done, we invoke `jobFinished(JobParameters params, boolean
    needsRescheduled)` to let the system know that we are finished with that task;
    however, when an exception happens, we inform the system that we were unable to
    finish the task with success passing `true` on the second `jobFinished` argument.
  prefs: []
  type: TYPE_NORMAL
- en: When a finished job failed and needs to be rescheduled, we pass `false` as the
    second `jobService.jobFinished` argument, and the Scheduler API will reschedule
    our job using the back-off time specified in the `JobInfo` object. However, since
    our job only executes on idle mode, the failed job will be added to the scheduler
    queue and re-executed within a future idle maintenance window without using the
    back-off times specified in the `JobInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to always call `jobFinished` to release the `WakeLock` assigned
    to the job and to inform the system that it can process additional jobs.
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes well, a notification should appear in the notification drawer
    presenting the success message and the time when the last synchronization happened
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can update the `SyncJobService` code to start and stop the `SyncTask`
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Listing pending jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the `AlarmManager` API, the Scheduler API provides the ability to list
    all the pending schedules for your application. This handy feature could help
    us to recognize the jobs that are going to be executed in the future and react
    accordingly with that list. The list retrieved could help us to pinpoint a pending
    job that we would like to cancel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JobScheduler` service class has an `instance` method with the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The method will return a list of `JobInfo` objects that we can use to observe
    job parameter sets during the job build:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Job criteria for each job:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getNetworkType()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRequireDeviceIdle()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRequireCharging()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMinLatencyMillis()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPeriodic()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getIntervalMillis()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPersisted()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMaxExecutionDelayMillis()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `JobService` subclass that will be called back by the `JobScheduler` to
    execute the job—`getService()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Job arguments: `getExtras()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Retry policy: `getInitialBackoffMillis()` and `getBackoffPolicy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, now we are ready to create an Activity that prints a list of pending
    jobs for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To list the pending jobs in the UI, we have used the support library `RecyclerView`
    class, a more advanced version of `ListView`, which simplifies the creation of
    a large set of `Views`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will build up our `ViewHolder` to hold the references to the row
    views that will display the `jobId` and the `Service` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To bind the `jobInfo` parameters to the current `ViewHolder`, we will write
    the `RecyclerView.onBindViewHolder` to set the information based on the current
    `JobInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Yes, thanks to `getAllPendingJobs`, we have a list of our jobs, and moreover,
    we can analyze that programmatically to create behavior around the current application
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: Some code is omitted on purpose; however, the full source code is available
    on Packt Publishing website. Take a look at the complete source code to appreciate
    how the recycler view and the card view was used to build up the job list UI.
  prefs: []
  type: TYPE_NORMAL
- en: To fully manipulate the jobs at will, there is only one CRUD (create, read,
    update, delete) operation that we need to cover in this chapter - the delete operation.
    The delete job operation is delivered by the `cancel` functions and is going to
    be covered in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some situations where we want to provide for the users an ability
    to cancel the job because the environment situation has changed or it does not
    make sense to execute the job anymore—for example, the user changed a piece of
    information that the job depends on and the job is no longer applicable. The `JobScheduler`
    service offers us the support for job cancellation with the following `cancel`
    and `cancelAll` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first method, `cancel(jobId)`, allows us to cancel a specific job using
    the job identifier returned from the `schedule(JobInfo job)` function or the `jobId`
    available on `JobInfo` objects returned by the `getAllPendingJobs` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `cancelAll()` method allows us to cancel the scheduled jobs that have been
    registered with the `JobScheduler` by the current application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `JobInfo` from the previous example we are able to cancel a specific job
    passing the job identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we cancel a schedule, the job will be removed from the `JobScheduler`
    future execution queue and will no longer be executed by the `SyncJobService`
    or any other `JobService`.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling a periodic job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have scheduled one-shot jobs, but do you know there is an option
    to schedule the execution of a job at periodic internals. These kinds of jobs
    might be the perfect construct to performing repeating backups or repeating network
    operations such as application user data backup.
  prefs: []
  type: TYPE_NORMAL
- en: Let's update our `AccountInfoActivity` to schedule the periodic execution of
    the account synchronization job.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining a new job identifier for our periodic job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can schedule a periodic job to be executed approximately every 12 hours
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now we are able to schedule the synchronization job to run periodically in the
    background while the device is idle and the Wi-Fi network is available. The job
    schedule will be persisted by the system and re-enabled after the device boots
    up until we explicitly cancel the job or all the jobs are cancelled through `cancelAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of the JobScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `JobScheduler` API allows us to schedule work that runs asynchronously without
    user intervention in the future under certain conditions. This API is also able
    to reduce the energy consumption by deferring the job execution until the device
    is charging or connected to an unmetered network, such as the Wi-Fi network.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal cases include things such as application database backup that could be
    deferred and do not require exact time execution, a periodic upload of user data
    to the network, and download of configuration parameters. So, typically jobs that
    don't have to run immediately and which data doesn't have to be ready for user
    consumption. Reducing your application energy consumption without compromising
    the user experience will increase the device battery lifetime and therefore improve
    the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The `JobScheduler` could cover most of the `AlarmManager` use cases, notwithstanding
    it provides advanced features to optimize device resources acquisition. As an
    additional feature, this API provides a way to create schedule that survive the
    device shutdown and restart.
  prefs: []
  type: TYPE_NORMAL
- en: The only big drawback is that `JobScheduler` was only introduced with Android
    5.0 (Lollipop). Therefore, you need to target your application to an API Version
    21 or higher to interact with this API.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing in July 2016, 45 percent of Android devices run a version
    of Android that supports `JobScheduler`. To get up-to-date information about the
    Android market share by version, please check the Android Developer Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the `JobSheduler` API, putting it to use to schedule
    background work that starts when a group of conditions defined by us are met.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in detail how to set the different criteria supported by the API
    and how to schedule based on the `JobInfo` object that starts a job when the device
    is charging and not in use.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, we learned how to implement an asynchronous `JobService` that
    is able to run in a background execution line and finish the job execution properly
    by releasing all the acquired resources (`WakeLock`, `...`).
  prefs: []
  type: TYPE_NORMAL
- en: Later, we used the `getAllPendingJobs` to create a sample code to list all the
    pending Scheduler API jobs within our application. From the example, we learned
    how to cancel a specific job or all the pending jobs in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, we built a persistent and recurrent schedule using the `JobSheduler`
    API, which wakes up the device and executes our job every 12 hours.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to transfer data from and to the network
    using effective asynchronous libraries and protocols, without even draining the
    battery.
  prefs: []
  type: TYPE_NORMAL
