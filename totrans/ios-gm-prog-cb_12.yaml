- en: Chapter 12. Implementing Multiplayer Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。实现多人游戏
- en: 'In this chapter we will be focusing on the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下主题：
- en: Creating our TankRace environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的TankRace环境
- en: Movement of players
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的移动
- en: Implementing game play
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现游戏玩法
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In the previous chapter, we covered the handshaking of players like connection
    establishment and assigning a unique identification to the players. Now we shall
    move forward to exploring more about multiplayer games, and create a multiplayer
    game called TankRace. We will be implementing the following things while creating
    the game:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了玩家的握手过程，如连接建立和为玩家分配唯一标识。现在，我们将继续探索更多关于多人游戏的内容，并创建一个名为TankRace的多人游戏。在创建游戏的过程中，我们将实现以下功能：
- en: Creating a visual game setup, like adding players, backgrounds, and other assets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视觉游戏设置，例如添加玩家、背景和其他资产
- en: Implementing movement of players on touching of the screen and also syncing
    the players across devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现玩家在触摸屏幕时的移动，并同步设备上的玩家
- en: Implementing gameplay, which is the game logic for winning and losing on players
    actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现游戏玩法，即玩家操作上的胜利和失败逻辑
- en: Creating our TankRace environment
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的TankRace环境
- en: The name of the game itself suggests that it's a racing game, where there will
    be two players and tanks named the blue tank and the red tank. The tanks will
    be placed on either side of the screen in the portrait mode on the iPhone and
    there will be two finishing lines, a blue line and a red line, to be crossed by
    blue tank (let's say first player) and red tank (let's say second player) respectively.
    The movement of player will be a touch based behavior and the player whose tank
    crosses their finish line first will win and the other will lose. We will be creating
    the environment for the game, TankRace, which will include adding players, game
    background, and finishing lines.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的名字本身暗示它是一个赛车游戏，其中将有两位玩家和名为蓝色坦克和红色坦克的坦克。在iPhone的纵向模式下，坦克将被放置在屏幕的两侧，并将有两个终点线，一个蓝色终点线和一条红色终点线，蓝色坦克（比如说第一位玩家）和红色坦克（比如说第二位玩家）分别要穿越。玩家的移动将基于触摸行为，第一个穿越自己终点线的坦克的玩家将获胜，另一个将失败。我们将创建游戏环境，即TankRace，它将包括添加玩家、游戏背景和终点线。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous chapters, you have learned all about adding sprites and backgrounds
    and updating their attributes like position, rotation, and so on. Now, we will
    be adding all the assets needed in the game to make it playable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经学习了如何添加精灵和背景，以及更新它们的属性，如位置、旋转等。现在，我们将添加游戏中需要的所有资产，使其可玩。
- en: How to do it
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The steps to add all the assets required to be added to the game are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 添加游戏中所需所有资产的操作步骤如下：
- en: 'Drag and add the resources provided with the with the code bundle for this
    chapter, which are: `BlueTank.png`, `RedTank.png`, and `Background.png` to the
    project, After adding the files, the project navigator will look like this:![How
    to do it](img/00175.jpeg)'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章代码包中提供的资源（`BlueTank.png`、`RedTank.png`和`Background.png`）拖放到项目中，添加文件后，项目导航器将看起来像这样：![如何操作](img/00175.jpeg)
- en: 'Now, here, we will be using GameKit, which is a great framework to create social
    games. This framework provides various features such ass peer-to-peer connection,
    game center, and in-game voice chat. Import GameKit and declare some enums, structures,
    properties, and constants to be used in the coming code as shown:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这里，我们将使用GameKit，这是一个创建社交游戏的好框架。这个框架提供了各种功能，如点对点连接、游戏中心和游戏内语音聊天。导入GameKit并声明一些枚举、结构、属性和常量，以便在接下来的代码中使用，如下所示：
- en: 'Import `GameKit` to use CGPoint for storing data structures:'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入`GameKit`以使用CGPoint存储数据结构：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add two more `NetworkPacketCode` for players to move and a packet code for
    when game finishes, for example, a packet for losing a game:'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家添加两个`NetworkPacketCode`以移动，并为游戏结束时添加一个包代码，例如，一个表示游戏失败的包：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Declare a structure called `TankInfo`, which will be used as a data structure
    for sending the information on tanks; the same structure will be used to sync
    at the remote player's receiving end.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个名为`TankInfo`的结构，它将被用作发送坦克信息的数据库结构；相同的结构将在远程玩家的接收端进行同步。
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For the movement of Tanks, add `Speed` and `TurnSpeed` constants
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于坦克的移动，添加`Speed`和`TurnSpeed`常量
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Change the text of the first and the second player's labels to blue and red
    respectively
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一和第二位玩家的标签文本分别改为蓝色和红色
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add text hash defines for when someone wins or loses.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加当有人获胜或失败时的文本哈希定义。
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add some properties to the private interface of `GameScene`, like a local data
    structure of the tank to be maintained and updated, so that it can be sent to
    the remote end as well. Also, declare all the `SKSpriteNodes` and `SKShapeNodes`
    to be used in the game.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `GameScene` 的私有接口添加一些属性，如要维护和更新的坦克局部数据结构，以便它可以发送到远程端。同时，声明所有在游戏中使用的 `SKSpriteNodes`
    和 `SKShapeNodes`。
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we shall add some nodes to the scene, hence the GameScene needs to be of
    the correct size. Click on `GameScene.sks` and open the right panel from the last
    icon on the right top bar of Xcode. From there, change the size of the GameScene
    to `320 x 568` which is the size of the iPhone 4 inch.![How to do it](img/00176.jpeg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在场景中添加一些节点，因此 `GameScene` 需要正确的大小。点击 `GameScene.sks` 并从 Xcode 右上角工具栏的最后一个图标打开右侧面板。从那里，将
    `GameScene` 的大小更改为 `320 x 568`，这是 iPhone 4 英寸的大小。![如何操作](img/00176.jpeg)
- en: Add a method `addGameBackground` under the `adding assets` method's `pragma`
    mark in which a `SKSpriteNode` is created, with the image `Background.png` added
    previously in the project. Keep the *z* position of background as `0` as it will
    be below all other nodes of the game.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `adding assets` 方法的 `pragma` 标记下添加一个方法 `addGameBackground`，在其中创建一个 `SKSpriteNode`，并添加之前在项目中添加的图像
    `Background.png`。保持背景的 *z* 位置为 `0`，因为它将在游戏中的所有其他节点下方。
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add two different methods under the `adding assets` methods `pragma` mark for
    players, namely, blue and red tank with `BlueTank.png` and `RedTank.png` images
    respectively as `SpriteNodes`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `adding assets` 方法下添加两个不同的方法 `pragma` 标记，用于玩家，即蓝色和红色坦克，分别使用 `BlueTank.png`
    和 `RedTank.png` 图像作为 `SpriteNodes`。
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Also, create two methods under the `adding assets` methods `pragma` mark for
    the finishing lines, which both the players will have to reach to win.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 `adding assets` 方法的 `pragma` 标记下创建两个方法，用于完成线，两个玩家都必须达到以获胜。
- en: '[PRE9]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we use the `SKNodeShape` class objects, which are used to draw any required
    shape on the screen using the core graphics path. We are thus adding the red and
    blue lines at either end of the game scene.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里我们使用 `SKNodeShape` 类对象，用于在屏幕上使用核心图形路径绘制任何所需的形状。因此，我们在游戏场景的两端添加红色和蓝色线条。
- en: To set the tanks in the initial positions both in the data structure and in
    the `GameScene`, we will write a method, namely, `resetLocalTanksAndInfoToInitialState`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在数据结构和 `GameScene` 中设置坦克的初始位置，我们将编写一个方法，即 `resetLocalTanksAndInfoToInitialState`。
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this method, the local data structure `tankStatsForLocal` and the local player's
    attributes position, `zRotation` using the only `tankStatsForLocal` are set to
    the initial state of the game. The remote player's position and `zRotation` are
    hardcoded in the initial state of the game. All this is set on the basis of who
    out of blue and red is the local and remote tank on the device.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种方法中，局部数据结构 `tankStatsForLocal` 和局部玩家的属性位置、`zRotation` 使用唯一的 `tankStatsForLocal`
    被设置为游戏的初始状态。远程玩家的位置和 `zRotation` 在游戏的初始状态中硬编码。所有这些设置都是基于在设备上谁属于蓝色和红色，谁是本地和远程坦克。
- en: To animate the players identity text, add a method `hideGameInfoLabelWithAnimation`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要动画化玩家身份文本，添加一个方法 `hideGameInfoLabelWithAnimation`。
- en: '[PRE11]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using sprite `SKAction` a sequence of animations is created, having a delay
    initially, fading the label and then using a callback to remove it at last. This
    is done when the users are connected. For fading in and out of the labels, we
    use the same animation code that we used earlier in [Chapter 3](part0025_split_000.html#page
    "Chapter 3. Animations and Texture"), *Animations and Texture*.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用精灵 `SKAction` 创建一系列动画，最初有延迟，然后淡出标签，最后使用回调将其移除。这是在用户连接时完成的。对于标签的淡入淡出，我们使用之前在
    [第 3 章](part0025_split_000.html#page "第 3 章。动画和纹理") 中使用的相同动画代码，*动画和纹理*。
- en: 'Now, edit the `didChangeState` delegate method of `MCSession`, when the state
    changes to connected as shown in the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑 `MCSession` 的 `didChangeState` 代理方法，当状态变为连接时，如以下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the receiving `MCSession` method, add all `NetworkPacketCode` in the `switch`
    case and make changes when the `KNetworkPacketCodePlayerAllotment` packet is received.
    When allocating the players, set the identity name accordingly and assign the
    local and remote sprite objects depending on the `gameUniqueIdForPlayerAllocation`.
    Finally, call a private method `resetLocalTanksAndInfoToInitialState`, in which
    initial states of both local and remote sprites with their local data structure
    are set. All these steps will be executed on both the connected devices in sessions,
    which will ensure that both the devices are in sync.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收`MCSession`方法中，在`switch`案例中添加所有`NetworkPacketCode`，并在接收到`KNetworkPacketCodePlayerAllotment`数据包时进行更改。在分配玩家时，根据相应的身份名称设置，并根据`gameUniqueIdForPlayerAllocation`分配本地和远程精灵对象。最后，调用一个私有方法`resetLocalTanksAndInfoToInitialState`，在其中设置本地和远程精灵及其本地数据结构的初始状态。所有这些步骤将在会话中的连接设备上执行，这将确保两个设备保持同步。
- en: Now once the `gameInfoLabel` displaying player identity is set, then insert
    the code to change the state of the game and to animate `gameInfoLabel` by hiding
    it in the `startGame` method of `GameScene`, called by a delegate method of `MCBrowerViewController`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一旦设置了显示玩家身份的`gameInfoLabel`，然后在`GameScene`的`startGame`方法中插入代码以改变游戏状态，并通过`MCBrowerViewController`的代理方法来隐藏`gameInfoLabel`，就可以通过隐藏来动画化游戏状态。
- en: '[PRE13]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the method is called by the delegate method, it checks if the allotment
    of the player has been done, then changes the state to playing and animates the
    hiding of the label on which either **You're blue** or **You're red** is written.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当该方法由代理方法调用时，它会检查玩家是否已经分配，然后更改状态为播放，并动画化隐藏标签，标签上写着**你是蓝色**或**你是红色**。
- en: After all these asset addition of games, its environment is setup and player's
    identities or we can say names, have been assigned as blue and red. All this comprises
    of the starter kit of this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加所有这些游戏资产之后，其环境已经设置好，玩家的身份或可以说名字，已经被分配为蓝色和红色。所有这些构成了本章的入门套件。
- en: How it works
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: 'The whole section was about using SpriteKit as a way to add game assets and
    as a part of multiplayer, the players were assigned as blue and red. The working
    part of the node addition on `GameScene` has already been explained in [Chapter
    11](part0065_split_000.html#page "Chapter 11. Getting Started with Multiplayer
    Games"), *Getting Started with Multiplayer Games*, and as a result of the outcome
    of these additions, the game looks like this on both the devices:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 整个部分都是关于使用SpriteKit作为添加游戏资源的方式，以及作为多人游戏的一部分，玩家被分配为蓝色和红色。`GameScene`上节点添加的工作部分已经在[第11章](part0065_split_000.html#page
    "第11章。开始多人游戏")中解释过，即*开始多人游戏*，并且由于这些添加的结果，游戏在两个设备上看起来如下：
- en: '![How it works](img/00177.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/00177.jpeg)'
- en: 'In the multiplayer part, when the user presses the **Done** button, the connection
    is established and both the players are connected. Also, when the user presses
    the **Done** button, names have been assigned to the players as blue and red as
    shown in the following image for both the devices. These labels are on two different
    devices and will animate on the allocation as well:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏部分，当用户按下**完成**按钮时，连接建立，两名玩家都连接上了。此外，当用户按下**完成**按钮时，已经为玩家分配了名称，如以下图像所示，两种设备上均为蓝色和红色。这些标签位于两个不同的设备上，并且将在分配时进行动画：
- en: '![How it works](img/00178.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/00178.jpeg)'
- en: Movement of players
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家的移动
- en: 'Once the environment for multiplayer is ready, it''s time for the actual action:
    making the player move when a user touches or drags on screen. As it''s a multiplayer
    game the movement is to be synced with the remote device, which a good challenge
    and a magical thing to experience.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦多人游戏的环境准备就绪，就是实际操作的时候了：当用户触摸或拖动屏幕时让玩家移动。由于这是一个多人游戏，移动需要与远程设备同步，这是一个很好的挑战，也是一次神奇的经历。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting with this section we should be aware of the touch methods of
    `SKScene` like `touchBegan`, `touchMoved`, and `touchEnded` as all the movement
    will be done on the basis on touch. Also we should be good at mathematics, as
    this movement of tanks with its head to be in the direction of touch, has to be
    done and synced with the remote device. In this section, we will be implementing
    the movement of tanks and also syncing the movement on other device by sending
    and receiving network packets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，我们应该了解`SKScene`的触摸方法，如`touchBegan`、`touchMoved`和`touchEnded`，因为所有的移动都将基于触摸进行。此外，我们还应该擅长数学，因为坦克的移动需要使其头部指向触摸方向，并且需要与远程设备同步。在本节中，我们将实现坦克的移动，并通过发送和接收网络数据包来同步其他设备上的移动。
- en: How to do it
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Following are the steps involved in making a tank move on touch and also sync
    on a remote device by sending and receiving packets:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在通过发送和接收数据包使坦克在触摸时移动并在远程设备上同步的步骤：
- en: On touching the screen, these methods of `SKScene` are called, which will be
    used to move the tank in the local device.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在触摸屏幕时，会调用`SKScene`的这些方法，这些方法将用于在本地设备上移动坦克。
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first method has already been implemented. Let''s add some updated lines
    of tank info on touch begins when the game state is `kGameStatePlaying` as shown
    in the following:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个方法已经实现。让我们在游戏状态为`kGameStatePlaying`时，在触摸开始时添加一些更新的坦克信息，如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this piece of code from the event received by the `touch` method, a `UITouch`
    object is fetched and, using that, the location of touch is determined with respect
    to the `GameScene`. Then if the touch `tapCount` is `0`, that is, the user is
    dragging the code to move, the player is executed. In this code the `tankStatsForLocal`
    is updated on the basis of the position of the touch on screen. The destination
    is set as the touch location, the direction is calculated by using vector mathematics
    using the touch point and the current position of tank. To keep the direction
    angle of the tank between 0 to 359 degrees, extra checks should be put in place
    once the direction is calculated. After all this, to update the actual position
    and rotation of the tank, a method called `updateLocalTank`, which we will be
    discussing soon, will be implemented.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过`touch`方法接收的事件中，获取了一个`UITouch`对象，并使用它来确定触摸位置相对于`GameScene`的位置。然后，如果触摸的`tapCount`为`0`，即用户正在拖动代码以移动，则执行玩家。在这段代码中，`tankStatsForLocal`根据触摸在屏幕上的位置进行更新。目的地设置为触摸位置，方向通过使用向量数学，结合触摸点和坦克的当前位置来计算。为了保持坦克的方向角度在0到359度之间，一旦计算出方向，就需要进行额外的检查。完成所有这些后，为了更新坦克的实际位置和旋转，将实现一个名为`updateLocalTank`的方法，我们将在稍后讨论它。
- en: Implement the two other touch methods as well, `touchMoved` and `touchEnded`,
    in `GameScene`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`中实现另外两个触摸方法，即`touchMoved`和`touchEnded`。
- en: In `touchesMoved`, if the game state is `kGameStatePlaying` then execute the
    same code as in `touchesBegan` method, explained in the preceding point.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`touchesMoved`中，如果游戏状态是`kGameStatePlaying`，则执行与`touchesBegan`方法相同的代码，如前一点所述。
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `touchesEnded` we must not do what we did in the other two touch methods;
    here we will only update the `tankDestination` and `tankDirection` with the local
    data structure and then call the same `updateLocalTank` method to update the final
    position and rotation.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`touchesEnded`中，我们不应该做其他两个触摸方法中所做的；在这里，我们只更新`tankDestination`和`tankDirection`到本地数据结构中，然后调用相同的`updateLocalTank`方法来更新最终的位置和旋转。
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In all the touch methods, the `updateLocalTank` method is called to update the
    final position and rotation. After updating these attributes for the local tank
    a network packet is sent to sync with the remote tank player.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有触摸方法中，都会调用`updateLocalTank`方法来更新最终的位置和旋转。在为本地坦克更新这些属性后，将发送一个网络数据包以与远程坦克玩家同步。
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Initially, check that the destination vector does not have a difference greater
    than the `kTankSpeed`. Then, update the position by the `tankStatsForLocal` destination
    and if the difference is greater, then write the code for turning around; that
    is, calculate the angle difference between the tank direction and `tankRotation`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始时，检查目的地向量与`kTankSpeed`的差异不要超过。然后，通过`tankStatsForLocal`的目的地更新位置，如果差异大于，则编写代码进行转弯；即计算坦克方向和`tankRotation`之间的角度差异。
- en: Check if the difference is greater than `kTankTurnSpeed`, then find the closest
    180 degrees to be rotated, and according to that subtract or add the `kTankTurnSpeed`
    with the rotation. If the difference is not greater than the facing, move around
    the line towards the destination. Set the rotation as the direction and calculate
    the position of the tank using current position, destination, and `kTankSpeed`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果差异大于`kTankTurnSpeed`，则找到最近的180度旋转，并根据该旋转减去或加上`kTankTurnSpeed`以调整旋转。如果差异不大于面向，则围绕线移动到目的地。将旋转设置为方向，并使用当前位置、目的地和`kTankSpeed`计算坦克的位置。
- en: All these calculations should be assigned to the `tankStatsForLocaldata` structure.
    After all this, set the `tankPreviousPosition` of the local data structure as
    the current position of the local player sprite. Update the position and rotation
    calculated in the `tankStatsForLocalstructure`. To sync the player's movement
    produced in this method, we need to send a packet to the other player with `NetworkPacketCode`
    as `KNetworkPacketCodePlayerMove` data part will be in the structure of `tankStatsForLocal`
    and this packet should be sent unreliably because it is been sent very frequently.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些计算都应该分配给`tankStatsForLocaldata`结构。完成所有这些后，将本地数据结构的`tankPreviousPosition`设置为本地玩家的当前精灵位置。更新`tankStatsForLocalstructure`中计算的位置和旋转。为了同步由该方法产生的玩家移动，我们需要向其他玩家发送一个包含`NetworkPacketCode`为`KNetworkPacketCodePlayerMove`的数据包，数据部分将在`tankStatsForLocal`结构中，并且这个数据包应该不可靠地发送，因为它发送得非常频繁。
- en: In the delegate method of `MCSessiondidReceiveData`, the packet for the movement
    of the player with type `KNetworkPacketCodePlayerMove` is received.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MCSessiondidReceiveData`的委托方法中，接收到了类型为`KNetworkPacketCodePlayerMove`的玩家移动数据包。
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `TankInfo` is the structure that holds all the location and rotation related
    data of the user. The `TankInfo` structure is sent over the network to sync both
    the devices.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，`TankInfo`是包含用户所有位置和旋转相关数据的结构。`TankInfo`结构通过网络发送以同步两个设备。
- en: The data is parsed in a `TankInfo` variable `ts`, which contains the sent tank
    position and rotation. Hence it is the data of the remote tank, so update it with
    the attributes received. As a result, we will be able to see the tank moving in
    the remote device, the same as the user driving the tank in the other device.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在`TankInfo`变量`ts`中解析，该变量包含发送的坦克位置和旋转。因此，它是远程坦克的数据，所以使用接收到的属性更新它。结果，我们将在远程设备中看到坦克移动，就像用户在另一台设备中驾驶坦克一样。
- en: How it works
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: The movement of the tanks is done by vector mathematics using the point on which
    the user has touched, what direction the tank is facing at the time of the touch,
    and so on. We have finally achieved the multiplayer behavior in our game where
    a tank moves remotely as per the local tank moves in the device and this can be
    seen in the following snapshot. Synchronization of remote devices entirely depends
    on the network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 坦克的移动是通过向量数学实现的，使用用户触摸的点、坦克在触摸时的朝向等因素。我们最终在我们的游戏中实现了多人行为，其中坦克根据设备中本地坦克的移动进行远程移动，这可以在以下快照中看到。远程设备的同步完全依赖于网络。
- en: If the network is weak, then user may face some lag in sync between devices.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络较弱，用户可能会在设备之间同步时遇到一些延迟。
- en: '![How it works](img/00179.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/00179.jpeg)'
- en: Implementing game play
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏玩法
- en: It is now time to implement the game play in which, how the players (tanks)
    are going to win or lose in the game called TankRace will be determined. The game
    play is that, whichever player first reaches the finish line on their opposite
    side, of the same color as their own, wins the race and other loses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现游戏玩法了，在这个游戏中，玩家（坦克）将如何赢得或输掉名为TankRace的游戏将得到确定。游戏玩法是这样的，哪个玩家首先到达他们自己颜色相同的一侧的终点线，就赢得比赛，而其他玩家则输掉。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we begin, we must know how to detect collision from sprites in the SpriteKit
    and a little about playing with the labels of SpriteKit. In this section, we will
    be implementing the game play and also show an alert when there is no connection
    between the devices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们必须知道如何从SpriteKit中的精灵检测碰撞，以及一些关于SpriteKit标签的玩法。在本节中，我们将实现游戏玩法，并在设备之间没有连接时显示一个警告。
- en: How to do it
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Following are the steps involved for implementing the game play and deciding
    who wins or loses:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现游戏玩法和决定谁赢谁输所涉及的步骤：
- en: We will be detecting the collision in the update method of the `GameScene` by
    using a method called `CGRectIntersectsRect`. In this, we can pass the two frames
    of nodes and it will check if the two frames intersect with each other or not.
    With this check, we will only check this for local player collision, and if collision
    happens update the game state to `kGameStateComplete` and show the local player
    **You Won** who has reached the finish line. Also, as the game has ended, to auto
    start the game, call a method called `restartGameAfterSomeTime`, which we will
    understand as we proceed.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过使用名为`CGRectIntersectsRect`的方法在`GameScene`的更新方法中检测碰撞。在此方法中，我们可以传递两个节点的框架，它将检查这两个框架是否相互交叉。通过这个检查，我们只为本地玩家碰撞进行检查，如果发生碰撞，则更新游戏状态为`kGameStateComplete`，并显示到达终点的本地玩家**你赢了**。此外，由于游戏已经结束，为了自动启动游戏，调用一个名为`restartGameAfterSomeTime`的方法，我们将在继续进行时了解它。
- en: 'After this, the local player is shown the correct result and the game is restarted,
    but as it is a multiplayer game, the reaction of this collision should also be
    reflected on the other device. So, pass a packet with a `NetworkPacketCode` named
    `KNetworkPacketCodePlayerLost` which will be sent to the other player who has
    lost the game. Following is the codes to achieve this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，本地玩家将显示正确的结果，游戏将重新启动，但由于这是一个多人游戏，碰撞的反应也应该反映在另一设备上。因此，传递一个带有名为`KNetworkPacketCodePlayerLost`的`NetworkPacketCode`的数据包，该数据包将被发送给已输掉游戏的另一玩家。以下是实现此功能的代码：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the preceding game lost packet is sent to the other player, a delegate
    method of `MCSession` named `didReceiveData` is called, with a `NetworkPacketCode`
    in the header of the packet named `KNetworkPacketCodePlayerLost`. When this packet
    is received, the game state is changed to `kGameStateComplete` and the game information
    label is shown as **You Lose** to inform the other user of losing the game. Also,
    we call a method `restartGameAfterSomeTime`, which will reset the game to its
    initial state and the players can restart the game again.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前面的游戏丢失的数据包发送给另一玩家时，会调用名为`MCSession`的代理方法`didReceiveData`，数据包的头部有一个名为`KNetworkPacketCodePlayerLost`的`NetworkPacketCode`。当接收到此数据包时，游戏状态将变为`kGameStateComplete`，游戏信息标签显示为**你输了**，以通知其他用户游戏失败。此外，我们调用一个名为`restartGameAfterSomeTime`的方法，该方法将游戏重置为其初始状态，玩家可以再次开始游戏。
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After using these two block of codes, about one player winning and the other
    player losing, the game looks like the following image for both devices:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这两段代码后，大约一名玩家获胜，另一名玩家失败，两个设备上的游戏看起来如下所示：
- en: '![How to do it](img/00180.jpeg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/00180.jpeg)'
- en: 'As `restartGameAfterSomeTime` is used at the time of sending and receiving
    the packet, let us write this method as shown in the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`restartGameAfterSomeTime`在发送和接收数据包时使用，让我们按照以下代码所示编写此方法：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this method, a `NSTimer` of 2.0 seconds will be triggered, calling a function
    `restartGame` in which, again, the `gameUniqueIdFoPlayerAllocation` will be generated,
    the game state set to `kGameStatePlayerToConnect`, and the label text changed
    to **Tap to connect**. For visual initial state, we call the method `resetLocalTanksAndInfoToInitialState`
    in which the local data structure and the visual attributes of tanks are set.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此方法中，将触发一个2.0秒的`NSTimer`，调用一个名为`restartGame`的函数，在此函数中，`gameUniqueIdForPlayerAllocation`将再次生成，游戏状态设置为`kGameStatePlayerToConnect`，标签文本更改为**点击连接**。为了视觉初始状态，我们调用名为`resetLocalTanksAndInfoToInitialState`的方法，在此方法中，设置本地数据结构和坦克的视觉属性。
- en: Whenever the game completes the `restartGameAfterSomeTime` method is called,
    on both local and remote devices, to set the initial state of game and it looks
    like this:![How to do it](img/00181.jpeg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当游戏完成`restartGameAfterSomeTime`方法时，在本地和远程设备上都会调用此方法，以设置游戏的初始状态，看起来如下所示：![如何操作](img/00181.jpeg)
- en: 'Sometimes, due to a weak network, the connection can be lost and the screen
    gets stuck, thereby showing no message to the user. Thus, we will add an alert,
    saying that there is a network problem, and to play, restart your app on both
    the devices, as shown in the following method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，由于网络弱，连接可能会丢失，屏幕会卡住，因此不会向用户显示任何消息。因此，我们将添加一个警告，说明存在网络问题，并且要玩游戏，请在两个设备上重新启动您的应用，如下所示的方法：
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To show the network has disconnected alert, call the `showNetworkDisconnectAlertView`
    when the delegate method of `MCSession` named `didChangeState` is called with
    a change of state as `MCSessionStateNotConnected`. It should be shown only when
    the current game state is `kGameStatePlaying`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示网络已断开连接的警告，当 `MCSession` 的代理方法 `didChangeState` 被调用，并且状态变化为 `MCSessionStateNotConnected`
    时，调用 `showNetworkDisconnectAlertView`。它应该在当前游戏状态为 `kGameStatePlaying` 时显示。
- en: '[PRE24]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whenever the game is disconnected, `showNetworkDisconnectAlertView` is called
    and an alert view is shown as depicted in the following snapshot:![How to do it](img/00182.jpeg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当游戏断开连接时，`showNetworkDisconnectAlertView` 被调用，并显示如图所示的警告视图：![如何操作](img/00182.jpeg)
- en: After all these implementations of game play logic, or we can say the game mechanics,
    we have accomplished making a multiplayer game and this is the solution kit for
    this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现所有这些游戏逻辑之后，或者说游戏机制之后，我们已经完成了制作多人游戏，这是本章的解决方案套件。
- en: How it works
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This section was all about the game play and the game mechanics; it had two
    parts, one detecting the collisions to decide the winner and second resetting
    the game to the initial state once the game ended.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本节全部关于游戏玩法和游戏机制；它分为两部分，一是检测碰撞以决定胜者，二是游戏结束后重置游戏到初始状态。
- en: To accomplish this, using the intersection of frame method, we detected the
    collision and declared the local player as winner and the other player as loser
    by sending a packet. As the game ended here, to help the user restart it again,
    at the same time as declaration of winner and loser takes place, we also reset
    the game to its initial state so that the players can restart the game again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用框架交集方法检测碰撞，并通过发送数据包将本地玩家宣布为胜者，其他玩家为败者。由于游戏在这里结束，为了帮助用户重新开始游戏，在宣布胜者和败者的同时，我们也重置游戏到其初始状态，以便玩家可以再次开始游戏。
- en: There's more
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: 'We have used the Multipeer Connectivity framework whereas we can also use the
    GameKit framework; you can use the following link for more on the same:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了多点连接框架，尽管我们也可以使用 GameKit 框架；有关更多信息，请使用以下链接：
- en: '[https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html)'
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For better understanding and learning of the Multipeer Connectivity framework
    you can visit the following link:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解和学习多点连接框架，您可以访问以下链接：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html](https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html](https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html)'
