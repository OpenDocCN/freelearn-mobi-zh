- en: Chapter 12. Implementing Multiplayer Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will be focusing on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our TankRace environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movement of players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing game play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered the handshaking of players like connection
    establishment and assigning a unique identification to the players. Now we shall
    move forward to exploring more about multiplayer games, and create a multiplayer
    game called TankRace. We will be implementing the following things while creating
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a visual game setup, like adding players, backgrounds, and other assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing movement of players on touching of the screen and also syncing
    the players across devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing gameplay, which is the game logic for winning and losing on players
    actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our TankRace environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the game itself suggests that it's a racing game, where there will
    be two players and tanks named the blue tank and the red tank. The tanks will
    be placed on either side of the screen in the portrait mode on the iPhone and
    there will be two finishing lines, a blue line and a red line, to be crossed by
    blue tank (let's say first player) and red tank (let's say second player) respectively.
    The movement of player will be a touch based behavior and the player whose tank
    crosses their finish line first will win and the other will lose. We will be creating
    the environment for the game, TankRace, which will include adding players, game
    background, and finishing lines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, you have learned all about adding sprites and backgrounds
    and updating their attributes like position, rotation, and so on. Now, we will
    be adding all the assets needed in the game to make it playable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps to add all the assets required to be added to the game are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag and add the resources provided with the with the code bundle for this
    chapter, which are: `BlueTank.png`, `RedTank.png`, and `Background.png` to the
    project, After adding the files, the project navigator will look like this:![How
    to do it](img/00175.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, here, we will be using GameKit, which is a great framework to create social
    games. This framework provides various features such ass peer-to-peer connection,
    game center, and in-game voice chat. Import GameKit and declare some enums, structures,
    properties, and constants to be used in the coming code as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `GameKit` to use CGPoint for storing data structures:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two more `NetworkPacketCode` for players to move and a packet code for
    when game finishes, for example, a packet for losing a game:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Declare a structure called `TankInfo`, which will be used as a data structure
    for sending the information on tanks; the same structure will be used to sync
    at the remote player's receiving end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: For the movement of Tanks, add `Speed` and `TurnSpeed` constants
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Change the text of the first and the second player's labels to blue and red
    respectively
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Add text hash defines for when someone wins or loses.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Add some properties to the private interface of `GameScene`, like a local data
    structure of the tank to be maintained and updated, so that it can be sent to
    the remote end as well. Also, declare all the `SKSpriteNodes` and `SKShapeNodes`
    to be used in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we shall add some nodes to the scene, hence the GameScene needs to be of
    the correct size. Click on `GameScene.sks` and open the right panel from the last
    icon on the right top bar of Xcode. From there, change the size of the GameScene
    to `320 x 568` which is the size of the iPhone 4 inch.![How to do it](img/00176.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method `addGameBackground` under the `adding assets` method's `pragma`
    mark in which a `SKSpriteNode` is created, with the image `Background.png` added
    previously in the project. Keep the *z* position of background as `0` as it will
    be below all other nodes of the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add two different methods under the `adding assets` methods `pragma` mark for
    players, namely, blue and red tank with `BlueTank.png` and `RedTank.png` images
    respectively as `SpriteNodes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, create two methods under the `adding assets` methods `pragma` mark for
    the finishing lines, which both the players will have to reach to win.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we use the `SKNodeShape` class objects, which are used to draw any required
    shape on the screen using the core graphics path. We are thus adding the red and
    blue lines at either end of the game scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To set the tanks in the initial positions both in the data structure and in
    the `GameScene`, we will write a method, namely, `resetLocalTanksAndInfoToInitialState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, the local data structure `tankStatsForLocal` and the local player's
    attributes position, `zRotation` using the only `tankStatsForLocal` are set to
    the initial state of the game. The remote player's position and `zRotation` are
    hardcoded in the initial state of the game. All this is set on the basis of who
    out of blue and red is the local and remote tank on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To animate the players identity text, add a method `hideGameInfoLabelWithAnimation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using sprite `SKAction` a sequence of animations is created, having a delay
    initially, fading the label and then using a callback to remove it at last. This
    is done when the users are connected. For fading in and out of the labels, we
    use the same animation code that we used earlier in [Chapter 3](part0025_split_000.html#page
    "Chapter 3. Animations and Texture"), *Animations and Texture*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `didChangeState` delegate method of `MCSession`, when the state
    changes to connected as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the receiving `MCSession` method, add all `NetworkPacketCode` in the `switch`
    case and make changes when the `KNetworkPacketCodePlayerAllotment` packet is received.
    When allocating the players, set the identity name accordingly and assign the
    local and remote sprite objects depending on the `gameUniqueIdForPlayerAllocation`.
    Finally, call a private method `resetLocalTanksAndInfoToInitialState`, in which
    initial states of both local and remote sprites with their local data structure
    are set. All these steps will be executed on both the connected devices in sessions,
    which will ensure that both the devices are in sync.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now once the `gameInfoLabel` displaying player identity is set, then insert
    the code to change the state of the game and to animate `gameInfoLabel` by hiding
    it in the `startGame` method of `GameScene`, called by a delegate method of `MCBrowerViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the method is called by the delegate method, it checks if the allotment
    of the player has been done, then changes the state to playing and animates the
    hiding of the label on which either **You're blue** or **You're red** is written.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all these asset addition of games, its environment is setup and player's
    identities or we can say names, have been assigned as blue and red. All this comprises
    of the starter kit of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The whole section was about using SpriteKit as a way to add game assets and
    as a part of multiplayer, the players were assigned as blue and red. The working
    part of the node addition on `GameScene` has already been explained in [Chapter
    11](part0065_split_000.html#page "Chapter 11. Getting Started with Multiplayer
    Games"), *Getting Started with Multiplayer Games*, and as a result of the outcome
    of these additions, the game looks like this on both the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the multiplayer part, when the user presses the **Done** button, the connection
    is established and both the players are connected. Also, when the user presses
    the **Done** button, names have been assigned to the players as blue and red as
    shown in the following image for both the devices. These labels are on two different
    devices and will animate on the allocation as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Movement of players
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the environment for multiplayer is ready, it''s time for the actual action:
    making the player move when a user touches or drags on screen. As it''s a multiplayer
    game the movement is to be synced with the remote device, which a good challenge
    and a magical thing to experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting with this section we should be aware of the touch methods of
    `SKScene` like `touchBegan`, `touchMoved`, and `touchEnded` as all the movement
    will be done on the basis on touch. Also we should be good at mathematics, as
    this movement of tanks with its head to be in the direction of touch, has to be
    done and synced with the remote device. In this section, we will be implementing
    the movement of tanks and also syncing the movement on other device by sending
    and receiving network packets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps involved in making a tank move on touch and also sync
    on a remote device by sending and receiving packets:'
  prefs: []
  type: TYPE_NORMAL
- en: On touching the screen, these methods of `SKScene` are called, which will be
    used to move the tank in the local device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first method has already been implemented. Let''s add some updated lines
    of tank info on touch begins when the game state is `kGameStatePlaying` as shown
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this piece of code from the event received by the `touch` method, a `UITouch`
    object is fetched and, using that, the location of touch is determined with respect
    to the `GameScene`. Then if the touch `tapCount` is `0`, that is, the user is
    dragging the code to move, the player is executed. In this code the `tankStatsForLocal`
    is updated on the basis of the position of the touch on screen. The destination
    is set as the touch location, the direction is calculated by using vector mathematics
    using the touch point and the current position of tank. To keep the direction
    angle of the tank between 0 to 359 degrees, extra checks should be put in place
    once the direction is calculated. After all this, to update the actual position
    and rotation of the tank, a method called `updateLocalTank`, which we will be
    discussing soon, will be implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the two other touch methods as well, `touchMoved` and `touchEnded`,
    in `GameScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `touchesMoved`, if the game state is `kGameStatePlaying` then execute the
    same code as in `touchesBegan` method, explained in the preceding point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `touchesEnded` we must not do what we did in the other two touch methods;
    here we will only update the `tankDestination` and `tankDirection` with the local
    data structure and then call the same `updateLocalTank` method to update the final
    position and rotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In all the touch methods, the `updateLocalTank` method is called to update the
    final position and rotation. After updating these attributes for the local tank
    a network packet is sent to sync with the remote tank player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Initially, check that the destination vector does not have a difference greater
    than the `kTankSpeed`. Then, update the position by the `tankStatsForLocal` destination
    and if the difference is greater, then write the code for turning around; that
    is, calculate the angle difference between the tank direction and `tankRotation`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check if the difference is greater than `kTankTurnSpeed`, then find the closest
    180 degrees to be rotated, and according to that subtract or add the `kTankTurnSpeed`
    with the rotation. If the difference is not greater than the facing, move around
    the line towards the destination. Set the rotation as the direction and calculate
    the position of the tank using current position, destination, and `kTankSpeed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these calculations should be assigned to the `tankStatsForLocaldata` structure.
    After all this, set the `tankPreviousPosition` of the local data structure as
    the current position of the local player sprite. Update the position and rotation
    calculated in the `tankStatsForLocalstructure`. To sync the player's movement
    produced in this method, we need to send a packet to the other player with `NetworkPacketCode`
    as `KNetworkPacketCodePlayerMove` data part will be in the structure of `tankStatsForLocal`
    and this packet should be sent unreliably because it is been sent very frequently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the delegate method of `MCSessiondidReceiveData`, the packet for the movement
    of the player with type `KNetworkPacketCodePlayerMove` is received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `TankInfo` is the structure that holds all the location and rotation related
    data of the user. The `TankInfo` structure is sent over the network to sync both
    the devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data is parsed in a `TankInfo` variable `ts`, which contains the sent tank
    position and rotation. Hence it is the data of the remote tank, so update it with
    the attributes received. As a result, we will be able to see the tank moving in
    the remote device, the same as the user driving the tank in the other device.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The movement of the tanks is done by vector mathematics using the point on which
    the user has touched, what direction the tank is facing at the time of the touch,
    and so on. We have finally achieved the multiplayer behavior in our game where
    a tank moves remotely as per the local tank moves in the device and this can be
    seen in the following snapshot. Synchronization of remote devices entirely depends
    on the network.
  prefs: []
  type: TYPE_NORMAL
- en: If the network is weak, then user may face some lag in sync between devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing game play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to implement the game play in which, how the players (tanks)
    are going to win or lose in the game called TankRace will be determined. The game
    play is that, whichever player first reaches the finish line on their opposite
    side, of the same color as their own, wins the race and other loses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin, we must know how to detect collision from sprites in the SpriteKit
    and a little about playing with the labels of SpriteKit. In this section, we will
    be implementing the game play and also show an alert when there is no connection
    between the devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps involved for implementing the game play and deciding
    who wins or loses:'
  prefs: []
  type: TYPE_NORMAL
- en: We will be detecting the collision in the update method of the `GameScene` by
    using a method called `CGRectIntersectsRect`. In this, we can pass the two frames
    of nodes and it will check if the two frames intersect with each other or not.
    With this check, we will only check this for local player collision, and if collision
    happens update the game state to `kGameStateComplete` and show the local player
    **You Won** who has reached the finish line. Also, as the game has ended, to auto
    start the game, call a method called `restartGameAfterSomeTime`, which we will
    understand as we proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, the local player is shown the correct result and the game is restarted,
    but as it is a multiplayer game, the reaction of this collision should also be
    reflected on the other device. So, pass a packet with a `NetworkPacketCode` named
    `KNetworkPacketCodePlayerLost` which will be sent to the other player who has
    lost the game. Following is the codes to achieve this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the preceding game lost packet is sent to the other player, a delegate
    method of `MCSession` named `didReceiveData` is called, with a `NetworkPacketCode`
    in the header of the packet named `KNetworkPacketCodePlayerLost`. When this packet
    is received, the game state is changed to `kGameStateComplete` and the game information
    label is shown as **You Lose** to inform the other user of losing the game. Also,
    we call a method `restartGameAfterSomeTime`, which will reset the game to its
    initial state and the players can restart the game again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After using these two block of codes, about one player winning and the other
    player losing, the game looks like the following image for both devices:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/00180.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'As `restartGameAfterSomeTime` is used at the time of sending and receiving
    the packet, let us write this method as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, a `NSTimer` of 2.0 seconds will be triggered, calling a function
    `restartGame` in which, again, the `gameUniqueIdFoPlayerAllocation` will be generated,
    the game state set to `kGameStatePlayerToConnect`, and the label text changed
    to **Tap to connect**. For visual initial state, we call the method `resetLocalTanksAndInfoToInitialState`
    in which the local data structure and the visual attributes of tanks are set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever the game completes the `restartGameAfterSomeTime` method is called,
    on both local and remote devices, to set the initial state of game and it looks
    like this:![How to do it](img/00181.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sometimes, due to a weak network, the connection can be lost and the screen
    gets stuck, thereby showing no message to the user. Thus, we will add an alert,
    saying that there is a network problem, and to play, restart your app on both
    the devices, as shown in the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To show the network has disconnected alert, call the `showNetworkDisconnectAlertView`
    when the delegate method of `MCSession` named `didChangeState` is called with
    a change of state as `MCSessionStateNotConnected`. It should be shown only when
    the current game state is `kGameStatePlaying`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whenever the game is disconnected, `showNetworkDisconnectAlertView` is called
    and an alert view is shown as depicted in the following snapshot:![How to do it](img/00182.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all these implementations of game play logic, or we can say the game mechanics,
    we have accomplished making a multiplayer game and this is the solution kit for
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section was all about the game play and the game mechanics; it had two
    parts, one detecting the collisions to decide the winner and second resetting
    the game to the initial state once the game ended.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, using the intersection of frame method, we detected the
    collision and declared the local player as winner and the other player as loser
    by sending a packet. As the game ended here, to help the user restart it again,
    at the same time as declaration of winner and loser takes place, we also reset
    the game to its initial state so that the players can restart the game again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used the Multipeer Connectivity framework whereas we can also use the
    GameKit framework; you can use the following link for more on the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For better understanding and learning of the Multipeer Connectivity framework
    you can visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html](https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html)'
  prefs: []
  type: TYPE_NORMAL
