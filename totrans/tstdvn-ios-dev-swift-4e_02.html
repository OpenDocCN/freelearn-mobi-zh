<html><head></head><body>
		<div><h1 id="_idParaDest-17"><em class="italic"><a id="_idTextAnchor018"/>Chapter 1</em>: Your First Unit Tests</h1>
			<p>When the iPhone platform was first introduced, applications were small and focused only on one feature. It was easy to make money with an app that only did one thing (for example, a flashlight app that only showed a white screen). The code of these early apps only had <a id="_idTextAnchor019"/><a id="_idTextAnchor020"/>a few hundred lines and could easily be tested by tapping the screen for a few minutes.</p>
			<p>Since then, the App Store and the available apps have changed a lot. There are still small apps with a clear focus in the App Store, but it's much harder to make money from them. A common app has many features but still needs to be easy to use. There are companies with several developers working on one app full-time. These apps sometimes have a feature set that is normally found in desktop applications. It is very difficult and time-consuming to test all the features in such apps manually for every update.</p>
			<p>One reason for this is that manual testing needs to be done through a <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>), and it takes time to load the app to be tested. In addition to this, human beings are very slow compared to the capabilities of computers for tasks such as testing and verifying computer programs. Most of the time, a computer (or a smartphone) waits for the user's next input. If we could let a computer insert values, testing could be <a id="_idTextAnchor021"/><a id="_idTextAnchor022"/>drastically accelerated. In fact, a computer can run several hundred tests within a few seconds. This is exactly what unit tests are all about.</p>
			<p>A unit test is a piece of code that executes some other code and checks whether the result is what the developer expected. The word "unit" means that the test executes a small unit of code. Usually, that is one function of a class or some similar type of structure. How big the unit actually is depends on the feature to be tested and on the person who is writing the test.</p>
			<p>Writing unit tests seems hard at first because for most developers, it's a new concept. This chapter is aimed at helping you get started with writing your first simple unit tests.</p>
			<p>These are the main topics we will cover in the chapter: </p>
			<ul>
				<li>Building your first automatic unit test</li>
				<li>Assert functions in the <code>XCTest</code> framework</li>
				<li>Understanding the difference from other kinds of tests</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor023"/>Technical requirements</h1>
			<p>All the code in this chapter is uploaded (in complete form) here:</p>
			<p><a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter01">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter01</a></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor024"/>Building your first automatic unit test</h1>
			<p>If you have done <a id="_idIndexMarker000"/>some iOS development (or application development in general) already, the following example might seem familiar to you.</p>
			<p>You are planning to build an app. You start collecting features, drawing some sketches, or your project manager hands the requirements to you. At some point, you start coding. You set up the project and start implementing the required features of the app.</p>
			<p>Let's say the app has an input form, and the values the user puts in have to be validated before the data can be sent to the server. The validation checks, for example, whether the email address and the phone number have a valid format. After implementing the form, you want to check whether everything works. But before you can test it manually, you need to write code that presents the form on the screen. Then, you build and run your app in the iOS simulator. The form is somewhere deep in the view hierarchy, so you navigate to the view and put the values into the form. It doesn't work—something is wrong with the phone number validation code. You go back to the code and try to fix the problem. Sometimes, this also means starting the debugger and stepping through the code to find the bug.</p>
			<p>Eventually, the validation works for the test data you put in. Normally, you would need to test for all possible values to make sure that the validation not only works for your name and your data, but also for all valid data. But there is this long list of requirements on your desk, and you are already running late. The navigation to the form takes three taps in the simulator <a id="_idIndexMarker001"/>and putting in all the different values just takes too long. You are a coder, after all.</p>
			<p>If only a robot could perform this testing for you.  </p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor025"/>What are unit tests?</h2>
			<p>Automatic unit tests act like this robot for you. They execute code, but without having to navigate to the <a id="_idIndexMarker002"/>screen with the feature to test. Instead of running the app over and over again, you write tests with different input data and let the computer test your code in the blink of an eye. Let's see how this works in a simple example.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor026"/>Implementing a unit test example</h2>
			<p>In this example, we <a id="_idIndexMarker003"/>write a simple function that counts the number of vowels in a string. Proceed as follows:</p>
			<ol>
				<li>Open Xcode and go to <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong>.</li>
				<li>Navigate to <strong class="bold">iOS</strong> | <strong class="bold">Application</strong> | <strong class="bold">App</strong> and click on <strong class="bold">Next</strong>.</li>
				<li>Put in the name <code>FirstDemo</code>, select <code>Storyboard</code> for the <code>Swift</code> for the <strong class="bold">Language</strong> field, and check <strong class="bold">Include Tests</strong>.</li>
				<li>Uncheck <strong class="bold">Use Core Data</strong> and click on <strong class="bold">Next</strong>. The following screenshot shows the options in Xcode:</li>
			</ol>
			<div><div><img src="img/Figure_1.01_B18127.jpg" alt="Figure 1.1 – Setting up your new project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Setting up your new project</p>
			<p>Xcode sets up a project ready for development, in addition to two test targets for your unit and your UI tests.</p>
			<ol>
				<li value="5">Open the <code>FirstDemoTests</code> folder in the project navigator. Within the folder, there is one file: <code>FirstDemoTests.swift</code>.</li>
				<li>Select <code>FirstDemoTests.swift</code> to open it in the editor.</li>
			</ol>
			<p>What you see <a id="_idIndexMarker004"/>here is a test case. A test case is a class comprising several tests. In the beginning, it's a good practice to have one test case for each class in the main target.</p>
			<p>Let's go through this file step by step, as follows:</p>
			<p>The file starts with the import of the test framework and the main target, as illustrated here:</p>
			<pre>import XCTest
@testable import FirstDemo</pre>
			<p>Every test case needs to import the <code>XCTest</code> framework. It defines the <code>XCTestCase</code> class and the test assertions that you will see later in this chapter.</p>
			<p>The second line imports the <code>FirstDemo</code> module. All the code you write for the demo app will be in this module. By default, classes, structs, enums, and their methods are defined with internal access control. This means that they can be accessed only from within the module. But the test code lives outside of the module. To be able to write tests for your code, you need to import the module with the <code>@testable</code> keyword. This keyword makes the internal elements of the module accessible in the test case.</p>
			<p>Next, we'll take a look at the class declaration, as follows:</p>
			<pre>class FirstDemoTests: XCTestCase {</pre>
			<p>Nothing special here. This defines the <code>FirstDemoTests</code> class as a subclass of <code>XCTestCase</code>.</p>
			<p>The first two methods in the class are shown in the following code snipp<a id="_idTextAnchor027"/><a id="_idTextAnchor028"/>et:</p>
			<pre>override func setUpWithError() throws {
  // Put setup code here. This method ...
}
override func tearDownWithError() throws {
  // Put teardown code here. This method ...
}</pre>
			<p>The <code>setUpWithError()</code> method is <a id="_idIndexMarker005"/>called before the invocation of each test method in the class. Here, you can insert the code that should run before each test. You will see an example of this later in this chapter.</p>
			<p>The opposite of <code>setUpWithError()</code> is <code>tearDownWithError()</code>. This method is called after the invocation of each test method in the class. If you need to clean up after your tests, put the necessary code in this method.</p>
			<p>The next two methods are template tests provided by the template authors at Ap<a id="_idTextAnchor029"/><a id="_idTextAnchor030"/><a id="_idTextAnchor031"/>ple:</p>
			<pre>func testExample() throws {
  // This is an example of a functional test case.
  // Use XCTAssert and related functions to ...
}
func testPerformanceExample() throws {
  // This is an example of a performance test case.
  self.measure {
    // Put the code you want to measure the time of here.
  }
}</pre>
			<p>The first method is a normal unit test. You will use this kind of test a lot in the course of this book.</p>
			<p>The second method is a performance test. It is used to test methods or functions that perform time-critical computations. The code you put into the measure closure is called 10 times, and the average duration is measured. Performance tests can be useful when implementing or improving complex algorithms and to make sure that their performance does not decline. We will not use performance tests in this book.</p>
			<p>All the test methods that you write have to have the <code>test</code> prefix; otherwise, the test runner can't find <a id="_idIndexMarker006"/>and run them. This behavior allows easy disabling of tests—just remove the <code>test</code> prefix of the method name. Later, you will take a look at other possibilities to disable some tests without renaming or removing them.</p>
			<p>Now, let's implement our first test. Let's assume that you have a method that counts the vowels of a string. A possible implementation looks like <a id="_idTextAnchor032"/><a id="_idTextAnchor033"/>this:</p>
			<pre>func numberOfVowels(in string: String) -&gt; Int {
  let vowels: [Character] = ["a", "e", "i", "o", "u",
                             "A", "E", "I", "O", "U"]
  var numberOfVowels = 0
  for character in string {
    if vowels.contains(character) {
      numberOfVowels += 1
    }
  }
  return numberOfVowels
}</pre>
			<p>I guess this code makes you feel uncomfortable. Please keep calm. Don't throw this book into the corner—we will make this code more "swifty" soon. Add this method to the <code>ViewController</code> class in <code>ViewController.swift</code>.</p>
			<p>This method does the following things:</p>
			<ol>
				<li value="1">First, an array of characters is defined containing all the vowels in the English alphabet.</li>
				<li>Next, we define a variable to store the number of vowels. The counting is done by looping over <a id="_idIndexMarker007"/>the characters of the string. If the current character is contained in the <code>vowels</code> array, <code>numberOfVowels</code> is increased by one.</li>
				<li>Finally, <code>numberOfVowels</code> is returned.</li>
			</ol>
			<p>Open <code>FirstDemoTests.swift</code> and delete the methods with the <code>test</code> prefix. Then, add the following m<a id="_idTextAnchor034"/><a id="_idTextAnchor035"/>ethod:</p>
			<pre>func test_numberOfVowels_whenGivenDominik_shouldReturn3() {
  let viewController = ViewController()
  let result = viewController.numberOfVowels(in: "Dominik")
  XCTAssertEqual(result, 3,
    "Expected 3 vowels in 'Dominik' but got \(result)")
}</pre>
			<p>This test creates an instance of <code>ViewController</code> and assigns it to the <code>viewController</code> constant. It calls the function that we want to test and assigns the result to a constant. Finally, the code in the test method calls the <code>XCTAssertEqual(_:, _:)</code> function to check whether the result is what we expected. If the two first parameters in <code>XCTAssertEqual</code> are equal, the test passes; otherwise, it fails. </p>
			<p>To run the tests, select a simulator of your choice and go to <strong class="bold">Product</strong> | <strong class="bold">Test</strong>, or use the <em class="italic"><img src="img/Symbol_01.png" alt=""/>U </em>shortcut. Xcode compiles the project and runs the test. You will see something similar to this:</p>
			<div><div><img src="img/Figure_1.02_B18127.jpg" alt="Figure 1.2 – Xcode shows a green diamond with a checkmark when a test passes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Xcode shows a green diamond with a checkmark when a test passes</p>
			<p>The green diamond with a <a id="_idIndexMarker008"/>checkmark on the left-hand side of the editor indicates that the test passed. So, that's it—your first unit test. Step back for a moment and celebrate. This could be the beginning of a new development paradigm for you.</p>
			<p>Now that we have a fast test that proves that the <code>numberOfVowels(in:)</code> method does what we intended, we <a id="_idIndexMarker009"/>are going to improve the implementation. The method looks like it has been translated from <code>ViewController.swift</code>, and replace the <code>numberOfVowels(in:)</code> method with this more "swifty" implemen<a id="_idTextAnchor036"/><a id="_idTextAnchor037"/>tation:</p>
			<pre>func numberOfVowels(in string: String) -&gt; Int {
  let vowels: [Character] = ["a", "e", "i", "o", "u",
                             "A", "E", "I", "O", "U"]
  return string.reduce(0) {
    $0 + (vowels.contains($1) ? 1 : 0)
  }
}</pre>
			<p>Here, we make use of the <code>reduce</code> function, which is defined on the array type. The <code>reduce</code> function <a id="_idIndexMarker010"/>combines all the elements of a sequence into one value using the provided closure. <code>$0</code> and <code>$1</code> are anonymous shorthand arguments representing the current value of the combination and the next item in the sequence. Run the tests again (<em class="italic"><img src="img/Symbol_01.png" alt=""/>U</em>) to make sure that this implementation works the same as the one earlier.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor038"/>Disabling slow UI tests</h2>
			<p>You might have <a id="_idIndexMarker011"/>realized that Xcode also runs the UI test in the <code>FirstDemoUITests</code> target. UI tests are painfully slow. We don't want to run those tests every time we type the <em class="italic"><img src="img/Symbol_01.png" alt=""/>U</em> shortcut. To disable the UI tests, proceed as follows:</p>
			<ol>
				<li value="1">Open the scheme selection and click on <strong class="bold">Edit Scheme…</strong>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_1.03_B18127.jpg" alt="Figure 1.3 – Selecting the target selector to open the scheme editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Selecting the target selector to open the scheme editor</p>
			<ol>
				<li value="2">Xcode opens the <a id="_idIndexMarker012"/>scheme editor. Select the <code>FirstDemoUITests</code> target, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_1.04_B18127.jpg" alt="Figure 1.4 – Deselecting the UI test target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Deselecting the UI test target</p>
			<p>This disables the UI tests for this scheme, and running tests becomes fast. Check yourself and run the tests using the <em class="italic"><img src="img/Symbol_01.png" alt=""/>U</em> shortcut.</p>
			<p>Before we move on, let's recap what we have seen so far. First, you learned that you could easily write code that tests your code. Secondly, you saw that a test helped improve the code <a id="_idIndexMarker013"/>because now, you don't have to worry about breaking the feature when changing the implementation.</p>
			<p>To check whether the result of the method is as we expected, we used <code>XCTAssertEqual(_:, _:)</code>. This is one of many <code>XCTAssert</code> functions that are defined in the XCTest framework. The next section shows the most important ones.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor039"/>Assert functions in the XCTest framework</h1>
			<p>Each test needs <a id="_idIndexMarker014"/>to assert some expected behavior. The use <a id="_idIndexMarker015"/>of <code>XCTAssert</code> functions tells Xcode what is expected.</p>
			<p>A test method without an <code>XCTAssert</code> function that doesn't throw an error will always pass.</p>
			<p>The most <a id="_idIndexMarker016"/>important assert functions are <a id="_idTextAnchor040"/><a id="_idTextAnchor041"/><a id="_idIndexMarker017"/>listed here:</p>
			<ul>
				<li><code>XCTAssertTrue(_:_:file:line:)</code>: This asserts that an expres<a id="_idTextAnchor042"/><a id="_idTextAnchor043"/>sion is true.</li>
				<li><code>XCTAssert(_:_:file:line:)</code>: This assertion is the same as <code>XCTAssertTrue(_:_:file:line:)</code>.</li>
				<li><code>XCTAssertFalse(_:_:file:line:)</code>: This asserts that an express<a id="_idTextAnchor044"/><a id="_idTextAnchor045"/><a id="_idTextAnchor046"/><a id="_idTextAnchor047"/>ion is false.</li>
				<li><code>XCTAssertEqual(_:_:_:file:line:)</code>: This asserts that two expressio<a id="_idTextAnchor048"/><a id="_idTextAnchor049"/>ns are equal.</li>
				<li><code>XCTAssertEqual(_:_:accuracy:_:file:line:)</code>: This asserts that two expressions are the same, taking into account the accuracy defined in the <code>accura<a id="_idTextAnchor050"/><a id="_idTextAnchor051"/>cy</code> parameter.</li>
				<li><code>XCTAssertNotEqual(_:_:_:file:line:)</code>: This asserts that two expressions are not equal.</li>
				<li><code>XCTAssertNotEqual(_:_:accuracy:_:file:line:)</code>: This asserts that two expressions are not the same, taking into account the accuracy defined in the <code>accura<a id="_idTextAnchor052"/><a id="_idTextAnchor053"/>cy</code> parameter.</li>
				<li><code>XCTAssertNil(_:_:file:line:)</code>: This asserts that an expression is nil.</li>
				<li><code>XCTAssertNotNil(_:_:file:line:)</code>: This asserts that an expression is not nil.</li>
				<li><code>XCTFail(_:file:line:)</code>: This always fails.</li>
			</ul>
			<p>To take a look at a full list of the available <code>XCTAssert</code> functions, press <em class="italic">Ctrl</em> and click on the <code>XCTAssertEqual</code> word in the test that you have just written. Then, select <strong class="bold">Jump to Definition</strong> in the pop-up menu, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_1.05_B18127.jpg" alt="Figure 1.5 – Jump to Definition of a selected function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Jump to Definition of a selected function</p>
			<p>Note that <a id="_idIndexMarker018"/>most <code>XCTAssert</code> functions can <a id="_idIndexMarker019"/>be replaced with <code>XCTAssert(_:_:file:line)</code>. For example, the following assert functions are asser<a id="_idTextAnchor054"/><a id="_idTextAnchor055"/>ting the same thing:</p>
			<pre>// This assertion asserts the same as...
XCTAssertEqual(2, 1+1, "2 should be the same as 1+1")
// ...this assertion
XCTAssertTrue(2 == 1+1, "2 should be the same as 1+1")</pre>
			<p>But you should use more precise assertions whenever possible, as the log output of the more precise assertion methods tells you exactly what happened in case of a failure. For example, look at the log output of the following two assertions:</p>
			<pre>XCTAssertEqual(1, 2)
// Log output:
// XCTAssertEqual failed: ("1") is not equal to ("2")
XCTAssert(1 == 2)
// Log output:
// XCTAssertTrue failed</pre>
			<p>In the first case, you don't <a id="_idIndexMarker020"/>need to look at the test <a id="_idIndexMarker021"/>to understand what happened. The log tells you exactly what went wrong.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor056"/>Custom assert functions</h2>
			<p>But sometimes, even the more precise assert function is not precise enough. In this case, you can write your <a id="_idIndexMarker022"/>own assert functions. As an example, let's assume we have a test that asserts that two dictionaries have the same content. If we used <code>XCTAssertEqual</code> to test that, the log output woul<a id="_idTextAnchor057"/><a id="_idTextAnchor058"/>d look like this:</p>
			<pre>func test_dictsAreQual() {
  let dict1 = ["id": "2", "name": "foo"]
  let dict2 = ["id": "2", "name": "fo"]
  XCTAssertEqual(dict1, dict2)
  // Log output:
  // XCTAssertEqual failed: ("["name": "foo", "id":
    "2"]")...
  // ...is not equal to ("["name": "fo", "id": "2"]")
}</pre>
			<p>For the short dictionaries in this example, finding the difference is quite easy. But what if the dictionary has 20 entries or even more? When we add the following assert function to the test target, we get be<a id="_idTextAnchor059"/><a id="_idTextAnchor060"/>tter log outputs:</p>
			<pre>func DDHAssertEqual&lt;A: Equatable, B: Equatable&gt;
  (_ first: [A:B],
   _ second: [A:B]) {
  if first == second {
    return
  }
  for key in first.keys {
    if first[key] != second[key] {
      let value1 = String(describing: first[key]!)
      let value2 = String(describing: second[key]!)
      let keyValue1 = "\"\(key)\": \(value1)"
      let keyValue2 = "\"\(key)\": \(value2)"
      let message = "\(keyValue1) is not equal to
        \(keyValue2)"
      XCTFail(message)
      return
    }
  }
}</pre>
			<p>This method compares the values for each key and fails if one of the values differs. Additionally, this assert function <a id="_idIndexMarker023"/>should check whether the dictionaries have the same keys. This functionality is left as an exercise for the reader. Here, we focus this example on how to write a custom assert function. By keeping the example short, the main point is easier to understand.</p>
			<p>When we run this test with the preceding dictionaries, we see the following output in Xcode:</p>
			<div><div><img src="img/Figure_1.06_B18127.jpg" alt="Figure 1.6 – Xcode showing the failure at two different places&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Xcode showing the failure at two different places</p>
			<p>As you can see in the preceding screenshot, Xcode shows the test failure in the assert function. In the test <a id="_idIndexMarker024"/>method, it only shows a redirect to the failure. Fortunately, there is an easy fix for that. All we have to do is to pass <code>file</code> and <code>line</code> parameters to the custom assert function and use these in the <code>XCTFail</code> call, like this:</p>
			<pre> func DDHAssertEqual&lt;A: Equatable, B: Equatable&gt;(
  _ first: [A:B],
  _ second: [A:B],
  file: StaticString = #filePath,        // &lt;&lt; new
  line: UInt = #line) {                  // &lt;&lt; new
    if first == second {
      return
    }
    for key in first.keys {
      if first[key] != second[key] {
        let value1 = String(describing: first[key]!)
        let value2 = String(describing: second[key]!)
        let keyValue1 = "\"\(key)\": \(value1)"
        let keyValue2 = "\"\(key)\": \(value2)"
        let message = "\(keyValue1) is not equal to
          \(keyValue2)"
        XCTFail(message, file: file, line: line)  // &lt;&lt; new
        return
      }
    }
  }</pre>
			<p>Note that our assert function <a id="_idIndexMarker025"/>now has two new parameters: <code>file</code> and <code>line</code>, with the default values <code>#filePath</code> and <code>#line</code>, respectively. When the function is called in a test method, these default parameters make sure that the file path and the line of the call site are passed into that assert function. These parameters are then forwarded into the <code>XCTAssert</code> functions (<code>XCTFail</code> in our case, but this works with all XCT... functions). As a result, the failure is now shown in the line in which the <code>DDHAssertEqual</code> function is called, and we didn't have to change the call of the assert function. The following screenshot illustrates this:</p>
			<div><div><img src="img/Figure_1.07_B18127.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Improved failure reporting</p>
			<p>This example shows how <a id="_idIndexMarker026"/>easy it is to write your own assert functions that behave like the ones that come with Xcode. Custom assert functions can improve the readability of the test code, but keep in mind that this is also code you have to maintain.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor061"/>Understanding the difference from other kinds of tests</h1>
			<p>Unit tests are just one piece of a good test suite. In my opinion, they are the most important tests because when carried out correctly, they are fast, focused, and easy to understand. But to increase your confidence in your code, you should additionally add integration, UI/snapshot, and manual tests. What are those?</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor062"/>Integration tests</h2>
			<p>In integration tests, the feature that is being tested is not isolated from the rest of the code. With these kinds <a id="_idIndexMarker027"/>of tests, the developer tries to figure out if the different units (that are thoroughly tested with unit tests) interact with each other as required. As a result, integration tests execute real database queries and fetch data from live servers, which makes them significantly slower than unit tests. They are not run as often as unit tests and failures are more difficult to understand as the error has to be tracked down in <a id="_idIndexMarker028"/>all involved code units.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor063"/>UI tests</h2>
			<p>As the name suggests, UI tests run on the UI of an app. A computer program (the test runner) executes the <a id="_idIndexMarker029"/>app as a user would do. Usually, this means that in such a test assertion, we also have to use information accessible on screen. This means a UI test can only test whether a feature works as required when the result is visible on screen. In addition, these tests are usually quite slow as the test runner often has to wait until animations and screen updates are finished.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor064"/>Snapshot tests</h2>
			<p>Snapshot tests compare the UI with previously taken snapshots. If a defined percentage of pixels differs from <a id="_idIndexMarker030"/>the snapshot image, the test fails. This makes them a perfect fit for situations where the UI of one app screen is already finished and you want to make sure that it won't change for given test data. </p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor065"/>Manual tests</h2>
			<p>The final kind of test in the development of an app is a manual test. Even if you have hundreds of unit and integration tests, real people using your app will most probably find a bug. To minimize <a id="_idIndexMarker031"/>the number of bugs your users can find, you need testers in your team or to ask some users for feedback on the beta version of your app. The more diverse the group of beta testers is, the more bugs they will find before your app ships.</p>
			<p>In this book, we will only cover unit tests because <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) only works reasonably well with fast reliable feedback.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor066"/>Summary</h1>
			<p>In this chapter, we discussed what unit tests are and saw some easy unit tests in action. We learned about the different assert functions available in <code>XCTest</code>, the testing framework provided by Apple. By writing our own assert function, we learned to improve the log output and what needs to be done to make it behave like built-in functions. This chapter concluded with other kinds of tests and how they differ from unit tests.</p>
			<p>In the next chapter, we will learn what TDD is, and what its advantages and disadvantages are.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor067"/>Exercises</h1>
			<ol>
				<li value="1">Write an assert function that only fails when the keys in two dictionaries differ. This assert function should also fail if a key is missing in one of the dictionaries.</li>
				<li>Improve <code>DDHAssertEqual&lt;A: Equatable, B: Equatable&gt;(_:_:file:line:)</code> such that it also checks the keys of the dictionaries.</li>
			</ol>
		</div>
	</body></html>