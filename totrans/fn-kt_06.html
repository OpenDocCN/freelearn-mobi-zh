<html><head></head><body>
        

                            
                    <h1 class="header-title">Delegates in Kotlin</h1>
                
            
            
                
<p>In the last two chapters, we learned about functions and function types in functional programming. We also learned about the various types of function Kotlin has to offer.</p>
<p>This chapter is based on delegates in Kotlin. Delegates are awesome features of Kotlin in favour of functional programming. If you are coming from a non-FP background such as Java, you are probably hearing about delegates for the first time. So in this chapter, we will try to untangle things for you.</p>
<p>We will start by learning the basics of delegation and then gradually move into implementations of delegates in Kotlin.</p>
<p>The following list contains the topics that will be covered in this chapter:</p>
<ul>
<li>Introduction to delegation</li>
<li>Delegates in Kotlin</li>
<li>Delegated properties</li>
<li>Standard delegates</li>
<li>Custom delegates</li>
<li>Delegated map</li>
<li>Local delegation</li>
<li>Class delegation</li>
</ul>
<p>So, let's get started with delegates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to delegation</h1>
                
            
            
                
<p>The origin of delegation in programming is from object composition. Object composition is a way to combine simple objects to derive a complex one. Object compositions are a critical building block of many basic data structures, including the tagged union, the linked list, and the binary tree.</p>
<p>To make object composition more reusable (as reusable as inheritance), a new pattern is incorporated—the <strong>delegation pattern</strong>.</p>
<p>This pattern allows an object to have a helper object, and that helper object is called a <strong>delegate</strong>. This pattern allows the original object to handle requests by delegating to the delegate helper object.</p>
<p>Though delegation is an object-oriented design pattern, not all languages have implicit support for delegation (such as Java, which doesn't support delegation implicitly). In those cases, you can still use <em>delegation</em> by explicitly passing the original object to the delegate to a method, as an argument/parameter.</p>
<p>But with the language support (such as in Kotlin), delegation becomes easier and often seems like using the original variable itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding delegation</h1>
                
            
            
                
<p>Over time, the delegation pattern has proven to be a better alternative of inheritance. Inheritance is a powerful tool for code reuse, especially in the context of the <em>Liskov Substitution</em> model. Moreover, the direct support of OOP languages makes it even stronger.</p>
<p>However, inheritance still has some limitations, such as a class can't change its superclass dynamically during program execution; also, if you perform a small modification to the super class, it'll be directly propagated to the child class, and that is not what we want every time.</p>
<p>Delegation, on the other hand, is flexible. You can think of delegation as a composition of multiple objects, where one object passes its method calls to another one and calls it a delegate. As I mentioned earlier, delegation is flexible; you can change the delegate at runtime.</p>
<p>For an example, think of the <kbd>Electronics</kbd> class and <kbd>Refrigerator</kbd> class. With inheritance, <kbd>Refrigerator</kbd> should implement/override the <kbd>Electronics</kbd> method calls and properties. With delegation however, the <kbd>Refrigerator</kbd> object would keep a reference of the <kbd>Electronics</kbd> object and would pass the method calls with it.</p>
<p>Now, since we know that Kotlin provides support for delegation, let's get started with delegation in Kotlin.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Delegates in Kotlin</h1>
                
            
            
                
<p>Kotlin has out-of-the-box support for delegation. Kotlin provides you with some standard delegates for properties for most common programming needs. Most of the time, you'll find yourself using those standard delegates, instead of creating your own one; however, Kotlin also allows you to create your own delegate, as per your requirements.</p>
<p>Not only delegation for properties, Kotlin also allows you to have delegated classes.</p>
<p>So basically, there are two types of delegation in Kotlin, which are as follows:</p>
<ul>
<li>Property delegation</li>
<li>Class delegation</li>
</ul>
<p>So, let's have a look at the property delegation first, and then we will move ahead with class delegation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Property delegation (standard delegates)</h1>
                
            
            
                
<p>In the previous section, where we discussed delegation, we learned that delegation is a technique of method passing/forwarding.</p>
<p>For property delegates, it almost does the same. A property can pass its getter and setter calls to the delegate and the delegate can handle those calls on behalf of the property itself.</p>
<p>You're probably thinking, what is the benefit of passing getter and setter calls to the delegate? Only the delegate you're using can answer this question. Kotlin has multiple predefined standard delegations for most common use cases. Let's have a look at the following list, containing available standard delegates:</p>
<ul>
<li>The <kbd>Delegates.notNull</kbd> function and <kbd>lateinit</kbd></li>
<li>The <kbd>lazy</kbd> function</li>
<li>The <kbd>Delegates.Observable</kbd> function</li>
<li>The <kbd>Delegates.vetoble</kbd> function</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Delegates.notNull function and lateinit</h1>
                
            
            
                
<p>Think of a situation where you need to declare a property at the class level, but you don't have the initial value for the variable there. You'll get the value at some later point, but before the property is actually used, and you're confident that the property will get initialised before using and it'll not be null. But, as per Kotlin syntax, you must initialize a property at the time of initializing. The quick fix is to declare it as a <kbd>nullable var</kbd> property, and assign a default null value. But as we mentioned earlier, since you are confident that the variable will not be null while using it, you are not willing to declare it as nullable.</p>
<p><kbd>Delegates.notNull</kbd> is here to save you in this scenario. Have a look at the following program:</p>
<pre>var notNullStr:String by Delegates.notNull&lt;String&gt;() 
 
fun main(args: Array&lt;String&gt;) { 
    notNullStr = "Initial value" 
    println(notNullStr) 
} </pre>
<p>Focus on the first line—<kbd>var notNullStr:String by Delegates.notNull&lt;String&gt;()</kbd>, we declared a non-null <kbd>String var</kbd> property, but we didn't initialize it. Instead, we wrote <kbd>by Delegates.notNull&lt;String&gt;()</kbd>, but what does it mean? Let us inspect. The <kbd>by</kbd> operator is a reserved keyword in Kotlin, to be used with delegates. The <kbd>by</kbd> operator works with two operands, on the left-hand side of <kbd>by</kbd> will be the property/class that needs to be delegated, and on the right-hand side will be the delegate.</p>
<p>The delegate—<kbd>Delegates.notNull</kbd> allows you to temporarily go without initializing the property. It must be initialized before it is used (as we did on the very first line of the <kbd>main</kbd> method), otherwise it'll throw an exception.</p>
<p>So, let's modify the program by adding another property, which we will not initialize before using it, and see what happens:</p>
<pre>var notNullStr:String by Delegates.notNull&lt;String&gt;() 
var notInit:String by Delegates.notNull&lt;String&gt;() 
 
fun main(args: Array&lt;String&gt;) { 
    notNullStr = "Initial value" 
    println(notNullStr) 
    println(notInit) 
} </pre>
<p>The output looks like the following:</p>
<div><img height="204" width="471" src="img/562500f7-04ce-47e2-97b1-5eca2ded726f.png"/></div>
<p>So, the <kbd>notInit</kbd> property caused the exception—<kbd>Property notInit should be initialized before get</kbd>.</p>
<p>But doesn't the variable declaration—<kbd>by Delegates.notNull()</kbd> sound awkward? The Kotlin team also thought the same way. That's why from Kotlin 1.1 they added a simple keyword—<kbd>lateinit</kbd>, to achieve the same objective. As it simply states about late initialization, it should be simply <kbd>lateinit</kbd>.</p>
<p>So, let's modify the last program by replacing <kbd>by Delegates.notNull()</kbd> with <kbd>lateinit</kbd>. The following is the modified program:</p>
<pre>lateinit var notNullStr1:String 
lateinit var notInit1:String 
 
fun main(args: Array&lt;String&gt;) { 
    notNullStr1 = "Initial value" 
    println(notNullStr1) 
    println(notInit1) 
} </pre>
<p>In this program, we had to rename the variables, as you can't have two top-level (package-level variable, without any class/function) variables of the same name. Except variable names, the only thing that changed is we added <kbd>lateinit</kbd>, instead of <kbd>by Delegates.notNull()</kbd>.</p>
<p>So, now let's have a look at the following output to identify if there's any change:</p>
<div><img height="150" width="503" src="img/0bb69276-a4e0-4be2-8f3a-4bed42942b3a.png"/></div>
<p>The output is also identical, except it slightly changes the error message. It now says, <kbd>lateinit property notInit1 has not been initialized</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The lazy function</h1>
                
            
            
                
<p>The <kbd>lateinit</kbd> keyword works only on the <kbd>var</kbd> properties. The <kbd>Delegates.notNull()</kbd>  function works properly only with <kbd>var</kbd> properties, too.</p>
<p>So, what should we do when using <kbd>val</kbd> properties? Kotlin provides you with another delegation—<kbd>lazy</kbd>, that's meant for <kbd>val</kbd> properties only. But it works in a slightly different way.</p>
<p>Unlike <kbd>lateinit</kbd> and <kbd>Delegates.notNull()</kbd>, you must specify how you want to initialize the variable at the time of declaration. So, what's the benefit? The initialization will not be called until the variable is actually used. That's why this delegate is called <kbd>lazy</kbd>; it enables lazy initialization of properties.</p>
<p>The following is a code example:</p>
<pre>val myLazyVal:String by lazy { 
    println("Just Initialised") 
    "My Lazy Val" 
} 
 
fun main(args: Array&lt;String&gt;) { 
    println("Not yet initialised") 
    println(myLazyVal) 
} </pre>
<p>So in this program, we declared a <kbd>String val</kbd> property—<kbd>myLazyVal</kbd> with a <kbd>lazy</kbd> delegate. We used (printed) that property in the second line of the <kbd>main</kbd> function.</p>
<p>Now, let's focus on the variable declaration. The <kbd>lazy</kbd> delegate accepts a lambda that's expected to return the value of the property.</p>
<p>So, let's have a look at the output:</p>
<div><img height="124" width="384" src="img/e9487a37-2d5f-4e9d-bd10-d85cb1c96271.png"/></div>
<p class="mce-root">Notice that the output clearly shows that the property got initialized after the first line of the <kbd>main</kbd> method executed, that is, when the property was actually used. This <kbd>lazy</kbd> initialization of properties can save your memory by a significant measure. It also comes as a handy tool in some situations, for example, think of a situation where you want to initialize the property with some other property/context, which would be available only after a certain point (but you have the property name); in that situation, you can simply keep the property as <kbd>lazy</kbd>, and then you can use it when it's confirmed that the initialization will be successful.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Observing property value change with Delegates.Observable</h1>
                
            
            
                
<p>Delegates are not only for initializing properties lately/lazily. As we learned, delegation enables the forwarding of getter and setter calls of a property to the delegate. This enables delegates to offer more cool features than just lately/lazily initialization.</p>
<p>One such cool feature comes with <kbd>Delegates.observable</kbd>. Think of a situation where you need to look out for the value change of a property, and perform some action as soon as this occurs. The immediate solution that comes to our mind is to override the setter, but this would look nasty and make codes complex, whereas delegates are there to save our life.</p>
<p>Have a look at the following example:</p>
<pre>var myStr:String by Delegates.observable("&lt;Initial Value&gt;") { 
    property, oldValue, newValue -&gt; 
    println("Property `${property.name}` changed value from "$oldValue" to "$newValue"") 
} 
 
fun main(args: Array&lt;String&gt;) { 
    myStr = "Change Value" 
    myStr = "Change Value again" 
} </pre>
<p>It's a simple example, we declared a <kbd>String</kbd> property—<kbd>myStr</kbd>, with the help of <kbd>Delegates.observable</kbd> (we will describe that initialization soon after having a look at the output), then, inside the <kbd>main</kbd> function, we changed the value of <kbd>myStr</kbd> twice.</p>
<p>Have a look at the following output:</p>
<div><img height="92" width="506" src="img/29f2b91e-fc1f-4b14-bc94-732c2397b7ef.png"/></div>
<p>In the output, we can see, that for both times we changed the value, a log got printed with the old and new value of the property. The <kbd>Delegates.observable</kbd> block in this program is responsible for that log in the output. So now, let's have a close look at the <kbd>Delegates.observable</kbd> block and understand how it works:</p>
<pre>var myStr:String by Delegates.observable("&lt;Initial Value&gt;") { 
    property, oldValue, newValue -&gt; 
    println("Property `${property.name}` changed value from "$oldValue" to "$newValue"") 
} </pre>
<p>The <kbd>Delegates.observable</kbd> function takes two parameters to create the delegate. The first argument is the initial value of the property, and the second argument is the lambda that should be executed whenever the value change is noticed.</p>
<p>The lambda for <kbd>Delegates.observable</kbd> expects three parameters:</p>
<ul>
<li>The first one is an instance of <kbd>KProperty&lt;out R&gt;</kbd></li>
</ul>
<div><kbd>KProperty</kbd> is an interface in the Kotlin <kbd>stdlib</kbd>, <kbd>kotlin.reflect</kbd> package, it is a property; such as a named <kbd>val</kbd> or <kbd>var</kbd> declaration. Instances of this class are obtainable by the <kbd>::</kbd> operator. For more information, visit: <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/.</a></div>
<ul>
<li>The second parameter contains the old value of the property (the last value just before the assignment)</li>
<li>The third parameter is the newest value assigned to the property (the new value used in the assignment)</li>
</ul>
<p>So, as we've got the concept of <kbd>Delegates.observable</kbd>, let's move ahead with a new delegate, <kbd>Delegates.vetoable</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The power of veto – Delegates.vetoable</h1>
                
            
            
                
<p><kbd>Delegates.vetoable</kbd> is another standard delegate that allows us to veto a value change.</p>
<p>A <strong>veto</strong>, Latin for <em>I forbid,</em> is the power (for example, used by an officer of the state) to unilaterally stop an official action. There is more information here: <a href="https://en.wikipedia.org/wiki/Veto">https://en.wikipedia.org/wiki/Veto</a>.<a href="https://en.wikipedia.org/wiki/Veto"/></p>
<p>This right to veto allows us to have a logic check on each assignment of the property, where we can decide to continue with the assignment or not.</p>
<p>The following is an example:</p>
<pre>var myIntEven:Int by Delegates.vetoable(0) { 
    property, oldValue, newValue -&gt; 
    println("${property.name} $oldValue -&gt; $newValue") 
    newValue%2==0 
} 
 
fun main(args: Array&lt;String&gt;) { 
    myIntEven = 6 
    myIntEven = 3 
    println("myIntEven:$myIntEven") 
} </pre>
<p>In this program, we created an <kbd>Int</kbd> property—<kbd>myIntEven</kbd>; this property should only accept even numbers as an assignment. The <kbd>Delegates.vetoable</kbd> delegate works almost the same as the <kbd>Delegates.observable</kbd> function, just there's a small change in the lambda. Here, the lambda is expected to return a Boolean; the assignment would be passed if that returned Boolean is <kbd>true</kbd>, else the assignment would be dismissed.</p>
<p>Have a look back at the program. While declaring the variable with the delegate <kbd>Delegates.vetoable</kbd>, we passed <kbd>0</kbd> as the initial value, then, in the lambda, we logged an assignment call, then we will return <kbd>true</kbd> if the new value is even and <kbd>false</kbd> if odd.</p>
<p>Here is the output:</p>
<div><img height="118" width="363" src="img/132e0642-60b1-4e3f-afb3-49aa4632b57d.png"/></div>
<p>So, in the output, we can see two logs of assignment, but when we printed the <kbd>myIntEven</kbd> property after the last assignment, we can see the last assignment wasn't successful.</p>
<p>Interesting, isn't it? Let us see another example of <kbd>Delegates.vetoable</kbd>. Have a look at the following code:</p>
<pre>var myCounter:Int by Delegates.vetoable(0) { 
    property, oldValue, newValue -&gt; 
    println("${property.name} $oldValue -&gt; $newValue") 
    newValue&gt;oldValue 
} 
 
fun main(args: Array&lt;String&gt;) { 
    myCounter = 2 
    println("myCounter:$myCounter") 
    myCounter = 5 
    myCounter = 4 
    println("myCounter:$myCounter")  
    myCounter++ 
    myCounter-- 
    println("myCounter:$myCounter") 
} </pre>
<p>This program has a property—<kbd>myCounter</kbd>, which is expected to increase with each assignment.</p>
<p>In the lambda, we checked if the <kbd>newValue</kbd> value is greater than the <kbd>oldValue</kbd> value. Here is the output:</p>
<div><img height="232" width="384" src="img/a5ef800e-3e61-4f75-8dbe-9efbb6620ca0.png"/></div>
<p>The output which shows those assignments where the value was increased was successful, but those where the value decreased got dismissed.</p>
<p>Even when we used the increment and decrement operators, the increment operator was successful, but the decrement operator wasn't. This feature wouldn't be that easy to implement without delegates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Delegated map</h1>
                
            
            
                
<p>So, we learned how to use standard delegates, but Kotlin has to offer more with delegation. The map delegation is among those awesome features that comes with delegation. So, what is it? It is the freedom of passing a map as a single parameter instead of numbers of parameters in a function/class constructor. Let's have a look. The following is a program applying <em>map delegation</em>:</p>
<pre>data class Book (val delegate:Map&lt;String,Any?&gt;) { 
    val name:String by delegate 
    val authors:String by delegate 
    val pageCount:Int by delegate 
    val publicationDate:Date by delegate 
    val publisher:String by delegate 
} 
 
fun main(args: Array&lt;String&gt;) { 
    val map1 = mapOf( 
            Pair("name","Reactive Programming in Kotlin"), 
            Pair("authors","Rivu Chakraborty"), 
            Pair("pageCount",400), 
            Pair("publicationDate",SimpleDateFormat("yyyy/mm/dd").parse("2017/12/05")), 
            Pair("publisher","Packt") 
    ) 
    val map2 = mapOf( 
            "name" to "Kotlin Blueprints", 
            "authors" to "Ashish Belagali, Hardik Trivedi, Akshay Chordiya", 
            "pageCount" to 250, 
            "publicationDate" to SimpleDateFormat("yyyy/mm/dd").parse("2017/12/05"), 
            "publisher" to "Packt" 
    ) 
 
    val book1 = Book(map1) 
    val book2 = Book(map2) 
 
    println("Book1 $book1 nBook2 $book2") 
} </pre>
<p>The program is simple enough; we defined a <kbd>Book</kbd> data class, and in the constructor, instead of taking all member values one by one, we took a map and then delegated all to the map delegate.</p>
<p>One thing to be cautious here is to mention all member variables in the map, and the key name should exactly match the property name.</p>
<p>Here is the output:</p>
<div><img height="171" width="500" src="img/01d55125-05ae-49c3-a258-dbc919e5606d.png"/></div>
<p>Simple enough, isn't it? Yes, delegations are that much powerful. But are you curious about what will happen if we skip mentioning any of the properties in the map? It will simply avoid the properties you skipped, and if you explicitly try to access them, then it'll throw an exception—<kbd>java.util.NoSuchElementException</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom delegation</h1>
                
            
            
                
<p>So far in this chapter, we have seen the standard delegations available with Kotlin. However, Kotlin does allow us to write our own custom delegates, to suit our custom needs.</p>
<p>For example, in the program, where we checked for the <kbd>Even</kbd> with <kbd>Delegates.vetoable</kbd>, we could only discard the value assignment, but there's no way to automatically assign the next even number to the variable.</p>
<p>In the following program, we used <kbd>makeEven</kbd>, a custom delegate which would automatically assign the next even number if an odd number is passed to the assignment, otherwise if an even number is passed to the assignment, it would pass that.</p>
<p>Have a look at the following program:</p>
<pre>var myEven:Int by makeEven(0) { 
    property, oldValue, newValue, wasEven -&gt; 
    println("${property.name} $oldValue -&gt; $newValue, Even:$wasEven") 
} 
 
fun main(args: Array&lt;String&gt;) { 
    myEven = 6 
    println("myEven:$myEven") 
    myEven = 3 
    println("myEven:$myEven") 
    myEven = 5 
    println("myEven:$myEven") 
    myEven = 8 
    println("myEven:$myEven") 
} </pre>
<p>Here is the output:</p>
<div><img height="225" width="375" src="img/59858d6f-3f44-44e2-9a36-1fbbd54cfd42.png"/></div>
<p>The output clearly shows that whenever we assigned an even number to <kbd>myEven</kbd>, it got assigned, but when we assigned an odd number, the next even number (<kbd>+1</kbd>) got assigned.</p>
<p>For this delegate, we used almost the same lambda as the <kbd>Delegates.observable</kbd> we just added one more parameter—<kbd>wasEven:Boolean</kbd>, which will contain <kbd>true</kbd> if the assigned number was even, or <kbd>false</kbd> otherwise.</p>
<p>Eager to know how we created the delegate? Here is the code:</p>
<pre>abstract class MakeEven(initialValue: Int):ReadWriteProperty&lt;Any?,Int&gt; { 
    private var value:Int = initialValue 
 
    override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;) = value 
 
    override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, newValue: Int) { 
        val oldValue = newValue 
        val wasEven = newValue %2==0 
        if(wasEven) { 
            this.value = newValue 
        } else { 
            this.value = newValue +1 
        } 
        afterAssignmentCall(property,oldValue, newValue,wasEven) 
    } 
 
    abstract fun afterAssignmentCall (property: KProperty&lt;*&gt;, oldValue: Int, newValue: Int, wasEven:Boolean):Unit 
} </pre>
<p>For creating a delegate on <kbd>var</kbd> properties, you need to implement the <kbd>ReadWriteProperty</kbd> interface.</p>
<p>That interface has two functions to be overridden—<kbd>getValue</kbd> and <kbd>setValue</kbd>. These functions are actually delegated functions of the getters and setters of the property. You can return your desired value from the <kbd>getValue</kbd> function, which will then be forwarded as the return value of the property. Every time the property is accessed, the <kbd>getValue</kbd> function will be called. Similarly, every time the property is assigned a value, the <kbd>setValue</kbd> function will get called, and whatever we return from the <kbd>setValue</kbd> function will actually be the value the property is finally assigned. For example, assume a property <kbd>a</kbd> is assigned <kbd>X</kbd>, but from the <kbd>setValue</kbd> function, we returned <kbd>Y</kbd>, so after the assignment statement, the property <kbd>a</kbd> will actually hold <kbd>Y</kbd> instead of <kbd>X</kbd>.</p>
<p>So, if you want to return the property's value from your delegate's <kbd>getValue</kbd> function, you must keep the value of the property stored somewhere (yes, you would not be able to pull the value from the original property, maybe because the original property will not even store the value, as the property knows that it would be delegated). In this program, we used a mutable <kbd>var</kbd> property—<kbd>value</kbd>, to store the value of the property. We are returning <kbd>value</kbd> from the <kbd>getValue</kbd> function.</p>
<p>Inside the <kbd>setValue</kbd> function, we checked whether the assigned <kbd>newValue</kbd> is even or not. If even, we assigned that <kbd>newValue</kbd> to the value property (which will be returned from the <kbd>getValue</kbd> function), and if the <kbd>newValue</kbd> is odd, we assigned <kbd>newValue+1</kbd> to the <kbd>value</kbd> property.</p>
<p>In the <kbd>MakeEven</kbd> class, we have an abstract function—<kbd>afterAssignmentCall</kbd>. We called this function during the end of the <kbd>setValue</kbd> function. This function is meant for logging purposes.</p>
<p>So, the delegate is almost ready, but what about the abstract function? We need to extend this class to apply the delegate, right? But remember the code where we used it like <kbd>by makeEven(0) {...}</kbd>, so there must be a function there, mustn't there? Yes, there's a function, the following is the definition:</p>
<pre> inline fun makeEven(initialValue: Int, crossinline onAssignment:(property: KProperty&lt;*&gt;, oldValue: Int, newValue: Int, wasEven:Boolean)-&gt;Unit):ReadWriteProperty&lt;Any?, Int&gt; 
        =object : MakeEven(initialValue){ 
    override fun afterAssignmentCall(property: KProperty&lt;*&gt;, oldValue: Int, newValue: Int, wasEven: Boolean) 
            = onAssignment(property,oldValue,newValue,wasEven) 
} </pre>
<p>We created an anonymous object of <kbd>MakeEven</kbd> and passed it as a delegate, and we passed the argument lambda—<kbd>onAssignment</kbd>, as the abstract function—<kbd>afterAssignmentCall</kbd>.</p>
<p>So, we've got to grip with delegates, let's move ahead and try our hands on some more interesting aspects of delegates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Local delegates</h1>
                
            
            
                
<p>Delegation is powerful, we've already seen that, but think of a common situation where inside a method we declare and initialize a property, then we apply a logic which will either use the property or will continue without it. For example, the following is such a program:</p>
<pre>fun useDelegate(shouldPrint:Boolean) { 
    val localDelegate = "Delegate Used" 
    if(shouldPrint) { 
        println(localDelegate) 
    } 
     
    println("bye bye") 
} </pre>
<p>In this program, we will use the <kbd>localDelegate</kbd> property, only if the <kbd>shouldPrint</kbd> value is <kbd>true</kbd>, else we won't use it. But it would always take space in memory since it is declared and initialized. An option to avoid this memory blockage is to have the property inside the <kbd>if</kbd> block, but it's a simple dummy program, and here we can easily afford to move the variable declaration inside the <kbd>if</kbd> block, whereas in many real-life scenarios, moving the variable declaration inside the <kbd>if</kbd> block is not possible.</p>
<p>So, what's the solution? Yes, using <kbd>lazy</kbd> delegation can save our life here. But it wasn't possible in Kotlin before the arrival of Kotlin 1.1.</p>
<p>So, the following is the updated program:</p>
<pre>fun useDelegate(shouldPrint:Boolean) { 
    val localDelegate by lazy { 
        "Delegate Used" 
    } 
    if(shouldPrint) { 
        println(localDelegate) 
    } 
     
    println("bye bye") 
} </pre>
<p>Though we only used <kbd>lazy</kbd> for this example, from Kotlin 1.1, we can have any delegation applied in local properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Class delegation</h1>
                
            
            
                
<p>Class delegation is another interesting feature of Kotlin. How? Just think of the following situation.</p>
<p>You have an interface, <em>I</em>, and two classes, <em>A</em> and <em>B</em>. Both <em>A</em> and <em>B</em> implement <em>I</em>. In your code, you've an instance of <em>A</em> and you want to create an instance of <em>B</em> from that <em>A</em>.</p>
<p>In traditional inheritance, it is not directly possible; you have to write a bunch of nasty codes to achieve that, but class delegation is there to save you.</p>
<p>Go through the following code:</p>
<pre>interface Person { 
    fun printName() 
} 
 
class PersonImpl(val name:String):Person { 
    override fun printName() { 
        println(name) 
    } 
} 
 
class User(val person:Person):Person by person { 
    override fun printName() { 
        println("Printing Name:") 
        person.printName() 
    } 
} 
 
fun main(args: Array&lt;String&gt;) { 
    val person = PersonImpl("Mario Arias") 
    person.printName() 
    println() 
    val user = User(person) 
    user.printName() 
} </pre>
<p>In this program, we created the instance of <kbd>User</kbd>, with its member property—<kbd>person</kbd>, which is an instance of the <kbd>Person</kbd> interface. In the main function, we passed an instance of <kbd>PersonImpl</kbd> to the user to create the instance of <kbd>User</kbd>.</p>
<p>Now, have a look at the declaration of <kbd>User</kbd>. After color (<kbd>:</kbd>), the phrase <kbd>Person by person</kbd> indicates that the class <kbd>User</kbd> extends <kbd>Person</kbd> and is expected to copy <kbd>Person</kbd> behaviors from the provided <kbd>person</kbd> instance.</p>
<p>Here is the output:</p>
<div><img height="154" width="376" src="img/47465d12-c4c5-46c2-aeab-eb0f50f470a0.png"/></div>
<p>The output shows the overriding works as expected, and we can also access properties and functions of the <kbd>person</kbd>, just like a normal property.</p>
<p>A really awesome feature, isn't it?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about delegates and we saw how to use delegates in various ways to make our code efficient and clean. We learned about different features and parts of delegates, and how to use them.</p>
<p>The next chapter is about coroutines, a path-breaking feature of Kotlin, to enable seamless asynchronous processing while keeping the developer's life easy and straightforward.</p>
<p>So, don't wait long, start with the next chapter now.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>