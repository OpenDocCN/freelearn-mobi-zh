<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Wi-Fi Smart Power Plug</h1></div></div></div><p>In this chapter, we will build an open source version of a very commonly connected object—a Wi-Fi power plug. Indeed, these kind of plugs can be bought from many stores, and usually come with their own iOS or Android app.</p><p>In this chapter, we will <a id="id206" class="indexterm"/>build such a power plug from scratch, based on Arduino. We will connect a relay module, a current sensor, and a Wi-Fi module to an Arduino board to make our own Wi-Fi power plug. The power plug will be able to switch any device on and off, and will continuously measure the power consumption of the device.</p><p>We will build an Android app to switch on and off the power plug remotely via Wi-Fi. We will also be able to get the power output on request and display it on a screen.</p><p>The following topics will be the major takeaways from this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connecting a relay module, a current sensor, and a Wi-Fi module to Arduino</li><li class="listitem" style="list-style-type: disc">Controlling the project by sending commands via Wi-Fi</li><li class="listitem" style="list-style-type: disc">Building an Android application to control the project from a mobile phone or tablet</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Hardware and software requirements</h1></div></div></div><p>First, let's see<a id="id207" class="indexterm"/> the <a id="id208" class="indexterm"/>required hardware components for this chapter.</p><p>We need an Arduino Uno board. To control the lamp remotely (the lamp was used as an example in the chapter, but of course any 110V or 230V device can be used here), you will also need a relay module. We used a 5V relay module from Polulu, but you can use any 5V relay module that you want.</p><p>To measure the instant power consumption of the device connected to the plug, you will also need a current sensor. For this part, we will choose a breakout board based on the ACS712 chip. The following is a picture of the board I used:</p><div><img src="img/0389OS_04_02.jpg" alt="Hardware and software requirements"/></div><p>You will also need a board that includes the CC3000 Wi-Fi chip, which we will use to receive <a id="id209" class="indexterm"/>commands via the Android device. For <a id="id210" class="indexterm"/>this project, we will choose a CC3000 breakout board from Adafruit. Of course, you can also use a shield from the same brand for this project; the code will be exactly the same.</p><p>To make the different connections, you will also need a breadboard and some jumper wires.</p><p>The following is a list of the components that were used in this project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id211" class="indexterm"/> Arduino Uno board (<a class="ulink" href="https://www.adafruit.com/products/50">https://www.adafruit.com/products/50</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id212" class="indexterm"/>5V relay module (<a class="ulink" href="http://www.pololu.com/product/2480">http://www.pololu.com/product/2480</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id213" class="indexterm"/>current sensor (<a class="ulink" href="http://imall.iteadstudio.com/im120710011.html">http://imall.iteadstudio.com/im120710011.html</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id214" class="indexterm"/>Adafruit CC3000 Wi-Fi breakout board (<a class="ulink" href="https://www.adafruit.com/product/1469">https://www.adafruit.com/product/1469</a>)</li><li class="listitem" style="list-style-type: disc">The<a id="id215" class="indexterm"/> breadboard (<a class="ulink" href="https://www.adafruit.com/products/64">https://www.adafruit.com/products/64</a>)</li><li class="listitem" style="list-style-type: disc">Jumper wires (<a class="ulink" href="https://www.adafruit.com/products/1957">https://www.adafruit.com/products/1957</a>)</li></ul></div><p>To connect <a id="id216" class="indexterm"/>a lamp or any other device to the project, you will need a pair of power cables: one male <a id="id217" class="indexterm"/>power plug and one female power plug. You <a id="id218" class="indexterm"/>will also need some screw terminals to make the required connections. The following is an image of the cables I used for this project:</p><div><img src="img/0389OS_04_03.jpg" alt="Hardware and software requirements"/></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>
<strong>Warning</strong>:</p><p>It can be dangerous to use high-voltage devices with such project. So, make sure to carefully follow all the instructions in the next section. Of course, you can make the entire project without connecting the project to the mains electricity; the principles are exactly the same.</p></div></div><p>On the software side, you will need the latest version of the Arduino IDE. You will need the <a id="id219" class="indexterm"/>library for the CC3000 chip found at <a class="ulink" href="https://github.com/adafruit/Adafruit_CC3000_Library">https://github.com/adafruit/Adafruit_CC3000_Library</a>.</p><p>You will also need the<a id="id220" class="indexterm"/> aREST library found at <a class="ulink" href="https://github.com/marcoschwartz/aREST">https://github.com/marcoschwartz/aREST</a>.</p><p>To install an Arduino library, simply put the <code class="literal">library</code> folder into your <code class="literal">/libraries</code> folder inside your main <code class="literal">Ard</code>
<code class="literal">uino</code> folder.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Configuring the hardware</h2></div></div></div><p>It's now time to <a id="id221" class="indexterm"/>assemble the hardware part of the project. Let's start by connecting the Adafruit CC3000 breakout board. First, connect the Arduino Uno +5V pin to the red rail on the breadboard, and the ground pin to the blue rail.</p><p>Then, connect the IRQ pin of the CC3000 board to pin number 3 of the Arduino board, <strong>VBAT</strong> to pin <strong>5</strong>, and <strong>CS</strong> to pin <strong>10</strong>. After that, you will need to connect the <strong>SPI</strong> pins to the Arduino board: <strong>MOSI</strong>, <strong>MISO</strong>, and <strong>CLK</strong> go to pins <strong>11</strong>, <strong>12</strong>, and <strong>13</strong>, respectively. Finally, take care of the power supply: <strong>VIN</strong> goes to the Arduino 5V (red power rail) and <strong>GND</strong> to <strong>GND</strong> (blue power rail).</p><p>The following is a schematic of the project, without the relay module connected:</p><div><img src="img/0389OS_04_04.jpg" alt="Configuring the hardware"/></div><p>We will now connect the relay module. First, connect the power supply: the <strong>VCC</strong> pin of the relay goes to the red <a id="id222" class="indexterm"/>power rail, and the <strong>GND</strong> pin goes to the blue power rail. Then, connect the signal pin of the relay (usually denoted as SIG) to Arduino pin number <strong>8</strong> followed by the current sensor. Like the relay, connect the power first: the <strong>VCC</strong> pin of the relay goes to the red power rail, and the <strong>GND</strong> pin goes to the blue power rail. Then, connect the signal pin of the sensor (usually denoted as SIG or OUT) to Arduino analog pin <strong>A0</strong>.</p><p>We will now take care of connecting the project to the device you want to control, and to the mains electricity.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Be very careful at this step as it involves high voltages (110V or 230V), which can be lethal. Also, make sure that you always connect the project to the mains electricity when you check everything else. When all other connections are done, make sure that you are not touching any bare cables. It is also recommended that you put the complete project in a plastic enclosure.</p></div></div><p>The following schematic describes how the different cables are connected to the relay and to the current sensor:</p><div><img src="img/0389OS_04_05.jpg" alt="Configuring the hardware"/></div><p>Note that as we are <a id="id223" class="indexterm"/>using AC voltages, the polarity of the cables doesn't matter here.</p><p>The following is an image illustrating the different connections between the cables, the relay, and the current sensor:</p><div><img src="img/0389OS_04_06.jpg" alt="Configuring the hardware"/></div><p>Finally, the following is an image of the complete project, with the male cable connected to the mains electricity, and <a id="id224" class="indexterm"/>a lamp connected to the female plug:</p><div><img src="img/0389OS_04_07.jpg" alt="Configuring the hardware"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Testing the relay</h2></div></div></div><p>We will now test <a id="id225" class="indexterm"/>the project, by testing the relay and switching it on and off. This will ensure that the relay is correctly connected to your Arduino board, and that the power cable connections are correctly done (otherwise, no electricity will flow through the connected device). Again, check every single connection before plugging the project into the mains electricity.</p><p>The following is the complete Arduino sketch for this part:</p><div><pre class="programlisting">// Relay pin
const int relay_pin = 8;

void setup() {
  pinMode(relay_pin,OUTPUT);
}

void loop() {

  // Activate relay
  digitalWrite(relay_pin, HIGH);

  // Wait for 5 seconds
  delay(5000);

   // Deactivate relay
  digitalWrite(relay_pin, LOW);

  // Wait for 5 seconds
  delay(5000);
}</pre></div><p>We will now consider the <a id="id226" class="indexterm"/>details of this sketch. It starts by declaring which pin the relay is connected to:</p><div><pre class="programlisting">const int relay_pin = 8;</pre></div><p>Then, in the <code class="literal">setup()</code> function of the sketch, we will declare this pin as an output:</p><div><pre class="programlisting">pinMode(relay_pin,OUTPUT);</pre></div><p>Finally, in the <code class="literal">loop()</code> function of the sketch, we will switch the pin from the on state to the off state every 5 seconds:</p><div><pre class="programlisting">// Activate relay
digitalWrite(relay_pin, HIGH);

// Wait for 5 seconds
delay(5000);</pre></div><p>Note that you can find<a id="id227" class="indexterm"/> the complete code for this part in the GitHub repository of the book at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p><p>Make sure that everything is connected correctly, that you have a device (like a lamp) connected to our project and that the project is plugged into the mains electricity. Again, check that every connection is correctly made before plugging the project into the mains electricity. You can now upload the sketch to your Arduino board. You should hear the relay switching on and off, and see the <a id="id228" class="indexterm"/>lamp switching on and off as well.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Writing the Arduino sketch</h1></div></div></div><p>Now <a id="id229" class="indexterm"/>that we are sure that the connections <a id="id230" class="indexterm"/>of the relay, the current sensor, and the power cables are correct, we will write an Arduino sketch to accept connections coming via Wi-Fi from the Android device.</p><p>The following is the complete sketch for this part:</p><div><pre class="programlisting">// Import required libraries
#include &lt;Adafruit_CC3000.h&gt;
#include &lt;SPI.h&gt;
#include &lt;aREST.h&gt;

// Relay state
const int relay_pin = 8;

// Define measurement variables
float amplitude_current;
float effective_value;
float effective_voltage = 230.; // Set voltage to 230V (Europe) or 110V (US)
float zero_sensor;

// These are the pins for the CC3000 chip if you are using a breakout board
#define ADAFRUIT_CC3000_IRQ   3
#define ADAFRUIT_CC3000_VBAT  5
#define ADAFRUIT_CC3000_CS    10

// Create CC3000 instance
Adafruit_CC3000 cc3000 = Adafruit_CC3000(ADAFRUIT_CC3000_CS, ADAFRUIT_CC3000_IRQ, ADAFRUIT_CC3000_VBAT,
                                         SPI_CLOCK_DIV2);
// Create aREST instance
aREST rest = aREST();

// Your WiFi SSID and password                                         
#define WLAN_SSID       "yourWiFiNetworkName"
#define WLAN_PASS       "yourPassword" #define WLAN_SECURITY   WLAN_SEC_WPA2

// The port to listen for incoming TCP connections
#define LISTEN_PORT           80

// Server instance
Adafruit_CC3000_Server restServer(LISTEN_PORT);

// Variables to be exposed to the API
int power;

void setup(void)
{  
  // Start Serial
  Serial.begin(115200);
  
  // Init variables and expose them to REST API
  rest.variable("power",&amp;power);
  
  // Set relay pin to output
  pinMode(relay_pin,OUTPUT);
  
  // Calibrate sensor with null current
  zero_sensor = getSensorValue(A0);
   
  // Give name and ID to device
  rest.set_id("001");
  rest.set_name("smart_lamp");
  
  // Set up CC3000 and get connected to the wireless network.
  if (!cc3000.begin())
  {
    while(1);
  }
  
  if (!cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY)) {
    while(1);
  }
  while (!cc3000.checkDHCP())
  {
    delay(100);
  }
  
  // Display connection details
  displayConnectionDetails();
   
  // Start server
  restServer.begin();
  Serial.println(F("Listening for connections..."));
}

void loop() {
  
  // Perform power measurement
  float sensor_value = getSensorValue(A0);
    
  // Convert to current
  amplitude_current = (float)(sensor_value-zero_sensor)/1024*5/185*1000000;
  effective_value = amplitude_current/1.414;
  power = (int)(abs(effective_value*effective_voltage/1000));
  
  // Handle REST calls
  Adafruit_CC3000_ClientRef client = restServer.available();
  rest.handle(client);
  
}

// Function to display connection details
bool displayConnectionDetails(void)
{
  uint32_t ipAddress, netmask, gateway, dhcpserv, dnsserv;
  
  if(!cc3000.getIPAddress(&amp;ipAddress, &amp;netmask, &amp;gateway, &amp;dhcpserv, &amp;dnsserv))
  {
    Serial.println(F("Unable to retrieve the IP Address!\r\n"));
    return false;
  }
  else
  {
    Serial.print(F("\nIP Addr: ")); cc3000.printIPdotsRev(ipAddress);
    Serial.print(F("\nNetmask: ")); cc3000.printIPdotsRev(netmask);
    Serial.print(F("\nGateway: ")); cc3000.printIPdotsRev(gateway);
    Serial.print(F("\nDHCPsrv: ")); cc3000.printIPdotsRev(dhcpserv);
    Serial.print(F("\nDNSserv: ")); cc3000.printIPdotsRev(dnsserv);
    Serial.println();
    return true;
  }
}

// Get the reading from the current sensor
float getSensorValue(uint8_t pin)
{
  uint16_t sensorValue;
  float avgSensor = 0;
  uint8_t nb_measurements = 100;
  for (uint8_t i = 0; i &lt; nb_measurements; i++) {
    sensorValue = analogRead(pin);
    avgSensor = avgSensor + float(sensorValue);
  }    
  avgSensor = avgSensor/float(nb_measurements);
  return avgSensor;
}</pre></div><p>Now, let's<a id="id231" class="indexterm"/> look in more detail at the Arduino sketch. It <a id="id232" class="indexterm"/>starts by importing the required libraries for this project:</p><div><pre class="programlisting">#include &lt;Adafruit_CC3000.h&gt;
#include &lt;SPI.h&gt;
#include &lt;CC3000_MDNS.h&gt;
#include &lt;aREST.h&gt;</pre></div><p>We also have to define which pin the relay module is connected to:</p><div><pre class="programlisting">const int relay_pin = 8;</pre></div><p>Then, we have to declare some variables that will help us to measure and calculate the power consumption of the device:</p><div><pre class="programlisting">float amplitude_current;
float effective_value;
float effective_voltage = 230.; // Set voltage to 230V (Europe) or 110V (US)
float zero_sensor;</pre></div><p>At this point, you should also change the value of the effective voltage so that it matches the voltage of your country.</p><p>Then, we have to define the pins on which the CC3000 Wi-Fi chip is connected to:</p><div><pre class="programlisting">#define ADAFRUIT_CC3000_IRQ   3
#define ADAFRUIT_CC3000_VBAT  5
#define ADAFRUIT_CC3000_CS    10</pre></div><p>We can now create an instance of the CC3000 Wi-Fi chip:</p><div><pre class="programlisting">Adafruit_CC3000 cc3000 = Adafruit_CC3000(ADAFRUIT_CC3000_CS, ADAFRUIT_CC3000_IRQ, ADAFRUIT_CC3000_VBAT,
                                         SPI_CLOCK_DIV2);</pre></div><p>We will also <a id="id233" class="indexterm"/>need to create an instance of the aREST library:</p><div><pre class="programlisting">aREST rest = aREST();</pre></div><p>You will <a id="id234" class="indexterm"/>now have to modify the code to put your Wi-Fi network credentials:</p><div><pre class="programlisting">#define WLAN_SSID       "yourWiFiNetworkName"
#define WLAN_PASS       "yourPassword"
#define WLAN_SECURITY   WLAN_SEC_WPA2</pre></div><p>We will also define the port we want to listen to with the Wi-Fi chip:</p><div><pre class="programlisting">#define LISTEN_PORT           80</pre></div><p>After that, we will declare a server listening on that port:</p><div><pre class="programlisting">Adafruit_CC3000_Server restServer(LISTEN_PORT);</pre></div><p>Finally, we declare a variable that will contain the power consumption of the device, which will be accessible from the outside via HTTP requests (within the same local Wi-Fi network):</p><div><pre class="programlisting">int power;</pre></div><p>In the <code class="literal">setup()</code> function of the sketch, we will start the Serial connection:</p><div><pre class="programlisting">Serial.begin(115200);</pre></div><p>We will also expose the power consumption variable to the aREST API:</p><div><pre class="programlisting">rest.variable("power",&amp;power);</pre></div><p>We will also declare the relay pin as an output:</p><div><pre class="programlisting">pinMode(relay_pin,OUTPUT);</pre></div><p>Then, we need to first take a measurement from the current sensor to get the value that the current sensor returns when no current is flowing through the connected device. This is done by a function that we won't detail here:</p><div><pre class="programlisting">zero_sensor = getSensorValue(A0);</pre></div><p>We will also assign an ID and name to our project:</p><div><pre class="programlisting">rest.set_id("001");
rest.set_name("smart_lamp");</pre></div><p>After this, we will <a id="id235" class="indexterm"/>call a function to display the details of the Wi-Fi connection, such as the CC3000 chip IP address:</p><div><pre class="programlisting">displayConnectionDetails();</pre></div><p>To end the <code class="literal">setup()</code> function, we will start our Wi-Fi server:</p><div><pre class="programlisting">restServer.begin();
Serial.println(F("Listening for connections..."));</pre></div><p>Now, in the <code class="literal">loop()</code> function of the sketch, we will read data from the sensor, which is connected on the analog pin A0:</p><div><pre class="programlisting">float sensor_value = getSensorValue(A0);</pre></div><p>Once we get<a id="id236" class="indexterm"/> this value, we can calculate the current from it as well as the device power consumption:</p><div><pre class="programlisting">amplitude_current = (float)(sensor_value-zero_sensor)/1024*5/185*1000000;
effective_value = amplitude_current/1.414;
power = (int)(abs(effective_value*effective_voltage/1000));</pre></div><p>Basically, the manufacturer of the current sensor gives the first formula. Then, we get the effective current by dividing the amplitude current by the square root of 2, which is approximately 1.414. Finally, we get the effective power by multiplying the effective current with the effective voltage (and dividing it by 1,000 to have a result in Watts). Once the measurements are done, we process the incoming requests using the aREST library:</p><div><pre class="programlisting">Adafruit_CC3000_ClientRef client = restServer.available();
rest.handle(client);</pre></div><p>Note that you can find<a id="id237" class="indexterm"/> the complete code for this part inside the GitHub repository of the book at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p><p>Don't forget to change the sketch to include your own Wi-Fi network name and Wi-Fi network password. You can now upload the code to your Arduino board, and open the Serial monitor. The following result is what you should see after a while (of course, the IP address of your board and the other parameters will probably be different):</p><div><pre class="programlisting">IP Addr: 192.168.1.130
Netmask: 255.255.255.0
Gateway: 192.168.1.1
DHCPsrv: 0.0.0.0
DNSserv: 192.168.1.1
Listening for connections...</pre></div><p>Write down the IP address that appeared in your Serial monitor—you will need it now, and while writing <a id="id238" class="indexterm"/>the Android application later. Now, we will test the Wi-Fi connection by sending some command to the project. You can go to your favorite web browser and type the following:</p><div><pre class="programlisting">192.168.1.130/digital/8/1</pre></div><p>Of course, you<a id="id239" class="indexterm"/> need to change the IP address with your own board's IP address as it was displayed in the Serial monitor. You should see that the relay instantly switches on, and you should be greeted by the following message:</p><div><pre class="programlisting">{"message": "Pin D8 set to 1", "id": "001", "name": "smart_lamp", "connected": true}</pre></div><p>You can now switch it off again with:</p><div><pre class="programlisting">192.168.1.130/digital/8/0</pre></div><p>We are now going to try to read the power consumption of the device. You can do so by typing:</p><div><pre class="programlisting">192.168.1.130/power</pre></div><p>You should be greeted by the following answer:</p><div><pre class="programlisting">{"power": 0, "id": "001", "name": "smart_lamp", "connected": true}</pre></div><p>If you can see this, then it means that the sensor was correctly calibrated (as the power is 0) and that the power variable was correctly exposed to the aREST API.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Wireframing our Android application</h2></div></div></div><p>The rigorous approach of wireframing our <a id="id240" class="indexterm"/>application before starting to write any code will help us provide a better user experience. The following is the paper prototype that we would like to follow when it comes to implementing our final code:</p><div><img src="img/0389OS_04_08.jpg" alt="Wireframing our Android application"/></div><p>We will go ahead and create a new project <a id="id241" class="indexterm"/>entitled <code class="literal">Arduino Wifi</code> in Android Studio with a minimum SDK of 15 and maximum SDK of 19 (which at the time of writing is the most stable version of the Android SDK). This will enable us to cater to more than 80% of Android devices in the market. A project with a blank activity should be enough to start off this project.</p><p>Once you've got the project set up, we will go ahead and direct the Android layout files, which can be found by navigating to <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">res</code> &gt; <code class="literal">layout</code> &gt; <code class="literal">activity_main_screen.xml</code>.</p><p>We will apply a relative <a id="id242" class="indexterm"/>layout first, and within this layout, drag-and-drop four buttons together with a TextView, which will look roughly as follows (at this point, there is no need to focus on the aesthetic quality of the layout):</p><div><img src="img/0389OS_04_09.jpg" alt="Wireframing our Android application"/></div><p>We will also identify each user <a id="id243" class="indexterm"/>interface item as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>Open the Gate</strong> button: <code class="literal">openGateButton</code></li><li class="listitem" style="list-style-type: disc">The <strong>Switch On</strong> button: <code class="literal">switchOnButton</code></li><li class="listitem" style="list-style-type: disc">The <strong>Switch Off</strong> button: <code class="literal">switchOffButton</code></li><li class="listitem" style="list-style-type: disc">The <strong>Check Power</strong> button: <code class="literal">checkPowerButton</code></li><li class="listitem" style="list-style-type: disc">The <strong>Power Output</strong> text view: <code class="literal">powerOutput</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Implementing our layouts into the code</h2></div></div></div><p>We will first start off by <a id="id244" class="indexterm"/>declaring a <code class="literal">String TAG</code> object, which refers to <code class="literal">MainActivity</code> and which will be used for logging purposes:</p><div><pre class="programlisting">public static final String TAG = MainScreen.class.getSimpleName();</pre></div><p>Then, we will follow this by declaring all our view variables and assigning them to the <code class="literal">layout</code> elements within the <code class="literal">onCreate</code> method, which means that the <code class="literal">onCreate</code> method will look as follows:</p><div><pre class="programlisting">@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main_screen);

        //Declare our View Variables and assign them to the layout elements
        Button checkPowerButton = (Button) findViewById(R.id.checkPowerButton);
        Button openTheGateButton = (Button) findViewById(R.id.openGateButton);
        Button switchOnButton = (Button) findViewById(R.id.switchOnButton);
        Button switchOffButton = (Button) findViewById(R.id.switchOffButton);


        checkPowerButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (isNetworkAvailable()) {
                    checkPowerTask getPowerTask = new checkPowerTask();
                    getPowerTask.execute();
                }
            }
        });

        openTheGateButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (isNetworkAvailable()) {
                    SwitchOpenTask switchOpenTask = new SwitchOpenTask();
                    switchOpenTask.execute();
                }
            }
        });

        switchOnButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (isNetworkAvailable()) {
                    SwitchOnTask switchOnTask = new SwitchOnTask();
                    switchOnTask.execute();
                }
            }
        });

        switchOffButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (isNetworkAvailable()) {
                    SwitchOffTask switchOffTask = new SwitchOffTask();
                    switchOffTask.execute();
                }
            }
        });

    }</pre></div><p>As you can see in the preceding code, we refer to a number of ASync tasks, which we will<a id="id245" class="indexterm"/> refer to together with a JSON parser that we will be using to parse the data from the Arduino and adapt it to the power output text view.</p><p>ASync tasks<a id="id246" class="indexterm"/> will help us run the application tasks separately from the main user interface thread and hence significantly improve the responsiveness of the user interface and thus enhance the user experience.</p><p>With the following code, you will need to replace the <code class="literal">yourip</code> part with your own IP address, which you have found in the Arduino IDE Serial monitor. You will be able to declare the IP address within the <code class="literal">Main Activity</code> declaration as follows:</p><div><pre class="programlisting">public static final String URL = "yourip";</pre></div><p>We will then declare the following <code class="literal">AsyncTasks</code> object to enable the different actions we would like to achieve:</p><div><pre class="programlisting">private class SwitchOpenTask extends AsyncTask&lt;Object,Void,String&gt; {

        @Override
        protected String doInBackground(Object... arg0) {

            int responseCode = -1;


            try {
                URL restApiUrl = new URL("http:// " + URL + "mode/8/o");
                HttpURLConnection connection = (HttpURLConnection) restApiUrl.openConnection();
                connection.connect();

                responseCode = connection.getResponseCode();
                Log.i(TAG, "Code" + responseCode);
            }
            catch(MalformedURLException e) {
                Log.e(TAG, "Malformed Exception Caught:", e);
            }
            catch(IOException e) {
                Log.e(TAG, "IO Exception Caught:", e);
                e.printStackTrace();
            }
            catch(Exception e){
                Log.e(TAG, "Generic Exception Caught:", e);
            }

            return "Code: " + responseCode;

        }

    }

    private class SwitchOnTask extends AsyncTask&lt;Object,Void,String&gt; {

        @Override
        protected String doInBackground(Object... arg0) {

            int responseCode = -1;

            try {
                URL restApiUrl = new URL("http://" + URL + "/digital/8/1");
                HttpURLConnection connection = (HttpURLConnection) restApiUrl.openConnection();
                connection.connect();

                responseCode = connection.getResponseCode();
                Log.i(TAG, "Code" + responseCode);
            }
            catch(MalformedURLException e) {
                Log.e(TAG, "Malformed Exception Caught:", e);
            }
            catch(IOException e) {
                Log.e(TAG, "IO Exception Caught:", e);
                e.printStackTrace();
            }
            catch(Exception e){
                Log.e(TAG, "Generic Exception Caught:", e);
            }

            return "Code: " + responseCode;

        }

    }

    private class SwitchOffTask extends AsyncTask&lt;Object,Void,String&gt; {

        @Override
        protected String doInBackground(Object... arg0) {

            int responseCode = -1;

            try {
                URL restApiUrl = new URL("http://" + URL + "/digital/8/0");
                HttpURLConnection connection = (HttpURLConnection) restApiUrl.openConnection();
                connection.connect();

                responseCode = connection.getResponseCode();
                Log.i(TAG, "Code" + responseCode);
            }
            catch(MalformedURLException e) {
                Log.e(TAG, "Malformed Exception Caught:", e);
            }
            catch(IOException e) {
                Log.e(TAG, "IO Exception Caught:", e);
                e.printStackTrace();
            }
            catch(Exception e){
                Log.e(TAG, "Generic Exception Caught:", e);
            }

            return "Code: " + responseCode;

        }

    }

    private class checkPowerTask extends AsyncTask&lt;Object,Void,String&gt; {

        @Override
        protected String doInBackground(Object... arg0) {

            int responseCode = -1;
            String result = null;

            try {
                URL restApiUrl = new URL("http://" + URL + "/power");
                HttpURLConnection connection = (HttpURLConnection) restApiUrl.openConnection();
                connection.connect();
                responseCode = connection.getResponseCode();

                InputStream is = null;
                //http post request
                try{
                    String postQuery = "http://" + URL + "/power";
                    HttpClient httpclient = new DefaultHttpClient();
                    HttpPost httppost = new HttpPost(postQuery);
                    HttpResponse response = httpclient.execute(httppost);
                    HttpEntity entity = response.getEntity();
                    is = entity.getContent();
                }catch(Exception e){
                    Log.e("log_tag", "Error in http connection "+e.toString());
                }

                //convert response to string
                try{
                    BufferedReader reader = new BufferedReader(new InputStreamReader(is,"UTF-8"),8);
                    StringBuilder sb = new StringBuilder();
                    String line = null;

                    while ((line = reader.readLine()) != null) {
                        sb.append(line + "\n");
                    }

                    is.close();

                    result=sb.toString();
                    Log.v(TAG,result);

                } catch(Exception e){
                    Log.e("log_tag", "Error converting result "+e.toString());
                }

                //parse json data
                try {

                    JSONObject userObject = new JSONObject(result);
                    final String powerOutputText = userObject.getString("power");

                    activity.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            TextView powerOutput = (TextView) findViewById(R.id.powerOutput);
                            powerOutput.setText(powerOutputText + "W");

                        }
                    });

                } catch(JSONException e){
                    Log.e(TAG, "JSON Exception Caught:", e);
                }
            }
            catch(MalformedURLException e) {
                Log.e(TAG, "Malformed Exception Caught:", e);
            }
            catch(IOException e) {
                Log.e(TAG, "IO Exception Caught:", e);
                e.printStackTrace();
            }
            catch(Exception e){
                Log.e(TAG, "Generic Exception Caught:", e);
            }

            return "Code: " + responseCode;
        }

    }</pre></div><p>We will add <a id="id247" class="indexterm"/>another <code class="literal">helper</code> method at the bottom to make sure that Wi-Fi network connectivity is available:</p><div><pre class="programlisting">private boolean isNetworkAvailable() {
        ConnectivityManager manager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = manager.getActiveNetworkInfo();

        boolean isAvailable = false;
        if (networkInfo != null &amp;&amp; networkInfo.isConnected()) {
            isAvailable = true;
        }

        return isAvailable;

    }</pre></div><p>Before going <a id="id248" class="indexterm"/>ahead, we will need to add the following permissions to our Android <code class="literal">Manifest</code> file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">AndroidManifest.xml</code>.</p><p>The following permissions will allow us to access the Wi-Fi network capabilities of the Android device:</p><div><pre class="programlisting">    &lt;uses-permission android:name="android.permission.INTERNET"/&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
    &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;</pre></div><p>After this, you can go ahead and compile the app. It's also important to note that Wi-Fi has a latency of about 300 ms and, depending on your Wi-Fi network, the value might take a significant amount of time to update the user interface.</p><p>If you are struggling with following along, you can also refer to the final project by checking out the GitHub repository at <a class="ulink" href="https://github.com/marcoschwartz/arduino-android-blueprints">https://github.com/marcoschwartz/arduino-android-blueprints</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Polishing the user interface and experience</h2></div></div></div><p>Once we have <a id="id249" class="indexterm"/>managed to finalize our code and assure ourselves that the user interface is being updated with the power value and that we can switch on and off the lamp, we can proceed to improve our user interface.</p><p>We will improve the user interface with the following main actions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding a new app icon</li><li class="listitem" style="list-style-type: disc">Enlarging the power output text</li><li class="listitem" style="list-style-type: disc">Aligning and styling the buttons</li><li class="listitem" style="list-style-type: disc">Changing the application name in the action bar</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Adding a new app icon</h2></div></div></div><p>First, we <a id="id250" class="indexterm"/>will start off by downloading the image asset. It's<a id="id251" class="indexterm"/> available within the GitHub repository and as a public download at <a class="ulink" href="http://bit.ly/iclauncherchapter4">http://bit.ly/iclauncherchapter4</a>.</p><p>You should navigate using the project tree, followed by a right-click on the <code class="literal">app</code> folder, as shown in the following screenshot:</p><div><img src="img/0389OS_04_10.jpg" alt="Adding a new app icon"/></div><p>When you right-click on <code class="literal">app</code>, create a new image asset by navigating to <strong>New</strong> &gt; <strong>Image Asset</strong>, as shown in the following screenshot:</p><div><img src="img/0389OS_04_11.jpg" alt="Adding a new app icon"/></div><p>You will then be shown an <strong>Asset Studio</strong> pop-up window, which will allow you to choose your very own<a id="id252" class="indexterm"/> image file, as shown in the following screenshot. For optimization purposes, we recommend that you go for a <code class="literal">.png</code> file with a resolution of 144 pixels by 144 pixels. Android Studio automatically does all the resizing and resource creation to adapt your graphic to different screens:</p><div><img src="img/0389OS_04_12.jpg" alt="Adding a new app icon"/></div><p>Once you choose<a id="id253" class="indexterm"/> the <code class="literal">ic_launcher</code> image file that we have provided you with, you will be shown a screen with the icon in different sizes. Click on <strong>Next</strong>, where you will see the following screen:</p><div><img src="img/0389OS_04_13.jpg" alt="Adding a new app icon"/></div><p>This screen warns you that the previous files will be overwritten and shows you the image launcher file<a id="id254" class="indexterm"/> in a number of different resolutions once again. Click on <strong>Finish</strong>, compile the app, launch it on your physical device, and you should see something pleasant in your app tray and in the app's action bar, which is shown as follows:</p><div><img src="img/0389OS_04_14.jpg" alt="Adding a new app icon"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Centering and enlarging the data output text</h2></div></div></div><p>In order<a id="id255" class="indexterm"/> to edit the layout <a id="id256" class="indexterm"/>for the main text output where the sensor data will be shown, we will need to open the project tree and navigate towards the layout file, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">res</code> &gt; <code class="literal">layout</code> &gt; <code class="literal">activity_main_screen.xml</code>.</p><p>Once in this view, we recommend that you modify the text using the text view. This will allow you finer control and get you used to the different conventions used when editing Android layout files programmatically.</p><p>When opening the <code class="literal">activity_main_screen.xml</code> file, we will see the different XML codes for the buttons and Text Views. At this point, look out for the code that takes care of the <code class="literal">Power Data Output</code> TextView and add the following code:</p><div><pre class="programlisting">android:textSize="100sp"
android:textAlignment="center"</pre></div><p>The whole block of code responsible for the <code class="literal">Sensor Data Output</code> TextView will now look as follows:</p><div><pre class="programlisting">&lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="100W"
        android:textSize="100sp"
        android:id="@+id/powerOutput"
        android:textAlignment="center"
        android:layout_alignParentTop="true"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="78dp"
        /&gt;</pre></div><p>In this block of code, we temporarily used the placeholder text <code class="literal">100W</code> so that we can approximate <a id="id257" class="indexterm"/>how it will look with the <a id="id258" class="indexterm"/>Android layout designer. With this modification, the sensor data is now big enough to show to the user and will be part of the enhancement within the user experience.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Aligning and styling the buttons</h2></div></div></div><a id="id259" class="indexterm"/><a id="id260" class="indexterm"/><p>For our final steps, we will modify our buttons and add some color to the text.</p><p>There will be two steps when creating the new buttons:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">drawable</code> folder with a new XML <code class="literal">drawable</code> file known as <code class="literal">button.xml</code>.</li><li class="listitem">We will then connect the <code class="literal">drawable</code> resource file to the main Android layout file.</li></ol></div><p>Create the <code class="literal">drawable</code> folder by right-clicking on the <code class="literal">res</code> folder, which is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">main</code> &gt; <code class="literal">res</code>.</p><p>After creating the <code class="literal">drawable</code> folder within the <code class="literal">res</code> folder, we need to once again right-click on the new <code class="literal">drawable</code> folder and navigate to <strong>New</strong> &gt; <strong>Drawable Resource File</strong>.</p><p>Name the file <code class="literal">button</code> and type down <code class="literal">shape</code> as the root element followed by clicking on <strong>OK</strong>.</p><p>Within the <code class="literal">button.xml</code> file, we will add the following code:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape &gt;
    android:shape="rectangle" &gt;
    &lt;corners
        android:radius="30dp"/&gt;
    &lt;solid
        android:color="#FFFFFF"/&gt;
    &lt;padding
        android:left="0dp"
        android:top="0dp"
        android:right="0dp"
        android:bottom="0dp"/&gt;
    &lt;size
        android:width="120dp"
        android:height="60dp"/&gt;
    &lt;stroke
        android:width="2dp"
        android:color="#4A90E2"/&gt;
&lt;/shape&gt;</pre></div><p>Then, we go <a id="id261" class="indexterm"/>towards the <code class="literal">activity_main_screen.xml</code> file and refer to this drawable by including the following<a id="id262" class="indexterm"/> line of code within the button modules:</p><div><pre class="programlisting">android:background="@drawable/button"</pre></div><p>We will add some flavor by adding the following line of code to the <code class="literal">Button</code> and <code class="literal">TextView</code> modules within the <code class="literal">activity_main_screen.xml</code> file:</p><div><pre class="programlisting">android:textColor="#4A90E2"</pre></div><p>The <code class="literal">#4A90E2</code> term refers to the hex code of the main color used in the app icon so that we maintain some consistency with the main user interface.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Changing the application name within the action bar</h2></div></div></div><p>We all would like to<a id="id263" class="indexterm"/> customize the name of the app to one of our own liking and that will be the easiest thing within our project! We will just go over to the <code class="literal">strings.xml</code> file where we have all our constant text values within the project. This is available at <code class="literal">app</code> &gt; <code class="literal">src</code> &gt; <code class="literal">res</code> &gt; <code class="literal">values</code> &gt; <code class="literal">string.xml</code>.</p><p>Then, you can change the text of <code class="literal">arduinoWifi</code> to any name of your liking. In this case, we will stick to <code class="literal">WiFi Lamp Switch</code>:</p><div><pre class="programlisting">&lt;string name="app_name"&gt;WiFi Lamp Switch&lt;/string&gt;</pre></div><p>Our final project should now look as follows (device used in this case is a Nexus 4):</p><div><img src="img/0389OS_04_15.jpg" alt="Changing the application name within the action bar"/></div><p>It's important to note that screen layouts might vary depending on different devices. In this case, you<a id="id264" class="indexterm"/> might have to adapt your Android layout file to your specific physical device.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>How to go further</h2></div></div></div><p>The <a id="id265" class="indexterm"/>options are endless when it comes to further modifying the Android app, and there are a number of implementations that can improve the app, such as real-time monitoring, where the power data output will refresh automatically. In addition, this data can provide a use case for data that is being generated to be stored in the cloud, which can be analyzed, allowing for the creation of graphical interpretations of this data. Such graphical interpretations can be correlated to the time of day and can help the user understand when the greatest power consumption occurs.</p><p>From a <a id="id266" class="indexterm"/>coding point of view, we can refactor our code, which implies that we simplify and reuse our code effectively. In fact, refactoring could definitely be achieved with the JSON parser, which could be refactored into its own class and which we opted on leaving out in the current setup so as to facilitate the learning process.</p><p>With regards to user experience, a new <code class="literal">EditText</code> field could be introduced together with a <strong>Submit</strong> button so as to allow the user to manually change the IP address, which will be called when discovering the IP address from the Arduino Serial monitor. Within this code, we use the concatenation and URL builder to form the right command.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Summary</h1></div></div></div><p>We created a DIY version of a smart power switch, based on Arduino, and controlled by an Android application via Wi-Fi. We connected all the required components to the Arduino board, wrote an Arduino sketch to accept commands via Wi-Fi, and finally, created an Android application to control the switch remotely.</p><p>In the next chapter, we will use another Arduino board, called the Arduino Yún, where we will be able to plug an USB camera. As this board will have Wi-Fi as well, we will use the project to create a remote Wi-Fi security camera.</p></div></body></html>