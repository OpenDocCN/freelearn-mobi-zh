["```kt\n    fun main(args: Array<String>) { \n\n      val observer:Observer<Any> = object :Observer<Any>{//1 \n        override fun onComplete() {//2 \n            println(\"All Completed\") \n        } \n\n        override fun onNext(item: Any) {//3 \n            println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) {//4 \n            println(\"Error Occured $e\") \n        } \n\n        override fun onSubscribe(d: Disposable) {//5 \n            println(\"Subscribed to $d\") \n        } \n      } \n\n      val observable: Observable<Any> = listOf\n      (\"One\", 2, \"Three\", \"Four\", 4.5, \"Five\", 6.0f).toObservable() //6 \n\n      observable.subscribe(observer)//7 \n\n      val observableOnList: Observable<List<Any>> =\n      Observable.just(listOf(\"One\", 2, \"Three\", \"Four\", \n      4.5, \"Five\", 6.0f), \n        listOf(\"List with Single Item\"), \n        listOf(1,2,3,4,5,6))//8 \n       observableOnList.subscribe(observer)//9 \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n\n      val observer: Observer<String> = object : Observer<String> { \n        override fun onComplete() { \n          println(\"All Completed\") \n        } \n\n        override fun onNext(item: String) { \n          println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n          println(\"Error Occured ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n          println(\"New Subscription \") \n        } \n    }//Create Observer \n\n    val observable:Observable<String> = Observable.create<String> {//1 \n      it.onNext(\"Emit 1\") \n      it.onNext(\"Emit 2\") \n      it.onNext(\"Emit 3\") \n      it.onNext(\"Emit 4\") \n      it.onComplete() \n    } \n\n    observable.subscribe(observer) \n\n    val observable2:Observable<String> = Observable.create<String> {//2 \n      it.onNext(\"Emit 1\") \n      it.onNext(\"Emit 2\") \n      it.onNext(\"Emit 3\") \n      it.onNext(\"Emit 4\") \n      it.onError(Exception(\"My Custom Exception\")) \n    } \n\n    observable2.subscribe(observer) \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n\n      val observer: Observer<String> = object : Observer<String> { \n        override fun onComplete() { \n          println(\"All Completed\") \n        } \n\n        override fun onNext(item: String) { \n          println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n          println(\"Error Occured ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n          println(\"New Subscription \") \n        } \n      }//Create Observer \n\n      val list = listOf(\"String 1\",\"String 2\",\"String 3\",\"String 4\") \n      val observableFromIterable: Observable<String> =\n      Observable.fromIterable(list)//1 \n      observableFromIterable.subscribe(observer) \n\n      val callable = object : Callable<String> { \n        override fun call(): String { \n          return \"From Callable\" \n        } \n      } \n      val observableFromCallable:Observable<String> =\n      Observable.fromCallable(callable)//2 \n      observableFromCallable.subscribe(observer) \n\n      val future:Future<String> = object :Future<String> { \n        override fun get(): String = \"Hello From Future\" \n\n        override fun get(timeout: Long, unit: TimeUnit?): String  =\n        \"Hello From Future\" \n\n        override fun isDone(): Boolean = true \n\n        override fun isCancelled(): Boolean = false \n\n        override fun cancel(mayInterruptIfRunning: Boolean):\n        Boolean = false \n\n      } \n      val observableFromFuture:Observable<String> = \n      Observable.fromFuture(future)//3 \n      observableFromFuture.subscribe(observer) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n\n      val observer: Observer<String> = object : Observer<String> { \n        override fun onComplete() { \n            println(\"All Completed\") \n        } \n\n        override fun onNext(item: String) { \n            println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occured ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"New Subscription \") \n        } \n      }//Create Observer \n\n      val list:List<String> = listOf\n      (\"String 1\",\"String 2\",\"String 3\",\"String 4\") \n\n      val observable:Observable<String> = list.toObservable() \n\n      observable.subscribe(observer) \n    } \n```", "```kt\n    fun <T : Any> Iterator<T>.toObservable(): Observable<T> = \n    toIterable().toObservable() \n    fun <T : Any> Iterable<T>.toObservable(): Observable<T> = \n    Observable.fromIterable(this) \n    fun <T : Any> Sequence<T>.toObservable(): Observable<T> =\n    asIterable().toObservable() \n\n    fun <T : Any> Iterable<Observable<out T>>.merge(): Observable<T> = \n    Observable.merge(this.toObservable()) \n    fun <T : Any> Iterable<Observable<out T>>.mergeDelayError(): \n    Observable<T> = Observable.mergeDelayError(this.toObservable()) \n```", "```kt\n    fun main(args: Array<String>) { \n      val observer: Observer<Any> = object : Observer<Any> { \n        override fun onComplete() { \n            println(\"All Completed\") \n        } \n\n        override fun onNext(item: Any) { \n            println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occured ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"New Subscription \") \n        } \n       }//Create Observer \n\n       Observable.just(\"A String\").subscribe(observer) \n       Observable.just(54).subscribe(observer) \n       Observable.just(listOf(\"String 1\",\"String 2\",\"String 3\",\n       \"String 4\")).subscribe(observer) \n       Observable.just(mapOf(Pair(\"Key 1\",\"Value 1\"),Pair\n       (\"Key 2\",\"Value 2\"),Pair(\"Key 3\",\"Value\n       3\"))).subscribe(observer) \n       Observable.just(arrayListOf(1,2,3,4,5,6)).subscribe(observer) \n       Observable.just(\"String 1\",\"String 2\",\n       \"String 3\").subscribe(observer)//1 \n      } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observer: Observer<Any> = object : Observer<Any> { \n        override fun onComplete() { \n            println(\"All Completed\") \n        } \n\n        override fun onNext(item: Any) { \n            println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occured ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"New Subscription \") \n        } \n      }//Create Observer \n\n      Observable.range(1,10).subscribe(observer)//(1) \n      Observable.empty<String>().subscribe(observer)//(2) \n\n      runBlocking {    \n        Observable.interval(300,TimeUnit.MILLISECONDS).\n        subscribe(observer)//(3) \n        delay(900) \n        Observable.timer(400,TimeUnit.MILLISECONDS).\n        subscribe(observer)//(4) \n        delay(450) \n     }   \n\n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable:Observable<Int> = Observable.range(1,5)//1 \n\n      observable.subscribe({//2 \n        //onNext method \n        println(\"Next $it\") \n      },{ \n        //onError Method \n        println(\"Error ${it.message}\") \n      },{ \n        //onComplete Method \n        println(\"Done\") \n     }) \n\n     val observer: Observer<Int> = object : Observer<Int> {//3 \n        override fun onComplete() { \n          println(\"All Completed\") \n        } \n\n        override fun onNext(item: Int) { \n          println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n          println(\"Error Occurred ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n          println(\"New Subscription \") \n        } \n    } \n\n    observable.subscribe(observer) \n  } \n```", "```kt\n    fun main(args: Array<String>) { \n      runBlocking { \n        val observale:Observable<Long> = \n        Observable.interval(100,TimeUnit.MILLISECONDS)//1 \n        val observer:Observer<Long> = object : Observer<Long> { \n          lateinit var disposable:Disposable//2 \n\n          override fun onSubscribe(d: Disposable) { \n            disposable = d//3 \n          } \n\n          override fun onNext(item: Long) { \n            println(\"Received $item\") \n            if(item>=10 && !disposable.isDisposed) {//4 \n              disposable.dispose()//5 \n              println(\"Disposed\") \n            } \n          } \n\n          override fun onError(e: Throwable) { \n            println(\"Error ${e.message}\") \n          } \n\n          override fun onComplete() { \n            println(\"Complete\") \n          } \n\n        } \n\n        observale.subscribe(observer) \n        delay(1500)//6 \n     } \n    } \n```", "```kt\nReceived 0\nReceived 1\nReceived 2\nReceived 3\nReceived 4\nReceived 5\nReceived 6\nReceived 7\nReceived 8\nReceived 9\nReceived 10\nDisposed\n```", "```kt\n    interface Disposable { \n      /** \n      * Dispose the resource, the operation should be idempotent. \n      */ \n      fun dispose() \n      /** \n      * Returns true if this resource has been disposed. \n      * @return true if this resource has been disposed \n      */ \n      val isDisposed:Boolean \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable: Observable<String> = listOf\n      (\"String 1\",\"String 2\",\"String 3\",\"String 4\").toObservable()//1 \n\n      observable.subscribe({//2 \n        println(\"Received $it\") \n      },{ \n        println(\"Error ${it.message}\") \n      },{ \n        println(\"Done\") \n      }) \n\n      observable.subscribe({//3 \n        println(\"Received $it\") \n      },{ \n        println(\"Error ${it.message}\") \n      },{ \n        println(\"Done\") \n     }) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val connectableObservable = listOf\n      (\"String 1\",\"String 2\",\"String 3\",\"String 4\",\"String\n      5\").toObservable() \n      .publish()//1 \n      connectableObservable.subscribe({ println\n      (\"Subscription 1: $it\") })//2 \n      connectableObservable.map(String::reversed)//3 \n      .subscribe({ println(\"Subscription 2 $it\")})//4 \n      connectableObservable.connect()//5 \n      connectableObservable.subscribe({ println\n      (\"Subscription 3: $it\") })//6 //Will not receive emissions \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val connectableObservable =  \n      Observable.interval(100,TimeUnit.MILLISECONDS) \n      .publish()//1 \n      connectableObservable. \n      subscribe({ println(\"Subscription 1: $it\") })//2 \n      connectableObservable \n      .subscribe({ println(\"Subscription 2 $it\")})//3 \n      connectableObservable.connect()//4 \n      runBlocking { delay(500) }//5 \n\n      connectableObservable. \n      subscribe({ println(\"Subscription 3: $it\") })//6 \n      runBlocking { delay(500) }//7 \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.interval(100, \n      TimeUnit.MILLISECONDS)//1 \n      val subject = PublishSubject.create<Long>()//2 \n      observable.subscribe(subject)//3 \n      subject.subscribe({//4 \n        println(\"Received $it\") \n    }) \n    runBlocking { delay(1100) }//5 \n   } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.interval(100,\n      TimeUnit.MILLISECONDS)//1 \n      val subject = PublishSubject.create<Long>()//2 \n      observable.subscribe(subject)//3 \n      subject.subscribe({//4 \n        println(\"Subscription 1 Received $it\") \n      }) \n      runBlocking { delay(1100) }//5 \n      subject.subscribe({//6 \n        println(\"Subscription 2 Received $it\") \n      }) \n      runBlocking { delay(1100) }//7 \n    }  \n```", "```kt\nSubscription 1 Received 0\nSubscription 1 Received 1\nSubscription 1 Received 2\nSubscription 1 Received 3\nSubscription 1 Received 4\nSubscription 1 Received 5\nSubscription 1 Received 6\nSubscription 1 Received 7\nSubscription 1 Received 8\nSubscription 1 Received 9\nSubscription 1 Received 10\nSubscription 1 Received 11\nSubscription 2 Received 11\nSubscription 1 Received 12\nSubscription 2 Received 12\nSubscription 1 Received 13\nSubscription 2 Received 13\nSubscription 1 Received 14\nSubscription 2 Received 14\nSubscription 1 Received 15\nSubscription 2 Received 15\nSubscription 1 Received 16\nSubscription 2 Received 16\nSubscription 1 Received 17\nSubscription 2 Received 17\nSubscription 1 Received 18\nSubscription 2 Received 18 Subscription 1 Received 19\nSubscription 2 Received 19\nSubscription 1 Received 20\nSubscription 2 Received 20\nSubscription 1 Received 21\nSubscription 2 Received 21  \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.just(1,2,3,4)//1 \n      val subject = AsyncSubject.create<Int>()//2 \n      observable.subscribe(subject)//3 \n      subject.subscribe({//4 \n        //onNext \n        println(\"Received $it\") \n      },{ \n        //onError \n        it.printStackTrace() \n      },{ \n        //onComplete \n        println(\"Complete\") \n      }) \n      subject.onComplete()//5 \n    } \n```", "```kt\nReceived 4\nComplete\n```", "```kt\n    fun main(args: Array<String>) { \n      val subject = AsyncSubject.create<Int>() \n      subject.onNext(1) \n      subject.onNext(2) \n      subject.onNext(3) \n      subject.onNext(4) \n      subject.subscribe({ \n        //onNext \n        println(\"S1 Received $it\") \n      },{ \n        //onError \n        it.printStackTrace() \n      },{ \n        //onComplete \n        println(\"S1 Complete\") \n      }) \n      subject.onNext(5) \n      subject.subscribe({ \n        //onNext \n        println(\"S2 Received $it\") \n      },{ \n        //onError \n        it.printStackTrace() \n      },{ \n        //onComplete \n        println(\"S2 Complete\") \n      }) \n      subject.onComplete() \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val subject = BehaviorSubject.create<Int>() \n      subject.onNext(1) \n      subject.onNext(2) \n      subject.onNext(3) \n      subject.onNext(4) \n      subject.subscribe({ \n        //onNext \n        println(\"S1 Received $it\") \n      },{ \n        //onError \n        it.printStackTrace() \n      },{ \n        //onComplete \n        println(\"S1 Complete\") \n      }) \n      subject.onNext(5) \n      subject.subscribe({ \n        //onNext \n        println(\"S2 Received $it\") \n      },{ \n        //onError \n        it.printStackTrace() \n      },{ \n        //onComplete \n        println(\"S2 Complete\") \n      }) \n      subject.onComplete() \n    } \n```", "```kt\nS1 Received 4\nS1 Received 5\nS2 Received 5\nS1 Complete\nS2 Complete\n```", "```kt\n    fun main(args: Array<String>) { \n      val subject = ReplaySubject.create<Int>() \n      subject.onNext(1) \n      subject.onNext(2) \n      subject.onNext(3) \n      subject.onNext(4) \n      subject.subscribe({ \n        //onNext \n        println(\"S1 Received $it\") \n      },{ \n        //onError \n        it.printStackTrace() \n      },{ \n        //onComplete \n        println(\"S1 Complete\") \n      }) \n      subject.onNext(5) \n      subject.subscribe({ \n        //onNext \n        println(\"S2 Received $it\") \n      },{ \n        //onError \n        it.printStackTrace() \n      },{ \n        //onComplete \n        println(\"S2 Complete\") \n      }) \n      subject.onComplete() \n    } \n```", "```kt\nS1 Received 1\nS1 Received 2\nS1 Received 3\nS1 Received 4\nS1 Received 5\nS2 Received 1\nS2 Received 2\nS2 Received 3\nS2 Received 4\nS2 Received 5\nS1 Complete\nS2 Complete  \n```"]