- en: '*Chapter 5*: Introducing Functional Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will discuss the fundamental principles of **functional programming**
    and how they fit into the **Kotlin** programming language.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll discover, we've already touched on some of the concepts in this chapter,
    as it would have been hard to discuss the benefits of the language up until now
    without touching on functional programming concepts such as **data immutability**
    and **functions as values**. But as we did before, we'll look at those features
    from a different angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning behind the functional approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions, not statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you'll understand how the concepts of functional
    programming are embedded in the Kotlin language and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA** **Community Edition** ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenJDK** **11** (or higher) ([https://openjdk.java.net/install/](https://openjdk.java.net/install/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on **GitHub** at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning behind the functional approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional programming** has been around for as long as other programming
    paradigms, for example, procedural and object-oriented programming. But in the
    past 15 years, it has gained significant momentum. The reason for this is that
    something else stalled: **CPU** speeds. We cannot speed up our CPUs as much as
    we did in the past, so we must **parallelize** our programs. And it turns out
    that the functional programming paradigm is exceptionally good at running parallel
    tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of multicore processors is a fascinating topic in itself, but
    we'll cover it only briefly here. Workstations have had multiple processors since
    at least the 1980s to support the running of tasks from different users in parallel.
    Since workstations were massive during this era, they didn't need to worry about
    cramming everything into one chip. But when multiprocessors came to the consumer
    market around 2005, it became necessary to have one physical unit that could work
    in parallel. This is why we have multiple cores in one chip in our PC or laptop.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that''s not the only reason we use functional programming. Here are a few
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming favors pure functions, and pure functions are usually
    easier to reason about and test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code written in a functional way is often more declarative than imperative,
    dealing with the *what* instead of the *how*, and this can be a benefit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we'll explore the different aspects of functional
    programming, starting with *immutability*.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the fundamental concepts of functional programming is **immutability**.
    This means that from the moment the function receives input to the moment the
    function returns output, the object doesn''t change. *But how could it change?*
    Well, let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code would output `a` first, and then we would receive `ConcurrentModificationException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is that the `for-each` loop uses an iterator (which we
    already discussed in the previous chapter), and by mutating the list inside the
    loop, we interfere with its operation. However, this raises a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Wouldn''t it be great if we could protect ourselves from these runtime exceptions
    in the first place?*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how *immutable collections* can help us with this.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Kotlin*, we already mentioned that collections in Kotlin are immutable by default,
    which is unlike many other languages.
  prefs: []
  type: TYPE_NORMAL
- en: The previous problem is caused by us not following the *single-responsibility
    principle*, which states that a function should do only one thing and do it well.
    Our function tries both to remove elements from an array and to print them at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the argument from `MutableList` to `List`, we won''t be able to
    invoke the `remove()` function on it, resolving our current problem. But this
    raises another question:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What if we need an empty list?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, our function should return a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In general, functions that don't return any values should be avoided in functional
    programming, as it usually means that they have a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s not enough that the collection *type* is immutable. The *content*
    of the collection should be immutable as well. To understand this better, let''s
    look at the following simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that this class has only one variable: `score`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a single instance of the `data` `class` and put it in an
    immutable collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We could put multiple instances of this class inside the collection, but to
    illustrate our point, only one is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's introduce the concept of *threads*.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with shared mutable state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you aren't familiar with **threads**, don't worry, we'll discuss them in
    detail in [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164), *Threads and Coroutines*.
    All you need to know for now is that threads allow the code to run *concurrently*.
    When using concurrent code and code that utilizes multiple CPUs, functional programming
    really helps. You may find that any other example that doesn't involve concurrency
    at all may seem rather convoluted or artificial.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s create a list that contains two threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each thread increments `score` by `1000` in total, using a regular
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We wait for the threads to complete by using `join()`, and then we check the
    counter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code yourself, the value will be anything under `2000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a classic case of a *race condition* for mutable variables. The number
    you''ll get will be different every time you run this code. The reason for this
    may be familiar to you if you have encountered concurrency previously. And, it
    has nothing to do with threads not completing their work, by the way. You can
    make sure of this by adding a print message after the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This also isn't the fault of using the increment (`++`) operator. As you can
    see, we used the long notation to increment the value, but if you run it again
    as many times as possible, you would still get the wrong results.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this behavior is that the addition operation and the assignment
    operation are not *atomic*. Two threads may override the addition operations of
    each other, resulting in the number not being incremented enough times.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used an extreme example of a collection that contains exactly one element.
    In the real world, the collections you will be working with will usually contain
    multiple elements. For example, you would track scores for multiple players, or
    even maintain a ranking system for thousands of players simultaneously. This would
    complicate the example even further.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you need to remember is the following: even if a collection is immutable,
    it may still *contain* mutable objects inside. Mutable objects are not thread-safe.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at *tuples*, which are an example of immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In functional programming, a `pair`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`pair` contains two properties – called `first` and `second` – and is immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can *destructure* `pair` into two separate values using a *destructure declaration*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When iterating over a map, we also work with another type of tuple: `Map.Entry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This tuple already has `key` and `value` members, instead of `first` and `second`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `pair`, there is a `Triple` tuple that also contains a `third`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In general, `data` classes are usually a good implementation for tuples because
    they provide clear naming. If you look at the preceding example, it's not immediately
    obvious that the `310` value represents the number of pages.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we saw in the previous section, not every `data` class is a proper
    tuple. You need to make sure that all of its members are *values* and not *variables*.
    You also need to check whether any nested collections or classes it has are immutable
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s discuss another important topic in functional programming: functions
    as a first-class citizen of the language.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already covered some of the functional capabilities of Kotlin in the chapters
    dedicated to design patterns. The **Strategy** and **Command** design patterns
    are only two examples that rely heavily on the ability to accept functions as
    arguments, return functions, store functions as values, or put functions inside
    of collections. In this section, we'll cover some other aspects of functional
    programming in Kotlin, such as *function purity* and *currying*.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed previously, in Kotlin, it''s possible for a function to return
    another function. Let''s look at the following simple function to understand this
    syntax in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, our `generateMultiply` function returns another function that doesn't
    have a name. Functions without a name are called **anonymous functions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also rewrite the preceding code using shorter syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If a function without a name uses short syntax, it's called a **lambda function**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the signature of the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: From that signature, we know that the function that we return will accept a
    single integer as input and produce an integer as output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function doesn''t accept any arguments, we denote that using empty round
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function doesn''t return anything, we use the `Unit` type to specify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions in Kotlin can be assigned to a variable or value to be invoked later
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The function assigned to a variable is usually called a **literal function**.
  prefs: []
  type: TYPE_NORMAL
- en: We applied this in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*, when discussing the Strategy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to specify a function as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function is the last parameter, it can also be supplied in an ad hoc fashion,
    outside of the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This syntax is also called **trailing lambda** or **call suffix**. We saw an
    example of this in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*, when discussing the Interpreter design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the basic syntax of functions, let's see how they can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions in a standard library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with Kotlin, something you will be doing on a daily basis is working
    with *collections*. As we mentioned briefly in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, collections have support for higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the previous chapters, to print elements of a collection one
    by one, we used a boring `for-each` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Many of you probably groaned at seeing this. But I hope you didn''t stop reading
    the book altogether. Of course, there is also another way to achieve the same
    goal that is common in many programming languages: a `forEach` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is one of the most basic examples of a higher-order function.
    Let''s see how it''s declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `action` is a function that receives an element of a collection and doesn''t
    return anything. This function presents an opportunity to discuss another aspect
    of Kotlin: the `it` notation.'
  prefs: []
  type: TYPE_NORMAL
- en: The it notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common in functional programming to keep your functions small and
    simple. The simpler the function, the easier it is to understand, and the more
    chances it has to be reused in other places. And the aim *of reusing* code is
    one of the basic Kotlin principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the preceding example, we didn''t specify the type of the `d`
    variable. We could do this using the same colon notation we have used elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: However, usually, we don't need to do this because the compiler can figure this
    out from the generic types that we use. After all, `dwarfs` is of the `List<String>`
    type, so `d` is of the `String` type as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the argument is not the only part that we can omit when writing
    short lambdas like this one. If a lambda takes a single argument, we can use the
    implicit name for it, which in this case, is `it`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases where we need to invoke a single function to a single parameter, we
    could also use a *function reference*. We saw an example of this in [*Chapter
    4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting Familiar with Behavioral
    Patterns*, when discussing the Strategy design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the shortest notation in most of the following examples. It is advised
    to use the longer syntax for cases such as *one lambda nested in another*. In
    those cases, giving proper names for the parameters is more important than conciseness.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the object-oriented paradigm, state is always stored within objects. But
    in functional programming, this isn''t necessarily the case. Let''s look at the
    following function as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is clearly a higher-order function, as you can see by
    its `return` type. It returns a function with zero arguments that produces an
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s store it in a variable, in the way we''ve already learned, and invoke
    it multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the function is able to keep a state, in this case, the value
    of a counter, even though it is not part of an object.
  prefs: []
  type: TYPE_NORMAL
- en: This is called a **closure**. The lambda has access to all of the local variables
    of the function that wraps it, and those local variables persist, as long as the
    reference to the lambda is kept.
  prefs: []
  type: TYPE_NORMAL
- en: The use of closures is another tool in the functional programming toolbox that
    reduces the need to define lots of classes that simply wrap a single function
    with some state.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **pure function** is a function without any side effects. A **side effect**
    can be considered anything that accesses or changes the external state. The external
    state can be a non-local variable (where a variable from a closure is still considered
    to be non-local) or any kind of IO (that is, reading or writing to a file or using
    any kind of network capabilities).
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: For those not familiar with the term, **IO** stands for **Input/Output**, and
    this covers any kind of interaction that is external to our program, such as writing
    to files or reading from a network.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the lambda we just discussed in the *Closures* section is not considered
    *pure* because it can return different output for the same input when it is invoked
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: '**Impure functions** are hard to test and to reason about in general, as the
    result they return may depend on the order of execution or on factors that we
    can''t control (such as network issues).'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to remember is that logging or even printing to a console still involves
    IO and is subject to the same set of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '*So, in this case, how do you ensure that Hello is printed?* The task is not
    as simple as it seems, as we''ll need some way to capture the standard output
    – that is, the same console where we usually see stuff printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll compare it to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function doesn''t have any side effects. That makes it a lot
    easier to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `hello()` function may look a bit meaningless, but that's actually one of
    the properties of pure functions. Their invocation could be replaced by their
    result if we knew it ahead of time. This is often called **referential transparency**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, not every function written in Kotlin is a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the function twice on the same list, it will return different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the preceding function to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our function is totally predictable, no matter how many times we invoke
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this instance, we used an immutable interface, `List<T>`,
    which helps us by preventing the possibility of mutating our input. When combined
    with the immutable values we discussed in the previous section, pure functions
    allow easier testing by providing predictable results and the parallelization
    of our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: A system that utilizes pure functions is easier to reason about because it doesn't
    rely on any external factors – what you see is what you get.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Currying** is a way to translate a function that takes a number of arguments
    into a chain of functions, where each function takes a single argument. This may
    sound confusing, so let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a function that takes two arguments as an input and returns the difference
    between them. However, some languages allow us to invoke this function with the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This is what currying looks like. Currying allows us to take a function with
    multiple arguments (in our case, two) and convert this function into a set of
    functions, where each one takes only a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine how this can be achieved in Kotlin. We''ve already seen how
    we can return a function from another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the shorter form of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use single-expression syntax to return an anonymous
    function without the need to declare the `return` type or use the `return` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here it is in an even shorter form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Now, an anonymous function is translated to a lambda, with the `return` type
    of the lambda inferred as well.
  prefs: []
  type: TYPE_NORMAL
- en: Although not very useful by itself, it's still an interesting concept to grasp.
    And if you're a **JavaScript** developer looking for a new job, make sure you
    understand it fully, since it's asked about in nearly every interview.
  prefs: []
  type: TYPE_NORMAL
- en: 'One real-world scenario where you might want to use currying is *logging*.
    A `log` function usually looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'We could fix the log level by storing the function in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `errorLog` function is easier to use than the regular `log`
    function because it accepts one argument instead of two. However, this raises
    a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What if we don''t want to create all of the possible loggers ahead of time?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can use currying. The *curried* version of this code would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s up to whoever uses our code to create the logger they want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This, in fact, is very similar to the Factory design pattern we covered in [*Chapter
    2*](B17816_02_ePub.xhtml#_idTextAnchor062), *Working with Creational Patterns*.
    Again, the power of a modern language decreases the number of custom classes we
    need to implement to achieve the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about another powerful technique that can save us from having
    to do the same computation over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If our function always returns the same output for the same input, we can easily
    map its input to the output, caching the results in the process. This technique
    is called **memoization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common task when developing different types of systems or solving problems
    is finding a way to avoid repeating the same computation multiple times. Let''s
    assume we receive multiple lists of integers, and for each list, we would like
    to print its sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the input, you can see that the first three sets are in fact equal
    – the difference is only in the order of the elements, so calculating the sum
    three times would be wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sum calculation can be easily described as a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This function does not depend on any external state and doesn't change the external
    state in any way. So, it is safe for the same input to replace the call to this
    function with the value it had returned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could store the results of a previous computation for the same set in a
    mutable map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid creating too many classes, we could use a higher-order function that
    would wrap the result in the cache that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use a method reference operator (`::`) to tell `computeIfAbsent` to
    use the `sum()` method in the event where the input hasn't been cached yet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `sum()` is a pure function, while `summarize()` is not. The latter
    will behave differently for the same input. But that's exactly what we want in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the following code on the preceding input will invoke the sum function
    only twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The combination of immutable objects, pure functions, and closures provides
    us with a powerful tool for performance optimization. Just remember: nothing is
    free. We trade one resource, CPU time, for another resource, which is memory.
    And it''s up to you to decide which resource is more expensive in each case.'
  prefs: []
  type: TYPE_NORMAL
- en: Using expressions instead of statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **statement** is a block of code that *doesn't return* anything. An **expression**,
    on the other hand, *returns a new value*. Since statements produce no results,
    the only way for them to be useful is to mutate the state, whether that's changing
    a variable, changing a data structure, or performing some kind of IO.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming tries to avoid mutating the state as much as possible.
    Theoretically, the more we rely on expressions, the more our functions will be
    pure, with all the benefits of functional purity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used the `if` expression many times already, so one of its benefits
    should be clear: it''s less verbose and, for that reason, less error-prone than
    the `if` statement from other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of `switch`/`case` on steroids. We've already seen how the `when`
    expression can be used, which we explored in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, so let's briefly discuss why this concept is important
    for the functional paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: You may know that in Java, `switch` accepts only some primitive types, strings,
    or enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, which is usually used to demonstrate how polymorphism
    is implemented in the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to decide which of the functions to call, we would need to write
    code akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: This code attempts to figure out at runtime what methods the `getSound` class
    implements.
  prefs: []
  type: TYPE_NORMAL
- en: This method could be shortened by introducing multiple returns, but in real
    projects, multiple returns are usually a bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: Since we don't have a `switch` statement for classes, we need to use an `if`
    statement instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compare the preceding code with the following Kotlin code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Since `when` is an expression, we avoided declaring the intermediate variable
    we previously had altogether. In addition, the code that uses pattern matching
    doesn't need any type checks and casts.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've learned how to replace imperative `if` statements with much more functional
    `when` expressions, let's see how we can replace imperative loops in our code
    by using *recursion*.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Recursion** is a function invoking itself with new arguments. Many well-known
    algorithms, such as **Depth First Search**, rely on recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a very inefficient function that uses recursion to calculate
    the sum of all the numbers in a given list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'We often try to avoid recursion due to the stack overflow errors that we may
    receive if our call stack is too deep. You can call this function with a list
    that contains a million numbers to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: However, Kotlin supports an optimization called **tail recursion**. One of the
    great benefits of tail recursion is that it avoids the dreaded stack overflow
    exception. If there is only a single recursive call in our function, we can use
    that optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our recursive function using a new keyword, `tailrec`, to avoid
    this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Now, the compiler will optimize our call and avoid the exception completely.
  prefs: []
  type: TYPE_NORMAL
- en: However, this optimization doesn't work if you have multiple recursive calls,
    such as in the **Merge Sort** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following function, which is the *sort* part of the Merge
    Sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there are two recursive calls instead of one. The Kotlin compiler
    will then issue the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a better understanding of functional programming and its
    benefits, as well as how Kotlin approaches this topic. We've discussed the concepts
    of *immutability* and *pure functions*, and how combining these results in more
    testable code that is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how Kotlin supports *closures*, which allow a function to access
    the variables of the function that wraps it and effectively store the state between
    executions. This enables techniques such as *currying* and *memoization* that
    allow us to fix some of the function arguments (by acting as defaults) and remember
    the value returned from a function in order to avoid recalculating it.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that Kotlin uses the `tailrec` keyword to allow the compiler to optimize
    *tail recursion*. We also looked at *higher-order functions*, *expressions versus
    statements*, and *pattern matching*. All of these concepts allow us to write code
    that is easier to test and has less risk of concurrency bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll put this knowledge to practical use and discover
    how **reactive programming** builds upon functional programming to create scalable
    and resilient systems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are higher-order functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `tailrec` keyword in Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are pure functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
