- en: '*Chapter 5*: Introducing Functional Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：介绍函数式编程'
- en: This chapter will discuss the fundamental principles of **functional programming**
    and how they fit into the **Kotlin** programming language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论函数式编程的基本原则以及它们如何融入**Kotlin**编程语言。
- en: As you'll discover, we've already touched on some of the concepts in this chapter,
    as it would have been hard to discuss the benefits of the language up until now
    without touching on functional programming concepts such as **data immutability**
    and **functions as values**. But as we did before, we'll look at those features
    from a different angle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将发现的，我们已经在本章中触及了一些概念，因为如果不涉及函数式编程的概念，如**数据不可变性**和**函数作为值**，那么讨论语言的优点将非常困难。但就像我们之前做的那样，我们将从不同的角度来探讨这些特性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reasoning behind the functional approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式方法背后的原因
- en: Immutability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Functions as values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为值
- en: Expressions, not statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式，而非语句
- en: Recursion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: After completing this chapter, you'll understand how the concepts of functional
    programming are embedded in the Kotlin language and when to use them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将了解函数式编程的概念如何嵌入到Kotlin语言中，以及何时使用它们。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to install the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要安装以下内容：
- en: '**IntelliJ IDEA** **Community Edition** ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ IDEA** **社区版** ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))'
- en: '**OpenJDK** **11** (or higher) ([https://openjdk.java.net/install/](https://openjdk.java.net/install/))'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenJDK** **11**（或更高版本）([https://openjdk.java.net/install/](https://openjdk.java.net/install/))'
- en: You can find the code files for this chapter on **GitHub** at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**GitHub**上找到本章的代码文件，地址为[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter05)。
- en: Reasoning behind the functional approach
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式方法背后的原因
- en: '**Functional programming** has been around for as long as other programming
    paradigms, for example, procedural and object-oriented programming. But in the
    past 15 years, it has gained significant momentum. The reason for this is that
    something else stalled: **CPU** speeds. We cannot speed up our CPUs as much as
    we did in the past, so we must **parallelize** our programs. And it turns out
    that the functional programming paradigm is exceptionally good at running parallel
    tasks.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**与其他编程范式一样历史悠久，例如过程式和面向对象编程。但在过去的15年里，它已经取得了显著的进展。原因在于其他方面的发展停滞了：**CPU**速度。我们无法像过去那样大幅提高CPU速度，因此我们必须**并行化**我们的程序。而且结果证明，函数式编程范式在运行并行任务方面非常出色。'
- en: The evolution of multicore processors is a fascinating topic in itself, but
    we'll cover it only briefly here. Workstations have had multiple processors since
    at least the 1980s to support the running of tasks from different users in parallel.
    Since workstations were massive during this era, they didn't need to worry about
    cramming everything into one chip. But when multiprocessors came to the consumer
    market around 2005, it became necessary to have one physical unit that could work
    in parallel. This is why we have multiple cores in one chip in our PC or laptop.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 多核处理器的演变本身就是一个迷人的话题，但在这里我们只会简要介绍。工作站自20世纪80年代以来就已经拥有多个处理器，以支持并行运行来自不同用户的任务。由于这个时代的工作站体积庞大，它们不需要担心将所有内容都挤在一个芯片上。但到了2005年左右，消费市场出现了多处理器，这时就需要一个能够并行工作的物理单元。这就是为什么我们的PC或笔记本电脑中有一个多核芯片。
- en: 'But that''s not the only reason we use functional programming. Here are a few
    more:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是我们使用函数式编程的唯一原因。这里还有更多：
- en: Functional programming favors pure functions, and pure functions are usually
    easier to reason about and test.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程倾向于纯函数，而纯函数通常更容易推理和测试。
- en: Code written in a functional way is often more declarative than imperative,
    dealing with the *what* instead of the *how*, and this can be a benefit.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式方式编写的代码通常比命令式代码更具声明性，处理的是**什么**而不是**如何**，这可以是一个优点。
- en: In the following sections, we'll explore the different aspects of functional
    programming, starting with *immutability*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨函数式编程的不同方面，从*不可变性*开始。
- en: Immutability
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'One of the fundamental concepts of functional programming is **immutability**.
    This means that from the moment the function receives input to the moment the
    function returns output, the object doesn''t change. *But how could it change?*
    Well, let''s look at a simple example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个基本概念是**不可变性**。这意味着从函数接收输入的那一刻起，到函数返回输出的那一刻，对象不会改变。*但是它怎么能改变呢？*好吧，让我们看看一个简单的例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code would output `a` first, and then we would receive `ConcurrentModificationException`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将首先输出`a`，然后我们会收到`ConcurrentModificationException`。
- en: 'The reason for this is that the `for-each` loop uses an iterator (which we
    already discussed in the previous chapter), and by mutating the list inside the
    loop, we interfere with its operation. However, this raises a question:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，`for-each` 循环使用了一个迭代器（我们已经在上一章中讨论过），而在循环内部修改列表会干扰其操作。然而，这引发了一个问题：
- en: '*Wouldn''t it be great if we could protect ourselves from these runtime exceptions
    in the first place?*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们可以从一开始就保护自己免受这些运行时异常的影响，那岂不是很好？*'
- en: Let's see how *immutable collections* can help us with this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*不可变集合*如何帮助我们解决这个问题。
- en: Immutable collections
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变集合
- en: In [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Kotlin*, we already mentioned that collections in Kotlin are immutable by default,
    which is unlike many other languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B17816_01_ePub.xhtml#_idTextAnchor015)，“Kotlin入门”，我们已经提到Kotlin中的集合默认是不可变的，这与许多其他语言不同。
- en: The previous problem is caused by us not following the *single-responsibility
    principle*, which states that a function should do only one thing and do it well.
    Our function tries both to remove elements from an array and to print them at
    the same time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个问题是由我们没有遵循*单一职责原则*引起的，该原则指出，一个函数应该只做一件事，并且要做好。我们的函数试图同时从数组中删除元素并打印它们。
- en: 'If we change the argument from `MutableList` to `List`, we won''t be able to
    invoke the `remove()` function on it, resolving our current problem. But this
    raises another question:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将参数从`MutableList`改为`List`，我们就无法调用其上的`remove()`函数，从而解决我们当前的问题。但这又提出了另一个问题：
- en: '*What if we need an empty list?*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们需要一个空列表怎么办？*'
- en: 'In this case, our function should return a new object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的函数应该返回一个新的对象：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In general, functions that don't return any values should be avoided in functional
    programming, as it usually means that they have a side effect.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在函数式编程中应避免不返回任何值的函数，因为这通常意味着它们有副作用。
- en: 'However, it''s not enough that the collection *type* is immutable. The *content*
    of the collection should be immutable as well. To understand this better, let''s
    look at the following simple class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，集合*类型*不可变还不够。集合的*内容*也应该不可变。为了更好地理解这一点，让我们看看以下简单的类：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see that this class has only one variable: `score`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这个类只有一个变量：`score`。
- en: 'Next, we''ll create a single instance of the `data` `class` and put it in an
    immutable collection:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`data` `class`的单个实例并将其放入不可变集合中：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We could put multiple instances of this class inside the collection, but to
    illustrate our point, only one is needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在集合中放置这个类的多个实例，但为了说明我们的观点，只需要一个实例。
- en: Next, let's introduce the concept of *threads*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们介绍*线程*的概念。
- en: The problem with shared mutable state
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享可变状态的问题
- en: If you aren't familiar with **threads**, don't worry, we'll discuss them in
    detail in [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164), *Threads and Coroutines*.
    All you need to know for now is that threads allow the code to run *concurrently*.
    When using concurrent code and code that utilizes multiple CPUs, functional programming
    really helps. You may find that any other example that doesn't involve concurrency
    at all may seem rather convoluted or artificial.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对**线程**不熟悉，不要担心，我们将在[*第6章*](B17816_06_ePub.xhtml#_idTextAnchor164)，“线程和协程”中详细讨论它们。现在您需要知道的是，线程允许代码*并发*运行。当使用并发代码和利用多个CPU的代码时，函数式编程非常有帮助。您可能会发现，任何不涉及并发的其他示例都可能显得相当复杂或人为。
- en: 'For now, let''s create a list that contains two threads:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含两个线程的列表：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, each thread increments `score` by `1000` in total, using a regular
    `for` loop.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个线程使用常规的`for`循环总共增加`score` 1000。
- en: 'We wait for the threads to complete by using `join()`, and then we check the
    counter value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`join()`等待线程完成，然后检查计数器的值：
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you run the code yourself, the value will be anything under `2000`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己运行代码，值将在`2000`以下。
- en: 'This is a classic case of a *race condition* for mutable variables. The number
    you''ll get will be different every time you run this code. The reason for this
    may be familiar to you if you have encountered concurrency previously. And, it
    has nothing to do with threads not completing their work, by the way. You can
    make sure of this by adding a print message after the loop:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可变变量的经典*竞态条件*案例。每次运行此代码时，你得到的结果都会不同。如果你之前遇到过并发，这个原因可能对你来说很熟悉。顺便说一句，这与线程没有完成它们的工作无关。你可以在循环后添加一个打印消息来确保这一点：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This also isn't the fault of using the increment (`++`) operator. As you can
    see, we used the long notation to increment the value, but if you run it again
    as many times as possible, you would still get the wrong results.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不是使用增量（`++`）操作符的错。正如你所见，我们使用了长格式来增加值，但如果你尽可能多次地运行它，你仍然会得到错误的结果。
- en: The reason for this behavior is that the addition operation and the assignment
    operation are not *atomic*. Two threads may override the addition operations of
    each other, resulting in the number not being incremented enough times.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的原因是加法操作和赋值操作不是原子的。两个线程可能会覆盖彼此的加法操作，导致数值增加的次数不够。
- en: Here, we used an extreme example of a collection that contains exactly one element.
    In the real world, the collections you will be working with will usually contain
    multiple elements. For example, you would track scores for multiple players, or
    even maintain a ranking system for thousands of players simultaneously. This would
    complicate the example even further.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个包含恰好一个元素的集合的极端例子。在现实世界中，你将要处理的集合通常包含多个元素。例如，你可能需要跟踪多个玩家的得分，甚至同时维护数千个玩家的排名系统。这会使例子变得更加复杂。
- en: 'What you need to remember is the following: even if a collection is immutable,
    it may still *contain* mutable objects inside. Mutable objects are not thread-safe.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住的是以下内容：即使一个集合是不可变的，它仍然可能包含可变对象。可变对象不是线程安全的。
- en: Next, let's look at *tuples*, which are an example of immutable objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看元组，它们是不可变对象的一个例子。
- en: Tuples
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'In functional programming, a `pair`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，一个`pair`：
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`pair` contains two properties – called `first` and `second` – and is immutable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`pair`包含两个属性，称为`first`和`second`，是不可变的：'
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can *destructure* `pair` into two separate values using a *destructure declaration*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`解构声明`将`pair`解构为两个单独的值：
- en: '[PRE36]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When iterating over a map, we also work with another type of tuple: `Map.Entry`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代映射时，我们还会处理另一种类型的元组：`Map.Entry`：
- en: '[PRE38]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This tuple already has `key` and `value` members, instead of `first` and `second`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元组已经包含了`key`和`value`成员，而不是`first`和`second`。
- en: 'In addition to `pair`, there is a `Triple` tuple that also contains a `third`
    value:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`pair`之外，还有一个包含`third`值的`Triple`元组：
- en: '[PRE41]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In general, `data` classes are usually a good implementation for tuples because
    they provide clear naming. If you look at the preceding example, it's not immediately
    obvious that the `310` value represents the number of pages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`data`类是元组的一个很好的实现，因为它们提供了清晰的命名。如果你看前面的例子，并不立即明显地看出`310`值代表页数。
- en: However, as we saw in the previous section, not every `data` class is a proper
    tuple. You need to make sure that all of its members are *values* and not *variables*.
    You also need to check whether any nested collections or classes it has are immutable
    as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在上一节中看到的，并不是每个`data`类都是合适的元组。你需要确保它的所有成员都是值而不是变量。你还需要检查它是否有嵌套的不可变集合或类。
- en: 'Now, let''s discuss another important topic in functional programming: functions
    as a first-class citizen of the language.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论函数式编程中的另一个重要主题：函数作为语言的第一等公民。
- en: Functions as values
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为值
- en: We already covered some of the functional capabilities of Kotlin in the chapters
    dedicated to design patterns. The **Strategy** and **Command** design patterns
    are only two examples that rely heavily on the ability to accept functions as
    arguments, return functions, store functions as values, or put functions inside
    of collections. In this section, we'll cover some other aspects of functional
    programming in Kotlin, such as *function purity* and *currying*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在关于设计模式的章节中介绍了Kotlin的一些函数式能力。**策略**和**命令**设计模式只是两个依赖于接受函数作为参数、返回函数、将函数作为值存储或将函数放入集合中的能力的例子。在本节中，我们将介绍Kotlin函数式编程的一些其他方面，例如*函数纯度*和*柯里化*。
- en: Learning about higher-order functions
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解高阶函数
- en: 'As we discussed previously, in Kotlin, it''s possible for a function to return
    another function. Let''s look at the following simple function to understand this
    syntax in depth:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，在 Kotlin 中，一个函数可以返回另一个函数。让我们看看以下简单的函数，以深入了解这个语法：
- en: '[PRE42]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, our `generateMultiply` function returns another function that doesn't
    have a name. Functions without a name are called **anonymous functions**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的 `generateMultiply` 函数返回另一个没有名字的函数。没有名字的函数被称为**匿名函数**。
- en: 'We could also rewrite the preceding code using shorter syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用更短的语法重写前面的代码：
- en: '[PRE47]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If a function without a name uses short syntax, it's called a **lambda function**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个没有名字的函数使用短语法，它被称为**lambda 函数**。
- en: 'Next, let''s look at the signature of the return type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看返回类型的签名：
- en: '[PRE52]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: From that signature, we know that the function that we return will accept a
    single integer as input and produce an integer as output.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个签名中，我们知道我们返回的函数将接受一个整数作为输入并产生一个整数作为输出。
- en: 'If a function doesn''t accept any arguments, we denote that using empty round
    brackets:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数不接受任何参数，我们使用空圆括号来表示：
- en: '[PRE53]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If a function doesn''t return anything, we use the `Unit` type to specify that:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数不返回任何内容，我们使用 `Unit` 类型来指定：
- en: '[PRE54]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Functions in Kotlin can be assigned to a variable or value to be invoked later
    on:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的函数可以被分配给变量或值，稍后调用：
- en: '[PRE55]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The function assigned to a variable is usually called a **literal function**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给变量的函数通常被称为**字面函数**。
- en: We applied this in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*, when discussing the Strategy design pattern.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 4 章*](B17816_04_ePub.xhtml#_idTextAnchor115)“熟悉行为模式”中讨论策略设计模式时应用了这一点。
- en: 'It''s also possible to specify a function as a parameter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将函数指定为参数：
- en: '[PRE58]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If a function is the last parameter, it can also be supplied in an ad hoc fashion,
    outside of the brackets:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是最后一个参数，它也可以以临时方式提供，在括号之外：
- en: '[PRE62]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This syntax is also called **trailing lambda** or **call suffix**. We saw an
    example of this in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*, when discussing the Interpreter design pattern.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法也被称为**尾随 lambda**或**调用后缀**。我们在[*第 4 章*](B17816_04_ePub.xhtml#_idTextAnchor115)“熟悉行为模式”中讨论解释器设计模式时看到了这个例子。
- en: Now that we've covered the basic syntax of functions, let's see how they can
    be used.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数的基本语法，让我们看看它们是如何被使用的。
- en: Higher-order functions in a standard library
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的高阶函数
- en: When working with Kotlin, something you will be doing on a daily basis is working
    with *collections*. As we mentioned briefly in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, collections have support for higher-order functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Kotlin 时，你将每天都会做的一件事是与**集合**一起工作。正如我们在[*第 1 章*](B17816_01_ePub.xhtml#_idTextAnchor015)“开始使用
    Kotlin”中简要提到的，集合支持高阶函数。
- en: 'For example, in the previous chapters, to print elements of a collection one
    by one, we used a boring `for-each` loop:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的章节中，为了逐个打印集合中的元素，我们使用了无聊的 `for-each` 循环：
- en: '[PRE65]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Many of you probably groaned at seeing this. But I hope you didn''t stop reading
    the book altogether. Of course, there is also another way to achieve the same
    goal that is common in many programming languages: a `forEach` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人看到这个可能都会感到沮丧。但我希望你没有完全停止阅读这本书。当然，在许多编程语言中，还有另一种实现相同目标的方法：一个 `forEach` 函数：
- en: '[PRE69]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This function is one of the most basic examples of a higher-order function.
    Let''s see how it''s declared:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是高阶函数最基本的一个例子。让我们看看它是如何声明的：
- en: '[PRE72]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, `action` is a function that receives an element of a collection and doesn''t
    return anything. This function presents an opportunity to discuss another aspect
    of Kotlin: the `it` notation.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`action` 是一个接收集合中元素但不返回任何内容的函数。这个函数提供了一个讨论 Kotlin 另一个方面的机会：`it` 语法。
- en: The it notation
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`it` 语法'
- en: It is very common in functional programming to keep your functions small and
    simple. The simpler the function, the easier it is to understand, and the more
    chances it has to be reused in other places. And the aim *of reusing* code is
    one of the basic Kotlin principles.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，保持函数小而简单是非常常见的。函数越简单，理解起来就越容易，也越有可能在其他地方被重用。而重用代码的目标是 Kotlin 的基本原则之一。
- en: 'Notice that in the preceding example, we didn''t specify the type of the `d`
    variable. We could do this using the same colon notation we have used elsewhere:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的例子中，我们没有指定`d`变量的类型。我们可以使用我们之前使用过的相同冒号符号来完成此操作：
- en: '[PRE73]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: However, usually, we don't need to do this because the compiler can figure this
    out from the generic types that we use. After all, `dwarfs` is of the `List<String>`
    type, so `d` is of the `String` type as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常我们不需要这样做，因为编译器可以从我们使用的泛型类型中推断出这一点。毕竟，`dwarfs`是`List<String>`类型，所以`d`也是`String`类型。
- en: 'The type of the argument is not the only part that we can omit when writing
    short lambdas like this one. If a lambda takes a single argument, we can use the
    implicit name for it, which in this case, is `it`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写像这样简短的lambda表达式时，我们不需要省略的不仅仅是参数的类型。如果一个lambda只有一个参数，我们可以使用它的隐含名称，在这种情况下，是`it`：
- en: '[PRE76]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In cases where we need to invoke a single function to a single parameter, we
    could also use a *function reference*. We saw an example of this in [*Chapter
    4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting Familiar with Behavioral
    Patterns*, when discussing the Strategy design pattern:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要将单个函数调用到单个参数的情况下，我们也可以使用*函数引用*。我们在[*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)中看到了一个例子，*熟悉行为模式*，在讨论策略设计模式时：
- en: '[PRE79]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We'll use the shortest notation in most of the following examples. It is advised
    to use the longer syntax for cases such as *one lambda nested in another*. In
    those cases, giving proper names for the parameters is more important than conciseness.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的大多数例子中，我们将使用最简短的表示法。建议在像*嵌套在一个lambda中的lambda*这样的情况下使用较长的语法。在这些情况下，为参数提供适当的名称比简洁更重要。
- en: Closures
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'In the object-oriented paradigm, state is always stored within objects. But
    in functional programming, this isn''t necessarily the case. Let''s look at the
    following function as an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象范式中，状态始终存储在对象中。但在函数式编程中，这并不一定是这种情况。让我们以以下函数为例：
- en: '[PRE80]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The preceding example is clearly a higher-order function, as you can see by
    its `return` type. It returns a function with zero arguments that produces an
    integer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子显然是一个高阶函数，正如您可以通过其`return`类型看到的那样。它返回一个不带参数的函数，该函数产生一个整数。
- en: 'Let''s store it in a variable, in the way we''ve already learned, and invoke
    it multiple times:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照我们已经学到的这种方式将其存储在一个变量中，并多次调用它：
- en: '[PRE84]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you can see, the function is able to keep a state, in this case, the value
    of a counter, even though it is not part of an object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该函数能够保持状态，在这种情况下，计数器的值，即使它不是对象的一部分。
- en: This is called a **closure**. The lambda has access to all of the local variables
    of the function that wraps it, and those local variables persist, as long as the
    reference to the lambda is kept.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**闭包**。lambda可以访问包装它的函数的所有局部变量，并且只要保持对lambda的引用，这些局部变量就会持续存在。
- en: The use of closures is another tool in the functional programming toolbox that
    reduces the need to define lots of classes that simply wrap a single function
    with some state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的使用是函数式编程工具箱中的另一个工具，它减少了定义大量仅用一些状态包装单个函数的类的需求。
- en: Pure functions
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: A **pure function** is a function without any side effects. A **side effect**
    can be considered anything that accesses or changes the external state. The external
    state can be a non-local variable (where a variable from a closure is still considered
    to be non-local) or any kind of IO (that is, reading or writing to a file or using
    any kind of network capabilities).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**是一个没有副作用的功能。副作用可以被认为是任何访问或改变外部状态的行为。外部状态可以是非局部变量（其中闭包中的变量仍然被认为是非局部的）或任何类型的IO（即，读取或写入文件或使用任何类型的网络功能）。'
- en: 'Important Note:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: For those not familiar with the term, **IO** stands for **Input/Output**, and
    this covers any kind of interaction that is external to our program, such as writing
    to files or reading from a network.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉这个术语的人来说，**IO**代表**输入/输出**，这涵盖了任何超出我们程序范围的外部交互，例如写入文件或从网络读取。
- en: For example, the lambda we just discussed in the *Closures* section is not considered
    *pure* because it can return different output for the same input when it is invoked
    multiple times.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在*闭包*部分讨论的lambda不被认为是*纯*的，因为它在多次调用时对相同的输入可以返回不同的输出。
- en: '**Impure functions** are hard to test and to reason about in general, as the
    result they return may depend on the order of execution or on factors that we
    can''t control (such as network issues).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**不纯函数**通常很难测试和推理，因为它们返回的结果可能取决于执行顺序或我们无法控制的因素（例如网络问题）。'
- en: One thing to remember is that logging or even printing to a console still involves
    IO and is subject to the same set of problems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一件事是，记录日志或甚至打印到控制台仍然涉及 I/O，并受到相同问题的影响。
- en: 'Let''s look at the following simple function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下简单的函数：
- en: '[PRE88]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '*So, in this case, how do you ensure that Hello is printed?* The task is not
    as simple as it seems, as we''ll need some way to capture the standard output
    – that is, the same console where we usually see stuff printed.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，在这种情况下，你如何确保打印出 Hello 呢？* 这个任务并不像看起来那么简单，因为我们需要某种方式来捕获标准输出——即我们通常看到打印内容的同一个控制台。'
- en: 'We''ll compare it to the following function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它与以下函数进行比较：
- en: '[PRE89]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The following function doesn''t have any side effects. That makes it a lot
    easier to test:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数没有任何副作用。这使得测试它变得容易得多：
- en: '[PRE90]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `hello()` function may look a bit meaningless, but that's actually one of
    the properties of pure functions. Their invocation could be replaced by their
    result if we knew it ahead of time. This is often called **referential transparency**.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello()` 函数可能看起来有点没有意义，但实际上这是纯函数的一个特性。如果我们提前知道结果，它们的调用可以被它们的结果所替代。这通常被称为**引用透明性**。'
- en: 'As we mentioned earlier, not every function written in Kotlin is a pure function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，不是每个用 Kotlin 编写的函数都是纯函数：
- en: '[PRE93]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If we call the function twice on the same list, it will return different results:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在同一个列表上两次调用该函数，它将返回不同的结果：
- en: '[PRE96]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Compare the preceding function to this one:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的函数与这个函数比较：
- en: '[PRE99]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, our function is totally predictable, no matter how many times we invoke
    it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的函数是完全可预测的，无论我们调用多少次：
- en: '[PRE102]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: As you can see, in this instance, we used an immutable interface, `List<T>`,
    which helps us by preventing the possibility of mutating our input. When combined
    with the immutable values we discussed in the previous section, pure functions
    allow easier testing by providing predictable results and the parallelization
    of our algorithms.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个例子中，我们使用了一个不可变的接口`List<T>`，它通过防止我们修改输入来帮助我们。当与上一节中讨论的不可变值结合使用时，纯函数通过提供可预测的结果和算法的并行化，使得测试更容易。
- en: A system that utilizes pure functions is easier to reason about because it doesn't
    rely on any external factors – what you see is what you get.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 利用纯函数的系统更容易推理，因为它不依赖于任何外部因素——所见即所得。
- en: Currying
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: '**Currying** is a way to translate a function that takes a number of arguments
    into a chain of functions, where each function takes a single argument. This may
    sound confusing, so let''s look at a simple example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化**是将接受多个参数的函数转换为一系列函数的方法，其中每个函数只接受一个参数。这听起来可能有些令人困惑，所以让我们看看一个简单的例子：'
- en: '[PRE105]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This is a function that takes two arguments as an input and returns the difference
    between them. However, some languages allow us to invoke this function with the
    following syntax:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受两个参数作为输入并返回它们之间差的函数。然而，一些语言允许我们使用以下语法调用此函数：
- en: '[PRE109]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This is what currying looks like. Currying allows us to take a function with
    multiple arguments (in our case, two) and convert this function into a set of
    functions, where each one takes only a single argument.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是柯里化的样子。柯里化允许我们将具有多个参数的函数（在我们的例子中是两个）转换为一系列函数，其中每个函数只接受一个参数。
- en: 'Let''s examine how this can be achieved in Kotlin. We''ve already seen how
    we can return a function from another function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Kotlin 中实现这一点。我们已经看到如何从一个函数中返回另一个函数：
- en: '[PRE110]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Here is the shorter form of the preceding code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面代码的简短形式：
- en: '[PRE115]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In the preceding example, we use single-expression syntax to return an anonymous
    function without the need to declare the `return` type or use the `return` keyword.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用单表达式语法返回一个匿名函数，而不需要声明`return`类型或使用`return`关键字。
- en: 'And here it is in an even shorter form:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的更简短形式：
- en: '[PRE118]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Now, an anonymous function is translated to a lambda, with the `return` type
    of the lambda inferred as well.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个匿名函数被转换为一个 lambda，lambda 的`return`类型也被推断出来。
- en: Although not very useful by itself, it's still an interesting concept to grasp.
    And if you're a **JavaScript** developer looking for a new job, make sure you
    understand it fully, since it's asked about in nearly every interview.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它本身可能不是非常有用，但它仍然是一个有趣的概念，值得掌握。如果你是一位正在寻找新工作的**JavaScript**开发者，确保你完全理解它，因为几乎在每次面试中都会问到它。
- en: 'One real-world scenario where you might want to use currying is *logging*.
    A `log` function usually looks something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想要使用柯里化的一个真实世界场景是*日志记录*。一个`log`函数通常看起来像这样：
- en: '[PRE119]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We could fix the log level by storing the function in a variable:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将函数存储在变量中来设置日志级别：
- en: '[PRE123]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Notice that the `errorLog` function is easier to use than the regular `log`
    function because it accepts one argument instead of two. However, this raises
    a question:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`errorLog`函数比常规的`log`函数更容易使用，因为它只接受一个参数而不是两个。然而，这引发了一个问题：
- en: '*What if we don''t want to create all of the possible loggers ahead of time?*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们不想提前创建所有可能的记录器呢？*'
- en: 'In this case, we can use currying. The *curried* version of this code would
    look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用柯里化。这个代码的*柯里化*版本将看起来像这样：
- en: '[PRE126]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now, it''s up to whoever uses our code to create the logger they want:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，取决于谁使用我们的代码，他们可以创建他们想要的记录器：
- en: '[PRE131]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This, in fact, is very similar to the Factory design pattern we covered in [*Chapter
    2*](B17816_02_ePub.xhtml#_idTextAnchor062), *Working with Creational Patterns*.
    Again, the power of a modern language decreases the number of custom classes we
    need to implement to achieve the same behavior.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这与我们在[*第2章*](B17816_02_ePub.xhtml#_idTextAnchor062)中讨论的工厂设计模式非常相似，*使用创建型模式*。同样，现代语言的力量减少了我们需要实现相同行为所需的自定义类的数量。
- en: Next, let's talk about another powerful technique that can save us from having
    to do the same computation over and over again.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈另一种强大的技术，它可以让我们免于重复进行相同的计算。
- en: Memoization
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆化
- en: If our function always returns the same output for the same input, we can easily
    map its input to the output, caching the results in the process. This technique
    is called **memoization**.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的函数总是对相同的输入返回相同的输出，我们就可以轻松地将输入映射到输出，并在过程中缓存结果。这种技术称为**记忆化**。
- en: 'A common task when developing different types of systems or solving problems
    is finding a way to avoid repeating the same computation multiple times. Let''s
    assume we receive multiple lists of integers, and for each list, we would like
    to print its sum:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发不同类型的系统或解决问题时，一个常见的任务是找到一种方法来避免多次重复相同的计算。假设我们收到多个整数列表，并且对于每个列表，我们希望打印其总和：
- en: '[PRE133]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Looking at the input, you can see that the first three sets are in fact equal
    – the difference is only in the order of the elements, so calculating the sum
    three times would be wasteful.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下输入，你可以看到前三个集合实际上是相等的——区别只在于元素的顺序，所以计算三次总和将是浪费的。
- en: 'The sum calculation can be easily described as a pure function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 求和计算可以很容易地描述为一个纯函数：
- en: '[PRE139]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This function does not depend on any external state and doesn't change the external
    state in any way. So, it is safe for the same input to replace the call to this
    function with the value it had returned previously.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不依赖于任何外部状态，并且以任何方式都不会改变外部状态。因此，对于相同的输入，可以用它之前返回的值替换对这个函数的调用是安全的。
- en: 'We could store the results of a previous computation for the same set in a
    mutable map:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在可变映射中存储相同集合的前一次计算结果：
- en: '[PRE142]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'To avoid creating too many classes, we could use a higher-order function that
    would wrap the result in the cache that we created earlier:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免创建过多的类，我们可以使用一个高阶函数，它会将结果包装在我们之前创建的缓存中：
- en: '[PRE143]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Here, we use a method reference operator (`::`) to tell `computeIfAbsent` to
    use the `sum()` method in the event where the input hasn't been cached yet.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用方法引用操作符（`::`）告诉`computeIfAbsent`在输入尚未缓存的情况下使用`sum()`方法。
- en: Note that `sum()` is a pure function, while `summarize()` is not. The latter
    will behave differently for the same input. But that's exactly what we want in
    this case.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sum()`是一个纯函数，而`summarize()`则不是。后者对于相同的输入会有不同的行为。但这正是我们想要的。
- en: 'Running the following code on the preceding input will invoke the sum function
    only twice:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输入上运行以下代码将只调用求和函数两次：
- en: '[PRE149]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The combination of immutable objects, pure functions, and closures provides
    us with a powerful tool for performance optimization. Just remember: nothing is
    free. We trade one resource, CPU time, for another resource, which is memory.
    And it''s up to you to decide which resource is more expensive in each case.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 不变对象、纯函数和闭包的结合为我们提供了强大的性能优化工具。只需记住：没有什么是免费的。我们用CPU时间这种资源交换另一种资源，即内存。而决定每种情况下哪种资源更昂贵的是你。
- en: Using expressions instead of statements
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表达式而不是语句
- en: A **statement** is a block of code that *doesn't return* anything. An **expression**,
    on the other hand, *returns a new value*. Since statements produce no results,
    the only way for them to be useful is to mutate the state, whether that's changing
    a variable, changing a data structure, or performing some kind of IO.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**语句**是一段不返回任何内容的代码块。相反，**表达式**返回一个新的值。由于语句不产生结果，它们唯一有用的方式是改变状态，无论是改变一个变量、改变数据结构还是执行某种类型的I/O。'
- en: Functional programming tries to avoid mutating the state as much as possible.
    Theoretically, the more we rely on expressions, the more our functions will be
    pure, with all the benefits of functional purity.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程试图尽可能避免改变状态。从理论上讲，我们越依赖表达式，我们的函数就越纯，从而获得函数式纯度的所有好处。
- en: 'We''ve used the `if` expression many times already, so one of its benefits
    should be clear: it''s less verbose and, for that reason, less error-prone than
    the `if` statement from other languages.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用过`if`表达式，因此它的一些好处应该是显而易见的：它比其他语言的`if`语句更简洁，因此更不容易出错。
- en: Pattern matching
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配
- en: The concept of `switch`/`case` on steroids. We've already seen how the `when`
    expression can be used, which we explored in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, so let's briefly discuss why this concept is important
    for the functional paradigm.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`/`case`的强化概念。我们已经看到了`when`表达式是如何被使用的，这在[*第一章*](B17816_01_ePub.xhtml#_idTextAnchor015)，“Kotlin入门”中进行了探讨，所以让我们简要讨论一下为什么这个概念对于函数式范式很重要。'
- en: You may know that in Java, `switch` accepts only some primitive types, strings,
    or enums.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，在Java中，`switch`只能接受一些原始类型、字符串或枚举。
- en: 'Consider the following code, which is usually used to demonstrate how polymorphism
    is implemented in the language:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，这通常用来演示语言中如何实现多态性：
- en: '[PRE153]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'If we were to decide which of the functions to call, we would need to write
    code akin to the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要决定调用哪个函数，我们需要编写类似于以下代码：
- en: '[PRE164]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: This code attempts to figure out at runtime what methods the `getSound` class
    implements.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码试图在运行时确定`getSound`类实现了哪些方法。
- en: This method could be shortened by introducing multiple returns, but in real
    projects, multiple returns are usually a bad practice.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以通过引入多个返回值来缩短，但在实际项目中，通常认为多个返回值是不良实践。
- en: Since we don't have a `switch` statement for classes, we need to use an `if`
    statement instead.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为类提供`switch`语句，我们需要用`if`语句来代替。
- en: 'Now, let''s compare the preceding code with the following Kotlin code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将前面的代码与以下Kotlin代码进行比较：
- en: '[PRE177]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Since `when` is an expression, we avoided declaring the intermediate variable
    we previously had altogether. In addition, the code that uses pattern matching
    doesn't need any type checks and casts.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`when`是一个表达式，我们完全避免了之前声明的中间变量。此外，使用模式匹配的代码不需要任何类型检查和转换。
- en: Now we've learned how to replace imperative `if` statements with much more functional
    `when` expressions, let's see how we can replace imperative loops in our code
    by using *recursion*.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何用更函数式的`when`表达式替换命令式的`if`语句，让我们看看我们如何通过使用*递归*来替换代码中的命令式循环。
- en: Recursion
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: '**Recursion** is a function invoking itself with new arguments. Many well-known
    algorithms, such as **Depth First Search**, rely on recursion.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归**是一个函数用新的参数调用自身。许多著名的算法，如**深度优先搜索**，都依赖于递归。'
- en: 'Here is an example of a very inefficient function that uses recursion to calculate
    the sum of all the numbers in a given list:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用递归计算给定列表中所有数字之和的非常低效的函数示例：
- en: '[PRE182]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'We often try to avoid recursion due to the stack overflow errors that we may
    receive if our call stack is too deep. You can call this function with a list
    that contains a million numbers to demonstrate this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常试图避免递归，因为我们可能会收到栈溢出错误，如果我们的调用栈太深的话。你可以用一个包含一百万个数字的列表来调用这个函数，以演示这一点：
- en: '[PRE189]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: However, Kotlin supports an optimization called **tail recursion**. One of the
    great benefits of tail recursion is that it avoids the dreaded stack overflow
    exception. If there is only a single recursive call in our function, we can use
    that optimization.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kotlin 支持一种称为**尾递归**的优化。尾递归的一个巨大好处是它避免了可怕的栈溢出异常。如果我们的函数中只有一个递归调用，我们可以使用这个优化。
- en: 'Let''s rewrite our recursive function using a new keyword, `tailrec`, to avoid
    this problem:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个新的关键字 `tailrec` 重写我们的递归函数，以避免这个问题：
- en: '[PRE192]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Now, the compiler will optimize our call and avoid the exception completely.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器将优化我们的调用并完全避免异常。
- en: However, this optimization doesn't work if you have multiple recursive calls,
    such as in the **Merge Sort** algorithm.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有多个递归调用，这种优化就不起作用了，例如在**归并排序**算法中。
- en: 'Let''s examine the following function, which is the *sort* part of the Merge
    Sort algorithm:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下函数，这是归并排序算法的**排序**部分：
- en: '[PRE200]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Notice that there are two recursive calls instead of one. The Kotlin compiler
    will then issue the following warning:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有两个递归调用而不是一个。Kotlin 编译器随后将发出以下警告：
- en: '[PRE217]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a better understanding of functional programming and its
    benefits, as well as how Kotlin approaches this topic. We've discussed the concepts
    of *immutability* and *pure functions*, and how combining these results in more
    testable code that is easier to maintain.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对函数式编程及其优势以及 Kotlin 如何处理这个主题有更好的理解。我们讨论了**不可变性**和**纯函数**的概念，以及将它们结合起来如何产生更容易测试且更容易维护的代码。
- en: We discussed how Kotlin supports *closures*, which allow a function to access
    the variables of the function that wraps it and effectively store the state between
    executions. This enables techniques such as *currying* and *memoization* that
    allow us to fix some of the function arguments (by acting as defaults) and remember
    the value returned from a function in order to avoid recalculating it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了 Kotlin 如何支持**闭包**，这允许一个函数访问其包装函数的变量，并有效地在执行之间存储状态。这使我们可以使用**柯里化**和**记忆化**等技术，这些技术允许我们固定一些函数参数（通过充当默认值）并记住函数返回的值，以避免重新计算。
- en: We learned that Kotlin uses the `tailrec` keyword to allow the compiler to optimize
    *tail recursion*. We also looked at *higher-order functions*, *expressions versus
    statements*, and *pattern matching*. All of these concepts allow us to write code
    that is easier to test and has less risk of concurrency bugs.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到 Kotlin 使用 `tailrec` 关键字来允许编译器优化**尾递归**。我们还探讨了**高阶函数**、**表达式与语句的区别**以及**模式匹配**。所有这些概念都使我们能够编写更容易测试且并发错误风险更低的代码。
- en: In the next chapter, we'll put this knowledge to practical use and discover
    how **reactive programming** builds upon functional programming to create scalable
    and resilient systems.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将将这些知识应用于实践，并了解**响应式编程**是如何建立在函数式编程之上以创建可扩展和健壮的系统的。
- en: Questions
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are higher-order functions?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是高阶函数？
- en: What is the `tailrec` keyword in Kotlin?
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 中的 `tailrec` 关键字是什么？
- en: What are pure functions?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是纯函数？
