- en: Chapter 6. Playing Sounds and Music
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 播放声音和音乐
- en: We hear sound effects and music in almost every type of media we encounter daily.
    Many notable games such as PAC-MAN, Angry Birds, and Fruit Ninja can be recognized
    just by their theme music or sound effects alone. Aside from the visual imagery
    we see in games, sounds help impact the mood conveyed in the storyline and/or
    during game play. Quality sound effects and music that pertain to the theme of
    your game helps to give your audience a realistic feel to the experience.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在日常接触的几乎所有类型的媒体中都能听到声音效果和音乐。许多著名的游戏，如 PAC-MAN、愤怒的小鸟和水果忍者，仅凭其主题曲或声音效果就可以被识别。除了我们在游戏中看到的外观图像外，声音有助于影响故事情节和/或游戏过程中的氛围。与您的游戏主题相关的优质声音效果和音乐有助于让您的观众感受到真实的体验。
- en: In this chapter, you will learn how to apply sound effects and music that can
    be added to your applications. We have the visual appeal down from creating Breakout
    and Panda Star Catcher in the previous chapters. Now let's enhance the sensory
    experience with our ears!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何应用可以添加到您应用程序中的声音效果和音乐。我们已经在创建 Breakout 和 Panda Star Catcher 的前几章中实现了视觉吸引力。现在让我们通过耳朵来增强感官体验！
- en: 'The main points we''ll be going over are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的主要要点是：
- en: Loading, playing, and looping audio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载、播放和循环音频
- en: Understanding how to play, pause, resume, rewind, and stop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何播放、暂停、继续、倒带和停止
- en: Memory management (disposing audio)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理（释放音频）
- en: Volume control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音量控制
- en: Performance and encoding tips
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和编码技巧
- en: Let's create some more magic!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创造一些奇迹！
- en: Corona Audio System
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冠状音频系统
- en: The Corona Audio System has advanced **OpenAL (Open Audio Library)** features.
    OpenAL is designed for efficient rendering of multichannel three-dimensional positional
    audio. The general functionality of OpenAL is encoded in source objects, audio
    buffers, and a single listener. A source object contains a pointer to a buffer,
    the velocity, position and direction of the sound, and the intensity of the sound.
    Buffers contain audio data in PCM format, either 8 or 16-bit, in either mono or
    stereo format. The listener object contains the velocity, position and direction
    of the listener, and the general gain applied to all sound.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Corona 音频系统具有先进的 **OpenAL (Open Audio Library**) 功能。OpenAL 是为高效渲染多通道三维定位音频而设计的。OpenAL
    的一般功能编码在源对象、音频缓冲区和单个听者中。源对象包含指向缓冲区的指针、声音的速度、位置和方向以及声音的强度。缓冲区包含以 PCM 格式的音频数据，可以是
    8 位或 16 位，可以是单声道或立体声格式。听者对象包含听者的速度、位置和方向以及应用于所有声音的一般增益。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the Corona Audio System you can go to: [http://developer.anscamobile.com/partner/audionotes](http://developer.anscamobile.com/partner/audionotes).
    General information on OpenAL can be found at: [http://www.openal.com.](http://www.openal.com).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关 Corona 音频系统的更多信息，请访问：[http://developer.anscamobile.com/partner/audionotes](http://developer.anscamobile.com/partner/audionotes)。有关
    OpenAL 的一般信息可在：[http://www.openal.com.](http://www.openal.com) 找到。
- en: Sound formats
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音格式
- en: 'The following are sound formats that are compatible with iOS and Android platforms:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与 iOS 和 Android 平台兼容的声音格式：
- en: All platforms support 16-bit, little endian, linear, `.wav` files
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有平台都支持 16 位、小端、线性、`.wav` 文件
- en: The iOS and Mac simulator support `.mp3, .caf`, and `.aac`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 和 Mac 模拟器支持 `.mp3, .caf` 和 `.aac`
- en: The Windows simulator supports `.mp3` and `.wav`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 模拟器支持 `.mp3` 和 `.wav`
- en: Android supports `.mp3` and `.ogg` formats
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 支持 `.mp3` 和 `.ogg` 格式
- en: Sound filename limitations on Android
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 上声音文件名的限制
- en: 'File extensions are ignored when building in Android, so files are considered
    the same regardless of extension. The workaround for the mean time is to change
    the filenames to differentiate file extensions. See the following examples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中构建时，文件扩展名会被忽略，因此无论扩展名如何，文件都被视为相同。暂时解决方法是更改文件名以区分文件扩展名。以下是一些示例：
- en: '`tap_aac.aac`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_aac.aac`'
- en: '`tap_aif.aif`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_aif.aif`'
- en: '`tap_caf.caf`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_caf.caf`'
- en: '`tap_mp3.mp3`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_mp3.mp3`'
- en: '`tap_ogg.ogg`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap_ogg.ogg`'
- en: Mono sounds at their best
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单声道声音的最佳效果
- en: Using mono sounds take half the amount of memory than stereo sounds. Since the
    Corona Audio System uses OpenAL, it will only apply spatialized/3D effects to
    mono sounds. OpenAL does not apply 3D effects to stereo samples.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单声道声音比立体声音耗内存少一半。由于 Corona 音频系统使用 OpenAL，它只会将空间化/3D 效果应用于单声道声音。OpenAL 不会将
    3D 效果应用于立体声样本。
- en: Maximum number of simultaneous channels
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大同时通道数
- en: 'The maximum number of channels that can be run is 32\. This allows up to 32
    distinct sounds to be played simultaneously. The API to see the resulting number
    of channels in your code is:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以运行的最大通道数是 32。这允许同时播放多达 32 个不同的声音。在您的代码中查看结果通道数的 API 是：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Time to play
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放时间
- en: 'Audio can be loaded in two different ways as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 音频可以以两种不同的方式加载，如下所示：
- en: '`loadSound()` preloads an entire sound into memory'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadSound()` 预加载整个声音到内存'
- en: '`loadStream()` prepares the sound to be played by reading small chunks at a
    time to save memory'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadStream()` 通过分批读取小部分数据来准备播放声音，以节省内存'
- en: audio.loadSound()
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.loadSound()
- en: Loads an entire file completely into memory and returns a reference to the audio
    data. Files that are loaded completely into memory can be reused, played, and
    shared simultaneously on multiple channels so you only need to load one instance
    of the file. Sounds that you would use as sound effects in your game would fit
    in this category.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完全将整个文件加载到内存中，并返回音频数据的引用。完全加载到内存中的文件可以被重用、播放和共享，可以在多个通道上同时使用，因此您只需要加载文件的一个实例。您在游戏中用作音效的声音适合这一类别。
- en: 'Syntax:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Parameters:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`audiofileName` - Specifies the name of the audio file you want to load. Supported
    file formats are determined by the platform you are running the audio file on.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audiofileName` - 指定要加载的音频文件名称。支持的文件格式取决于您在哪个平台上运行音频文件。'
- en: '`baseDir` - By default, sound files are expected to be in the application resources
    directory. If the sound file is in the application documents directory, use `system.DocumentsDirectory`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseDir` - 默认情况下，预期声音文件位于应用程序资源目录中。如果声音文件位于应用程序文档目录中，请使用 `system.DocumentsDirectory`。'
- en: 'Example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '`tapSound = audio.loadSound("tap.wav")`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tapSound = audio.loadSound("tap.wav")`'
- en: '`smokeSound = audio.loadSound("smoke.mp3")`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smokeSound = audio.loadSound("smoke.mp3")`'
- en: audio.loadStream()
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.loadStream()
- en: This loads a file to be read as a stream. Streamed files are read in small chunks
    at a time to minimize memory use. Files that are large in size and have a long
    duration are intended for this. These files cannot be shared simultaneously across
    multiple channels. If need be, you must load multiple instances of the file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载一个文件作为流来读取。流式文件将分批读取小部分数据，以最小化内存使用。大型且持续时间长的文件适用于此。这些文件不能在多个通道上同时共享。如果需要，您必须加载文件的多实例。
- en: 'Syntax:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Parameters:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`audiofileName` - Specifies the name of the audio file you want to load. Supported
    file formats are determined by the platform you are running the audio file on.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audiofileName` - 指定要加载的音频文件名称。支持的文件格式取决于您在哪个平台上运行音频文件。'
- en: '`baseDir` - By default, sound files are expected to be in the application resources
    directory. If the sound file is in the application documents directory, use `system.DocumentsDirectory`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseDir` - 默认情况下，预期声音文件位于应用程序资源目录中。如果声音文件位于应用程序文档目录中，请使用 `system.DocumentsDirectory`。'
- en: 'Example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '`music1 = audio.loadStream("song1.mp3")`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`music1 = audio.loadStream("song1.mp3")`'
- en: '`music2 = audio.loadStream("song2.wav")`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`music2 = audio.loadStream("song2.wav")`'
- en: audio.play()
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.play()
- en: Plays the audio specified by the audio handle on a channel. If a channel is
    not specified, an available channel will be automatically chosen for you.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定通道上播放由音频句柄指定的音频。如果没有指定通道，系统将自动为您选择一个可用通道。
- en: 'Syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Parameters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`audioHandle` - This is the audio data you want to play.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audioHandle` - 这是您想要播放的音频数据。'
- en: '`channel` - The channel number you want to play on. Channel number 1 to the
    maximun number of channels, which is 32, are valid channels. Specify 0 or omit
    this parameter to have a channel automatically picked for you.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 您想要播放的通道号。通道号从 1 到最大通道数（32），都是有效的通道。指定 0 或省略此参数，系统将自动为您选择一个通道。'
- en: '`loops` - The number of times you want the audio to loop. 0 means the audio
    will loop 0 times which means that the sound will play once and not loop. Passing
    -1 will tell the system to infinitely loop the sample.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loops` - 您想要音频循环的次数。0 表示音频将循环 0 次，这意味着声音将播放一次而不循环。传递 -1 将告诉系统无限循环样本。'
- en: '`duration` - In milliseconds, this will cause the system to play the audio
    for the specified amount of time.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration` - 以毫秒为单位，这将导致系统播放指定时间的音频。'
- en: '`fadein` - In milliseconds, this will start playing a sound at the minimum
    channel volume and transition to the normal channel volume over the specified
    number of milliseconds.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadein` - 以毫秒为单位，这将从最小通道音量开始播放声音，并在指定的毫秒数内过渡到正常通道音量。'
- en: '`onComplete` - A callback function you want to be called when playback ends.
    The `onComplete` callback function passes back an event parameter.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete` - 当播放结束时想要调用的回调函数。`onComplete` 回调函数传递回一个事件参数。'
- en: 'Example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Looping
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: Highly compressed formats like mp3, aac, ogg vorbis, can remove samples at the
    end of an audio sample and possibly break a clip that is looped correctly. If
    you experience gaps in looping playback, try using WAV (compatible with iOS and
    Android) and make sure your lead-in and ending points are clean.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 高度压缩的格式，如 mp3、aac、ogg vorbis，可能会在音频样本的末尾删除样本，并可能破坏正确循环的剪辑。如果你在循环播放中遇到间隙，请尝试使用
    WAV（兼容 iOS 和 Android），并确保你的起始点和结束点是干净的。
- en: Simultaneous playback
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时播放
- en: 'Sounds loaded via `loadSound()` can be played back simultaneously on multiple
    channels. For example, you can load a sound effect like so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `loadSound()` 加载的音频可以在多个通道上同时回放。例如，你可以这样加载一个声音效果：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you want to make a variety of bell sounds occur for multiple objects, you
    can. The audio engine is highly optimized to handle this case. Call `audio.play()`
    using that same handle as many times as you need it (up to the maximum number
    of channels).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为多个对象制作各种铃声，你可以做到。音频引擎高度优化以处理这种情况。使用相同的句柄多次调用 `audio.play()`（最多可达通道数上限）。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Time for action—playing audio
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——播放音频
- en: 'We''re going to listen to how sound effects and music are implemented in Corona
    to get an idea of how it really works:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将倾听在 Corona 中如何实现声音效果和音乐，以了解它实际上是如何工作的：
- en: Create a new project folder on your desktop called `Playing Audio`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的桌面创建一个名为 `Playing Audio` 的新项目文件夹。
- en: In the `Chapter 6 Resources` folder, copy the `ring.wav` and `song1.mp3` sound
    files into your project folder and create a new `main.lua` file. You can download
    the project files accompanying this book from the Packt website.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter 6 Resources` 文件夹中，将 `ring.wav` 和 `song1.mp3` 音频文件复制到你的项目文件夹中，并创建一个新的
    `main.lua` 文件。你可以从 Packt 网站下载本书的配套项目文件。
- en: Preload the following audio with `loadSound()` and `loadStream():`
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `loadSound()` 和 `loadStream()` 预加载以下音频：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Play `backgroundSound` by setting it to channel 1, loop it infinitely, and
    fade in after for 3 seconds:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `backgroundSound` 设置为通道 1，无限循环，并在 3 秒后淡入来播放 `backgroundSound`：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add in `ringSound` and have it played once:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ringSound` 并播放一次：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save and run the project in the Corona simulator to hear the results.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Corona 模拟器中保存并运行项目以听取结果。
- en: What Just Happened?
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: For audio that is merely a short sound effect, we used `audio.loadSound()` to
    prepare the sound. For audio that is large in size or long in duration, `audio.loadStream()`
    is used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅仅是短声音效果的音频，我们使用了 `audio.loadSound()` 来准备声音。对于大尺寸或长时间段的音频，使用 `audio.loadStream()`。
- en: The `backgroundSound` file is set to channel 1 and fades in at 3 seconds when
    it starts playing. `loops = -1` means that the file loops infinitely from beginning
    to end.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`backgroundSound` 文件设置为通道 1，在开始播放时淡入 3 秒。`loops = -1` 表示文件从头到尾无限循环。'
- en: Have a go hero—repeating audio with delay
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试——带延迟重复音频
- en: As you can see, loading and playing audio is really simple. It only takes 2
    lines of code to play a simple sound. Let's see if you can take it up a notch.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，加载和播放音频非常简单。播放一个简单的声音只需要 2 行代码。让我们看看你能否提高一个档次。
- en: Use the `ring.wav` file and load it through `loadSound()`. Create a function
    that plays the audio. Play the sound five times at an interval of 2 seconds.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ring.wav` 文件并通过 `loadSound()` 加载它。创建一个播放音频的函数。每隔 2 秒播放声音五次。
- en: Time to take control
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制时间
- en: We have the ability to control our sounds now that we can have them play in
    the simulator. If you think back to the days of cassette tape players, they had
    the ability to use functions such as pause, stop, and rewind. Corona's audio API
    library can do just that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以控制我们的声音了，因为它们可以在模拟器中播放。如果你回想起磁带播放机的日子，它们有使用暂停、停止和倒带等功能的能力。Corona 的音频 API
    库可以做到这一点。
- en: audio.stop()
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.stop()
- en: Stops playback on a channel and clears the channel so it can be played again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在通道上停止播放并清除通道，以便可以再次播放。
- en: 'Syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'or:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Parameters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: Having no parameters stops all active channels.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有参数将停止所有活动通道。
- en: '`channel` - The channel to stop. Specifying 0 stops all channels.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 要停止的通道。指定 0 停止所有通道。'
- en: audio.pause()
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.pause()
- en: This pauses playback on a channel and has no effect on channels that aren't
    playing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在通道上暂停播放，对未播放的通道没有影响。
- en: 'Syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'or:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Parameters:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: Having no parameters pauses all active channels.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有参数将暂停所有活动通道。
- en: '`channel` - The channel to pause. Specifying 0 pauses all channels.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 要暂停的通道。指定 0 暂停所有通道。'
- en: audio.resume()
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.resume()
- en: This resumes playback on a channel that is paused. It has no effect on channels
    that aren't paused.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在暂停的通道上恢复播放。对未暂停的通道没有影响。
- en: 'Syntax:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'or:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Parameters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: Having no parameters resumes all paused channels.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有参数将恢复所有暂停的通道。
- en: '`channel` - The channel to resume. Specifying 0 resumes all channels.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 要恢复的通道。指定 0 恢复所有通道。'
- en: audio.rewind()
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.rewind()
- en: This rewinds audio to the beginning position on either an active channel or
    directly on the audio handle.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将音频回退到活动通道或音频句柄的起始位置。
- en: 'Syntax:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Parameters:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`audioHandle` - The audio handle of the data you want to rewind. Best for audio
    loaded with `audio.loadStream()`. Don''t try using this with the channel parameter
    in the same call.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audioHandle` - 你想要回退的数据的音频句柄。最适合使用 `audio.loadStream()` 加载的音频。不要在同一调用中尝试与通道参数一起使用此参数。'
- en: '`channel` - The channel you want the rewind operation to apply to. Best for
    audio loaded with `audio.loadSound()`. Don''t try using this with the `audioHandle`
    parameter in the same call.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 要应用回退操作的通道。最适合使用 `audio.loadSound()` 加载的音频。不要在同一调用中与 `audioHandle`
    参数一起使用此参数。'
- en: Time for action—controlling audio
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间——控制音频
- en: 'Let''s simulate our own little music player by creating user interface buttons
    that will control the audio calls:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建控制音频调用的用户界面按钮来模拟我们自己的小型音乐播放器：
- en: In the `Chapter 6` folder, copy the `Controlling Audio` project folder to your
    desktop. You will notice several art assets, a `ui.lua` library and a `song2.mp3`
    file inside. You can download the project files accompanying this book from the
    Packt website:![Time for action—controlling audio](img/1888_06_01.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `第 6 章` 文件夹中，将 `Controlling Audio` 项目文件夹复制到你的桌面。你将注意到其中包含几个艺术资产、一个 `ui.lua`
    库和一个 `song2.mp3` 文件。你可以从 Packt 网站下载本书的配套项目文件：![操作时间——控制音频](img/1888_06_01.jpg)
- en: In the same project folder, create a brand new `main.lua` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个项目文件夹中，创建一个全新的 `main.lua` 文件。
- en: Load the audio file via `loadStream()`, name it `backgroundSound`, and call
    the UI library. Also add in a local variable called `myMusic:`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `loadStream()` 加载音频文件，命名为 `backgroundSound`，并调用 UI 库。还添加一个名为 `myMusic:` 的局部变量：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a local function called `onPlayTouch()` with an event parameter to play
    the audio file. Add an `if` statement that contains `event.phase == "release"`,
    so that the music starts playing upon button release. Apply the `playBtn` display
    object as a new UI button:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `onPlayTouch()` 的局部函数，并带有事件参数以播放音频文件。添加一个包含 `event.phase == "release"`
    的 `if` 语句，以便在按钮释放时开始播放音乐。将 `playBtn` 显示对象应用为新 UI 按钮：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a local function called `onPauseTouch()` with an event parameter to
    pause the audio file. Add an `if` statement when `event.phase == "release"`, so
    that the music pauses. Apply the `pauseBtn` display object as a new UI button:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `onPauseTouch()` 的局部函数，并带有事件参数以暂停音频文件。当 `event.phase == "release"` 时添加一个
    `if` 语句，以便音乐暂停。将 `pauseBtn` 显示对象应用为新 UI 按钮：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a local function called `onResumeTouch()` with an event parameter to resume
    the audio file. Add an `if` statement when `event.phase == "release"`, so that
    the music resumes. Apply the `resumeBtn` display object as a new UI button:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `onResumeTouch()` 的局部函数，并带有事件参数以恢复音频文件。当 `event.phase == "release"` 时添加一个
    `if` 语句，以便音乐恢复播放。将 `resumeBtn` 显示对象应用为新 UI 按钮：
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a local function called `onStopTouch()` with an event parameter to stop
    the audio file. Create an `if` statement when `event.phase == "release"`, so that
    the music stops. Apply the `stopBtn` display object as a new UI button:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `onStopTouch()` 的局部函数，并带有事件参数以停止音频文件。当 `event.phase == "release"` 时创建一个
    `if` 语句，以便音乐停止。将 `stopBtn` 显示对象应用为新 UI 按钮：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a local function called `onRewindTouch()` with an `event` parameter to
    rewind the audio file. Create an `if` statement when `event.phase == "release"`,
    that the music rewinds to the beginning of the track. Apply the `rewindBtn` display
    object as a new UI button:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `onRewindTouch()` 的局部函数，并带有 `event` 参数以回退音频文件。当 `event.phase == "release"`
    时创建一个 `if` 语句，以便音乐回退到曲目开头。将 `rewindBtn` 显示对象应用为新 UI 按钮：
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save your project and run it in the simulator. You now have created a functional
    media player!![Time for action—controlling audio](img/1888_06_02.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目并在模拟器中运行它。你现在已经创建了一个功能齐全的媒体播放器！！[操作时间——控制音频](img/1888_06_02.jpg)
- en: What Just Happened?
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We added a UI library for our user interface buttons by calling `require("ui")`.
    This produces the "on press" look when a button has been pushed down on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`require("ui")`为用户界面按钮添加了一个UI库。当按钮被按下时，它会产生“按下”的外观。
- en: 'A variety of functions were created to run each button:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了各种函数来运行每个按钮：
- en: '`onPlayTouch()` calls out `myMusic = audio.play(backgroundSound, {channel=1,
    loops=-1})` when the event is triggered by the user pressing the button'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户按下按钮触发事件时，`onPlayTouch()`调用`myMusic = audio.play(backgroundSound, {channel=1,
    loops=-1})`
- en: '`onPauseTouch()` calls out `myMusic = audio.pause(backgroundSound)` to pause
    the song when the button is pressed'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPauseTouch()`调用`myMusic = audio.pause(backgroundSound)`以在按钮按下时暂停歌曲'
- en: '`onResumeTouch()` calls out `myMusic = audio.resume(backgroundSound)` to resume
    the song if it has been paused'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResumeTouch()`调用`myMusic = audio.resume(backgroundSound)`以恢复已暂停的歌曲'
- en: '`onStopTouch()` calls out `myMusic = audio.stop(backgroundSound)` if the song
    is currently playing and will stop the audio'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果歌曲正在播放，`onStopTouch()`将调用`myMusic = audio.stop(backgroundSound)`并停止音频
- en: '`onRewindTouch()` calls out `myMusic = audio.rewind(backgroundSound)` to rewind
    the song to the beginning of the track'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRewindTouch()`调用`myMusic = audio.rewind(backgroundSound)`将歌曲倒回轨道开头'
- en: Note
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：
- en: When a song is paused, it resumes only by pressing the **Resume** button. The
    **Play** button will have no effect when the **Pause** button is pressed.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当歌曲暂停时，只有通过按下**恢复**按钮才能继续播放。当按下**暂停**按钮时，**播放**按钮将没有任何效果。
- en: Memory management
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: It is important to call `audio.dispose()` on your loaded audio when you are
    completely done with the audio file. Doing so allows you to recover the memory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完全完成音频文件时，重要的一步是调用`audio.dispose()`。这样做可以回收内存。
- en: audio.dispose()
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audio.dispose()
- en: Releases audio memory associated with the handle.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 释放与句柄关联的音频内存。
- en: 'Syntax:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Parameters:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`audioHandle` - The handle returned by the `audio.loadSound()` or `audio.loadStream()`
    functions that you want to free.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`audioHandle` - 由`audio.loadSound()`或`audio.loadStream()`函数返回的您想要释放的句柄。'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You must not use the handle once the memory is freed. The audio should not be
    playing or paused on any channel when you try to free it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 内存释放后，您不得再使用句柄。当您尝试释放它时，音频不应在任何通道上播放或暂停。
- en: 'Example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Have a go hero—disposing audio
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——销毁音频
- en: 'You have just learned how to dispose audio files properly to recover memory
    in your application. Try the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何正确处理音频文件以回收应用程序中的内存。尝试以下操作：
- en: Load your audio file and have it played over a set duration. Create a function
    that will dispose of the file when calling an `onComplete` command.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载您的音频文件，并在设定的时间内播放。创建一个函数，当调用`onComplete`命令时，将销毁文件。
- en: In the `Controlling Audio` project file, dispose of the audio in the `onStopTouch()`
    function.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Controlling Audio`项目文件中，在`onStopTouch()`函数中处理音频。
- en: Alterations to audio
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频更改
- en: The audio system also has the ability to alter the minimum and maximum states
    of audio volume as well as audio fades when needed in your application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 音频系统还具有在您的应用程序中需要时更改音频音量最小和最大状态以及音频淡入淡出的能力。
- en: Volume control
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音量控制
- en: The volume of audio can be set with values ranging from 0 to 1.0\. This setting
    can be adjusted at any time before or during the extended sound playback.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 音频音量可以用0到1.0的值设置。此设置可以在扩展声音播放之前或期间进行调整。
- en: audio.setVolume()
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.setVolume()
- en: 'Syntax:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Parameters:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`volume` - The new volume level you want to apply. Valid numbers range from
    0.0 to 1.0, where 1.0 is the maximum volume value. Default volume is based on
    your device ringer volume and will vary.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume` - 您想要应用的新音量级别。有效数字范围从0.0到1.0，其中1.0是最大音量值。默认音量基于您的设备铃声音量，可能会有所不同。'
- en: '`channel` - The channel number you want to set the volume on. Channel number
    1 to the maximum number of channels. Specify 0 to apply the volume to all the
    channels. Omitting this parameter entirely sets the master volume, which is different
    than the channel volume.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 您想要设置音量的通道号。通道号从1到最大通道数。指定0将音量应用于所有通道。完全省略此参数将设置主音量，这与通道音量不同。'
- en: 'Example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '`audio.setVolume(0.75) -- set master volume`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audio.setVolume(0.75) -- 设置主音量`'
- en: '`audio.setVolume(0.5, {channel=2}) -- set volume on channel 2`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audio.setVolume(0.5, {channel=2}) -- 在通道2上设置音量`'
- en: audio.setMinVolume()
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.setMinVolume()
- en: Clamps the minimum volume to the set value. Any volumes that go below the minimum
    volume will be played at the minimum volume level.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将最小音量限制在设置值。任何低于最小音量的音量将以最小音量级别播放。
- en: 'Syntax:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Parameters:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`volume` - The new minimum volume level you want to apply. Valid numbers range
    from 0.0 to 1.0, where 1.0 is the maximum volume value.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume` - 你想要应用的新最小音量级别。有效数字范围从0.0到1.0，其中1.0是最大音量值。'
- en: '`channel` - The channel number you want to set the minimum volume on. Channel
    number 1 to the minimum number of channels are valid channels. Specify 0 to apply
    the minimum volume to all the channels.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 你想要设置最小音量的通道号。通道号1到最小通道数都是有效的通道。指定0将应用最小音量到所有通道。'
- en: 'Example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: audio.setMaxVolume()
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.setMaxVolume()
- en: Clamps the maximum volume to the set value. Any volumes that exceed the maximum
    volume will be played at the maximum volume level.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将最大音量限制在设置值。任何超过最大音量的音量将以最大音量级别播放。
- en: 'Syntax:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Parameters:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`volume` - The new maximum volume level you want to apply. Valid numbers range
    from 0.0 to 1.0, where 1.0 is the maximum value.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume` - 你想要应用的新最大音量级别。有效数字范围从0.0到1.0，其中1.0是最大值。'
- en: '`channel` - The channel number you want to set the maximum volume on. 1 to
    the maximum number of channels are valid channels. Specify 0 to apply the maximum
    volume to all the channels.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 你想要设置最大音量的通道号。1到最大通道数都是有效的通道。指定0将应用最大音量到所有通道。'
- en: 'Example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: audio.getVolume()
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.getVolume()
- en: This gets the volume either for a specific channel or gets the master volume.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取特定通道的音量或获取主音量。
- en: 'Syntax:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Parameters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`channel` - The channel number you want to get the volume on. There can be
    a maximum number of 32 channels that are valid. Specifying 0 will return the average
    volume across all channels. Omitting this parameter entirely gets the master volume,
    which is different than the channel volume.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel` - 你想要获取音量的通道号。最多可以有32个有效的通道。指定0将返回所有通道的平均音量。完全省略此参数将获取主音量，这与通道音量不同。'
- en: 'Example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '`masterVolume = audio.getVolume() -- get the master volume`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`masterVolume = audio.getVolume() -- 获取主音量`'
- en: '`channel1Volume = audio.getVolume({channel=1}) -- get the volume on channel
    1`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel1Volume = audio.getVolume({channel=1}) -- 获取1通道的音量`'
- en: audio.getMinVolume()
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.getMinVolume()
- en: This gets the minimum volume for a specific channel.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取特定通道的最小音量。
- en: 'Syntax:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Parameters:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`channel` - The channel number you want to get the minimum volume on. There
    can be a maximum number of 32 channels that are valid. Specifying 0 will return
    the average minimum volume across all channels.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel` - 你想要获取最小音量的通道号。最多可以有32个有效的通道。指定0将返回所有通道的平均最小音量。'
- en: 'Example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: audio.getMaxVolume()
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.getMaxVolume()
- en: This gets the maximum volume for a specific channel.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取特定通道的最大音量。
- en: 'Syntax:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Parameters:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`channel` - The channel number you want to get the maximum volume on. There
    can be a maximum number of 32 channels that are valid. Specifying 0 will return
    the average volume across all channels.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`channel` - 你想要获取最大音量的通道号。最多可以有32个有效的通道。指定0将返回所有通道的平均音量。'
- en: 'Example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Fading audio
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 淡入音频
- en: You can fade in volume at the time any audio starts playing, but there are other
    ways to control it as well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何音频开始播放时淡入音量，但还有其他控制它的方法。
- en: audio.fade()
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.fade()
- en: This fades a playing sound in a specified amount to a specified volume. The
    audio will continue playing after the fade completes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在指定的量将播放的声音淡入到指定的音量。淡入完成后，音频将继续播放。
- en: 'Syntax:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Parameters:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`channel` - The channel number you want to fade on. 1 to the maximum number
    of channels are valid channels. Specify 0 to apply fade to all the channels.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 你想要淡入的通道号。1到最大通道数都是有效的通道。指定0将应用淡入到所有通道。'
- en: '`time` - The amount of time from now that you want the audio to fade over and
    stop. Omitting this parameter invokes a default fade time, which is 1000 milliseconds.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time` - 你想要音频淡入并停止的时间。省略此参数将调用默认的淡入时间，为1000毫秒。'
- en: '`volume` - The target volume you want to change the fade to. Valid numbers
    are 0.0 to 1.0 where 1.0 is the maximum volume. If this parameter is omitted,
    the default value is 0.0.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume` - 你想要更改淡入的音量目标。有效数字是0.0到1.0，其中1.0是最大音量。如果省略此参数，默认值是0.0。'
- en: 'Example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: audio.fadeOut()
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: audio.fadeOut()
- en: This stops playing sound in a specified amount of time and fades to the minimum
    volume. The audio will stop at the end of the time and the channel will be freed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在指定的时间内停止播放声音并淡至最小音量。音频将在时间结束时停止，并且通道将被释放。
- en: 'Syntax:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Parameters:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`channel` - The channel number you want to fade out on. 1 to the maximum number
    of channels are valid channels. Specify 0 to apply `fadeOut` to all the channels.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel` - 你想要淡出的通道号。1到最大通道数都是有效的通道。指定0将`fadeOut`应用于所有通道。'
- en: '`time` - The amount of time from now that you want the audio to fade out over
    and stop. Omitting this parameter invokes a default fade out time, which is 1000
    milliseconds.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time` - 从现在开始，你希望音频淡出并停止的时间量。省略此参数将调用默认的淡出时间，为1000毫秒。'
- en: 'Example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Performance tips
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能技巧
- en: The following are some helpful notes when creating good quality audio for your
    games.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在为你的游戏创建高质量音频时，以下是一些有用的提示。
- en: Pre-loading phase
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载阶段
- en: It is best to pre-load all your files at the startup of your application. While
    `loadStream()` is generally fast, `loadSound()` may take awhile since it must
    load and decode the entire file the instant it needs to be used. Generally, you
    don't want to be calling `loadSound()` in the parts of your app where users expect
    it to be running smoothly when events occur, such as during gameplay.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序启动时最好预加载所有文件。虽然`loadStream()`通常很快，但`loadSound()`可能需要一段时间，因为它必须立即加载和解码整个文件。通常，你不想在用户期望事件发生时调用`loadSound()`的部分，例如在游戏过程中。
- en: audioPlayFrequency
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: audioPlayFrequency
- en: In your `config.lua` file, you may specify a field called `audioPlayFrequency`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`config.lua`文件中，你可以指定一个名为`audioPlayFrequency`的字段。
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This tells the OpenAL system what sample rate to mix and playback at. For best
    results, set this no higher than you actually need. So if you never need better
    than 22050 Hz playback, set this to 22050\. It produces quality speech recordings
    or middle-quality recordings of music. If you really do need high quality, then
    set this to 44100 to produce audio CD quality at playback.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉OpenAL系统在混音和回放时使用什么采样率。为了获得最佳效果，请将其设置为您实际需要的最高值。所以如果您不需要超过22050 Hz的回放，请将其设置为22050。它产生高质量的语音录音或中等质量的音乐录音。如果您确实需要高质量，请将其设置为44100以在回放时产生音频CD质量。
- en: It is best to have all your audio files encoded at the same frequency when you
    have this set. Supported values are 11025, 22050, and 44100.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置此选项时，最好将所有音频文件编码在同一频率下。支持的值有11025、22050和44100。
- en: Patents and royalties
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专利和版税
- en: 'For highly compressed formats, such as MP3 and AAC, AAC is the better option.
    AAC is the official successor to MP3 by the MPEG group. MP3 has patent and royalty
    issues you may need to concern yourself with if you distribute anything yourself.
    You may need to consult your lawyers for guidance. When AAC was ratified, it was
    agreed there would be no royalties required for distribution. If you prefer to
    use AAC over MP3, here''s a tutorial on how to convert MP3s to AAC or any file
    format of your preference on the Apple website: [http://support.apple.com/kb/ht1550](http://support.apple.com/kb/ht1550).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高度压缩的格式，如MP3和AAC，AAC是更好的选择。AAC是MPEG小组对MP3的官方继任者。MP3有专利和版税问题，如果你分发任何内容，你可能需要关注这些问题。你可能需要咨询你的律师以获得指导。当AAC被批准时，达成协议，分发时不需要版税。如果你更喜欢使用AAC而不是MP3，苹果网站上有一篇关于如何将MP3转换为AAC或任何你偏好的文件格式的教程：[http://support.apple.com/kb/ht1550](http://support.apple.com/kb/ht1550)。
- en: '**Ogg Vorbis** is a royalty free and patent free format. However, this is not
    supported on iOS devices.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ogg Vorbis** 是一种无版税和无专利的格式。然而，此格式在iOS设备上不受支持。'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information on audio formats can be found at: [http://www.nch.com.au/acm/formats.html](http://www.nch.com.au/acm/formats.html).
    Ray Wenderlich, a mobile developer also has a tutorial available based on file
    and data formats for audio at: [http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats](http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于音频格式的信息可以在：[http://www.nch.com.au/acm/formats.html](http://www.nch.com.au/acm/formats.html)。移动开发者Ray
    Wenderlich也提供了一篇基于音频文件和数据格式的教程：[http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats](http://www.raywenderlich.com/204/audio-101-for-iphone-developers-file-and-data-formats)。
- en: Pop quiz—all about audio
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频知识小测验
- en: What is the proper way to clear audio files from memory?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除音频文件从内存中的正确方法是什么？
- en: a. `audio.pause()`
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. `audio.pause()`
- en: b. `audio.stop()`
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. `audio.stop()`
- en: c. `audio.dispose()`
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. `audio.dispose()`
- en: d. `audio.fadeOut()`
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. `audio.fadeOut()`
- en: How many channels of audio can be played simultaneously in an application?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中可以同时播放多少个音频通道？
- en: a. 10
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. 10
- en: b. 18
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. 18
- en: c. 25
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. 25
- en: d. 32
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 32
- en: How do you make your audio file loop infinitely?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使你的音频文件无限循环？
- en: a. loops = -1
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a. loops = -1
- en: b. loops = 0
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b. loops = 0
- en: c. loops = 1
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: c. loops = 1
- en: d. None of the above
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d. 以上皆非
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We're now caught up on understanding the important aspects of using audio files
    in the Corona SDK. Now you can go off and add your own sound effects and music
    to your games or even add them to any of the samples we have made in the previous
    chapters. In doing so, you add another layer to the user experience that will
    draw players into the environment you created.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在Corona SDK中使用音频文件的重要方面。现在你可以去添加自己的音效和音乐到你的游戏中，甚至可以将它们添加到我们在前几章中制作的任何示例中。这样做，你为用户体验添加了另一层，这将吸引玩家进入你创建的环境。
- en: 'Up until now, you have learned how to:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何：
- en: Pre-load and play sound effects and music using `loadSound()` and `loadStream()`
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`loadSound()`和`loadStream()`预加载并播放音效和音乐
- en: Control audio functions that pause, resume, stop, and rewind a music track under
    the Audio System API
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在音频系统API下控制暂停、恢复、停止和倒退音乐轨道的音频功能
- en: Dispose audio from memory when it is no longer in use
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当音频不再使用时，从内存中释放音频
- en: Adjust the volume in your audio files
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整音频文件中的音量
- en: In the next chapter, we will be combining everything we have learned thus far
    into creating our final game in this book. We'll also be going over other ways
    to implement physical objects and collision mechanics that are popular in mobile
    games in the market to date. More exciting information to learn awaits us. Let's
    power through!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把迄今为止所学的一切结合起来，创建本书中的最终游戏。我们还将介绍其他实现物理对象和碰撞机制的方法，这些方法在目前市场上的移动游戏中很受欢迎。更多激动人心的信息等待我们去学习。让我们全力以赴吧！
