- en: Chapter 9. Threading Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a look at the basics of using threads within
    an iOS application and the pitfalls that may confront you if you use them. In
    this chapter, I'll be carrying it on and we'll have a look at the other aspects
    of threading as well as asynchronous calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using background threading and `System.Threading.Tasks` within your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems that using tasks may have on the threading model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threading moved on from its humble beginnings when developers discovered its
    power, and with that created background threading and task threading. Background
    threads are just that—you set something running in the background and look in
    on it sometimes, or when it's finished it will report back to you. On the college
    analogy I used in the previous chapter, the background threads are the admin staff—they're
    there in the background working away and report when they are done.
  prefs: []
  type: TYPE_NORMAL
- en: Threading tasks need to be thought of as almost miniature applications in themselves.
    They start, end, and can continue with the next task on the list—all this time,
    the app is free to be working on other tasks. There is an overhead to be considered
    with any threading operation, but unless you're doing something insanely complex,
    it's not going to be horrible.
  prefs: []
  type: TYPE_NORMAL
- en: Using background threading within your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Background threading comes from the `System.ComponentModel` namespace and is
    known as a `BackgroundWorker` thread. Alternatively, `ThreadPool.QueueUserWorkItem()`
    does the same thing (as `ThreadPool` is from `System.Threading`).
  prefs: []
  type: TYPE_NORMAL
- en: BackgroundWorker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BackgroundWorker` thread is recommended when you don't want to tie up the
    UI, so creating large files or sending a large amount of data to a server can
    be considered to be used with `BackgroundWorker`. When the thread is complete,
    the `WorkerCompleted` event is raised. During the operation of `BackgroundWorker`,
    the UI can be updated with the `ProgressChanged` event. A background lasts for
    a finite amount of time. It is important to remember that `BackgroundWorker` is
    an asynchronous task.
  prefs: []
  type: TYPE_NORMAL
- en: When you use a `BackgroundWorker` thread, you need to write a code using three
    events (`ProgressChanged` can be omitted if you don't want to use it).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates using `BackgroundWorker` within an app. It's
    simple enough; it puts a counter on the screen, which will carry on counting while
    it downloads a picture that is then displayed when the `RunWorkerCompleted` event
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is simple enough to follow, it creates the `BackgroundWorker`
    object and it also creates the handles and a click event for the button. Inside
    the button, it sets up a timer to update the counter every second and start `BackgroundWorker`.
    When `BackgroundWorker` `DoWork` thread is completed, the image is displayed and
    scaled. The result of the preceding code is shown in the form of the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![BackgroundWorker](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Remember though, this is a background task—the UI can't act on the data until
    the data is ready. When you run the application, the counter value will differ
    as well, depending on if you're on a wireless network or outside, using 3G or
    4G.
  prefs: []
  type: TYPE_NORMAL
- en: ThreadPool.QueueUserWorkItem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having seen how the background worker operates, let us consider using `ThreadPool.QueueUserWorkItem`
    for the same task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **callback** is a piece of code passed as an argument, which needs to be
    executed at some point in time. In threading terms, it is typically executed within
    the thread being called or created. The callback tells the thread when it has
    called the thread back to the main thread. The end result is the same, but the
    `QueueUserWorkItem` method can be used for both foreground and background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Using System.Threading.Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks` namespace sets up tasks within a thread, so a thread
    can perform a type of mini program and then report back. It can also be used to
    start a task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The call starts a new thread task that calls `GetMessage`. Once that has returned,
    the task continues with `ShowResults`. The scheduler prevents the timing from
    getting out of hand.
  prefs: []
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the code available at [http://www.gregshackles.com/2011/04/using-background-threads-in-mono-for-android-applications/](http://www.gregshackles.com/2011/04/using-background-threads-in-mono-for-android-applications/)
    is for Android, the same code can (more or less) be used in Xamarin.iOS and gives
    a fantastic cover of the different types of threading and how they're used.
  prefs: []
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Problems while using Tasks on threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever an additional task is created, the processor has to start swapping
    between the tasks themselves, which slows the code down. You have the additional
    problem of tracking the tasks and how they work with the main UI thread. In general,
    they shouldn't cause a problem, but you also have to consider that unless you
    explicitly program the threads to run synchronously, they run asynchronously.
    To prevent the code from getting out of hand, locks or callbacks need to be used.
    **Locks** may lead to **deadlock** conditions, so be careful! Refer back to [Chapter
    8](../Text/part0040.html#page "Chapter 8. Threading"), *Threading*, for an overview
    of deadlocks and avoiding them.
  prefs: []
  type: TYPE_NORMAL
- en: Using Asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Async is one of the big changes to .NET and was released in .NET v4, but has
    only quite recently landed within the Mono framework, and therefore within Xamarin.Android
    and Xamarin.iOS. As I explained in a previous chapter, asynchronous code can be
    a bit of a handful, but thankfully that bit of a handful is simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks and EventHandlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The handler for `LoadStarted` is a synchronous process—in other words, it is
    like a walk to the pub in a straight line. The problem is that while `webView`
    is loading a page, everything is being held up—so if it's a slow page or you need
    something else to be running (say a piece of music to play), there are going to
    be sticking points. This is where an asynchronous `LoadStarted` event can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `async` method looks different from a normal method as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A more practical example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to the `async` method being implemented, a system of events had to be
    implemented so that once the data had been returned it can be handled by the method
    (say, from a web data download). For example (the following is a psuedo code,
    so you get the idea):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can now be handled in a single `async` method, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The key here is `await`—this prevents the next line from executing until `callLoginService`
    has returned. This greatly improves responsiveness—less code, fewer events to
    listen to, and far less messing about.
  prefs: []
  type: TYPE_NORMAL
- en: If a method returns a value, the `Task<T>` parameter needs to be used prior
    to the method name. If there isn't a return value (as, when responding to a button
    click), `void` needs to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many uses for background threads as well as asynchronous calls, and
    the general recommendation is that if a process takes a long time, throw it at
    the background. Be careful when using threads. While for the majority of the time
    they are fine, you still need to test all apps on a real device to ensure the
    threads are working. Remember, the simulator is buggy (for example, the simulator
    works on a **Just In Time** processor model rather than **Ahead Of Time**, which
    the phone uses—the results are that web services may not work as planned) and
    doesn't work the same way as a phone.
  prefs: []
  type: TYPE_NORMAL
