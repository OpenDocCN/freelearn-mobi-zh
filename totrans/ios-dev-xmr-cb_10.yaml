- en: Chapter 10. Location Services and Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining heading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using region monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a significant-change location service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location services in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding map annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding map overlays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's smartphones and hand-held devices are equipped with high-accuracy Global
    Positioning System (GPS) hardware. The GPS hardware receives location information
    from a constellation of satellites. Apart from the satellites, iOS devices take
    advantage of the cellular and Wi-Fi networks to provide location information to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss how to use the appropriate frameworks to take
    advantage of the location services of the device. Furthermore, we will learn how
    to display maps and annotate them. Specifically, we will focus on the following
    subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Location services**: Here, the services available on a device for providing
    location information will be discussed. These services are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard location service**: This location service depends fully on the device''s
    GPS module and provides location data of the highest accuracy'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Region monitoring service**: This location service monitors boundary crossings'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Significant-change location service**: This service monitors significant
    changes in the location of the device'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLLocationManager`: This class allows us to use the location services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compass`: This class shows how to use the built-in compass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MKMapView`: This view is used to display maps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLGeocoder`: This class provides geocoding features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MKAnnotation`: This class allows us to add annotations on maps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MKOverlay`: This class allows us to add overlays on maps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now learn how to receive the location information from the built-in
    GPS hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `LocationApp`.
    Add two buttons and a label on the view of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to receive the location of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve location information from the built-in GPS hardware, we need to
    use the Core Location framework. It is exposed through the `MonoTouch.CoreLocation`
    namespace as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `LocationAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Tap the start button to view your location
    coordinates on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Projects using the Core Location framework to determine the current position
    of a device can work on the simulator. By navigating to the **Debug** | **Location**
    menu of the simulator, we can customize the location that the device will be using.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The location data that the GPS module provides can be accessed through the
    `CLLocationManager` class. After initializing an instance of the class, we need
    to subscribe to its `LocationsUpdated` event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Location data will become available, as they are issued through this event.
    It is also a good practice to subscribe to the `Failed` event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the location manager first requests for location updates, the user is
    informed through a system-specific alert, which is similar to the one shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This alert basically asks for user permission to allow the app to retrieve location
    data. If the user denies this request, the `Failed` event will be triggered with
    the appropriate message. Future location requests will not trigger the permission
    alert, and the user will have to enable location services for the app through
    the device's settings, so we need to handle this scenario accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'After subscribing to the appropriate events, we request the delivery of location
    updates through the `StartUpdatingLocation` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop receiving location updates, we call the `StopUpdatingLocation` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LocationsUpdated` event accepts the delegates of the `EventHandler<CLLocationsUpdatedEventArgs>`
    type. The `CLLocationsUpdatedEventArgs` parameter contains one property that returns
    an array of `CLLocation` objects. The last item in the array contains the most
    recent location data that were retrieved from location services. The array will
    always contain at least one `CLLocation` item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates are returned as values of the `double` type and represent the
    coordinates of the position in degrees as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Negative latitude values indicate south coordinates and positive values indicate
    north coordinates. Negative longitude values indicate west coordinates, while
    positive longitude values indicate east coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The `HorizontalAccuracy` property returns the accuracy of the GPS fix in meters.
    For example, a value of 17 m indicates that the location is determined within
    a circle of a diameter 17 m. Lower values indicate better accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: GPS accuracy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is always a margin of error in location data, which is independent of
    GPS hardware, and there are variable factors that define it, such as the surrounding
    buildings and various obstacles. You will notice that the `HorizontalAccuracy`
    property will return lower values when the device is outdoors, while higher values
    will be returned when we use the GPS indoors or on a city street with tall buildings.
  prefs: []
  type: TYPE_NORMAL
- en: Location services availability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all devices are equipped with location services hardware. Furthermore, even
    if a device is equipped with the appropriate hardware, location services could
    be disabled by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine if the location services are available or enabled on the device,
    we read the return value of the `CLLocationManager.LocationServicesEnabled` static
    property before initializing the location manager object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can check for the authorization status of location services
    through the `CLLocationManager.Status` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Location services usage indicator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When any type of location service is used, the location services icon appears
    on the right-hand side of the status bar next to the battery indicator, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Location services usage indicator](img/8924OT_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Determining heading* and *Location services in the background* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining heading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the built-in compass to determine the
    heading of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `HeadingApp`.
    Just as you did in the previous recipe, add two buttons and a label on the view
    of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The project in this recipe cannot be tested on the simulator. A device with
    compass hardware (magnetometer) is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to determine the heading of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in the `HeadingAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the device. Tap the start button and rotate the device
    to view the different heading values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve the heading information, we first need to subscribe to the location
    manager''s `UpdatedHeading` event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To initiate the delivery of heading information, we call the `StartUpdatingHeading`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `UpdatedHeading` event handler, we retrieve the heading information
    through the `MagneticHeading` property of the `CLHeading` object exposed through
    the event arguments'' `NewHeading` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop retrieving heading updates, we call the `StopUpdatingHeading` method
    with the help of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The heading is measured in degrees. The values for the four points of the horizon
    that can be viewed on a simple compass are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 or 360 degrees**: The magnetometer will return values of up to 359.99 degrees
    and then return 0 when the device is heading North.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**90 degrees**: The device is heading East'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**180 degrees**: The device is heading South'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**270 degrees**: The device is heading West'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magnetic vs true heading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magnetic heading is the heading that is based on what a normal compass will
    show as North. True heading is the true direction of North based on the actual
    position of the earth's North Pole. There is a slight difference between the two,
    which varies according to the earth's magnetic-field fluctuations, and it is usually
    about 2 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: The `CLHeading` class provides both readings through the `MagneticHeading` and
    `TrueHeading` properties. This provides a significant help to developers, as calculating
    the difference between the two readings requires either expensive equipment or
    very difficult calculations based on the time of year and other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Compass availability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The magnetometer, a module that can determine the heading in degrees and provides
    compass functionality to devices, is not available on all devices. To check if
    a device can provide heading information, retrieve the value from the `CLLocationManager.HeadingAvailable`
    static property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Determining location* and *Location services in the background* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using region monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use GPS to respond to region-specific position
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `RegionApp`.
    Add two buttons and a label on the view of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two fields in the `RegionAppViewController` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` method, initialize the `RegionAppViewController` class,
    and subscribe to the `LocationsUpdated`, `RegionEntered`, and `RegionLeft` events
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following event handlers in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the start button''s `TouchUpInside` handler, call the `StartUpdatingLocation`
    method using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the stop button''s `TouchUpInside` handler, call the `StopMonitoring` method
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Navigate to **Debug** | **Location**
    | **Freeway drive** on the simulator's menu and tap the **Start region monitoring**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Region monitoring is a feature that monitors boundary crossings. When a boundary
    of a specific region is crossed, the `CLLocationManager` object issues the appropriate
    events as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define the region based on the current location; hence,
    we also subscribe to the `LocationsUpdated` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the app starts receiving location updates, it first checks for location
    accuracy using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the desired accuracy is achieved (<100 m, modify at your discretion), we
    initialize the `CLCircularRegion` object using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `CLCircularRegion` class is used to define circular regions and inherits
    the `CLRegion` class. Here, in the first parameter, we create the region to be
    monitored based on our current location. The second parameter declares the radius
    around the coordinate, in meters, defining the region's boundary. The third parameter
    is a string identifier we want to assign to the region.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start monitoring the region, we call the `StartMonitoring` method using
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When region monitoring has started, the appropriate events will be triggered
    when the device enters or leaves the region.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Region monitoring is a very useful feature. For example, an app could provide
    specific information to users based on their proximity to various areas. Furthermore,
    it can notify of boundary crossings while the app is in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Region monitoring availability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To check if a device supports region monitoring, call the `CLLocationManager.IsMonitoringAvailable`
    static method passing the type of the `CLRegion` object we want to use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using a significant-change location service* and *Location services in
    the background* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a significant-change location service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use the significant location change monitoring
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `SLCApp`.
    Add a label and two buttons on the view of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `ViewDidLoad` method in the `SLCAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In iOS Simulator, navigate to **Debug** | **Location** | **Freeway drive** on
    the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app on the simulator. Tap the **Start monitoring** button
    to start monitoring for significant location changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The significant-change location service monitors significant location changes
    and provides location information when these changes occur. In terms of power
    consumption, it is the less-demanding location service. It uses the device's cellular
    radio transceiver to determine the user's location. Only devices equipped with
    a cellular radio transceiver can use this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for using the significant-change location service is similar to the
    code of the standard location services. The only differences are the methods of
    starting and stopping the service. To start the service, we call the `StartMonitoringSignificantLocationChanges`
    method using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Location updates are issued through the `LocationsUpdated` event handler, which
    is the same event we use for the standard location service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The significant-change location service can report location changes while in
    the background, waking up the app. It is very useful for apps that need to make
    use of location services, with a lower accuracy than that of the standard location
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Significant-change location service availability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine if a device is capable of using the significant-change location
    service, retrieve the value of the `SignificantLocationChangeMonitoringAvailable`
    static property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using region monitoring* and *Location services in the background* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location services in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to use location services while the app is
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundLocationApp`.
    Just like we did in the previous recipes, add a label and two buttons on the view
    of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to use the location services when the app is in
    the background:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Solution** pane, double-click on the `Info.plist` file to open it.
    Under the **Source** tab, add a new key by clicking on the plus (**+**) sign or
    by right-clicking and selecting **New Key** from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Required background modes** from the drop-down list or just type `UIBackgroundModes`
    in the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the key and right-click on the empty item below it. Click on **New Key**
    in the context menu. In its **Value** field, select **App registers for location
    updates**, or type the word `location`. Save the document. When done, you should
    have something similar to the following screenshot:![How to do it...](img/8924OT_10_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BackgroundLocationAppViewController` class, enter the same code as the
    one used in the *Determining location* recipe of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of the `LocationManager_LocationsUpdated` method, add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the **Start** button to start
    receiving location updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the simulator window active, press *Cmd* + *Shift* + *H*. This key combination
    simulates pressing the home button on a device and will move the app to the background.
    Watch Xamarin Studio's **Application Output** pad continuing the display of location
    updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To receive location updates while the app is in the background, we need to set
    the `location` value to the `UIBackgroundModes` key in the `Info.plist` file.
    This basically makes sure that the app has the appropriate permission to receive
    location updates while it is in the background and that it will not get suspended.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `Info.plist` file in a text editor, this is what has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To make sure that the app is receiving location updates, check the status bar.
    The location services icon should be displayed even if the app is in the background.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting the `UIBackgroundModes` key for location services is only needed for
    the standard location service. Both the region monitoring and significant-change
    location services support delivery of location updates while the app is in the
    background, by default. While one of these location services has started updating
    location data, the app can even be terminated. When a location update is received,
    the app is started or woken up from the suspended state and is given a limited
    amount of time to execute code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine if an app has been started by one of these two location services,
    check the `options` parameter of the `FinishedLaunching` method in the `AppDelegate`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `options` parameter is of the `NSDictionary` type. If this dictionary contains
    `UIApplication.LaunchOptionsLocationKey`, then the app has been started or woken
    up from the suspended state due to a location service. When this is the case,
    we need to call the `StartMonitoringSignificantLocationChanges` method on a `CLLocationManager`
    instance again, to retrieve location data.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to region-monitoring location service. Note that if we use
    either of these two location services, but our app does not support the background
    delivery of a location's events, we have to make sure that we stop monitoring
    location updates when they are no longer needed. If we do not, the location services
    will continue to run, causing significant battery drain.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting to supported hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our app's features are fully dependent on location services and cannot operate
    correctly on devices that do not support them, we have to add the `UIRequiredDeviceCapabilities`
    key in the `Info.plist` file with the `location-services` value.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, when the app requires the use of the standard location service,
    which uses the GPS hardware, we need to add the `gps` value to the `UIRequiredDeviceCapabilities`
    key. This way, we make sure that the app will not be available through the App
    Store to the devices that are not equipped with the appropriate hardware.
  prefs: []
  type: TYPE_NORMAL
- en: UI updates while in the background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, we deliberately set a value to the label's **Text** property
    while the app is in the background. However, updating the UI while the app is
    in the background should be avoided, because the iOS might terminate our app if
    there are too many updates. Furthermore, UI updates that occur in the background
    are basically being queued for when the app returns to the foreground and take
    place instantaneously when this happens. This may result in unexpected behavior
    in our app.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Determining location* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating an iOS project with Xamarin Studio* recipe in [Chapter 1](ch01.html
    "Chapter 1. Development Tools"), *Development Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display maps in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `MapDisplayApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to display maps in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `MKMapView` on the controller. The following screenshot shows the symbol
    for `MKMapView` in Xcode's object library:![How to do it...](img/8924OT_10_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives in the `MapDisplayAppViewController.cs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code in the `MapDisplayAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app either on the simulator or on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zoom or pan the map by pinching on the screen (press *Option* and click-and-drag
    on the simulator) to output the current location in the **Application Output**
    pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.MapKit` namespace wraps all the objects contained in the MapKit
    framework. The MapKit framework uses Apple maps to display maps.
  prefs: []
  type: TYPE_NORMAL
- en: '`MKMapView` is the default iOS view that displays maps. It is especially designed
    for this purpose, and it should not be subclassed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the user''s location on the map, we set its `ShowsUserLocation`
    property to `true` using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This activates the standard location service to start receiving location updates
    and handing them over to the `MKMapView` object internally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `MKMapView` is first shown in an app, the system will prompt the user for
    the permission to use location services, just as if we were trying to use location
    services directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine when the user zooms or pans the map, we subscribe to the `RegionChanged`
    event using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the event handler, we retrieve the current location through the `UserLocation`
    property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the `ShowsUserLocation` property is set to `false`, the location services
    will not be activated, and the `UserLocation.Location` property will return `null`.
    It will also return `null` when the app runs for the first time, as it will ask
    the user for permission to use location services. However, a map will be displayed
    as long as the device or simulator has an active Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can set the center coordinate of the map to be displayed with the `SetCenterCoordinate`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the map coordinates where we want the map to be centered
    at, represented by an object of the `CLLocationCoordinate2D` type. The second
    parameter declares if we want the centering of the map to be animated or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from centering the map, we can also set its zoom level. We do this through
    the `SetRegion` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is of the `MKCoordinateRegion` type. Here, its `FromDistance`
    static method is used to create an instance. Its first parameter is the coordinate
    of the region's center, while the next two parameters represent the horizontal
    and vertical span of the map to display, in meters. It basically means that the
    region represented by this `MKCoordinateRegion` instance will have `mapCoordinates`
    at the center, and the horizontal and vertical part of the map will each represent
    1000 meters on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `MKMapView` will set the actual region to an approximation of the
    values of `MKCoordinateRegion`. This is because the dimensions of `MKMapView`
    cannot always match the horizontal and vertical span values provided. For example,
    here, we set a square region of 1000 x 1000 meters, but our `MKMapView` layout
    is not an absolute square, as it basically takes over the entire screen. We can
    retrieve the actual region of the map that the `MKMapView` is displaying through
    its `Region` property.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Geocoding*, *Adding map annotations*, and *Adding map overlays* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to provide information about an address, city,
    or country based on location coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `GeocodingApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an `MKMapView` on the top half of the view of `MainController`, a label,
    and a button on the bottom half.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `MonoTouch.MapKit` and `MonoTouch.CoreLocation` namespaces in the `GeocodingAppViewController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following `ViewDidLoad` method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the simulator's location is set to a stationary position. Navigate
    to **Debug** | **Location** | **Custom** (or **Apple**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app either on the simulator or on the device. The result
    should be similar to the following screenshot:![How to do it...](img/8924OT_10_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Geocoding is the process of matching address information to geographic coordinates.
    Reverse geocoding is the opposite, matching geographic coordinates to address
    information. In this recipe, we are using reverse geocoding through the `CLGeocoder`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing the geocoder object, we call the `ReverseGeocodeAsync` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The method accepts a `CLLocation` parameter, which represents the location
    for which we want to retrieve geocoding data. The `return` value is an array of
    the CLPlacemark objects. The `CLPlacemark` class contains the reverse-geocoded
    information, such as the country, city, and address of the coordinates as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When reverse-geocoding a location, the array will always contain one item. If
    the return value is null, then an error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also use the `CLGeocoder` class for forward geocoding. For example,
    to get the coordinates of Apple''s central offices, we use the `GeocodeAddressAsync`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The method will give more accurate results when we pass as all the information
    that we have to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forward geocoding with the `GeocodeAddressAsync` method might return more than
    one item in the resulting `CLPlacemark[]` object. This is because the geocoder
    might not be able to determine the exact location through the passed information,
    so a set of possible results will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Things to have in mind for CLGeocoder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple provides the geocoding feature with a rate limit. Although the exact limit
    is not documented, it is recommended that you do not make more than one geocoding
    request per minute. If the rate limit is exceeded, the geocoder will fail with
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Obsolete API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CLGeocoder` class basically replaces `MKReverseGeocoder`, which only offered
    reverse geocoding until iOS 5.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying maps*, *Adding map annotations*, and *Adding map overlays* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding map annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss annotating a map to provide a variety of information
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `MapAnnotateApp`.
    Add `MKMapView` and a button on the view of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to add annotations to a map:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `MonoTouch.MapKit` and `MonoTouch.CoreLocation` namespaces in the `MapAnnotateAppViewController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `IMKMapViewDelegate` interface to the `MapAnnotateAppViewController`
    class declaration using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method in the `MapAnnotateAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app either on the simulator or on the device. Tap the button
    to add a pin on the map. The result should be similar to the following screenshot:![How
    to do it...](img/8924OT_10_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tapping on the pin displays the callout bubble with the annotation title and
    subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Annotating maps is very useful for providing a variety of information along
    with the map data. We can use the `MKPointAnnotation` class to create a simple
    annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We assign the annotation that will appear on the map coordinates, and optionally,
    a title and subtitle might also appear. We then add the annotation to the map
    view with the `AddAnnotation` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just adding an annotation object to a map view is not enough. The annotation
    needs a view that will display its information. To provide a view for the annotation,
    we need to assign a delegate object to our map view. In this recipe, we are using
    our controller class as a delegate object for the map view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can assign any object that derives from `NSObject` to the `WeakDelegate`
    property. All we need to make it work properly is to make sure that we provide
    the necessary methods. Here is where the `GetViewForAnnotation` method comes in
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This method is found in the `MKMapViewDelegate` class and is called by the system
    when it needs to get a view for an annotation. The main difference in our implementation
    here is that instead of subclassing `MKMapViewDelegate`, we just use our controller
    as a delegate for our map view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `GetViewForAnnotation` method, we need to make sure that we create
    and return a view for our annotation. As the map displays the user''s location,
    there are two annotations on the map. We first need to check if the annotation
    object is `MKUserLocation` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we just return null. If the annotation parameter is of the `MKPointAnnotation`
    type, we first try to retrieve the view for it in a fashion similar to `UITableView`
    that creates the cells it contains, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If the result of the `DequeueReusableAnnotation` method is `null`, we initialize
    a new instance for our annotation view using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The view we create for the annotation here is of the `MKPinAnnotationView` type.
    This is the standard view that is represented by a pin on the map. The properties
    we set are pretty straightforward and define its appearance and behavior. The
    `PinColor` property defines the color of the pin, the `AnimatesDrop` property
    defines if the pin will be displayed on the map with an animation, and the `CanShowCallout`
    property defines if the annotation view will display the information of its underlying
    annotation in a callout bubble.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created the view for the annotation, we just return it from the
    method using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also create custom annotations and annotation views. For annotations,
    we have to override the `MKAnnotation` class, while for annotation views, we can
    override the `MKAnnotationView` class.
  prefs: []
  type: TYPE_NORMAL
- en: An annotation's performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Theoretically, we can add as many annotations as we want to a map view. Although
    `MKMapView` can manage a large amount of annotations efficiently, it is strongly
    advised to take performance degradation into account. A way to overcome this is
    to display only the required annotations, instead of all of them. To do this,
    we can call the `ShowAnnotations` method, passing the specific annotation objects
    as an array using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying maps* and *Adding map overlays* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Displaying data in a table* recipe in [Chapter 5](ch05.html "Chapter 5. Displaying
    Data"), *Displaying Data*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding map overlays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add a red circle overlay over a point on
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `MapOverlayApp`.
    Add `MKMapView` and a button on the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to add overlays on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `MonoTouch.MapKit` and `MonoTouch.CoreLocation` namespaces in the `MapOverlayAppViewController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `IMKMapViewDelegate` interface to the class declaration using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app either on the simulator or on the device. When you tap
    the button, the result should be similar to the following screenshot:![How to
    do it...](img/8924OT_10_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While an `MK` `MKAnnotation` represents a point on a map, an `MKOverlay` object
    can represent an area on a map. In this example, we use the `MKCircle` class,
    which inherits from `MKOverlay`, to display a circle over an area on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize an `MKCircle` instance with its `Circle` static method using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter represents the coordinates of the center of the circle,
    while the second parameter represents the radius of the circle, in meters. After
    initialization, we add the overlay to the map view with the `AddOverlay` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter of the `AddOverlay` method determines how the overlay
    should be rendered in relation to the map''s information. There are two possible
    values, which are explained with the following accompanying screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MKOverlayLevel.AboveRoads`: This overlay will be displayed above the roads
    of the map, but below the map labels, as shown in the following screenshot:![How
    it works...](img/8924OT_10_08.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MKOverlayLevel.AboveLabels`: This overlay will be displayed above both roads
    and labels on the map, but below annotations and 3D projections of the buildings,
    as shown in the following screenshot:![How it works...](img/8924OT_10_09.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike annotations, overlays require `MKOverlayRenderer` to display their information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to iOS 7, overlays were shown with a view of the `MKOverlayView` type.
    This class is now deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a renderer for our overlay, we use the `OverlayRenderer` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this method, we first check if the `overlay` parameter is of the type
    we want (in this case, an `MKCircle`) using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an instance of the `MKCircleView` class and return it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We set the appropriate properties that will define the appearance of our overlay.
    In this case, we set the `FillColor`, `StrokeColor`, and `LineWidth` properties.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overlays are handled efficiently by the map view. One important thing that the
    map view takes care of for us is that when we scale the map, the overlay is automatically
    scaled to match each zoom level. This way, we do not need to scale the overlay
    manually in code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom overlays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can create our own custom overlays. To do this, we need to override the `MKOverlay`
    class for the overlay and the `MKOverlayRenderer` class for the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Standard overlay objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from `MKCircle`, the other standard overlay objects are `MKPolygon` for
    creating polygon shapes and `MKPolyline` for creating polylines, like in a track-recording
    application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying maps* and *Adding map annotations* recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
