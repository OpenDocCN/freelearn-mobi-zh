- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Extending Video Playback in Your Packtflix App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的 Packtflix 应用中扩展视频播放
- en: Have you ever wanted your users to continue enjoying their favorite videos even
    when they switch apps or turn off the screen? This chapter dives deep into the
    world of extended video playback on Android, bringing you the skills to create
    a more engaging and versatile user experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾希望用户在切换应用或关闭屏幕时仍能继续享受他们最喜欢的视频？本章深入探讨了 Android 上扩展视频播放的世界，为您带来创建更具吸引力和灵活性的用户体验的技能。
- en: 'We’ll be exploring two key functionalities: `MediaRouter` and the Cast SDK,
    which enable users to transfer the video playback to a larger screen, such as
    a TV with Google Chromecast.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索两个关键功能：`MediaRouter` 和 Cast SDK，它们使用户能够将视频播放传输到更大的屏幕，例如带有 Google Chromecast
    的电视。
- en: By the end of this chapter, you’ll have gained a solid understanding of the
    PiP functionalities and unlocked the potential of extended video playback in our
    Android app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将深入了解 PiP 功能，并解锁我们 Android 应用中扩展视频播放的潜力。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Getting to know the PiP API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 PiP API
- en: Using PiP to continue playback in the background
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PiP 在后台继续播放
- en: Getting to know **MediaRouter**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 **MediaRouter**
- en: Connecting to Google Chromecast devices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 Google Chromecast 设备
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have installed Android Studio (or
    another editor of your preference).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，您需要安装 Android Studio（或您偏好的其他编辑器）。
- en: We will follow the project started in [*Chapter 7*](B19443_07.xhtml#_idTextAnchor142)
    with the changes we have made in [*Chapter 8*](B19443_08.xhtml#_idTextAnchor160).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循在 [*第 7 章*](B19443_07.xhtml#_idTextAnchor142) 中开始的项目，并加入我们在 [*第 8 章*](B19443_08.xhtml#_idTextAnchor160)
    中所做的更改。
- en: 'You can find the complete code that we are going to build through this chapter
    available in this repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本仓库中找到本章将要构建的完整代码：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9).
- en: Getting to know the PiP API
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 PiP API
- en: The first step on our extended video playback journey is to understand the PiP
    API, which lets us use PiP mode. **PiP mode** allows users to minimize your app
    and continue watching a video in a resizable and movable miniature player. This
    functionality enhances user experience by providing flexibility and convenience.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展视频播放之旅的第一步是了解 PiP API，它使我们能够使用 PiP 模式。**PiP 模式**允许用户最小化您的应用，并在可调整大小和可移动的迷你播放器中继续观看视频。这种功能通过提供灵活性和便利性来增强用户体验。
- en: This section will provide you with the knowledge to leverage PiP effectively
    in your app. We’ll cover the most important aspects such as understanding the
    PiP requirements and learning how to enter and exit PiP mode programmatically,
    and review some different listener events. So, let’s get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将为您提供在应用中有效利用 PiP 的知识。我们将涵盖最重要的方面，例如理解 PiP 要求、学习如何以编程方式进入和退出 PiP 模式，并回顾一些不同的监听事件。那么，让我们开始吧。
- en: PiP requirements
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PiP 要求
- en: Not every device is created equal when it comes to PiP. Before we go deep into
    the exciting functionalities, let’s ensure a smooth user experience by understanding
    the requirements and compatibility aspects of PiP mode.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PiP 方面，并非所有设备都相同。在我们深入探讨令人兴奋的功能之前，让我们通过理解 PiP 模式的需求和兼容性方面来确保用户体验的流畅。
- en: 'Regarding the requirements, there are two variables to take into account:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于需求，有两个变量需要考虑：
- en: '**Minimum Android version**: PiP mode relies on specific APIs introduced in
    Android 8.0 (Oreo). Targeting devices running older versions of Android will not
    only prevent PiP functionality but could also lead to crashes or unexpected behavior.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最低 Android 版本**：PiP 模式依赖于 Android 8.0（奥利奥）中引入的特定 API。针对运行旧版 Android 的设备不仅会阻止
    PiP 功能，还可能导致崩溃或意外行为。'
- en: 'To check if the user’s device is compatible with PiP, we could implement the
    following code:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检查用户的设备是否与 PiP 兼容，我们可以实现以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code ensures our app gracefully handles devices that can’t use PiP mode.
    First, we define the minimum Android version required for PiP (typically Android
    8.0 or Oreo). Then, we check the device’s current version. If it’s older than
    the minimum, the code recognizes that PiP functionality isn’t available and signals
    this back (potentially by returning `false`) to prevent the app from attempting
    to use PiP features that would cause issues on incompatible devices.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码确保我们的应用优雅地处理无法使用PiP模式的设备。首先，我们定义了PiP所需的最低Android版本（通常是Android 8.0或奥利奥）。然后，我们检查设备的当前版本。如果它低于最低版本，代码会识别PiP功能不可用，并通过（可能通过返回`false`）向应用发出信号，防止应用尝试使用在不兼容设备上会引起问题的PiP功能。
- en: This allows you to gracefully handle situations where PiP isn’t available and
    potentially offer alternative functionalities for users on older devices (for
    example, we could offer them to send the playback to a different device).
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许您优雅地处理PiP不可用的情况，并可能为旧设备上的用户提供替代功能（例如，我们可以提供让他们将播放发送到另一台设备的功能）。
- en: '**Screen size requirements**: While PiP mode can be technically implemented
    on various screen sizes, smaller displays might not provide an optimal user experience.
    Imagine trying to watch a movie in a tiny PiP window on a phone with a 4-inch
    screen! Therefore, it’s essential to consider screen size limitations.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕尺寸要求**：虽然PiP模式可以在各种屏幕尺寸上技术上实现，但较小的显示屏可能无法提供最佳的用户体验。想象一下在4英寸屏幕的手机上尝试在微小的PiP窗口中看电影！因此，考虑屏幕尺寸限制是至关重要的。'
- en: 'Now that we’ve established the requirements, let’s explore the exciting part:
    initiating PiP mode within our app.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了需求，让我们探索一下激动人心的部分：在我们的应用中启动PiP模式。
- en: Entering and exiting PiP mode programmatically
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式进入和退出PiP模式
- en: 'As we already know, PiP mode offers users the convenience of continuing video
    playback in a miniature window even when they switch apps or turn off the screen.
    To do this, we’ll use the `enterPictureInPictureMode()` method available in the
    `Activity` class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，PiP模式为用户提供在切换应用或关闭屏幕时继续在迷你窗口中播放视频的便利性。为此，我们将使用`Activity`类中可用的`enterPictureInPictureMode()`方法：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Calling this method allows you to programmatically trigger PiP mode from within
    your activity, and the system will handle resizing the video player window and
    placing it on top of other apps. It’s important to note that you should typically
    only call this method when the user explicitly requests it, such as upon tapping
    a dedicated PiP button within your app’s UI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法允许您在您的活动中以编程方式触发PiP模式，系统将处理调整视频播放器窗口大小并将其置于其他应用之上。需要注意的是，您通常只在用户明确请求时调用此方法，例如在您的应用UI中轻触专用的PiP按钮。
- en: 'While entering PiP mode is initiated programmatically, exiting is primarily
    user-driven. The user can exit PiP mode by swiping the miniature player away or
    tapping a designated **Close** button provided by the system. However, as developers,
    we can still play a role in ensuring a smooth transition back to the fullscreen
    experience. The system triggers specific callbacks within your activity when PiP
    mode is exited. Here’s how we can utilize these callbacks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然进入PiP模式是通过编程方式触发的，但退出主要是用户驱动的。用户可以通过滑动迷你播放器或轻触系统提供的指定**关闭**按钮来退出PiP模式。然而，作为开发者，我们仍然可以在确保平滑过渡回全屏体验方面发挥作用。当PiP模式退出时，系统会在您的活动中触发特定的回调。以下是我们可以如何利用这些回调：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function will be called every time the user closes the PiP miniature screen.
    This is not the only function that we can use to handle PiP status changes, though;
    the listener provides various events to keep our app informed about changes in
    the PiP window. These events allow us to react and update our app’s behavior accordingly,
    ensuring a seamless user experience:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户关闭PiP迷你屏幕时，此函数都会被调用。这不是我们可以用来处理PiP状态变化的唯一函数；监听器提供了各种事件，以使我们的应用了解PiP窗口的变化。这些事件允许我们做出反应并相应地更新我们的应用行为，确保无缝的用户体验：
- en: '**OnPictureInPictureEntered()**: This event gets triggered when the user successfully
    enters PiP mode. You can use this opportunity to potentially update UI elements
    to reflect the PiP state (for example, hide unnecessary controls) or perform any
    necessary optimizations for PiP playback (for example, adjust video quality).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnPictureInPictureEntered()**: 当用户成功进入PiP模式时，此事件会被触发。您可以利用这个机会更新UI元素以反映PiP状态（例如，隐藏不必要的控件）或对PiP播放进行任何必要的优化（例如，调整视频质量）。'
- en: '**OnPictureInPictureExited()**: As discussed previously, this event signifies
    the user exiting PiP mode. Here, you can clean up resources associated with the
    PiP window or update the UI to reflect the return to fullscreen playback.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnPictureInPictureExited()**：如前所述，此事件表示用户退出PiP模式。在这里，你可以清理与PiP窗口相关的资源或更新UI以反映全屏播放的返回。'
- en: '**OnPictureInPictureUiStateChanged()**: This event gets fired whenever any
    change occurs to the PiP window, such as resizing or moving it. You might use
    this to adjust your UI layout based on the new PiP window dimensions or update
    video playback based on potential performance changes due to resizing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnPictureInPictureUiStateChanged()**：此事件在PiP窗口发生任何变化时触发，例如调整大小或移动它。你可能使用此事件根据新的PiP窗口尺寸调整UI布局或根据调整大小可能导致的性能变化更新视频播放。'
- en: By effectively handling PiP events and listener callbacks, you can keep your
    app in sync with the changing PiP window state. Now, let’s see how we can integrate
    it into our existing project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效地处理PiP事件和监听器回调，你可以使你的应用与变化的PiP窗口状态保持同步。现在，让我们看看如何将其集成到我们的现有项目中。
- en: Using PiP to continue playback in the background
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PiP在后台继续播放
- en: 'The first step before we can use PiP in our project is that we must declare
    support for it in our `AndroidManifest.xml` file. This step is crucial for informing
    the Android system that our `PlaybackActivity` class is capable of running in
    PiP mode. We do this like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在项目中使用PiP之前的第一步是，我们必须在`AndroidManifest.xml`文件中声明对其的支持。这一步对于通知Android系统我们的`PlaybackActivity`类能够以PiP模式运行至关重要。我们这样做：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For PiP specifically, the key attribute in our manifest is `android:supportsPicture`
    **InPicture="true"**, which explicitly declares that your activity supports PiP
    mode.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PiP而言，我们清单中的关键属性是`android:supportsPicture` **InPicture="true"**，它明确声明你的活动支持PiP模式。
- en: The `resizeableActivity` attribute, while related to the ability of an activity
    to be resized, is implicitly set to `true` for all activities when targeting API
    level 24 or higher. This means if your app targets API level 24+, you don’t need
    to explicitly set `resizeableActivity="true"` for PiP mode to work because the
    system already considers all activities to be resizable to support multi-window
    mode.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`resizeableActivity`属性，虽然与活动可调整大小的能力相关，但在针对API级别24或更高版本时，默认设置为`true`。这意味着如果你的应用针对API级别24+，你不需要显式设置`resizeableActivity="true"`以使PiP模式工作，因为系统已经默认认为所有活动都是可调整大小的，以支持多窗口模式。'
- en: However, explicitly setting `resizeableActivity="true"` can be a good practice
    for clarity, especially if your app is designed to take advantage of multi-window
    features beyond just PiP, or if you want to ensure compatibility across different
    Android versions and devices. It’s also useful for documentation purposes, making
    it clear to anyone reading your `AndroidManifest.xml` file that your activity
    is intended to support resizable behaviors, including PiP.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，显式设置`resizeableActivity="true"`是一种良好的实践，特别是如果你的应用旨在利用多窗口功能，而不仅仅是PiP，或者如果你想确保在不同Android版本和设备上的兼容性。它对于文档目的也很有用，使任何阅读你的`AndroidManifest.xml`文件的人都能清楚地知道你的活动旨在支持可调整的行为，包括PiP。
- en: Implementing PiP
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现PiP
- en: 'Now that we have explicitly opted in our `Activity` class to use the PiP feature,
    let’s implement it. We will override the `onUserLeaveHint()` callback, which is
    triggered when the user presses the **Home** button or switches to another app:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经明确选择在我们的`Activity`类中使用PiP功能，让我们来实现它。我们将重写`onUserLeaveHint()`回调，该回调在用户按下**主页**按钮或切换到另一个应用时触发：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we said, we are overriding the `onUserLeaveHint()` existing function. Here,
    we still have to include the call to `super.onUserLeaveHint()` as it ensures that
    the `Activity` class properly handles any additional underlying operations defined
    by Android’s framework before executing custom behavior.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，我们正在重写`onUserLeaveHint()`现有函数。在这里，我们仍然必须包含对`super.onUserLeaveHint()`的调用，因为它确保`Activity`类在执行自定义行为之前正确处理Android框架定义的任何附加底层操作。
- en: Within this method, the aspect ratio for the PiP window is defined as `16:9`,
    a common choice for video content, by using the `Rational` class. This aspect
    ratio is crucial as it dictates the proportional relationship between the width
    and height of the PiP window, ensuring the video maintains its intended appearance
    without distortion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，通过使用`Rational`类，将PiP窗口的宽高比定义为`16:9`，这是视频内容的常见选择。这个宽高比至关重要，因为它决定了PiP窗口宽度和高度之间的比例关系，确保视频在无扭曲的情况下保持其预期的外观。
- en: To apply this aspect ratio, the `PictureInPictureParams.Builder` class is utilized
    to construct a configuration object. By invoking `setAspectRatio(aspectRatio)`
    on the builder, the previously defined aspect ratio is applied to this configuration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个宽高比，使用`PictureInPictureParams.Builder`类构建一个配置对象。通过在构建器上调用`setAspectRatio(aspectRatio)`，将之前定义的宽高比应用于此配置。
- en: While `setAspectRatio(Rational)` sets the preferred aspect ratio of the PiP
    window, meaning that the system will try to maintain this aspect ratio when displaying
    the PiP window, it may not always be possible depending on the device and screen
    size constraints. Android 11 (API level 30) introduced `setMaxAspectRatio(Rational)`
    and `setMinAspectRatio(Rational)` for defining the maximum and minimum aspect
    ratios. Additionally, `setMaxSize(int, int)` allows setting the maximum size of
    the PiP window, providing greater control over how the PiP window appears on different
    devices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当`setAspectRatio(Rational)`设置PiP窗口的首选宽高比时，意味着系统在显示PiP窗口时会尝试维持这个宽高比，但根据设备和屏幕尺寸的限制，这并不总是可能的。Android
    11（API级别30）引入了`setMaxAspectRatio(Rational)`和`setMinAspectRatio(Rational)`来定义最大和最小的宽高比。此外，`setMaxSize(int,
    int)`允许设置PiP窗口的最大尺寸，从而提供了对PiP窗口在不同设备上显示方式的更多控制。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are also other **PictureInPictureParams.Builder** options that could
    be applied. For more information about these options, refer to the documentation:
    [https://developer.android.com/reference/android/app/PictureInPictureParams.Builder](https://developer.android.com/reference/android/app/PictureInPictureParams.Builder).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的**PictureInPictureParams.Builder**选项可以应用。有关这些选项的更多信息，请参阅文档：[https://developer.android.com/reference/android/app/PictureInPictureParams.Builder](https://developer.android.com/reference/android/app/PictureInPictureParams.Builder)。
- en: The `build()` method then compiles these configurations into a `PictureInPictureParams`
    object, which encapsulates all the necessary settings for entering PiP mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`build()`方法将这些配置编译成一个`PictureInPictureParams`对象，该对象封装了进入PiP模式所需的所有设置。
- en: Finally, the `enterPictureInPictureMode(params)` method is invoked, signaling
    the system to transition the current `Activity` class into PiP mode using the
    specified parameters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`enterPictureInPictureMode(params)`方法，向系统发出信号，使用指定的参数将当前的`Activity`类转换为PiP模式。
- en: 'Now that we have integrated this feature, when we are on the playback screen
    and we leave the application, we should still see the video on the PiP screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经集成了这个功能，当我们处于播放屏幕并离开应用程序时，我们仍然应该在PiP屏幕上看到视频：
- en: '![Figure 9.1: Playback using the PiP feature](img/B19443_09_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：使用PiP功能进行播放](img/B19443_09_01.jpg)'
- en: 'Figure 9.1: Playback using the PiP feature'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：使用PiP功能进行播放
- en: 'The `PictureInPictureParams.Builder` class in Android provides a customizable
    way to configure the behavior and appearance of an app when it enters PiP mode.
    Apart from setting the aspect ratio with `setAspectRatio()`, as we did in the
    previous instruction, there are several other options available to tailor the
    PiP experience:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的`PictureInPictureParams.Builder`类提供了一种可定制的配置方法，用于配置应用程序进入PiP模式时的行为和外观。除了使用`setAspectRatio()`设置宽高比，如我们在前面的指令中所做的那样，还有其他几个选项可用于定制PiP体验：
- en: '**Actions**: Using **setActions(List<RemoteAction>)**, developers can specify
    a list of actions that the user can perform while in PiP mode. These actions are
    represented as **RemoteAction** objects and can include things such as play, pause,
    or skip. These actions appear as buttons in the PiP window, providing interactive
    elements for the user without needing to return to the full app interface.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：通过使用**setActions(List<RemoteAction>)**，开发者可以指定用户在PiP模式下可以执行的操作列表。这些操作以**RemoteAction**对象的形式表示，可以包括播放、暂停或跳过等操作。这些操作在PiP窗口中作为按钮出现，为用户提供交互元素，而无需返回到完整的应用程序界面。'
- en: '**Auto enter/exit**: Through **setAutoEnterEnabled(boolean)** and **setAutoExitEnabled(boolean)**
    (introduced in later Android versions), developers can control whether the app
    should automatically enter or exit PiP mode based on certain conditions, such
    as media playback state.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动进入/退出**：通过**setAutoEnterEnabled(boolean)**和**setAutoExitEnabled(boolean)**（在后续的Android版本中引入），开发者可以控制应用程序是否应根据某些条件（如媒体播放状态）自动进入或退出PiP模式。'
- en: '**Seamless resize**: By invoking **setSeamlessResizeEnabled(boolean)**, it’s
    possible to enable or disable seamless resizing for the PiP window. This option,
    available in later Android versions, helps make the transition into and out of
    PiP mode smoother visually.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无缝调整大小**：通过调用 **setSeamlessResizeEnabled(boolean)**，可以启用或禁用 PiP 窗口的无缝调整大小。这个选项在后来的
    Android 版本中可用，有助于使进入和退出 PiP 模式的视觉转换更加平滑。'
- en: '**Source rect hint**: **setSourceRectHint(Rect)** allows developers to suggest
    a preferred area of the screen that the PiP mode should try to align with when
    entering PiP mode. This can be useful for guiding the system on where the PiP
    window should ideally be placed based on the app’s UI layout.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源矩形提示**：**setSourceRectHint(Rect)** 允许开发者建议 PiP 模式进入时应该尝试对齐的屏幕上的首选区域。这可以根据应用程序的
    UI 布局指导系统，确定 PiP 窗口理想的位置。'
- en: Let’s use these options to add actions so that the user can toggle between play
    and pause in the PiP view. But first, a little theory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些选项来添加动作，以便用户可以在 PiP 视图中在播放和暂停之间切换。但首先，让我们先来一点理论。
- en: Understanding how to add actions to the PiP mode
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解如何向 PiP 模式添加动作
- en: Integrating actions into PiP mode enhances user interaction by allowing direct
    control over app functionality without leaving the PiP window. By using the `setActions(List<RemoteAction>)`
    method, you can create a more immersive and user-friendly experience, offering
    controls such as play, pause, or skip directly within the PiP overlay. This capability
    is especially valuable in media applications, where users often need to manage
    playback without disrupting their current onscreen activities.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将动作集成到 PiP 模式通过允许在 PiP 窗口中直接控制应用程序功能而不离开 PiP 窗口，从而增强了用户交互。通过使用 `setActions(List<RemoteAction>)`
    方法，您可以创建一个更加沉浸式和用户友好的体验，提供如播放、暂停或直接在 PiP 叠加层中跳过的控制功能。这种能力在媒体应用程序中尤其有价值，因为用户通常需要在不干扰当前屏幕活动的情况下管理播放。
- en: In a moment, we will learn how to effectively create and manage these `RemoteAction`
    objects, ensuring our app’s PiP mode is both functional and engaging, complementing
    the existing array of PiP features. But let’s dig into the concepts further.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在不久的将来，我们将学习如何有效地创建和管理这些 `RemoteAction` 对象，确保我们的应用程序 PiP 模式既功能性强又引人入胜，补充现有的
    PiP 功能。但让我们进一步探讨这些概念。
- en: Each `RemoteAction` object represents an actionable element in the PiP window,
    such as a button for play, pause, or skip functionality. To create these actions,
    we would have to specify an icon, a title, a `PendingIntent` object that defines
    the action to take when the user interacts with the button, and a description
    for accessibility purposes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `RemoteAction` 对象代表 PiP 窗口中的一个可操作元素，例如用于播放、暂停或跳过的按钮。要创建这些动作，我们需要指定一个图标、一个标题、一个定义用户与按钮交互时采取的动作的
    `PendingIntent` 对象，以及用于辅助功能的描述。
- en: The utilization of a `PendingIntent` object is crucial here, as it allows the
    action to trigger specific behaviors in your app when invoked. An `Intent` object
    in Android is like a message that can signify a wide range of events, including
    system boot completion, network changes, or custom events defined by the application.
    Typically, these intents are directed toward a `BroadcastReceiver` instance within
    your application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PendingIntent` 对象的使用至关重要，因为它允许动作在调用时触发应用程序中的特定行为。Android 中的 `Intent` 对象就像一条消息，可以表示广泛的事件，包括系统启动完成、网络变化或应用程序定义的自定义事件。通常，这些意图被指向应用程序内的
    `BroadcastReceiver` 实例。
- en: A `BroadcastReceiver` instance in Android is a fundamental component that enables
    applications to listen for and respond to broadcast messages from other applications
    or from the system itself. When an intent that matches a `BroadcastReceiver` instance’s
    filter is broadcasted, the `BroadcastReceiver` instance’s `onReceive()` method
    is invoked, allowing the app to execute logic in response to the event. This mechanism
    provides a powerful way for applications to react to global system events or inter-app
    communication without needing to be running in the foreground, making `BroadcastReceiver`
    instances a key tool for event-driven programming in Android.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Android 中的 `BroadcastReceiver` 实例是一个基本组件，它使应用程序能够监听并响应来自其他应用程序或系统本身的广播消息。当广播一个与
    `BroadcastReceiver` 实例的过滤器匹配的意图时，`BroadcastReceiver` 实例的 `onReceive()` 方法会被调用，允许应用程序在事件发生时执行逻辑。这种机制为应用程序提供了一种强大的方式来响应全局系统事件或应用程序间通信，而无需在前景运行，使
    `BroadcastReceiver` 实例成为 Android 中事件驱动编程的关键工具。
- en: In our case, this `BroadcastReceiver` instance is responsible for listening
    to and processing the broadcasted intents sent by PiP actions. For instance, when
    a user presses the `PendingIntent` object associated with the play action is broadcasted,
    and the corresponding receiver in your app catches this intent and triggers the
    media to play.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个`BroadcastReceiver`实例负责监听和处理由PiP动作发送的广播意图。例如，当与播放动作关联的`PendingIntent`对象被广播时，你的应用中的相应接收器捕获这个意图并触发媒体播放。
- en: The need for a `BroadcastReceiver` instance arises from the decoupled nature
    of PiP action intents from direct method calls within your app. Since these actions
    occur outside the regular UI flow, using a broadcast mechanism allows your app
    to respond to these actions asynchronously and perform the necessary operations,
    such as updating the media playback state. This setup ensures that your app can
    handle PiP controls effectively, providing a seamless experience for users even
    when interacting with the app from the PiP window.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个`BroadcastReceiver`实例的原因是PiP动作意图与你的应用中直接方法调用解耦。由于这些动作发生在常规UI流程之外，使用广播机制允许你的应用异步响应这些动作并执行必要的操作，例如更新媒体播放状态。这种设置确保你的应用可以有效地处理PiP控制，即使在用户从PiP窗口与应用交互时也能提供无缝体验。
- en: Now that we know how to create `RemoteAction` objects, let’s apply our learnings
    in our project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建`RemoteAction`对象，让我们将我们的学习应用到我们的项目中。
- en: Adding actions to the PiP mode
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向PiP模式添加动作
- en: 'Let’s start by creating our `BroadcastReceiver` subclass. This class will extend
    `BroadcastReceiver` and override the `onReceive()` method, where you’ll define
    how your app should react to PiP action `Intent` objects:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建我们的`BroadcastReceiver`子类。这个类将扩展`BroadcastReceiver`并重写`onReceive()`方法，在那里你将定义你的应用应该如何对PiP动作`Intent`对象做出反应：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `onReceive` method, a check is performed on the `Intent` action to determine
    if it matches the `ACTION_TOGGLE_PLAY` action. If it does, the play/pause toggle
    logic will be executed. In this case, we will execute a callback, as the logic
    to play or pause the playback will likely be outside this receiver.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onReceive`方法中，会检查`Intent`动作是否与`ACTION_TOGGLE_PLAY`动作匹配。如果匹配，将执行播放/暂停切换逻辑。在这种情况下，我们将执行一个回调，因为播放或暂停回放的逻辑可能位于此接收器之外。
- en: 'Next, we need to register the `BroadcastReceiver` instance so that it can receive
    the `Intent` object. This can be done in two ways:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要注册`BroadcastReceiver`实例，以便它可以接收`Intent`对象。这可以通过两种方式完成：
- en: '**Manifest declaration**: Registering in the **AndroidManifest.xml** file is
    suitable for actions that should be received even if your app is not running.
    However, for PiP actions, dynamic registration in the activity or service that
    handles PiP mode is often more appropriate.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Manifest声明**：在**AndroidManifest.xml**文件中注册适合于即使应用未运行也应接收的动作。然而，对于PiP动作，在处理PiP模式的activity或service中进行动态注册通常更为合适。'
- en: '**Dynamic registration**: Since PiP actions are specifically related to when
    our app is in PiP mode, registering the **BroadcastReceiver** instance dynamically
    in our **PlaybackActivity** class allows for more control and is contextually
    relevant.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态注册**：由于PiP动作与我们的应用处于PiP模式时特别相关，因此在我们**PlaybackActivity**类中动态注册`BroadcastReceiver`实例可以提供更多控制，并且与上下文相关。'
- en: 'We will register the `BroadcastReceiver` instance using dynamic registration.
    In our `PlaybackActivity` class, the implementation will look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用动态注册来注册`BroadcastReceiver`实例。在我们的`PlaybackActivity`类中，实现将如下所示：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we will declare a `BroadcastReceiver` variable named `pipActionReceiver`.
    This receiver is not initialized immediately (it is declared as `lateinit var`)
    because it will be set up in the `onCreate` method of our activity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明一个名为`pipActionReceiver`的`BroadcastReceiver`变量。这个接收器不会立即初始化（它被声明为`lateinit
    var`），因为它将在我们activity的`onCreate`方法中设置。
- en: In the `onCreate` method, we will initialize the `BroadcastReceiver` variable.
    The `pipActionReceiver` variable is instantiated and assigned a lambda function
    as its argument. This function is intended to contain the logic that handles the
    play/pause action.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，我们将初始化`BroadcastReceiver`变量。`pipActionReceiver`变量被实例化并分配了一个lambda函数作为其参数。这个函数旨在包含处理播放/暂停动作的逻辑。
- en: 'Then, we will register the `BroadcastReceiver` variable, indicating the `Intent`
    filter signal it will listen to. The registration method differs depending on
    the SDK version:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将注册 `BroadcastReceiver` 变量，指示它将监听的 `Intent` 过滤信号。注册方法取决于 SDK 版本：
- en: For SDK versions Tiramisu (Android 13, API level 33) and above, you use the
    **registerReceiver** method with an additional flag, **RECEIVER_NOT_EXPORTED**,
    for enhanced security, ensuring that your receiver does not inadvertently become
    accessible to other apps.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Tiramisu (Android 13，API 级别 33) 及以上版本的 SDK，您使用带有附加标志的 `registerReceiver`
    方法，即 **RECEIVER_NOT_EXPORTED**，以增强安全性，确保您的接收器不会意外地被其他应用访问。
- en: For earlier versions, you register the receiver without this flag. This ensures
    backward compatibility while adhering to best practices for app security on newer
    devices.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于早期版本，您将注册接收器而不使用此标志。这确保了向后兼容性，同时遵守在新设备上应用安全性的最佳实践。
- en: 'Now, let’s create the action that will trigger the `Intent` action needed to
    launch the `BroadcastReceiver` instance:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个将触发启动 `BroadcastReceiver` 实例所需的 `Intent` 操作的动作：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code, we are creating a `RemoteAction` method. The first line inside
    the method creates an `Icon` object from a drawable resource `(R.drawable.baseline_play_arrow_24)`.
    This icon visually represents the toggle play/pause action to the user.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个 `RemoteAction` 方法。方法内部的第一行从可绘制资源 `(R.drawable.baseline_play_arrow_24)`
    创建了一个 `Icon` 对象。此图标向用户直观地表示切换播放/暂停操作。
- en: Then, a new `Intent` object is instantiated with the `PiPActionReceiver.ACTION_TOGGLE_PLAY`
    action. This `Intent` object is designed to be broadcasted when the `RemoteAction`
    method is invoked by the user. The `let` block is utilized to directly chain the
    creation of a `PendingIntent` object that wraps this `Intent` object, making it
    executable from outside the application context.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `PiPActionReceiver.ACTION_TOGGLE_PLAY` 操作创建一个新的 `Intent` 对象。此 `Intent`
    对象设计为在用户调用 `RemoteAction` 方法时广播。`let` 块被用来直接链式创建一个包装此 `Intent` 对象的 `PendingIntent`
    对象，使其可以在应用程序上下文之外执行。
- en: The `PendingIntent.getBroadcast` method is called to create a `PendingIntent`
    object that broadcasts the `Intent` object. This `PendingIntent` object is configured
    with `PendingIntent.FLAG_UPDATE_CURRENT` to ensure that if the pending `Intent`
    object already exists, it will be reused but with its extra data updated. `PendingIntent.FLAG_IMMUTABLE`
    is used for security purposes, marking the `Intent` object as immutable to prevent
    alterations after creation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `PendingIntent.getBroadcast` 方法来创建一个广播 `Intent` 对象的 `PendingIntent` 对象。此
    `PendingIntent` 对象配置了 `PendingIntent.FLAG_UPDATE_CURRENT` 以确保如果挂起的 `Intent` 对象已经存在，它将被重用，但其额外数据将被更新。`PendingIntent.FLAG_IMMUTABLE`
    用于安全目的，将 `Intent` 对象标记为不可变，以防止创建后进行更改。
- en: Finally, a `RemoteAction` object is instantiated and returned. This object takes
    the previously created icon, a title (`PendingIntent` object as its parameters.
    The title and content description should be concise yet descriptive enough to
    inform the user of the action’s purpose, adhering to accessibility standards.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实例化并返回一个 `RemoteAction` 对象。此对象接受先前创建的图标、标题（`PendingIntent` 对象）作为参数。标题和内容描述应简明扼要，但足以向用户说明操作的目的，符合无障碍标准。
- en: 'Now, we need to configure this action as a parameter for our PiP configuration.
    We will modify the existing configuration as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将此操作配置为我们的 PiP 配置的参数。我们将按以下方式修改现有配置：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are using the `setActions()` function to add a list including the new
    action.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `setActions()` 函数添加一个包含新操作的列表。
- en: 'The last step is to handle the logic to effectively toggle between play and
    pause. We already have this functionality implemented in the `ViewModel` component,
    so we just have to inject the `PlaybackViewModel` component in the `Activity`
    class and call the `togglePlayPause()` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是处理在播放和暂停之间有效切换的逻辑。我们已经在 `ViewModel` 组件中实现了此功能，所以我们只需在 `Activity` 类中注入 `PlaybackViewModel`
    组件并调用 `togglePlayPause()` 函数：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, we are injecting `PlaybackViewModel` and then, the `viewModel.toggle`
    **PlayPause()** function will be invoked when the receiver detects that the user
    has sent a broadcast with the play/pause action.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们正在注入 `PlaybackViewModel`，然后，当接收器检测到用户发送了带有播放/暂停操作的广播时，`viewModel.toggle`
    **PlayPause()** 函数将被调用。
- en: 'If we execute the code with these changes, we should see the **Play** button
    in our PiP UI:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这些更改执行代码，我们应该在我们的 PiP UI 中看到 **播放** 按钮：
- en: '![Figure 9.2: PiP view with some actions](img/B19443_09_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：带有一些操作的PiP视图](img/B19443_09_02.jpg)'
- en: 'Figure 9.2: PiP view with some actions'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：带有一些操作的PiP视图
- en: Having implemented PiP mode, let’s move on to connecting with other devices
    for media playback using the `MediaRouter` API, which allows your app to cast
    or stream content to devices such as smart TVs or Chromecast. We’ll cover how
    to use `MediaRouter` to identify compatible devices and manage media streaming
    to them, enhancing our app’s functionality.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了PiP模式后，让我们继续使用`MediaRouter` API连接到其他设备进行媒体播放，该API允许您的应用程序将内容投放到智能电视或Chromecast等设备。我们将介绍如何使用`MediaRouter`来识别兼容设备并管理对它们的媒体流式传输，从而增强应用程序的功能。
- en: Getting to know MediaRouter
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解MediaRouter
- en: '`MediaRouter` is a pivotal component in Android development, especially for
    applications that deal with multimedia content. It acts as a bridge between devices
    running your app and external devices such as Google Chromecast, smart TVs, and
    various speakers that support media routing capabilities.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaRouter`是Android开发中的一个关键组件，特别是对于处理多媒体内容的应用程序。它作为运行您的应用程序的设备和外部设备（如Google
    Chromecast、智能电视和多种支持媒体路由功能的扬声器）之间的桥梁。'
- en: The core function of `MediaRouter` is to facilitate the streaming of multimedia
    content—be it audio, video, or images—from the user’s current device to another
    device that provides a better or more suitable playback experience. It intelligently
    discovers available media routes and allows the application to connect to them,
    thereby extending the multimedia capabilities beyond the confines of the user’s
    primary device.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaRouter`的核心功能是促进多媒体内容的流式传输——无论是音频、视频还是图像——从用户的当前设备传输到另一个提供更好或更合适播放体验的设备。它智能地发现可用的媒体路由，并允许应用程序连接到它们，从而将多媒体功能扩展到用户主要设备的限制之外。'
- en: Android’s `MediaRouter` API provides a framework that developers can utilize
    to search for and interact with media route providers registered on the local
    network. These providers represent devices or services capable of media playback.
    With `MediaRouter`, applications can not only discover these routes dynamically
    but also present the user with a streamlined interface for choosing their preferred
    playback devices, all while managing the connections and playback state seamlessly
    across devices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Android的`MediaRouter` API提供了一个框架，开发人员可以利用它来搜索和与本地网络上注册的媒体路由提供者进行交互。这些提供者代表能够进行媒体播放的设备或服务。使用`MediaRouter`，应用程序不仅可以动态发现这些路由，还可以向用户提供一个简化的界面来选择他们首选的播放设备，同时无缝管理跨设备的连接和播放状态。
- en: 'The use of `MediaRouter` in Android apps opens up a myriad of possibilities
    for enhancing the user’s media consumption experience. Here are some typical use
    cases:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android应用程序中使用`MediaRouter`为增强用户的媒体消费体验提供了无数可能性。以下是一些典型的用例：
- en: '**Casting videos to larger screens**: One of the most common uses of **MediaRouter**
    is casting videos from a mobile device to a larger display, such as a smart TV
    or a monitor with Chromecast. This is particularly appealing for watching movies,
    TV shows, or user-generated content on a bigger screen that offers a more immersive
    viewing experience.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将视频投放到更大的屏幕上**：**MediaRouter**最常用的功能之一就是将移动设备上的视频投放到更大的显示设备上，例如智能电视或带有Chromecast的显示器。这对于在更大屏幕上观看电影、电视剧或用户生成的内容，以获得更沉浸式的观看体验尤其有吸引力。'
- en: '**Streaming music to external speakers**: **MediaRouter** allows apps to stream
    music to external speakers, amplifying the audio experience. This is ideal for
    parties, workouts, or simply enhancing the quality of music playback beyond what
    the phone’s or tablet’s built-in speakers can provide.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将音乐流式传输到外部扬声器**：**MediaRouter**允许应用程序将音乐流式传输到外部扬声器，增强音频体验。这对于派对、锻炼或简单地提升手机或平板电脑内置扬声器的音乐播放质量非常理想。'
- en: '**Displaying images on a shared screen**: Apps can use **MediaRouter** to send
    images to a smart TV or a connected display, making it perfect for sharing photos
    with a group, conducting presentations, or viewing artwork in higher resolution.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在共享屏幕上显示图像**：应用程序可以使用**MediaRouter**将图像发送到智能电视或连接的显示器，非常适合与一群人分享照片、进行演示或以更高分辨率查看艺术品。'
- en: '**Gaming**: With the capability to cast screen content to a larger display,
    gaming apps can leverage **MediaRouter** to provide a console-like gaming experience
    on the TV while using the mobile device as a controller.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏**：利用将屏幕内容投放到更大显示器的功能，游戏应用可以利用**MediaRouter**在电视上提供类似游戏机的游戏体验，同时使用移动设备作为控制器。'
- en: '**Fitness and education**: For apps focused on fitness or education, casting
    instructional videos or workout routines to a TV allows users to follow along
    more comfortably and effectively.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健身和教育**：对于专注于健身或教育的应用，将教学视频或锻炼计划投射到电视上，可以让用户更舒适、更有效地跟随。'
- en: In each of these use cases, `MediaRouter` significantly enhances the functionality
    of apps by leveraging the power of connected devices, thus offering users a more
    flexible and enriched media playback experience. Through its comprehensive API,
    developers can create applications that are not just confined to the small screens
    of mobile devices but are instead capable of bringing content to life on any compatible
    device within the home network.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些用例中，`MediaRouter` 通过利用连接设备的强大功能，显著增强了应用的功能，从而为用户提供更灵活和丰富的媒体播放体验。通过其全面的 API，开发者可以创建不仅限于移动设备小屏幕的应用程序，而是能够在家庭网络中的任何兼容设备上呈现内容的程序。
- en: Setting up MediaRouter
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 MediaRouter
- en: Integrating `MediaRouter` into our Android app involves a few key setup steps,
    including adding the necessary dependencies to your project and ensuring you have
    the correct permissions in place.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MediaRouter` 集成到我们的 Android 应用中涉及几个关键的设置步骤，包括将必要的依赖项添加到项目中，并确保您已设置正确的权限。
- en: 'First, we’ll need to include the `MediaRouter` library dependencies in our
    `libs.versions.toml` file. This library provides the classes and interfaces needed
    to discover and interact with media route providers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的 `libs.versions.toml` 文件中包含 `MediaRouter` 库依赖项。这个库提供了发现和与媒体路由提供者交互所需的类和接口：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we plan to support casting to Chromecast devices or other Google Cast-enabled
    devices, we need the `play-services-cast-framework` library. This library facilitates
    the integration with Google Cast devices and extends the capabilities of `MediaRouter`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们计划支持投射到 Chromecast 设备或其他 Google Cast 兼容设备，我们需要 `play-services-cast-framework`
    库。这个库促进了与 Google Cast 设备的集成，并扩展了 `MediaRouter` 的功能。
- en: 'The next step will be to add it to our `build.gradle` module:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是将其添加到我们的 `build.gradle` 模块中：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, to enable `MediaRouter` to discover and interact with devices on the local
    network, we must declare the necessary permissions in our app’s `AndroidManifest.xml`
    file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使 `MediaRouter` 能够发现和与本地网络上的设备交互，我们必须在应用的 `AndroidManifest.xml` 文件中声明必要的权限：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are including permissions here for the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此包括以下权限：
- en: '**Internet permission**: Since **MediaRouter** may use the network to communicate
    with media route providers, your app needs permission to access the internet.
    We have already needed to declare this permission for the previous chapters, so
    it shouldn’t be new.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网权限**：由于 **MediaRouter** 可能会使用网络与媒体路由提供者通信，您的应用需要权限来访问互联网。我们已经在之前的章节中需要声明此权限，因此不应是新的。'
- en: '**Network state permissions**: These permissions are required for the app to
    monitor changes in network connectivity, which is essential for discovering devices
    on the network.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络状态权限**：这些权限是应用监控网络连接变化所必需的，这对于在网络中发现设备至关重要。'
- en: '**Local network permissions (Android 12 and above)**: Starting with Android
    12 (API level 31), if your app targets API level 31 or higher and needs to discover
    devices on the local network, you must also declare the permission.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地网络权限（Android 12 及以上）**：从 Android 12（API 级别 31）开始，如果您的应用针对 API 级别 31 或更高版本，并且需要发现本地网络上的设备，您还必须声明此权限。'
- en: '**Post notifications**: For Android 12+, to access the local network for device
    discovery, it is mandatory to have this permission.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送通知**：对于 Android 12 及以上版本，为了访问本地网络进行设备发现，必须拥有此权限。'
- en: After adding the necessary dependencies and permissions, our project is ready
    to use `MediaRouter` for discovering media route providers and enabling media
    streaming to external devices.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加必要的依赖项和权限后，我们的项目就准备好使用 `MediaRouter` 来发现媒体路由提供者并启用媒体流到外部设备。
- en: Discovering media routes
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现媒体路由
- en: Once your app is set up with the necessary `MediaRouter` dependencies and permissions,
    the next step is discovering available media routes. This involves identifying
    external devices or services your app can stream media to. Android’s `MediaRouter`
    framework simplifies this by providing tools to both discover media routes and
    present them to users.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用设置了必要的 `MediaRouter` 依赖项和权限，下一步就是发现可用的媒体路由。这涉及到识别您的应用可以流式传输媒体的外部设备或服务。Android
    的 `MediaRouter` 框架通过提供发现媒体路由并将其呈现给用户的工具来简化这一过程。
- en: Learning about MediaRouteProvider
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解 MediaRouteProvider
- en: '`MediaRouteProvider` is a component that publishes media routes to `MediaRouter`.
    It acts as a bridge between your app and external devices or services, such as
    speakers, TVs, or other Cast-enabled devices. There are two options to use `MediaRouteProvider`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaRouteProvider` 是一个将媒体路由发布到 `MediaRouter` 的组件。它作为您的应用与外部设备或服务（如扬声器、电视或其他
    Cast 启用设备）之间的桥梁。使用 `MediaRouteProvider` 有两种选择：'
- en: 'The default **MediaRouteProvider** implementation: For most use cases, especially
    when integrating with Google Cast devices, Android provides a default **MediaRouteProvider**
    implementation, so you don’t need to implement your own. The Google Cast framework
    automatically discovers compatible devices and makes them available as media routes.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认 **MediaRouteProvider** 实现：对于大多数用例，尤其是在与 Google Cast 设备集成时，Android 提供了一个默认的
    **MediaRouteProvider** 实现，因此您不需要实现自己的。Google Cast 框架自动发现兼容设备并将它们作为媒体路由提供。
- en: 'A custom **MediaRouteProvider** implementation: If you need to discover devices
    for a custom protocol or a specific type of media routing not covered by Google
    Cast, you can implement your own **MediaRouteProvider** instance by extending
    the **MediaRouteProvider** class. This involves defining the discovery logic and
    publishing routes to **MediaRouter**.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 **MediaRouteProvider** 实现：如果您需要发现自定义协议或 Google Cast 未涵盖的特定类型的媒体路由设备，您可以通过扩展
    **MediaRouteProvider** 类来实现自己的 **MediaRouteProvider** 实例。这涉及到定义发现逻辑并向 **MediaRouter**
    发布路由。
- en: 'However, creating a custom `MediaRouteProvider` implementation is beyond the
    scope of basic media routing and requires in-depth knowledge of the specific hardware
    or protocol you’re targeting. If you want to know more, here is the official documentation
    to create a customized `MediaRouteProvider` implementation: [https://developer.android.com/media/routing/mediarouteprovider](https://developer.android.com/media/routing/mediarouteprovider).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建自定义的 `MediaRouteProvider` 实现超出了基本媒体路由的范围，并需要深入了解您针对的具体硬件或协议。如果您想了解更多信息，请参阅创建自定义
    `MediaRouteProvider` 实现的官方文档：[https://developer.android.com/media/routing/mediarouteprovider](https://developer.android.com/media/routing/mediarouteprovider)。
- en: We will use the default `MediaRouteProvider` implementation instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用默认的 `MediaRouteProvider` 实现。
- en: Using the MediaRouter class
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 MediaRouter 类
- en: The `MediaRouter` class is your primary tool for interacting with media routes.
    Here’s how you can use it to discover and monitor available media routes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaRouter` 类是您与媒体路由交互的主要工具。以下是您如何使用它来发现和监控可用媒体路由的示例。'
- en: 'We will begin by defining a `MediaRouteSelector` instance and allow it to start
    discovering other devices to send the media to. We will use `LaunchedEffect` to
    tie the discovery process to the composable’s lifecycle:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个 `MediaRouteSelector` 实例，并允许它开始发现其他设备以发送媒体。我们将使用 `LaunchedEffect` 将发现过程与可组合组件的生命周期绑定：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This composable function accepts a `MediaRouter` instance as a parameter, highlighting
    its dependency on this framework for discovering media routes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可组合函数接受一个 `MediaRouter` 实例作为参数，突出了它对该框架发现媒体路由的依赖性。
- en: The function begins by obtaining the current `Context` value using `LocalContext.current`,
    then it creates a `MediaRouterSelector` instance. This selector is specifically
    configured to filter for routes supporting live video content. The use of `remember`
    ensures that the `MediaRouteSelector` instance is preserved across recompositions
    of the composable, optimizing performance by preventing unnecessary reinitializations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先使用 `LocalContext.current` 获取当前的 `Context` 值，然后创建一个 `MediaRouterSelector`
    实例。此选择器专门配置为筛选支持实时视频内容的路由。使用 `remember` 确保在可组合组件的重构过程中保留 `MediaRouteSelector`
    实例，通过防止不必要的重新初始化来优化性能。
- en: Then, we are adding a `DisposableEffect` composable, which encapsulates the
    logic for starting and stopping media route discovery in alignment with the composable’s
    lifecycle. By passing `MediaRouter` as a key to `DisposableEffect`, the enclosed
    block of code is executed in a coroutine when the composable is first composed
    into the UI, and the coroutine is canceled when the composable is removed, effectively
    managing the lifecycle of the discovery process. Within this block, the `addCallback`
    method of `MediaRouter` is called to register a callback with the active scan
    flag, initiating the active scanning for media routes that match the criteria
    set by `routeSelector`. The `onDispose` block within `DisposableEffect` serves
    as a cleanup mechanism, where the callback is unregistered from `MediaRouter`
    when the composable is disposed of, ensuring resources are freed and background
    processing is minimized.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了一个 `DisposableEffect` 可组合组件，它封装了与可组合组件生命周期一致的启动和停止媒体路由发现逻辑。通过将 `MediaRouter`
    作为键传递给 `DisposableEffect`，当可组合组件首次组合到 UI 中时，封装的代码块将在协程中执行，当可组合组件被移除时，协程将被取消，从而有效地管理发现过程的生命周期。在这个块中，调用
    `MediaRouter` 的 `addCallback` 方法来注册一个带有活动扫描标志的回调，启动与 `routeSelector` 设置的标准匹配的媒体路由的主动扫描。`DisposableEffect`
    中的 `onDispose` 块充当清理机制，当可组合组件被销毁时，回调将从 `MediaRouter` 中注销，确保资源得到释放，后台处理最小化。
- en: 'Now, we will create a callback that we have included in the `addCallback` function
    described previously:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个回调，它包含在之前描述的 `addCallback` 函数中：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are instantiating a `MediaRouter.Callback` listener, using `remember` to
    avoid needing to recreate it every time the app’s UI updates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实例化一个 `MediaRouter.Callback` 监听器，使用 `remember` 来避免每次应用 UI 更新时都需要重新创建它。
- en: This listener, `MediaRouter.Callback`, has two main jobs through its `onRouteAdded`
    and `onRouteRemoved` methods. When a new device becomes available for casting
    media, `onRouteAdded` gets called, and the app adds this new route to a list called
    `mediaRoutes`. This list is crucial for the app to know what devices are available
    at any moment. On the flip side, when a device goes offline or disconnects, `onRouteRemoved`
    is called, and the app removes that route from the list, ensuring the list stays
    current.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个监听器，`MediaRouter.Callback`，通过其 `onRouteAdded` 和 `onRouteRemoved` 方法有两个主要任务。当一个新设备可用于媒体传输时，`onRouteAdded`
    被调用，并且应用将这个新路由添加到名为 `mediaRoutes` 的列表中。这个列表对于应用知道任何时刻可用的设备至关重要。另一方面，当一个设备离线或断开连接时，`onRouteRemoved`
    被调用，应用将此路由从列表中删除，确保列表保持最新。
- en: Effectively, this setup allows the app to dynamically adjust to changes in the
    available devices for media casting.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种设置允许应用动态调整可用的媒体传输设备的变化。
- en: 'To provide users with an easy way to select from these available devices, we
    need to integrate a button designed for this purpose. The `MediaRouter` API offers
    a ready-made button that displays the available devices for casting. Although
    this button is an Android view and not a composable, we can still use it in Jetpack
    Compose by wrapping it with the `AndroidView` composable. Here’s how we can do
    it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给用户提供一个方便的方式来选择这些可用的设备，我们需要集成一个为此目的设计的按钮。`MediaRouter` API 提供了一个显示可传输设备的现成按钮。尽管这个按钮是一个
    Android 视图而不是可组合组件，我们仍然可以使用 `AndroidView` 可组合组件来使用它。以下是我们可以如何做到这一点：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we just have to use the `MediaRouteDiscoveryOptions` composable from our
    playback screen:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需使用我们的回放屏幕中的 `MediaRouteDiscoveryOptions` 可组合组件：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we have added the `MediaRouteDiscoveryOptions` composable to our already
    existing `TopMediaRow` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将 `MediaRouteDiscoveryOptions` 可组合组件添加到我们现有的 `TopMediaRow` 函数中。
- en: 'When calling the `TopMediaRow` function we will pass it an instance of `mediaRouter`
    that we had obtained before, using `LocalContext`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `TopMediaRow` 函数时，我们将传递之前获得的 `mediaRouter` 实例，使用 `LocalContext`：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we will see the `PlaybackScreen` composable. If we click it, `MediaRouter`
    will automatically search for devices:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到 `PlaybackScreen` 可组合组件。如果我们点击它，`MediaRouter` 将会自动搜索设备：
- en: '![Figure 9.3: MediaRouter searching for devices](img/B19443_09_03.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：MediaRouter 搜索设备](img/B19443_09_03.jpg)'
- en: 'Figure 9.3: MediaRouter searching for devices'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：MediaRouter 搜索设备
- en: 'If it cannot find any device, it will show a message encouraging the user to
    check the connection:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它找不到任何设备，它将显示一条消息，鼓励用户检查连接：
- en: '![Figure 9.4: MediaRouter functionality, prompting the user to check the device
    connections](img/B19443_09_04.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4：MediaRouter 功能，提示用户检查设备连接](img/B19443_09_04.jpg)'
- en: 'Figure 9.4: MediaRouter functionality, prompting the user to check the device
    connections'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：MediaRouter 功能，提示用户检查设备连接
- en: 'After discovering available media routes using the `MediaRouter` API, the next
    step is connecting to a selected device for media playback. This involves two
    main actions: selecting a media route and then establishing a connection to that
    route. Here’s how you can approach this process.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `MediaRouter` API 发现可用的媒体路由后，下一步是连接到选定的设备进行媒体播放。这涉及两个主要操作：选择一个媒体路由，然后建立到该路由的连接。以下是你可以如何处理这个流程。
- en: When utilizing the built-in media route selector with `MediaRouteButton`, the
    process of connecting to a device is streamlined. `MediaRouteButton` automatically
    handles the display of available media routes based on the criteria defined in
    a `MediaRouteSelector` instance. Users can then select their preferred device
    directly from the UI that `MediaRouteButton` presents.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `MediaRouteButton` 内置的媒体路由选择器时，连接到设备的流程得到了简化。`MediaRouteButton` 会自动根据 `MediaRouteSelector`
    实例中定义的标准显示可用的媒体路由。用户可以从 `MediaRouteButton` 展示的 UI 中直接选择他们偏好的设备。
- en: Once a user selects a route from the dialog, the connection to that device is
    automatically managed by the `MediaRouter` framework based on the route’s capabilities
    and the types of media specified in your `MediaRouteSelector` instance. There’s
    no need for additional manual connection management in your application code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户从对话框中选择了一条路由，`MediaRouter` 框架就会根据路由的能力和你在 `MediaRouteSelector` 实例中指定的媒体类型自动管理到该设备的连接。在你的应用程序代码中不需要额外的手动连接管理。
- en: With the route selected and a connection established, you can control media
    playback through the selected route. This typically involves using media control
    APIs that are appropriate for your application’s media content and the capabilities
    of the selected route. We will learn how can we cast media playback for Google
    Cast devices in the next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了路由并建立了连接后，你可以通过选定的路由控制媒体播放。这通常涉及使用适合你应用程序的媒体内容和所选路由能力的媒体控制 API。我们将在下一节学习如何为
    Google Cast 设备投射媒体播放。
- en: Connecting to Google Chromecast devices
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 Google Chromecast 设备
- en: Google Cast is a powerful technology developed by Google that allows users to
    wirelessly stream audio and video content from their smartphones, tablets, or
    computers directly to Cast-enabled devices. This technology is embedded in a wide
    array of devices, including Chromecast dongles, smart TVs, and speakers, making
    it accessible to a vast user base. At its core, Google Cast works by establishing
    a connection between a Cast-enabled app on a mobile device or computer and a Cast-enabled
    receiver device. Once a connection is made, media can be played back on the receiver
    device, effectively turning it into a remote screen or speaker for the content
    being cast.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cast 是由 Google 开发的一项强大技术，它允许用户将智能手机、平板电脑或电脑上的音频和视频内容无线流式传输到支持 Cast 的设备。这项技术嵌入到各种设备中，包括
    Chromecast 拓展器、智能电视和扬声器，使其能够服务于广泛的用户群体。在核心上，Google Cast 通过在移动设备或电脑上的支持 Cast 的应用程序和支持
    Cast 的接收设备之间建立连接来工作。一旦建立连接，媒体就可以在接收设备上播放，有效地将其转变为被投射内容的远程屏幕或扬声器。
- en: The functionality of Google Cast is not limited to streaming media from the
    internet. It also enables the mirroring of content from the sender device’s screen,
    extending its utility to presentations, educational content, and more. Google
    Cast operates over Wi-Fi, ensuring high-quality streaming performance without
    the need for physical cables or adapters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cast 的功能不仅限于从互联网流式传输媒体。它还允许从发送设备屏幕镜像内容，扩展其用途到演示、教育内容等。Google Cast 通过
    Wi-Fi 运行，确保高质量流式传输性能，无需物理电缆或适配器。
- en: 'We have already done some steps: we have already included the library and we
    are already detecting the devices that allow casting. Now, we need to establish
    a cast session. This session facilitates a connection between your app and the
    selected Cast device, enabling media control and playback on the larger screen.
    This process hinges on effectively using `CastContext` and adeptly managing Cast
    session events.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了一些步骤：我们已经包含了库，并且正在检测允许投射的设备。现在，我们需要建立一个投射会话。这个会话促进了你的应用程序和所选 Cast 设备之间的连接，使得可以在大屏幕上进行媒体控制和播放。这个过程依赖于有效地使用
    `CastContext` 和熟练地管理 Cast 会话事件。
- en: '`CastContext` is central to initiating and managing Cast sessions in your application,
    providing the necessary APIs to connect to the selected Cast device. Here’s how
    to initiate a connection.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`CastContext` 在你的应用程序中启动和管理 Cast 会话中起着核心作用，提供了连接到所选 Cast 设备所需的 API。以下是初始化连接的方法。'
- en: 'First, we need to ensure that you have initialized `CastContext` in your application.
    This is typically done in the `Application` subclass or your main activity. We
    will initialize it in our `PlaybackActivity` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保你在应用程序中初始化了 `CastContext`。这通常在 `Application` 子类或你的主活动中完成。我们将在 `PlaybackActivity`
    类中初始化它：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, we need to select a device. We have already implemented `MediaRouterbutton`,
    which will automatically handle the selection. Once a device is selected, the
    Cast SDK automatically initiates a connection to the device. This process is abstracted
    away from the developer, but it’s crucial to listen for session events to manage
    the connection effectively.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要选择一个设备。我们已实现了 `MediaRouterbutton`，它将自动处理选择。一旦选择了一个设备，Cast SDK 将自动启动到该设备的连接。这个过程对开发者来说是抽象的，但监听会话事件对于有效地管理连接至关重要。
- en: The Cast SDK provides callbacks for session events such as starting, ending,
    resuming, and suspending. Handling these events allows your app to respond to
    changes in the session state, such as updating the UI or pausing media playback
    when the session ends.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Cast SDK 为会话事件（如启动、结束、恢复和挂起）提供回调。处理这些事件允许你的应用程序对会话状态的变化做出反应，例如，在会话结束时更新 UI 或暂停媒体播放。
- en: 'To listen to these session events, we must implement `SessionManagerListener`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '要监听这些会话事件，我们必须实现 `SessionManagerListener`:'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we are implementing our `SessionManagerListener<CastSession>` interface,
    crucial for managing Google Cast sessions. This listener is designed to react
    to various events related to the lifecycle of a Cast session, including its start,
    end, resumption, and failure cases. Let’s look deeper into this implementation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在实现我们的 `SessionManagerListener<CastSession>` 接口，这对于管理 Google Cast 会话至关重要。这个监听器旨在对与
    Cast 会话生命周期相关的各种事件做出反应，包括其开始、结束、恢复和失败情况。让我们更深入地看看这个实现：
- en: '**onSessionStarted**: This callback is invoked when a new Cast session has
    successfully started. Here, the **session** parameter, which is an instance of
    **CastSession**, represents the newly established session. The method sets the
    global **castSession** variable to this instance, effectively marking the beginning
    of a session. Subsequently, it calls **updateUIForCastSession(true)**, a method
    that will be implemented to update the application’s UI to reflect that casting
    has started.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onSessionStarted**: 当一个新的 Cast 会话成功启动时，此回调被调用。在这里，**session** 参数，它是一个 **CastSession**
    的实例，代表了新建立的会话。该方法将全局 **castSession** 变量设置为该实例，有效地标志着会话的开始。随后，它调用 **updateUIForCastSession(true)**，这是一个将实现的方法，用于更新应用程序的
    UI 以反映传输已经开始。'
- en: '**onSessionEnded**: Triggered when an existing Cast session ends, this method
    clears the **castSession** variable by setting it to **null**, indicating that
    there is no longer an active Cast session. It also invokes **updateUIForCastSession(false)**
    to adjust the UI, signaling to the user that casting has stopped.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onSessionEnded**: 当现有的 Cast 会话结束时触发，此方法通过将其设置为 **null** 来清除 **castSession**
    变量，表示不再有活跃的 Cast 会话。它还调用 **updateUIForCastSession(false)** 来调整 UI，向用户发出信号，表示传输已停止。'
- en: '**onSessionResumed**: Similar to **onSessionStarted**, this callback is called
    when a previously suspended Cast session is resumed. It updates **castSession**
    with the current session and calls **updateUIForCastSession(true)** to reflect
    the resumption of casting in the UI.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onSessionResumed**: 与 **onSessionStarted** 类似，当先前挂起的 Cast 会话恢复时，此回调被调用。它使用当前会话更新
    **castSession** 并调用 **updateUIForCastSession(true)** 以在 UI 中反映传输的恢复。'
- en: '**onSessionStarting** and **onSessionResuming**: Indicate that a session is
    in the process of starting or resuming but has not yet completed. No action is
    taken in these callbacks in our case.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onSessionStarting** 和 **onSessionResuming**: 指示会话正在启动或恢复，但尚未完成。在我们的情况下，这些回调中不采取任何操作。'
- en: '**onSessionStartFailed** and **onSessionResumeFailed**: Called when attempts
    to start or resume a session fail. Again, no action is specified in our case,
    but these would be appropriate places to handle errors, such as by notifying the
    user or attempting to restart the session.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onSessionStartFailed** 和 **onSessionResumeFailed**: 当尝试启动或恢复会话失败时被调用。同样，在我们的情况下没有指定任何操作，但这些是处理错误（例如，通知用户或尝试重新启动会话）的适当位置。'
- en: '**onSessionEnding** and **onSessionSuspended**: These callbacks are triggered
    when a session is in the process of ending or being suspended. As with the start
    and resume events, no specific actions are taken in these cases.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onSessionEnding** 和 **onSessionSuspended**：这些回调在会话正在结束或暂停过程中被触发。与开始和恢复事件一样，在这些情况下不采取任何特定操作。'
- en: 'Once we have implemented our listener, we need to register it using `castContext.sessionManager`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了我们的监听器，我们需要使用 `castContext.sessionManager` 来注册它：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we are registering the listener when the `Activity` class is started and
    removing it when it is stopped. That way, we ensure that the listener is only
    retained when the `Activity` class is in a started state.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们是在 `Activity` 类启动时注册监听器，并在它停止时移除它。这样，我们确保只有在 `Activity` 类处于启动状态时，监听器才会被保留。
- en: 'Now, let’s implement the `updateUIForCastSession` function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现 `updateUIForCastSession` 函数：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are calling a new function that we will include next in the `ViewModel`
    component, called `setCastingState`. We are passing a Boolean as the argument,
    indicating whether the app is casting or not.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在调用一个新函数，我们将在 `ViewModel` 组件中包含它，称为 `setCastingState`。我们传递一个布尔值作为参数，指示应用程序是否正在传输。
- en: 'In our `PlaybackViewModel` component, we will introduce the following changes.
    We will start adding a new property, `isCasting`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `PlaybackViewModel` 组件中，我们将引入以下更改。我们将开始添加一个新的属性，`isCasting`：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we will change its value when the `setCastingState` function is called:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当调用 `setCastingState` 函数时，我们将更改其值：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will use it in our `PlaybackScreen` composable:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在我们的 `PlaybackScreen` 组合组件中使用它：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In our already existing `PlaybackScreen` composable, we have added a new property,
    `isCasting`. This property is used to choose if the screen will show a **Now Casting**
    message or the complete playback UI.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现有的 `PlaybackScreen` 组合组件中，我们添加了一个新的属性，`isCasting`。这个属性用于选择屏幕是否显示 **正在传输**
    消息或完整的播放用户界面。
- en: 'Next, we will build a new `NowCastingView` composable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个新的 `NowCastingView` 组合组件：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This composable is just placing and showing a text with the **Now Casting**
    content, just to make the user aware that the media content is currently being
    cast to another device.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合组件只是放置并显示一个包含 **正在传输** 内容的文本，只是为了让用户意识到媒体内容目前正在传输到另一个设备。
- en: 'There’s just one thing that we must do: load the media in the remote device.
    We will modify the `onSessionStarted` callback in the `SessionManagerListener`
    interface, including a call to a new function to load the media:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的一件事是：在远程设备上加载媒体。我们将修改 `SessionManagerListener` 接口中的 `onSessionStarted`
    回调，包括调用一个新函数来加载媒体：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we will implement this function as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将如下实现这个函数：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The function begins by constructing a `MediaInfo` object, which encapsulates
    all necessary details about the media file intended for playback. Utilizing the
    `MediaInfo.Builder` pattern, it starts with specifying the media’s URL, sourced
    from `viewModel.mediaUrl`. This URL is the location of the media file, which the
    Cast-enabled device will stream. The builder then sets the stream type to `MediaInfo.STREAM_TYPE_BUFFERED`,
    indicating that the content is pre-recorded and can be buffered before playback,
    which is ideal for video content that isn’t being streamed live. Furthermore,
    the content type is set to `"video/mp4"`, defining the **MIME** type (**Multipurpose
    Internet Mail Extensions**, used not only by email but also by web browsers and
    apps to interpret and display content correctly.) of the file as an MP4 video.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先构建一个 `MediaInfo` 对象，它封装了关于要播放的媒体文件的所有必要细节。利用 `MediaInfo.Builder` 模式，它从 `viewModel.mediaUrl`
    指定媒体的 URL，这是媒体文件的存储位置，Cast 兼容设备将从中流式传输。然后，构建器将流类型设置为 `MediaInfo.STREAM_TYPE_BUFFERED`，表示内容是预先录制的，可以在播放前进行缓冲，这对于不进行实时流式传输的视频内容来说非常理想。此外，内容类型被设置为
    `"video/mp4"`，定义了文件的 **MIME** 类型（**多用途互联网邮件扩展**，不仅用于电子邮件，还用于网页浏览器和应用程序来正确解释和显示内容）作为
    MP4 视频。
- en: Following the creation of the `MediaInfo` object, the function proceeds to configure
    additional playback options through a `MediaLoadOptions` object. The options set
    include `setAutoplay(true)`, which commands the Cast device to automatically start
    playing the media as soon as it’s loaded, and `setPlayPosition(0)`, ensuring that
    playback commences from the very beginning of the media file, for simplicity.
    One improvement to this could be to obtain the current play position from the
    `ViewModel` component so that the video can continue at the same point in time
    if the playback has already started.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`MediaInfo`对象之后，函数继续通过`MediaLoadOptions`对象配置额外的播放选项。设置的选项包括`setAutoplay(true)`，该命令指示Cast设备在加载后自动开始播放媒体，以及`setPlayPosition(0)`，确保播放从媒体文件的开始处开始，以简化操作。对此的一个改进可能是从`ViewModel`组件获取当前的播放位置，以便如果播放已经开始，视频可以继续在相同的时间点播放。
- en: The final step in the `loadMedia` function involves invoking the `load` method
    on the `castSession` variable’s `remoteMediaClient` instance. This method call
    is where the media loading and playback command is actually sent to the Cast-enabled
    device. `remoteMediaClient` acts as the intermediary, transmitting commands from
    the app to the receiver. By passing the `MediaInfo` object and `MediaLoadOptions`
    to this method, the app specifies what to play and how it should be played, effectively
    initiating the streaming of video content to the Cast device.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadMedia`函数的最后一步是在`castSession`变量的`remoteMediaClient`实例上调用`load`方法。这个方法调用实际上是向启用Cast的设备发送媒体加载和播放命令的地方。`remoteMediaClient`充当中间人，将命令从应用传输到接收器。通过将`MediaInfo`对象和`MediaLoadOptions`传递给此方法，应用指定了要播放的内容以及如何播放，从而有效地启动视频内容到Cast设备的流式传输。'
- en: Now, our app is ready to start casting to Google Cast devices. With that, we
    have finished this chapter and learned the vast possibilities of playback in Android
    and other connected devices.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用已经准备好开始向Google Cast设备进行投屏。随着这一点，我们完成了这一章节，并学习了在Android和其他连接设备上播放的广泛可能性。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we tackled the essentials of extended video playback on Android,
    focusing on making our app more engaging by allowing videos to play in other contexts.
    We covered two main areas: PiP mode and media casting, both aimed at keeping our
    users connected to their content, whether they’re multitasking on their device
    or looking to enjoy videos on a larger screen.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在Android上扩展视频播放的基本知识，重点是让我们的应用在更多上下文中播放视频。我们涵盖了两个主要领域：PiP模式和媒体投屏，两者都旨在让我们的用户保持与内容的连接，无论他们是在设备上多任务处理还是想要在大屏幕上享受视频。
- en: Starting with PiP, we walked through how to enable a video to continue playing
    in a small window while users navigate away from the app. This section detailed
    everything from modifying your app’s manifest to implementing PiP mode, ensuring
    users won’t have to pause their viewing experience when they need to use another
    app.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从PiP模式开始，我们探讨了如何在用户离开应用时，让视频在一个小窗口中继续播放。本节详细介绍了从修改应用清单到实现PiP模式的所有内容，确保用户在使用其他应用时不需要暂停他们的观看体验。
- en: Next, we shifted focus to media casting, particularly with `MediaRouter` and
    the Cast SDK for devices such as Google Chromecast. Here, you learned how to let
    users send video from their mobile device to a TV. We discussed using `MediaRouteButton`
    for easy device discovery and connection, as well as how to create a custom UI
    for users who want more control over the casting process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将焦点转向媒体投屏，特别是针对Google Chromecast等设备的`MediaRouter`和Cast SDK。在这里，你学习了如何让用户从他们的移动设备向电视发送视频。我们讨论了使用`MediaRouteButton`进行轻松的设备发现和连接，以及如何为希望对投屏过程有更多控制的用户创建自定义UI。
- en: By the end of this chapter, you should have understood how to implement PiP
    for in-app multitasking and set up casting to external devices. These skills are
    key to creating Android apps that offer flexible and user-friendly video playback
    experiences. Whether it’s keeping a video running in a corner of the screen or
    sharing a favorite movie on a big TV, your app can now cater to various user needs,
    enhancing overall engagement with your video content.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该已经了解了如何实现PiP模式以支持应用内多任务处理，并设置外部设备的投屏。这些技能对于创建提供灵活且用户友好的视频播放体验的Android应用至关重要。无论是保持视频在屏幕角落运行，还是在大电视上分享喜欢的电影，你的应用现在可以满足各种用户需求，增强与视频内容的整体互动。
- en: 'And with that, we’ve reached the end of our journey, where we built key features
    for three types of apps: a messaging app, a social platform, and a video app.
    Each project aimed to deepen your Android and Kotlin development skills and inspire
    you to think about how you can apply these ideas to your own work.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的旅程走到了尽头，我们为三种类型的应用构建了关键功能：一个即时通讯应用、一个社交平台和一个视频应用。每个项目都旨在加深您的Android和Kotlin开发技能，并激发您思考如何将这些想法应用到您自己的工作中。
- en: Thank you for reading this book. I hope it has not only broadened your knowledge
    but also sparked new ideas for your projects. With the tools and techniques you’ve
    learned, you’re well prepared to advance your career and start building your own
    innovative apps. Here’s to your success in the field of mobile development – go
    out there and make great things!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您阅读这本书。我希望它不仅拓宽了您的知识面，也为您的项目激发了新的想法。凭借您所学的工具和技术，您已经做好了准备，去提升您的职业生涯并开始构建您自己的创新应用。祝您在移动开发领域取得成功——走出去，创造伟大事物吧！
