- en: Chapter 10. A First Look at OpenGL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 初识OpenGL ES
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up the OpenGL ES environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置OpenGL ES环境
- en: Drawing shapes on GLSurfaceView
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GLSurfaceView上绘制形状
- en: Applying projection and camera view while drawing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在绘图时应用投影和相机视图
- en: Moving the triangle with rotation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过旋转移动三角形
- en: Rotating the triangle with user input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户输入旋转三角形
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As we saw in the previous chapter, Android offers many tools for handling graphics
    and animations. Though the canvas and drawable objects are designed for custom
    drawing, when you need high performance graphics, especially 3D gaming graphics,
    Android also supports OpenGL ES. **Open Graphics Library for Embedded Systems**
    (**OpenGL ES**), is targeted for embedded system. (Embedded systems include consoles
    and phones.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，Android提供了许多处理图形和动画的工具。尽管画布和可绘制对象是为自定义绘图设计的，但在你需要高性能图形，尤其是3D游戏图形时，Android也支持OpenGL
    ES。**嵌入式系统开放图形库**（**OpenGL ES**）针对嵌入式系统。（嵌入式系统包括游戏机和手机。）
- en: This chapter is meant to serve as an introduction to using OpenGL ES on Android.
    As usual, we'll provide the steps and explain how things work, but we aren't going
    to be digging into the math or technical details of OpenGL. If you are already
    familiar with OpenGL ES from other platforms, such as iOS, this chapter should
    get you up and running quickly. If you are new to OpenGL, hopefully, these recipes
    will help you decide whether this is an area you want to pursue.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在作为在Android上使用OpenGL ES的入门介绍。像往常一样，我们将提供步骤并解释其工作原理，但不会深入探讨OpenGL的数学或技术细节。如果你已经熟悉来自其他平台（如iOS）的OpenGL
    ES，本章应该能让你快速上手。如果你是OpenGL的新手，希望这些食谱能帮助你决定是否想在这个领域继续深入。
- en: 'Android supports the following versions of OpenGL:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持以下版本的OpenGL：
- en: '**OpenGL ES 1.0**: Android 1.0'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 1.0**：Android 1.0'
- en: '**OpenGL ES 2.0**: Introduced in Android 2.2 (API 8)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 2.0**：在Android 2.2（API 8）中引入'
- en: '**OpenGL ES 3.0**: Introduced in Android 4.3 (API 18)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 3.0**：在Android 4.3（API 18）中引入'
- en: '**OpenGL ES 3.1**: Introduced in Android 5.0 (API 21)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 3.1**：在Android 5.0（API 21）中引入'
- en: The recipes for this chapter are of an introductory nature and target OpenGL
    ES 2.0 and higher. OpenGL ES 2.0 is available for nearly all devices currently
    available. Unlike OpenGL ES 2.0 and lower, OpenGL 3.0 and higher require driver
    implementation from the hardware manufacturer. This means, even if your application
    is running on Android 5.0, OpenGL 3.0 and higher may not be available. Therefore,
    it's a good programming practice to check the available OpenGL versions at runtime.
    Alternatively, if your application requires 3.0 and higher features, you can add
    a `<uses-feature/>` element to your Android manifest. (We'll discuss this in the
    first recipe that follows.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的食谱具有入门性质，针对OpenGL ES 2.0及以上版本。OpenGL ES 2.0几乎适用于目前所有可用的设备。与OpenGL ES 2.0及以下版本不同，OpenGL
    3.0及以上版本需要硬件制造商提供驱动程序实现。这意味着，即使你的应用程序运行在Android 5.0上，OpenGL 3.0及以上版本可能不可用。因此，在运行时检查可用的OpenGL版本是一种良好的编程实践。或者，如果你的应用程序需要3.0及以上版本的功能，你可以在Android清单中添加一个`<uses-feature/>`元素。（我们将在接下来的第一个食谱中讨论这个问题。）
- en: Unlike the other chapters in this book, this chapter is written more as a tutorial
    with each recipe building on lessons learned from the previous recipe. The *Getting
    ready* section of each recipe will clarify the prerequisites.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他章节不同，本章更像是一个教程，每个食谱都是基于前一个食谱中学到的经验。每个食谱的“准备”部分将明确说明先决条件。
- en: Set up the OpenGL ES environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置OpenGL ES环境
- en: Our first recipe will start by showing the steps to set up an activity to use
    an OpenGL `GLSurfaceView`. Similar to the Canvas, the `GLSurfaceView` is where
    your will perform your OpenGL drawing. As this is the starting point, the other
    recipes will refer to this recipe as the base step when they need a `GLSurfaceView`
    created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一道食谱将从展示如何设置一个活动来使用OpenGL `GLSurfaceView`的步骤开始。类似于Canvas，`GLSurfaceView`是你将执行OpenGL绘图的地方。由于这是起点，其他食谱在需要创建`GLSurfaceView`时，将把这个食谱作为基础步骤进行引用。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `SetupOpenGL`. Use the
    default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为：`SetupOpenGL`。使用默认的**手机和平板电脑**选项，并在提示**活动类型**时选择**空活动**。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll start by indicating the application''s use of OpenGL in the Android
    Manifest, and then we''ll add the OpenGL classes to the activity. Here are the
    steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在AndroidManifest中指明应用程序使用OpenGL，然后我们将OpenGL类添加到活动中。以下是步骤：
- en: 'Open the Android Manifest and add the following XML:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开AndroidManifest并添加以下XML：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并添加以下全局变量：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following inner class to the `MainActivity` class:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内部类添加到`MainActivity`类中：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add another inner class to the `MainActivity` class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个内部类添加到`MainActivity`类中：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code to the existing `onCreate()` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的`onCreate()`方法中：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行应用程序在设备或模拟器上了。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you ran the preceding application, you saw the activity created and the
    background set to gray. Since these are the basic steps to setting up OpenGL,
    you''ll be reusing this code for the other recipes in this chapter as well. Here
    is the process explained in detail:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了前面的应用程序，你应该看到了创建的活动和背景被设置为灰色。由于这些是设置OpenGL的基本步骤，你将在本章的其他菜谱中重用此代码。以下是详细解释的过程：
- en: Declaring OpenGL in the Android Manifest
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在AndroidManifest中声明OpenGL
- en: 'We start by declaring our requirement to use OpenGL ES version 2.0 in the Android
    Manifest with this line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过以下行在AndroidManifest中声明我们使用OpenGL ES版本2.0的需求：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we were using Version 3.0, we would use this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用版本3.0，我们会使用这个：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For Version 3.1, use this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于版本3.1，使用这个：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Extending the GLSurfaceView class
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展GLSurfaceView类
- en: 'Create a custom OpenGL `SurfaceView` class by extending `GLSurfaceView`, as
    we do in this code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展`GLSurfaceView`创建一个自定义的OpenGL `SurfaceView`类，就像我们在代码中所做的那样：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we instantiate an OpenGL rendered class and pass it to the `GLSurfaceView`
    class with the `setRenderer()` method. The OpenGL `SurfaceView` provides a surface
    for our OpenGL drawing, similar to the `Canvas` and `SurfaceView` objects. The
    actual drawing is done in the `Renderer`, which we''ll create next:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化一个OpenGL渲染类，并通过`setRenderer()`方法将其传递给`GLSurfaceView`类。OpenGL `SurfaceView`为我们提供了OpenGL绘图的表面，类似于`Canvas`和`SurfaceView`对象。实际的绘图是在`Renderer`中完成的，我们将在下一步创建它：
- en: Creating an OpenGL rendered class
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个OpenGL渲染类
- en: 'The last step is to create the `GLSurfaceView.Renderer` class and implement
    the following three callbacks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建`GLSurfaceView.Renderer`类并实现以下三个回调：
- en: '`onSurfaceCreated()`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceCreated()`'
- en: '`onDrawFrame()`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDrawFrame()`'
- en: '`onSurfaceChanged()`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceChanged()`'
- en: 'Here is the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Right now, all we're doing with this class is setting up the callbacks and clearing
    the screen using the color we specify with `glClearColor()` (gray in this case).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们使用这个类所做的只是设置回调和清除屏幕，使用我们通过`glClearColor()`指定的颜色（在这种情况下是灰色）。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With the OpenGL environment set up, we'll continue to the next recipe where
    we'll actually draw on the view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好OpenGL环境后，我们将继续到下一个菜谱，我们将实际在视图中绘制。
- en: Drawing shapes on GLSurfaceView
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GLSurfaceView上绘制形状
- en: The previous recipe set up the activity to use OpenGL. This recipe will continue
    by showing how to draw on `OpenGLSurfaceView`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个菜谱设置了活动以使用OpenGL。这个菜谱将继续展示如何在`OpenGLSurfaceView`上绘制。
- en: First, we need to define the shape. With OpenGL, it is important to realize
    the order in which the vertices of a shape are defined are very important, as
    they determine the front (face) and back of the shape. It's customary (and the
    default behavior) to define the vertices counter clockwise. (Though this behavior
    can be changed, it requires additional code and is not standard practice.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义形状。使用OpenGL时，重要的是要意识到形状顶点的定义顺序非常重要，因为它们决定了形状的前面（面）和背面。通常（并且是默认行为）是逆时针定义顶点。（尽管这种行为可以改变，但它需要额外的代码，并且不是标准实践。）
- en: 'It''s also important to understand the OpenGL screen coordinate system, as
    it differs from the Android canvas. The default coordinate system defines (`0,0,0`)
    as the center of the screen. The four edge points are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理解OpenGL屏幕坐标系也很重要，因为它与Android画布不同。默认坐标系定义(`0,0,0`)为屏幕中心。四个边缘点如下：
- en: '**Top left**: (-1.0, 1.0, 0)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左上角**：(-1.0, 1.0, 0)'
- en: '**Top right**: (1.0, 1.0, 0)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右上角**：(1.0, 1.0, 0)'
- en: '**Bottom left**: (-1.0, -1.0, 0)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左下角**：(-1.0, -1.0, 0)'
- en: '**Bottom right**: (1.0, -1.0, 0)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右下角**：(1.0, -1.0, 0)'
- en: The *Z* axis comes straight out of the screen or straight behind.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Z*轴直接从屏幕中出来或直接在屏幕后面。'
- en: 'Here is an illustration showing the *X*, *Y*, and *Z* axes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显示*X*，*Y*和*Z*轴的插图：
- en: '![Drawing shapes on GLSurfaceView](img/B05057_10_01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![在GLSurfaceView上绘制形状](img/B05057_10_01.jpg)'
- en: 'We''re going to create a `Triangle` class since it is the base shape. In OpenGL,
    you generally use a collection of triangles to create objects. To draw a shape
    with OpenGL, we need to define the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Triangle`类，因为它是基本形状。在OpenGL中，通常使用三角形的集合来创建对象。要使用OpenGL绘制形状，我们需要定义以下内容：
- en: '**Vertex shader**: This is to draw the shape'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这是用来绘制形状的'
- en: '**Fragment shader**: This is to color the shape'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这是用来着色形状的'
- en: '**Program**: This is an OpenGL ES object for the preceding shaders'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序**：这是用于前面着色器的OpenGL ES对象'
- en: The shaders are defined using **OpenGL Shading Language** (**GLSL**), and then
    compiled and added to the OpenGL program object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器使用**OpenGL着色语言（GLSL）**定义，然后编译并添加到OpenGL程序对象中。
- en: 'Here are two screenshots showing the triangle in both portrait and landscape
    orientation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两张截图显示了肖像和横幅方向下的三角形：
- en: '![Drawing shapes on GLSurfaceView](img/B05057_10_02.jpg)![Drawing shapes on
    GLSurfaceView](img/B05057_10_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![在GLSurfaceView上绘制形状](img/B05057_10_02.jpg)![在GLSurfaceView上绘制形状](img/B05057_10_03.jpg)'
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `ShapesWithOpenGL`. Use
    the default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为：`ShapesWithOpenGL`。使用默认的**手机和平板**选项，并在提示**活动类型**时选择**空活动**。
- en: This recipe uses the OpenGL environment created in the previous recipe *Set
    up the Open GL environment*. Refer to the previous recipe if you have not already
    completed those steps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用前一个菜谱中创建的OpenGL环境*设置OpenGL环境*。如果你还没有完成这些步骤，请参考前一个菜谱。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As indicated previously, we''ll be using the OpenGL environment created in
    the previous recipe. The steps that follow will walk you through creating a class
    for the triangle shape and drawing it on the GLSurfaceView:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用前一个菜谱中创建的OpenGL环境。以下步骤将指导你创建一个用于三角形形状的类，并在GLSurfaceView上绘制它：
- en: Create a new Java class called `Triangle`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Triangle`的新Java类。
- en: 'Add the following global declarations to the `Triangle` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下全局声明添加到`Triangle`类中：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following `loadShader()` method to the `Triangle` class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`loadShader()`方法添加到`Triangle`类中：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `Triangle` constructor, as shown:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式添加`Triangle`构造函数：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the `draw()` method, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式添加`draw()`方法：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now open `MainActivity.java` and add a `Triangle` variable to the `GLRenderer`
    class as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`MainActivity.java`文件，并在`GLRenderer`类中添加一个`Triangle`变量，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize the `Triangle` variable in the `onSurfaceCreated()` callback, as
    follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSurfaceCreated()`回调中初始化`Triangle`变量，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call the `draw()` method in the `onDrawFrame()` callback:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onDrawFrame()`回调中调用`draw()`方法：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As mentioned in the introduction, to draw with OpenGL, we first have to define
    the shaders, which we do with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，要使用OpenGL绘制，我们首先必须定义着色器，这可以通过以下代码完成：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since this is uncompiled **OpenGL Shading Language** (**OpenGLSL**), the next
    step is to compile and attach it to our OpenGL object, which we do with the following
    two OpenGL ES methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是未编译的**OpenGL着色语言（OpenGLSL）**，下一步是将它编译并附加到我们的OpenGL对象上，我们使用以下两个OpenGL ES方法来完成：
- en: '`glAttachShader()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glAttachShader()`'
- en: '`glLinkProgram()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glLinkProgram()`'
- en: After setting up the shaders, we create `ByteBuffer` to store the triangle vertices,
    which are defined in `triangleCoords`. The `draw()` method is where the actual
    drawing occurs using the GLES20 library calls, which is called from the `onDrawFrame()`
    callback.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好着色器后，我们创建`ByteBuffer`来存储三角形顶点，这些顶点在`triangleCoords`中定义。`draw()`方法是在`onDrawFrame()`回调中调用GLES20库调用进行实际绘制的位置。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may have noticed, from the screenshots in the introduction, that the triangles
    in the Portrait and Landscape do look identical. As you can see from the code,
    we make no distinction in the orientation when drawing. We'll explain why this
    is happening and show how to correct this issue in the next recipe.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，从介绍中的截图来看，肖像和横幅模式下的三角形看起来确实相同。正如你从代码中看到的，我们在绘制时没有对方向进行区分。我们将解释为什么会发生这种情况，并展示如何在下一个菜谱中纠正这个问题。
- en: See also
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information on the OpenGL Shading Language, refer the following link:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于OpenGL着色语言（OpenGL Shading Language）的更多信息，请参考以下链接：
- en: '[https://www.opengl.org/documentation/glsl/](https://www.opengl.org/documentation/glsl/)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.opengl.org/documentation/glsl/](https://www.opengl.org/documentation/glsl/)'
- en: Applying Projection and Camera View while drawing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制时应用投影和相机视图
- en: As we saw in the previous recipe, when we draw our shape to the screen, the
    shape is skewed by the screen orientation. The reason for this is because, by
    default, OpenGL assumes a perfectly square screen. We mentioned before, the default
    screen coordinates for the top right is (1,1,0) and bottom left is (-1,-1,0).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个配方中看到的，当我们将形状绘制到屏幕上时，形状会因为屏幕方向而倾斜。原因是默认情况下，OpenGL 假设屏幕是完美的正方形。我们之前提到，默认屏幕坐标中右上角是
    (1,1,0)，左下角是 (-1,-1,0)。
- en: 'Since most device screens are not perfectly square, we need to map the display
    coordinates to match our physical device. In OpenGL, we do this with *Projection*.
    This recipe will show how to use Projection to match the GLSurfaceView coordinates
    with the device coordinates. Along with the Projection, we''ll also show how to
    set the Camera View. Here''s a screenshot showing the final result:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数设备屏幕不是完美的正方形，我们需要将显示坐标映射到与我们的物理设备匹配。在 OpenGL 中，我们通过 *投影* 来做这件事。这个配方将展示如何使用投影来匹配
    GLSurfaceView 坐标与设备坐标。除了投影之外，我们还将展示如何设置相机视图。以下是显示最终结果的截图：
- en: '![Applying Projection and Camera View while drawing](img/B05057_10_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![绘制时应用投影和相机视图](img/B05057_10_04.jpg)'
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Create a new project in Android Studio and call it: `ProjectionAndCamera`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for **Activity Type**.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为：`ProjectionAndCamera`。使用默认的 **Phone & Tablet**
    选项，并在提示 **Activity Type** 时选择 **Empty Activity**。
- en: This recipe builds on the previous recipe *Drawing shapes on the GLSurfaceView*.
    If you have not already typed in the previous recipe, do so before starting these
    steps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方建立在之前的配方 *在 GLSurfaceView 上绘制形状* 之上。如果您还没有输入之前的配方，请在开始这些步骤之前这样做。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As stated previously, this recipe will build on the previous recipe, so complete
    those steps before starting. We will be modifying the previous code to add projection
    and camera view to the drawing calculations. Here are the steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个配方将建立在之前的配方之上，所以在开始之前完成这些步骤。我们将修改之前的代码以添加投影和相机视图到绘制计算中。以下是步骤：
- en: 'Open the `Triangle` class and add the following global declaration to the existing
    declarations:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Triangle` 类，并在现有声明中添加以下全局声明：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a matrix variable to `vertexShaderCode` and use it in the position calculation.
    Here is the final result:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `vertexShaderCode` 中添加一个矩阵变量，并在位置计算中使用它。以下是最终结果：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Change the `draw()` method to pass in a matrix parameter as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `draw()` 方法修改为传入一个矩阵参数，如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To use the transformation matrix, add the following code to the `draw()` method
    just before the `GLES20.glDrawArrays()` method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用变换矩阵，请在 `draw()` 方法中在 `GLES20.glDrawArrays()` 方法之前添加以下代码：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open `MainActivity.java` and add the following class variables to the `GLRenderer`
    class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并将以下类变量添加到 `GLRenderer` 类中：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `onSurfaceChanged()` callback to calculate the position matrix as
    follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `onSurfaceChanged()` 回调以计算位置矩阵如下：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Modify the `onDrawFrame()` callback to calculate the Camera View as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `onDrawFrame()` 回调以计算相机视图如下：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序在设备或模拟器上。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we modify the `vertexShaderCode` to include a matrix variable. We calculate
    the matrix in the `onSurfaceChanged()` callback using the height and width, which
    are passed in as parameters. We pass the transformation matrix to the `draw()`
    method to use it when calculating the position to draw.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们修改 `vertexShaderCode` 以包含一个矩阵变量。我们使用传入的参数高度和宽度在 `onSurfaceChanged()` 回调中计算矩阵。我们将变换矩阵传递给
    `draw()` 方法，以便在计算绘制位置时使用。
- en: 'Before we call the `draw()` method, we calculate the camera view. These two
    lines of code calculate the camera view:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用 `draw()` 方法之前，我们计算相机视图。这两行代码计算相机视图：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Without this code, there would actually be no triangle drawn as the camera perspective
    would not "see" our vertices. (This goes back to our discussion on how the order
    of the vertices dictate the front and back of the image.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这段代码，实际上不会绘制三角形，因为相机视角不会“看到”我们的顶点。（这回到了我们之前关于顶点顺序决定图像前后关系的讨论。）
- en: When you run the program now, you'll see the output shown in the *Introduction*.
    Notice we have a uniform triangle now, even when the display is rotated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在运行程序时，您将看到 *简介* 中显示的输出。注意我们现在有一个均匀的三角形，即使显示被旋转。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In the next recipe, we will start showing the power of OpenGL by rotating the
    triangle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个配方中，我们将开始展示通过旋转三角形 OpenGL 的功能。
- en: Moving the triangle with rotation
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过旋转移动三角形
- en: What we've demonstrated so far with OpenGL would probably be easier using the
    traditional canvas or drawable objects. This recipe will show a bit of the power
    of OpenGL by rotating the triangle. Not that we can't create movement with the
    other drawing methods, but how easily we can do this with OpenGL!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止用 OpenGL 展示的内容可能使用传统的画布或可绘制对象会更简单。此配方将通过旋转三角形展示 OpenGL 的一些功能。虽然我们也可以用其他绘图方法创建运动，但使用
    OpenGL 来做这一点是多么容易！
- en: 'This recipe will demonstrate how to rotate the triangle, as this screenshot
    shows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将演示如何旋转三角形，如此截图所示：
- en: '![Moving the triangle with rotation](img/B05057_10_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![通过旋转移动三角形](img/B05057_10_05.jpg)'
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `CreatingMovement`. Use
    the default **Phone & Tablet** options and select **Empty Activity** when prompted
    for **Activity Type**.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为：`CreatingMovement`。使用默认的 **Phone & Tablet**
    选项，并在提示 **Activity Type** 时选择 **Empty Activity**。
- en: This recipe builds on the previous recipe *Applying Projection and Camera View
    While Drawing*. If you have not already typed in the previous recipe, do so before
    continuing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于之前的配方 *在绘图时应用投影和相机视图*。如果您还没有输入之前的配方，请在继续之前这样做。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since we are continuing from the previous recipe, we have very little work
    to do. Open `MainActivity.java` and follow these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从上一个配方继续的，所以我们几乎没有工作要做。打开 `MainActivity.java` 并按照以下步骤操作：
- en: 'Add a Matrix to the `GLRendered` class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GLRendered` 类中添加一个矩阵：
- en: '[PRE26]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `onDrawFrame()` callback, replace the existing `mTriangle.draw(mMVPMatrix);`
    statement with the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onDrawFrame()` 回调中，将现有的 `mTriangle.draw(mMVPMatrix);` 语句替换为以下代码：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序在设备或模拟器上。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We're using the `Matrix.setRotateM()` method to calculate a new rotation matrix
    based on the angle we pass in. For this example, we're using the system uptime
    to calculate an angle. We can use whatever method we want to derive an angle,
    such as a sensor reading or touch events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Matrix.setRotateM()` 方法根据我们传递的角度计算一个新的旋转矩阵。在这个例子中，我们使用系统运行时间来计算一个角度。我们可以使用任何我们想要的方法来推导一个角度，例如传感器读取或触摸事件。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Using the system clock provides the added benefit of creating continuous movement,
    which certainly looks better for demonstration purposes. The next recipe will
    demonstrate how to use user input to derivate an angle for rotating the triangle.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统时钟提供了创建连续运动的额外好处，这对于演示目的当然看起来更好。下一个配方将演示如何使用用户输入来推导旋转三角形的角。
- en: The render mode
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染模式
- en: 'OpenGL offers a `setRenderMode()` option to draw only when the view is dirty.
    This can be enabled by adding the following code to the `CustomGLSurfaceView()`
    constructor just below the `setRenderer()` call:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 提供了一个 `setRenderMode()` 选项，仅在视图脏时绘制。这可以通过在 `CustomGLSurfaceView()` 构造函数中添加以下代码来实现，位于
    `setRenderer()` 调用下方：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will cause the display to update once, then wait until we request an update
    with `requestRender()`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致显示更新一次，然后等待我们使用 `requestRender()` 请求更新。
- en: Rotating the triangle with user input
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过用户输入旋转三角形
- en: The previous example demonstrated rotating the triangle based on the system
    clock. This created a continuously rotating triangle, depending on the render
    mode we used. But what if you wanted to respond to the input from the user?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子演示了根据系统时钟旋转三角形。这创建了一个根据我们使用的渲染模式连续旋转的三角形。但如果你想要响应用户的输入怎么办？
- en: In this recipe, we'll show how to respond to user input by overriding the `onTouchEvent()`
    callback from `GLSurfaceView`. We'll still rotate the triangle using the `Matrix.setRotateM()`
    method, but instead of deriving an angle from the system time, we'll calculate
    an angle based on the touch location.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何通过覆盖 `GLSurfaceView` 的 `onTouchEvent()` 回调来响应用户输入。我们仍然会使用 `Matrix.setRotateM()`
    方法来旋转三角形，但不是从系统时间推导角度，而是基于触摸位置计算角度。
- en: 'Here''s a screenshot showing this recipe running on a physical device (to highlight
    the touch, the **Show touches** developer option is enabled):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一张显示此配方在物理设备上运行的截图（为了突出触摸，已启用**显示触摸**开发者选项）：
- en: '![Rotating the triangle with user input](img/B05057_10_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![使用用户输入旋转三角形](img/B05057_10_06.jpg)'
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `RotateWithUserInput`.
    Use the default **Phone & Tablet** options and select **Empty Activity** when
    prompted for **Activity Type**.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为：`RotateWithUserInput`。使用默认的 **手机和平板** 选项，并在提示
    **活动类型** 时选择 **空活动**。
- en: This recipe demonstrates an alternative approach to the previous recipe and
    therefore will be based on *Applying projection and camera view while drawing*
    (the same starting point as the previous recipe.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方演示了与先前配方不同的替代方法，因此将基于 *在绘制时应用投影和相机视图*（与先前配方相同的起点）。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'As stated previously, we will continue, not from the previous recipe, but from
    the *Applying projection and camera view while drawing* recipe. Open `MainActivity.java`
    and follow these steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将继续，而不是从先前的配方开始，而是从 *在绘制时应用投影和相机视图* 配方开始。打开 `MainActivity.java` 并按照以下步骤操作：
- en: 'Add the following global variables to the `MainActivity` class:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下全局变量添加到 `MainActivity` 类中：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following code the `GLRendered` class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `GLRendered` 类中：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the same class, modify the `onDrawFrame()` method by replacing the existing
    `mTriangle.draw(mMVPMatrix);` statement with the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一类中，通过将现有的 `mTriangle.draw(mMVPMatrix);` 语句替换为以下代码来修改 `onDrawFrame()` 方法：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to the `onSurfaceChanged()` callback:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `onSurfaceChanged()` 回调中：
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following code to the `CustomGLSurfaceView` constructor, which is below
    `setRenderer()`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `CustomGLSurfaceView` 构造函数中，该构造函数位于 `setRenderer()` 下方：
- en: '[PRE33]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following `onTouchEvent()` to the `CustomGLSurfaceView` class:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `onTouchEvent()` 添加到 `CustomGLSurfaceView` 类中：
- en: '[PRE34]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The obvious difference between this example and the previous recipe is how we
    derive the angle to pass to the `Matrix.setRotateM()` call. We also changed the
    `GLSurfaceView` render mode using `setRenderMode()` to only draw on request. We
    made the request using `requestRender()` after calculating a new angle in the
    `onTouchEvent()` callback.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的配方相比，此示例的明显区别在于我们如何推导出传递给 `Matrix.setRotateM()` 调用的角度。我们还使用 `setRenderMode()`
    改变了 `GLSurfaceView` 的渲染模式，使其仅在请求时绘制。我们在 `onTouchEvent()` 回调中计算了一个新角度后，使用 `requestRender()`
    发出了请求。
- en: We also demonstrated the importance of deriving our own `GLSurfaceView` class.
    Without our `CustomGLSurfaceView` class, we would not have a way to override the
    `onTouchEvent` callback, or any other callbacks from `GLSurfaceView`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了自定义 `GLSurfaceView` 类的重要性。如果没有我们的 `CustomGLSurfaceView` 类，我们就无法覆盖 `onTouchEvent`
    回调，或从 `GLSurfaceView` 的任何其他回调。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This concludes the OpenGL ES recipes but we've only just touched upon the power
    of OpenGL. If you're serious about learning OpenGL, see the links in the next
    section and check out one of the many books written on OpenGL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了 OpenGL ES 配方，但我们只是刚刚触及 OpenGL 的强大功能。如果您认真想学习 OpenGL，请查看下一节中的链接，并查看关于 OpenGL
    的许多书籍之一。
- en: 'It''s also worth checking out one of the many frameworks available, such as
    the Unreal Engine:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，检查可用的许多框架之一，例如虚幻引擎：
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unreal Engine 4 is a complete suite of game development tools made by game developers,
    for game developers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎 4 是由游戏开发者为游戏开发者制作的完整游戏开发工具套件。
- en: '[https://www.unrealengine.com/what-is-unreal-engine-4](https://www.unrealengine.com/what-is-unreal-engine-4)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.unrealengine.com/what-is-unreal-engine-4](https://www.unrealengine.com/what-is-unreal-engine-4)'
- en: See also
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '**OpenGL**: The Industry Standard for High Performance Graphics'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL**: 高性能图形的行业标准'
- en: '[https://www.opengl.org/](https://www.opengl.org/)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.opengl.org/](https://www.opengl.org/)'
- en: '**OpenGL ES**: The Standard for Embedded Accelerated 3D Graphics'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES**: 嵌入式加速 3D 图形的行业标准'
- en: '[https://www.khronos.org/opengles/](https://www.khronos.org/opengles/)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.khronos.org/opengles/](https://www.khronos.org/opengles/)'
- en: '**Unreal Engine**: Android Quick Start'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚幻引擎**: Android 快速入门'
- en: '[https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html](https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html](https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html)'
