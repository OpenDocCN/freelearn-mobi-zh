<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Looking Good – Graphical Interface</h1></div></div></div><p>
<em>In the previous chapter, we covered the features of Unity and Android. We also discussed the benefits of using them together. After we finished installing a bunch of software and setting up our devices, we created a simple Hello World application to confirm that everything was connected correctly.</em>
</p><p>
<em>This chapter is all about <strong>Graphical User Interface</strong> (<strong>GUI</strong>). We will start by creating a simple Tic-tac-toe game, using the <a id="id96" class="indexterm"/>basic pieces of GUI that Unity provides. Following that we will discuss Unity's GUI Styles and GUI Skins. Using what we learned, we will improve the look of our game. Also, we will explore some tips and tricks for handling many different screen sizes of Android devices. Finally, we will learn about a much quicker way to put our games on the device, which was covered in the previous chapter. With all that said, let's jump in.</em>
</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User preferences</li><li class="listitem" style="list-style-type: disc">Buttons and labels</li><li class="listitem" style="list-style-type: disc">GUI Skins and GUI Styles</li><li class="listitem" style="list-style-type: disc">Dynamic GUI positioning</li><li class="listitem" style="list-style-type: disc">Build and run</li></ul></div><p>In this chapter, we will be creating a new project in Unity. The first section here will walk you through its creation and setup.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Creating a Tic-tac-toe game</h1></div></div></div><p>The project for this<a id="id97" class="indexterm"/> chapter is a simple Tic-tac-toe-style game, similar to what any of us might play on paper. As with anything else, there are several ways you could make this game. We are going to use Unity's GUI system, in order to better understand how to create a GUI for any of our other games.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Time for action – creating Tic-tac-toe</h1></div></div></div><p>The basic Tic-tac-toe game involves two players and a 3 x 3 grid. The players take turns filling X's and O's. The <a id="id98" class="indexterm"/>player who first fills a line of three squares with his/her letter wins the game. If all squares are filled without a player achieving a line of three, the game is a tie. Let's perform the following steps to create our game:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing to do is to create a project for this chapter. So, start up Unity and we will do just that.</li><li class="listitem">If you have been following along so far, Unity should boot up into the last project that was open. This isn't a bad feature, but it can become extremely annoying. Think of it like this: you have been working on a project for a while and it has grown large. Now you need to quickly open something else, but Unity defaults to your huge project. If you wait for it to open before you can work on anything else, it can consume a lot of time. To change this feature, go to the top of the Unity window and click on <strong>Edit</strong> followed by <strong>Preferences</strong>. This is the same place where we changed our script editor's preferences. This time, though, we are going to change settings in the <strong>General</strong> tab<a id="id99" class="indexterm"/>. The following screenshot shows the options present under the <strong>General</strong> tab:<div><img src="img/2014OT_02_01.png.jpg" alt="Time for action – creating Tic-tac-toe"/></div></li><li class="listitem">At this moment,<a id="id100" class="indexterm"/> the primary concern is the <strong>Always Show Project Wizard</strong> option; however, we will still cover all of the options in turn. All the options under the <strong>General</strong> tab are explained in detail as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Auto Refresh</strong>: This is one of the best features of Unity. As assets are changed outside of Unity, this option lets Unity automatically detect the change and refresh the asset inside your project.</li><li class="listitem" style="list-style-type: disc"><strong>Always Show Project Wizard</strong>: This is a great first option to go check whenever installing Unity. Instead of opening the last project, Unity opens <strong>Project Wizard</strong>. From there, you can open any project of your choice or create a new one. This is always a good one to turn on.</li><li class="listitem" style="list-style-type: disc"><strong>Compress Assets on Import</strong>: This is the checkbox for automatically compressing your game assets when they are first imported to Unity.</li><li class="listitem" style="list-style-type: disc"><strong>Editor Analytics</strong>: This is the checkbox for Unity's anonymous usage statistics. Leave it checked and the Unity Editor sends info occasionally to the Unity source. It doesn't hurt anything to leave it on, and helps the Unity team make the Unity Editor better. But it comes down to personal preference.</li><li class="listitem" style="list-style-type: disc"><strong>Show Asset Store search hits</strong>: This setting is only relevant if you are planning to use the Asset Store. The Asset Store can be a great source of assets and tools for any game; however, since we are not going to use it, the relevance to this book is rather limited. It does what the name suggests. When you search the Asset Store for something from within the Unity Editor, the number of results is displayed based on this checkbox.</li><li class="listitem" style="list-style-type: disc"><strong>Verify Saving Assets</strong>: This is a good one to be left off. If this is on, every time you click on <strong>Save</strong> in Unity. A dialog box will pop up so that you can make sure you save any and all of the assets that have changed since your last save. It is not so much about your models and textures, but concerned with Unity's internal files, the materials, and prefabs. Best to leave it off for now.</li><li class="listitem" style="list-style-type: disc"><strong>Skin (Pro Only)</strong>: This option only applies to Unity's pro users. It gives the option to switch between the light and dark versions of the Unity Editor. It is purely cosmetic, so go with your gut for this one.</li></ul></div></li><li class="listitem">With your preferences <a id="id101" class="indexterm"/>set, now go up to <strong>File</strong> and follow it with selecting <strong>Open Project</strong>.</li><li class="listitem">Select the <strong>Create New Project</strong> tab, followed by the <strong>Browse...</strong> button to pick a location and name for the new project.</li><li class="listitem">We will not be using any of the included packages, so click on <strong>Create</strong> and we can get on with it.</li><li class="listitem">Once Unity finishes initializing the new project, create two new scripts in the <strong>Project</strong> panel, just as we did for the <em>Hello World</em> project in the previous chapter. Name the new scripts as <code class="literal">TicTacToeControl</code> and <code class="literal">SquareState</code>. Open them and clear out the default functions; again, just as we did in <a class="link" href="ch01.html" title="Chapter 1. Saying Hello to Unity and Android">Chapter 1</a>, <em>Saying Hello to Unity and Android</em>.</li><li class="listitem">The <code class="literal">SquareState</code> script will hold the possible states of each square of our game board. To do that, clear everything out of the script and replace it with a simple enumeration. An enumeration is just a list of potential values. This one is concerned with the player who controls the square. Do X's control it, O's control it, or is it clear because the game board is traditionally clear by default. <code class="literal">Clear</code> becomes the first and therefore the default state.<div><pre class="programlisting">public enum SquareState {
  Clear,
  XControl,
  OControl
}</pre></div></li><li class="listitem">In our other script, <code class="literal">TicTacToeControl</code>, we start with two variables that will largely control the flow of the game. The first defines our game board. Traditionally the game is played on a 3 x 3 grid, therefore nine squares. The second line dictates whose turn it is. How it is going to change will be made clear in a little bit, but for now suffice it to say that if it is X's turn, the value will be true. If it is not X's turn, the value will be false.<div><pre class="programlisting">public SquareState[] board = new SquareState[9];
public bool xTurn = true;</pre></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>In Unity, every<a id="id102" class="indexterm"/> script by default inherits from the <code class="literal">MonoBehaviour</code> class. This gives our scripts two primary benefits.</p><p>First, it allows us to add our scripts to objects as components. The filename of the script also needs to be the exact same as the class name within the script, if you plan on adding the script to an object.</p><p>The second benefit of the <code class="literal">MonoBehaviour</code> class is the variety of variables and functions that come with it. The variables give us access to all the parts that make up objects in Unity. The functions provide a number of automatic features and access to the game initialization and loop. This is what we are most interested in at this particular moment.</p></div></div></li><li class="listitem">In order to draw anything in each GUI frame, one needs to utilize the <code class="literal">OnGUI</code> function provided by the <code class="literal">MonoBehaviour</code> class. That is where we will draw our game board. The <code class="literal">OnGUI</code> function lets us draw our interface every frame. Inside it, we will first define the width and height of our board squares.<div><pre class="programlisting">public void OnGUI() {
  float width = 75;
  float height = 75;</pre></div></li><li class="listitem">Following that is a pair of for-loops. Because our board is a 3 x 3 grid, we need the loops to count three rows of three squares.<div><pre class="programlisting">for(int y=0;y&lt;3;y++) {
    for(int x=0;x&lt;3;x++) {</pre></div></li><li class="listitem">Inside the loops we must first figure out which square we are currently drawing. It becomes hard to play a game, if you don't know which square was touched.<div><pre class="programlisting">int boardIndex = (y * 3) + x;</pre></div></li><li class="listitem">The next line of code defines whether the square is going to be drawn as a <code class="literal">Rect</code> class. A <code class="literal">Rect</code> class is defined in GUI space as x position, y position, width, and height. In Unity, GUI space is defined as the top-left corner being (0,0) and the bottom-right is <code class="literal">Screen.width</code>, <code class="literal">Screen.height</code>. The width and height of the screen are the number of pixels.<div><pre class="programlisting">Rect square = new Rect(x * width, y * height, width, height);</pre></div></li><li class="listitem">We then figure<a id="id103" class="indexterm"/> out who controls the square. The following line of code is a little complicated, but it is really just a compressed <code class="literal">if</code> statement. Basically, it works like this: first check a condition and if it is true return the first value, whatever is between the question mark and the colon. If the condition is false, return the value after the colon. Two of these compressed <code class="literal">if</code> statements were combined here; if the square is owned by X, set our owner to X. Otherwise, if it is owned by O, set the owner to O. If neither of the conditions is true, nobody owns the square and we set our owner to an empty string.<div><pre class="programlisting">string owner = board[boardIndex] == SquareState.XControl ? "X" : board[boardIndex] == SquareState.OControl ? "O" : "";</pre></div></li><li class="listitem">Now that all the hard work of figuring out where we are is done, we actually draw our game board square. This is done through the use of a wonderful little function provided by Unity, <code class="literal">GUI.Button</code>. To use this function in its basic form, we must tell the function where the button should be drawn and what text to display, hence rect and string. We give it our square and owner variables, it does all the hard work of actually drawing on screen, and we are given back a Boolean result, whether or not the button was pressed. Therefore, we check it with an <code class="literal">if</code> statement and if true, we send to a new function which square was pressed, letting it handle setting the owner. Also, don't forget the extra curly braces to close up the loops and the function.<div><pre class="programlisting">      if(GUI.Button(square, owner))
        SetControl(boardIndex);
    }
  }
}</pre></div></li><li class="listitem">The <code class="literal">SetControl</code> function<a id="id104" class="indexterm"/> is pretty short; it simply sets the owner for whichever square is passed to it. It first makes sure that the index given is actually within the range for our board. If it is not, we'll exit the function early. The next line of code sets control of the board square based on whose turn it is. If it is X's turn, set the square to <code class="literal">XControl</code>; otherwise set control to <code class="literal">OControl</code>. Finally we change whose turn it is. This is done by simply setting our <code class="literal">xTurn</code> Boolean to the opposite of itself, indicating that it is the other person's turn.<div><pre class="programlisting">public void SetControl(int boardIndex) {
  if(boardIndex &lt; 0 || boardIndex &gt;= board.Length) return;

  board[boardIndex] = xTurn ? SquareState.XControl : SquareState.OControl;
  xTurn = !xTurn;
}</pre></div></li><li class="listitem">We are<a id="id105" class="indexterm"/> just about ready to play our game. We just need to set up the scene. To do this, start by dragging our <code class="literal">TicTacToeControl</code> script from the <strong>Project</strong> pane of the Unity Editor  to the <strong>Main Camera</strong> object in the <strong>Hierarchy</strong> pane of the Unity Editor.</li><li class="listitem">Now save the scene, just as we did in <a class="link" href="ch01.html" title="Chapter 1. Saying Hello to Unity and Android">Chapter 1</a>, <em>Saying Hello to Unity and Android</em>, as <code class="literal">TicTacToe</code>.</li><li class="listitem">It is possible to play the game at this point. It is also possible to do so on a device; just follow the same steps as in <a class="link" href="ch01.html" title="Chapter 1. Saying Hello to Unity and Android">Chapter 1</a>, <em>Saying Hello to Unity and Android</em>, but for now just perform testing in the Unity Editor. Later in this chapter we will cover a much easier way to build to our devices.<div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the very base of what we need to play Tic-tac-toe. We did this with two short and simple scripts. However, while playing the game now, you probably noticed a few things about it. For starters, it doesn't look particularly fantastic. That is extremely odd, considering it is the point of this chapter, but we will address that soon enough. Second, there are no checks to determine whether or not somebody already controls a square.</p><p>Also, there are no checks to see if anybody won the game. Finally, if you decided to build to device, you might have noticed one of the great things about Unity's GUI functions. There is no special programming needed to make any of the GUI functions work with touch inputs rather than the mouse. A lot of time is saved when you don't have to worry about special inputs, especially if you plan on multiplatform targeting.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Finishing the game</h1></div></div></div><p>If you didn't want to<a id="id106" class="indexterm"/> go through the process of building the application and putting it on your device, it is still possible for you to try out interacting with the buttons, and touching them with your fingers. In <a class="link" href="ch01.html" title="Chapter 1. Saying Hello to Unity and Android">Chapter 1</a>, <em>Saying Hello to Unity and Android</em>, we installed the application, Unity Remote. Plug the device into your computer and start it up; when you click on <strong>Play</strong> in the Unity Editor, you should see the game running on your device. If you can see the game playing in the Unity Editor but not on the device, just restart Unity. Make sure to save it; it would be awful to lose all of your hard work.</p><p>Undoubtedly the first thing you will notice when using Unity Remote is that the game doesn't look good. It is almost certainly stretched and pixelated. If it doesn't concern you now, don't worry, it gets worse when the project becomes more complicated. Now, before you start freaking out, grumbling about why you had to install such a useless program, you must understand the point of Unity Remote. We went over it sometime back, but we will dig a little deeper. Unity Remote is for testing device inputs: touch screen, tilt, and so on. What it looks like<a id="id107" class="indexterm"/> is a result of freeing up bandwidth so that the frame rate is the same as it is in the Unity Editor.</p><p>There is something you can and should do about the stretching. At the top-left corner of the <strong>Game</strong> window of the Unity Editor is a drop-down list. By default it is set to <strong>Free Aspect</strong>, which means the window will fill all the space available. If you click on it, a variety of aspect ratio options will be presented. Clicking through these options, you will see black bars in the <strong>Game</strong> window. This is Unity resizing the <strong>Game</strong> window and blacking out the unused space. The options change based on what the build target is. In the <strong>Build Settings</strong> window, change your platform to Android. In the <strong>Game</strong> window's drop-down menu, find an aspect ratio that matches your device. With that selected, your game will no longer appear stretched when using Unity Remote.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Time for action – finish creating the game</h1></div></div></div><p>Let us finish the creation of our game by creating an opening screen. We will then add some checks to stop <a id="id108" class="indexterm"/>players from selecting squares more than once. Follow that with a check to see if anyone won and finally display a game over screen. With that, the game will be ready for us to make it look great.</p><p>Let's perform the following steps for finishing our game:</p><div><ol class="orderedlist arabic"><li class="listitem">We will do all this by first creating another script like our <code class="literal">SquareState</code> script. Create the new <code class="literal">GameState</code> script and clear out the default contents. Add the following code snippet and we will have the values needed to track the current state of our game:<div><pre class="programlisting">public enum GameState {
  Opening,
  MultiPlayer,
  GameOver
}</pre></div></li><li class="listitem">We now need to update our <code class="literal">TicTacToeControl</code> script. For starters, because we want to be able to play multiple games, add the <code class="literal">NewGame</code> function to the script. This function initializes our control variables so that we can start a fresh game with a clear board. It will not do very well for players to start a new game and have the board already filled in. This function will be used by our main menu, which we will be writing shortly.<div><pre class="programlisting">public void NewGame() {
  xTurn = true;
  board = new SquareState[9];
}</pre></div></li><li class="listitem">But first, we need to update our <code class="literal">OnGUI</code> function<a id="id109" class="indexterm"/>. To do that, start by moving all of the current contents of <code class="literal">OnGUI</code> to a new function called <code class="literal">DrawGameBoard</code>.</li><li class="listitem">Now, we<a id="id110" class="indexterm"/> need to change our cleared <code class="literal">OnGUI</code> function to the following code snippet in order to allow it to check and draw the proper screen based on the current game state. A <code class="literal">switch</code> statement works the same as a bunch of <code class="literal">if</code> and <code class="literal">else if</code> statements. In our case, we check the game state and call a different function based on what it is. For example, if the game state is equal to <code class="literal">GameState.MultiPlayer</code>, we will call the <code class="literal">DrawGameBoard</code> function, which should now contain what used to be in the <code class="literal">OnGUI</code> function.<div><pre class="programlisting">public void OnGUI() {
  switch(gameState) {
    case GameState.Opening:
      DrawOpening();
      break;
    case GameState.MultiPlayer:
      DrawGameBoard();
      break;
    case GameState.GameOver:
      DrawGameOver();
      break;
  }
}</pre></div></li><li class="listitem">By this point you are probably wondering where that game state variable is coming from. If you guessed that it was automatically provided by Unity, you are wrong. We have to track our own game state. That is why we created the <code class="literal">GameState</code> script earlier. Add the following line of code to the top of our <code class="literal">TicTacToeControl</code> class<a id="id111" class="indexterm"/>, right above where we defined our game board:<div><pre class="programlisting">public GameState gameState = GameState.Opening;</pre></div></li><li class="listitem">Next, we need to create the other two game state screens. Let us start with the opening screen. When we draw our opening screen, we start by defining the <code class="literal">Rect</code> class used by our title. We follow that with a quick call to <code class="literal">GUI.Label</code>. By passing it a <code class="literal">Rect</code> class to position itself by and some text, the text is simply drawn on screen. This function is the best way to draw a section of text on the screen.<div><pre class="programlisting">public void DrawOpening() {
  Rect titleRect = new Rect(0, 0, 300, 75);
  GUI.Label(titleRect, "Tic-Tac-Toe");</pre></div></li><li class="listitem">The following line of code defines the <code class="literal">Rect</code> class used by our <code class="literal">New Game</code> button. We want to be sure that it was right under the title, so it starts with the title's x position. We then combine the title's y position with its height to find the position right underneath it. Next, we used the width from the title so that our button<a id="id112" class="indexterm"/> will cover the entire position under it. Finally, the height is set to <code class="literal">75</code> because it is a good size for fingers and we don't want it to change based on the title. We could have just as easily used all the values from the title or just put in the numbers but our title will change later when we start styling everything.<div><pre class="programlisting">  Rect multiRect = new Rect(titleRect.x, titleRect.y + titleRect.height, titleRect.width, 75);</pre></div></li><li class="listitem">Finally, we make a call that will draw our button. You may remember our use of the <code class="literal">GUI.Button</code> function from when we drew the game board. If the button is pressed, the game state is set to <code class="literal">MultiPlayer</code> that will start our game. The <code class="literal">NewGame</code> function is also called, which will reset our game board. And of course, there is an extra curly brace to finish off the function.<div><pre class="programlisting">  if(GUI.Button(multiRect, "New Game")) {
    NewGame();
    gameState = GameState.MultiPlayer;
  }
}</pre></div></li><li class="listitem">We have one screen left to draw, the game over screen. To do this, we will create the function referenced by our <code class="literal">OnGUI</code> function. However, in order for a game to end, there must be a winner, so add the following line of code right under our game state variable. We are making extended use of the <code class="literal">SquareState</code> enumeration. If the winner variable is equal to <code class="literal">Clear</code>, nobody won the game. If it is equal to <code class="literal">XControl</code> or <code class="literal">OControl</code>, the relevant player has won. Don't worry, it will make more sense when we create the game over screen next and the winner check system in a little bit.<div><pre class="programlisting">public SquareState winner = SquareState.Clear;</pre></div></li><li class="listitem">There is nothing particularly new in the <code class="literal">DrawGameOver</code> function. First, we'll define where we are going to write who won the game. We'll then figure out who won, using our winner variable. After drawing the winner title, the <code class="literal">Rect</code> class used is shifted down by its height so it can be reused. Finally, we'll draw a button that changes our game state back to <code class="literal">Opening</code>, which is of course our main menu.<div><pre class="programlisting">public void DrawGameOver() {
  Rect winnerRect = new Rect(0, 0, 300, 75);
  string winnerTitle = winner == SquareState.XControl ? "X Wins!" : winner == SquareState.OControl ? "O Wins!" : "It's A Tie!";
  GUI.Label(winnerRect, winnerTitle);

  winnerRect.y += winnerRect.height;
  if(GUI.Button(winnerRect, "Main Menu"))
    gameState = GameState.Opening;
}</pre></div></li><li class="listitem">To make sure<a id="id113" class="indexterm"/> we are not overwriting squares that somebody already controls, we need to make a few changes to our <code class="literal">DrawGameBoard</code> function<a id="id114" class="indexterm"/>. First, it would be helpful if the players could easily tell whose turn it is. To do this, we'll add the following code snippet to the end of the function. This should start to become familiar. We'll first define where we want to draw. Then, we'll use our <code class="literal">xTurn</code> Boolean to determine what to write about whose turn it is. Finally, it is the <code class="literal">GUI.Label</code> function to draw it on screen.<div><pre class="programlisting">Rect turnRect = new Rect(300, 0, 100, 100);
string turnTitle = xTurn ? "X's Turn!" : "O's Turn!";
GUI.Label(turnRect, turnTitle);</pre></div></li><li class="listitem">We now need to change the bit where we draw the board square, the <code class="literal">GUI.Button</code> function<a id="id115" class="indexterm"/>. We need to only draw that button if the square is clear. The following code snippet will do just that by moving the button inside of a new <code class="literal">if</code> statement. It checks whether the board square is clear. If it is, we draw the button. Otherwise, we use a label to write the owner to the button's location.<div><pre class="programlisting">if(board[boardIndex] == SquareState.Clear) {
  if(GUI.Button(square, owner))
    SetControl(boardIndex);
}
else GUI.Label(square, owner);</pre></div></li><li class="listitem">The last thing we need to do is make a system that checks for a winner. We will do this in another function provided by the <code class="literal">MonoBehaviour</code> class.<a id="id116" class="indexterm"/> <code class="literal">LateUpdate</code> is called at the end of every frame, just before things are drawn on the screen. You might be wondering to yourself, why don't we just create a function that is called at the end of <code class="literal">OnGUI</code>, which is already called every frame? The reason is that the <code class="literal">OnGUI</code> function gets a little weird when drawing some of the GUI elements. It will sometimes be called more than once so that it can draw everything. So, for the most part, the functionality should never be controlled by <code class="literal">OnGUI</code>. That is what <code class="literal">Update</code> and <code class="literal">LateUpdate</code> are for. <code class="literal">Update</code> is the normal game loop where most of a game's functionality is called from. <code class="literal">LateUpdate</code> is for things that need to happen after the objects' update, such as our check for a game over.</li><li class="listitem">Add the following <code class="literal">LateUpdate</code> function to our <code class="literal">TicTacToeControl</code> class.<a id="id117" class="indexterm"/> We'll start with a check to make sure we should even be checking for a winner. If the game isn't in a state where we are playing, in this case <code class="literal">MultiPlayer</code>, exit here and go no further.<div><pre class="programlisting">public void LateUpdate() {
  if(gameState != GameState.MultiPlayer) return;</pre></div></li><li class="listitem">Follow that with a short <code class="literal">for</code> loop. A victory in this game is a run of three matching squares. We start by checking the column that is marked by our loop. If the first square is not <code class="literal">Clear</code>, compare it to the square below; if they match, check it against the square below that. Our board is stored as a list but drawn <a id="id118" class="indexterm"/>as a grid, so we have to add three to go down a square. The <code class="literal">else if</code> statement follows checks of each row. By multiplying our loop value by three, we will skip down a row of each loop. We'll again compare the square to <code class="literal">SquareState.Clear</code>, then to the square one to its right, and finally two to the right. If either set of conditions is correct, we'll send the first square in the set out to another function to change our game state.<div><pre class="programlisting">  for(int i=0;i&lt;3;i++) {
    if(board[i] != SquareState.Clear &amp;&amp; board[i] == board[i + 3] &amp;&amp; board[i] == board[i + 6]) {
      SetWinner(board[i]);
      return;
    }
    else if(board[i * 3] != SquareState.Clear &amp;&amp; board[i * 3] == board[(i * 3) + 1] &amp;&amp; board[i * 3] == board[(i * 3) + 2]) {
      SetWinner(board[i * 3]);
      return;
    }
  }</pre></div></li><li class="listitem">The following code snippet is largely the same as the <code class="literal">if</code> statements we just wrote previously. However, these lines of code check the diagonals. If the conditions are true, again send out to the other function to change game states. You have probably also noticed the returns after the function calls. If we have found a winner at any point, there is no need to check any more of the board. So, we'll exit the <code class="literal">LateUpdate</code> function early.<div><pre class="programlisting">  if(board[0] != SquareState.Clear &amp;&amp; board[0] == board[4] &amp;&amp; board[0] == board[8]) {
    SetWinner(board[0]);
    return;
  }
  else if(board[2] != SquareState.Clear &amp;&amp; board[2] == board[4] &amp;&amp; board[2] == board[6]) {
    SetWinner(board[2]);
    return;
  }</pre></div></li><li class="listitem">This is the last little bit for our <code class="literal">LateUpdate</code> function. If no one has won the game, as determined by the previous parts of this function, we have to check for a tie. This<a id="id119" class="indexterm"/> is done by checking all of the squares of the game board. If any one of them is <code class="literal">Clear</code>, the game has yet to finish and we exit the function. But, if we make it through the entire loop without finding a <code class="literal">Clear</code> square, we go set the winner but declare a tie.<div><pre class="programlisting">  for(int i=0;i&lt;board.Length;i++) {
    if(board[i] == SquareState.Clear)
      return;
  }
  SetWinner(SquareState.Clear);
}</pre></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Do remember to close the last curly brace. It is needed to close off the <code class="literal">LateUpdate</code> function. If you forget it, some annoying errors will come your way.</p></div></div></li><li class="listitem">Finally, we'll create the <code class="literal">SetWinner</code> function that is called repeatedly in our <code class="literal">LateUpdate</code> function<a id="id120" class="indexterm"/>. Short and sweet, we'll pass to this function that is going to win. It sets our winner variable and changes our game state to <code class="literal">GameOver</code>.<div><pre class="programlisting">public void SetWinner(SquareState toWin) {
  winner = toWin;
  gameState = GameState.GameOver;
}</pre></div><div><img src="img/2014OT_02_02.png.jpg" alt="Time for action – finish creating the game"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>
<em>What just happened?</em>
</h2></div></div></div><p>That is it. Congratulations! We now have a fully functioning Tic-tac-toe game and you survived the process. In the next sections, we will finally get to make it all look pretty. That is a good thing because, as the screenshot shows, the game does not look great right now.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>GUI Skins and GUI Styles</h1></div></div></div><p>GUI Styles are how we change the look and feel of GUI elements, buttons, and labels in Unity. A GUI Skin contains several GUI Styles and allows us to change the look of the entire <a id="id121" class="indexterm"/>GUI without explicitly defining GUI Styles for each element. To create a GUI Skin, right-click in the <strong>Project</strong> window of the Unity Editor, just as with creating a new script. Go to <strong>Create</strong> but, instead of selecting <strong>Script</strong>, go to the bottom and select <strong>GUI skin</strong>. Selecting this option will create the new GUI Skin and let us name it to <code class="literal">GameSkin</code>. By looking at our <code class="literal">GameSkin</code> in the <strong>Inspector</strong> window<a id="id122" class="indexterm"/>, you can see what we have to work with.</p><div><img src="img/2014OT_02_03.png.jpg" alt="GUI Skins and GUI Styles"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At the top is a<a id="id123" class="indexterm"/> <strong>Font</strong> attribute. By importing font files to your project and placing one here, you can change the default font used by text in the whole game.</li><li class="listitem" style="list-style-type: disc">Under that is a long list of GUI elements, including our good friends <strong>Button</strong> and <strong>Label</strong>. These are all <a id="id124" class="indexterm"/>GUI Styles and coincide with the GUI functions that we use to draw things on screen. For example, unless otherwise specified, when we use the <code class="literal">Button</code> function, it will draw using the <strong>Button</strong> GUI Style.</li><li class="listitem" style="list-style-type: disc">Following the list of GUI elements is a <strong>Custom Styles</strong> attribute<a id="id125" class="indexterm"/>. This is where we can put any extra styles that we want to use. Of our dozen buttons, perhaps we want one to have red text. That GUI Style would go here.</li><li class="listitem" style="list-style-type: disc">At the bottom is a <strong>Settings</strong> attribute<a id="id126" class="indexterm"/>. By expanding it, we can see it is fairly short. It includes options for whether or not multiclicks can be used for selection, what color of cursor and how fast it should flash when in a text field, and what color the highlight on selected words should be. The defaults here are just fine. Unless there is a very specific look or need, these values can be ignored.</li></ul></div><p>Now, let us go over what it takes to be a GUI Style. Expand the <a id="id127" class="indexterm"/>
<strong>Button</strong> GUI Style from our <code class="literal">GameSkin</code> example. No matter what the GUI Style is used for, they all are made up the same. It may look like there are many attributes that make up a GUI Style, but most of them are nearly identical, making it much simpler.</p><div><img src="img/2014OT_02_04.png.jpg" alt="GUI Skins and GUI Styles"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first attribute is fairly straightforward, but perhaps the most important. <strong>Name</strong> is what Unity uses to find GUI Styles and apply them to GUI elements. It lets us know what the style is supposed to be; however, if there is a typo between it and the code, you will never see your style in the game.</li><li class="listitem" style="list-style-type: disc">The next <a id="id128" class="indexterm"/>several groups of values describe how the GUI element should look when in a particular state. This is where the bulk of your styling will go. The primary states of any element are <strong>Normal</strong>, <strong>Hover</strong>, <strong>Active</strong>, and <strong>Focused</strong>. Secondary to these are <strong>On Normal</strong>, <strong>On Hover</strong>, <strong>On Active</strong>, and <strong>On Focused</strong>. These secondary states only occur as the GUI element transfers into the corresponding primary state. Not every GUI element makes use of every state, and you have the ability to control which states an element can go into, but we will discuss that a little later. Let's see in detail how these states work:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Normal</strong>: This is the<a id="id129" class="indexterm"/> default state of any GUI element. It is always used and occurs any time the element is not being interacted with.</li><li class="listitem" style="list-style-type: disc"><strong>Hover</strong>: This state is <a id="id130" class="indexterm"/>used primarily by buttons and other clickable elements. When your mouse is on top of a GUI element, it will enter this state, if it can. However, since the focus of this book is touch screens, we do not have a mouse to really concern ourselves with. So, we will not be using this state.</li><li class="listitem" style="list-style-type: disc"><strong>Active</strong>: This has to<a id="id131" class="indexterm"/> be the second most important state. An element enters this state when it is activated. For example, when one presses a button, it is active. By clicking on or touching a button, it enters the <strong>Active</strong> state. All of the GUI elements that can be interacted with use this state.</li><li class="listitem" style="list-style-type: disc"><strong>Focused</strong>: This is a rarely used state. In terms of Unity's GUI, focused means having <a id="id132" class="indexterm"/>keyboard control. The only element that uses it by default is the <strong>Text Field</strong>.</li></ul></div></li><li class="listitem" style="list-style-type: disc">If you were to expand any of the states, you would see that it has two attributes, <strong>Background</strong> and <strong>Text Color</strong>. The <strong>Background</strong> attribute is a texture. It can be any texture in your game. The <strong>Text Color</strong> attribute is simply the color of any text that appears in the GUI element. Except for the <strong>Normal</strong> state, if a state does not have a background texture, it will not be used. This can be both good and annoying. If we do not want our buttons to show that they have been hovered over, simply remove the texture from the Hover state's <strong>Background</strong> attribute. It becomes annoying when we want a GUI element that does not have a background image of its own, but we do want the text to change color between states. How do we make use of the active state, but not use a texture for the background? The answer is that we create a blank image, but it is not quite as simple as saving off a 100 percent transparent PNG and using that. The GUI Style is too smart for that. It detects that the image is completely blank, making it no different than if there was no image. And so, the state still is not used. To get around this, create a small, blank PNG image, but take a single pixel and make it 90 percent transparent white. This might seem like a hack solution, but it is, unfortunately, the only way. At such a low transparency, we can't detect the pixel; though it is not actually clear. However, Unity sees that there is a slightly white pixel that must be drawn and does so.</li><li class="listitem" style="list-style-type: disc">Now, you might be thinking, that's stupid. I'm just going to create images of all of my buttons and not worry about the text. It is indeed stupid but the response to that is, what if you need to slightly change the text of a button? Or perhaps the text on the button is dynamic based on the player's name. In nearly every project I have been a part of there has been a need to create the not quite blank image.</li><li class="listitem" style="list-style-type: disc">Below the GUI element's states are <strong>Border</strong>, <strong>Margin</strong>, <strong>Padding</strong>, and <strong>Overflow</strong>. These attributes control how an element interacts with its background images and contained text. Inside each you will find <strong>Left</strong>, <strong>Right</strong>, <strong>Top</strong>, and <strong>Bottom</strong> values. Since every element is drawn as a rectangle, these correspond to each side of the said rectangle. They are defined in pixels, just like our GUI space. Let's see all these attributes in detail as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Border</strong>: This lets <a id="id133" class="indexterm"/>us define how many pixels from each side should not be stretched. When defining a GUI element, the background is normally stretched evenly across the space occupied. If you were to create a blue box with red edging and rounded corners, these values would keep your edges and corners regular while still stretching the blue on the inside.</li><li class="listitem" style="list-style-type: disc"><strong>Margin</strong>: This is only used by<a id="id134" class="indexterm"/> Unity's automatic GUI layout system named GUILayout. It is how much extra space should be around the outside of the element.</li><li class="listitem" style="list-style-type: disc"><strong>Padding</strong>: This is the space <a id="id135" class="indexterm"/>between the borders of an element and the text that it contains. If you want the text of a button left-justified but in slightly, you should use <strong>Padding</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Overflow</strong>: This defines an <a id="id136" class="indexterm"/>extra space for your background image. When creating our buttons, we defined a <code class="literal">Rect</code> class for how much space the button takes up. If we are to use <code class="literal">Overflow</code>, the button itself would be where the <code class="literal">Rect</code> class is, but the background would extend beyond each edge as dictated by the values. This would be useful for buttons with a shadow or glow around them.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The next several values have to do with the text in an element. The <strong>Font</strong> attribute is a font that is used specifically by this style. If this value is left empty, the font from the GUI Skin is used. <strong>Font Size</strong> is how big the letters of the text should be. This works just like your favorite word processor, except that a value of zero means to use the default font size defined in the font object. <strong>Font Style</strong> also works like your word processor. It lets you choose between <strong>Normal</strong>, <strong>Bold</strong>, and <strong>Italic</strong> text. This only makes a difference if it is supported by your chosen font.</li><li class="listitem" style="list-style-type: disc"><strong>Alignment</strong> defines where<a id="id137" class="indexterm"/> to justify the text in the GUI element. Imagine splitting your element into a 3 x 3 grid. <strong>Alignment</strong> is the same as the position of the grid.</li><li class="listitem" style="list-style-type: disc"><strong>Word Wrap</strong> defines<a id="id138" class="indexterm"/> whether or not text should split into multiple lines if it is too long. It again works on the same principle as your word processor. If checked and the line of text would extend beyond the sides of the GUI element, the text is split into as many lines as necessary to keep it within the bounds.</li><li class="listitem" style="list-style-type: disc"><strong>Rich Text</strong> is a fairly new<a id="id139" class="indexterm"/> and interesting feature of GUI Styles. It allows us to use HTML style markup to control text. You could put the tags <code class="literal">&lt;b&gt;</code> and <code class="literal">&lt;/b&gt;</code> around a word in your Label's text, and instead of writing those tags, Unity will make the words in between bold. We can make use of the bold, italics, size, and color tags. This allows for selectively making parts of our text bold or italics. We can make certain words larger or smaller. And, the color of any part of the text can be altered using hexadecimal values.</li><li class="listitem" style="list-style-type: disc"><strong>Text Clipping</strong> became weird<a id="id140" class="indexterm"/> in the recent updates. It used to be a nice drop-down list of values, but now it is an integer field. Either way, it still serves its function. If the text extends beyond the edges of the GUI element, this attribute dictates what to do. A value of zero means don't clip the text, let it extend beyond the edges. Any value that is not zero will cause the text to be clipped. Any text that extends beyond the borders will simply not be drawn.</li><li class="listitem" style="list-style-type: disc"><strong>Image Position</strong> is used in <a id="id141" class="indexterm"/>conjunction with GUIContent. GUIContent is a way of passing GUI elements the text, an icon image, and a tool tip. <strong>Image Position</strong> describes how the image and text interact. The image can either go to the left of the text or above. Or, we can choose to only use either the image or the text. Since tool tips aren't really useful in a touch environment, GUIContent is of limited use to us. For that reason, we will not be using it extensively, if at all.</li><li class="listitem" style="list-style-type: disc"><strong>Content Offset</strong> adjusts<a id="id142" class="indexterm"/> anything contained inside the GUI element by the values provided. If all of your text is normally centered in your button, this will allow you to move it slightly to the right and up. It is an aesthetic thing, for when you need a very specific look.</li><li class="listitem" style="list-style-type: disc"><strong>Fixed Width</strong> and <strong>Fixed Height</strong> provides<a id="id143" class="indexterm"/> approximately the same function. If any value other <a id="id144" class="indexterm"/>than zero is provided for these attributes, they will override the corresponding values in the <code class="literal">Rect</code> class used for the GUI element. So, if you wanted buttons to always be one hundred pixels wide, no matter where they are in the game, you could set <strong>Fixed Width</strong> to one hundred and they will do just that.</li><li class="listitem" style="list-style-type: disc"><strong>Stretch Width</strong> and <strong>Stretch Height</strong><a id="id145" class="indexterm"/> also serves about the same function. They are used by GUILayout for automatic placement of GUI elements. It pretty much gives<a id="id146" class="indexterm"/> the system permission to make elements wider/skinnier and taller/shorter, respectively, in order to satisfy its conditions for a better layout. The way GUILayout arranges elements is not always the best. It is good, if you need something up quick. But it gets complicated if you want any sort of deeper control.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>A prettier form of Tic-tac-toe</h1></div></div></div><p>Finally, we get to put what we learned about GUI Skins and GUI Styles into action and make our game look better. Or, at least make the game look like it isn't using default assets. Whatever your artistic talents, you will need to find or create a few images to continue following along.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Time for action – styling the game</h1></div></div></div><p>If you do not want to look far,<a id="id147" class="indexterm"/> the assets used for this chapter are found along with the resources for the book. All of the needed images are available, and they will work just well, until you have an opportunity to create some of your own.</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need five small textures: <code class="literal">ButtonActive</code>, <code class="literal">ButtonNormal</code>, <code class="literal">ONormal</code>, <code class="literal">XNormal</code>, and <code class="literal">Title</code>. To create these, you will have to use a separate photo-editing program or use the ones supplied with the included projects.</li><li class="listitem">The easiest way to get the images into your Unity project is to simply save them into the <code class="literal">Assets</code> folder that is created when you create a new project. Alternatively, you can go up to the top and click on <strong>Assets</strong> followed by <strong>Import New Asset</strong>. This will open a file browser and let you navigate to the asset you want. When you have found the asset you desire to import and have clicked on the <strong>Import</strong> button, a copy of the asset is put in your project. Unity will not move or remove files that exist outside of the current project.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">And now<a id="id148" class="indexterm"/> a note about import settings for textures. By default, Unity assumes any image files imported to your project are going to be used as game model textures. Because of that, Unity compresses them and adjusts them to fit a power of two.<div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>In case you didn't know, in computer graphics it is much faster to render images that can be divided in half evenly, down to a single unit. There are deeper reasons, but suffice it to say that it is because of the binary switches that actually make up a computer.</p></div></div><div><img src="img/2014OT_02_05.png.jpg" alt="Time for action – styling the game"/></div></li><li class="listitem" style="list-style-type: disc">Making our images recognized as being for the GUI is quite simple. To the right of <strong>Texture Type</strong>, click on <strong>Texture</strong> and select <strong>GUI</strong> from the drop-down menu.</li><li class="listitem" style="list-style-type: disc">You will<a id="id149" class="indexterm"/> notice that we were given a new <strong>Filter Mode</strong> drop-down menu. This is essentially how much effort Unity will put into making the image look nice as it is resized for the various GUI elements. <strong>Trilinear</strong> is the best, <strong>Point</strong> is the fastest, and <strong>Bilinear</strong> is in the middle.</li><li class="listitem" style="list-style-type: disc">Once the import settings have been changed, be sure to click on <strong>Apply</strong>, or Unity will complain when you try to do anything else. If you do not want to commit the changes, clicking on <strong>Revert</strong> will discard any changes just made and set back the <strong>Import Settings</strong> window to the last configuration that was used.</li></ul></div></li><li class="listitem">So, set all of <strong>Texture Types</strong> for your images to GUI and we will get on with it.</li><li class="listitem">Let us start with the beginning of the game. Open your <code class="literal">TicTacToeControl</code> script and add the following lines of code at the beginning. These allow us to attach references to other assets inside of the Unity Editor. The first will hold our <code class="literal">GameSkin</code>, so we can style all of our GUI elements. The second, as you can see in the following lines of code, will hold our fancy title image:<div><pre class="programlisting">public GUISkin guiSkin;
public Texture2D titleImage;</pre></div></li><li class="listitem">Now go to the Unity Editor and select <strong>Main Camera</strong> from the <strong>Hierarchy</strong> window.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Every object that you see listed in the <a id="id150" class="indexterm"/><strong>Hierarchy</strong> window is a <code class="literal">GameObject</code>. A <code class="literal">GameObject</code> is given a purpose and a meaning by the various components that are attached to it, for example, our <code class="literal">TicTacToeControl</code> script.</li><li class="listitem" style="list-style-type: disc">An empty <code class="literal">GameObject</code> is just a point in space, as defined by the <code class="literal">Transform</code> component that is always the first component on any <code class="literal">GameObject</code>.</li><li class="listitem" style="list-style-type: disc">You can see in the <strong>Inspector</strong> window, the <strong>Main Camera</strong> object has a <strong>Camera</strong> component. It gives a purpose to the <code class="literal">GameObject</code> and controls how the <strong>Camera</strong> component functions, just as our <code class="literal">TicTacToeControl</code> component at the bottom lets it control our Tic-tac-toe game.</li><li class="listitem" style="list-style-type: disc">The <strong>Inspector</strong> window also lets us see all of the public variables that can be changed in the Unity Editor. If they are changed, those values<a id="id151" class="indexterm"/> are saved and used when the game is played. So, by creating a variable in our script, we can add the reference to our <code class="literal">GameSkin</code> and it will be used in the game. To add the reference, simply click-and-drag the object to the desired variable on the component in the <strong>Inspector</strong> window.</li></ul></div></li><li class="listitem">Drag <code class="literal">GameSkin</code> to the <strong>GUI Skin</strong> slot and our title image to the <strong>Title Image</strong> slot.<div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Be sure to save. Saving regularly is the only thing that stands between you and premature baldness, the next time your computer decides to die.</p></div></div></li><li class="listitem">Inside of our <code class="literal">TicTacToeControl</code> script, add the following line of code at the beginning of the <code class="literal">OnGUI</code> function. It first checks to make sure there is a GUI Skin available. If it is, it is set into the <code class="literal">GUI.skin</code> variable. This variable controls the GUI Skin that is used in the game. Once set, any GUI elements drawn after that will use the new GUI Skin. This could allow you to set one GUI Skin and draw half of the GUI, then set a different GUI Skin and draw the other half in a completely different style.<div><pre class="programlisting">if(guiSkin != null) GUI.skin = guiSkin;</pre></div></li><li class="listitem">If you play your game now, it won't look like much. The defaults of a new GUI Skin are the exact same as the default GUI Skin that Unity uses. Let us change that by selecting our <code class="literal">GameSkin</code> and expanding <strong>Button</strong> and <strong>Label</strong> in the <strong>Inspector</strong> window.</li><li class="listitem">For <strong>Button</strong> we created a <strong>ButtonNormal</strong> and <strong>ButtonActive</strong> image. By dragging those to the <strong>Background</strong> properties of the respective states, the look of the buttons will change.</li><li class="listitem">The supplied button images have a yellow background, which will make the white text hard to read. So, by clicking on the color next to the <strong>Text Color</strong> property, the <strong>Color Picker</strong> window will open and we can select a new color. A navy blue for the <strong>Normal</strong> state and a faded blue for the <strong>Active</strong> state works well.</li><li class="listitem">Also, to keep it from looking weird in the Unity Editor, remove the <strong>Hover</strong> state. With a touch interface, there is no cursor to hover over buttons; therefore, there is no need for a hover state. To remove it, first click on the little circle to the right of the <strong>Background</strong> image.<div><img src="img/2014OT_02_06.png.jpg" alt="Time for action – styling the game"/></div></li><li class="listitem">The new window that pops up allows us to select any image that is currently in our project. <a id="id152" class="indexterm"/>However, since we want nothing to be in there select <strong>None</strong>, the first option in the list.</li><li class="listitem">The borders on the button images are much larger than those of the default buttons. So, we need to adjust the <strong>Border</strong> attribute to accommodate them. Values of 15 for each side works well.</li><li class="listitem">The text is also too small, so for the <strong>Font Size</strong> attribute choose a value of 40. This will give us a large and easily readable text.</li><li class="listitem">For the <strong>Label</strong> element, we are only going to make two changes. First, the text is too small. So, it will also get a value of 40 for its font size. Second, we want the text to be centered in the GUI elements. That requires setting the alignment to middle center.<div><img src="img/2014OT_02_07.png.jpg" alt="Time for action – styling the game"/></div></li><li class="listitem">Play the game now. It is already looking better or at least different. However, it is a little difficult to tell at a glance who controls which square. To fix this we are going to create two custom GUI Styles. To do this, expand the <strong>Custom Styles</strong> <a id="id153" class="indexterm"/>attribute of our <code class="literal">GameSkin</code> in the <strong>Inspector</strong> window. By default, one blank style is already in there. We are going to need two, but don't change the quantity just yet.</li><li class="listitem">Expand the custom GUI Style, by default called <code class="literal">Element 0</code>.</li><li class="listitem">On clicking to the right of the <strong>Name</strong> attribute, more or less in the middle of the <strong>Inspector</strong> window, will allow us to rename the style. The name is very important. Whatever we call it here we need to call it exactly the same in code or it won't be used. Give it the name <code class="literal">XSquare</code> because it will be used to mark which squares are controlled by the X player.</li><li class="listitem">Inside of the <strong>Normal</strong> state, add the <strong>XNormal</strong> image to the <strong>Background</strong> attribute. The <strong>Text Color</strong> attribute can be left as black. We also need to adjust the font size and alignment properties to the same as we did for the <strong>Label</strong> element. So, set them to <strong>40</strong> and <strong>MiddleCenter</strong> respectively.</li><li class="listitem">Now that we have created the first style, creating the second becomes fast and easy. Collapse the <strong>XSquare</strong> style.</li><li class="listitem">Set the size of the <strong>Custom Styles</strong> attribute to <strong>2</strong>. When increasing the size of arrays in the Unity<a id="id154" class="indexterm"/> Editor, Unity duplicates whatever was the last item in the array to each of the new slots. So, we should now have two <code class="literal">XSquare</code> GUI Styles.</li><li class="listitem">Expand the second GUI Style and change its name to <code class="literal">Osquare</code>.</li><li class="listitem">Also, replace the <code class="literal">XNormal</code> <strong>Background</strong> image with the <code class="literal">ONormal</code> image.<div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>If you are having trouble in dragging-and-dropping in the <strong>Inspector</strong> window, the <code class="literal">GameSkin</code> keeps losing focus perhaps; there is a lock at the top of the <strong>Inspector</strong> window. Clicking on that will stop the window from changing to anything else when a new object is selected. Clicking it again will toggle off this feature.</p></div></div></li><li class="listitem">Just because we have our spiffy new custom GUI Styles, doesn't mean they will work automatically. But, just a little bit of coding will make them work. Inside our <code class="literal">DrawGameBoard</code> function of the <code class="literal">TicTacToeControl</code> script, we need to change the line that draws our label by adding a little bit to the end of it. The addition of a second string will tell the GUI system to look for a specific GUI Style. A little bit earlier in the function, we figure out who owns the square, is it X or O. By adding this to <code class="literal">Square</code> we create the names of our two custom GUI Styles, <code class="literal">XSquare</code> and <code class="literal">OSquare</code>.<div><pre class="programlisting">else GUI.Label(square, owner, owner + "Square");</pre></div></li><li class="listitem">If you play the game now, you will see that when a player claims control of a square, our custom styles appear.<div><img src="img/2014OT_02_08.png.jpg" alt="Time for action – styling the game"/></div></li><li class="listitem">There is one<a id="id155" class="indexterm"/> more thing to do to change the look of our Tic-tac-toe game. Do you remember the title image that was created and for which we added a variable? Now is the time to place that. Inside of <code class="literal">TicTacToeControl</code> go to the <code class="literal">DrawOpening</code> function. To draw our image, we need to replace the call to <code class="literal">GUI.Label</code> with a call to <code class="literal">GUI.DrawTexture</code>. Instead of using GUI Styles, this function simply draws an image to the screen. It uses a <code class="literal">Rect</code> class, just as with all of our <strong>Buttons</strong> and <strong>Labels</strong>, to define a size and position. The image is, by default, stretched to fill the whole <code class="literal">Rect</code> class. For now, this suits us just fine.<div><pre class="programlisting">GUI.DrawTexture(titleRect, titleImage);</pre></div></li><li class="listitem">We can fix the stretching by updating the previous line of code, where we defined the <code class="literal">Rect</code> class for our title to accommodate. As you can see by the following code snippet, we use the width and height of <code class="literal">titleImage</code> to determine the width and height of <code class="literal">titleRect</code>. The <code class="literal">Rect</code> class now automatically determines how large it should be based on the size of our title image. If the <code class="literal">Rect</code> class is of the same size and shape as the image, it won't be stretched. In addition to that, because of the way we defined the <code class="literal">Rect</code> class for our <strong>New Game</strong> button<a id="id156" class="indexterm"/>, it will still be directly under and just as wide as our title image.<div><pre class="programlisting">Rect titleRect = new Rect(0, 0, titleImage.width, titleImage.height);</pre></div></li><li class="listitem">That is all there for<a id="id157" class="indexterm"/> styling our Tic-tac-toe game. Click on the <strong>Play</strong> button and take a look at all your hard work.<div><img src="img/2014OT_02_09.png.jpg" alt="Time for action – styling the game"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>
<em>What just happened?</em>
</h2></div></div></div><p>We made our Tic-tac-toe game look great, or at least not like the defaults. We achieved this through the use of a handful of images and some custom GUI Skins and GUI Styles. With the addition of a special function for drawing textures on screen, we also add a unique title image to our opening screen.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Have a go hero – backgrounds</h2></div></div></div><p>Your challenge here is to make a background image and draw it behind the game. It also has to cover the whole of the screen. The default blue is great, but we could do so much better. As a note, whichever GUI element was drawn last is drawn on top, so think carefully about where<a id="id158" class="indexterm"/> to call the function to have the image drawn in the background. Also, since stretching is only good for exercising and rubber bands, take a look at also passing the function a <code class="literal">ScaleMode</code>, which is a special value type that Unity uses to determine how images should stretch. Look in the scripting reference or search online to find more information about it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Dynamic positioning</h1></div></div></div><p>You are probably thinking that it is all well and good that the game is all styled now, but everything is still sitting in the top-left corner of the screen. Well then, you are in luck. That is exactly the topic of this section. It is not enough to simply adjust the numbers in our <code class="literal">Rects</code> until our GUI is centered. While working with the Android platform and other mobile devices, we have to be prepared for a large variety of possibilities. Not every device that our games will be played on will have the same screen size. So, you may position your GUI to be centered on your tablet, but it will be far off screen on a phone.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Time for action – the dynamic GUI</h1></div></div></div><p>We will be covering two excellent ways of dynamically adjusting our GUI to meet any screen requirements. The opening screen and the game over screen will both be centered. We will stretch the game board to<a id="id159" class="indexterm"/> fill the available space. The turn indicator text will also be set up to automatically change position based on the screen orientation.</p><div><ol class="orderedlist arabic"><li class="listitem">Again, let's start with our main menu. Open up the <code class="literal">TicTacToeControl</code> script and go to the <a id="id160" class="indexterm"/><code class="literal">DrawOpening</code> function.</li><li class="listitem">To center the menu, we will wrap up the contents as a GUI group by adding the following line of code at the beginning of the <code class="literal">DrawOpening</code> function<a id="id161" class="indexterm"/>. Think of GUI's grouping as<a id="id162" class="indexterm"/> <strong>picture-in-picture</strong> (<strong>PIP</strong>) that some televisions can do. Pick a rectangle section on screen and draw some other channel in it. So, first we are deciding where to draw our group. We do this by finding the center of the screen, <code class="literal">Screen.width</code> and <code class="literal">Screen.height</code> is divided by two. But, because GUI content is positioned at the top-left corner, we must subtract half our content's size to find that corner. For the width, that is simply the width of our title image. But the height is a combination of the image and the button below.<div><pre class="programlisting">Rect groupRect = new Rect((Screen.width / 2) - (titleImage.width / 2), (Screen.height / 2) - ((titleImage.height + 75) / 2), titleImage.width, titleImage.height + 75);</pre></div></li><li class="listitem">The <a id="id163" class="indexterm"/><code class="literal">BeginGroup</code> function of the GUI is what gives us the PIP effect. Any GUI elements that are drawn after a call to this function are confined to the <code class="literal">Rect</code> class that was passed to the function. Instead of positions starting from the top-left corner of the screen, elements within the group will start at the top-left corner of the group <code class="literal">Rect</code>. Anything that extends beyond the edges of the group is also not drawn, just as if it extended beyond the edges of the screen.<div><pre class="programlisting">GUI.BeginGroup(groupRect);</pre></div></li><li class="listitem">Before we can see<a id="id164" class="indexterm"/> the group in action, we must add a line to the end of our <a id="id165" class="indexterm"/><code class="literal">DrawOpening</code> function. <code class="literal">EndGroup</code> is the direct counterpart to <code class="literal">BeginGroup</code>. If ever you use <code class="literal">BeginGroup</code>, there must be a corresponding call to <code class="literal">EndGroup</code>. Should you fail to pair up the function calls, Unity will make no end of complaints until the problem is fixed. It is really quite annoying.<div><pre class="programlisting">GUI.EndGroup();</pre></div></li><li class="listitem">With that line added, play the game. The main menu will now center itself. It will do this no matter the screen size. Also, it will do this whether the screen is in landscape or in portrait mode. In this case, the trick to keeping everything on screen is to plan for the smallest screen size and make images and GUI elements that fit accordingly.</li><li class="listitem">Skipping ahead a little, we can use a similar method for centering the game over screen. Add the following line of code to the beginning of the <code class="literal">DrawGameOver</code> function<a id="id166" class="indexterm"/>. You can see that we are doing the same thing we did a moment ago. Figure out where the center of the screen is and subtract half of the total size of our content. In this case we supplied solid numbers instead of keying off the size of an image. Also, because the math is easy, we already did the divisions to come up with <code class="literal">150</code> and <code class="literal">75</code>.<div><pre class="programlisting">Rect groupRect = new Rect((Screen.width / 2) - 150, (Screen.height / 2) - 75, 300, 150);
GUI.BeginGroup(groupRect);</pre></div></li><li class="listitem">Be sure to add your<a id="id167" class="indexterm"/> <code class="literal">EndGroup</code> function call to the end of the <a id="id168" class="indexterm"/><code class="literal">DrawGameOver</code> function.<div><pre class="programlisting">GUI.EndGroup();</pre></div></li><li class="listitem">After that, find the line where we define the <a id="id169" class="indexterm"/><code class="literal">winnerRect variable</code> class. We need to change it so it is easier to adjust the size and fit the contents, should we want to. Because of the way we set up the <strong>winner</strong> label and <strong>main menu</strong> button, this will cause each to take up the whole width of the group. They will also split the available height evenly; hence the division is by two.<div><pre class="programlisting">Rect winnerRect = new Rect(0, 0, groupRect.width, groupRect.height / 2);</pre></div></li><li class="listitem">Now we have the tricky part to do. For the game board, we want it to expand evenly so that it fills whichever direction is shortest. The turn indicator should be centered in the remaining space. Because the board needs to dynamically expand and the turn indicator needs to be either in the right or bottom of the screen, based on orientation, we can't get away with using our GUI group functions. Instead, we first need to figure out which side of our screen is smaller, the width or the height. This is fairly simple with the following lines of code added to the beginning of the<a id="id170" class="indexterm"/> <code class="literal">DrawGameBoard</code> function. Recognize the conditional statement, our good old friend? First, we create a variable to hold the result of comparing the width and height of the screen; we will be using it again later. If the width is smaller, obviously the small side is the width; otherwise it is the height.<div><pre class="programlisting">bool widthSmaller = Screen.width &lt; Screen.height;
float smallSide = widthSmaller ? Screen.width : Screen.height;</pre></div></li><li class="listitem">Next we change our width and height definitions. Because the game board is a 3 x 3 grid, once we have the small side it is a simple matter to figure out how big the squares should be to fill the space. The change to the height is to keep the board squares actually square. Perhaps you remember from your first geometry lessons? The width and height of the sides of a square are equal.<div><pre class="programlisting">float width = smallSide / 3;
float height = width;</pre></div></li><li class="listitem">Playing the game at this point, we will be able to experience a game board that scales with our game screen. Try it out!<div><img src="img/2014OT_02_10.png.jpg" alt="Time for action – the dynamic GUI"/></div></li><li class="listitem">Remember when we were connecting Unity Remote? Use the drop-down menu in the top-left corner of the<a id="id171" class="indexterm"/> <strong>Game</strong> window to select different screen sizes and orientations. This does, however, reveal another small error. The turn indicator text sometimes appears over the top of our game board. Other times it may be beyond the edges of the screen. Or, perhaps you already noticed that one? Either way, to make it better we need to find the <a id="id172" class="indexterm"/><code class="literal">Rect</code> class that will cover the remaining negative space.</li><li class="listitem">After the initial definition of our <code class="literal">turnRect</code>, add the following code snippet. Using our conditional friends, we figured out all we need to place the <code class="literal">Rect</code> class in the negative space. If the width is smaller in portrait mode, the negative space starts at the left side of the screen, zero. The y position of the space begins where the board ends, the equivalent of the width; it is a square board, after all. The total width of the negative space is also equivalent to the width of the screen. The height becomes whatever is left over from the difference between the height and the width. If we are in landscape mode instead, the height being smaller than the width, the positioning is largely determined in the same way.<div><pre class="programlisting">turnRect.x = widthSmaller ? 0 : smallSide;
turnRect.y = widthSmaller ? smallSide : 0;
turnRect.width = widthSmaller ? Screen.width : Screen.width - Screen.height;
turnRect.height = widthSmaller ? Screen.height - Screen.width : Screen.height;</pre></div></li><li class="listitem">This is all well and good. Looks pretty good with the turn text actually positioned where it can easily be seen and read. But, in some of those screen sizes there is an awful lot of empty space. If only there was some way we could scale the text to better fit the space. It just so happens that there is a good way to do just that. After we are done messing with the turn indicator's <code class="literal">Rect</code>, we can add the following line of code. This touch of code gets the label GUI Style from the current GUI Skin and creates a duplicate. In code, if we ever create a new GUI Style and pass another one as the argument, all of the values are copied into the new GUI Style. This allows us to cause temporary and dynamic changes without ruining the whole GUI Skin being used.<div><pre class="programlisting">GUIStyle turnStyle = new GUIStyle(GUI.skin.GetStyle("label"));</pre></div></li><li class="listitem">In the next line of code we'll adjust the font size. To do this we have to figure out how much space is left on the long side of the screen after the game board is scaled up. Adding the width and height of the screen results in the total amount of screen distance available. By subtracting the smaller of the two sides, the distance that the game board covers multiplied by two, we are left with the excess negative space. Dividing all of that by one hundred, the amount of space that we had previously used for our turn indicator, will scale the font size to proportionately fit the change in space. It is finally wrapped in an explicit conversion to the integer type because the font size value must be defined as an integer.<div><pre class="programlisting">turnStyle.fontSize *= (int)((Screen.width + Screen.height - (smallSide * 2)) / 100);</pre></div></li><li class="listitem">To actually see this dynamic font size in action, we need to make a change to the line that draws the turn indicator. We change the call to the <code class="literal">Label</code> function to use the temporary style. Instead of providing the name of the GUI Style to GUI functions, we can provide a specific GUI Style. The function will then use this style to draw the GUI element.<div><pre class="programlisting">GUI.Label(turnRect, turnTitle, turnStyle);</pre></div></li><li class="listitem">Try it out. By clicking on the <a id="id173" class="indexterm"/><strong>Game window</strong> tab and dragging it into the <strong>Game</strong> window, you can undock the window and make it free floating. Changing the aspect ratio, that drop-down menu in the top-right corner of the <strong>Game</strong> window<a id="id174" class="indexterm"/>, to <strong>Free Aspect</strong> allows us to freely re-size the window and witness our great work in action.<div><img src="img/2014OT_02_11.png.jpg" alt="Time for action – the dynamic GUI"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>
<em>What just happened?</em>
</h2></div></div></div><p>We made our game change dynamically based on the screen of our devices. Both of the menu screens will center themselves. We also caused our game board to grow and shrink until it fills as much of the screen as it can. We then used a carefully applied bit of code magic to make the turn indicator automatically position itself and change font size to fill the remaining space.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Have a go hero – scaling menus</h2></div></div></div><p>The second challenge is a little tougher. Continue to use the GUI groups, but make the opening screen and the game over screen scale with the screen size. If you want a subchallenge with this one, see what you can do about scaling the text with it as well. And, don't forget about the text used to indicate control of the game board squares.</p><p>If you want to prepare for even more devices, change the Rects that we use throughout the section. Wherever we used specific numbers for position or size on screen, change them to percent. You will have to calculate the pixel size using percent and the size of the screen. That calculated amount can then be passed to and used in our Rects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec33"/>A better way to build to device</h1></div></div></div><p>Now for the part of the build process that everyone itches to learn. There is a quicker and easier way to have your game built and playing on your Android device. The long and complicated way is still very good to know. Should this shorter method fail, and it will at some point, it is helpful to know the long method so you can debug any errors. Also, the short path is only good for building to a single device. If you have multiple devices and a large project, it will take significantly more time to load them all with the short path.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Time for action – build and run</h1></div></div></div><p>With this alternate build<a id="id175" class="indexterm"/> method, we can quickly and easily test games on our devices as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Start by opening the <strong>Build Settings</strong> window. Remember, it can be found under <strong>File</strong> at the top of the Unity Editor.</li><li class="listitem">Click on the <strong>Add Current</strong> button to add our current scene, also the only scene, to the list of <strong>Scenes In Build</strong>. If this list is empty, there is no game.</li><li class="listitem">Be sure to change your <strong>Platform</strong> to <strong>Android</strong>, if you haven't already done so. It is after all still the point of this book.</li><li class="listitem">Do not forget to set the <strong>Player Settings</strong>. Click on the <a id="id176" class="indexterm"/><strong>Player Settings</strong> button to open them up in the <strong>Inspector</strong> window. Do you remember this from <a class="link" href="ch01.html" title="Chapter 1. Saying Hello to Unity and Android">Chapter 1</a>, <em>Saying Hello to Unity and Android</em>.</li><li class="listitem">At the top, set the <strong>Company Name</strong> and <strong>Product Name</strong> fields. Values of <code class="literal">TomPacktAndBegin</code> and <code class="literal">Ch2 TicTacToe</code> respectively will match the included completed project. Remember, these are seen by the people playing your game.</li><li class="listitem">The <strong>Bundle Identifier</strong> field under <strong>Other Settings</strong> needs to be set as well. The format is still <code class="literal">com.CompanyName.ProductName</code>, so <code class="literal">com.TomPactAndBegin.Ch2.TicTacToe</code> will work well.</li><li class="listitem">So that we can see our cool dynamic GUI in action on a device, there is one other setting that should be changed. Click on <strong>Resolution</strong> and <strong>Presentation</strong> to expand the options.</li><li class="listitem">We are interested in <strong>Default Orientation</strong>. The default is <strong>Portrait</strong>, but this option means the game will be fixed in the portrait display mode. Click on the drop-down menu and select <strong>Auto Rotation</strong>. This option tells Unity to automatically adjust the game to be upright in whichever orientation the device is being held.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The new<a id="id177" class="indexterm"/> set of options that popped up when <strong>Auto Rotation</strong> was selected allow for the limiting of the orientations that are supported. Perhaps you are making a game that needs to be wider and held in landscape orientation. By unchecking <strong>Portrait</strong> and <strong>Portrait Upside Down</strong>, Unity will still adjust (but only for the remaining orientations). On your Android device, along one of the shorter sides, are the controls of some sort usually a home, menu, back, and search set of buttons. This side is generally recognized as the bottom of the device and it is the position of these buttons that dictates what each orientation is. <strong>Portrait</strong> is when those buttons are down relative to the screen. <strong>Landscape Right</strong> is when they are to the right. The pattern begins to come clear, does it not?</li></ul></div></li><li class="listitem">For now, leave all of the orientation options checked and we will go back to <strong>Build Settings</strong>.</li><li class="listitem">The next step (and this is very important) is to connect your device to your computer and give it a moment to be recognized. If your device is not first connected to your computer, this shorter build path will fail.</li><li class="listitem">In the bottom-right corner of the <strong>Build Settings</strong> window, click on the <strong>Build And Run</strong> button.<a id="id178" class="indexterm"/> You will be asked to give the application file, the APK, a relevant name and save it to an appropriate location. A name <code class="literal">Ch2_TicTacToe.apk</code> will be fine and it is suitable enough to save the file to the desktop.</li><li class="listitem">Click on <strong>Save</strong> and sit back to watch the wonderful loading bar that is provided. If you paid attention to the loading bar when we built the <em>Hello World</em> project in <a class="link" href="ch01.html" title="Chapter 1. Saying Hello to Unity and Android">Chapter 1</a>, <em>Saying Hello to Unity and Android</em>, you will notice that there is an extra step taken this time around. After the application is built, there is a pushing to device step. This means the build was successful and Unity is now putting the application on your device and installing it. Once done, the game will be started on the device and the loading bar will be finished.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just learned about the <strong>Build And Run</strong> button<a id="id179" class="indexterm"/> provided by the <strong>Build Settings</strong> window. Quick, easy, and free from command prompt pain; isn't the short build path wonderful? But if the build process fails for any reason including being unable to find the device, the application<a id="id180" class="indexterm"/> file will not be saved. You will have to sit through the entire build process again, if you want to try installing again. This isn't so bad for our simple Tic-tac-toe game, but might consume a lot of time for a larger project. Also, you can only have one Android device connected to your computer while building. Any more and the build process is a guaranteed failure. Unity also doesn't check for multiple devices until after it has gone through the rest of the potentially long build process.</p><p>Other than those words of caution, the <a id="id181" class="indexterm"/>
<strong>Build And Run</strong> option is really quite nice. Let Unity handle the hard part of getting the game to your device. This gives us much more time to focus on testing and making a great game.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Have a go hero – single player mode</h2></div></div></div><p>This is a tough one. Create a single player mode. You will have to start by adding an extra game state. Is the choice of <code class="literal">MultiPlayer</code> for a game state starting to make sense? The opening screen is going to need an extra button for selecting the second game mode. Also, any logic for the computer<a id="id182" class="indexterm"/> player should go in the <code class="literal">Update</code> function<a id="id183" class="indexterm"/> that is provided by the <code class="literal">MonoBehaviour</code> class. The computer needs to take its turn before we check for victory in <code class="literal">LateUpdate</code>. The <code class="literal">Update</code> function is just the place to do it. Also, take a look at <code class="literal">Random.Range</code> for randomly selecting a square to take control of. Or, you could do a little more work and make the computer search for a square where it can win or create a line of two matches.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Summary</h1></div></div></div><p>At this point, you should be familiar with Unity's GUI system including GUI Skins, GUI Styles, and a variety of GUI functions.</p><p>In this chapter, we learned all about the GUI by creating a Tic-tac-toe game. We first became familiar with drawing buttons and the like to the GUI. After delving into the depths and gaining understanding of GUI Styles and GUI Skins, we applied the knowledge to make our game look even better. The game continued to improve when we added some dynamic positioning to our GUI elements. The opening and closing screens became centered, while the game board dynamically scaled to fill the screen. Finally, we explored an alternative build method for putting our game onto devices.</p><p>In the next chapter, we will be starting a new and more complex game. The Tank Battle game that we will be creating will be used to gain understanding with the basic building blocks of any game: meshes, materials, and animations. When all is done, we will be able to drive a tank around a colorful city and shoot animated targets.</p></div></body></html>