<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting Started with Kotlin</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we'll cover basic Kotlin syntax, and discuss what design patterns are good for and why they should be used in Kotlin.</p>
<p class="calibre2"><span class="calibre7">The goal of this chapter is not to cover the entire language vocabulary, but to get you familiar with some basic concepts and idioms. The following chapters will slowly expose you to more language features as they become relevant to the design patterns we'll discuss.</span></p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Basic language syntax and features</li>
<li class="calibre12">Introduction to design patterns</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Basic language syntax and features</h1>
                
            
            <article>
                
<p class="calibre2">Whether you come from Java, C#, Scala or any other statically typed programming language, you'll find Kotlin syntax quite familiar. This is not by coincidence, but to make the transfer to this new language as smooth as possible for those with previous experience in other languages. Besides that familiarity, Kotlin brings a vast amount of features, such as better type safety. As we move ahead, you'll notice that all of them are attempting to solve real-world problems. That pragmatic approach is very consistent across the language. For example, one of the strongest sides of Kotlin is complete Java interoperability. You can have Java and Kotlin classes alongside each other, and freely use any library that is available in Java for a Kotlin project.</p>
<p class="calibre2">To summarize, the goals of language are as follows:</p>
<ul class="calibre11">
<li class="calibre12">Pragmatism</li>
<li class="calibre12">Having clear syntax</li>
<li class="calibre12">Being type-safe</li>
<li class="calibre12">Interoperability</li>
</ul>
<p class="calibre2">The first chapter will discuss how these goals are achieved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multi-paradigm</h1>
                
            
            <article>
                
<p class="calibre2">Some of the major paradigms in programming languages are procedural, object-oriented, and functional paradigms.</p>
<p class="calibre2">Being practical, Kotlin allows for any of these paradigms. It has classes and inheritance, coming from the object-oriented approach. It has higher-order functions from functional programming. But you don't have to wrap everything in classes if you don't want to. You can structure your entire code as just a set of procedures and structs. You will see how all these approaches come together, as different examples will use different paradigms to solve the problems discussed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Code structure</h1>
                
            
            <article>
                
<p class="calibre2">The first thing you'll need to do when you start programming in Kotlin is create a new file. Kotlin's extension is usually <kbd class="calibre13">.kt</kbd>.</p>
<p class="calibre2">Unlike Java, there's no strong relationship between the filename and class name. You can put as many public classes in your file as you want, as long as the classes are related to one another and your file doesn't grow too long to read.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">No semicolons</h1>
                
            
            <article>
                
<p class="calibre2">In Java, every line of code must be terminated with a semicolon:</p>
<pre class="calibre18">System.out.println("Hello")<strong class="calibre1">; //&lt;- This is a semicolon<br class="title-page-name"/></strong>System.out.println("World");<strong class="calibre1"> //&lt;- I still see you, semicolon<br class="title-page-name"/></strong></pre>
<p class="calibre2">But Kotlin is a pragmatic language. So, instead, it infers during compilation where it should put the semicolons:</p>
<pre class="calibre18">println("Hello") <strong class="calibre1">//&lt;- No semicolon here</strong><br class="title-page-name"/>println("World") <strong class="calibre1">//&lt;- Not here</strong></pre>
<p class="calibre2">Most of the time, you won't need to put semicolons in your code. They're considered optional. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Naming conventions</h1>
                
            
            <article>
                
<p class="calibre2">As a convention, if your file contains a single class, name your file the same as your class.</p>
<p class="calibre2">If your file contains more than one class, then the filename should describe the common purpose of those classes. Use CamelCase when naming your files, as per the Kotlin Coding Conventions: <a href="https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules" class="calibre10">https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules</a>.</p>
<div class="packt_infobox">Actually, you don't have to write your code in a file for simple snippets. You can also play with the language online: try <a href="http://kotlinlang.org/" class="calibre19">http://kotlinlang.org/</a> or use REPL and interactive shell after installing Kotlin and running <kbd class="calibre20">kotlinc</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Packages</h1>
                
            
            <article>
                
<p class="calibre2">It wouldn't be convenient to have all your classes and functions in the same folder or under the same namespace. That's the reason Kotlin, similar to many other languages, uses the notion of a package. </p>
<p class="calibre2">Like Java, Kotlin uses packages:</p>
<pre class="calibre18">package me.soshin.controllers</pre>
<p class="calibre2">If you're mixing Java and Kotlin, Kotlin files should follow Java package rules.</p>
<p class="calibre2">In purely Kotlin projects, common package prefixes can be omitted from the folder structure. For example, if all your projects are under the <kbd class="calibre13">me.soshin</kbd> package, place your controllers in the <kbd class="calibre13">/controllers</kbd> folder and not in the <kbd class="calibre13">/me/soshin/controllers</kbd> folder like Java does.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Types</h1>
                
            
            <article>
                
<p class="calibre2">We'll start with the Kotlin type system, and compare it to what Java provides.</p>
<div class="packt_infobox">The Java examples are for familiarity, and not to prove that Kotlin is superior to Java in any way.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type inference</h1>
                
            
            <article>
                
<p class="calibre2">Let's define a simple string in Java:</p>
<pre class="calibre18">String s = "Hello World";</pre>
<p class="calibre2">We defined that<span class="calibre7"> </span><kbd class="calibre13">s</kbd><span class="calibre7"> </span>is of type<span class="calibre7"> </span><kbd class="calibre13">String</kbd>. But why? Isn't it obvious at this point?</p>
<p class="calibre2">Kotlin provides us with type inference:</p>
<pre class="calibre18">val s = "Hello World"</pre>
<p class="calibre2">Now, the compiler will decide what type of variable should be used. Unlike interpreted languages (such as JavaScript, Groovy, or Ruby), the type of variable is defined only once. This will not work:</p>
<pre class="calibre18">var s = "I'm a string"<br class="title-page-name"/>s = 1 // s is a String</pre>
<p class="calibre2"><span class="calibre7">You may wonder why we've used one </span><kbd class="calibre13">var</kbd><span class="calibre7"> and one </span><kbd class="calibre13">val</kbd><span class="calibre7"> to define the variables. We'll explain it shortly.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">val versus var</h1>
                
            
            <article>
                
<p class="calibre2">In Java, variables can be declared final. Final variables can be assigned only once:</p>
<pre class="calibre18">final String s = "Hi";<br class="title-page-name"/>s = "Bye"; // Doesn't work</pre>
<p class="calibre2">Kotlin urges you to use immutable data as much as possible. Final variables in Kotlin are simply<span class="calibre7"> </span><kbd class="calibre13">val</kbd>:</p>
<pre class="calibre18">val s = "Hi"<br class="title-page-name"/>s = "Bye" // Doesn't work</pre>
<p class="calibre2">If you do have a case in which you would like to reassign a variable, use<span class="calibre7"> </span><kbd class="calibre13">var</kbd><span class="calibre7"> </span>instead:</p>
<pre class="calibre18">var s = "Hi"<br class="title-page-name"/>s = "Bye" // Works now</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Comparison</h1>
                
            
            <article>
                
<p class="calibre2">We were taught very early in Java that comparing objects using <kbd class="calibre13">==</kbd> won't produce the expected results, since it tests for reference equality, and we need to use <kbd class="calibre13">equals()</kbd> for that.</p>
<p class="calibre2">JVM does string interning to prevent that in some basic cases, so for the sake of the example we'll use <kbd class="calibre13">new String()</kbd> to avoid that:</p>
<pre class="calibre18">String s1 = <span>"ABC"</span><span>;<br class="title-page-name"/></span>String s2 = <span>new </span>String(s1)<span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span>System.<span>out</span>.println(s1 == s2)<span>; // false</span></pre>
<p class="calibre2">Kotlin translates <kbd class="calibre13">==</kbd> to <kbd class="calibre13">equals()</kbd>:</p>
<pre class="calibre18"><span>val </span>s1 = <span>"ABC"<br class="title-page-name"/></span><span>val </span>s2 = <span>String</span>(s1.<span>toCharArray</span>())<br class="title-page-name"/><br class="title-page-name"/><span>println</span>(s1 == s2) // true</pre>
<p class="calibre2">If you do want to check for reference equality, use <kbd class="calibre13">===</kbd>:</p>
<pre class="calibre18"><span>println</span>(s1 === s2) // false</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Null safety</h1>
                
            
            <article>
                
<p class="calibre2">Probably the most notorious exception in the Java world is <kbd class="calibre13">NullPointerException</kbd>. </p>
<p class="calibre2">The reason behind this exception is that every object in Java can be <kbd class="calibre13">null</kbd>. The code here shows us why:</p>
<pre class="calibre18">String s = "Hello";<br class="title-page-name"/>...<br class="title-page-name"/>s = null;<br class="title-page-name"/>System.out.println(s.length); // Causes NullPointerException</pre>
<p class="calibre2">In this case, marking <kbd class="calibre13">s</kbd> as <kbd class="calibre13"><span>final</span></kbd> would prevent the exception.</p>
<p class="calibre2">But what about this one:</p>
<pre class="calibre18">public class Printer {    <br class="title-page-name"/>    public static void printLength(final String s) {<br class="title-page-name"/>       System.out.println(s.length);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">From anywhere in the code it's still possible to pass <kbd class="calibre13">null</kbd>:</p>
<pre class="calibre18">Printer.printLength(null); // Again, NullPointerException</pre>
<p class="calibre2">Since Java 8, there's been an <kbd class="calibre13">optional</kbd> construct:</p>
<pre class="calibre18"><span>if </span>(optional.isPresent()) {<br class="title-page-name"/>    System.<span>out</span>.println(optional.get())<span>;<br class="title-page-name"/></span>}</pre>
<p class="calibre2">In a more functional style:</p>
<pre class="calibre18">optional.ifPresent(System.<span>out</span>::println)<span>;</span></pre>
<p class="calibre2">But... it doesn't solve our problem. We can still pass <kbd class="calibre13">null</kbd> instead of the proper <kbd class="calibre13">Optional.empty()</kbd> and crash the program.</p>
<p class="calibre2">Kotlin checks it even earlier—during compile time:</p>
<pre class="calibre18">val s : String = null // Won't compile</pre>
<p class="calibre2">Let's go back to our <kbd class="calibre13">printLength()</kbd> function:</p>
<pre class="calibre18"><span>fun </span><span>printLength</span>(s: String) {<br class="title-page-name"/>    <span>println</span>(s.<span>length</span>)<br class="title-page-name"/>}</pre>
<p class="calibre2">Calling this function with null won't compile any more:</p>
<pre class="calibre18"><span>printLength</span>(<span>null</span>) // Null can not be a value of a non-null type String</pre>
<p class="calibre2">If you specifically want your type to be able to receive nulls, you'll need to mark it as nullable using the question mark:</p>
<pre class="calibre18">val notSoSafe : String? = null</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring functions</h1>
                
            
            <article>
                
<p class="calibre2">Everything is an object in Java. If you have a method that doesn't rely on any state, it still must be wrapped by a class. You're probably familiar with a lot of <kbd class="calibre13">Util</kbd> classes in Java that only have static methods, and their only purpose is to satisfy the language requirements and bundle those methods together.</p>
<p class="calibre2">In Kotlin, a function can be declared outside of a class instead of the following code:</p>
<pre class="calibre18">public class MyFirstClass {</pre>
<pre class="calibre18"><br class="title-page-name"/>    public static void main(String[] args) {<br class="title-page-name"/>        System.out.println("Hello world");<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">It's enough to have:</p>
<pre class="calibre18">fun main(args: Array&lt;String&gt;) {<br class="title-page-name"/>    println("Hello, world!")<br class="title-page-name"/>}</pre>
<p class="calibre2">Functions declared outside of any class are already static. </p>
<div class="packt_infobox">Many examples in this book assume that the code we provide is wrapped in the main function. If you don't see a signature of the function, it probably should be:<br class="calibre21"/>
<kbd class="calibre20">fun main(args: Array&lt;String&gt;)</kbd>.</div>
<p class="calibre2">The keyword to declare a function is <kbd class="calibre13">fun</kbd>. The argument type comes after the argument name, and not before. And if the function doesn't return anything, the return type can be omitted completely.</p>
<p class="calibre2">What if you do want to declare the return type? Again, it will come after the function declaration:</p>
<pre class="calibre18">fun getGreeting(): <span class="underline"><strong class="calibre1">String</strong> </span>{<br class="title-page-name"/>    return "Hello, world!"<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fun main(args: Array&lt;String&gt;) {<br class="title-page-name"/>    println(getGreeting())<br class="title-page-name"/>}</pre>
<p class="calibre2">There are lots of other topics regarding function declarations, such as default and named arguments, default parameters, and variable numbers of arguments. We'll introduce them in the following chapters, with relevant examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Control flow</h1>
                
            
            <article>
                
<p class="calibre2">One could say that control flow is the bread and butter of writing programs. We'll start with two conditional expressions: <kbd class="calibre13">if</kbd> and <kbd class="calibre13">when</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the if expression</h1>
                
            
            <article>
                
<p class="calibre2">Previously it was noted that Kotin likes variables to be assigned only once. And it also doesn't like nulls so much. You probably wondered how that would ever work out in the real world. In Java, constructs such as this are quite common:</p>
<pre class="calibre18">public String getUnixSocketPolling(boolean isBsd) {<br class="title-page-name"/>    String value = null;<br class="title-page-name"/>    if (isBsd) {<br class="title-page-name"/>        value = "kqueue";<br class="title-page-name"/>    }<br class="title-page-name"/>    else {<br class="title-page-name"/>        value = "epoll";<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    return value;<br class="title-page-name"/>}</pre>
<p class="calibre2">Of course, this is an oversimplified situation, but still, you have a variable that at some point absolutely must be <kbd class="calibre13">null</kbd>, right?</p>
<p class="calibre2">In Java, <kbd class="calibre13">if</kbd> is just a statement and doesn't return anything. On the contrary, in Kotlin, <kbd class="calibre13">if</kbd> is an expression, meaning it returns a value:</p>
<pre class="calibre18">fun getUnixSocketPolling(isBsd : Boolean) : String {<br class="title-page-name"/>    val value = if (isBsd) {<br class="title-page-name"/>        "kqueue"<br class="title-page-name"/>    } else {<br class="title-page-name"/>        "epoll"<br class="title-page-name"/>    }<br class="title-page-name"/>    return value<br class="title-page-name"/>}</pre>
<p class="calibre2">If you are familiar with Java, you can easily read this code. This function receives a Boolean (which cannot be null), and returns a string (and never a null). But since it is an expression, it can return a result. And the result is assigned to our variable only once.</p>
<p class="calibre2">We can simplify it even further: </p>
<ol class="calibre15">
<li value="1" class="calibre12">The return type could be inferred</li>
<li value="2" class="calibre12">The return as the last line can be omitted</li>
<li value="3" class="calibre12">A simple <kbd class="calibre13">if</kbd> expression can be written in one line</li>
</ol>
<p class="calibre2">So, our final result in Kotlin will look like this:</p>
<pre class="calibre18">fun getUnixSocketPolling(isBsd : Boolean) = if (isBsd) "kqueue" else "epoll"</pre>
<p class="calibre2">Single line functions in Kotlin are very cool and pragmatic. But you should make sure that somebody else other than you can understand what they do. Use with care.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the when expression</h1>
                
            
            <article>
                
<p class="calibre2">What if (no pun intended) we want to have more conditions in our <kbd class="calibre13">if</kbd> statement?</p>
<p class="calibre2">In Java, we use the <kbd class="calibre13">switch</kbd> statement. In Kotlin, there's a <kbd class="calibre13">when</kbd> expression, which is a lot more powerful, since it can embed some other Kotlin features.</p>
<p class="calibre2">Let's create a method that's based on the amount of money that  will give cause to suggest a nice birthday gift:</p>
<pre class="calibre18">fun suggestGift(amount : Int) : String {<br class="title-page-name"/>    return <span class="underline"><strong class="calibre1">when</strong> </span>(amount) {<br class="title-page-name"/>        <span class="underline"><strong class="calibre1">in</strong> </span>(0..10) -&gt; "a book"<br class="title-page-name"/>        in (10..100) -&gt; "a guitar"<br class="title-page-name"/>        else -&gt; if (amount &lt; 0) "no gift" else "anything!"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">As you can see, <kbd class="calibre13">when</kbd> also supports a range of values. The default case is covered by the <kbd class="calibre13">else</kbd> block. In the following examples, we will elaborate on even more powerful ways to use this expression.</p>
<p class="calibre2">As a general rule, use <kbd class="calibre13">when</kbd> if you have more than two conditions. Use <kbd class="calibre13">if</kbd> for simple checks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">String interpolation</h1>
                
            
            <article>
                
<p class="calibre2">What if we would like to actually print those results? </p>
<p class="calibre2">First, as you may have already noticed, in one of the examples above, Kotlin provides a nifty <kbd class="calibre13">println()</kbd> standard function that wraps the bulkier <kbd class="calibre13">System.out.println()</kbd> from Java.</p>
<p class="calibre2">But, more importantly, as in many other modern languages, Kotlin supports string interpolation using the <kbd class="calibre13">${}</kbd> syntax. Following on from the example before:</p>
<pre class="calibre18">println("I would suggest: ${suggestGift(10)} ")</pre>
<p class="calibre2">The preceding code would print: </p>
<pre class="calibre18"><strong class="calibre1">I would suggest: a book</strong></pre>
<p class="calibre2">If you're interpolating a variable, and not a function, curly braces could be omitted: </p>
<pre class="calibre18">val gift = suggestGift(100)<br class="title-page-name"/>println("I would suggest: $gift ")</pre>
<p class="calibre2">This would print the following output:</p>
<pre class="calibre18"><strong class="calibre1">I would suggest: a guitar</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Classes and inheritance</h1>
                
            
            <article>
                
<p class="calibre2">Although Kotlin is multi-paradigm, it has a strong affinity to the Java programming language, which is based on classes. Keeping Java and JVM interoperability in mind, it's no wonder that Kotlin also has the notion of classes and classical inheritance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Classes</h1>
                
            
            <article>
                
<p class="calibre2">To declare a <kbd class="calibre13">class</kbd>, we use a class keyword, exactly like in Java:</p>
<pre class="calibre18">class Player {<br class="title-page-name"/>}</pre>
<p class="calibre2">There's no <kbd class="calibre13">new</kbd> keyword in Kotlin. The instantiation of a class simply looks like this:</p>
<pre class="calibre18"><span>// Kotlin figured out you want to create a new player</span><br class="title-page-name"/>val p = Player() </pre>
<p class="calibre2">If the class has no body, as in this simple example, we can omit the <strong class="calibre5">curly brackets</strong>:</p>
<pre class="calibre18">class Player // Totally fine</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inheritance</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7">Exactly like in Java, abstract classes are marked by </span><kbd class="calibre13">abstract</kbd><span class="calibre7"> and interfaces by the </span><kbd class="calibre13">interface</kbd><span class="calibre7"> keyword:</span></p>
<pre class="calibre18"><span><strong class="calibre1">abstract</strong> class </span>AbstractDungeonMaster {<br class="title-page-name"/>    <span><strong class="calibre1">abstract</strong> val </span><span>gameName</span>: String<br class="title-page-name"/><br class="title-page-name"/>    <span>fun </span><span>startGame</span>() {<br class="title-page-name"/>        <span>println</span>(<span>"Game </span><span>$</span><span>gameName</span><span> has started!"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">interface</strong> Dragon</pre>
<p class="calibre2"><span class="calibre7">As in Java 8, interfaces in Kotlin can have a default implementation of functions, as long as they don't rely on any state:</span></p>
<pre class="calibre18"><span>interface </span>Greeter {<br class="title-page-name"/><strong class="calibre1">    <span>fun </span><span>sayHello</span>() {</strong><br class="title-page-name"/><strong class="calibre1">        <span>println</span>(<span>"Hello"</span>)</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/>}</pre>
<p class="calibre2">There are no <kbd class="calibre13">inherits</kbd> and <kbd class="calibre13">implements</kbd> keywords in Kotlin. Instead, both the name of an abstract class and <span class="calibre7">all the names of the interfaces that class implements</span> are put after a colon: </p>
<pre class="calibre18"><span>class </span>DungeonMaster<strong class="calibre1">: Greeter, AbstractDungeonMaster()</strong> {<br class="title-page-name"/>    <span>override val </span><span>gameName</span>: String<br class="title-page-name"/>        <span>get</span>() = <span>"Dungeon of the Beholder"<br class="title-page-name"/></span>}</pre>
<p class="calibre2">We can still distinguish the abstract class by the parenthesis<span class="calibre7"> that comes after its name, and there can still be only one <kbd class="calibre13">abstract</kbd> class, as there are no multiple inheritances in Kotlin.</span></p>
<p class="calibre2">Our <kbd class="calibre13">DungeonMaster</kbd> has access to both functions from <kbd class="calibre13">Greeter</kbd> and <kbd class="calibre13">AbstractDungeonMaster</kbd>:</p>
<pre class="calibre18"><span>val </span>p = DungeonMaster()<br class="title-page-name"/>p.sayHello()  // From Greeter interface<br class="title-page-name"/>p.startGame() // From AbstractDungeonMaster abstract class</pre>
<p class="calibre2">Calling the preceding code, it will print the following output:</p>
<pre class="calibre18"><strong class="calibre1">Hello</strong><br class="title-page-name"/><strong class="calibre1">Game Dungeon of the Beholder has started!</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructors</h1>
                
            
            <article>
                
<p class="calibre2">Our <kbd class="calibre13">DungeonMaster</kbd> looks a bit awkward now, since it can proclaim the start of only one game. Let's add a non-empty constructor to our <kbd class="calibre13">abstract</kbd> class to fix that:</p>
<pre class="calibre18"><span>abstract class </span>AbstractDungeonMaster(<span>private val </span><span>gameName </span>: String) {<br class="title-page-name"/>    <span>fun </span><span>startGame</span>() {<br class="title-page-name"/>        <span>println</span>(<span>"Game </span><span>$</span><span>gameName</span><span> has started!"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, our <kbd class="calibre13">DungeonMaster</kbd> must receive the name of the game and pass it to the <kbd class="calibre13">abstract</kbd> class:</p>
<pre class="calibre18"><span>open class </span>DungeonMaster(gameName: String):<br class="title-page-name"/>        Greeter<span>, </span>AbstractDungeonMaster(gameName)</pre>
<p class="calibre2">What if we wanted to extend <kbd class="calibre13">DungeonMaster</kbd> by having an <kbd class="calibre13">EvilDungeonMaster</kbd>?</p>
<p class="calibre2">In Java, all classes can be extended, unless they're marked <kbd class="calibre13">final</kbd>. In Kotlin, no class can be extended, unless it's marked <kbd class="calibre13">open</kbd>. The same goes for functions in abstract classes. That's the reason why we declared <kbd class="calibre13">DungeonMaster</kbd> as <kbd class="calibre13">open</kbd> in the first place.</p>
<p class="calibre2">We'll change <kbd class="calibre13">AbstractDungeonMaster</kbd> a bit again to give more power to the evil ruler:</p>
<pre class="calibre18"><span><strong class="calibre1">open</strong> fun </span><span>startGame</span>() {<br class="title-page-name"/>    // Everything else stays the same<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we add the following to our <kbd class="calibre13">EvilDungeonMaster</kbd> implementation:</p>
<pre class="calibre18"><span>class </span>EvilDungeonMaster(<span>private val </span><span>awfulGame</span>: String) : DungeonMaster(awfulGame) {<br class="title-page-name"/>    <span>override fun </span><span>sayHello</span>() {<br class="title-page-name"/>        <span>println</span>(<span>"Prepare to die! Muwahaha!!!"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    <span>override fun </span><span>startGame</span>() {<br class="title-page-name"/>        <span>println</span>(<span>"</span><span>$</span><span>awfulGame</span><span> will be your last!"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Whereas in Java, <kbd class="calibre13">@Override</kbd> is an optional annotation, in Kotlin it is a mandatory keyword.</p>
<p class="calibre2">You cannot hide supertype methods, and code that doesn't use <kbd class="calibre13">override</kbd> explicitly won't compile.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Properties</h1>
                
            
            <article>
                
<p class="calibre2">In Java, we are used to the concept of getters and setters. A typical class may look something like this:</p>
<pre class="calibre18"><span>public class </span>Person {<br class="title-page-name"/>    <span>private </span>String <span>name</span><span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>    public </span>String <span>getName</span>() {<br class="title-page-name"/>        <span>return </span><span>name</span><span>;<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/><br class="title-page-name"/>    <span>public void </span><span>setName</span>(String name) {<br class="title-page-name"/>        <span>this</span>.<span>name </span>= name<span>;<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/><br class="title-page-name"/>    // More methods come here<br class="title-page-name"/>}</pre>
<p class="calibre2">If we want to get a person's name, we call <kbd class="calibre13">getName()</kbd>. If we want to change it, we call <kbd class="calibre13">setName()</kbd>. That's quite simple.</p>
<p class="calibre2">If we want to set the name only once, during object instantiation, we can specify the non-default constructor and remove the setter as follows:</p>
<pre class="calibre18"><span>public class </span>ImmutablePerson {<br class="title-page-name"/>    <span>private </span>String <span>name</span><span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>    public </span><span>ImmutablePerson</span>(String name) {<br class="title-page-name"/>        <span>this</span>.<span>name </span>= name<span>;<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/><br class="title-page-name"/>    <span>public </span>String <span>getName</span>() {<br class="title-page-name"/>        <span>return </span><span>name</span><span>;<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/>}</pre>
<p class="calibre2">All this dates back to the beginning of Java, somewhere around '95.</p>
<p class="calibre2">But if you've worked with C#, for example, you're probably familiar with the idea of properties. To understand them, let's go to the first example and change it a bit:</p>
<pre class="calibre18"><span>public class </span>PublicPerson {<br class="title-page-name"/>    <span>public </span>String <span>name</span><span>;<br class="title-page-name"/></span>}</pre>
<p class="calibre2">Reading a person's name is not much shorter: <kbd class="calibre13">p.name</kbd>.</p>
<p class="calibre2">Also, changing the name is much more intuitive: <kbd class="calibre13">p.name = "Alex";</kbd>.</p>
<p class="calibre2">But by doing so, we lost a lot of control over our object. We cannot make <kbd class="calibre13">PublicPerson</kbd> immutable. If we want everybody to be able to read the person's name, they'll also be able to change it at any point in time. And what if later we decide that all names must be uppercase? With setter, we could do that. But not with the public field.</p>
<p class="calibre2">Properties provide a solution for all those problems:</p>
<pre class="calibre18">class Person() {<br class="title-page-name"/>    var name : String = ""<br class="title-page-name"/>}</pre>
<p class="calibre2">This may look the same as the Java example, with all its problems. But actually, behind the scenes, it's compiled to a getter and setter pair, just like the first example.</p>
<p class="calibre2">And since properties in Kotlin are translated into getters and setters, we can also control their behavior:</p>
<pre class="calibre18">class Person {<br class="title-page-name"/>    var name : String = ""<br class="title-page-name"/>    set(value) {<br class="title-page-name"/>        field = value.toUpperCase()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that we don't need to check that <kbd class="calibre13">value</kbd> is null. The <kbd class="calibre13">String</kbd> type simply cannot receive nulls.</p>
<p class="calibre2">Coming from Java, it may seem intuitive to use the following assignment: <kbd class="calibre13">this.name = value.toUpperCase()</kbd>. But, in Kotlin, this will create a circular dependency. Instead, there's a <kbd class="calibre13">field</kbd> identifier that we're using, which is provided automatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data classes</h1>
                
            
            <article>
                
<p class="calibre2">Remember how Kotlin is all about productiveness? One of the most common tasks for Java developers is to create another <strong class="calibre5"><span class="calibre7">Plain Old Java Object</span></strong> (<strong class="calibre5">POJO</strong>). If you're not familiar with POJO, it is basically an object that only has getters, setters, and an implementation of <kbd class="calibre13">equals</kbd> or <kbd class="calibre13">hashCode</kbd> methods.</p>
<p class="calibre2">This task is so common that Kotlin has it built into the language:</p>
<pre class="calibre18"><span>data class User (val username : String, val password : String)</span></pre>
<p class="calibre2">This will generate a class with two getters and no setters (note the <kbd class="calibre13">val</kbd> part), which will also implement <kbd class="calibre13">equals</kbd>, <kbd class="calibre13">hashCode</kbd>, and <kbd class="calibre13">clone</kbd> functions in the correct way.</p>
<p class="calibre2">The introduction of data classes is one of the biggest improvements in reducing the amount of boilerplate in the language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">More control flow – loops</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7">Now let's discuss another common control structure—a loop. Loops are a very natural construct for most developers. Without loops, it would be very hard to repeat the same block of code more than once (although we will discuss how to do that without loops in later chapters).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The for loop</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">for</kbd> loop in Java, which prints each character of a string on a new line, may look something like this:</p>
<pre class="calibre18">final String word = "Word";<br class="title-page-name"/>for (int i = 0; i &lt; word.length; i++) {<br class="title-page-name"/>    <br class="title-page-name"/>}</pre>
<p class="calibre2">The same loop in Kotlin is:</p>
<pre class="calibre18">val word = "Word";<br class="title-page-name"/>for (i in 0..(word.length-1)) {<br class="title-page-name"/>    println(word[i])<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that while the usual <kbd class="calibre13">for</kbd> loop in Java is exclusive (it excludes the last index by definition, unless specified otherwise), the <kbd class="calibre13">for</kbd> loop over ranges in Kotlin is inclusive. That's the reason we have to subtract one from the length to prevent overflow (string index out of range): <kbd class="calibre13">(word.length-1)</kbd>.</p>
<p class="calibre2">If you want to avoid that, you can use the <kbd class="calibre13">until</kbd> function:</p>
<pre class="calibre18">val word = "Word";<br class="title-page-name"/>for (i in 0 until word.length) {<br class="title-page-name"/>    println(word[i])<br class="title-page-name"/>}</pre>
<p class="calibre2">Unlike some other languages, reversing the range indexes won't work:</p>
<pre class="calibre18">val word = "Word";<br class="title-page-name"/>for (i in (word.length-1)..0) {<br class="title-page-name"/>    println(word[i])<br class="title-page-name"/>} // Doesn't print anything</pre>
<p class="calibre2">If your intention is to print the word in reverse order, for example, use the <kbd class="calibre13">downTo</kbd> function:</p>
<pre class="calibre18">val word = "Word";<br class="title-page-name"/>for (i in (word.length-1) downTo 0) {<br class="title-page-name"/>    println(word[i])<br class="title-page-name"/>}</pre>
<p class="calibre2">It will print the following output:</p>
<pre class="calibre18"><strong class="calibre1">d</strong><br class="title-page-name"/><strong class="calibre1">r</strong><br class="title-page-name"/><strong class="calibre1">o</strong><br class="title-page-name"/><strong class="calibre1">W</strong></pre>
<p class="calibre2">It may seem confusing that <kbd class="calibre13">until</kbd> and <kbd class="calibre13">downTo</kbd> are called functions, although they look more like operators. This is another interesting Kotlin feature called <strong class="calibre5">infix call</strong>, which will be discussed later on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">For-each loop</h1>
                
            
            <article>
                
<p class="calibre2">Of course, if you're a bit familiar with Java, you may argue that the previous code could be improved by using a <kbd class="calibre13">for-each</kbd> construct instead:</p>
<pre class="calibre18"><span>final </span>String word = <span>"Word"</span><span>;<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>for </span>(Character c : word.toCharArray()) {<br class="title-page-name"/>    System.<span>out</span>.println(c)<span>;<br class="title-page-name"/></span>}</pre>
<p class="calibre2">The same in Kotlin would be:</p>
<pre class="calibre18"><span>val </span>word = <span>"Word"<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>for </span>(c <span>in </span>word) {<br class="title-page-name"/>    <span>println</span>(c)<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">While loop</h1>
                
            
            <article>
                
<p class="calibre2">There are no changes to the <kbd class="calibre13">while</kbd> loop functionality, so we'll cover them very briefly:</p>
<pre class="calibre18">var x = 0<br class="title-page-name"/>while (x &lt; 10) { <br class="title-page-name"/>   x++ <br class="title-page-name"/>   println(x)<br class="title-page-name"/>}</pre>
<p class="calibre2">This will print numbers from 1 to 10. Note that we are forced to define <kbd class="calibre13">x</kbd> as <kbd class="calibre13">var</kbd>. In the following chapters, we'll discuss much more idiomatic ways to do this.</p>
<p class="calibre2">The lesser used <kbd class="calibre13">do while</kbd> loop is also present in the language:</p>
<pre class="calibre18">var x = 5<br class="title-page-name"/>   do { <br class="title-page-name"/>      println(x)<br class="title-page-name"/>      x--<br class="title-page-name"/>} while (x &gt; 0)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Extension functions</h1>
                
            
            <article>
                
<p class="calibre2">You may have noticed from the previous examples that <kbd class="calibre13">String</kbd> in Kotlin has some methods that its Java counterpart is lacking, such as <kbd class="calibre13">reversed()</kbd>. How is that achieved, if it's the same <kbd class="calibre13">String</kbd> type as in Java and, as we know, <kbd class="calibre13">String</kbd> in Java cannot be extended by any other class, since it's declared <kbd class="calibre13">final</kbd>?</p>
<p class="calibre2">If you look at the source code, you'll find the following:</p>
<pre class="calibre18"><span>public inline fun </span>String.reversed(): String {<br class="title-page-name"/>    <span>return </span>(<span>this as </span>CharSequence).reversed().toString()<br class="title-page-name"/>}</pre>
<p class="calibre2">This feature is called an extension function, and it also exists in some other languages, such as C# or Groovy. </p>
<p class="calibre2">To extend a class without inheriting from it, we prefix the function name, <kbd class="calibre13">reversed</kbd> in our example, with a class name we want to extend.</p>
<p class="calibre2">Do note that the extension function cannot override the member function. The <kbd class="calibre13">inline</kbd> keyword will be discussed in later chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to design patterns</h1>
                
            
            <article>
                
<p class="calibre2">Now that we are a bit familiar with basic Kotlin syntax, we can move on to discuss what design patterns are all about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What are design patterns?</h1>
                
            
            <article>
                
<p class="calibre2">There are different misconceptions surrounding design patterns. In general, they are as follows:</p>
<ul class="calibre11">
<li class="calibre12">Missing language features</li>
<li class="calibre12">Not necessary in dynamic language</li>
<li class="calibre12">Relevant only to object-oriented languages</li>
<li class="calibre12">Relevant only to enterprises</li>
</ul>
<p class="calibre2">But actually, design patterns are just a proven way to solve a common problem. As a concept, they are not limited to a specific programming language (Java), nor to a family of languages (C-family, for example), nor are they limited to programming in general. You may have even heard of design patterns in software architecture, which discuss how different systems can efficiently communicate with each other. There are service-oriented architectural patterns, which you may know as <strong class="calibre5">Service-Oriented Architecture</strong> (<strong class="calibre5">SOA</strong>), and microservice design patterns that evolved from SOA and emerged over the past few years. The future will, for sure, bring us even more design pattern <em class="calibre14">families</em>.</p>
<p class="calibre2">Even in the physical world, outside software development, we're surrounded by design patterns and commonly accepted solutions to a certain problem. Let's look at an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Design patterns in real life</h1>
                
            
            <article>
                
<p class="calibre2">Did you ride an elevator lately? Was there a mirror on the wall of the elevator? Why is that?</p>
<p class="calibre2">How did you feel when you last rode an elevator that had no mirror and no glass walls? </p>
<p class="calibre2">The main reason we commonly have mirrors in our elevators is to solve a common problem. Riding in an elevator is boring. We could put in a picture. But a picture would also get boring after a while, if you rode the same elevator at least twice a day. Cheap, but not much of an improvement.</p>
<p class="calibre2">We could put in a TV screen, as some do. But it makes the elevator more expensive. And it also requires a lot of maintenance. We need to put some content on the screen, to make it not too repetitive. So either there's a person whose responsibility is <span class="calibre7">to renew the content</span> once in a while, or a third-party company that does it for us. We'll also have to handle different problems that may occur with screen hardware and the software behind it. Seeing the "Blue Screen of Death" is amusing, of course, but only mildly. </p>
<p class="calibre2">Some architects even go for putting elevator shafts on the building exterior, and making part of the walls transparent. This may provide some exciting views. But this solution also requires maintenance <span class="calibre7">(</span>dirty windows don't make for the best view), <span class="calibre7">and</span> a lot of architectural planning.</p>
<p class="calibre2">So, we put in a mirror. You get to watch an attractive person even if you ride alone. Some studies indicate that we find ourselves more attractive than we are, anyway. Maybe you get a chance to review your appearances one last time before that important meeting. Mirrors visually expand the visual space and make the entire trip less claustrophobic, or less awkward, if it's the start of a day and the elevator is really crowded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Design process</h1>
                
            
            <article>
                
<p class="calibre2">Let's try and understand what we did just now.</p>
<p class="calibre2">We didn't invent mirrors in elevators. We've seen them thousands of times. But we formalized the problem (riding in an elevator is boring) and discussed alternative solutions (TV screens, glass walls) and the benefits of the commonly used solution (solves the problem, easy to implement). That's what design patterns are all about.</p>
<p class="calibre2">The basic steps of the design process are:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Define exactly what the current problem is.</li>
<li value="2" class="calibre12">Consider different alternatives, based on the pros and cons.</li>
<li value="3" class="calibre12">Choose the solution that solves the problem, while best fitting your specific constraints.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why use design patterns in Kotlin?</h1>
                
            
            <article>
                
<p class="calibre2">Kotlin comes to solve the real-world problems of today. In the following chapters, we will discuss both <em class="calibre14">Design Patterns</em> first introduced by the Gang of Four back in '94, as well as design patterns that emerged from the functional programming paradigm.</p>
<p class="calibre2">You'll find that some of the design patterns are so common or useful that they're already built into the language as reserved keywords or standard functions. Some of them will need to combine a set of language features. <span class="calibre7">And some are not so useful any more, since the world has moved forward, and they're being replaced by some other patterns.</span></p>
<p class="calibre2">But in any case, familiarity with design patterns and best practices expands your "developer toolbox" and creates shared vocabulary between you and your colleagues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">So, in this chapter, we covered the main goals of the Kotlin programming language.</p>
<p class="calibre2">We went through the variables that are defined, such as <kbd class="calibre13">val</kbd>, <kbd class="calibre13">var</kbd>, null safety, and type inference. We observed how program flow is controlled by commands such as <kbd class="calibre13">if</kbd>, <kbd class="calibre13">when</kbd>, <kbd class="calibre13">for</kbd>, and <kbd class="calibre13">while</kbd>, and we also took a look at the different keywords used to define classes and interfaces: <kbd class="calibre13">class</kbd>, <kbd class="calibre13">interface</kbd>, <kbd class="calibre13">data</kbd>, and <kbd class="calibre13">abstract</kbd> class. We learned how to construct new classes and how we inherit from interfaces and implement classes. And finally, we learned what design patterns are good for, and why we need them in Kotlin. </p>
<p class="calibre2">In the next chapter, we'll start discussing the first of the three design pattern families: creation patterns.</p>


            </article>

            
        </section>
    </body></html>