["```swift\nimport SpriteKit\n```", "```swift\nstruct SmokeView: UIViewRepresentable {\n    func makeUIView(context: \n      UIViewRepresentableContext<SmokeView>) -> SKView {\n        let view = SKView(frame: CGRect(x: 0, y: 0, width: \n          400, height: 400))\n        view.backgroundColor = .clear\n        let scene = SKScene(size: CGSize(width: 400, \n          height: 600))\n        ///set the scenes background color to clear because \n          we will set the color in the ContentView.\n        ///You can also use any other valid color like \n          UIColor.lightGray, UIColor.green, \n          UIColor.init(red: 1, green: 1, blue: 1, alpha: \n          0.5) or any other UIColor initializer.\n        scene.backgroundColor = UIColor.clear\n        guard let smoke = SKEmitterNode(fileNamed: \n          \"Smoke.sks\") else { return SKView() }\n        smoke.position = CGPoint(x: scene.size.width / 2, \n          y: scene.size.height / 2)\n        // set the blend mode - scale - range\n        smoke.particleBlendMode = .screen\n        smoke.particleScale = 0.01\n        smoke.particleScaleRange = 0.05\n        ///add the smoke to the scene\n        scene.addChild(smoke)\n        view.presentScene(scene)\n        return view\n    }\n    func updateUIView(_ uiView: SKView, context: \n      UIViewRepresentableContext<SmokeView>) {\n      /// Update the smoke in this function if you need to\n    }\n}\n```", "```swift\nstruct ContentView: View {\n    var body: some View {\n        ZStack {\n            ///adding the pipe image and setting the size \n              and scale to fit on it\n            Image(\"pipe\")\n                .resizable().frame(width: 350, height: 350)\n                .scaledToFit()\n            ///calling and positioning the SmokeView\n            SmokeView()\n            .offset(x: -140, y: 105)\n        }.background(Image(\"background\"))\n    }\n}\n```", "```swift\nstruct CoffeeSteam: UIViewRepresentable {\n    func makeUIView(context: \n      UIViewRepresentableContext<CoffeeSteam>) -> SKView {\n        let view = SKView(frame: CGRect(x: 0, y: 0, width: \n          400, height: 400))\n        view.backgroundColor = .clear\n        let scene = SKScene(size: CGSize(width: 400, \n          height: 600))\n        ///set the scenes background color to clear - we \n          only want the particles seen\n        scene.backgroundColor = UIColor.clear\n        guard let steam = SKEmitterNode(fileNamed: \n          \"CoffeeSteam.sks\") else { return SKView() }\n        steam.position = CGPoint(x: scene.size.width / 2, \n          y: scene.size.height / 2)\n        /// set the blend mode - scale - range\n        steam.particleBlendMode = .screen\n        steam.particleScale = 0.01\n        steam.particleScaleRange = 0.05\n        ///add the smoke to the scene\n        scene.addChild(steam)\n        view.presentScene(scene)\n        return view\n    }\n    func updateUIView(_ uiView: SKView, context: \n      UIViewRepresentableContext<CoffeeSteam>) {\n      /// Update the steam in this function if you need to\n    }\n}\n```", "```swift\nstruct ContentView: View {\n  var body: some View {\n    ZStack {\n        Image(\"background\")\n            .resizable().frame(width: 600, height: 900)\n            .aspectRatio(contentMode: .fit)\n        ZStack {\n            ///adding the whole cup\n            Image(\"cup\")\n                .resizable().frame(width: 350, height: 300)\n                .aspectRatio(contentMode: .fit)\n            ///calling and positioning the SmokeView\n            CoffeeSteam().offset(x: 15, y: 80)\n            ///adding the altered cup\n            Image(\"cup 2\")\n                .resizable().frame(width: 350, height: 300)\n                .aspectRatio(contentMode: .fit)\n        }.offset(y: 250)\n    }\n  }\n}\n```", "```swift\nstruct FireView: UIViewRepresentable {\n    func makeUIView(context: \n      UIViewRepresentableContext<FireView>) -> SKView {\n        let view = SKView(frame: CGRect(x: 0, y: 0, width: \n          400, height: 400))\n        view.backgroundColor = .clear\n        scene.backgroundColor = UIColor.clear\n        guard let fire = SKEmitterNode(fileNamed: \n          \"Fire.sks\") else { return SKView() }\n        fire.position = CGPoint(x: scene.size.width / 2, y: \n          scene.size.height / 2)\n        ///use the particlePositionRange property to \n          constrain the fire particles so they are not so \n          wide and can fit under the rockets exhaust\n        fire.particlePositionRange = CGVector(dx: 5, dy: 0)\n        ///add the fire to the scene\n        scene.addChild(fire)\n        view.presentScene(scene)\n        return view\n    }\n    func updateUIView(_ uiView: SKView, context: \n      UIViewRepresentableContext<FireView>) {\n        /// Update the fire in this function if you need to\n    }\n}\n```", "```swift\nstruct RocketView: View {\n        @State private var rocketAndFireOffset: CGFloat = 0\n        var body: some View {\n            ZStack {\n                FireView().rotationEffect(Angle(degrees: \n                  180.0)).offset(y: 60)\n                     ///move the fire upwards by changing y \n                       offset\n                    .offset(x: 0, y: -rocketAndFireOffset)\n                    /// position the fire at the bottom \n                      center of the screen\n                    .position(x: \n                      UIScreen.main.bounds.width/2, y: \n                      UIScreen.main.bounds.height)\n                Image(\"rocket\")\n                    .resizable().aspectRatio(contentMode: \n                      .fit).frame(width: 100, height: 200)\n                     ///move the rocket upwards by changing \n                       y offset\n                    .offset(x: 0, y: -rocketAndFireOffset)\n                    ///position the rocket at the bottom \n                      center of the screen\n                    .position(x: \n                      UIScreen.main.bounds.width/2, y: \n                      UIScreen.main.bounds.height)\n                ///rotate the fire and offset it so its \n                  under the bottom of the rocket\n            } .animation(Animation.linear(duration: \n              8).repeatForever(autoreverses: false),value: \n              rocketAndFireOffset) // increase the duration \n              of the animation\n                .onAppear {\n                    rocketAndFireOffset = \n                      UIScreen.main.bounds.height * 1.3 // \n                      move the rocket off the top of the \n                      screen, by increasing the offset\n            }\n        }\n    }\n```", "```swift\nstruct ContentView: View {\n    var body: some View {\n        ZStack {\n            ///add the RocketView to the scene\n            RocketView()\n        }.background(Image(\"background\")\n            .resizable()\n            .scaledToFill().edgesIgnoringSafeArea(.all))\n    }\n}\n```", "```swift\nstruct SnowView: UIViewRepresentable {\n  func makeUIView(context: \n    UIViewRepresentableContext<SnowView>) -> SKView {\n      let view = SKView(frame: CGRect(x: 0, y: 0, width: \n        400, height: 400))\n      view.backgroundColor = .clear\n      let scene = SKScene(size: CGSize(width: 500, \n        height: 800))\n      scene.backgroundColor = UIColor.clear\n      guard let snow = SKEmitterNode(fileNamed: \n        \"Snow.sks\") else { return SKView() }\n      guard let blustery = SKEmitterNode(fileNamed: \n        \"Blustery.sks\") else { return SKView() }\n      //snow sks file\n      snow.position = CGPoint(x: scene.size.width / 2, y: \n        scene.size.height / 2)\n      ///use the particlePositionRange property to spread \n        the snow particles on the screen for the x and y \n        axis\n      snow.particlePositionRange = CGVector(dx: 500, dy: \n        900)\n      //blustery sks file\n      blustery.position = CGPoint(x: scene.size.width / 2, \n        y: scene.size.height / 2)\n      ///use the particlePositionRange property to spread \n        the snow particles on the screen for the x and y \n        axis\n      blustery.particlePositionRange = CGVector(dx: 500, \n        dy: 900)\n      ///add the snow to the scene\n      scene.addChild(snow)\n      scene.addChild(blustery)\n      view.presentScene(scene)\n      return view\n  }\n  func updateUIView(_ uiView: SKView, context: \n    UIViewRepresentableContext<SnowView>) {\n      /// Update the snow in this function if you need to\n  }\n}\n```", "```swift\nstruct ContentView: View {\n    var body: some View {\n        ZStack {\n            Image(\"background\")\n                .resizable().frame(width: 600, height: 900)\n                .aspectRatio(contentMode: .fit)\n            SnowView()\n        }\n    }\n}\n```", "```swift\nstruct Branches: View {\n var body: some View {\n     }\n}\n```", "```swift\n   @State private var anglesX = [Double](repeating: 0, \n     count: 25)\n    @State private var anglesY = [Double](repeating: 0, \n      count: 25)\n    @State private var anglesZ = [Double](repeating: 0, \n      count: 25)\n    @State private var positions = [CGPoint](repeating: \n      .zero, count: 25)\n    @State private var durations = [Double](repeating: 0, \n      count: 25)\n```", "```swift\nZStack {\n    ForEach(0..<8) { index in\n         Image(\"branch\")\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .rotationEffect(Angle(degrees: anglesX[index]))\n            .rotationEffect(Angle(degrees: anglesY[index]), \n              anchor: .center)\n            .rotationEffect(Angle(degrees: anglesZ[index]), \n              anchor: .center)\n            .position(positions[index])\n            .frame(width: 200, height: 700)\n            .animation(\n                Animation.easeInOut(duration: \n                  durations[index])\n                    .repeatForever(autoreverses: true), \n                      value: anglesX)\n            .onAppear {\n                anglesX[index] = Double.random(in: 2...4)\n                anglesY[index] = Double.random(in: 2...3)\n                anglesZ[index] = Double.random(in: 1...3)\n                positions[index] = CGPoint(x: \n                  CGFloat.random(in: 0...10), y: \n                  CGFloat.random(in: 0...5))\n                durations[index] = Double.random(in: 3...5)\n            }\n    }\n} .offset(x: 50, y: 200)\n```", "```swift\nZStack {\n    ForEach(0..<10) { index in\n        Image(\"branch\")\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .rotationEffect(Angle(degrees: anglesX[index]))\n            .rotationEffect(Angle(degrees: anglesY[index]), \n              anchor: .center)\n            .rotationEffect(Angle(degrees: anglesZ[index]), \n              anchor: .center)\n    .position(positions[index])\n            .frame(width: 200, height: 700)\n            .offset(x: 50, y: 200)\n            .animation(\n                Animation.easeInOut(duration: \n                  durations[index])\n                    .repeatForever(autoreverses: \n                      true),value: anglesY)\n            .onAppear {\n                anglesX[index] = Double.random(in: 3...4)\n                anglesY[index] = Double.random(in: 2...5)\n                anglesZ[index] = Double.random(in: 1...4)\n                positions[index] = CGPoint(x: \n                  CGFloat.random(in: 0...10), y: \n                  CGFloat.random(in: 0...14))\n                durations[index] = Double.random(in: 2...6)\n            }\n    }\n}.offset(x: -80, y: -156)\n  ZStack {\n    ForEach(0..<15) { index in\n      Image(\"branch\")\n          .resizable()\n          .aspectRatio(contentMode: .fit)\n          .rotationEffect(Angle(degrees: anglesX[index]))\n          .rotationEffect(Angle(degrees: anglesY[index]), \n            anchor: .center)\n          .rotationEffect(Angle(degrees: anglesZ[index]), \n            anchor: .center)\n          .position(positions[index])\n          .frame(width: 200, height: 700)\n          .offset(x: 50, y: 200)\n          .animation(\n              Animation.easeInOut(duration: \n                durations[index])\n                  .repeatForever(autoreverses: true)\n              ,value: anglesZ)\n          .onAppear {\n              anglesX[index] = Double.random(in: 1...3)\n              anglesY[index] = Double.random(in: 2...4)\n              anglesZ[index] = Double.random(in: 3...6)\n              positions[index] = CGPoint(x: \n                CGFloat.random(in: 0...10), y: \n                CGFloat.random(in: 0...8))\n              durations[index] = Double.random(in: 4...6)\n          }\n  }\n}.offset(x: -120, y: 0)\n\n    ZStack {\n      ForEach(0..<7) { index in\n        Image(\"branch\")\n          .resizable()\n          .aspectRatio(contentMode: .fit)\n          .rotationEffect(Angle(degrees: anglesX[index]))\n          .rotationEffect(Angle(degrees: anglesY[index]), \n            anchor: .center)\n          .rotationEffect(Angle(degrees: anglesZ[index]), \n            anchor: .center)\n          .position(positions[index])\n          .frame(width: 200, height: 700)\n          .offset(x: 50, y: 200)\n          .animation(\n              Animation.easeInOut(duration: \n                durations[index])\n                  .repeatForever(autoreverses: true)\n              ,value: anglesX)\n          .onAppear {\n              anglesX[index] = Double.random(in: 1...3)\n              anglesY[index] = Double.random(in: 2...3)\n              anglesZ[index] = Double.random(in: 3...5)\n              positions[index] = CGPoint(x: \n                CGFloat.random(in: 0...10), y: \n                CGFloat.random(in: 0...12))\n              durations[index] = Double.random(in: 4...6)\n          }\n  }\n  }.offset(x: -100, y: 160)\n\n  ZStack {\n    ForEach(0..<7) { index in\n      Image(\"branch\")\n          .resizable()\n          .aspectRatio(contentMode: .fit)\n          .rotationEffect(Angle(degrees: anglesX[index]))\n          .rotationEffect(Angle(degrees: anglesY[index]), \n            anchor: .center)\n          .rotationEffect(Angle(degrees: anglesZ[index]), \n            anchor: .center)\n          .position(positions[index])\n          .frame(width: 180, height: 700)\n          .offset(x: 50, y: 200)\n          .animation(\n              Animation.easeInOut(duration: \n                durations[index])\n                  .repeatForever(autoreverses: true)\n              ,value: anglesY)\n          .onAppear {\n              anglesX[index] = Double.random(in: 0...2)\n              anglesY[index] = Double.random(in: 0...3)\n              anglesZ[index] = Double.random(in: 0...1)\n              positions[index] = CGPoint(x: \n                CGFloat.random(in: 0...10), y: \n                CGFloat.random(in: 0...12))\n              durations[index] = Double.random(in: 3...6)\n          }\n  }\n  }.offset(x: 10, y: 100)\n```", "```swift\nstruct ContentView: View {\n    var body: some View {\n        ZStack {\n            Image(\"background\")\n                .resizable().frame(width: 600, height: 900)\n                .aspectRatio(contentMode: .fit)\n            Branches()\n            SnowView()\n        }\n    }\n}\n```", "```swift\nstruct DropView: View {\n  @State private var dropScale: CGFloat = 0.1\n  @State private var xOffsets = (0..<300).map { _ in \n    CGFloat.random(in: -150...UIScreen.main.bounds.width)}\n  @State private var yOffsets = (0..<240).map { _ in \n    CGFloat.random(in: UIScreen.main.bounds.height/5...\n    UIScreen.main.bounds.height)}\n  @State private var durations = (0..<150).map { _ in \n    Double.random(in: 0.3...1.0)}\n  var body: some View {\n      //Color.clear.edgesIgnoringSafeArea(.all)\n          ForEach(0..<150) { index in\n              Circle()\n                  .fill(Color.white)\n                      .opacity(0.6)\n                    .blur(radius: 3)\n                  .frame(width: 15, height: 15)\n                  .scaleEffect(dropScale)\n                  .rotation3DEffect(Angle(degrees: 80.0), \n                    axis: (x: 1, y: 0, z: 0))\n                  .offset(x: xOffsets[index] - 140, y: \n                    yOffsets[index])\n                  .animation(Animation.easeInOut(duration: \n                    durations[index]).repeatForever\n                    (autoreverses: true), value: dropScale)\n                  .onAppear {\n                      dropScale = 0.8\n                  }\n          }\n  }\n}\n```", "```swift\nstruct PuddleView: View {\n  @State private var scaleX: CGFloat = 0.5\n  @State private var scaleY: CGFloat = 0.5\n  var body: some View {\n    ZStack {\n      Capsule()\n          .fill(LinearGradient(gradient: Gradient(colors: \n            [.white,  .black,.gray, .white,.black]), \n            startPoint: .topLeading, endPoint:  \n            .bottomTrailing))\n          .opacity(0.5)\n          .blur(radius: 5)\n          .frame(width: 600, height: 500)\n          .scaleEffect(x: scaleX, y: scaleY, anchor: \n        .center)\n      .animation(Animation.easeInOut(duration: \n        8.0).repeatForever(autoreverses: true),value: \n        scaleX)\n      //creates the ripple\n          .overlay(\n              Capsule()\n                  .stroke(Color.gray, lineWidth: 5)\n                  .opacity(0.5 )\n                  .frame(width: 350, height: 200)\n                  .offset(x: 0, y: -15)\n                  .scaleEffect(x: scaleX + 0.03, y: scaleY \n                    + 0.03, anchor: .center)\n                  .animation(Animation.easeInOut(duration: \n                    8.0).repeatForever(autoreverses: true), \n                    value: scaleY)\n                  .onAppear {\n                      scaleX = 0.54\n                      scaleY = 0.6\n                  }).rotation3DEffect(Angle(degrees: 81.0), \n                    axis: (x: 1, y: 0, z: 0))\n\n  } .offset(x: -50, y: 300)\n      .onAppear {\n          scaleX = 0.55\n          scaleY = 0.6\n      }\n  }\n}\n```", "```swift\nimport SpriteKit\nimport SwiftUI\nstruct ContentView: View {\n    var body: some View {\n        ZStack {\n            Image(\"street\")\n                   .resizable()\n                   .scaledToFill()\n            PuddleView()//.blendMode(.hardLight)\n            RainView()\n            DropView()\n            RainView()\n        }.edgesIgnoringSafeArea(.all)\n    }\n}\n```", "```swift\nimport SwiftUI\nimport SpriteKit\nstruct MagicView: UIViewRepresentable {\n    func makeUIView(context: \n      UIViewRepresentableContext<MagicView>) -> SKView {\n        let view = SKView(frame: CGRect(x: 0, y: 0, width: \n          400, height: 400))\n        view.backgroundColor = .clear\n        let scene = MagicScene(size: CGSize(width: 900, \n          height: 600))\n        scene.backgroundColor = UIColor.clear\n        scene.scaleMode = .aspectFill\n        view.presentScene(scene)\n        return view\n    }\n    func updateUIView(_ uiView: SKView, context: \n      UIViewRepresentableContext<MagicView>) {\n    }\n}\n```", "```swift\nimport Foundation\nimport SwiftUI\nimport SpriteKit\nclass MagicScene: SKScene {\n  var magic: SKEmitterNode!\n  var wand: SKSpriteNode!\n  override func touchesMoved(_ touches: Set<UITouch>, \n    with event: UIEvent?) {\n      let touch = touches.first!\n      let touchLocation = touch.location(in: self)\n      wand.position = CGPoint(x: touchLocation.x - 30, y: \n        touchLocation.y + wand.frame.size.height / 2 - 20)\n      ///make the skeleton appear\n      if touchLocation.x < frame.size.width * 0.55 && \n        touchLocation.y < frame.size.height * 0.12 {\n          let skeleton = SKSpriteNode(imageNamed: \n            \"skeleton\")\n          skeleton.position = CGPoint(x: frame.size.width / \n            2 - 80, y: 175)\n          skeleton.size = CGSize(width: skeleton.size.width \n            / 2, height: skeleton.size.height / 2)\n          addChild(skeleton)\n          let moveAction = SKAction.move(to: CGPoint(x: \n            frame.size.width / 2 - 50, y: frame.size.height \n            / 2), duration: 2.0)\n          skeleton.run(moveAction)\n      }\n      wand.zPosition = 2\n      let trail = SKEmitterNode(fileNamed: \"Magic.sks\")!\n      trail.particlePositionRange = CGVector(dx: 5, dy: 5)\n      trail.particleSpeed = 50\n      trail.position = CGPoint(x: wand.position.x - 40, y: \n        wand.position.y + wand.frame.size.height / 2 + \n        trail.particlePositionRange.dy)\n      addChild(trail)\n      let fadeAway = SKAction.fadeOut(withDuration: 1.2)\n      trail.run(fadeAway) {\n          trail.removeFromParent()\n      }\n  }\n  override func didMove(to view: SKView) {\n      let stone = SKSpriteNode(imageNamed: \"stone\")\n      stone.position = CGPoint(x: frame.size.width / 2.3, \n        y: frame.size.height / 2 - 150)\n      stone.size = CGSize(width: 120, height: 175)\n      stone.zRotation = CGFloat(Double.pi / 20)\n      stone.zPosition = 2\n         addChild(stone)\n      guard let magic = SKEmitterNode(fileNamed: \n        \"Magic.sks\") else { return }\n      magic.particlePositionRange = CGVector(dx: 5, dy: 5)\n      magic.particleSpeed = 50\n      addChild(magic)\n      self.magic = magic\n      wand = SKSpriteNode(imageNamed: \"wand\")\n      wand.position = CGPoint(x: frame.size.width / 2, y: \n        frame.size.height / 3)\n      wand.size = CGSize(width: 80, height: 180)\n      addChild(wand)\n  }\n}\n```", "```swift\nstruct ContentView: View {\n    var body: some View {\n    ZStack {\n        Image(\"graveyard\")\n            .resizable()\n            .scaledToFill().frame(width: 500, height: 900)\n        MagicView()\n      }\n  }\n}\n```"]