<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Advanced Build Customization</h1></div></div></div><p>Now that you know how Gradle works, how to create your own tasks and plugins, how to run tests, and how to set up continuous integration, you can almost call yourself a Gradle expert. This chapter contains a few tips and tricks that we have not mentioned in the previous chapters that make it easier to build, develop, and deploy Android projects using Gradle.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reducing the APK file size</li><li class="listitem" style="list-style-type: disc">Speeding up builds</li><li class="listitem" style="list-style-type: disc">Ignoring Lint</li><li class="listitem" style="list-style-type: disc">Using Ant from Gradle</li><li class="listitem" style="list-style-type: disc">Advanced app deployment</li></ul></div><p>We will start out by looking at how we can reduce the size of the build output and why that is useful.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Reducing the APK file size</h1></div></div></div><p>The size of <a id="id336" class="indexterm"/>APK files has been increasing dramatically in the last few years. There are several causes for this—more libraries have become available to Android developers, more densities have been added, and apps are getting more functionality in general.</p><p>It is a good idea to keep APKs as small as possible. Not only because there is a 50 MB limit on APK files in Google Play, but a smaller APK also means that users can download and install an app faster, and it keeps the memory footprint down.</p><p>In this section, we will look at a few properties in the Gradle build configuration file that we can manipulate to shrink APK files.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec82"/>ProGuard</h2></div></div></div><p>
<strong>ProGuard</strong><a id="id337" class="indexterm"/> is a Java tool that can not only shrink, but also optimize, obfuscate, and preverify your code at compile time. It goes through all the code paths in your app to find code that is not used and deletes it. ProGuard also renames your classes and fields. This process keeps the footprint of the app down, and makes the code more difficult to reverse engineer.</p><p>The Android plugin for Gradle has a Boolean property called <code class="literal">minifyEnabled</code> on the build type that you need to set to true to enable ProGuard:</p><div><pre class="programlisting">android {
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}</pre></div><p>When you set <code class="literal">minifyEnabled</code> to <code class="literal">true</code>, the <code class="literal">proguardRelease</code> task is executed and invokes ProGuard during the build process.</p><p>It is a good idea to retest your entire application after enabling ProGuard, because it might remove some code that you still need. This is an issue that has made lots of developers weary of ProGuard. To solve this problem, you can define ProGuard rules to exclude certain classes from getting removed or obfuscated. The <code class="literal">proguardFiles</code> property is used to define the files that contain ProGuard rules. For example, to keep a class, you can add a simple rule like this:</p><div><pre class="programlisting">-keep public class &lt;MyClass&gt;</pre></div><p>The <code class="literal">getDefaultProguardFile('proguard-android.txt')</code> method fetches the default ProGuard settings from a file called <code class="literal">proguard-android.txt</code>, which comes with the Android SDK in the <code class="literal">tools/proguard</code> folder. The <code class="literal">proguard-rules.pro</code> file gets added to new Android modules by default by Android Studio, so you can simply add rules specific to the module in that file.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>The ProGuard<a id="id338" class="indexterm"/> rules are different for each app or library you build, so we will not go into too much detail in this book. If you want to know more about ProGuard and ProGuard rules, check the official Android ProGuard documentation at <a class="ulink" href="http://developer.android.com/tools/help/proguard.html">http://developer.android.com/tools/help/proguard.html</a>.</p></div></div><p>Besides shrinking the Java code, it is also a good idea to shrink the used resources.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec83"/>Shrinking resources</h2></div></div></div><p>Gradle and the <a id="id339" class="indexterm"/>Android plugin for Gradle can get rid of all unused resources at build time, when the app is being packaged. This can be useful if you have old resources that you forgot to remove. Another use case is when you import a library that has lots of resources, but you only use a small subset of them. You can fix this by enabling resource shrinking. There are two ways to go about shrinking resources, automatic or manual.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec13"/>Automatic shrinking</h3></div></div></div><p>The easiest way is to <a id="id340" class="indexterm"/>configure the <code class="literal">shrinkResources</code> property on your build. If you set this property to <code class="literal">true</code>, the Android build tools will automatically try to determine which resources are not used, and not include them in the APK.</p><p>There is one requirement for using this feature, though you have to enable ProGuard as well. This is due to the way the resource shrinking works, as the Android build tools cannot figure out which resources are unused until the code that references these resources has been removed.</p><p>The following snippet shows how to configure automatic resource shrinking on a certain build type:</p><div><pre class="programlisting">android {
    buildTypes {
    release {
            minifyEnabled = true
            shrinkResources = true
        }
    }
}</pre></div><p>If you want to see exactly how much smaller your APK becomes after enabling automatic resource shrinking, you can run the <code class="literal">shrinkReleaseResources</code> task. This task prints out how much it has reduced the package in size:</p><div><pre class="programlisting">:app:shrinkReleaseResources
Removed unused resources: Binary resource data reduced from 433KB to 354KB: Removed 18%</pre></div><p>You can get a detailed overview of the resources that are stripped from the APK, by adding the <code class="literal">--info</code> flag to your build command:</p><div><pre class="programlisting">
<strong>$ gradlew clean assembleRelease --info</strong>
</pre></div><p>When you use this flag, Gradle prints out a lot of extra information about the build process, including every resource it does not include in the final build output.</p><p>One problem with automatic resource shrinking is that it might remove too many resources. Especially resources that are used dynamically might be accidentally stripped out. To prevent this, you can define exceptions in a file called <code class="literal">keep.xml</code> that you place in <code class="literal">res/raw/</code>. A simple <code class="literal">keep.xml</code> file will look like this:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources 
    tools:keep="@layout/keep_me,@layout/also_used_*"/&gt;</pre></div><p>The <code class="literal">keep.xml</code> file<a id="id341" class="indexterm"/> itself will also be stripped out of the final result.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec14"/>Manual shrinking</h3></div></div></div><p>A less drastic way<a id="id342" class="indexterm"/> to strip out resources is to get rid of certain language files or images for certain densities. Some libraries, such as Google Play Services, include a lot of languages. If your app only supports one or two languages, it does not make sense to include all the language files from these libraries in the final APK. You can use the <code class="literal">resConfigs</code> property to configure the resources you want to keep, and then the rest will be thrown out.</p><p>If you want to keep only English, Danish, and Dutch strings, you can use <code class="literal">resConfigs</code> like this:</p><div><pre class="programlisting">android {
    defaultConfig {
        resConfigs "en", "da", "nl"
    }
}</pre></div><p>You can do this for density buckets as well, like this:</p><div><pre class="programlisting">android {
    defaultConfig {
        resConfigs "hdpi", "xhdpi", "xxhdpi", "xxxhdpi"
    }
}</pre></div><p>It is even possible to combine languages and densities. In fact, every type of resource can be restricted using this property.</p><p>If you are having a hard time setting up ProGuard, or you just want to get rid of resources for languages or densities your app does not support, then using <code class="literal">resConfigs</code> is a good way to get started with resource shrinking.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Speeding up builds</h1></div></div></div><p>A lot of Android <a id="id343" class="indexterm"/>developers that start using Gradle complain about the prolonged compilation time. Builds can take longer than they do with Ant, because Gradle has three phases in the build lifecycle that it goes through every time you execute a task. This makes the whole process very configurable, but also quite slow. Luckily, there are several ways to speed up Gradle builds.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec84"/>Gradle properties</h2></div></div></div><p>One way to tweak the<a id="id344" class="indexterm"/> speed of a Gradle build is to change <a id="id345" class="indexterm"/>some of the default settings. We already mentioned in parallel build execution in <a class="link" href="ch05.html" title="Chapter 5. Managing Multimodule Builds">Chapter 5</a>, <em>Managing Multimodule Builds</em>, but there are a few more settings that you can adjust.</p><p>Just to recap, you can enable parallel builds by setting a property in a <code class="literal">gradle.properties</code> file that is placed in the root of a project. All you need to do is add the following line:</p><div><pre class="programlisting">org.gradle.parallel=true</pre></div><p>Another easy win is to enable the Gradle daemon, which starts a background process when you run a build the first time. Any subsequent builds will then reuse that background process, thus cutting out the startup cost. The process is kept alive as long as you use Gradle, and is terminated after three hours of idle time. Using the daemon is particularly useful when you use Gradle several times in a short time span. You can enable the daemon in the <code class="literal">gradle.properties</code> file like this:</p><div><pre class="programlisting">org.gradle.daemon=true</pre></div><p>In Android Studio, the Gradle daemon is enabled by default. This means that after the first build from inside the IDE, the next builds are a bit faster. If you build from the command-line interface; however, the Gradle daemon is disabled, unless you enable it in the properties.</p><p>To speed up the compilation itself, you can tweak parameters on the Java Virtual Machine (JVM). There is a Gradle property called <code class="literal">jvmargs</code> that enables you to set different values for the memory allocation pool for the JVM. The two parameters that have a direct influence on your build speed are <code class="literal">Xms</code> and <code class="literal">Xmx</code>. The <code class="literal">Xms</code> parameter is used to set the initial amount of memory to be used, while the <code class="literal">Xmx</code> parameter is used to set a maximum. You can manually set these values in the <code class="literal">gradle.properties</code> file like this:</p><div><pre class="programlisting">org.gradle.jvmargs=-Xms256m -Xmx1024m</pre></div><p>You need to set the desired amount and a unit, which can be k for kilobytes, m for megabytes, and g for gigabytes. By default, the maximum memory allocation (<code class="literal">Xmx</code>) is set to 256 MB, and the starting memory allocation (<code class="literal">Xms</code>) is not set at all. The optimal settings depend on the capabilities of your computer.</p><p>The last property you can configure to influence build speed is <code class="literal">org.gradle.configureondemand</code>. This property is particularly useful if you have complex projects with several modules, as it tries to limit the time spent in the configuration phase, by skipping modules that are not required for the task that is being executed. If you set this property to <code class="literal">true</code>, Gradle will try to figure out which modules have configuration changes and which ones do not, before it runs the configuration phase. This is a feature that will not be very useful if you only have an Android app and a library in your project. If<a id="id346" class="indexterm"/> you have a lot of modules that are <a id="id347" class="indexterm"/>loosely coupled, though, this feature can save you a lot of build time.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>
<strong>System-wide Gradle properties</strong>
</p><p>If you want to apply<a id="id348" class="indexterm"/> these properties system-wide to all your Gradle-based projects, you can create a <code class="literal">gradle.properties</code> file in the <code class="literal">.gradle</code> folder in your home directory. On Microsoft Windows, the full path to this directory is <code class="literal">%UserProfile%\.gradle</code>, on Linux and Mac OS X it is <code class="literal">~/.gradle</code>. It is a good practice to set these properties in your home directory, rather than on the project level. The reason for this is that you usually want to keep memory consumption down on build servers, and the build time is of less importance.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec85"/>Android Studio</h2></div></div></div><p>The Gradle properties you can <a id="id349" class="indexterm"/>change to speed up the compilation process are also configurable in the Android Studio settings. To find the compiler settings, open the <strong>Settings</strong> dialog, and then navigate to <strong>Build, Execution, Deployment</strong> | <strong>Compiler</strong>. On that screen, you can find settings for parallel builds, JVM options, configure on demand, and so on. These settings only show up for Gradle-based Android modules. Have a look at the following screenshot:</p><div><img src="img/B01061_09_01.jpg" alt="Android Studio"/></div><p>Configuring <a id="id350" class="indexterm"/>these settings from Android Studio is easier than configuring them manually in the build configuration file, and the settings dialog makes it easy to find properties that influence the build process.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec86"/>Profiling</h2></div></div></div><p>If you want to find <a id="id351" class="indexterm"/>out which parts of the build are slowing the process down, you can profile the entire build process. You can do this by adding the <code class="literal">--profile</code> flag whenever you execute a Gradle task. When you provide this flag, Gradle creates a profiling report, which can tell you which parts of the build process are the most time consuming. Once you know where the bottlenecks are, you can make the necessary changes. The report is saved as an HTML file in your module in <code class="literal">build/reports/profile</code>.</p><p>This is the report generated after executing the build task on a multimodule project:</p><div><img src="img/B01061_09_02.jpg" alt="Profiling"/></div><p>The profiling report<a id="id352" class="indexterm"/> shows an overview of the time spent in each phase while executing the task. Below that summary is an overview of how much time Gradle spent on the configuration phase for each module. There are two more sections in the report that are not shown in the screenshot. The <strong>Dependency Resolution</strong> section shows how long it took to resolve dependencies, per module. Lastly, the <strong>Task Execution</strong> section contains an extremely detailed task execution overview. This overview has the timing for every single task, ordered by execution time from high to low.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec87"/>Jack and Jill</h2></div></div></div><p>If you are willing to use experimental tools, you can enable Jack and Jill to speed up builds. <strong>Jack</strong> (<strong>Java Android Compiler Kit</strong>)<a id="id353" class="indexterm"/> is a new Android build toolchain that compiles Java source code directly to the Android Dalvik executable (dex) format. It has its own <code class="literal">.jack</code> library format and takes care of packaging and shrinking as well. <strong>Jill</strong> (<strong>Jack Intermediate Library Linker</strong>) <a id="id354" class="indexterm"/>is a tool that can convert <code class="literal">.aar</code> and <code class="literal">.jar</code> files to <code class="literal">.jack</code> libraries. These tools are still quite experimental, but they were made to improve build times and to simplify the Android build process. It is not recommended to start using Jack and Jill for production versions of your projects, but they are made available so that you can try them out.</p><p>To be able to use Jack and Jill, you need to use build tools version 21.1.1 or higher, and the Android plugin for Gradle version 1.0.0 or higher. Enabling Jack and Jill is as easy as setting one property in the <code class="literal">defaultConfig</code> block:</p><div><pre class="programlisting">android {
    buildToolsRevision '22.0.1'
    defaultConfig {
      useJack = true
    }
}</pre></div><p>You can also enable Jack and Jill on a certain build type or product flavor. This way, you can continue using the regular build toolchain, and have an experimental build on the side:</p><div><pre class="programlisting">android {
    productFlavors {
        regular {
            useJack = false
        }

        experimental {
            useJack = true
        }
    }
}</pre></div><p>As soon as you set <code class="literal">useJack</code> to <code class="literal">true</code>, minification and obfuscation will not go through ProGuard anymore, but you can still use the ProGuard rules syntax to specify certain rules and exceptions. Use the same <code class="literal">proguardFiles</code> method that we mentioned before, when talking about ProGuard.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Ignoring Lint</h1></div></div></div><p>When you execute a release build with Gradle, a Lint check will be performed on your code. Lint is<a id="id355" class="indexterm"/> a static code analysis tool that flags potential bugs in your layouts and Java code. In some cases, it might even block the build process. If you have not used Lint on your project before, and you want to migrate to Gradle, Lint might come up with a lot of errors. To at least make the build work, you can configure Gradle to ignore Lint errors and prevent them from aborting the build, by disabling <code class="literal">abortOnError</code>. This should only be a temporary solution, because ignoring Lint errors can result in issues like missing translations, which can cause the app to crash. To prevent Lint from blocking the build process, disable <code class="literal">abortOnError</code> like this:</p><div><pre class="programlisting">android {
    lintOptions {
        abortOnError false
    }
}</pre></div><p>Temporarily <a id="id356" class="indexterm"/>disabling the Lint abort can make it easier to migrate an existing Ant build process to Gradle. Another way to make the transition smoother is to execute Ant tasks directly from Gradle.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Using Ant from Gradle</h1></div></div></div><p>If you have<a id="id357" class="indexterm"/> invested a lot of time in setting up a build with Ant, the <a id="id358" class="indexterm"/>switch to Gradle might sound scary. In that case, Gradle cannot only execute Ant tasks, it can also expand them. This means you can migrate from Ant to Gradle in smaller steps, instead of spending several days on converting your entire build configuration.</p><p>Gradle uses Groovy's <strong>AntBuilder</strong><a id="id359" class="indexterm"/> for the Ant integration. The AntBuilder enables you to execute any standard Ant task, your own custom Ant tasks, and entire Ant builds. It also makes it possible to define Ant properties in your Gradle build configuration.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec88"/>Running Ant tasks from Gradle</h2></div></div></div><p>Running <a id="id360" class="indexterm"/>a standard Ant task from Gradle is straightforward. You <a id="id361" class="indexterm"/>just need to prepend the task name with <code class="literal">ant.</code> and everything works out of the box. For example, to create an archive, you can use this task:</p><div><pre class="programlisting">task archive &lt;&lt; {
    ant.echo 'Ant is archiving...'
    ant.zip(destfile: 'archive.zip') {
        fileset(dir: 'zipme')
    }
}</pre></div><p>The task is defined in Gradle, but makes use of two Ant tasks, <code class="literal">echo</code> and <code class="literal">zip</code>.</p><p>Of course you should always consider the Gradle alternatives for the standard Ant tasks. To create an archive like in the previous example, you can define a Gradle task that can handle this for you:</p><div><pre class="programlisting">task gradleArchive(type:Zip) &lt;&lt; {
    from 'zipme/'
    archiveName 'grarchive.zip'
}</pre></div><p>The task for the Gradle-based archive is more concise and easy to understand. Because it does not need to go through the AntBuilder, it is also slightly faster than using the Ant tasks.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec89"/>Importing an entire Ant script</h2></div></div></div><p>If you have created an <a id="id362" class="indexterm"/>Ant script to build your app, you can import the whole build configuration, using <code class="literal">ant.importBuild</code>. All Ant targets are then automatically converted to Gradle tasks that you can access by their original name.</p><p>For example, take the following Ant build file:</p><div><pre class="programlisting">&lt;project&gt;
    &lt;target name="hello"&gt;
        &lt;echo&gt;Hello, Ant&lt;/echo&gt;
    &lt;/target&gt;
&lt;/project&gt;</pre></div><p>You can import this build file into your Gradle build like this:</p><div><pre class="programlisting">ant.importBuild 'build.xml'</pre></div><p>This will expose the hello task to your Gradle build, so you can execute it like a regular Gradle task, and it will print out <code class="literal">Hello, Ant</code>:</p><div><pre class="programlisting">
<strong>$ gradlew hello</strong>
<strong>:hello</strong>
<strong>[ant:echo] Hello, Ant</strong>
</pre></div><p>Because the Ant task is converted to a Gradle task, you can also extend it using the <code class="literal">doFirst</code> and <code class="literal">doLast</code> blocks, or the <code class="literal">&lt;&lt;</code> shortcut. For example, you can print another line to the console:</p><div><pre class="programlisting">hello &lt;&lt; {
    println 'Hello, Ant. It\'s me, Gradle'
}</pre></div><p>If you execute the <code class="literal">hello</code> task now, it looks like this:</p><div><pre class="programlisting">
<strong>$ gradlew hello</strong>
<strong>:hello</strong>
<strong>[ant:echo] Hello, Ant</strong>
<strong>Hello, Ant. It's me, Gradle</strong>
</pre></div><p>You can also depend on tasks imported from Ant, just like you usually would. For example, if you want to create a new task that depends on the hello task, you can simply do this:</p><div><pre class="programlisting">task hi(dependsOn: hello) &lt;&lt; {
    println 'Hi!'
}</pre></div><p>Using <code class="literal">dependsOn</code> makes sure the <code class="literal">hello</code> task gets triggered when executing the <code class="literal">hi</code> task:</p><div><pre class="programlisting">
<strong>$ gradlew intro</strong>
<strong>:hello</strong>
<strong>[ant:echo] Hello, Ant</strong>
<strong>Hello, Ant. It's me, Gradle</strong>
<strong>:hi</strong>
<strong>Hi!</strong>
</pre></div><p>If you need to, you can even make an Ant task depend on a Gradle task. To accomplish this, you need to add the <code class="literal">depends</code> attribute to the task in the <code class="literal">build.xml</code> file, like this:</p><div><pre class="programlisting">&lt;target name="hi" depends="intro"&gt;
    &lt;echo&gt;Hi&lt;/echo&gt;
&lt;/target&gt;</pre></div><p>If you have a big Ant build file, and you want to make sure none of the task names overlap, you can rename all the Ant tasks on import, using this code snippet:</p><div><pre class="programlisting">ant.importBuild('build.xml') { antTargetName -&gt;
    'ant-' + antTargetName
}</pre></div><p>If you decide to<a id="id363" class="indexterm"/> rename all the Ant tasks, keep in mind that if you have an Ant task that depends on a Gradle task, then that Gradle task needs to be prefixed as well. Otherwise, Gradle will not be able to find it and throw an <code class="literal">UnknownTaskException</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec90"/>Properties</h2></div></div></div><p>Gradle and Ant cannot only share tasks, but you can also define properties<a id="id364" class="indexterm"/> in Gradle<a id="id365" class="indexterm"/> that can be used in your Ant build files. Consider this Ant target, which prints out a property called <code class="literal">version</code>:</p><div><pre class="programlisting">&lt;target name="appVersion"&gt;
    &lt;echo&gt;${version}&lt;/echo&gt;
&lt;/target&gt;</pre></div><p>You can define the version property in the Gradle build configuration by prepending the property name with <code class="literal">ant.</code>, just like with tasks. This is the shortest way to define an Ant property:</p><div><pre class="programlisting">ant.version = '1.0'</pre></div><p>Groovy hides a lot of the implementation here. If you write the property definition in full, it looks like this:</p><div><pre class="programlisting">ant.properties['version'] = '1.0'</pre></div><p>Executing the <code class="literal">version</code> task will do exactly what you would expect, namely printing out <code class="literal">1.0</code> to the console:</p><div><pre class="programlisting">
<strong>$ gradlew appVersion</strong>
<strong>:appVersion</strong>
<strong>[ant:echo] 1.0</strong>
</pre></div><p>Having deep Ant<a id="id366" class="indexterm"/> integration in Gradle makes it a lot easier to transition<a id="id367" class="indexterm"/> from Ant-based builds to Gradle, and you can do it at a pace that you are comfortable with.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Advanced app deployment</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Creating Build Variants">Chapter 4</a>, <em>Creating Build Variants</em>, we looked at <a id="id368" class="indexterm"/>several ways to create multiple versions of the same app, using build types and product flavors. However, in some cases, it might be easier to use a more specific technique, such as APK splits.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec91"/>Split APK</h2></div></div></div><p>Build variants <a id="id369" class="indexterm"/>can be seen as separate entities, that can each have their own code, resources, and <a id="id370" class="indexterm"/>manifest file. APK splits, on the other hand, only impact the packaging of an app. The compilation, shrinking, obfuscation, and so on are still shared. This mechanism allows you to split APKs based on either density or <a id="id371" class="indexterm"/>
<strong>application binary interface</strong> (<strong>ABI</strong>).</p><p>You can configure splits by defining a <code class="literal">splits</code> block inside the <code class="literal">android</code> configuration block. To configure density splits, create a <code class="literal">density</code> block inside the <code class="literal">splits</code> block. If you want to set up ABI splits, use an <code class="literal">abi</code> block.</p><p>If you enable density splits, Gradle creates a separate APK for each density. You can manually exclude certain densities if you do not need them, to speed up the build process. This example shows how to enable density splits and exclude devices with low density:</p><div><pre class="programlisting">android {
    splits {
        density {
            enable true
            exclude 'ldpi', 'mdpi'
            compatibleScreens 'normal', 'large', 'xlarge'
        }
    }
}</pre></div><p>If you only support a few densities, you can use <code class="literal">include</code> to create a whitelist of densities. To use include, you first need to use the <code class="literal">reset()</code> property, which resets the list of included densities to an empty string.</p><p>The <code class="literal">compatibleScreens</code> property in the preceding snippet is optional, and injects a matching node in the manifest file. The configuration in the example is for an app that supports normal to extra large screens, excluding devices with small screens.</p><p>Splitting APKs based on the ABI works in the same way, and all of the properties are the same as the properties for density splits, except for <code class="literal">compatibleScreens</code>. ABI splits have nothing to do with screen size, so there is no property called <code class="literal">compatibleScreens</code>.</p><p>The result of<a id="id372" class="indexterm"/> executing a build after configuring the density splits is that Gradle now<a id="id373" class="indexterm"/> creates one universal APK and several density-specific APKs. This means you will end up with a collection of APKs like this:</p><div><pre class="programlisting">app-hdpi-release.apk
app-universal-release.apk
app-xhdpi-release.apk
app-xxhdpi-release.apk
app-xxxhdpi-release.apk</pre></div><p>There is one caveat to using APK splits, though. If you want to push multiple APKs to Google Play, you will need to make sure every APK has a different version code. This means that each split should have a unique version code. Luckily, by now you are able to do this in Gradle by looking at the <code class="literal">applicationVariants</code> property.</p><p>The following snippet comes straight from the Android plugin for Gradle documentation, and shows how to generate different version codes for each APK:</p><div><pre class="programlisting">ext.versionCodes = ['armeabi-v7a':1, mips:2, x86:3]

import com.android.build.OutputFile

android.applicationVariants.all { variant -&gt;
    // assign different version code for each output
    variant.outputs.each { output -&gt;
        output.versionCodeOverride =  project.ext.versionCodes.get(output.getFilter(OutputFile.ABI)) * 1000000 + android.defaultConfig.versionCode
    }
}</pre></div><p>This little snippet checks which ABI is used on a build variant, and then applies a multiplier to the version code to make sure each variant has a unique version code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Summary</h1></div></div></div><p>After reading this chapter, you know how to reduce the size of your build outputs, and how to speed up builds by configuring Gradle and the JVM. Big migration projects should not frighten you anymore. You also learned some tricks that make development and deployment easier.</p><p>And with that, you have reached the end of the book! Now that you know the possibilities of Gradle, you can tweak and customize the build processes of your Android projects to the point where you will not need to do any manual work, except for executing tasks. You can configure build variants, manage dependencies, and configure multimodule projects. The Gradle DSL makes sense to you because you understand Groovy syntax, and you are comfortable with hooking into the Android plugin. You can even create tasks or plugins and share them, to help others automate their builds. All you need to do now is to apply your new skills!</p></div></body></html>