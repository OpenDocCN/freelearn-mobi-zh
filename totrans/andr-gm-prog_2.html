<html><head></head><body><div class="part" title="Part&#xA0;2.&#xA0;Module 2"><div class="titlepage"><div><div><h1 class="title"><a id="part02"/>Part 2. Module 2</h1></div></div></div><div class="partintro" title="Module 2"><div/><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em><span class="strong"><strong>Android Game Programming by Example</strong></span></em></span></p><p><span class="emphasis"><em>Harness the power of the Android SDK by building three immersive and captivating games</em></span></p></blockquote></div></div></div>
<div class="chapter" title="Chapter&#xA0;1.&#xA0;Player 1 UP"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 1. Player 1 UP</h1></div></div></div><p>The terminology used by old arcade and pinball machines "1 UP" was a kind of notice to the players that they were playing (up) now. It was also used to indicate earning an extra life. Are you ready to build three great games?</p><p>We will build three cool games together. Every line of code for these three games is shown in this book; you will never have to refer to the code files to see what is going on. Also, the entire file set required to build all three games is included in the download bundle that can be obtained from the books page on the Packt website.</p><p>All the code, Android manifest files, and the graphical and audio assets are included in the download as well. The three cool games are progressively more challenging to implement.</p><p>The first project uses a simple but functional game engine that clearly demonstrates the essentials of a main game loop. The game will be fully working with the home screen, high scores, sound, and animation. But by the end of the project, as we add features and try to balance the game play, we will soon see that we need more flexibility in order to add features.</p><p>In the second project, a hard retro platformer, we will see how we can use a simple and flexible design to build a relatively fast and very flexible game engine, which is extendable and reusable. This flexibility will allow us to make quite a complex and well-featured game. This game will have multiple levels, different environments, and more. This in turn will highlight the need for being able to draw graphics more quickly. That leads us on to the third project.</p><p>In the third project, we will build an Asteroids-like game called <a class="indexterm" id="id000"/>
<span class="strong"><strong>Asteroids simulator</strong></span>. Although the game won't have as many features as the previous project, it will feature the super-smooth drawing of hundreds of animated game objects running at over 60 frames per second. We will achieve this by learning about and using<a class="indexterm" id="id001"/> the <span class="strong"><strong>Open Graphics Library for Embedded Systems</strong></span> (<span class="strong"><strong>OpenGL ES 2</strong></span>).</p><p>By the end of this book, you will have a whole repertoire of design ideas, techniques, and code templates that you can use in your future games. By seeing the strengths and weaknesses of the different ways of making games on Android, you will be able to successfully design and build games in the most appropriate way for your next big game.</p><div class="section" title="A closer look at the games"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec009"/>A closer look at the games</h1></div></div></div><p>Here is a quick glimpse at the three projects.</p><div class="section" title="Tappy Defender"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec008"/>Tappy Defender</h2></div></div></div><p>Fly Flappy Bird-style with one finger <a class="indexterm" id="id002"/>to reach your home planet, while avoiding multiple enemies. Features include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic animation</li><li class="listitem" style="list-style-type: disc">Home screen<div class="mediaobject"><img alt="Tappy Defender" src="graphics/B04322_01_01.jpg"/></div></li><li class="listitem" style="list-style-type: disc">Collision detection</li><li class="listitem" style="list-style-type: disc">High scores</li><li class="listitem" style="list-style-type: disc">Simple HUD</li><li class="listitem" style="list-style-type: disc">One-finger touch screen controls<div class="mediaobject"><img alt="Tappy Defender" src="graphics/B04322_01_01b.jpg"/></div></li></ul></div></div><div class="section" title="Tough retro platformer"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec009"/>Tough retro platformer</h2></div></div></div><p>This is a genuinely<a class="indexterm" id="id003"/> tough-to-beat retro style platform game. We have to guide Bob from the underground fire caves through the city, forest, and finally to the mountains. It has four challenging levels. Features include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A more advanced, flexible<a class="indexterm" id="id004"/> game engine</li><li class="listitem" style="list-style-type: disc">More advanced "sprite sheet" character animation</li><li class="listitem" style="list-style-type: disc">A level builder engine to design your levels in text format</li><li class="listitem" style="list-style-type: disc">Multiple scrolling parallax backgrounds</li><li class="listitem" style="list-style-type: disc">Transition between levels</li><li class="listitem" style="list-style-type: disc">A more advanced HUD<div class="mediaobject"><img alt="Tough retro platformer" src="graphics/B04322_01_02.jpg"/></div></li><li class="listitem" style="list-style-type: disc">Add loads of extra diverse levels</li><li class="listitem" style="list-style-type: disc">Sound manager to easily manage sound FX</li><li class="listitem" style="list-style-type: disc">Pickups</li><li class="listitem" style="list-style-type: disc">An <a class="indexterm" id="id005"/>upgradeable gun</li><li class="listitem" style="list-style-type: disc">Seek-and-destroy enemy drones</li><li class="listitem" style="list-style-type: disc">Simple AI scripting for patrolling enemy guards</li><li class="listitem" style="list-style-type: disc">Hazards such as fire pits</li><li class="listitem" style="list-style-type: disc">Scenery objects to create atmosphere<div class="mediaobject"><img alt="Tough retro platformer" src="graphics/B04322_01_02b.jpg"/></div></li></ul></div></div><div class="section" title="Asteroids simulator"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec010"/>Asteroids simulator</h2></div></div></div><p>This is a classic shooter <a class="indexterm" id="id006"/>with retro vector-graphics style visuals. It involves clearing waves of smoothly animated spinning asteroids with a rapid fire gun. Features <a class="indexterm" id="id007"/>include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">60 frames per second or better, even on old hardware</li><li class="listitem" style="list-style-type: disc">An introduction to OpenGL ES 2</li><li class="listitem" style="list-style-type: disc">Shooter with waves of progressive difficulty</li><li class="listitem" style="list-style-type: disc">Advanced multiphase collision detection<div class="mediaobject"><img alt="Asteroids simulator" src="graphics/B04322_01_03.jpg"/></div></li></ul></div></div></div></div>
<div class="section" title="Setting up your development environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec010"/>Setting up your development environment</h1></div></div></div><p>All the code in this book and <a class="indexterm" id="id008"/>the download bundle will work in your favorite Android IDE. However, I found the latest version of Android Studio exceptionally friendly to use and the code was written and tested in it as well.</p><p>If you don't currently use Android Studio, I encourage you to give it a try. Here is a quick overview of how to get up and running quickly. This guide includes steps to install the Java JDK in case you are completely new to Android development.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0002"/>Tip</h3><p>If you already have your preferred development environment ready to go then jump straight to <a class="link" href="ch11.html" title="Chapter 2. Tappy Defender – First Step">Chapter 2</a>, <span class="emphasis"><em>Tappy Defender – First Step</em></span>.</p></div></div><p>The first thing we need to do is prepare your PC to develop for Android using Java. Fortunately, this is made quite simple for us.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0003"/>Tip</h3><p>If you are learning on Mac or Linux everything in this book will still work. The next two tutorials have Windows-specific instructions and screenshots. However, it shouldn't be too difficult to vary the steps slightly to suit Mac or Linux.</p></div></div><p>All we need to do is:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the <span class="strong"><strong>Java Development Kit</strong></span> (<span class="strong"><strong>JDK</strong></span>), which allows us to develop in Java.</li><li class="listitem">Then install <a class="indexterm" id="id009"/>Android Studio to make Android development fast and easy. Android Studio uses the JDK and some other Android-specific tools that get automatically installed when we install Android Studio.</li></ol></div><div class="section" title="Installing the JDK"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec011"/>Installing the JDK</h2></div></div></div><p>The first thing we need to do <a class="indexterm" id="id0010"/>is get the <a class="indexterm" id="id0011"/>latest version of the JDK. To complete this guide, perform the following instructions:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to be <a class="indexterm" id="id0012"/>on the Java website, so visit: <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>.</li><li class="listitem">Find the three buttons shown here and click on the one that says <span class="strong"><strong>JDK</strong></span> that is highlighted in the following image. They are on the right-hand side of the web page. Then, click on the <span class="strong"><strong>Download</strong></span> button under the <span class="strong"><strong>JDK</strong></span> option:<div class="mediaobject"><img alt="Installing the JDK" src="graphics/B04322_01_04.jpg"/></div></li><li class="listitem">You will be taken to a page that has multiple options to download the JDK. In the <span class="strong"><strong>Product/File Description</strong></span> column, you need to click the option that matches your operating system. Windows, Mac, Linux, and some other less common options are all listed.</li><li class="listitem">A common question asked here is, do I have 32- or 64-bit windows? To find out, right-click on your <span class="strong"><strong>My Computer</strong></span> icon (<span class="strong"><strong>This PC</strong></span> on Windows 8), click on the <span class="strong"><strong>Properties</strong></span> option, and look under the <span class="strong"><strong>System</strong></span> heading at the <span class="strong"><strong>System type</strong></span> entry:<div class="mediaobject"><img alt="Installing the JDK" src="graphics/B04322_01_05.jpg"/></div></li><li class="listitem">Click on the <a class="indexterm" id="id0013"/>somewhat hidden <span class="strong"><strong>Accept License Agreement</strong></span> checkbox:<div class="mediaobject"><img alt="Installing the JDK" src="graphics/B04322_01_06.jpg"/></div></li><li class="listitem">Now, click on <a class="indexterm" id="id0014"/><span class="strong"><strong>download for your OS</strong></span> and type as previously determined. Wait for the download to finish.</li><li class="listitem">In your <code class="literal">downloads</code> folder, double-click on the file you just downloaded. The latest version at the time of writing for a 64-bit Windows PC was <code class="literal">jdk-8u5-windows-x64</code>. If you are using Mac/Linux or have a 32-bit OS, your filename will vary accordingly.</li><li class="listitem">In the first of several install dialogs, click on the <span class="strong"><strong>Next</strong></span> button and you will see the following dialog box:<div class="mediaobject"><img alt="Installing the JDK" src="graphics/B04322_01_07.jpg"/></div></li><li class="listitem">Accept the defaults shown in the previous image by clicking on <span class="strong"><strong>Next</strong></span>. In the next dialog box, you can accept the default install location by clicking on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Next up is the last dialog of the Java installer; for this click on <span class="strong"><strong>Close</strong></span>.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0002"/>Note</h3><p>The JDK is now installed. Next, we will make sure that Android Studio is able to use the JDK.</p></div></div></li><li class="listitem">Right-click on <a class="indexterm" id="id0015"/>your <span class="strong"><strong>My Computer</strong></span> icon (<span class="strong"><strong>This PC</strong></span> on windows 8) <a class="indexterm" id="id0016"/>and click on <span class="strong"><strong>Properties</strong></span> | <span class="strong"><strong>Advanced system settings</strong></span> | <span class="strong"><strong>Environment Variables...</strong></span> | <span class="strong"><strong>New...</strong></span> (under <span class="strong"><strong>System variables</strong></span>, not under <span class="strong"><strong>User variables</strong></span>). Now, you can see the <span class="strong"><strong>New System Variable</strong></span> dialog box:<div class="mediaobject"><img alt="Installing the JDK" src="graphics/B04322_01_08.jpg"/></div></li><li class="listitem">Type <code class="literal">JAVA_HOME</code> for <span class="strong"><strong>Variable name:</strong></span> and enter <code class="literal">C:\Program Files\Java\jdk1.8.0_05</code> for the <span class="strong"><strong>Variable value:</strong></span> field. If you installed the JDK somewhere else, then the file path you enter in the <span class="strong"><strong>Variable value:</strong></span> field will need to point to wherever you put it. Your exact file path will likely have a different ending to match the latest version of Java at the time you downloaded it.</li><li class="listitem">Click on <span class="strong"><strong>OK</strong></span> to save your new settings.</li><li class="listitem">Now under <span class="strong"><strong>System variables</strong></span>, click on <span class="strong"><strong>Path</strong></span> and then click on the <span class="strong"><strong>Edit...</strong></span> button. At the very end of the text in the <span class="strong"><strong>Variable value:</strong></span> field, enter the following text to add our new variable to the file paths that Windows will use, <code class="literal">;JAVA_HOME</code>. Be sure not to miss the semicolon from the beginning.</li><li class="listitem">Click on <span class="strong"><strong>OK</strong></span> to save the updated <span class="strong"><strong>Path</strong></span> variable.</li><li class="listitem">Now, click on <a class="indexterm" id="id0017"/><span class="strong"><strong>OK</strong></span> again to clear the <span class="strong"><strong>Advanced system settings</strong></span> <a class="indexterm" id="id0018"/>dialog box.</li></ol></div><p>The JDK is now installed on our PC.</p></div><div class="section" title="Installing Android Studio"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec012"/>Installing Android Studio</h2></div></div></div><p>Without delay, let's get<a class="indexterm" id="id0019"/> Android Studio installed, and then we can begin our <a class="indexterm" id="id0020"/>first <a class="indexterm" id="id0021"/>game project. Visit:</p><p>
<a class="ulink" href="https://developer.android.com/sdk/index.html">https://developer.android.com/sdk/index.html</a>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click on the button labeled <span class="strong"><strong>DOWNLOAD ANDROID STUDIO FOR WINDOWS</strong></span> to start the Android Studio download. This will take you to another web page with a very similar looking button to the one you just clicked on.</li><li class="listitem">Accept the license by checking the checkbox and commence the download by clicking the button labeled <span class="strong"><strong>DOWNLOAD ANDROID STUDIO FOR WINDOWS</strong></span> and wait for the download to complete.</li><li class="listitem">In the folder you just downloaded Android Studio to, right-click on the <code class="literal">android-studio-bundle-135.12465-windows.exe</code> file and click on <span class="strong"><strong>Run as administrator</strong></span>. The end of your filename will vary depending on the version of Android Studio and your operating system.</li><li class="listitem">When asked if you want to allow the following program from an unknown publisher to make changes to your computer, click on <span class="strong"><strong>Yes</strong></span>. On the next screen, click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">On the screen pictured here, you can choose which users of your PC can use Android Studio. Choose which is right for you as all options will work, and then click on <span class="strong"><strong>Next</strong></span>:<div class="mediaobject"><img alt="Installing Android Studio" src="graphics/B04322_01_09.jpg"/></div></li><li class="listitem">In the next dialog, leave the default settings and then click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">On the <span class="strong"><strong>Choose start menu folder</strong></span> dialog box leave the defaults and click on <span class="strong"><strong>Install</strong></span>.</li><li class="listitem">On the Installation complete dialog, click on <span class="strong"><strong>Finish</strong></span> to run Android Studio for the first time.</li><li class="listitem">The next dialog is for users who have already used Android Studio, so assuming you are <a class="indexterm" id="id0022"/>first-time user, select the <span class="strong"><strong>I do not have a previous version of Android Studio or I do not want to import my settings</strong></span> <a class="indexterm" id="id0023"/>checkbox. Then click on <span class="strong"><strong>OK</strong></span>:<div class="mediaobject"><img alt="Installing Android Studio" src="graphics/B04322_01_10.jpg"/></div></li></ol></div><p>That was the last piece of software we needed. We will begin to use Android Studio straight away in the next chapter.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec011"/>Summary</h1></div></div></div><p>This chapter was deliberately kept as short as possible, so we can get on with building some games. We will do this now.</p></div>
<div class="chapter" title="Chapter&#xA0;2.&#xA0;Tappy Defender &#x2013; First Step"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 2. Tappy Defender – First Step</h1></div></div></div><p>Welcome to the first game, which we will learn about in three chapters. In this chapter, we will closely examine the goals for the finished product. It helps a lot when building a game, if we know exactly what we are trying to achieve.</p><p>We can then look at the structure of our code, including an approximate design pattern that we will be adhering to. Then, we will put together the code skeleton of our first game engine. Finally, to finish the chapter, we will draw our first real object from the game and animate it on the screen.</p><p>We will then be ready for <a class="link" href="ch12.html" title="Chapter 3. Tappy Defender – Taking Flight">Chapter 3</a>, <span class="emphasis"><em>Tappy Defender – Taking Flight</em></span>, where we can make really fast progress before completing our first game in <a class="link" href="ch13.html" title="Chapter 4. Tappy Defender – Going Home">Chapter 4</a>, <span class="emphasis"><em>Tappy Defender – Going Home</em></span>.</p><div class="section" title="Planning the first game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec012"/>Planning the first game</h1></div></div></div><p>In this section, we will flesh out <a class="indexterm" id="id0024"/>exactly what our game will be. The backstory; who is our hero and what are they trying to achieve? The game mechanics; what will the player actually do? What buttons will he press and in what way is that a challenge or fun thing to do? Then, we will look at the rules. What constitutes victory, death, and progress? Finally, we will get technical and start to examine how we will actually build the game.</p><div class="section" title="Backstory"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec013"/>Backstory</h2></div></div></div><p>Valerie has been defending the far <a class="indexterm" id="id0025"/>outposts of humanity since the early '80s. Her <a class="indexterm" id="id0026"/>brave exploits were originally immortalized in the 1981 arcade classic, Defender. However, after over 30 years on the front line, she is retiring and it is time to begin the journey home. Unfortunately, in a recent skirmish, her ship's engines and navigation systems were severely damaged. Therefore, now she must fly all the way home using only her boost thruster. </p><p>This means that she must fly her ship by simultaneously thrusting up and forward, kind of bouncing really, while avoiding enemies who try to crash into her. In a recent communication with Earth, Valerie was heard to claim that it was, "Like trying to fly a lame bird." This is some concept art of Valerie in her damaged ship because it helps to visualize our game as early as possible.</p><div class="mediaobject"><img alt="Backstory" src="graphics/B04322_02_01.jpg"/></div><p>Now that we have learned a<a class="indexterm" id="id0027"/> little bit about our hero and her predicament, we take a <a class="indexterm" id="id0028"/>closer look at the mechanics of the game.</p></div><div class="section" title="The game mechanics"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec014"/>The game mechanics</h2></div></div></div><p>Mechanics<a class="indexterm" id="id0029"/> are the key<a class="indexterm" id="id0030"/> actions that a player must make and become good at, to be able to beat the game. When designing a game, you can rely on tried and tested ideas for mechanics or you can invent your own. In Tappy Defender, we will be using a mechanic where the player taps and holds the screen to boost the ship.</p><p>This boosting will raise the ship up the screen, but will also make the ship speed up and therefore be more vulnerable. When the player removes their finger, the boost engine will cut out and the ship will fall downward and decelerate, thus making the ship slightly less vulnerable. Therefore, a very fine and masterful balance of boosting and not boosting is required to survive.</p><p>Tappy Defender is of course heavily inspired by Flappy Bird and a multitude of similar games that followed its success.</p><p>Instead of a how-far-can-I-get scoring system like Flappy Bird, Tappy Defender will have a goal of reaching "home". Then, the player can replay the game multiple times in order to try and beat their fastest time. Of course to go faster, the player must boost more frequently and put Valerie in greater peril.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0003"/>Note</h3><p>In the unlikely event you have never played or seen Flappy Bird, it is well worth spending 5 minutes having a play with this type of game now. You can download one of the many<a class="indexterm" id="id0031"/> Flappy Bird inspired apps from the Google Play store:</p><p>
<a class="ulink" href="https://play.google.com/store/search?q=flappy%20bird&amp;c=apps">https://play.google.com/store/search?q=flappy%20bird&amp;c=apps</a>
</p></div></div></div><div class="section" title="Rules for the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec015"/>Rules for the game</h2></div></div></div><p>Here, we will<a class="indexterm" id="id0032"/> define things <a class="indexterm" id="id0033"/>which balance the game and make it fair and consistent for the player:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The player's ship is much tougher than the enemy ships. This is because the player's ship has shields. Each time the player collides with an enemy, the enemy is instantly destroyed, but the player loses a shield. The player has three shields.</li><li class="listitem" style="list-style-type: disc">The player will need to fly a set number of kilometers to reach home.</li><li class="listitem" style="list-style-type: disc">Every time the player reaches home, they win the game. If their time was the fastest, they also get a new fastest time, like a high score.</li><li class="listitem" style="list-style-type: disc">Enemies will spawn at a random height on the far right of the screen and fly toward the player at a random speed.</li></ul></div><p>The player is always positioned on the far left of the screen, but boosting will mean the enemies approach more quickly.</p></div><div class="section" title="The design"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec016"/>The design</h2></div></div></div><p>We will use a loose <a class="indexterm" id="id0034"/>design pattern, where we will separate our code based on a <a class="indexterm" id="id0035"/>control part, model part, and view. This is how we will separate our code into three areas.</p><div class="section" title="Control"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec001"/>Control</h3></div></div></div><p>This is the part of our code that will control<a class="indexterm" id="id0036"/> all other parts. It will decide when to show the view, it will initialize all our game objects from the model, and it will prompt decisions based on the states of data to take place within the model.</p></div><div class="section" title="Model"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec002"/>Model</h3></div></div></div><p>The model<a class="indexterm" id="id0037"/> is our game data and logic. What do the ships look like? Where on the screen are our ships? How fast are they going, and so on. Furthermore, the model part of our code is the intelligence system for each of our game objects. Although our enemies in this game don't have sophisticated AI, they will know and decide for themselves how fast they are going, when to respawn and more.</p></div><div class="section" title="View"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec003"/>View</h3></div></div></div><p>The view<a class="indexterm" id="id0038"/> is exactly what it sounds like. It is the part of our code that will do the actual drawing based on the state of the models. It will draw when the control part of our code tells it. It will not have any influence over the game objects. For example, the view will not decide where an object is or even what it looks like. It just draws and then hands control back to the control code.</p></div><div class="section" title="Design pattern reality check"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec004"/>Design pattern reality check</h3></div></div></div><p>In reality, the separation is not as<a class="indexterm" id="id0039"/> clear as the discussion suggests. In fact, the code for drawing and control is within the same class. However, you will see that the logic of drawing and controlling is separate within that class.</p><p>By separating our game into these three parts, we will see how we simplify the development and avoid getting tied up in messy code that constantly expands as we add new features to our game.</p><p>Let's look more closely at where this pattern fits in with our code.</p></div></div><div class="section" title="The game code structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec017"/>The game code structure</h2></div></div></div><p>First of all, we must take<a class="indexterm" id="id0040"/> account of the system we are working within. In this case, it is<a class="indexterm" id="id0041"/> the Android system. If you have been making Android apps for a while, you may be wondering where this pattern stuff fits in with the Android Activity lifecycle. If you are new to Android, you might ask what the Activity lifecycle is.</p><div class="section" title="The Android Activity lifecycle"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec005"/>The Android Activity lifecycle</h3></div></div></div><p>The <a class="indexterm" id="id0042"/>Android Activity lifecycle <a class="indexterm" id="id0043"/>is the framework we must work within to make any type of Android app. There is a class called <code class="literal">Activity</code> that we must derive from and is an entry point to our app. In addition, we need to be aware that this class, that our game is an object of, also has some methods we can override. These methods control the lifecycle of our app.</p><p>When an app is started by the user, our <code class="literal">Activity</code> object is created and a number of the methods that we can override are called in sequence. This is what happens.</p><p>When the <code class="literal">Activity</code> object is created, three methods are called in sequence; <code class="literal">onCreate()</code>, <code class="literal">onStart()</code>, and <code class="literal">onResume()</code>. At this point, the app is now running. In addition, when the user quits an app or the app is interrupted, perhaps by a phone call, the <code class="literal">onPause</code> method is called. The user may decide, perhaps after completing their phone call, to return to the app. If this happens, the <code class="literal">onResume</code> method is called, following which the app is running again.</p><p>Should the user not return to the app or the Android system decides that it<a class="indexterm" id="id0044"/> wants the system resources for something else, two further methods are called to clean up. First <code class="literal">onStop()</code>, and then <code class="literal">onDestroy()</code>. The app is now destroyed and any attempt to return to the game again will result in the Activity lifecycle starting from the beginning.</p><p>All we have to do as game programmers is be aware of this lifecycle and observe a few rules of good housekeeping. We will implement and explain the rules of good housekeeping as we proceed.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0004"/>Note</h3><p>The <a class="indexterm" id="id0045"/>Android Activity lifecycle is much more complex and far more nuanced than I have just explained it. However, we know everything we need to get programming our first game. If you want to know more please have a look at this article on the Android developer's web site at:</p><p>
<a class="ulink" href="http://developer.android.com/reference/android/app/Activity.html">http://developer.android.com/reference/android/app/Activity.html</a>
</p></div></div><p>Once we have catered for the Android Activity lifecycle, the core methods of our class representing the control part of the pattern will be as simple as this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update the state of our game objects.</li><li class="listitem">Draw the game objects based on their state.</li><li class="listitem">Pause to lock the frame rate.</li><li class="listitem">Get player input. Actually because parts 1, 2, and 3 happen in a thread, this part can happen at any time.</li><li class="listitem">Repeat.</li></ol></div><p>One last bit of preparation, before we start to build our game for real.</p></div></div><div class="section" title="The Android Studio file structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec018"/>The Android Studio file structure</h2></div></div></div><p>The Android system is quite<a class="indexterm" id="id0046"/> particular about where we put our class files, including <code class="literal">Activity</code> and where in the file hierarchy we place our assets like sound files and graphics.</p><p>Here is a really quick overview of where we will be putting everything. You don't need to memorize this, as we will remind ourselves of the correct folder while adding assets. We will step through the activity/class creation process the first few times we need to do it.</p><p>As a heads up, here is an annotated diagram of what your Android Studio project explorer will look like by the end of the Tappy Defender project:</p><div class="mediaobject"><img alt="The Android Studio file structure" src="graphics/B04322_02_02.jpg"/></div><p>Now, we can actually start building Tappy Defender.</p></div></div></div>
<div class="section" title="Building the home screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec013"/>Building the home screen</h1></div></div></div><p>Since we have<a class="indexterm" id="id0047"/> done all the <a class="indexterm" id="id0048"/>planning and preparation, we can get started with the code.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0005"/>Note</h3><p>To use the code files, you will still need to create an Android Studio project. In addition, you will need to change the package name in the very first line of code of each of the JAVA files. Change the package name to match the package name of the project you created. Finally, you will need to make sure that any assets such as images or sound files are placed into the appropriate folder in the project. All the required assets for each project are supplied in the download bundle.</p></div></div><div class="section" title="Creating the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec019"/>Creating the project</h2></div></div></div><p>Fire up Android Studio <a class="indexterm" id="id0049"/>and create a new project by following these steps. All the files to get the project to where we will be, by the end of this chapter, are in the download bundle in the <code class="literal">Chapter2</code> folder.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On the <span class="strong"><strong>Welcome to Android Studio</strong></span> dialog, click on <span class="strong"><strong>Start a new Android Studio project</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Create New Project</strong></span> window shown next, we need to enter some basic information about our app. These bits of information will be used by Android Studio to determine the package name.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0006"/>Note</h3><p>In the following image, you can see the <span class="strong"><strong>Edit</strong></span> link where you can customize the package name if required.</p></div></div></li><li class="listitem"> If you will be copy/pasting the supplied code into your project, then use <code class="literal">C1 Tappy Defender</code> for the <span class="strong"><strong>Application name</strong></span> field and <code class="literal">gamecodeschool.com</code> in the <span class="strong"><strong>Company Domain</strong></span> field as shown in the following screenshot:<div class="mediaobject"><img alt="Creating the project" src="graphics/B04322_02_03.jpg"/></div></li><li class="listitem">Click on the<a class="indexterm" id="id0050"/> <span class="strong"><strong>Next</strong></span> button when you're ready. When asked to select the form factors, your app will run on, we can accept the default settings (<span class="strong"><strong>Phone and Tablet</strong></span>). So click on <span class="strong"><strong>Next</strong></span> again.</li><li class="listitem">On the <span class="strong"><strong>Add an activity to mobile </strong></span>dialog, just click on <span class="strong"><strong>Blank Activity</strong></span> followed by the <span class="strong"><strong>Next</strong></span> button.</li><li class="listitem">On the <span class="strong"><strong>Customize the Activity </strong></span>dialog, again we can accept the default settings because <code class="literal">MainActivity</code> seems like a good name for our main Activity. So click on the <span class="strong"><strong>Finish</strong></span> button.</li></ol></div><div class="section" title="What we did"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec006"/>What we did</h3></div></div></div><p>Android Studio has built the project and created a number of files, most of which we will see and edit during the course of building this game. As mentioned earlier, even if you are just copying and pasting the code, you need to go through this step because Android Studio is doing things behind the scenes to make our project work.</p></div></div><div class="section" title="Building the home screen UI"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec020"/>Building the home screen UI</h2></div></div></div><p>The first and <a class="indexterm" id="id0051"/>simplest part of our Tappy Defender game is the home screen. All we need is a neat picture with a scene about the game, a high score, and a button to start the game. The finished home screen will look a bit like this:</p><div class="mediaobject"><img alt="Building the home screen UI" src="graphics/B04322_02_04.jpg"/></div><p>When we built the project, Android Studio opens up two files ready for us to edit. You can see them as tabs in the following Android Studio UI designer. The files (and tabs) are <code class="literal">MainActivity.java</code> and <code class="literal">activity_main.xml</code>:</p><div class="mediaobject"><img alt="Building the home screen UI" src="graphics/B04322_02_05.jpg"/></div><p>The <code class="literal">MainActivity.java</code> file is the entry point to our game, and we will see this in more detail soon. The <code class="literal">activity_main.xml</code> file is the UI layout that our home screen will use. Now, we can go ahead and edit the <code class="literal">activity_main.xml</code> file, so it actually looks like our home screen should.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, your<a class="indexterm" id="id0052"/> game will be played with the Android device in landscape mode. If we change our UI preview window to landscape, we will see your progress more accurately. Look for the button shown in the next image. It is just preceding the UI preview:<div class="mediaobject"><img alt="Building the home screen UI" src="graphics/B04322_02_06.jpg"/></div></li><li class="listitem">Click on the button shown in the preceding screenshot, and your UI preview will switch to landscape like this:<div class="mediaobject"><img alt="Building the home screen UI" src="graphics/B04322_02_07.jpg"/></div></li><li class="listitem">Make sure <code class="literal">activity_main.xml</code> is open by clicking on its tab.</li><li class="listitem">Now, we will set in a background image. You can use your own or mine from <code class="literal">Chapter2/drawable/background.jpg</code> in the download bundle. Add your chosen image to the <code class="literal">drawable</code> folder of the project in Android Studio.</li><li class="listitem">In the <span class="strong"><strong>Properties</strong></span> <a class="indexterm" id="id0053"/>window of the UI designer, find and click on the <span class="strong"><strong>background</strong></span> property as shown in the next image:<div class="mediaobject"><img alt="Building the home screen UI" src="graphics/B04322_02_08.jpg"/></div></li><li class="listitem">Also, in the previous image the button labelled <span class="strong"><strong>...</strong></span> is outlined. It is just to the right of the <span class="strong"><strong>background</strong></span> property. Click on that <span class="strong"><strong>...</strong></span> button and browse to and select the background image file that you will be using.</li><li class="listitem">Next, we need a <span class="strong"><strong>TextView</strong></span> widget that we will use to display the high score. Note that there is already a <span class="strong"><strong>TextView</strong></span> widget on the layout. It says <span class="strong"><strong>Hello World</strong></span>. You will modify this and use it for our high score. Left click on it and drag the <span class="strong"><strong>TextView</strong></span> to where you want it. You can copy me if you intend using the supplied background or put it where it looks best with your background.</li><li class="listitem">Next, in the <span class="strong"><strong>Properties</strong></span> window, find and click on the <span class="strong"><strong>id</strong></span> property. Enter <code class="literal">textHighScore</code>. Type it exactly as shown because when we write some Java code in a later tutorial, we will refer to this ID in order to manipulate it, to show the player's fastest time.</li><li class="listitem">You can also edit the <span class="strong"><strong>text</strong></span> property to say <code class="literal">High Score: 99999</code> or similar so that the <span class="strong"><strong>TextView</strong></span> looks the part. However, this isn't necessary because your Java code will take care of this later.</li><li class="listitem">Now, we will<a class="indexterm" id="id0054"/> drag a button from the widget palette as shown in the following screenshot:<div class="mediaobject"><img alt="Building the home screen UI" src="graphics/B04322_02_09.jpg"/></div></li><li class="listitem">Drag it to where it looks good on your background. You can copy me if using the supplied background or put it where it looks best with your background.</li><li class="listitem">Next, in the Properties window, find and click on the id property of the button. Enter buttonPlay. Type it exactly as shown because when we write some Java code in a later tutorial, we will refer to this ID in order to manipulate it. Also edit the text property to say Play.</li></ol></div><div class="section" title="What we did"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec007"/>What we did</h3></div></div></div><p>We now have a cool background with neatly arranged widgets (a <span class="strong"><strong>TextView</strong></span> and a <span class="strong"><strong>Button</strong></span>) for your home screen. We can add functionality via Java code to the <span class="strong"><strong>Button</strong></span> widget next. Revisit the <span class="strong"><strong>TextView</strong></span> for the player's high score in <a class="link" href="ch13.html" title="Chapter 4. Tappy Defender – Going Home">Chapter 4</a>, <span class="emphasis"><em>Tappy Defender – Going Home</em></span>. The important point is that both the widgets have been assigned a unique ID that we can use to reference and manipulate in your Java code.</p></div></div><div class="section" title="Coding the functionality"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec021"/>Coding the functionality</h2></div></div></div><p>Now, we have a simple layout<a class="indexterm" id="id0055"/> for our game home screen. Now, we need to add the functionality that will allow the player to click on the <span class="strong"><strong>Play</strong></span> button to start the game.</p><p>Click on the tab for the <code class="literal">MainActivity.java</code> file. The code that was automatically generated for us is not exactly what we need. Therefore, we will start again as it is simpler and quicker than tinkering with what is already there.</p><p>Delete the entire contents of the <code class="literal">MainActivity.java</code> file except the package name and enter the following code in it. Of course, your package name may be different.</p><div class="informalexample"><pre class="programlisting">package com.gamecodeschool.c1tappydefender;

import android.app.Activity;
import android.os.Bundle;

public class MainActivity extends Activity{

    // This is the entry point to our game
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        //Here we set our UI layout as the view
        setContentView(R.layout.activity_main);

    }
}</pre></div><p>The mentioned code is the<a class="indexterm" id="id0056"/> current contents of our main <code class="literal">MainActivity</code> class and the entry point of our game, the <code class="literal">onCreate</code> method. The line of code that begins with <code class="literal">setContentView...</code> is the line that loads our UI layout from <code class="literal">activity_main.xml</code> to the players screen. We can run the game now and see our home screen, but let's make some more progress, following which we will look at how we run the game on a real device at the end of the chapter.</p><p>Now, let's handle the <span class="strong"><strong>Play</strong></span> button on our home screen. Add the two highlighted lines of the following code into the <code class="literal">onCreate</code> method just after the call to <code class="literal">setContentView()</code>. The first new line creates a new <code class="literal">Button</code> object and gets a reference to <code class="literal">Button</code> in our UI layout. The second line is the code that listens for clicks on the button.</p><div class="informalexample"><pre class="programlisting">//Here we set our UI layout as the view
setContentView(R.layout.activity_main);

// Get a reference to the button in our layout
<span class="strong"><strong>final Button buttonPlay =</strong></span>
<span class="strong"><strong>            (Button)findViewById(R.id.buttonPlay);</strong></span>
<span class="strong"><strong>// Listen for clicks</strong></span>
<span class="strong"><strong>buttonPlay.setOnClickListener(this);</strong></span>
</pre></div><p>Note that we have a few errors in our code. We can resolve these errors by holding down the <span class="emphasis"><em>Alt</em></span> keyboard key and then pressing <span class="emphasis"><em>Enter</em></span>. This will add an import directive for the <code class="literal">Button</code> class.</p><p>We still have one error. We need to implement an interface so that our code listens to the button clicks. Modify the <code class="literal">MainActivity</code> class declaration as highlighted:</p><div class="informalexample"><pre class="programlisting">public class MainActivity extends Activity 
<span class="strong"><strong>        implements View.OnClickListener{</strong></span>
</pre></div><p>When we implement<a class="indexterm" id="id0057"/> the <code class="literal">onClickListener</code> interface, we must also implement the <code class="literal">onClick</code> method. This is where we will handle what happens when a button is clicked. We can automatically generate the <code class="literal">onClick</code> method by right-clicking somewhere after the <code class="literal">onCreate</code> method, but within the <code class="literal">MainActivity</code> class, and navigating to <span class="strong"><strong>Generate</strong></span> | <span class="strong"><strong>Implement methods</strong></span> | <span class="strong"><strong>onClick(v:View):void. Or just add the given code.</strong></span>
</p><p>We also need to have Android Studio add another import directive for <code class="literal">Android.view.View</code>. Use the <span class="emphasis"><em>Alt</em></span> | <span class="emphasis"><em>Enter</em></span> keyboard combination again.</p><p>We can now scroll to near the bottom of the <code class="literal">MainActivity</code> class and see that Android Studio has implemented an empty <code class="literal">onClick</code> method for us. We should have no errors in your code at this point. Here is the <code class="literal">onClick</code> method:</p><div class="informalexample"><pre class="programlisting">@Override
public void onClick(View v) {
  //Our code goes here
}</pre></div><p>As we only have one <code class="literal">Button</code> object and one listener, we can safely assume that any clicks on our home screen are the player pressing our <span class="strong"><strong>Play</strong></span> button.</p><p>Android uses the <code class="literal">Intent</code> class to switch between activities. As we need to go to a new activity when the <span class="strong"><strong>Play</strong></span> button is clicked, we will create a new <code class="literal">Intent</code> object and pass in the name of our future <code class="literal">Activity</code> class, <code class="literal">GameActivity</code> to its constructor. We can then use the <code class="literal">Intent</code> object to switch activities. Add the following code to the body of the <code class="literal">onClick</code> method:</p><div class="informalexample"><pre class="programlisting">// must be the Play button.
// Create a new Intent object
Intent i = new Intent(this, GameActivity.class);
// Start our GameActivity class via the Intent
startActivity(i);
// Now shut this activity down
finish();    </pre></div><p>Once again, we have errors in our code because we need to generate a new import directive, this time for the <code class="literal">Intent</code> class so use the <span class="emphasis"><em>Alt</em></span> | <span class="emphasis"><em>Enter</em></span> keyboard combination again. We still have one error in our code. This is because our <code class="literal">GameActivity</code> class does not exist yet. We will now solve this problem.</p></div><div class="section" title="Creating GameActivity"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec022"/>Creating GameActivity</h2></div></div></div><p>We have seen that when the player<a class="indexterm" id="id0058"/> clicks on the <span class="strong"><strong>Play</strong></span> button, main activity will close and game activity will begin. Therefore, we need to create a new activity called <code class="literal">GameActivity</code> that will be were your game actually executes.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">From the main menu, navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Activity</strong></span> | <span class="strong"><strong>Blank Activity</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Customize the Activity</strong></span> dialog, change the <span class="strong"><strong>Activity Name</strong></span> field to <code class="literal">GameActivity</code>.</li><li class="listitem">We can accept all the other default settings from this dialog, so click on <span class="strong"><strong>Finish</strong></span>.</li><li class="listitem">As we did with your <code class="literal">MainActivity</code> class, we will code this class from scratch. Therefore, delete the entire code content from <code class="literal">GameActivity.java</code>.</li></ol></div><div class="section" title="What we did"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec008"/>What we did</h3></div></div></div><p>Android Studio has generated two more files for us and done some work behind the scenes that we will investigate soon. The new files are <code class="literal">GameActivity.java</code> and <code class="literal">activity_game.xml</code>. They are both automatically opened for us in two new tabs, in the same place as the other tabs above the UI designer.</p><p>We will never need <code class="literal">activity_game.xml</code> because we will build a dynamically generated game view, not a static UI. Feel free to close that now or just ignore it. We will come back to the <code class="literal">GameActivity.java</code> file, when we start to code our game for real, later in the chapter in the <span class="emphasis"><em>Coding the game loop</em></span> section.</p></div></div><div class="section" title="Configuring the AndroidManifest.xml file"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec023"/>Configuring the AndroidManifest.xml file</h2></div></div></div><p>We briefly mentioned that <a class="indexterm" id="id0059"/>when we create a new project or a new activity, Android Studio does more than just creating two files for us. This is why we create new projects/activities the way we do.</p><p>One of the things going on behind the scenes is the creation and modification of the <code class="literal">AndroidManifest.xml</code> file in the <code class="literal">manifests</code> directory.</p><p>This file is required for our app to work. Also, it needs to be edited to make our app work the way we want it to. Android Studio has automatically configured the basics for us, but we will now do two more things to this file.</p><p>By editing the <code class="literal">AndroidManifest.xml</code> file, we will force both of our activities to run with a full screen, and we will also lock them to a landscape layout. Let's make these changes here:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">manifests</code> folder now, and double click on the <code class="literal">AndroidManifest.xml</code> file to open it in the code editor.</li><li class="listitem">In the <code class="literal">AndroidManifest.xml</code> file, find the following line of code:<div class="informalexample"><pre class="programlisting">android:name=".MainActivity"</pre></div></li><li class="listitem">Immediately following it, type or copy and paste these two lines to make <code class="literal">MainActivity</code> run full screen and lock it in the landscape orientation:<div class="informalexample"><pre class="programlisting">android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
android:screenOrientation="landscape"</pre></div></li><li class="listitem">In the <code class="literal">AndroidManifest.xml</code> file, find the following line of code:<div class="informalexample"><pre class="programlisting">android:name=".GameActivity"</pre></div></li><li class="listitem">Immediately following it, type or copy and paste these two lines to make <code class="literal">GameActivity</code> run full screen and lock it in the landscape orientation:<div class="informalexample"><pre class="programlisting">android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
android:screenOrientation="landscape"</pre></div></li></ol></div><div class="section" title="What we did"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec009"/>What we did</h3></div></div></div><p>We have now <a class="indexterm" id="id0060"/>configured both activities from our game to be full screen. This presents a much more pleasing appearance to our player. In addition, we have disabled the player's ability to affect our game by rotating their Android device.</p></div></div></div>
<div class="section" title="Coding the game loop"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec014"/>Coding the game loop</h1></div></div></div><p>We said that we will not be using a<a class="indexterm" id="id0061"/> UI layout for our game screen, but instead a<a class="indexterm" id="id0062"/> dynamically drawn view. This is where the view of our pattern comes in. Let's create a new class to represent our view, then we will put in the fundamental building blocks of our Tappy Defender game.</p><div class="section" title="Building the view"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec024"/>Building the view</h2></div></div></div><p>We will leave our two activity <a class="indexterm" id="id0063"/>classes alone for a while so that we can take a look at our class that will represent the view of our game. As we discussed at the start of this chapter, the view and the controller aspects will be part of the same class.</p><p>The Android API provides us with an ideal class for our requirements. The <code class="literal">android.view.SurfaceView</code> class not only provides us a view that is designed for drawing pixels, text, lines, and sprites onto, but also enables us to quickly handle player input as well.</p><p>As if this wasn't useful <a class="indexterm" id="id0064"/>enough, we can also spawn a thread by implementing the runnable interface allowing our main game loop to get player input and other system essentials at the same time. We will deal with the general structure of your new <code class="literal">SurfaceView</code> implementation now, so we can fill in the details as we progress with the project.</p><div class="section" title="Creating a new class for the view"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec010"/>Creating a new class for the view</h3></div></div></div><p>Without further delay, we can<a class="indexterm" id="id0065"/> create a new class which extends <code class="literal">SurfaceView</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click the folder containing our <code class="literal">.java</code> files and select <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Java Class</strong></span> then click on <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Create New Class</strong></span> dialog, name the new class <code class="literal">TDView,</code> (Tappy Defender view). Now, click on <span class="strong"><strong>OK</strong></span> to have Android Studio autogenerate the class.</li><li class="listitem">The new class will open in the code editor. Amend the code to have it extend <code class="literal">SurfaceView</code> and implement <code class="literal">Runnable</code> as discussed in the previous section. Edit the highlighted parts of the code that follows:<div class="informalexample"><pre class="programlisting">
<code class="literal">package com.gamecodeschool.c1tappydefender;</code>

<code class="literal">import android.view.SurfaceView;</code>

<code class="literal">public class TDView extends SurfaceView implements Runnable{</code>

}</pre></div></li><li class="listitem">Use the <span class="emphasis"><em>Alt</em></span> | <span class="emphasis"><em>Enter</em></span> combination to import the missing classes.</li><li class="listitem">Note that we still have an error in our code. This is because we must provide a constructor for our <code class="literal">SurfaceView</code> implementation. Right-click just below the <code class="literal">TDView</code> class declaration and navigate to <span class="strong"><strong>Generate</strong></span> | <span class="strong"><strong>Constructor</strong></span> | <span class="strong"><strong>SurfaceView(Context:context)</strong></span>. Or you can just type this in as shown in the next block of code. Now click on <span class="strong"><strong>OK</strong></span>.</li></ol></div></div><div class="section" title="What we did"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec011"/>What we did</h3></div></div></div><p>We now have a new class called <code class="literal">TDView</code>, which extends <code class="literal">SurfaceView</code> for our drawing requirements and implements <code class="literal">Runnable</code> for our threading needs. We have also generated a constructor, which we will use soon to initialize our new class.</p><p>The <code class="literal">Context</code> parameter that is passed into our constructor is a reference to the current state of our application within the Android system that is held by our <code class="literal">GameActivity</code> class. This <code class="literal">Context</code> parameter is useful/essential for a number of things that we will be implementing throughout this<a class="indexterm" id="id0066"/> project.</p><p>So far, our <code class="literal">TDView</code> class will look like this:</p><div class="informalexample"><pre class="programlisting">package com.gamecodeschool.c1tappydefender;

import android.content.Context;
import android.view.SurfaceView;

public class TDView extends SurfaceView implements Runnable{

    public TDView(Context context) {
        super(context);
    }
}</pre></div></div><div class="section" title="Structuring the class code"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec012"/>Structuring the class code</h3></div></div></div><p>Now that we have our <code class="literal">TDView</code> class<a class="indexterm" id="id0067"/> extended from the <code class="literal">SurfaceView</code> class, we can start coding it. To control the game, we need to be able to update all the game data/objects. This implies an <code class="literal">update</code> method. In addition, we are obviously going to want to draw all our game data once every frame after they have been updated. Let's keep all of our drawing code together in a method called <code class="literal">draw</code>. Furthermore, we need to control the frequency with which this happens. Therefore, a <code class="literal">control</code> method seems like it should be part of the class as well.</p><p>We also know that everything needs to happen in your thread; so to achieve this, we should wrap the code in the <code class="literal">run</code> method. Lastly, we need a way to control when the thread should and shouldn't do its work so we need an infinite loop controlled by a Boolean, perhaps, <code class="literal">playing</code>.</p><p>Copy the following code into the body of our <code class="literal">TDView</code> class to implement what we just discussed:</p><div class="informalexample"><pre class="programlisting">@Override
    public void run() {
        while (playing) {
            update();
            draw();
            control();
        }
    }</pre></div><p>This is the bare-bones of our game. The <code class="literal">run</code> method will execute in a thread, but it will only execute the game loop while the Boolean <code class="literal">playing</code> instance is true. Then, it will update all the game data, draw the screen based on that game data, and control how long it is until the <code class="literal">run</code> method is called again.</p><p>Now, we can quickly build on this code. First of all, we can implement the three methods that we call from the <code class="literal">run</code> method. Type the following code in the body of our <code class="literal">TDView</code> class after closing the curly brace of the <code class="literal">run</code> method:</p><div class="informalexample"><pre class="programlisting">private void update(){
        
}
    
private void draw(){
        
}
       
private void control(){
        
}</pre></div><p>We now need to declare our playing member variable. We can do this using the <code class="literal">volatile</code> keyword as it will be accessed from outside the thread and from within. Type this code just after the <code class="literal">TDView</code> class declaration:</p><div class="informalexample"><pre class="programlisting">volatile boolean playing;</pre></div><p>Now, we know that we <a class="indexterm" id="id0068"/>can control the execution of code within the run method with the infinite loop and the <code class="literal">playing</code> variable. We also need to start and stop the actual thread itself. Not just when we decide, but when the player unexpectedly quits the game. What if he gets a phone call or just taps the home button on his device.</p><p>To handle these events, we need the <code class="literal">TDView</code> class and <code class="literal">GameActivity</code> to work together. Now, in the <code class="literal">TDView</code> class, we can implement a <code class="literal">pause</code> method and a <code class="literal">resume</code> method. Within them, we put the code to stop and start our thread. Implement these two methods within the body of the <code class="literal">TDView</code> class:</p><div class="informalexample"><pre class="programlisting">// Clean up our thread if the game is interrupted or the player quits
public void pause() {
        playing = false;
        try {
            gameThread.join();
        } catch (InterruptedException e) {

        }
    }

    // Make a new thread and start it
    // Execution moves to our R
    public void resume() {
           playing = true;
           gameThread = new Thread(this);
           gameThread.start();
    }</pre></div><p>Now, we need an instance of a <code class="literal">Thread</code> class called <code class="literal">gameThread</code>. We can declare it as a member variable of <code class="literal">TDView</code> just after the class declaration, right after our Boolean <code class="literal">playing</code> parameter. Like this:</p><div class="informalexample"><pre class="programlisting">volatile boolean playing;
<span class="strong"><strong>Thread gameThread = null;</strong></span>
</pre></div><p>Note that the <code class="literal">onPause</code><a class="indexterm" id="id0069"/> and <code class="literal">onResume</code> methods are public. We can now add code to our <code class="literal">GameActivity</code> class to call these methods at the appropriate time. Remember that <code class="literal">GameActivity</code> extends <code class="literal">Activity</code>. Therefore, use the overridden <code class="literal">Activity</code> lifecycle methods.</p><p>By overriding the <code class="literal">onPause</code> method, whenever the activity is paused, we can shut down the thread. This avoids potentially embarrassing the player and having to explain to his caller, why they can hear sound FX in the background.</p><p>By overriding <code class="literal">onResume()</code>, we can have our thread start up in the last phase of the Android lifecycle before the app is actually running.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0007"/>Note</h3><p>Note the distinction between the <code class="literal">pause</code> and <code class="literal">resume</code> methods of the <code class="literal">TDView</code> class and the overridden <code class="literal">onPause</code> and <code class="literal">onResume</code> methods of the <code class="literal">GameActivity</code> class.</p></div></div></div></div><div class="section" title="The game activity"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec025"/>The game activity</h2></div></div></div><p>Before you<a class="indexterm" id="id0070"/> implement/override this method, note that all they will do is call the parent version of their respective methods followed by the public methods in the <code class="literal">TDView</code> class to which they correspond.</p><p>You might remember back to the section when we created our new <code class="literal">GameActivity</code> class, we deleted the entire code contents? With that in mind, here is the outline of the code we will need in <code class="literal">GameActivity.java</code> including the implementation of the overridden methods within the body of the <code class="literal">GameActivity</code> class that we discussed in the previous section. Type this code in <code class="literal">GameActivity.java</code>:</p><div class="informalexample"><pre class="programlisting">package com.gamecodeschool.c1tappydefender;

import android.app.Activity;
import android.os.Bundle;

public class GameActivity extends Activity {

    // This is where the "Play" button from HomeActivity sends us
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        
    }

    // If the Activity is paused make sure to pause our thread
    @Override
    protected void onPause() {
        super.onPause();
        gameView.pause();
    }

    // If the Activity is resumed make sure to resume our thread
    @Override
    protected void onResume() {
        super.onResume();
        gameView.resume();
    }

   
}</pre></div><p>Finally, let's go ahead <a class="indexterm" id="id0071"/>and declare an object of the <code class="literal">TDView</code> class. Do this just after the <code class="literal">GameActivity</code> class declaration:</p><div class="informalexample"><pre class="programlisting">// Our object to handle the View
private TDView gameView;</pre></div><p>Now, within the <code class="literal">onCreate</code> method, we need to instantiate your object, keeping in mind that your constructor in <code class="literal">TDView.java</code> takes a <code class="literal">Context</code> object as an argument. Then, we use the newly instantiated object in a call to <code class="literal">setContentView()</code>. Remember when we built our home screen, we called <code class="literal">setContentView()</code> and passed in our UI design. This time, we are setting the player's view to be the object of our <code class="literal">TDView</code> class. Copy the following code into the <code class="literal">onCreate</code> method of the <code class="literal">GameActivity</code> class:</p><div class="informalexample"><pre class="programlisting">// Create an instance of our Tappy Defender View (TDView)
// Also passing in "this" which is the Context of our app
gameView = new TDView(this);

// Make our gameView the view for the Activity
setContentView(gameView);</pre></div><p>At this point, we can actually run our game and click on the <span class="strong"><strong>Play</strong></span> button to proceed to the <code class="literal">GameView</code> activity, which will use <code class="literal">TDView</code> as its view and start our thread. Obviously, there is nothing to see yet, so let's work on the model of our design pattern and build the basic outline of our first game object. At the end of the chapter, we will see how to run the game on an <a class="indexterm" id="id0072"/>Android device.</p></div></div>
<div class="section" title="The PlayerShip object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec015"/>The PlayerShip object</h1></div></div></div><p>We need to keep the model part of <a class="indexterm" id="id0073"/>our code as separate as possible from the rest. We can <a class="indexterm" id="id0074"/>do this by creating a class for our player's spaceship. Let's call our new class <code class="literal">PlayerShip</code>.</p><p>Go ahead and add a new class to the project, and call it <code class="literal">PlayerShip</code>. Here are a few quick steps on how to do that. Now, right-click the folder with our <code class="literal">.java</code> files in it and navigate to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Java Class</strong></span>, then enter <code class="literal">PlayerShip</code> as the name and click on <span class="strong"><strong>OK</strong></span>.</p><p>What do we need our <code class="literal">PlayerShip</code> class to be able to know about itself? As a bare minimum it needs to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Know where it is on the screen</li><li class="listitem" style="list-style-type: disc">What it looks like</li><li class="listitem" style="list-style-type: disc">How fast it is flying</li></ul></div><p>These requirements suggest a few member variables we can declare. Enter the code just after the class declaration that we generated:</p><div class="informalexample"><pre class="programlisting">private Bitmap bitmap;
private int x, y;
private int speed = 0;</pre></div><p>As usual, use the <span class="emphasis"><em>Alt</em></span> | <span class="emphasis"><em>Enter</em></span> keyboard combination to import any missing classes. In the previous block of code, we see that we have declared an object of type <code class="literal">Bitmap</code> that we will use to hold the graphic which represents our ship.</p><p>We have also declared three <code class="literal">int</code> type variables; <code class="literal">x</code> and <code class="literal">y</code> to hold the spaceship's screen coordinates and another <code class="literal">int</code> type variable, <code class="literal">speed</code> to hold a value for how fast our spaceship is traveling.</p><p>Now, let's consider what our <code class="literal">PlayerShip</code> class needs to do. Again as a bare minimum it needs to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Prepare itself</li><li class="listitem" style="list-style-type: disc">Update itself</li><li class="listitem" style="list-style-type: disc">Share it's state with our view</li></ul></div><p>A constructor seems to be the ideal place to prepare itself. We can initialize its <code class="literal">x</code> and <code class="literal">y</code> coordinate variables and set a starting speed with the <code class="literal">speed</code> variable.</p><p>The other thing the constructor will need to do is to load the bitmap graphic, which represents its appearance. To load bitmaps, we require an Android <code class="literal">Context</code> object. This implies that the constructor that we write will need to receive a <code class="literal">Context</code> object from our view.</p><p>With all this in mind, here <a class="indexterm" id="id0075"/>is our <code class="literal">PlayerShip</code> constructor to implement point<a class="indexterm" id="id0076"/> one from our to-do list:</p><div class="informalexample"><pre class="programlisting">// Constructor
public PlayerShip(Context context) {
        x = 50;
        y = 50;
        speed = 1;
        bitmap = BitmapFactory.decodeResource 
        (context.getResources(), R.drawable.ship);

    }</pre></div><p>As usual, we need to import some new classes using the <span class="emphasis"><em>Alt</em></span> | <span class="emphasis"><em>Enter</em></span> combination. After importing all the new classes required by the line which initializes our bitmap object, we can see we still have an error; <code class="literal">Cannot resolve symbol ship</code>.</p><p>Let's dissect the line that loads the ship bitmap as we will be seeing this quite a lot throughout the book.</p><p>The <code class="literal">BitmapFactory</code> class is using its static method <code class="literal">decodeResource()</code> to attempt to load our graphic of the player ship. It requires two parameters. The first is the <code class="literal">getResources</code> method supplied by the <code class="literal">Context</code> object that was passed from the view.</p><p>The second parameter <code class="literal">R.drawable.ship</code> is requesting a graphic called <code class="literal">ship</code> from the (R)esource folder named <code class="literal">drawable</code>. All we have to do to resolve this error is to copy our graphic, named <code class="literal">ship.png</code>, into the <code class="literal">drawable</code> folder of our project.</p><p>Simply drag and drop/copy and paste the <code class="literal">ship.png</code> graphic contained in the <code class="literal">Chapter2/drawable</code> folder from the download bundle into the <code class="literal">res/drawable</code> folder in the Android Studio project explorer window. The following is a <code class="literal">ship.png</code> image:</p><div class="mediaobject"><img alt="The PlayerShip object" src="graphics/B04322_02_10.jpg"/></div><p>Number two on our list of things that <code class="literal">PlayerShip</code> needs to do is, to update itself. Let's implement a public <code class="literal">update</code> method that can be called from our <code class="literal">TDView</code> class. The method will simply increment the <a class="indexterm" id="id0077"/>ship's <span class="emphasis"><em>x</em></span> value by 1 each time it is called. Clearly, we need to get more advanced <a class="indexterm" id="id0078"/>than this. For now implement the method in the <code class="literal">PlayerShip</code> class like this:</p><div class="informalexample"><pre class="programlisting">public void update() {
  x++;
}</pre></div><p>Number three on the to-do list is to share its state with the view. We can do this by providing a bunch of getter methods like this:</p><div class="informalexample"><pre class="programlisting">//Getters
public Bitmap getBitmap() {
  return bitmap;
}

public int getSpeed() {
  return speed;
}

public int getX() {
  return x;
}

public int getY() {
  return y;
}</pre></div><p>Now your <code class="literal">TDView</code> class can be instantiated, and find out what it likes about any <code class="literal">PlayerShip</code> objects. However, only the <code class="literal">PlayerShip</code> class itself can decide how it should look, what properties it has, and how it behaves.</p><p>We can see how we will <a class="indexterm" id="id0079"/>draw our player's ship to the screen and <a class="indexterm" id="id0080"/>animate it as well.</p></div>
<div class="section" title="Drawing the scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec016"/>Drawing the scene</h1></div></div></div><p>As we will see, drawing <a class="indexterm" id="id0081"/>a bitmap is really trivial. But the coordinate system<a class="indexterm" id="id0082"/> that we use to draw our graphics onto needs a brief explanation.</p><div class="section" title="Plotting and drawing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec026"/>Plotting and drawing</h2></div></div></div><p>When we draw a <code class="literal">Bitmap</code> object to<a class="indexterm" id="id0083"/> the screen, we pass in the coordinates we want to draw the object at. The available coordinates of a given Android device depend on the resolution of its screen.</p><p>For example, the Samsung Galaxy S4 phone has a screen resolution of 1920 pixels (across) by 1080 pixels (down) when held in a landscape view.</p><p>The numbering system of these coordinates starts in the top-left hand corner at 0,0 and proceeds down and to the right until the bottom right corner is pixel 1919, 1079. The apparent 1 pixel disparity between 1920/ 1919 and 1080/ 1079 is because the numbering starts at 0.</p><p>Therefore, when we draw a bitmap or any other drawable to the screen, we must specify <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> coordinates.</p><p>Furthermore, a bitmap is, of course, comprised of many pixels. So which pixel of a given bitmap is drawn at the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> screen coordinate that we will be specifying?</p><p>The answer is the top-left pixel of the <code class="literal">Bitmap</code> object. Take a look at the next image, which should clarify the screen coordinates using the Samsung Galaxy S4 as an example.</p><div class="mediaobject"><img alt="Plotting and drawing" src="graphics/B04322_02_10b.jpg"/></div><p>For now, when drawing<a class="indexterm" id="id0084"/> just a single ship at an arbitrary location, this information is of little consequence. It will become more important in the next chapter, when we start constraining our graphics to the visible screen and respawning them when they disappear.</p><p>So let's just bare this in mind and get on with drawing our ship to the screen.</p></div><div class="section" title="Drawing PlayerShip"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec027"/>Drawing PlayerShip</h2></div></div></div><p>Now that we know all this, we <a class="indexterm" id="id0085"/>can add some code to our <code class="literal">TDView</code> class, so <a class="indexterm" id="id0086"/>we can see our <code class="literal">PlayerShip</code> class in action. First, we need a new <code class="literal">PlayerShip</code> object with class scope. The following code is the <code class="literal">TDView</code> class declaration:</p><div class="informalexample"><pre class="programlisting">//Game objects
private PlayerShip player;</pre></div><p>We also need a bunch of objects that we haven't seen yet to help us actually do some drawing. We need a canvas and some paint.</p><div class="section" title="The Canvas and Paint objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec013"/>The Canvas and Paint objects</h3></div></div></div><p>The aptly named <code class="literal">Canvas</code> class provides just what you will expect—a virtual canvas to draw our graphics upon.</p><p>We can make a virtual canvas<a class="indexterm" id="id0087"/> using the <code class="literal">Canvas</code> class and project it <a class="indexterm" id="id0088"/>onto our <code class="literal">SurfaceView</code> object which is the view of your <code class="literal">GameActivity</code> class. We can actually add <code class="literal">Bitmap</code> objects and even manipulate individual pixels on our <code class="literal">Canvas</code> object using methods from our <code class="literal">Paint</code> object. In addition, we also need an object of the <code class="literal">SurfaceHolder</code> class. This allows us to lock your <code class="literal">Canvas</code> object while we are manipulating it and unlock it when we are ready to draw the frame.</p><p>We will see in more detail how these classes work as we proceed. Type this code immediately following the previous line of code we typed:</p><div class="informalexample"><pre class="programlisting">// For drawing
private Paint paint;
private Canvas canvas;
private SurfaceHolder ourHolder;</pre></div><p>As usual, we need to use the <span class="emphasis"><em>Alt | Enter</em></span> keyboard combination to import some new classes for the two lines of code that follow. From this point on, we will save digital link and just assume that you know to do this each time you add a new class.</p><p>Next, we need to set up to prepare for drawing. The best place to do this is in the<code class="literal"> TDView()</code>, constructor. Type the following code to prepare our <code class="literal">Paint</code> and <code class="literal">SurfaceHolder</code> objects for action:</p><div class="informalexample"><pre class="programlisting">// Initialize our drawing objects
ourHolder = getHolder();
paint = new Paint();</pre></div><p>Immediately after the previous line of code, we can at last call <code class="literal">new()</code> to initialize our <code class="literal">PlayerShip</code> object:</p><div class="informalexample"><pre class="programlisting">// Initialize our player ship
player = new PlayerShip(context);</pre></div><p>Now, we can jump to our <code class="literal">TDView</code> class's <code class="literal">update</code> method and do this:</p><div class="informalexample"><pre class="programlisting">// Update the player
player.update();</pre></div><p>That's it. The <code class="literal">PlayerShip</code> class (part of the model) knows what to do, and we can add all kinds of artificial intelligence into our <code class="literal">PlayerShip</code> class. The <code class="literal">TDView</code> class (the controller) just says when it is time to update. You can easily imagine that all we need to do is create lots of different game objects with different properties and behaviors and call their <code class="literal">update</code> methods once per frame.</p><p>Now, jump to the <code class="literal">TDView</code> <a class="indexterm" id="id0089"/>class's <code class="literal">draw</code> method. Let's draw our <code class="literal">player</code> object by<a class="indexterm" id="id0090"/> performing the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check that our <code class="literal">SurfaceHolder</code> class is valid.</li><li class="listitem">Lock the <code class="literal">Canvas</code> object.</li><li class="listitem">Clear the screen with a call to <code class="literal">drawColor()</code>.</li><li class="listitem">Splash some virtual paint on it by calling <code class="literal">drawBitmap()</code> and passing in the <code class="literal">PlayerShip</code> bitmap and an <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> coordinate.</li><li class="listitem">Finally, unlock the <code class="literal">Canvas</code> object and draw the scene.</li></ol></div><p>To achieve these things, type this code in the <code class="literal">draw</code> method:</p><div class="informalexample"><pre class="programlisting">if (ourHolder.getSurface().isValid()) {

  //First we lock the area of memory we will be drawing to
  canvas = ourHolder.lockCanvas();

  // Rub out the last frame
  canvas.drawColor(Color.argb(255, 0, 0, 0));

  // Draw the player
  canvas.drawBitmap(
    player.getBitmap(), 
    player.getX(), 
    player.getY(), 
    paint);

  // Unlock and draw the scene
  ourHolder.unlockCanvasAndPost(canvas);
}</pre></div><p>At this point, we can actually run the game. If our eyesight is fast enough or our Android device slow enough, we will just about see our player spaceship fly across the screen with immense speed.</p><p>There is just one more thing to do before we deploy our game so far.</p></div></div><div class="section" title="Controlling the frame rate"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec028"/>Controlling the frame rate</h2></div></div></div><p>The reason we can barely see<a class="indexterm" id="id0091"/> anything is that even though we only move our ship at one pixel per frame along the <span class="emphasis"><em>x</em></span> axis (in the <code class="literal">PlayerShip</code> class's <code class="literal">update</code> method), our thread is calling the <code class="literal">run</code> method in an unrestricted manner. This is probably happening hundreds of times per second. What we need to do is control this rate.</p><p>Sixty frames per second (FPS) is a reasonable goal. This goal implies the need for timing. The Android system measures time in milliseconds (thousandths of a second). Therefore, we can add the following code to the <code class="literal">control</code> method:</p><div class="informalexample"><pre class="programlisting">try {
    gameThread.sleep(17);
    } catch (InterruptedException e) {

    }</pre></div><p>In the preceding code, we paused the thread for 17 milliseconds (<span class="emphasis"><em>1000(milliseconds)/60(FPS)</em></span>) by calling <code class="literal">gameThread.sleep</code> with <code class="literal">17</code> as the argument to the method. We wrap the code <a class="indexterm" id="id0092"/>within a <code class="literal">try</code>/<code class="literal">catch</code> block.</p></div></div>
<div class="section" title="Deploying the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec017"/>Deploying the game</h1></div></div></div><p>Now, we can run our <a class="indexterm" id="id0093"/>game to see our spaceship floating through space (starting at 50 pixels on the <span class="emphasis"><em>x</em></span> axis and 50 pixels on the <span class="emphasis"><em>y</em></span> axis).</p><p>Android Studio enables us to fairly quickly create emulators, on which we can test our games on a development PC. However, even the most simple of games will not run well on an emulator. When we start testing things like player input, the experience is so awful that it is best to avoid using emulators completely.</p><p>The solution is to carry out debugging on a real Android device. It is very easy to prepare for this.</p><div class="section" title="Debugging on an Android device"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec029"/>Debugging on an Android device</h2></div></div></div><p>The first thing to do is to <a class="indexterm" id="id0094"/>visit your device manufacturer's<a class="indexterm" id="id0095"/> website and obtain and install any drivers that are required for your device and operating system.</p><p>The next few steps will setup the Android device for debugging. Note that different manufacturers structure the menu options slightly differently than others. The following sequence is probably very close, if not exact to enable debugging on most devices.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Tap the <span class="strong"><strong>Settings</strong></span> menu option or the <span class="strong"><strong>Settings</strong></span> app.</li><li class="listitem">Tap <span class="strong"><strong>Developer</strong></span> options.</li><li class="listitem">Tap the checkbox for <span class="strong"><strong>USB Debugging</strong></span>.</li><li class="listitem">Connect your Android device to the USB port of your development system. The next image shows on the Android tab. At the bottom of the Android Studio UI, you can see that <span class="strong"><strong>Samsung GT-I9100 Android 4.1.2 (API 16)</strong></span> has been detected:<div class="mediaobject"><img alt="Debugging on an Android device" src="graphics/B04322_02_11.jpg"/></div></li><li class="listitem">Click on the <span class="strong"><strong>Play</strong></span> icon from the Android Studio toolbar:<div class="mediaobject"><img alt="Debugging on an Android device" src="graphics/B04322_02_12.jpg"/></div></li><li class="listitem">When prompted, click on <span class="strong"><strong>OK</strong></span> to run the game on your chosen device.</li></ol></div><p>The game will now run <a class="indexterm" id="id0096"/>on the device. Any output or <a class="indexterm" id="id0097"/>errors can be seen in the <span class="strong"><strong>logcat</strong></span> window, also on the <span class="strong"><strong>Android</strong></span> tab:</p><div class="mediaobject"><img alt="Debugging on an Android device" src="graphics/B04322_02_13.jpg"/></div><p>Watch with awe as our <a class="indexterm" id="id0098"/>player's spaceship moves slowly <a class="indexterm" id="id0099"/>from left to right.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec018"/>Summary</h1></div></div></div><p>In this chapter, we spent a lot of time setting up the structure, game loop, and thread. We also spent time handling the Android Activity lifecycle.</p><p>Now, we have all this in place, and we can easily start adding more game objects to make Tappy Defender quickly feel more like a real game in the next chapter.</p></div>
<div class="chapter" title="Chapter&#xA0;3.&#xA0;Tappy Defender &#x2013; Taking Flight"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 3. Tappy Defender – Taking Flight</h1></div></div></div><p>We are now ready to quickly add a lot of new objects and some features as well. By the end of this chapter, we will be really close to a playable game. We will detect the player touching the screen, so he can control the spaceship. We will add virtual boosters to our <code class="literal">SpaceShip</code> class to move the ship up and down and increase the speed.</p><p>We will then detect the resolution of the Android device and use it to do things like prevent the player boosting off the screen, and to detect when our enemies need to respawn.</p><p>We will create a new <code class="literal">EnemyShip</code> class, which will represent the suicidal enemies. We will also see how we can easily spawn and then control them without changing any of the logic from the control part of our code.</p><p>We will add a scrolling effect by adding a <code class="literal">SpaceDust</code> class and spawning dozens of them to make it look like the player is whizzing through space.</p><p>Finally, we will learn about, and implement, collision detection so we know when our player has been hit by an enemy, as well as look at a graphical trick to help us with debugging our collision detection code.</p><div class="section" title="Controlling the spaceship"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec019"/>Controlling the spaceship</h1></div></div></div><p>We have our player's <a class="indexterm" id="id00100"/>spaceship floating aimlessly on the screen starting 50 pixels from the left and 50 pixels from the top and drifting slowly to the right. Now, we can give the player the power to control the spaceship.</p><p>Remember the design for the controls is a one finger tap and hold to boost, release to quit boosting and decelerate.</p><div class="section" title="Detecting touches"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec030"/>Detecting touches</h2></div></div></div><p>The <code class="literal">SurfaceView</code> class that we<a class="indexterm" id="id00101"/> extended for our view is perfect for handling screen touches.</p><p>All we need to do is override the <code class="literal">onTouchEvent</code> method within our <code class="literal">TDView</code> class. Let's see the code in full, and then we can examine it more closely to make sure we understand what is going on. Enter this method in the <code class="literal">TDView</code> class and import the necessary classes in the usual way. I have highlighted the parts of the code that we will be customizing later:</p><div class="informalexample"><pre class="programlisting">// SurfaceView allows us to handle the onTouchEvent
@Override
public boolean onTouchEvent(MotionEvent motionEvent) {

    // There are many different events in MotionEvent
    // We care about just 2 - for now.
    switch (motionEvent.getAction() &amp; MotionEvent.ACTION_MASK) {
            
        // Has the player lifted their finger up?
        case MotionEvent.ACTION_UP:
<span class="strong"><strong>            // Do something here</strong></span>
            break;

        // Has the player touched the screen?
        case MotionEvent.ACTION_DOWN:
<span class="strong"><strong>           // Do something here</strong></span>
           break;
    }
   return true;
}</pre></div><p>This is how the <code class="literal">onTouchEvent</code> method works so far. The player touches the screen; this can be any kind of contact at all. It could be a swipe, a pinch, multiple fingers, and so on. A detailed message is sent to the <code class="literal">onTouchEvent</code> method.</p><p>The details of the event are<a class="indexterm" id="id00102"/> contained in the <code class="literal">MotionEvent</code> class parameter, as we can see in our code. The <code class="literal">MotionEvent</code> class holds lots of data. It knows how many fingers were placed on the screen, the coordinates of each, and if any gestures were made as well.</p><p>As we are implementing a simple tap and hold to boost, release to stop boosting control scheme; we can simply switch using the <code class="literal">motionEvent.getAction() &amp; MotionEvent.ACTION_MASK</code> condition and cater for just two of many possible different cases.</p><p>The case <code class="literal">MotionEvent.ACTION_UP:</code> will, as the name suggests, tell us when the player removes a finger from the screen. Then, perhaps unsurprisingly, case <code class="literal">MotionEvent.ACTION_DOWN:</code> tells us if the player places a finger on the screen.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0008"/>Note</h3><p>What we can find out through the <code class="literal">MotionEvent</code> class<a class="indexterm" id="id00103"/> is quite vast. Why not take a look at the full scope of its potential here: <a class="ulink" href="http://developer.android.com/reference/android/view/MotionEvent.html">http://developer.android.com/reference/android/view/MotionEvent.html</a>. We will also explore this class further in the next project that we start to build in <a class="link" href="ch14.html" title="Chapter 5. Platformer – Upgrading the Game Engine">Chapter 5</a>, <span class="emphasis"><em>Platformer – Upgrading the Game Engine</em></span>.</p></div></div></div><div class="section" title="Adding boosters to the spaceship"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec031"/>Adding boosters to the spaceship</h2></div></div></div><p>Now, all we need to do is <a class="indexterm" id="id00104"/>think about how we will use these events to control the spaceship. First of all, the spaceship needs to know if it is boosting or not boosting. This suggests a Boolean member variable. Add this code just after the class declaration in the <code class="literal">PlayerShip</code> class:</p><div class="informalexample"><pre class="programlisting">private boolean boosting;</pre></div><p>We then need to initialize it when a <code class="literal">PlayerShip</code> object is created. So add this to the <code class="literal">PlayerShip</code> constructor:</p><div class="informalexample"><pre class="programlisting">boosting = false;</pre></div><p>Now, we need to let the <code class="literal">onTouchEvent</code> method toggle <code class="literal">boosting</code> between true and false, boosting and not boosting. Add these methods to the <code class="literal">PlayerShip</code> class:</p><div class="informalexample"><pre class="programlisting">public void setBoosting() {
  boosting = true;
}

public void stopBoosting() {
  boosting = false;
}</pre></div><p>Now, we can call these public methods from our <code class="literal">onTouchEvent</code> method to control the state of whether the spaceship is boosting or not. Add this new code in the <code class="literal">onTouchEvent</code> method:</p><div class="informalexample"><pre class="programlisting">// Has the player lifted there finger up?
case MotionEvent.ACTION_UP:
<span class="strong"><strong>  player.stopBoosting();</strong></span>
  break;

// Has the player touched the screen?
case MotionEvent.ACTION_DOWN:
<span class="strong"><strong>  player.setBoosting();</strong></span>
  break;</pre></div><p>Now, our view is talking to our model; all we need to do is make the boosting variable do something depending on which state it is in. The logical place for this code will be the <code class="literal">PlayerShip</code> class's <code class="literal">update</code> method.</p><p>We will change the <code class="literal">speed</code> variable<a class="indexterm" id="id00105"/> of our spaceship based on whether the ship is currently boosting. At first this seems simple, but there are a few minor issues with just increasing the speed based on whether the ship is boosting:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One problem is that the <code class="literal">update</code> method is called 60 times every second. So, it wouldn't take much boosting to have the ship flying at ridiculous speeds. We need to constrain the ship's speed.</li><li class="listitem" style="list-style-type: disc">Another problem is that our spaceship will rise up the screen when boosting, and there is nothing to stop it whizzing straight off the top of the screen, never to be seen again. We need to constrain the ship's <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates within the screen.</li><li class="listitem" style="list-style-type: disc">When the ship is not boosting and the speed steadily returns to zero, what will bring the ship back down again? We will need a simple gravity physics simulation.</li></ul></div><p>To solve these three problems, we can add code to our <code class="literal">PlayerShip</code> class. However, before we do this, a quick word about gameplay balance. The code which we will see very soon uses different integer values, for example, we initialize <code class="literal">GRAVITY</code> to <code class="literal">-12</code> and <code class="literal">MAX_SPEED</code> to <code class="literal">20</code>. These numbers have no bearing in reality!</p><p>They are simply the arbitrary numbers that make the gameplay balanced. Feel free to play with all these arbitrary figures to make the game harder, easier, or even impossible. At the end of <a class="link" href="ch13.html" title="Chapter 4. Tappy Defender – Going Home">Chapter 4</a>, <span class="emphasis"><em>Tappy Defender – Going Home</em></span>, we will look more closely at game iteration and look again at difficulty and balance.</p><p>With three of our previously stated problems in mind, add the following member variables just after the class declaration in the <code class="literal">PlayerShip</code> class:</p><div class="informalexample"><pre class="programlisting">private final int GRAVITY = -12;

// Stop ship leaving the screen
private int maxY;
private int minY;

//Limit the bounds of the ship's speed
private final int MIN_SPEED = 1;
private final int MAX_SPEED = 20;</pre></div><p>Now, we made a start to solve our three problems, we can add code to our <code class="literal">PlayerShip</code> class's <code class="literal">update</code> method. We will delete the one line of code, we put in there in the previous chapter. That was just there to take a quick look at our ship in action. Enter the new code of our <code class="literal">PlayerShip</code> class's <code class="literal">update</code> method. We will take a closer look afterward:</p><div class="informalexample"><pre class="programlisting">public void update() {
  
  // Are we boosting?
  if (boosting) {
    // Speed up
    speed += 2;
  } else {
    // Slow down
    speed -= 5;
  }

  // Constrain top speed
  if (speed &gt; MAX_SPEED) {
    speed = MAX_SPEED;
}

  // Never stop completely
  if (speed &lt; MIN_SPEED) {
    speed = MIN_SPEED;
}

  // move the ship up or down
  y -= speed + GRAVITY;

  // But don't let ship stray off screen
  if (y &lt; minY) {
    y = minY;
  }

  if (y &gt; maxY) {
    y = maxY;
  }

}</pre></div><p>In order from the top of the <a class="indexterm" id="id00106"/>previous block of code, we are increasing and decreasing the speed variable by apparently arbitrary amounts, each frame of the game, based on if the ship is boosting or not.</p><p>We then constrain the speed of the ship to a maximum of 20 and a minimum of 1, as specified by the variables we added earlier. With the line <code class="literal">y -= speed + GRAVITY</code>, we move the graphic on screen either up or down based on speed and gravity. The apparently arbitrary values for <code class="literal">GRAVITY</code> and <code class="literal">MAX_SPEED</code> work nicely to allow the player to awkwardly and precariously bounce along through space.</p><p>Finally, we stop the ship <a class="indexterm" id="id00107"/>from ever disappearing off the screen by making sure the ship graphic is never drawn beyond <code class="literal">maxY</code> and <code class="literal">minY</code>. You have probably noticed that, as of yet, we haven't initialized <code class="literal">maxY</code> and <code class="literal">minY</code>. Furthermore, what will we initialize them to anyway as many Android devices have vastly different screen resolutions?</p><p>What we need to do is discover the resolution of the Android device at run time and use the information to initialize <code class="literal">MaxY</code> and <code class="literal">minY</code>.</p></div><div class="section" title="Detecting the screen resolution"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec032"/>Detecting the screen resolution</h2></div></div></div><p>We know that we need the<a class="indexterm" id="id00108"/> maximum <span class="emphasis"><em>y</em></span> coordinate of the player's screen. Later in the project when we start adding backgrounds and enemy ships, we will realize that we also need the maximum <span class="emphasis"><em>x</em></span> coordinate as well. With this in mind, let's see how we can get this information and make it available to the <code class="literal">PlayerShip</code> class.</p><p>The most expedient time to detect the screen resolution is as the app is starting, and before our view and the model have been instantiated. This implies that our <code class="literal">GameActivity</code> class is a good place to do it. We will now add code to the <code class="literal">onCreate</code> method of the <code class="literal">GameActivity</code> class. Add this new code to the <code class="literal">onCreate</code> class, before the call to <code class="literal">new...</code> that creates our <code class="literal">TDView</code> object:</p><div class="informalexample"><pre class="programlisting">// Get a Display object to access screen details
Display display = getWindowManager().getDefaultDisplay();
// Load the resolution into a Point object
Point size = new Point();
display.getSize(size);</pre></div><p>The previous code declares and initializes an object of the <code class="literal">Display</code> type using <code class="literal">getWindowManager().getDefaultDisplay();</code>. Then we create a new object of type <code class="literal">Point</code>. The <code class="literal">Point</code> object can hold two coordinates and we then pass it as an argument into the <code class="literal">getSize</code> method of our new <code class="literal">Display</code> object.</p><p>We now have the resolution of the Android device our game is running on, neatly stored in <code class="literal">size</code>. Now pass this on to the parts of our code which require it. First, we will change the arguments we pass in the call to <code class="literal">new</code>, which initializes our <code class="literal">TDView</code> object. Change the call to <code class="literal">new</code> as shown next to pass in the screen resolution to the <code class="literal">TDView</code> constructor:</p><div class="informalexample"><pre class="programlisting">// Create an instance of our Tappy Defender View
// Also passing in this.
// Also passing in the screen resolution to the constructor
<span class="strong"><strong>gameView = new TDView(this, size.x, size.y);</strong></span>
</pre></div><p>Then, of course, we need to update the <code class="literal">TDView</code> constructor itself. In the <code class="literal">TDView.java</code> file, amend the <code class="literal">TDView</code> constructor's signature so that the declaration now looks like this:</p><div class="informalexample"><pre class="programlisting">TDView(Context context, int x, int y) {</pre></div><p>Now, still in the constructor, change the way we initialize the player of our <code class="literal">PlayerShip</code> object:</p><div class="informalexample"><pre class="programlisting">player = new PlayerShip(context, x, y);</pre></div><p>Of course, we must now amend the constructor declaration within the <code class="literal">PlayerShip</code> class itself, to this:</p><div class="informalexample"><pre class="programlisting">public PlayerShip(Context context, int screenX, int screenY) {</pre></div><p>In addition, we can now <a class="indexterm" id="id00109"/>initialize our <code class="literal">maxY</code> and <code class="literal">minY</code> variables within the <code class="literal">PlayerShip</code> constructor. Before we see the code, we need to consider exactly how this will work.</p><p>The coordinates of the bitmap that holds our spaceship graphic is drawn with the top-left corner at the <span class="emphasis"><em>x = 0</em></span> and <span class="emphasis"><em>y = 0</em></span> coordinates passed in to <code class="literal">drawBitmap()</code> in the <code class="literal">TDView</code> class's <code class="literal">draw</code> method. This means that there are pixels off to the right and after the coordinates at which we begin to draw the ship. Take a look at this next image to visualize this:</p><div class="mediaobject"><img alt="Detecting the screen resolution" src="graphics/B043422_03_01.jpg"/></div><p>Therefore, we must set our <code class="literal">minY</code> and <code class="literal">maxY</code> values with this in mind. As the image illustrates, the top pixel of the bitmap is indeed drawn exactly at the ships <span class="emphasis"><em>y</em></span>. We can then be confident that <code class="literal">minY</code> should be zero.</p><p>The bottom of the ship, however, is drawn at <span class="emphasis"><em>y + the height of the bitmap</em></span>.</p><p>We can now add two lines of code to our constructor to initialize these variables:</p><div class="informalexample"><pre class="programlisting">maxY = screenY - bitmap.getHeight();
minY = 0;</pre></div><p>You can now run the <a class="indexterm" id="id00110"/>game and test out your boosters!</p></div></div></div>
<div class="section" title="Building the enemies"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec020"/>Building the enemies</h1></div></div></div><p>Now that we have the<a class="indexterm" id="id00111"/> tap controls implemented, it is time to add some enemies that the player can boost to avoid.</p><p>This is going to be much easier than when we added our player's spaceship because most of what we need is in place already. All we have to do is code a class to represent our enemy, instantiate as many enemy objects as we need, call their <code class="literal">update</code> methods, and then draw them.</p><p>As we will see, the <code class="literal">update</code> method for our enemy will be quite different to that of <code class="literal">PlayerShip</code>. It will need to handle things like simple AI to fly toward the player. It will also need to handle respawning when it leaves the screen.</p><div class="section" title="Designing the enemy"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec033"/>Designing the enemy</h2></div></div></div><p>To begin with, create<a class="indexterm" id="id00112"/> a new Java class and call it <code class="literal">EnemyShip</code>. Add these member variables inside the class so your new class will look like this:</p><div class="informalexample"><pre class="programlisting">public class EnemyShip{
    private Bitmap bitmap;
    private int x, y;
    private int speed = 1;

    // Detect enemies leaving the screen
    private int maxX;
    private int minX;

    // Spawn enemies within screen bounds
    private int maxY;
    private int minY;
}</pre></div><p>Now, add some getter and setter methods so that the <code class="literal">draw</code> method can access what it needs to draw, and where it needs to draw it. There is nothing new or unusual here:</p><div class="informalexample"><pre class="programlisting">//Getters and Setters
public Bitmap getBitmap(){
  return bitmap;
}

public int getX() {
  return x;
}

public int getY() {
  return y;
}</pre></div></div><div class="section" title="Spawning the enemy"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec034"/>Spawning the enemy</h2></div></div></div><p>Let's implement <a class="indexterm" id="id00113"/>the <code class="literal">EnemyShip</code> constructor in full. Enter the code now, and we will then take a closer look:</p><div class="informalexample"><pre class="programlisting">// Constructor
public EnemyShip(Context context, int screenX, int screenY){
    bitmap = BitmapFactory.decodeResource 
    (context.getResources(), R.drawable.enemy);

  maxX = screenX;
  maxY = screenY;
  minX = 0;
  minY = 0;

  Random generator = new Random();
  speed = generator.nextInt(6)+10;

  x = screenX;
  y = generator.nextInt(maxY) - bitmap.getHeight();
}</pre></div><p>The constructors' signature is exactly that of the <code class="literal">PlayerShip</code> class. A <code class="literal">Context </code>class for manipulating your <code class="literal">Bitmap</code> object and <code class="literal">screenX</code> and <code class="literal">screenY</code> that hold the resolution of the screen.</p><p>Just as we did with the <code class="literal">PlayerShip</code> class, we load up an image into <code class="literal">Bitmap</code>. Of course, we once again need to add an image file named <code class="literal">enemy.png</code> to the <code class="literal">drawable</code> folder of our project. There is a neat enemy graphic in the <code class="literal">Chapter3/drawable</code> folder of the download bundle or you can design your own. Any size between roughly 32 x 32 and 256 x 256 will suffice for the purposes of this game. Also, like those supplied, your graphics do not need to be square. We will see that our game engine is imperfect when it comes to how it looks on different screen sizes, and we will address this in the next project:</p><div class="mediaobject"><img alt="Spawning the enemy" src="graphics/B043422_03_02.jpg"/></div><p>Next, we<a class="indexterm" id="id00114"/> initialize <code class="literal">maxX</code>, <code class="literal">maxY</code>, <code class="literal">minX</code>, and <code class="literal">minY</code>. Although the enemies only move horizontally, we need the <code class="literal">maxY</code> and <code class="literal">minY</code> coordinates to make sure that we spawn them at a sensible height. The <code class="literal">maxX</code> coordinate will enable us to spawn them just off-screen horizontally.</p><p>We create a new object of type <code class="literal">Random</code> and generate a random number between the values of 10 and 15. These are the maximum and minimum speeds our enemies can travel at. These values are fairly arbitrary, and we might adjust them when we do some play-testing in <a class="link" href="ch13.html" title="Chapter 4. Tappy Defender – Going Home">Chapter 4</a>, <span class="emphasis"><em>Tappy Defender – Going Home</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0009"/>Note</h3><p>If you are wondering how <code class="literal">generator.nextInt(6)+10;</code> comes up with a number between 10 and 15, it is because the <code class="literal">6</code> argument causes <code class="literal">nextInt()</code> to return a number between 0 and 5.</p></div></div><p>We then set the enemy ship's <span class="emphasis"><em>x</em></span> coordinate to screen, which spawns it on the far right of the screen. Actually, this spawns it off screen. However, that is fine because it will then emerge in to the player's view rather than just appearing all at once.</p><p>We now generate another random number based on <code class="literal">maxY</code>—the height of the enemy ship bitmap <code class="literal">(bitmap.getHeight())</code>—to create a random but sensible <span class="emphasis"><em>y</em></span> coordinate for our enemy ship to spawn at.</p><p>What we need to do now is to give our enemies life by coding their update method.</p></div><div class="section" title="Making the enemy think"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec035"/>Making the enemy think</h2></div></div></div><p>Now, we can handle the <code class="literal">EnemyShip</code> class<a class="indexterm" id="id00115"/>'s <code class="literal">update</code> method. For now, we just need to handle two things. First, fly the enemy toward the player's end of the screen. We need to take account of the enemy's speed and the player's speed to simulate this accurately. The reason we need to do this is because when the player boosts, he expects his speed to increase, and objects to rush toward him more quickly. However, the spaceship graphic is horizontally static.</p><p>We can increase the rate of travel of an enemy in proportion to both the enemy's static and randomly generated speed at the same time as the player's dynamically set speed (through boosting). This will give the player a sense of speeding up even though the ship graphic never moves forward.</p><p>The other issue is that the enemy ship will eventually fly off the screen, on the left-hand side. We need to detect when this happens and respawn it on the right-hand side with a new random <span class="emphasis"><em>y</em></span> coordinate and a new random speed. This is just like we did in the constructor.</p><p>Finally before we get to the actual code, let's consider something. If the enemy is going to take note of and use the player's speed, it will need to be able to get it. Note that in the next block of code, the <code class="literal">EnemyShip</code> class's <code class="literal">update</code> method declaration has a parameter to receive the player's speed.</p><p>We will see how this is passed in when we add code to the <code class="literal">TDView</code> class's <code class="literal">update</code> method soon. Enter the following code for the <code class="literal">EnemyShip</code> class's <code class="literal">update</code> method to implement what we have just discussed:</p><div class="informalexample"><pre class="programlisting">public void update(int playerSpeed){
        
  // Move to the left
  x -= playerSpeed;
  x -= speed;

  //respawn when off screen
  if(x &lt; minX-bitmap.getWidth()){
    Random generator = new Random();
    speed = generator.nextInt(10)+10;
    x = maxX;
    y = generator.nextInt(maxY) - bitmap.getHeight();
  }
}</pre></div><p>As you can see, we first decreased the enemy's <span class="emphasis"><em>x</em></span> coordinate by the player's speed then by the enemy's speed. As the player boosts, the enemy will fly at the player faster. However, if the player is not boosting then the enemy will attack at the speed that was previously and randomly generated.</p><div class="informalexample"><pre class="programlisting">// Move to the left
x -= playerSpeed;
x -= speed;</pre></div><p>After this, we simply detected if the right-hand edge of the enemy bitmap has disappeared from the left-hand side of the screen. This is done by detecting if the <code class="literal">EnemyShip</code> class's <span class="emphasis"><em>x</em></span> coordinate is the width of the bitmap off screen.</p><div class="informalexample"><pre class="programlisting">if(x &lt; minX-bitmap.getWidth()){</pre></div><p>Then we respawn the very same object to come at the player again. This appears to the player as if it is an entirely new enemy.</p><p>The last three things we <a class="indexterm" id="id00116"/>must do are create a new object from <code class="literal">EnemyShip</code> by declaring and then initializing an object. Actually, let's make three.</p><p>Here, were we declared our player's ship in our <code class="literal">TDView.java</code> file, declare three enemy ships like this:</p><div class="informalexample"><pre class="programlisting">// Game objects
private PlayerShip player;
<span class="strong"><strong>public EnemyShip enemy1;</strong></span>
</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>public EnemyShip enemy2;</strong></span>
<span class="strong"><strong>public EnemyShip enemy3;</strong></span>
</pre></div><p>Now, in the constructor of our <code class="literal">TDView</code> class, initialize our three new enemies:</p><div class="informalexample"><pre class="programlisting">// Initialize our player ship
player = new PlayerShip(context, x, y);
<span class="strong"><strong>enemy1 = new EnemyShip(context, x, y);</strong></span>
<span class="strong"><strong>enemy2 = new EnemyShip(context, x, y);</strong></span>
<span class="strong"><strong>enemy3 = new EnemyShip(context, x, y);</strong></span>
</pre></div><p>In the <code class="literal">update</code> method of our <code class="literal">TDView</code> class, we call each of the new object's <code class="literal">update</code> methods in turn. Here, we also see how we pass in the player's speed to each of our enemies so they can use it in their <code class="literal">update</code> methods to adjust speed accordingly.</p><div class="informalexample"><pre class="programlisting">// Update the player
player.update();
// Update the enemies
enemy1.update(player.getSpeed());
enemy2.update(player.getSpeed());
enemy3.update(player.getSpeed());</pre></div><p>Finally, in the <code class="literal">TDView</code> class's <code class="literal">draw</code> method, we draw our new enemies to the screen.</p><div class="informalexample"><pre class="programlisting">// Draw the player
canvas.drawBitmap
    (player.getBitmap(), player.getX(), player.getY(), paint);

<span class="strong"><strong>canvas.drawBitmap</strong></span>
<span class="strong"><strong>    (enemy1.getBitmap(), </strong></span>
<span class="strong"><strong>    enemy1.getX(), </strong></span>
<span class="strong"><strong>    enemy1.getY(), paint);</strong></span>

<span class="strong"><strong>canvas.drawBitmap</strong></span>
<span class="strong"><strong>    (enemy2.getBitmap(), </strong></span>
<span class="strong"><strong>    enemy2.getX(), </strong></span>
<span class="strong"><strong>    enemy2.getY(), paint);</strong></span>

<span class="strong"><strong>canvas.drawBitmap</strong></span>
<span class="strong"><strong>    (enemy3.getBitmap(), </strong></span>
<span class="strong"><strong>    enemy3.getX(), </strong></span>
<span class="strong"><strong>    enemy3.getY(), paint);</strong></span>
</pre></div><p>You can run the game and give this a try now.</p><p>The first and most obvious <a class="indexterm" id="id00117"/>problem is that the player and the enemies fly right through each other. We will solve this problem later in this chapter, in the <span class="emphasis"><em>Things that go bump – collision detection</em></span> section. But right now, we can make our player's sense of immersion better by drawing a star/space dust field as a background.</p></div></div>
<div class="section" title="The thrill of flight &#x2013; scrolling the background"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec021"/>The thrill of flight – scrolling the background</h1></div></div></div><p>Implementing our <a class="indexterm" id="id00118"/>space dust is going to be really quick and easy. All we will do is create a <code class="literal">SpaceDust</code> class with very similar properties to our other game objects. Spawn them into the game at a random location, move them toward the player at a random speed, and respawn them on the far right of the screen, again with a random speed and <span class="emphasis"><em>y</em></span> coordinate.</p><p>Then in our <code class="literal">TDView</code> class, we can declare a whole array of these objects, update, and draw them each frame.</p><p>Create a new class and call it <code class="literal">SpaceDust</code>. Now enter this code:</p><div class="informalexample"><pre class="programlisting">public class SpaceDust {

    private int x, y;
    private int speed;

    // Detect dust leaving the screen
    private int maxX;
    private int maxY;
    private int minX;
    private int minY;

    // Constructor
    public SpaceDust(int screenX, int screenY){

        maxX = screenX;
        maxY = screenY;
        minX = 0;
        minY = 0;

        // Set a speed between  0 and 9
        Random generator = new Random();
        speed = generator.nextInt(10);

        //  Set the starting coordinates
        x = generator.nextInt(maxX);
        y = generator.nextInt(maxY);
    }

    public void update(int playerSpeed){
        // Speed up when the player does
        x -= playerSpeed;
        x -= speed;

        //respawn space dust
        if(x &lt; 0){
            x = maxX;
            Random generator = new Random();
            y = generator.nextInt(maxY);
            speed = generator.nextInt(15);
        }
    }

    // Getters and Setters
    public int getX() {

        return x;
    }

    public int getY() {

        return y;
    }
}</pre></div><p>Here is what is <a class="indexterm" id="id00119"/>happening in the <code class="literal">SpaceDust</code> class. At the top of the previous block of code, we declare our usual speed and maximum and minimum variables. They will allow us to detect when the <code class="literal">SpaceDust</code> object leaves the left of the screen and needs respawning on the right, and provide sensible bounds for the height at which we respawn the object.</p><p>Then inside the <code class="literal">SpaceDust</code> constructor, we initialize the <code class="literal">speed</code>, <code class="literal">x</code>, and <code class="literal">y</code> variables with random values, but within the bounds set by the maximum and minimum variables we just initialized.</p><p>Then we implement the <code class="literal">SpaceDust</code> class's <code class="literal">update</code> method, which moves the object to the left based on the speed of the object and the player, then checks if the object has flown of the left-hand edge of the screen and respawns it with random but appropriate values if it has.</p><p>At the bottom, we provide two getter methods so that our <code class="literal">draw</code> method knows where to draw each speck of dust.</p><p>Now, we can create an <code class="literal">ArrayList</code> object to hold all our <code class="literal">SpaceDust</code> objects. Declare it just under the declaration of the other game objects near the top of the <code class="literal">TDView</code> class:</p><div class="informalexample"><pre class="programlisting">// Make some random space dust
public ArrayList&lt;SpaceDust&gt; dustList = new
  ArrayList&lt;SpaceDust&gt;();</pre></div><p>In the <code class="literal">TDView</code> constructor, we can initialize a whole bunch of the <code class="literal">SpaceDust</code> objects using a <code class="literal">for</code> loop and then stash them into the <code class="literal">ArrayList</code> object:</p><div class="informalexample"><pre class="programlisting">int numSpecs = 40;

for (int i = 0; i &lt; numSpecs; i++) {
  // Where will the dust spawn?
  SpaceDust spec = new SpaceDust(x, y);
  dustList.add(spec);
}</pre></div><p>We create forty specks of dust in total. Each time through the loop, we create a new speck of dust and the <code class="literal">SpaceDust</code> constructor assigns it a random location and a random speed. We then put the <code class="literal">SpaceDust</code> object into our <code class="literal">ArrayList</code> object with <code class="literal">dustList.add(spec);</code>
</p><p>Next, we jump to our <code class="literal">TDView</code> class's <code class="literal">update</code> method and use an enhanced <code class="literal">for</code> loop to call <code class="literal">update()</code> on each of our <code class="literal">SpaceDust</code> objects:</p><div class="informalexample"><pre class="programlisting">for (SpaceDust sd : dustList) {
  sd.update(player.getSpeed());
}</pre></div><p>Remember that we <a class="indexterm" id="id00120"/>passed in the player speed so that the dust increases and decreases its speed relative to the player's speed.</p><p>Now to draw all our space dust, we loop through our <code class="literal">ArrayList</code> object and draw a speck at a time. Of course, we add the code to our <code class="literal">TDView</code> class's <code class="literal">draw</code> method, but we must make sure to draw the space dust first so it appears behind the other game objects. In addition, we have an extra line to switch pixel color to white before using the <code class="literal">drawPoint</code> method of our <code class="literal">Canvas</code> object to plot a single pixel for each <code class="literal">SpaceDust</code> object.</p><p>In the <code class="literal">draw</code> method of the <code class="literal">TDView</code> class, add this code to draw our dust:</p><div class="informalexample"><pre class="programlisting">// White specs of dust
paint.setColor(Color.argb(255, 255, 255, 255));

//Draw the dust from our arrayList
for (SpaceDust sd : dustList) {
      canvas.drawPoint(sd.getX(), sd.getY(), paint);

    // Draw the player
    // ...
}</pre></div><p>The only new thing here is the <code class="literal">canvas.drawpoint...</code> line of code. Apart from drawing bitmaps to the screen, the <code class="literal">Canvas</code> class allows us to draw primitives, like points and lines, as well as things like text and shapes. We will use these features when drawing a HUD for our game in <a class="link" href="ch13.html" title="Chapter 4. Tappy Defender – Going Home">Chapter 4</a>, <span class="emphasis"><em>Tappy Defender – Going Home</em></span>.</p><p>Why not run the app and check out how much neat stuff we have implemented? In this screenshot, I have temporarily increased the number of the <code class="literal">SpaceDust</code> objects to <code class="literal">200</code>, just for fun. You can also see that we have enemies drawn, attacking at a random <span class="emphasis"><em>y</em></span> coordinate with random speed:</p><div class="mediaobject"><img alt="The thrill of flight – scrolling the background" src="graphics/B043422_03_03.jpg"/></div></div>
<div class="section" title="Things that go bump &#x2013; collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec022"/>Things that go bump – collision detection</h1></div></div></div><p>Collision detection<a class="indexterm" id="id00121"/> is quite a broad subject. Throughout the three projects in this book, we will use a whole range of different ways to detect when things collide.</p><p>So, here is a quick look at our options for collision detection, and in which circumstances different methods may be appropriate.</p><p>Essentially, we just need to know when certain objects from our game touch other objects. We can then respond to that event by exploding, reducing shields, playing a sound, or whatever is appropriate. We need a broad understanding of our different options so we can make the right decisions in any particular game.</p><div class="section" title="Collision detection options"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec036"/>Collision detection options</h2></div></div></div><p>First of all, here are a few of the <a class="indexterm" id="id00122"/>different mathematical calculations we can utilize and when they may be useful.</p><div class="section" title="Rectangle intersection"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec014"/>Rectangle intersection</h3></div></div></div><p>This type of collision<a class="indexterm" id="id00123"/> detection is really<a class="indexterm" id="id00124"/> straightforward. We draw an imaginary rectangle; we can call it a hitbox or bounding rectangle, around the objects we want to test for collision. Then, test to see if they intersect. If they do, we have a collision:</p><div class="mediaobject"><img alt="Rectangle intersection" src="graphics/B043422_03_04.jpg"/></div><p>Where the hitboxes intersect, we have a collision. As we can see from the previous image, this is far from perfect. However, in some situations, it is sufficient. To implement this method, all we need to do is test for the intersection using the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates of both objects.</p><p>Don't use the following code. It is for demonstration purposes only.</p><div class="informalexample"><pre class="programlisting">if(ship.getHitbox().right &gt; enemy.getHitbox().left  
    &amp;&amp; ship.getHitbox().left &lt; enemy.getHitbox().right ){
    // Ship is intersecting enemy on x axis
    //But they could be at different heights

    if(ship.getHitbox().top &lt; enemy.getHitbox().bottom  
        &amp;&amp; ship.getHitbox().bottom &gt; enemy.getHitbox().top ){
        // Ship is intersecting enemy on y axis as well
        // Crash
    }
}</pre></div><p>The preceding code <a class="indexterm" id="id00125"/>assumes we have a <code class="literal">getHitbox</code> method that returns the left and right <span class="emphasis"><em>x</em></span> coordinates as well as the top and bottom <span class="emphasis"><em>y</em></span> coordinates of the given object. In the aforementioned code, we first check to see if the <span class="emphasis"><em>x</em></span> axes overlap. If they don't, then there is no point going any further. If they do, then check the <span class="emphasis"><em>y</em></span> axes. If they don't, it could have been an enemy whizzing by above or below. If they overlap on the <span class="emphasis"><em>y</em></span> axis as well, then we have a collision.</p><p>Note that we can <a class="indexterm" id="id00126"/>check the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axis in either order as long as we check them both.</p></div><div class="section" title="Radius overlapping"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec015"/>Radius overlapping</h3></div></div></div><p>This method is also <a class="indexterm" id="id00127"/>checking to<a class="indexterm" id="id00128"/> see if two hitboxes intersect with each other, but as the title suggests, it does so using circles instead. There are obvious advantages and disadvantages. Mainly that this works well with shapes more circular in nature and less well with elongated shapes.</p><div class="mediaobject"><img alt="Radius overlapping" src="graphics/B043422_03_05.jpg"/></div><p>From the previous image, it is easy to see how the radius overlapping method is inaccurate for these particular objects and not hard to imagine how for a circular object like a ball it would be perfect.</p><p>Here is how we can implement this method.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0010"/>Note</h3><p>The following code is for demonstration purposes only.</p></div></div><div class="informalexample"><pre class="programlisting">// Get the distance of the two objects from 
// the edges of the circles on the x axis
distanceX = (ship.getHitBox.centerX + ship.getHitBox.radius) - 
  (enemy.getHitBox.centerX + enemy.getHitBox.radius;

// Get the distance of the two objects from 
// the edges of the circles on the y axis
distanceY = (ship.getHitBox.centerY + ship.getHitBox.radius) -  
  (enemy.getHitBox.centerY + enemy.getHitBox.radius;

// Calculate the distance between the center of each circle
double distance = Math.sqrt
    (distanceX * distanceX + distanceY * distanceY);

// Finally see if the two circles overlap
if (distance &lt; ship.getHitBox.radius + enemy.getHitBox.radius) {
    // bump
}</pre></div><p>The code again makes<a class="indexterm" id="id00129"/> some assumptions. Like we have a <code class="literal">getHitBox</code> method that can return the radius as well as the center <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates. Furthermore, because <a class="indexterm" id="id00130"/>the static <code class="literal">Math.sqrt</code> method takes and returns a variable of type <code class="literal">double</code>, we will need to start working with different types in our <code class="literal">SpaceShip</code> and <code class="literal">EnemyShip</code> classes.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0011"/>Note</h3><p>If the way we initialize distance: <code class="literal">Math.sqrt(distanceX * distanceX + distanceY * distanceY);</code> looks a little confusing, it is simply using Pythagoras' theorem to get the length of the hypotenuse of a triangle which is equal in length to a straight line drawn between the centers of the two circles. In the last line of our solution, we test if <code class="literal">distance &lt; ship.getHitBox.radius + enemy.getHitBox.radius</code>, then we can be certain that we must have a collision. That is because if the center points of two circles are closer than the combined length of their radii, they must be overlapping.</p></div></div></div><div class="section" title="The crossing number algorithm"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec016"/>The crossing number algorithm</h3></div></div></div><p>This method is mathematically<a class="indexterm" id="id00131"/> more complicated. However, as <a class="indexterm" id="id00132"/>we will see in our third and final project, it is perfect for detecting when a point intersects a convex polygon:</p><div class="mediaobject"><img alt="The crossing number algorithm" src="graphics/B043422_03_06.jpg"/></div><p>This is perfect for an Asteroids clone, and we will explore this method more as well as see it in action in our final project.</p></div></div><div class="section" title="Optimizations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec037"/>Optimizations</h2></div></div></div><p>As we have seen, the different collision detection methods can have at least two problems depending on which method you use in which situation. The problems are lack of accuracy and drain on CPU cycles.</p><div class="section" title="Multiple hitboxes"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec017"/>Multiple hitboxes</h3></div></div></div><p>The first problem, a lack of accuracy, can <a class="indexterm" id="id00133"/>be solved by having multiple hitboxes per object.</p><p>We simply add the required number of hitboxes to our game object to most effectively <span class="emphasis"><em>wrap </em></span>it, and then perform the same rectangle intersection code on each in turn.</p></div><div class="section" title="Neighbor checking"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec018"/>Neighbor checking</h3></div></div></div><p>This method allows us to only check <a class="indexterm" id="id00134"/>objects that are in the approximate same area as each other. It can be achieved by checking which neighborhood of our game a given two objects are in, and then only performing the more CPU intensive collision detection if there is a realistic chance that a collision could occur.</p><p>Suppose we have 10 objects that each need to be checked against each other, then we need to perform 10 squared (100) collision checks. If we do neighbor checking first, we can significantly reduce this number. In the very hypothetical situation in the diagram, we would only need to do an absolute maximum of 11 collision checks, instead of 100, for our 10 objects, if we first check to see if objects share the same sector.</p><div class="mediaobject"><img alt="Neighbor checking" src="graphics/B043422_03_07.jpg"/></div><p>Implementing this in code<a class="indexterm" id="id00135"/> can be as simple as having a sector member variable for each game object, then looping through the list of objects and just checking if they are in the same sector.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0012"/>Note</h3><p>We will use all these options and optimizations over the course of our three game projects.</p></div></div></div></div><div class="section" title="Best options for Tappy Defender"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec038"/>Best options for Tappy Defender</h2></div></div></div><p>Now that we  know our collision <a class="indexterm" id="id00136"/>detection options, we can decide the best course of action in our current game. All our ships are approximately rectangular (or square), there are few or no extremities on any of them, and we only have one object were we really care about a collision (with all the others).</p><p>This tends to suggest that we can use a single rectangular hitbox for the player and the enemy and perform purely corner aligned, global collision detection. If you're disappointed that we are going for the easy option, then you will be pleased to hear we will be getting into all the fancier techniques over the next two projects.</p><p>To make life even easier, the Android API has a handy the <code class="literal">Rect</code> class that can not only represent our hitboxes, but also has a neat <code class="literal">intersects</code> method that basically does the same thing as rectangle intersection collision detection. Let's think about how to add collision detection to our game.</p><p>First, all of our enemies and our player ship are going to need a hitbox. Add this code to declare a new <code class="literal">Rect</code> member called <code class="literal">hitbox</code>. Do this in both the <code class="literal">PlayerShip</code> and <code class="literal">EnemyShip</code> class:</p><div class="informalexample"><pre class="programlisting">// A hit box for collision detection
private Rect hitBox;</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip00113"/>Tip</h3><p>
<span class="strong"><strong>Important!</strong></span>
</p><p>Be sure to do the previous step and the next three blocks of code for both the <code class="literal">EnemyShip</code> class as well as the <code class="literal">PlayerShip</code> class. I will remind you each time but just thought it worth mentioning beforehand as well.</p></div></div><p>Now, we need to add a getter method to the <code class="literal">PlayerShip</code> class and the <code class="literal">EnemyShip</code> class. Add this code to both classes:</p><div class="informalexample"><pre class="programlisting">public Rect getHitbox(){
  return hitBox;
}</pre></div><p>And next, we need to make sure we<a class="indexterm" id="id00137"/> initialize our hitboxes in both constructors. Make sure to enter the code right at the end of the constructor:</p><div class="informalexample"><pre class="programlisting">// Initialize the hit box
hitBox = new Rect(x, y, bitmap.getWidth(), bitmap.getHeight());</pre></div><p>Now we need to make sure the hitboxes are kept up-to-date with the coordinates of our enemies and our player. The best place to do this is the <code class="literal">update</code> method of the enemy/player ships. The next block of code will update the hitboxes with the ship's current coordinates. Be sure to add this block of code at the very end of the <code class="literal">update</code>() methods so that the hitbox is updated with the coordinates after the <code class="literal">update</code> methods have done their adjustments. Again, add it to both <code class="literal">PlayerShip</code> and <code class="literal">EnemyShip</code>:</p><div class="informalexample"><pre class="programlisting">// Refresh hit box location
hitBox.left = x;
hitBox.top = y;
hitBox.right = x + bitmap.getWidth();
hitBox.bottom = y + bitmap.getHeight();</pre></div><p>Our hitboxes have the coordinates that represent the outline of our bitmaps. This situation is nearly perfect, apart from the transparent bits around the edges.</p><p>Now, we can use our hitboxes from the <code class="literal">TDView</code> class's <code class="literal">update</code> method to detect collisions. But first, we need to decide what we are going to do when a collision occurs.</p><p>We need to refer to the rules of our game. We discussed them back at the beginning of <a class="link" href="ch11.html" title="Chapter 2. Tappy Defender – First Step">Chapter 2</a>, <span class="emphasis"><em>Tappy Defender – First Step</em></span>. We know that the player has three shields but an enemy blows up after one hit. It makes sense to leave things like shields to a later part of the chapter, but we need some way to see our collision detection in action and make sure it is working.</p><p>Probably, the simplest way to acknowledge a collision at this stage, will be to make the enemy ship disappear and respawn as normal, as if it is a totally new enemy. We already have a mechanism in place for this. We know that when an enemy moves off the left of the screen it respawns as if it is a new enemy on the right. All we need to do is instantly transport the enemy to a location off of the left of the screen and the <code class="literal">EnemyShip</code> class will do the rest.</p><p>We need to be able to change the <code class="literal">EnemyShip</code> object's <span class="emphasis"><em>x</em></span> coordinate. Let's add a setter method to the <code class="literal">EnemyShip</code> class so we can manipulate the <span class="emphasis"><em>x</em></span> coordinate of all our enemy spaceships. Like this:</p><div class="informalexample"><pre class="programlisting">// This is used by the TDView update() method to
// Make an enemy out of bounds and force a re-spawn
public void setX(int x) {
  this.x = x;
}</pre></div><p>Now, we can carry out collision<a class="indexterm" id="id00138"/> detection and respond when we get a hit. The next block of code uses the static method <code class="literal">Rect.intersects()</code> to detect a hit by comparing the player ship's hitbox with each of the enemy hitboxes in turn. If a hit is detected, the appropriate enemy is moved off screen, ready to be respawned by its own <code class="literal">update</code> method in the next frame. Enter this code at the very top of the <code class="literal">TDView</code> class's <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">// Collision detection on new positions
// Before move because we are testing last frames
// position which has just been drawn

// If you are using images in excess of 100 pixels
// wide then increase the -100 value accordingly
if(Rect.intersects
  (player.getHitbox(), enemy1.getHitbox())){
    enemy1.setX(-100);
}

if(Rect.intersects
  (player.getHitbox(), enemy2.getHitbox())){
    enemy2.setX(-100);
}

if(Rect.intersects
  (player.getHitbox(), enemy3.getHitbox())){
    enemy3.setX(-100);
}</pre></div><p>That's it, our collisions will now work. It may be nice to be able to really see what is going on. For the purposes of debugging, let's draw a rectangle around all our spaceships, so we can see the hitboxes. We will use the <code class="literal">drawRect</code> method of the <code class="literal">Paint</code> class and pass the properties of our hitboxes in as arguments to define the area to draw. As you will expect, this code goes in the <code class="literal">draw</code> method. Note that it should go before the code that draws our ships so that the rectangles are drawn behind them, but after we clear the screen, as shown by the <a class="indexterm" id="id00139"/>highlighted code:</p><div class="informalexample"><pre class="programlisting">// Rub out the last frame
canvas.drawColor(Color.argb(255, 0, 0, 0));

<span class="strong"><strong>// For debugging</strong></span>
<span class="strong"><strong>// Switch to white pixels</strong></span>
<span class="strong"><strong>paint.setColor(Color.argb(255, 255, 255, 255));</strong></span>

<span class="strong"><strong>// Draw Hit boxes</strong></span>
<span class="strong"><strong>canvas.drawRect(player.getHitbox().left, </strong></span>
<span class="strong"><strong>  player.getHitbox().top, </strong></span>
<span class="strong"><strong>  player.getHitbox().right, </strong></span>
<span class="strong"><strong>  player.getHitbox().bottom, </strong></span>
<span class="strong"><strong>  paint);</strong></span>

<span class="strong"><strong>canvas.drawRect(enemy1.getHitbox().left, </strong></span>
<span class="strong"><strong>  enemy1.getHitbox().top, </strong></span>
<span class="strong"><strong>  enemy1.getHitbox().right, </strong></span>
<span class="strong"><strong>  enemy1.getHitbox().bottom, </strong></span>
<span class="strong"><strong>  paint);</strong></span>

<span class="strong"><strong>canvas.drawRect(enemy2.getHitbox().left, </strong></span>
<span class="strong"><strong>  enemy2.getHitbox().top, </strong></span>
<span class="strong"><strong>  enemy2.getHitbox().right, </strong></span>
<span class="strong"><strong>  enemy2.getHitbox().bottom, </strong></span>
<span class="strong"><strong>  paint);</strong></span>

<span class="strong"><strong>canvas.drawRect(enemy3.getHitbox().left, </strong></span>
<span class="strong"><strong>  enemy3.getHitbox().top, </strong></span>
<span class="strong"><strong>  enemy3.getHitbox().right, </strong></span>
<span class="strong"><strong>  enemy3.getHitbox().bottom, </strong></span>
<span class="strong"><strong>  paint);</strong></span>
</pre></div><p>We can now run Tappy Defender <a class="indexterm" id="id00140"/>and see the game in action complete with debugging mode hitboxes enabled:</p><div class="mediaobject"><img alt="Best options for Tappy Defender" src="graphics/B043422_03_08.jpg"/></div><p>We can comment out this debugging code when we are done with it and then uncomment it should we need it again later.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec023"/>Summary</h1></div></div></div><p>We now have all the game objects that we need for a complete game. They all think and represent themselves internally in the model part of our design pattern. Furthermore, our player can at last control his spaceship, and we can detect when he crashes.</p><p>In the next chapter, we will put the finishing touches to our game including adding a HUD (Heads Up Display), implementing the game rules, adding some extra features, and play-testing our game to get everything in balance.</p></div>
<div class="chapter" title="Chapter&#xA0;4.&#xA0;Tappy Defender &#x2013; Going Home"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 4. Tappy Defender – Going Home</h1></div></div></div><p>We are on the home straight of our first game. In this chapter, we will draw a HUD to show the player in-game information, and implement the rules of the game so that the player can win, lose, and get fastest times.</p><p>After that, we will make a pause screen so the player can admire their achievements (or not) after they win or lose.</p><p>In this chapter, we will also generate our own sound FX and then add them to the game. Following that, we will enable the player to save their fastest time, and finally we will add a whole bunch of minor improvements, including a bit of difficulty balancing based on the screen resolution of the player's Android device.</p><div class="section" title="Displaying a HUD"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec024"/>Displaying a HUD</h1></div></div></div><p>We need to start making <a class="indexterm" id="id00141"/>our game a bit more rounded. Games have a score or, in our case, a time, and other rules as well. For the player to keep check on their progress we need to display the stats of the game.</p><p>Here, we will quickly set up a HUD that will show the player everything they need to know on screen while he is dodging enemies. We will also declare and initialize the variables required to supply data to the HUD. In the next section, <span class="emphasis"><em>Implementing the rules</em></span>, we can begin to manipulate variables such as, shields, time, fastest time, and so on.</p><p>We can start by adding some member variables to the <code class="literal">TDView</code> class. We use a float value for the <code class="literal">distanceRemaining</code> variable because we will be using pseudo-kilometers and fractions of kilometers to represent the distance remaining until our hero makes it to her home planet. For the <code class="literal">timeTaken</code>, <code class="literal">timeStarted</code>, and <code class="literal">fastestTime</code> variables, we will use the <span class="strong"><strong>long</strong></span> type because time is represented in milliseconds and the values get really big. Add this code after the <code class="literal">TDView</code> class declaration:</p><div class="informalexample"><pre class="programlisting">private float distanceRemaining;
private long timeTaken;
private long timeStarted;
private long fastestTime;</pre></div><p>For now, we will just leave these variables with their default values and concentrate on displaying them in our HUD. We will make them useful and meaningful in the next section, <span class="emphasis"><em>Implementing the rules</em></span>.</p><p>Now, we can go ahead<a class="indexterm" id="id00142"/> and draw our HUD to display all the data the player may want to know while playing. As so often, we will be using our versatile <code class="literal">Paint</code> class object <code class="literal">paint</code> to do the bulk of the work. This time, we use the <code class="literal">drawText</code> method to add text to the screen, the <code class="literal">setTextAlign</code> method to justify our text, and <code class="literal">setTextSize</code> to scale the size of the text.</p><p>We can now add this code to our <code class="literal">TDView</code> class's <code class="literal">draw</code> method. Add it as the last thing to draw, just before the call to <code class="literal">unlockCanvasAndPost()</code>, as shown by the highlighted code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Draw the hud</strong></span>
<span class="strong"><strong>paint.setTextAlign(Paint.Align.LEFT);</strong></span>
<span class="strong"><strong>paint.setColor(Color.argb(255, 255, 255, 255));</strong></span>
<span class="strong"><strong>paint.setTextSize(25);</strong></span>
<span class="strong"><strong>canvas.drawText("Fastest:"+ fastestTime + "s", 10, 20, paint);</strong></span>
<span class="strong"><strong>canvas.drawText("Time:" + timeTaken + "s", screenX / 2, 20, paint);</strong></span>
<span class="strong"><strong>canvas.drawText("Distance:" + </strong></span>
<span class="strong"><strong>  distanceRemaining / 1000 + </strong></span>
<span class="strong"><strong>  " KM", screenX / 3, screenY - 20, paint);</strong></span>

<span class="strong"><strong>canvas.drawText("Shield:" + </strong></span>
<span class="strong"><strong>  player.getShieldStrength(), 10, screenY - 20, paint);</strong></span>
<span class="strong"><strong>            </strong></span>
<span class="strong"><strong>canvas.drawText("Speed:" + </strong></span>
<span class="strong"><strong>  player.getSpeed() * 60 + </strong></span>
<span class="strong"><strong>  " MPS", (screenX /3 ) * 2, screenY - 20, paint);</strong></span>
            
// Unlock and draw the scene
ourHolder.unlockCanvasAndPost(canvas);</pre></div><p>After entering this code, we have some errors and probably some questions.</p><p>First, we will deal with the questions. We will look more closely at what we are doing to <code class="literal">fastestTime</code>, <code class="literal">timeTaken</code>, <code class="literal">distanceRemaining</code>, and the value returned by <code class="literal">getSpeed</code> in the next section, <span class="emphasis"><em>Implementing the rules</em></span>. Simply put, they are representations of distance and time that serve to give the player a sense of how they are doing. They are not real simulations of distance, although the time is accurate.</p><p>The first error we will deal with is caused by a call to a nonexistent method <code class="literal">player.getShieldStrength</code>. Add a member variable <code class="literal">shieldStrength</code> to the <code class="literal">PlayerShip</code> class:</p><div class="informalexample"><pre class="programlisting">private int shieldStrength;</pre></div><p>Initialize it to <code class="literal">2</code> in the <code class="literal">PlayerShip</code> constructor:</p><div class="informalexample"><pre class="programlisting"> shieldStrength = 2;</pre></div><p>Implement your missing getter method in the <code class="literal">PlayerShip</code> class:</p><div class="informalexample"><pre class="programlisting">public int getShieldStrength() {
  return shieldStrength;
}</pre></div><p>The final errors are caused<a class="indexterm" id="id00143"/> by the undeclared variables <code class="literal">screenX</code> and <code class="literal">screenY</code>. It is now apparent that we need the screen resolution in this part of our code. The fastest way to deal with this is to make some new class variables called <code class="literal">screenX</code> and <code class="literal">screenY</code>. Declare these now just after the <code class="literal">TDView</code> class declaration:</p><div class="informalexample"><pre class="programlisting">private int screenX;
private int screenY;</pre></div><p>As we will see, knowing the screen coordinates is useful in a number of places, so it makes sense to do this.</p><p>Now, in the <code class="literal">TDView</code> constructor, initialize <code class="literal">screenX</code> and <code class="literal">screenY</code> with the resolution passed in by the <code class="literal">GameActivity</code> class. Do this at the start of the constructor:</p><div class="informalexample"><pre class="programlisting">screenX = x;
screenY = y;</pre></div><p>We can now run the game and see our HUD. The only parts of our HUD with meaningful data are the <span class="strong"><strong>Shield</strong></span> and <span class="strong"><strong>Speed</strong></span> labels. The speed is a pseudo-measurement of MPS (meters per second). Of course it has no bearing on reality, but it is relative to the speed of the whizzing stars, approaching enemies and soon, to the decreasing distance from the player's goal, home:</p><div class="mediaobject"><img alt="Displaying a HUD" src="graphics/B04322_04_01.jpg"/></div></div></div>
<div class="section" title="Implementing the rules"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec025"/>Implementing the rules</h1></div></div></div><p>Now, we should<a class="indexterm" id="id00144"/> pause and think about what we need to <a class="indexterm" id="id00145"/>do later in the project because it will affect what we do while implementing our rules. When the player's ship is destroyed or when player reaches their goal, the game will end. This implies that the game will need to be restarted. We don't want to quit back to the home screen each time, so we need a way to restart the game from within the <code class="literal">TDView</code> class.</p><p>To facilitate this, we are going to implement a <code class="literal">startGame</code> method in our <code class="literal">TDView</code> class. The constructor will be able to call it and our game loop will also be able to call it when necessary as well.</p><p>It will also be necessary to pass some of the tasks that the constructor currently performs onto the new <code class="literal">startGame</code> method so that it can properly do its job. Also, we will use <code class="literal">startGame</code> to initialize some of the variables that our game rules and HUD require.</p><p>In order to accomplish what we discussed, <code class="literal">startGame()</code> will need a copy of the application's <code class="literal">Context</code> object. So, like we did with <code class="literal">startX</code> and <code class="literal">startY</code>, we will now make <code class="literal">context</code> a member of <code class="literal">TDView</code>. Declare it after the <code class="literal">TDView</code> class declaration:</p><div class="informalexample"><pre class="programlisting">private Context context;</pre></div><p>Initialize it in the constructor right after the call to <code class="literal">super()</code>, like this:</p><div class="informalexample"><pre class="programlisting">super(context);
<span class="strong"><strong>this.context  = context;</strong></span>
</pre></div><p>We can now implement the new <code class="literal">startGame</code> method. Most of the code is just moved from the constructor. Note that the subtle but important differences, like using the class version of the screen coordinates <code class="literal">screenX</code> and <code class="literal">screenY</code> instead of the constructor parameters <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>. Also, we initialize <code class="literal">distanceRemaining</code>, <code class="literal">timeTaken</code>, and <code class="literal">timeStarted</code>.</p><div class="informalexample"><pre class="programlisting">private void startGame(){
    //Initialize game objects
        player = new PlayerShip(context, screenX, screenY);
        enemy1 = new EnemyShip(context, screenX, screenY);
        enemy2 = new EnemyShip(context, screenX, screenY);
        enemy3 = new EnemyShip(context, screenX, screenY);

        int numSpecs = 40;
        for (int i = 0; i &lt; numSpecs; i++) {
            // Where will the dust spawn?
            SpaceDust spec = new SpaceDust(screenX, screenY);
            dustList.add(spec);
        }

        // Reset time and distance
        distanceRemaining = 10000;// 10 km
        timeTaken = 0;

        // Get start time
        timeStarted = System.currentTimeMillis();
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0014"/>Note</h3><p>Are you are wondering what is going on with the <code class="literal">timeStarted</code> initialization? We initialized <code class="literal">startTime</code> using a method of the <code class="literal">System</code> class, <code class="literal">currentTimeMillis</code>. Now, <code class="literal">startTime</code> holds the number of milliseconds since January 1, 1970. We will see how this is used in the upcoming section, <span class="emphasis"><em>Ending the game</em></span>. The <code class="literal">System</code> class has many uses. Here, we use it to get the number of milliseconds since January 1, 1970. This is a common system for measuring time in a computer. It is called Unix time and the moment before the 1st millisecond of January 1, 1970 is known as the Unix Epoch.</p></div></div><p>Now, comment <a class="indexterm" id="id00146"/>out or delete the now unnecessary code from the <code class="literal">TDView</code> constructor <a class="indexterm" id="id00147"/>but add the call to <code class="literal">startGame()</code> in its place:</p><div class="informalexample"><pre class="programlisting">// Initialize our player ship
//player = new PlayerShip(context, x, y);
//enemy1 = new EnemyShip(context, x, y);
//enemy2 = new EnemyShip(context, x, y);
//enemy3 = new EnemyShip(context, x, y);

//int numSpecs = 40;

//for (int i = 0; i &lt; numSpecs; i++) {
      // Where will the dust spawn?
      //SpaceDust spec = new SpaceDust(x, y);
      //dustList.add(spec);
//}
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>startGame();</strong></span>
</pre></div><p>Next, we want to create a method to decrement the <code class="literal">PlayerShip</code> shield strength. This is so that when we detect a collision, we can reduce it by one each time. Add this simple method to the <code class="literal">PlayerShip</code> class:</p><div class="informalexample"><pre class="programlisting">public void reduceShieldStrength(){
  shieldStrength --;
}</pre></div><p>Now, we can <a class="indexterm" id="id00148"/>jump to the <code class="literal">TDView</code> class's <code class="literal">update</code> <a class="indexterm" id="id00149"/>method and add code to implement our game rules a bit further. We will add a Boolean variable <code class="literal">hitDetected</code> just before we do all our collision detection. Inside each of the <code class="literal">if</code> blocks which detects a hit, we can set <code class="literal">hitDetected</code> to <code class="literal">true</code>. </p><p>Then, after all the collision detection code, we can see if a hit has been detected and reduce the player's shield strength accordingly. Here is the top part of the <code class="literal">TDView</code> class's <code class="literal">update</code> method with the new lines of code highlighted:</p><div class="informalexample"><pre class="programlisting">// Collision detection on new positions
// Before move because we are testing last frames
// position which has just been drawn
<span class="strong"><strong>boolean hitDetected = false;</strong></span>
if(Rect.intersects(player.getHitbox(), enemy1.getHitbox())){
<span class="strong"><strong>    hitDetected = true;</strong></span>
    enemy1.setX(-100);
}

if(Rect.intersects(player.getHitbox(), enemy2.getHitbox())){
<span class="strong"><strong>    hitDetected = true;</strong></span>
    enemy2.setX(-100);
}

if(Rect.intersects(player.getHitbox(), enemy3.getHitbox())){
<span class="strong"><strong>    hitDetected = true;</strong></span>
    enemy3.setX(-100);
}

<span class="strong"><strong>if(hitDetected) {</strong></span>
<span class="strong"><strong>    player.reduceShieldStrength();</strong></span>
<span class="strong"><strong>       if (player.getShieldStrength() &lt; 0) {</strong></span>
<span class="strong"><strong>            //game over so do something</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Note the nested if statement after the call to <code class="literal">player.reduceShieldStrength</code>. This detects when the player has lost all their shields and failed. We will deal with what happens here soon.</p><p>We are really <a class="indexterm" id="id00150"/>close to finishing off our game rules. We <a class="indexterm" id="id00151"/>just need to decrease the <code class="literal">distanceRemaining</code> relative to the player's speed. This is so that we know when the player has succeeded. We also need to update the <code class="literal">timeTaken</code> variable so that the HUD is updated each time our draw method is called. This may not seem important, but thinking ahead a little, we can foresee a time when the game has ended, either because the player has failed or because the player has won. Let's talk about the end of the game.</p></div>
<div class="section" title="Ending the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec026"/>Ending the game</h1></div></div></div><p>If the game is not ended, the <a class="indexterm" id="id00152"/>game is playing, and if the player has just died or won, the game is ended. We need to know when the game is ended and when it is playing. Let's make a new member variable <code class="literal">gameEnded</code> and declare it after the <code class="literal">TDView</code> class declaration:</p><div class="informalexample"><pre class="programlisting">private boolean gameEnded;</pre></div><p>Now, we can initialize <code class="literal">gameEnded</code> in the <code class="literal">startGame</code> method. Enter this code as the very last line in the method.</p><div class="informalexample"><pre class="programlisting">gameEnded = false;</pre></div><p>Now, we can finish the last few lines of our game rules logic, but wrap them in a test to see if the game has ended or not. Add the following code to conditionally update our game rules logic, right at the end of the <code class="literal">TDView</code> class's <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">if(!gameEnded) {
            //subtract distance to home planet based on current speed
            distanceRemaining -= player.getSpeed();

            //How long has the player been flying
            timeTaken = System.currentTimeMillis() - timeStarted;
}</pre></div><p>Our HUD will now have accurate data to keep the player informed of exactly how they are doing. We can also detect when the player arrives home and wins because <code class="literal">distanceRemaining</code> will pass zero. In addition, when distance remaining is less than zero, we can test to see if <code class="literal">timeTaken</code> is less than <code class="literal">fastestTime</code> and update <code class="literal">fastestTime</code> if it is. We can also set <code class="literal">gameEnded</code> to <code class="literal">true</code>. Add this code directly after the last block of code in the <code class="literal">TDView</code> class's <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">//Completed the game!
if(distanceRemaining &lt; 0){
  //check for new fastest time
  if(timeTaken &lt; fastestTime) {
    fastestTime = timeTaken;
  }
            
  // avoid ugly negative numbers
  // in the HUD
  distanceRemaining = 0;

  // Now end the game
  gameEnded = true;
}</pre></div><p>We ended the game<a class="indexterm" id="id00153"/> when the player won; now, add this next line of code to end the game when the player loses all their shields. Update this code in the <code class="literal">TDView</code> class's <code class="literal">update</code> method. The new line of code is highlighted:</p><div class="informalexample"><pre class="programlisting">if(hitDetected) {
  player.reduceShieldStrength();
  if (player.getShieldStrength() &lt; 0) {
<span class="strong"><strong>    gameEnded = true;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Now, we just need to make something actually happen when <code class="literal">gameEnded</code> is set to true.</p><p>One way to do this is to alternate how we draw the HUD based on whether the <code class="literal">gameEnded</code> Boolean is true or false. Identify the HUD drawing code in the <code class="literal">draw</code> method, shown again here for easy reference:</p><div class="informalexample"><pre class="programlisting">// Draw the HUD
paint.setTextAlign(Paint.Align.LEFT);
paint.setColor(Color.argb(255, 255, 255, 255));
paint.setTextSize(25);
canvas.drawText("Fastest:"+ fastestTime + "s", 10, 20, paint);
canvas.drawText("Time:" + timeTaken + "s", screenX / 2, 20, paint);

canvas.drawText("Distance:" + 
  distanceRemaining / 1000 + 
  " KM", screenX / 3, screenY - 20, paint);

canvas.drawText("Shield:" + 
  player.getShieldStrength(), 10, screenY - 20, paint);
            
canvas.drawText("Speed:" + 
  player.getSpeed() * 60 +
  " MPS", (screenX /3 ) * 2, screenY - 20, paint);</pre></div><p>We want to wrap that code in an <code class="literal">if</code>-<code class="literal">else</code> block. If the game is not ended, draw the normal HUD else draw an alternative. Wrap the HUD drawing code like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>if(!gameEnded){</strong></span>
  // Draw the hud
  paint.setTextAlign(Paint.Align.LEFT);
  paint.setColor(Color.argb(255, 255, 255, 255));
  paint.setTextSize(25);
  canvas.drawText("Fastest:"+ fastestTime + "s", 10, 20, paint);
  
  canvas.drawText("Time:" + 
    timeTaken + 
    "s", screenX / 2, 20,   paint);

  canvas.drawText("Distance:" + 
    distanceRemaining / 1000 + 
    " KM", screenX / 3, screenY - 20, paint);

  canvas.drawText("Shield:" + 
    player.getShieldStrength(), 10, screenY - 20, paint);
            
  canvas.drawText("Speed:" + 
    player.getSpeed() * 60 +
    " MPS", (screenX /3 ) * 2, screenY - 20, paint);

<span class="strong"><strong>}else{</strong></span>
<span class="strong"><strong>  //this happens when the game is ended</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Now, let's deal with<a class="indexterm" id="id00154"/> the <code class="literal">else</code> block, which we will execute when the game is ended. What we will do is draw a big <span class="strong"><strong>Game Over</strong></span>, and show the end game stats from the HUD. The thread continues on but the HUD stops updating. Enter this code in the <code class="literal">else</code> block:</p><div class="informalexample"><pre class="programlisting">// Show pause screen
paint.setTextSize(80);
paint.setTextAlign(Paint.Align.CENTER);
canvas.drawText("Game Over", screenX/2, 100, paint);
paint.setTextSize(25);
canvas.drawText("Fastest:"+ 
  fastestTime + "s", screenX/2, 160, paint);
                
canvas.drawText("Time:" + timeTaken + 
  "s", screenX / 2, 200, paint);
                
canvas.drawText("Distance remaining:" + 
  distanceRemaining/1000 + " KM",screenX/2, 240, paint);
                
paint.setTextSize(80);
canvas.drawText("Tap to replay!", screenX/2, 350, paint);</pre></div><p>Note that we switch<a class="indexterm" id="id00155"/> text sizes using <code class="literal">setTextSize()</code>, and we align all the text in the center of the screen using <code class="literal">setTextAlign()</code>. This is what it looks like when you run the game. We just need a way to restart the game after it has ended:</p><div class="mediaobject"><img alt="Ending the game" src="graphics/B04322_04_02.jpg"/></div><div class="section" title="Restarting the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec039"/>Restarting the game</h2></div></div></div><p>To allow the player to<a class="indexterm" id="id00156"/> restart after the game has ended, we just need to listen for a touch and call <code class="literal">startGame()</code>. Lets edit our <code class="literal">onTouchListener()</code> code to achieve this. The case <code class="literal">MotionEvent.ACTION_DOWN:</code> is the case we are interested in amending. We can simply add conditions here that if the screen is touched while the game is ended, restart. The new code to add to case <code class="literal">MotionEvent.ACTION_DOWN:</code> is highlighted:</p><div class="informalexample"><pre class="programlisting">// Has the player touched the screen?
case MotionEvent.ACTION_DOWN:
    player.setBoosting();
<span class="strong"><strong>   // If we are currently on the pause screen, start a new game</strong></span>
<span class="strong"><strong>   if(gameEnded){</strong></span>
<span class="strong"><strong>       startGame();</strong></span>
<span class="strong"><strong>   }</strong></span>
   break;</pre></div><p>Try it out. You can now<a class="indexterm" id="id00157"/> restart the game from the pause menu by tapping the screen. Is it just me or is it a bit quiet round here?</p></div></div>
<div class="section" title="Adding sound FX"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec027"/>Adding sound FX</h1></div></div></div><p>Adding sound effects in <a class="indexterm" id="id00158"/>Android is really straightforward. First, let's <a class="indexterm" id="id00159"/>look at where we can get our sound FX from. If you just want to get on with the coding, you can use my sound FX in the <code class="literal">Chapter4/assets</code> folder.</p><div class="section" title="Generating the FX"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec040"/>Generating the FX</h2></div></div></div><p>We require four<a class="indexterm" id="id00160"/> sound FX for our Tappy Defender game:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The sound for <a class="indexterm" id="id00161"/>when our player crashes into an alien, which we will call <code class="literal">bump.ogg</code>.</li><li class="listitem" style="list-style-type: disc">The sound for when the player is destroyed, which we will call <code class="literal">destroyed.ogg</code>.</li><li class="listitem" style="list-style-type: disc">A fun sound for when the game first begins, which we will call <code class="literal">start.ogg</code>.</li><li class="listitem" style="list-style-type: disc">Finally, a victory whoop-type sound, which we will call <code class="literal">win.ogg</code>.</li></ul></div><p>Here is a very quick guide to make these sound FX using BFXR. Grab a free copy of BFXR<a class="indexterm" id="id00162"/> from <a class="ulink" href="http://www.bfxr.net">www.bfxr.net</a>.</p><p>Follow the simple instructions on the website to set it up. Try out a few of these things to make our cool sound FX.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0015"/>Note</h3><p>This is a very condensed tutorial. You can do so much with BFXR. To learn more read the tips on the website at the previous URL.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run <code class="literal">bfxr.exe</code>.<div class="mediaobject"><img alt="Generating the FX" src="graphics/B04322_04_03.jpg"/></div></li><li class="listitem">Try out all the <a class="indexterm" id="id00163"/>preset types, which generate <a class="indexterm" id="id00164"/>a random sound of the type you are working on. When you have a sound that is close to what you want, move to the next step:<div class="mediaobject"><img alt="Generating the FX" src="graphics/B04322_04_05.jpg"/></div></li><li class="listitem">Use the <a class="indexterm" id="id00165"/>sliders to fine-tune the <a class="indexterm" id="id00166"/>pitch, duration, and other aspects of your new sound:<div class="mediaobject"><img alt="Generating the FX" src="graphics/B04322_04_04.jpg"/></div></li><li class="listitem">Save your<a class="indexterm" id="id00167"/> sound by clicking on <a class="indexterm" id="id00168"/>the <span class="strong"><strong>Export Wav</strong></span> button. Despite the name of this button, as we will see we can save in formats other than <code class="literal">.wav</code> too.<div class="mediaobject"><img alt="Generating the FX" src="graphics/B04322_04_06.jpg"/></div></li><li class="listitem">Android likes to work with sounds in the OGG format, so when asked to name your file use the <code class="literal">.ogg</code> extension at the end of the filename. Remember we need to create <code class="literal">bump.ogg</code>, <code class="literal">destroyed.ogg</code>, <code class="literal">start.ogg</code>, and <code class="literal">win.ogg</code>.</li><li class="listitem">Repeat steps 2 to 5 and create the four sound FX that we discussed.</li><li class="listitem">Right-click the <code class="literal">app</code> folder in Android Studio. From the pop-up menu, navigate to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Android resource directory</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Directory name</strong></span> field, type <code class="literal">assets</code>. Click on <span class="strong"><strong>OK</strong></span> to create the <code class="literal">assets</code> folder.</li><li class="listitem">Use your <a class="indexterm" id="id00169"/>operating system's file <a class="indexterm" id="id00170"/>manager to add a folder called <code class="literal">assets</code> to the main folder of the project, then add the four sound files to the new assets folder in your project.</li></ol></div></div><div class="section" title="The SoundPool class"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec041"/>The SoundPool class</h2></div></div></div><p>To play our sounds, we will <a class="indexterm" id="id00171"/>use the <code class="literal">SoundPool</code> class. We are using the deprecated version of the <code class="literal">SoundPool</code> constructor because the new version needs API 21 or newer and it is likely that lots of readers will be using an earlier version of Android. We can dynamically get the Android version and provide a different version of the code for pre- and post-API level 21, but the older constructor meets our needs.</p></div><div class="section" title="Coding the sound FX"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec042"/>Coding the sound FX</h2></div></div></div><p>Declare a <code class="literal">SoundPool</code> object and <a class="indexterm" id="id00172"/>some integers to represent the individual sounds. Add this code just after the <code class="literal">TDView</code> class declaration:</p><div class="informalexample"><pre class="programlisting">private SoundPool soundPool;
    int start = -1;
    int bump = -1;
    int destroyed = -1;
    int win = -1;</pre></div><p>Next, we can initialize our <code class="literal">SoundPool</code> object and our integer sound IDs. We wrap the code in a <code class="literal">try</code>-<code class="literal">catch</code> block as required.</p><p>Note that the call to <code class="literal">load()</code> starts a process of converting our <code class="literal">.ogg</code> files to raw sound data. If the process is not finished when a call to <code class="literal">playSound()</code> is made, the sound won't play. The calls to <code class="literal">load()</code> are in the likely order of them being used to minimize this possibility. Enter this code in the constructor of our <code class="literal">TDView</code> class as shown. The new code is highlighted:</p><div class="informalexample"><pre class="programlisting">TDView(Context context, int x, int y) {
  super(context);
  this.context  = context;

<span class="strong"><strong>  // This SoundPool is deprecated but don't worry</strong></span>
<span class="strong"><strong>  soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);</strong></span>
<span class="strong"><strong>  try{</strong></span>
<span class="strong"><strong>    //Create objects of the 2 required classes</strong></span>
<span class="strong"><strong>    AssetManager assetManager = context.getAssets();</strong></span>
<span class="strong"><strong>    AssetFileDescriptor descriptor;</strong></span>

<span class="strong"><strong>    //create our three fx in memory ready for use</strong></span>
<span class="strong"><strong>    descriptor = assetManager.openFd("start.ogg");</strong></span>
<span class="strong"><strong>    start = soundPool.load(descriptor, 0);</strong></span>

<span class="strong"><strong>    descriptor = assetManager.openFd("win.ogg");</strong></span>
<span class="strong"><strong>    win = soundPool.load(descriptor, 0);</strong></span>

<span class="strong"><strong>    descriptor = assetManager.openFd("bump.ogg");</strong></span>
<span class="strong"><strong>    bump = soundPool.load(descriptor, 0);</strong></span>

<span class="strong"><strong>    descriptor = assetManager.openFd("destroyed.ogg");</strong></span>
<span class="strong"><strong>    destroyed = soundPool.load(descriptor, 0);</strong></span>


<span class="strong"><strong>  }catch(IOException e){</strong></span>
<span class="strong"><strong>    //Print an error message to the console</strong></span>
<span class="strong"><strong>    Log.e("error", "failed to load sound files");</strong></span>
<span class="strong"><strong>  }</strong></span>
</pre></div><p>Add a call to <code class="literal">playSound()</code> using the <a class="indexterm" id="id00173"/>appropriate reference at the points in our code which represent the appropriate event in our game. We have four sounds, so four calls to <code class="literal">playSound()</code> will be made.</p><p>The first goes at the very end of the <code class="literal">startGame()</code> method:</p><div class="informalexample"><pre class="programlisting">soundPool.play(start, 1, 1, 0, 0, 1);</pre></div><p>The next two are highlighted in the <code class="literal">if(hitDetected)</code> block:</p><div class="informalexample"><pre class="programlisting">if(hitDetected) {
<span class="strong"><strong>  soundPool.play(bump, 1, 1, 0, 0, 1);</strong></span>
  player.reduceShieldStrength();
  if (player.getShieldStrength() &lt; 0) {
<span class="strong"><strong>      soundPool.play(destroyed, 1, 1, 0, 0, 1);</strong></span>
      paused = true;
  }
}</pre></div><p>The last one is in the <code class="literal">if(distanceRemaining &lt; 0)</code> block, as highlighted:</p><div class="informalexample"><pre class="programlisting">//Completed the game!
if(distanceRemaining &lt; 0){
<span class="strong"><strong>     soundPool.play(win, 1, 1, 0, 0, 1);</strong></span>
     //check for new fastest time
     if(timeTaken &lt; fastestTime) {
         fastestTime = timeTaken;
     }
           
     // avoid ugly negative numbers
     // in the HUD
     distanceRemaining = 0;
             
     // Now end the game
     gameEnded = true;
}</pre></div><p>It's time to run Tappy Defender now and hear the sound in action.</p><p>We will see how to save our player's high score by saving it to a file when they achieve it and loading it back up <a class="indexterm" id="id00174"/>again when Tappy Defender starts.</p></div></div>
<div class="section" title="Adding persistence"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec028"/>Adding persistence</h1></div></div></div><p>You may have <a class="indexterm" id="id00175"/>noticed that the current fastest time is zero and <a class="indexterm" id="id00176"/>can therefore never be beaten. The other problem is that every time the player quits the game the high score is lost. Now, we will load a default high score from a file. When a new high score is achieved, save it to the file. It doesn't matter if the player quits the game or even switches off their phone; their high score will remain.</p><p>First we need two new objects. Declare them as members of the <code class="literal">TDView</code> class after the <code class="literal">TDView</code> class declaration. The first is a <code class="literal">SharedPreferences</code> object and the second is an <code class="literal">Editor</code> object, which actually writes to the file for us:</p><div class="informalexample"><pre class="programlisting">private SharedPreferences prefs;
private SharedPreferences.Editor editor;</pre></div><p>We use <code class="literal">prefs</code> first as we just want to attempt to load a high score if one exists. We will also initialize <code class="literal">editor</code> ready for when we save our high score. We do this in the <code class="literal">TDView</code> constructor:</p><div class="informalexample"><pre class="programlisting">// Get a reference to a file called HiScores. 
// If id doesn't exist one is created
prefs = context.getSharedPreferences("HiScores", 
  context.MODE_PRIVATE);

// Initialize the editor ready
editor = prefs.edit();

// Load fastest time from a entry in the file
//  labeled "fastestTime"
// if not available highscore = 1000000
fastestTime = prefs.getLong("fastestTime", 1000000);</pre></div><p>Let's use our <code class="literal">Editor</code> object to write any new fastest times to the <code class="literal">HiScores</code> file when appropriate. Add the extra highlighted lines shown to add the proposed changes to our file, first into a <a class="indexterm" id="id00177"/>buffer and then commit the<a class="indexterm" id="id00178"/> changes:</p><div class="informalexample"><pre class="programlisting">//Completed the game!
if(distanceRemaining &lt; 0){
<span class="strong"><strong>     soundPool.play(win, 1, 1, 0, 0, 1);</strong></span>
     //check for new fastest time
     if(timeTaken &lt; fastestTime) {
         // Save high score
         editor.putLong("fastestTime", timeTaken);
         editor.commit();
         fastestTime = timeTaken;
     }
           
     // avoid ugly negative numbers
     // in the HUD
     distanceRemaining = 0;
             
     // Now end the game
     gameEnded = true;
}</pre></div><p>The last thing we need to do is get the home screen to load up the fastest time and display it to the player. We will load the fastest time in exactly the same way as we did in our <code class="literal">TDView</code> constructor. We will also get a reference to our <code class="literal">TextView</code> through its ID <code class="literal">textHighScore</code>, which we assigned way back at the beginning of <a class="link" href="ch11.html" title="Chapter 2. Tappy Defender – First Step">Chapter 2</a>, <span class="emphasis"><em>Tappy Defender – First Step</em></span>. We then use the <code class="literal">setText</code> method to display it to the player.</p><p>Open up <code class="literal">MainActivity.java</code> and add the highlighted code to the <code class="literal">onCreate</code> method to achieve what we just discussed:</p><div class="informalexample"><pre class="programlisting">// This is the entry point to our game
@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);

  //Here we set our UI layout as the view
  setContentView(R.layout.activity_main);

<span class="strong"><strong>  // Prepare to load fastest time</strong></span>
<span class="strong"><strong>  SharedPreferences prefs;</strong></span>
<span class="strong"><strong>  SharedPreferences.Editor editor;</strong></span>
<span class="strong"><strong>  prefs = getSharedPreferences("HiScores", MODE_PRIVATE);</strong></span>


  // Get a reference to the button in our layout
  final Button buttonPlay =
    (Button)findViewById(R.id.buttonPlay);

<span class="strong"><strong>  // Get a reference to the TextView in our layout</strong></span>
<span class="strong"><strong>  final TextView textFastestTime =             </strong></span>
<span class="strong"><strong>    (TextView)findViewById(R.id.textHighScore);</strong></span>
        
  // Listen for clicks
  buttonPlay.setOnClickListener(this);

<span class="strong"><strong>  // Load fastest time</strong></span>
<span class="strong"><strong>  // if not available our high score = 1000000</strong></span>
<span class="strong"><strong>  long fastestTime = prefs.getLong("fastestTime", 1000000);</strong></span>

<span class="strong"><strong>  // Put the high score in our TextView</strong></span>
<span class="strong"><strong>  textFastestTime.setText("Fastest Time:" + fastestTime);</strong></span>

}</pre></div><p>Now, we have a <a class="indexterm" id="id00179"/>complete working game. However, it is <a class="indexterm" id="id00180"/>not really finished yet. To make a game that is genuinely playable and fun, we have to improve, refine, test, and iterate.</p></div>
<div class="section" title="Iteration"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec029"/>Iteration</h1></div></div></div><p>How can we make our <a class="indexterm" id="id00181"/>game better and more playable? Let's look at a<a class="indexterm" id="id00182"/> number of possibilities and then go ahead and implement them.</p><div class="section" title="Multiple different enemy graphics"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec043"/>Multiple different enemy graphics</h2></div></div></div><p>Let's make the enemies a bit <a class="indexterm" id="id00183"/>more interesting by adding a few more graphics to the game. First, we need to add the extra graphics to the project. Copy and paste <code class="literal">enemy2.png</code> and <code class="literal">enemy3.png</code> from the <code class="literal">Chapter4/drawables</code> folder of the download bundle into the <code class="literal">drawables</code> folder in Android Studio.</p><div class="mediaobject"><img alt="Multiple different enemy graphics" src="graphics/B04322_04_07.jpg"/><div class="caption"><p>enemy2 and enemy3</p></div></div><p>Now, we just need to <a class="indexterm" id="id00184"/>amend the <code class="literal">EnemyShip</code> constructor. This code generates a random number between 0 and 2, and then switches to load a different enemy bitmap accordingly. Our completed constructor now looks like this:</p><div class="informalexample"><pre class="programlisting">// Constructor
public EnemyShip(Context context, int screenX, int screenY){
<span class="strong"><strong>    Random generator = new Random();</strong></span>
<span class="strong"><strong>    int whichBitmap = generator.nextInt(3);</strong></span>
<span class="strong"><strong>    switch (whichBitmap){</strong></span>
<span class="strong"><strong>        case 0:</strong></span>
<span class="strong"><strong>            bitmap = BitmapFactory.decodeResource</strong></span>
<span class="strong"><strong>            (context.getResources(), R.drawable.enemy3);</strong></span>
<span class="strong"><strong>            break;</strong></span>

<span class="strong"><strong>        case 1:</strong></span>
<span class="strong"><strong>            bitmap = BitmapFactory.decodeResource</strong></span>
<span class="strong"><strong>            (context.getResources(), R.drawable.enemy2);</strong></span>
<span class="strong"><strong>            break;</strong></span>

<span class="strong"><strong>        case 2:</strong></span>
<span class="strong"><strong>            bitmap = BitmapFactory.decodeResource</strong></span>
<span class="strong"><strong>            (context.getResources(), R.drawable.enemy);</strong></span>
<span class="strong"><strong>            break;</strong></span>
<span class="strong"><strong>    }</strong></span>

    maxX = screenX;
    maxY = screenY;
    minX = 0;
    minY = 0;

    speed = generator.nextInt(6)+10;
    x = screenX;
    y = generator.nextInt(maxY) - bitmap.getHeight();

    // Initialize the hit box
    hitBox = new Rect(x, y, bitmap.getWidth(),  bitmap.getHeight());

}</pre></div><p>Note that <a class="indexterm" id="id00185"/>we just need to move the <code class="literal">Random generator = new Random();</code> line of code to the top of the constructor, so we can use it to choose a bitmap as well as generate a random height later in the constructor, as usual.</p></div><div class="section" title="An exercise in balance"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec044"/>An exercise in balance</h2></div></div></div><p>Probably the biggest playability <a class="indexterm" id="id00186"/>issue in the game is the difference in difficulty when playing on a medium/high resolution screen as opposed to a low resolution screen. For example, one of my testing devices is a Samsung Galaxy S2. It is a few years old now, and the screen resolution is 800 x 480 pixels when held in the landscape position. For comparison, I tested the game on a Samsung Galaxy S4 that has 1920 x 1080 pixels in landscape mode. This is more than double the resolution of the S2.</p><p>On the S4, the player seems to effortlessly glide in between the almost insignificant enemies, while on the S2, the player is faced with an almost impenetrable wall of alien steel.</p><p>The real solution to this problem is to draw game objects at pseudo-real-world coordinates, and then map these coordinates back to the device at the same scale, regardless of resolution. This way, the game will look and play the same on both an S2 and an S4. In the next project, we will build a more advanced game engine that does this.</p><p>Of course, we will still have the consideration of the actual physical screen size, making the player's experience varied, but this is a much more accepted situation by gamers.</p><p>As a quick and dirty solution, we will vary the size of the ships and the number of enemies. So on lower resolutions, we will have three enemies, but we will shrink their size. On higher resolutions, we will increase the number of enemies gradually.</p><p>In the <code class="literal">EnemyShip</code> class, just after the <code class="literal">switch</code> block that loads our enemy graphics into our <code class="literal">Bitmap</code> object, add the line shown highlighted to call a new method that we will write soon, <code class="literal">scaleBitmap()</code>:</p><div class="informalexample"><pre class="programlisting">switch (whichBitmap){
    case 0:
          bitmap = BitmapFactory.decodeResource(context.getResources(),           
          R.drawable.enemy3);
          break;

    case 1:
          bitmap = BitmapFactory.decodeResource(context.getResources(),           
          R.drawable.enemy2);
          break;

   case 2:
          bitmap = BitmapFactory.decodeResource(context.getResources(),           
          R.drawable.enemy);
          break;
}

<span class="strong"><strong>scaleBitmap(screenX);</strong></span>
</pre></div><p>Now, we will write<a class="indexterm" id="id00187"/> our new <code class="literal">scaleBitmap</code> method. This simple helper method takes a single argument, which as we have seen is the horizontal resolution of the screen. We then use the resolution and the static <code class="literal">createScaledBitmap</code> method to reduce our <code class="literal">Bitmap</code> objects on a scale of 2 or 3 depending on the resolution of the screen. Add the new <code class="literal">scaleBitmap</code> method to the <code class="literal">EnemyShip</code> class:</p><div class="informalexample"><pre class="programlisting">public void scaleBitmap(int x){

  if(x &lt; 1000) {
       bitmap = Bitmap.createScaledBitmap(bitmap,
       bitmap.getWidth() / 3,
       bitmap.getHeight() / 3,
       false);
  }else if(x &lt; 1200){
       bitmap = Bitmap.createScaledBitmap(bitmap,
       bitmap.getWidth() / 2,
       bitmap.getHeight() / 2,
       false);
   }
}</pre></div><p>The enemies will be scaled down in size on lower resolution screens. Now, let's increase the number of enemies for the higher resolutions.</p><p>For this, we will add code to the <code class="literal">TDView</code> class to add extra enemies to higher resolution screens.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0016"/>Note</h3><p>Warning! This code sucks, but it works and it shows us where we can make improvements in our next project. When planning a game, there is always a trade-off between good design and simplicity. By keeping things organized from the start, we can get away with a bit of hacking near the end. Yes, we can redesign the way we spawn and store our game objects, and if Tappy Defender was an ongoing project then this would be worthwhile.</p></div></div><p>Add two more<a class="indexterm" id="id00188"/> enemy ship objects after the first three, as shown:</p><div class="informalexample"><pre class="programlisting">// Game objects
private PlayerShip player;
public EnemyShip enemy1;
public EnemyShip enemy2;
public EnemyShip enemy3;
<span class="strong"><strong>public EnemyShip enemy4;</strong></span>
<span class="strong"><strong>public EnemyShip enemy5;</strong></span>
</pre></div><p>Now, add code to conditionally initialize these two new objects in the <code class="literal">startGame</code> method:</p><div class="informalexample"><pre class="programlisting">enemy1 = new EnemyShip(context, screenX, screenY);
enemy2 = new EnemyShip(context, screenX, screenY);
enemy3 = new EnemyShip(context, screenX, screenY);

<span class="strong"><strong>if(screenX &gt; 1000){</strong></span>
<span class="strong"><strong>  enemy4 = new EnemyShip(context, screenX, screenY);</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>if(screenX &gt; 1200){</strong></span>
<span class="strong"><strong>  enemy5 = new EnemyShip(context, screenX, screenY);</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Add code in the <code class="literal">update</code> method to update our fourth and fifth enemies and check for collisions:</p><div class="informalexample"><pre class="programlisting">// Collision detection on new positions
// Before move because we are testing last frames
// position which has just been drawn
boolean hitDetected = false;
if(Rect.intersects(player.getHitbox(), enemy1.getHitbox())){
  hitDetected = true;
  enemy1.setX(-100);
}


if(Rect.intersects(player.getHitbox(), enemy2.getHitbox())){
  hitDetected = true;
  enemy2.setX(-100);        
}
        

if(Rect.intersects(player.getHitbox(), enemy3.getHitbox())){
  hitDetected = true;
  enemy3.setX(-100);       
}
        

<span class="strong"><strong>if(screenX &gt; 1000){</strong></span>
<span class="strong"><strong>  if(Rect.intersects(player.getHitbox(), enemy4.getHitbox())){</strong></span>
<span class="strong"><strong>      hitDetected = true;</strong></span>
<span class="strong"><strong>      enemy4.setX(-100);            </strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
        

<span class="strong"><strong>if(screenX &gt; 1200){</strong></span>
<span class="strong"><strong>  if(Rect.intersects(player.getHitbox(), enemy5.getHitbox())){</strong></span>
<span class="strong"><strong>      hitDetected = true;</strong></span>
<span class="strong"><strong>      enemy5.setX(-100);</strong></span>
<span class="strong"><strong>   }</strong></span>
<span class="strong"><strong>}</strong></span>

if(hitDetected) {
soundPool.play(bump, 1, 1, 0, 0, 1);
            player.reduceShieldStrength();
            if (player.getShieldStrength() &lt; 0) {
                soundPool.play(destroyed, 1, 1, 0, 0, 1);
                gameEnded = true;
            }
}


// Update the player
player.update();
// Update the enemies
enemy1.update(player.getSpeed());
enemy2.update(player.getSpeed());
enemy3.update(player.getSpeed());

<span class="strong"><strong>if(screenX &gt; 1000) {</strong></span>
<span class="strong"><strong>  enemy4.update(player.getSpeed());</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>if(screenX &gt; 1200) {</strong></span>
<span class="strong"><strong>  enemy5.update(player.getSpeed());</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Finally, in the <code class="literal">draw</code> method, draw <a class="indexterm" id="id00189"/>our extra enemies when appropriate:</p><div class="informalexample"><pre class="programlisting">// Draw the player
canvas.drawBitmap(player.getBitmap(), player.getX(), player.getY(), paint);
canvas.drawBitmap(enemy1.getBitmap(),
  enemy1.getX(), enemy1.getY(), paint);
canvas.drawBitmap(enemy2.getBitmap(),
  enemy2.getX(), enemy2.getY(), paint);
canvas.drawBitmap(enemy3.getBitmap(),
  enemy3.getX(), enemy3.getY(), paint);

<span class="strong"><strong>if(screenX &gt; 1000) {</strong></span>
<span class="strong"><strong>  canvas.drawBitmap(enemy4.getBitmap(),</strong></span>
<span class="strong"><strong>  enemy4.getX(), enemy4.getY(), paint);</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>if(screenX &gt; 1200) {</strong></span>
<span class="strong"><strong>  canvas.drawBitmap(enemy5.getBitmap(),</strong></span>
<span class="strong"><strong>  enemy5.getX(), enemy5.getY(), paint);</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Of course, we now realize that we may like to scale the player as well. This makes it plain that perhaps we need a <code class="literal">Ship</code> class, from which we can derive <code class="literal">PlayerShip</code> and <code class="literal">EnemyShip</code>.</p><p>Add to this the cumbersome manner in which we added the extra enemies for higher resolution screens and a much more polymorphic solution is probably worthwhile. We will see how we can seriously improve this and virtually every other aspect of our game engine in the next project.</p></div><div class="section" title="Format time"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec045"/>Format time</h2></div></div></div><p>Look at how time is<a class="indexterm" id="id00190"/> formatted in the player's HUD:</p><div class="mediaobject"><img alt="Format time" src="graphics/B04322_04_08.jpg"/></div><p>Yuck! Let's write a simple helper method to make this look a whole lot nicer. We will add a new method to the <code class="literal">TDView</code> class called <code class="literal">formatTime()</code>. The method uses the number of elapsed milliseconds in this game (<code class="literal">timeTaken</code>) and reorganizes them into seconds and fractions of a second. It pads the fractions with zeros where appropriate and returns the result as a <code class="literal">String</code> ready to be drawn in the <code class="literal">TDView</code> class's <code class="literal">draw</code> method. The reason the method takes an argument rather than just using the member variable <code class="literal">timeTaken</code> is so we can reuse this code in a minute.</p><div class="informalexample"><pre class="programlisting">private String formatTime(long time){
    long seconds = (time) / 1000;
    long thousandths = (time) - (seconds * 1000);
    String strThousandths = "" + thousandths;
    if (thousandths &lt; 100){strThousandths = "0" + thousandths;}
    if (thousandths &lt; 10){strThousandths = "0" + strThousandths;}
    String stringTime = "" + seconds + "." + strThousandths;
    return stringTime;
}</pre></div><p>We amend the line that <a class="indexterm" id="id00191"/>draws the time in the player's HUD. For context, in the next piece of code, I have commented out the entirety of the original line and provided the new line, which includes our call to <code class="literal">formatTime()</code>, and highlighted it:</p><div class="informalexample"><pre class="programlisting">//canvas.drawText("Time:" + timeTaken + "s", screenX / 2, 20, paint);
<span class="strong"><strong>canvas.drawText("Time:" + </strong></span>
<span class="strong"><strong>  formatTime(timeTaken) + </strong></span>
<span class="strong"><strong>  "s", screenX / 2, 20, paint);</strong></span>
</pre></div><p>In addition, with one minor change, we can use this formatting on the <span class="strong"><strong>Fastest:</strong></span> label in the HUD as well. Again, the old line is commented out and the new one is highlighted. Find and amend the code in the <code class="literal">TDView</code> class's <code class="literal">draw</code> method:</p><div class="informalexample"><pre class="programlisting">//canvas.drawText("Fastest:" + fastestTime + "s", 10, 20, paint);
<span class="strong"><strong>canvas.drawText("Fastest:" + </strong></span>
<span class="strong"><strong>  formatTime(fastestTime) + </strong></span>
<span class="strong"><strong>  "s", 10, 20, paint);</strong></span>
</pre></div><p>We should also update the time formatting on the pause screen. The lines to change are commented out and the new lines to add are highlighted:</p><div class="informalexample"><pre class="programlisting">// Show pause screen
paint.setTextSize(80);
paint.setTextAlign(Paint.Align.CENTER);
canvas.drawText("Game Over", screenX/2, 100, paint);
paint.setTextSize(25);

// canvas.drawText("Fastest:"
  + fastestTime + "s", screenX/2, 160, paint);
<span class="strong"><strong>canvas.drawText("Fastest:"+ </strong></span>
<span class="strong"><strong>  formatTime(fastestTime) + "s", screenX/2, 160, paint);</strong></span>
                
// canvas.drawText("Time:" + 
  timeTaken + "s", screenX / 2, 200, paint);
<span class="strong"><strong>canvas.drawText("Time:" </strong></span>
<span class="strong"><strong>  + formatTime(timeTaken) + "s", screenX / 2, 200, paint);</strong></span>
                
canvas.drawText("Distance remaining:" +
  distanceRemaining/1000 + " KM",screenX/2, 240, paint);
paint.setTextSize(80);
canvas.drawText("Tap to replay!", screenX/2, 350, paint);</pre></div><p>
<span class="strong"><strong>Fastest:</strong></span> is now<a class="indexterm" id="id00192"/> formatted in the same way as <span class="strong"><strong>Time:</strong></span> on both the in-game HUD and the pause screen HUD. Take a look at our neatly formatted time now:</p><div class="mediaobject"><img alt="Format time" src="graphics/B04322_04_09.jpg"/></div></div><div class="section" title="Handle the back button"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec046"/>Handle the back button</h2></div></div></div><p>We will quickly add a <a class="indexterm" id="id00193"/>small block of code to handle what happens when the player presses the back button on their Android device. Add this new method to both the <code class="literal">GameActivity</code> and <code class="literal">MainActivity</code> classes. We simply check if the back button was pressed, and if it was, call <code class="literal">finish()</code> to let the operating system know we are done with this activity.</p><div class="informalexample"><pre class="programlisting">// If the player hits the back button, quit the app
public boolean onKeyDown(int keyCode, KeyEvent event) {
  if (keyCode == KeyEvent.KEYCODE_BACK) {
       finish();
       return true;
  }
  return false;
}</pre></div></div></div>
<div class="section" title="The finished game"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec030"/>The finished game</h1></div></div></div><p>Finally, in case you are following along for the<a class="indexterm" id="id00194"/> theory and not the practical, here is the finished <code class="literal">GameActivity</code> on a high resolution screen with a few hundred extra stars and shields:</p><div class="mediaobject"><img alt="The finished game" src="graphics/B04322_04_10.jpg"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec031"/>Summary</h1></div></div></div><p>We have implemented the component parts of a basic game engine. We can do so much more. Of course, a modern mobile game will have a lot more going on than in ours. How will we handle collisions when there are lots more game objects? Couldn't we tighten up our class hierarchy a bit, as there were lots of similarities between our <code class="literal">PlayerShip</code> and <code class="literal">EnemyShip</code> classes? How can we add complex internal character animations without confusing the structure of our code, and what if we want smart enemies, enemies who can actually think?</p><p>We need realistic backgrounds, side objectives, power-ups, and pick-ups. We want a game world with real-world coordinates that map back accurately regardless of the resolution of the screen.</p><p>We need a smarter game loop that runs the game at the same speed regardless of the CPU it is being processed on. Most of all, what we really need, more than any of these things, is a dirty big machine gun. Let's build a classic platform game.</p></div>
<div class="chapter" title="Chapter&#xA0;5.&#xA0;Platformer &#x2013; Upgrading the Game Engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 5. Platformer – Upgrading the Game Engine</h1></div></div></div><p>Welcome to the second project of this book. Here, we will build a really tough retro platform game. It is not tough to build, but tough to beat when you play it. At the end of the project, we will also discuss ways to make the game play a little less punishing should you wish.</p><p>This chapter will focus entirely on our game engine and essentially lead to an upgraded version of the Tappy Defender code.</p><p>First, we will discuss what we want to achieve with this game: the backstory, game mechanics, and rules.</p><p>Then, we will quickly create an activity that instantiates a view that will do all the work.</p><p>After that, we will flesh out the basic structure of our <code class="literal">PlatformView</code> class, which will have some subtle, but important differences to our <code class="literal">TDView</code> class. Most notably, <code class="literal">PlatformView</code> will have a simple but effective way of managing the timing of all the events of our game.</p><p>We will then start the iterative process of building our <code class="literal">GameObject</code> class, from which almost every entity of the game world will be derived.</p><p>Next, we will discuss the concept of a viewport through which the game world is viewed by the player. We will no longer be designing our game objects to operate at the level of the screen resolution, but they will now exist in a world with their own <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates that we can think of as virtual meters. There is also a simple system of depth on the <span class="emphasis"><em>z</em></span> axis as well. This will be handled by our new <code class="literal">Viewport</code> class.</p><p>After this, we will look at how we design and layout the content of our game. This is done via a class that is used as a level designer and can be used in a nonprogrammatic way to map out the jumps, enemies, rewards, and goals that constitute the layout of a level.</p><p>To manage the level designs and load them into our game engine, we will need another class. We will call it <code class="literal">LevelManager</code>.</p><p>Finally in this chapter, we will look at our enhanced <code class="literal">update</code> and <code class="literal">draw</code> methods within the <code class="literal">PlatformView</code> class so that we can actually run our new game and see the first output on the screen.</p><p>With so much to do, we better get started.</p><div class="section" title="The game"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec032"/>The game</h1></div></div></div><p>The game we will<a class="indexterm" id="id00195"/> build is based on the game play of some of the brutally hard platform games of the '80s, such as Bounty Bob Strikes Back and Impossible Mission. These games featured difficult jumps and required insanely precise timing at the same time as giving the player an unforgiving number of lives/chances. This style of game works well for us because we can actually build a multilevel playable game in just four chapters.</p><p>The design of the classes will make it really easy for you to add your own extra features, and game objects or make it slightly less challenging to play should you want to.</p><div class="section" title="The backstory"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec047"/>The backstory</h2></div></div></div><p>Our hero Bob, having just returned <a class="indexterm" id="id00196"/>from a secret mission to destroy an evil <a class="indexterm" id="id00197"/>scientist at the center of the Earth, finds he is deep underground. Worse, it seems that although he has defeated the evil scientist, it was not in time to save the planet from the powerful guards and deadly flying robot drones that he unleashed.</p><p>Bob must make his way from the deep underground fiery cave, through the heavily guarded city, and forest, high in the mountains, where he hopes to live, free from the terrifying new order that has taken over the planet.</p><p>On his journey through these four levels, he must avoid guards, destroy drones, collect lots of money, and upgrade his initially puny machine gun.</p></div><div class="section" title="The game mechanics"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec048"/>The game mechanics</h2></div></div></div><p>The game will be about executing precise jumps, planning the best route through a level to collect the loot and escape. Bob<a class="indexterm" id="id00198"/> will be able to stand precariously on ledges <a class="indexterm" id="id00199"/>with whole pixels of his feet overhanging, to be able to make seemingly impossible jumps. Bob will be able to control the distance he travels while jumping, meaning that sometimes he will often need to make sure he doesn't over jump.</p><p>Bob will need to collect machine gun upgrades before attempting to escape via heavily guarded areas.</p><p>Bob will only have three lives, but may be able to find some more on his journey.</p></div><div class="section" title="Rules for the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec049"/>Rules for the game</h2></div></div></div><p>When Bob loses a <a class="indexterm" id="id00200"/>life by being caught by a drone/guard, touching fire, or falling out of the game world, he will respawn at the start of the current<a class="indexterm" id="id00201"/> level. Drones can fly, and will home in on Bob as soon as he comes into view. Bob will need to make sure he has enough firepower to handle the drones. Guards will patrol predetermined parts of the level, but they are tough and can only be knocked back by Bob's machine gun. Usually, Bob will need to execute a precisely timed jump to progress past a guard.</p><p>The environment will also be tough. Bob will need to completely master each level, as one wrong jump will send him plummeting back to the start, straight into the clutches of an enemy or even to his fiery death.</p></div></div></div>
<div class="section" title="Upgrading the game engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec033"/>Upgrading the game engine</h1></div></div></div><p>All the talk of guards, drones, fire, collectibles, guns, and the implied much <a class="indexterm" id="id00202"/>larger game world suggests a much more complex system to manage. One <a class="indexterm" id="id00203"/>of the goals of our game engine will be to make this complexity easily manageable. The other goal will be to separate the level design from the coding. When our game is done, you will be able to sit back and design the most evil, yet rewarding levels, in multiple different environments without touching the code.</p><div class="section" title="The platform activity"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec050"/>The platform activity</h2></div></div></div><p>First we start off with our <code class="literal">Activity</code> class, which<a class="indexterm" id="id00204"/> is the entry point into our game. There is not much new here, so let's go ahead and get it built quickly. Create a new project, and in the <span class="strong"><strong>Application Name</strong></span> field, enter <code class="literal">C5 Platform Game</code>. Choose <span class="strong"><strong>Phones and tablets</strong></span>, then <span class="strong"><strong>Blank Activity</strong></span> when prompted. In the <span class="strong"><strong>Activity Name</strong></span> field, type <code class="literal">PlatformActivity</code>.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0004"/>Tip</h3><p>Obviously you don't have to follow my exact naming choices, but just remember to make minor alterations in the code to reflect your own naming choices.</p></div></div><p>You can delete <code class="literal">activity_platform.xml</code> from the <code class="literal">layout</code> folder. You can also delete all the code within the <code class="literal">PlatformActivity.java</code> file. Just leave the package declaration. Now, we have an entirely blank canvas ready for us to start coding. Here is the entirety of our project so far:</p><div class="informalexample"><pre class="programlisting">package com.gamecodeschool.c5platformgame;</pre></div><p>Let's start building our engine. Just like in our Tappy Defender project, we will build a class to handle the view aspect of our game. Perhaps unsurprisingly, we will call the class <code class="literal">PlatformView</code>. Therefore, our <code class="literal">PlatformActivity</code> class needs to instantiate a <code class="literal">PlatformView</code> object and set it as the main view of the app, just like in the previous project.</p><p>We will be making some significant upgrades to our engine, but this will mainly happen in the view. In the code for the <code class="literal">PlatformActivity</code> class that we will look at next, we do much the same as in the previous project. First, declare the <code class="literal">PlatformView</code> object and set it as the main view in the overridden <code class="literal">onCreate</code> method; however, before we do this, we also capture and pass in the resolution of the device's screen.</p><p>We do this using <a class="indexterm" id="id00205"/>the <code class="literal">Display</code> class and chaining the <code class="literal">getWindowManager()</code> and <code class="literal">getDefaultDisplay()</code> methods to get the properties of the physical display hardware that our game will be running on. Then, we create an object of type <code class="literal">Point</code> called resolution and store the resolution of the display into our <code class="literal">Point</code> object by calling <code class="literal">display.getSize(size)</code>.</p><p>This stores the horizontal and vertical number of pixels of the screen into <code class="literal">size.x</code> and <code class="literal">size.y</code>, respectively. We can then go ahead and instantiate a new <code class="literal">PlatformView</code> object by calling its constructor and passing in the values stored in <code class="literal">size.x</code> and <code class="literal">size.y</code>. As before, we also pass in the application, <code class="literal">Context</code> object (<code class="literal">this</code>) that like in the previous project, we will find many uses for.</p><p>We can then set <code class="literal">platformView</code> as the view by calling <code class="literal">setContentView()</code> in the usual way. As earlier, we override the <code class="literal">Activity</code> class's lifecycle methods <code class="literal">onPause()</code> and <code class="literal">onResume()</code> to have them call their respective methods in our soon-to-be-written <code class="literal">PlatformView</code> class. These two methods can then start and stop our <code class="literal">Thread</code> class.</p><p>Here is the entirety of the code for the <code class="literal">PlatformActivity</code> class that we have just discussed, with no significant new aspects. Type or copy and paste the code into your project. The code for this chapter can be found within the download bundle from the book's page on the Packt Publishing website. All the code and assets from this chapter can be found in the <code class="literal">Chapter5</code> folder. This file is called <code class="literal">PlatformActivity.java</code>.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0005"/>Tip</h3><p>Remember to import all the new classes when prompted to do so, or by pressing the <span class="emphasis"><em>Alt</em></span> | <span class="emphasis"><em>Enter</em></span> keyboard combination while hovering the cursor over the error when a missing class causes this error.</p></div></div><div class="informalexample"><pre class="programlisting">import android.app.Activity;
import android.graphics.Point;
import android.os.Bundle;
import android.view.Display;

public class PlatformActivity extends Activity {

    // Our object to handle the View
    private PlatformView platformView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Get a Display object to access screen details
        Display display = getWindowManager().getDefaultDisplay();

        // Load the resolution into a Point object
        Point resolution = new Point();
        display.getSize(resolution);

        // And finally set the view for our game
        // Also passing in the screen resolution
        platformView = new PlatformView
        (this, resolution.x, resolution.y);

        // Make our platformView the view for the Activity
        setContentView(platformView);

    }

    // If the Activity is paused make sure to pause our thread
    @Override
    protected void onPause() {
        super.onPause();
        platformView.pause();
    }

    // If the Activity is resumed make sure to resume our thread
    @Override
    protected void onResume() {
        super.onResume();
        platformView.resume();
    }
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0017"/>Note</h3><p>Obviously, until we create our <code class="literal">PlatformView</code> class, there will be errors in our <code class="literal">PlatformActivity</code> class's code.</p></div></div></div><div class="section" title="Locking the layout to landscape"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec051"/>Locking the layout to landscape</h2></div></div></div><p>Just as we did for the last<a class="indexterm" id="id00206"/> project, we will make sure the game runs in the landscape mode only. We will make our <code class="literal">AndroidManifest.xml</code> file force our <code class="literal">PlatformActivity</code> class to run with a full screen, and we will also lock it to a landscape layout. Let's make these changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">manifests</code> folder now and double-click the <code class="literal">AndroidManifest.xml</code> file to open it in the code editor.</li><li class="listitem">In the <code class="literal">AndroidManifest.xml</code> file, find the following line of code:<div class="informalexample"><pre class="programlisting">android:name=".PlatformActivity"</pre></div></li><li class="listitem">Immediately after it, type or copy and paste these two lines to make <code class="literal">PlatformActivity</code> run full screen and lock it in the landscape orientation.<div class="informalexample"><pre class="programlisting">android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
android:screenOrientation="landscape"</pre></div></li></ol></div><p>Now, we can move on to the real guts of our game and see how we can implement all these improvements we talked about.</p></div><div class="section" title="The PlatformView class"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec052"/>The PlatformView class</h2></div></div></div><p>This class, by the time it is <a class="indexterm" id="id00207"/>completed, will be dependent on many other <a class="indexterm" id="id00208"/>classes. I don't want to just present each class in turn, as this would be quite hard to follow and exactly what code implements which feature will become confusing. Instead, we will look at, and code, each feature in turn, as we require them, and then revisit many of the classes multiple times to add more features. This will keep the focus on the specific purpose of each part of the code.</p><p>Having said this, great care has been taken so that although we will revisit many of these classes multiple times, we won't be constantly deleting code, just adding to it. When we add to it, the code will be presented in its proper context with the new parts highlighted among the existing code.</p><p>With regard to the structure of the classes, they are designed to be as minimal as possible, while at the same time, not restricting your potential to easily add features and extend the code.</p><p>This is not a lesson in game engine design, but more a lesson in seeing how many different features we can learn to implement and cram into four chapters, without the code becoming unmanageable.</p><p>If you plan to build very large-scale games, especially when working as a team, then a more robust design will be necessary. This more robust design will also mean a whole lot of extra classes, interfaces, packages, and so on.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0006"/>Tip</h3><p>If this type of discussion interests you, I highly recommend the book, <span class="emphasis"><em>Beginning Android Games</em></span> by Mario Zechner, published by APRESS. Mario is the founder/creator of the LibGDX cross-platform game library, and his book goes into great detail about the design patterns required to build a highly extensible and reusable code base for games. The only downside to the great design detail that this book has, is that it would take around 600 pages to build a simple retro Snake game.</p></div></div><p>First, let's create the class. Right-click on the package name in the Android Studio project explorer and navigate <a class="indexterm" id="id00209"/>to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Java Class</strong></span>. Call the new class <code class="literal">PlatformView</code>. Delete <a class="indexterm" id="id00210"/>the autogenerated contents of the class, as we will add our own code soon.</p><p>We will continue to add code to this class over the entirety of the project. The full extent of the code that we add to the class in this chapter can be found in the download bundle at <code class="literal">Chapter5/PlatformView.java</code>.</p><p>We need a class that can manage our level. Let's call it <code class="literal">LevelManager</code>.</p><p>We also need a class that can hold the data for our level, as we can then extend it each time we create a new/different level design. Let's call the parent class <code class="literal">LevelData</code>, and our first real level for Bob to escape from, <code class="literal">LevelCave</code>.</p><p>Furthermore, as this game is going to have many enemies, props, and terrain types, we are going to need a cleaner system of managing them all. We need a fairly generic <code class="literal">GameObject</code> class, which all the different game objects can extend. We can then manage them really easily in our <code class="literal">update</code> and <code class="literal">draw</code> methods.</p><p>We will also, as a matter of necessity, build a slightly more complicated method of detecting the players input. We will create an <code class="literal">InputController</code> class to delegate all of the code from <code class="literal">PlatformView</code>. However, the details of this class we will not see, until we have fully fleshed out our <code class="literal">Player</code> object to represent the player in the next chapter.</p><p>We can quickly code our basic <code class="literal">PlatformView</code> class with very similar code to the first project, but with a few notable exceptions that we will discuss.</p><div class="section" title="The basic structure of PlatformView"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec019"/>The basic structure of PlatformView</h3></div></div></div><p>Here are the necessary imports <a class="indexterm" id="id00211"/>and our member variables to get us started. We will add to these a fair bit as the project continues.</p><p>Note that we also declare three new object types, <code class="literal">lm</code> that will be our <code class="literal">LevelManager</code> class, <code class="literal">vp</code> that will be our <code class="literal">Viewport</code> class, and <code class="literal">ic</code> that is our <code class="literal">InputController</code> class. We will begin working on some of these in this chapter. These declarations will of course show an error until we implement their respective classes.</p><div class="informalexample"><pre class="programlisting">import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

public class PlatformView extends SurfaceView 
  implements Runnable {
  
  private boolean debugging = true;
  private volatile boolean running;
  private Thread gameThread = null;

  // For drawing
  private Paint paint;
  // Canvas could initially be local.
  // But later we will use it outside of draw()
  private Canvas canvas;
  private SurfaceHolder ourHolder;
    
  Context context;
  long startFrameTime;
  long timeThisFrame;
  long fps;

   // Our new engine classes
   private LevelManager lm;
   private Viewport vp;
   InputController ic;</pre></div><p>Here, we have our <code class="literal">PlatformView</code> constructor. At this stage, it does nothing new, in fact, it has less code than our <code class="literal">TDView</code> constructor but it will soon be enhanced. For now, enter the code as shown:</p><div class="informalexample"><pre class="programlisting">PlatformView(Context context, int screenWidth, 
    int screenHeight) {
        
    super(context);
    this.context = context;

    // Initialize our drawing objects
    ourHolder = getHolder();
    paint = new Paint();
}</pre></div><p>Here is our thread's <code class="literal">run</code> method. Note that before the call to <code class="literal">update()</code>, we get the current time in milliseconds<a class="indexterm" id="id00212"/> and put it in the <code class="literal">startFrameTime</code> long variable. Then after <code class="literal">draw()</code> has completed, we make another call to get the system time and measure how many milliseconds have elapsed since the frame started. We then carry out the calculation <code class="literal">fps = 1000 / thisFrameTime</code>, which gives us the number of frames per second our game ran at, in that last frame. This value is stored in the <code class="literal">fps</code> variable. We will be using this all over the place as we proceed with the game. Code the <code class="literal">run</code> method that we have just discussed, like this:</p><div class="informalexample"><pre class="programlisting">@Override
public void run() {

  while (running) {
       startFrameTime = System.currentTimeMillis();

       update();
       draw();

      // Calculate the fps this frame
      // We can then use the result to
      // time animations and movement.
      timeThisFrame = System.currentTimeMillis() - startFrameTime;
            if (timeThisFrame &gt;= 1) {
                fps = 1000 / timeThisFrame;
            }
     }
}</pre></div><p>Later in the chapter, we will see how we manage the extra complexity of multiple object types and update them when necessary. For now, just add an empty <code class="literal">update</code> method to the <code class="literal">PlatformView</code> class like this:</p><div class="informalexample"><pre class="programlisting">private void update() {
  // Our new update() code will go here
}</pre></div><p>Here, we see the familiar parts of our <code class="literal">draw</code> method. Later in this chapter, we will see some of the new code. For now, add the basics of the <code class="literal">draw</code> method as shown next as this will remain unchanged:</p><div class="informalexample"><pre class="programlisting">private void draw() {

     if (ourHolder.getSurface().isValid()){
      //First we lock the area of memory we will be drawing to
      canvas = ourHolder.lockCanvas();

      // Rub out the last frame with arbitrary color
      paint.setColor(Color.argb(255, 0, 0, 255));
      canvas.drawColor(Color.argb(255, 0, 0, 255));
    
      // New drawing code will go here
    
      // Unlock and draw the scene
      ourHolder.unlockCanvasAndPost(canvas);
  }
}</pre></div><p>The last parts of the<a class="indexterm" id="id00213"/> first phase of putting together our view is the <code class="literal">pause</code> and <code class="literal">resume</code> methods, which are called by <code class="literal">PlatformActivity</code> when the corresponding Activity lifecycle methods are called by the operating system. They are unchanged from the previous project, but here they are again for the sake of completeness and being able to follow along easily. Add these methods to the <code class="literal">PlatformView</code> class:</p><div class="informalexample"><pre class="programlisting">// Clean up our thread if the game is interrupted    
public void pause() {
  running = false;
   try {
       gameThread.join();
   } catch (InterruptedException e) {
       Log.e("error", "failed to pause thread");
   }
}

    
// Make a new thread and start it
// Execution moves to our run method
public void resume() {
   running = true;
   gameThread = new Thread(this);
   gameThread.start();
    
}

}// End of PlatformView</pre></div><p>Now, we have the basic outline of our view coded and ready. Let's take our first look at the <code class="literal">GameObject</code> class.</p></div><div class="section" title="The GameObject class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec020"/>The GameObject class</h3></div></div></div><p>We know that we need a parent <a class="indexterm" id="id00214"/>class to hold the vast majority of our game objects as we want to improve on the inflexibility and code duplication of the last project. From the previous project, we also know many of the properties and methods it will require.</p><p>First, we need a simple class to represent the world location of all our future <code class="literal">GameObject</code> classes. This class will hold a detailed location on both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axis. Note that these are totally independent to the coordinates of the pixels of the device on which our game will run. We can think of the <span class="emphasis"><em>z</em></span> coordinate as a layer number. The lower numbers get drawn first. Therefore, create a new Java class, call it <code class="literal">Vector2Point5D</code>, and enter this code:</p><div class="informalexample"><pre class="programlisting">public class Vector2Point5D {

    float x;
    float y;
    int z;
}</pre></div><p>Now, let's have a look at, and code the basic working outline of, the <code class="literal">GameObject</code> class, and then throughout the project, we can come back and add extra features. Create a new Java class and call it <code class="literal">GameObject</code>. Let's look at the code we need to start to make this class useful. First, we import the classes we need.</p><div class="informalexample"><pre class="programlisting">import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;</pre></div><p>When we code <code class="literal">GameObject</code> itself, note that the class does not provide a constructor as this will be handled differently, depending on the specific <code class="literal">GameObject</code> that we are implementing.</p><p>The first variable you will notice in the code is <code class="literal">worldLocation</code>, which, as you may expect, is of type <code class="literal">Vector2Point5D</code>. We then have two float members, which will hold the width and height of the <code class="literal">GameObject</code> class. Next up, we have the Boolean variables <code class="literal">active</code> and <code class="literal">visible</code> which will be used, perhaps to label an object when it is active, visible, or otherwise. We will begin to see later in the chapter how this is of benefit.</p><p>We will also need to know how many frames of internal animation any given object has. The default will be <code class="literal">1</code>, so <code class="literal">animFrameCount</code> is initialized accordingly.</p><p>We then have a <code class="literal">char</code> class<a class="indexterm" id="id00215"/> called <code class="literal">type</code>. This <code class="literal">type</code> variable will determine exactly what any particular <code class="literal">GameObject</code> might be. It will be used extensively. The last member variable for now is <code class="literal">bitmapName</code>. We will see that it will become useful to know the name of the graphic, which represents the appearance of each of our individual objects. Add the member variables we have just discussed:</p><div class="informalexample"><pre class="programlisting">public abstract class GameObject {

    private Vector2Point5D worldLocation;
    private float width;
    private float height;

    private boolean active = true;
    private boolean visible = true;
    private int animFrameCount = 1;
    private char type;

    private String bitmapName;
    </pre></div><p>Now, we can look at the first part of the functionality of <code class="literal">GameObject</code>. We have the abstract method <code class="literal">update()</code>. The plan was that all objects will need to update themselves. Turns out that this was over ambitious in just four chapters, and some of our objects (mainly the platforms and scenery) will just provide an empty <code class="literal">update()</code> implementation. However, there is nothing to stop you making the scenery more interactive than we have time for now, or make the platforms more dynamic and adventurous once we see how things work. Add the abstract <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">public abstract void update(long fps, float gravity);</pre></div><p>We handle our methods that manage our graphics. We have a getter to retrieve <code class="literal">bitmapName</code>. Then, we have <code class="literal">prepareBitmap()</code>, which uses the string <code class="literal">bitmapName</code> to make an Android resource ID from a <code class="literal">.png</code> image file. This file must be present in the <code class="literal">drawable</code> folder of the project. A bitmap is created as we have seen before.</p><p>Now our <code class="literal">prepareBitmap</code> method does something new. It uses the <code class="literal">createScaledBitmap</code> method to change the size of the bitmap we just created. It not only uses the <code class="literal">animFrameCount</code>, which we already discussed, but also the <code class="literal">pixelsPerMetre</code> variable, which is a parameter of the method.</p><p>The idea being, that each device has a <code class="literal">pixelsPerMetre</code> value that is appropriate for the device, which will help us create an identical view of the game across devices with different resolutions. We will see exactly where we get this <code class="literal">pixelsPerMetre</code> value from, when we discuss the <code class="literal">Viewport</code> class. Enter the following methods in the <code class="literal">GameObject</code> class:</p><div class="informalexample"><pre class="programlisting">public String getBitmapName() {
        return bitmapName;
}

public Bitmap prepareBitmap(Context context, 
    String bitmapName, 
    int pixelsPerMetre) {

   // Make a resource id from the bitmapName
   int resID = context.getResources().
        getIdentifier(bitmapName,
        "drawable", context.getPackageName());

       
    // Create the bitmap
    Bitmap bitmap = BitmapFactory.
        decodeResource(context.getResources(),
        resID);

    // Scale the bitmap based on the number of pixels per metre
    // Multiply by the number of frames in the image
    // Default 1 frame
    bitmap = Bitmap.createScaledBitmap(bitmap,
                (int) (width * animFrameCount * pixelsPerMetre),
                (int) (height * pixelsPerMetre),
                false);

    return bitmap;
}</pre></div><p>We also want to be able to <a class="indexterm" id="id00216"/>know where in the world each <code class="literal">GameObject</code> is and, of course, to set where in the world it is. Here are a getter and a setter, which do just that.</p><div class="informalexample"><pre class="programlisting">    public Vector2Point5D getWorldLocation() {
        return worldLocation;
    }

    public void setWorldLocation(float x, float y, int z) {
        this.worldLocation = new Vector2Point5D();
        this.worldLocation.x = x;
        this.worldLocation.y = y;
        this.worldLocation.z = z;
    }</pre></div><p>We also want to be able to both, get and set many of the member variables we have already discussed. These <a class="indexterm" id="id00217"/>getters and setters will do that.</p><div class="informalexample"><pre class="programlisting">    public void setBitmapName(String bitmapName){
        this.bitmapName = bitmapName;
    }


    public float getWidth() {
        return width;
    }

    public void setWidth(float width) {
        this.width = width;
    }

    public float getHeight() {
        return height;
    }

    public void setHeight(float height) {
        this.height = height;
    }</pre></div><p>Furthermore, we will want to check and change the status of our active and visible variables as well.</p><div class="informalexample"><pre class="programlisting">    public boolean isActive() {
        return active;
    }

    public boolean isVisible() {
        return visible;
    }

    public void setVisible(boolean visible) {
        this.visible = visible;
    }</pre></div><p>Set and get <code class="literal">type</code> of each <code class="literal">GameObject</code>.</p><div class="informalexample"><pre class="programlisting">    public char getType() {
        return type;
    }

    public void setType(char type) {
        this.type = type;
    }



}// End of GameObject</pre></div><p>Now, we will create our first of many child classes from <code class="literal">GameObject</code>. Right-click on the package name in the Android Studio explorer and create a class called <code class="literal">Grass</code>. This will be our first basic tile type that the player can walk about on.</p><p>This straightforward code uses the constructor to initialize height, width, type, and its location in the game world. Note that all this information is passed in as parameters to the constructor. The only thing <a class="indexterm" id="id00218"/>the <code class="literal">Grass</code> class "knows", and one of the few things that will differentiate it from some of the other simple <code class="literal">GameObject</code> child classes, is the value used for <code class="literal">bitmapName</code>, which in this case is <code class="literal">turf</code>.</p><p>As discussed previously, we also provide an empty implementation of the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">public class Grass extends GameObject {

    Grass(float worldStartX, float worldStartY, char type) {
        final float HEIGHT = 1;
        final float WIDTH = 1;

        setHeight(HEIGHT); // 1 metre tall
        setWidth(WIDTH); // 1 metre wide

        setType(type);


        // Choose a Bitmap
        setBitmapName("turf");

        // Where does the tile start
        // X and y locations from constructor parameters
        setWorldLocation(worldStartX, worldStartY, 0);
    }

    public void update(long fps, float gravity) {}
}</pre></div><p>Now, add the <code class="literal">turf.png</code> graphic from the <code class="literal">Chapter5/drawable</code> folder in the download bundle to the <code class="literal">drawable</code> folder in Android Studio.</p><p>Finally, we will do an absolute barebones implementation of our <code class="literal">Player</code> class that will also extend <code class="literal">GameObject</code>. We will not be putting any functionality into this class just an <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> world location. This is so that the <code class="literal">Viewport</code> class, which we will implement next, knows where to focus.</p><p>Here is the <code class="literal">Player</code> class, which<a class="indexterm" id="id00219"/> will represent Bob our hero. The class at this stage is as simple and straightforward as, and nearly identical to the <code class="literal">Grass</code> class. This will change and evolve substantially as we progress. Note that we set the type to <code class="literal">p</code>.</p><div class="informalexample"><pre class="programlisting">import android.content.Context;

public class Player extends GameObject {

    Player(Context context, float worldStartX, 
        float worldStartY, int pixelsPerMetre) {
        
        final float HEIGHT = 2;
        final float WIDTH = 1;

        setHeight(HEIGHT); // 2 metre tall
        setWidth(WIDTH); // 1 metre wide

        setType('p');
        
        // Choose a Bitmap
        // This is a sprite sheet with multiple frames
        // of animation. So it will look silly until we animate it
        // In chapter 6.
        
        setBitmapName("player");
        
        // X and y locations from constructor parameters
        
        setWorldLocation(worldStartX, worldStartY, 0);
    
    }
    
    public void update(long fps, float gravity) {
    
    }
}</pre></div><p>Add the <code class="literal">player.png</code> graphic from the <code class="literal">drawable</code> folder in the download bundle to the <code class="literal">drawable</code> folder in Android Studio. The graphic is a multiframe sprite sheet, so it won't display nicely until we animate it in <a class="link" href="ch15.html" title="Chapter 6. Platformer – Bob, Beeps, and Bumps">Chapter 6</a>, <span class="emphasis"><em>Platformer – Bob, Beeps, and Bumps </em></span>, but it will serve its purpose as a placeholder for now.</p><p>As we will see next, the view of the game world that the player sees, will focus on Bob, as you will probably expect.</p></div><div class="section" title="The view through a viewport"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec021"/>The view through a viewport</h3></div></div></div><p>A viewport can be thought<a class="indexterm" id="id00220"/> of as the movie camera that follows the action of our game. It defines the area of the game world that is to be shown to the player. Typically, it will center on Bob.</p><p>It also serves the combined function of making our draw method more efficient by determining which objects are inside and outside the player's field of vision. There is no point drawing or processing a bunch of enemies, if they are not relevant at any given moment.</p><p>This will significantly speed up tasks like collision detection by implementing a first phase of detection by removing objects off screen from the list of objects to check for collisions, and it is surprisingly simple to do.</p><p>Furthermore, our <code class="literal">Viewport</code> class will have the task of translating game world coordinates into appropriate pixel coordinates for drawing on the screen. We will also see how this class calculates the <code class="literal">pixelsPerMetre</code> value that our <code class="literal">GameObject</code> class used in the <code class="literal">prepareBitmap</code> method.</p><p>The <code class="literal">Viewport</code> class really is an all singing and dancing thing. So let's get coding.</p><p>First, we will declare a whole bunch of useful variables. We have another <code class="literal">Vector2Point5D</code>, which will just be used to represent whatever point in the world is currently the central focus in the viewport. Then, we have separate integer values for <code class="literal">pixelsPerMetreX</code> and <code class="literal">pixelsPerMetreY</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0018"/>Note</h3><p>Actually, in this implementation, there is no distinction between <code class="literal">pixelsPerMetrX</code> and <code class="literal">pixelsPerMetreY</code>. However, the <code class="literal">Viewport</code> class can be upgraded to take into account different ratios of width to height of the device, based on screen size, rather than just resolution. We don't do so in this implementation.</p></div></div><p>Next, we simply have the resolution of the screen in both axes: <code class="literal">screenXResolution</code> and <code class="literal">screenYResolution</code>. We then have <code class="literal">screenCentreX</code> and <code class="literal">screenCentreY</code>, which are basically the two previous variables divided by two to find the middle.</p><p>In our list of declared variables, we have <code class="literal">metresToShowX</code> and <code class="literal">metresToShowY</code> that will be the number of meters we will squash into our viewport. Changing these values will show more or less of the game world on screen.</p><p>The last member, we will declare at this point, is the <code class="literal">int numClipped</code>. This we will use to output debugging text to see what effect our <code class="literal">Viewport</code> class is having with regard to making drawing, updates, and multiphase collision detection, more efficient.</p><p>Create a new class called <code class="literal">Viewport</code> and declare the variables we have just discussed:</p><div class="informalexample"><pre class="programlisting">import android.graphics.Rect;

public class Viewport {
    private Vector2Point5D currentViewportWorldCentre;
    private Rect convertedRect;
    private int pixelsPerMetreX;
    private int pixelsPerMetreY;
    private int screenXResolution;
    private int screenYResolution;
    private int screenCentreX;
    private int screenCentreY;
    private int metresToShowX;
    private int metresToShowY;
    private int numClipped;</pre></div><p>Now, let's look at the <a class="indexterm" id="id00221"/>constructor. The constructor just needs to know the resolution of the screen. This is obtained in parameters <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>, which, of course, we assign to <code class="literal">screenXResolution</code> and <code class="literal">screenYResolution</code>, respectively.</p><p>Then, as previously suggested, we divide those two previous variables by two and assign the results to <code class="literal">screenCentreX</code> and <code class="literal">screenCentreY</code>, respectively.</p><p>The <code class="literal">pixelsPerMetreX</code> and <code class="literal">pixelsPerMetreY</code> are calculated by dividing by 32 and 18 (again, respectively), so a device with a resolution of 840 x 400 pixels will have pixels per meter <span class="emphasis"><em>x/y</em></span> of 32/22. Now, we have variables that refer to the number of pixels of screen real estate on the current device that represents a meter of our game world. We will see a number of times in our code, where this will be useful.</p><p>We will actually draw a slightly wider area than this, to make sure we don't have any unsightly gaps/lines around the edge of the screen and assign 34 to <code class="literal">metresToShowX</code> and 20 to <code class="literal">metresToShowY</code>. Now, we have variables that refer to the amount of our game world that we will draw each frame.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0007"/>Tip</h3><p>Once we have some screen output, you can experiment with these values to create a more or less zoomed-in or zoomed-out experience for the player.</p></div></div><p>Nearing the end of the constructor, we create a new <code class="literal">Rect</code> object called <code class="literal">convertedRect</code> that we will see in action soon. We call <code class="literal">new()</code> on <code class="literal">currentViewportWorldCentre</code>, so it is ready for action shortly.</p><div class="informalexample"><pre class="programlisting"> Viewport(int x, int y){
        
        screenXResolution = x;
        screenYResolution = y;

        screenCentreX = screenXResolution / 2;
        screenCentreY = screenYResolution / 2;

        pixelsPerMetreX = screenXResolution / 32;
        pixelsPerMetreY = screenYResolution / 18;

        metresToShowX = 34;
        metresToShowY = 20;

        convertedRect = new Rect();
        currentViewportWorldCentre = new Vector2Point5D();

    
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0019"/>Note</h3><p>If some of the screenshots throughout this project look slightly different to the results you get, it is because some images have been taken using different viewport settings to highlight different aspects of the game world.</p></div></div><p>The first method <a class="indexterm" id="id00222"/>we write for the <code class="literal">Viewport</code> class is <code class="literal">setWorldCentre()</code>. It receives an <span class="emphasis"><em>x</em></span> and a <span class="emphasis"><em>y</em></span> parameter, which is promptly assigned as the <code class="literal">currentWorldCentre</code>. We need this method because of course the player will be moving around in the world, and we need to let the <code class="literal">Viewport</code> class know where Bob is. Also, as we will see in <a class="link" href="ch17.html" title="Chapter 8. Platformer – Putting It All Together">Chapter 8</a>, <span class="emphasis"><em>Putting It All together</em></span>, we will also have a situation where we don't want Bob as the center of attention.</p><div class="informalexample"><pre class="programlisting">void setWorldCentre(float x, float y){
  currentViewportWorldCentre.x  = x;
  currentViewportWorldCentre.y  = y;
}</pre></div><p>Now, a few simple getters and setters that will be useful to us as we progress.</p><div class="informalexample"><pre class="programlisting">public int getScreenWidth(){
  return  screenXResolution;
}

public int getScreenHeight(){
  return  screenYResolution;
}

public int getPixelsPerMetreX(){
  return  pixelsPerMetreX;
}</pre></div><p>We fulfil one of the primary roles of the <code class="literal">Viewport</code> class with the <code class="literal">worldToScreen()</code> method. As the name suggests, this is the method that converts the locations of all the objects currently in the visible viewport from world coordinates to pixel coordinates that can actually be drawn to the screen. It returns our previously prepared <code class="literal">rectToDraw</code> object as the result.</p><p>This is how <code class="literal">worldToScreen()</code> works. It receives the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> world locations of an object along<a class="indexterm" id="id00223"/> with that object's width and height. With these values, each in turn, subtracts the objects world coordinate multiplied by the pixels per meter for the current screen, from the appropriate current world viewport center (<span class="emphasis"><em>x</em></span> or <span class="emphasis"><em>y</em></span>). Then, for the left and top coordinates of the object, the result is subtracted from the pixel screen center value and for the bottom and right coordinates, it is added.</p><p>These values are then packed into the left, top, right, and bottom values of <code class="literal">convertedRect</code> and returned to the <code class="literal">draw</code> method of <code class="literal">PlatformView</code>. Add the <code class="literal">worldToScreen</code> method to the <code class="literal">Viewport</code> class:</p><div class="informalexample"><pre class="programlisting">    
public Rect worldToScreen(
  float objectX, 
  float objectY, 
  float objectWidth, 
  float objectHeight){

   int left = (int) (screenCentreX -               
    ((currentViewportWorldCentre.x - objectX) 
    * pixelsPerMetreX));

    int top =  (int) (screenCentreY -         
    ((currentViewportWorldCentre.y - objectY) 
    * pixelsPerMetreY));

   int right = (int) (left + 
    (objectWidth * 
    pixelsPerMetreX));
        
  int bottom = (int) (top + 
    (objectHeight * 
    pixelsPerMetreY));

  convertedRect.set(left, top, right, bottom);
        
  return convertedRect;
}</pre></div><p>Now, we implement the second primary function of the <code class="literal">Viewport</code> class, removing objects that are currently of no interest to us. We call this clipping, and the method we will call; <code class="literal">clipObjects()</code>.</p><p>Once again, we receive as parameters the <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">width</code>, and <code class="literal">height</code> of an object. The test starts by assuming that we want to clip the current object and we assign <code class="literal">true</code> to clipped.</p><p>Then, the four <a class="indexterm" id="id00224"/>nested <code class="literal">if</code> statements test whether each and every point of the object is within the bounds of the related side of the viewport. If it is, we set <code class="literal">clipped</code> to <code class="literal">false</code>. Some of the levels we will design have in excess of a thousand objects, but we will see that we rarely need to process (update, collision detection, and draw) more than a quarter of them in any given frame. Enter the code for the <code class="literal">clipObjects</code> method:</p><div class="informalexample"><pre class="programlisting">    
public boolean clipObjects(float objectX, 
  float objectY, 
  float objectWidth, 
  float objectHeight) {
        
  boolean clipped = true;

   if (objectX - objectWidth &lt; 
    currentViewportWorldCentre.x + (metresToShowX / 2)) {
            
    if (objectX + objectWidth &gt; 
      currentViewportWorldCentre.x - (metresToShowX / 2)) {
                
      if (objectY - objectHeight &lt;           
        currentViewportWorldCentre.y + 
        (metresToShowY / 2)) {
                    
        if (objectY + objectHeight &gt;       
          currentViewportWorldCentre.y - 
          (metresToShowY / 2)){

                 clipped = false;
        }     
      }
          
    }
      
  }

   // For debugging
   if(clipped){
       numClipped++;
   }

   return clipped;
}</pre></div><p>Now, we provide access to the <code class="literal">numClipped</code> variable so that it can be read and reset to zero each frame. </p><div class="informalexample"><pre class="programlisting">public int getNumClipped(){
  return numClipped;    
}

public void resetNumClipped(){
  numClipped = 0;
}

}// End of Viewport</pre></div><p>Let's declare and<a class="indexterm" id="id00225"/> initialize our <code class="literal">Viewport</code> object. Add this code right after we initialize our <code class="literal">Paint</code> object in the <code class="literal">PlatformView</code> constructor. The new code is shown highlighted here:</p><div class="informalexample"><pre class="programlisting">  // Initialize our drawing objects
  ourHolder = getHolder();
  paint = new Paint();

<span class="strong"><strong>  // Initialize the viewport</strong></span>
<span class="strong"><strong>  vp = new Viewport(screenWidth, screenHeight);</strong></span>
    
}// End of constructor</pre></div><p>We can now describe and position objects in our game world and focus on the precise parts of the world we are interested in. Let's see how we will actually get our objects into that world, so we can then update and draw them as we have done before. We will also look at the concept of a level.</p></div><div class="section" title="Creating the levels"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec022"/>Creating the levels</h3></div></div></div><p>Here, we will see how <a class="indexterm" id="id00226"/>to build our <code class="literal">LevelManager</code>, <code class="literal">LevelData</code>, and our first real level, <code class="literal">LevelCave</code>.</p><p>The <code class="literal">LevelManager</code> class will eventually need a copy of our <code class="literal">InputController</code> class. Therefore, in order to try and keep to our intentions of not having to delete any code, we will include a parameter for <code class="literal">InputController</code> in our <code class="literal">LevelManager</code> constructor.</p><p>Let's quickly create a blank template for our <code class="literal">InputController</code> class. Create a new class in the usual way and call it <code class="literal">InputController</code>. Add this code:</p><div class="informalexample"><pre class="programlisting">public class InputController {
    InputController(int screenWidth, int screenHeight) {
    }
}</pre></div><p>Now, let's look at our, initially, very simple <code class="literal">LevelData</code> class. Create a new class, call it <code class="literal">LevelData</code>, and add this code. At this stage, it holds just an <code class="literal">ArrayList</code> object for <code class="literal">Strings</code>.</p><div class="informalexample"><pre class="programlisting">import java.util.ArrayList;

public class LevelData {
    ArrayList&lt;String&gt; tiles;

    // This class will evolve along with the project

    // Tile types
    // . = no tile
    // 1 = Grass

}</pre></div><p>Next, we can start on what <a class="indexterm" id="id00227"/>will eventually become our first playable level. Create a new class, call it <code class="literal">LevelCave</code>, and add this code:</p><div class="informalexample"><pre class="programlisting">import java.util.ArrayList;

public class LevelCave extends LevelData{
    LevelCave() {
    tiles = new ArrayList&lt;String&gt;();
    this.tiles.add("p.............................................");
    this.tiles.add("..............................................");
    this.tiles.add(".....................111111...................");
    this.tiles.add("..............................................");
    this.tiles.add("............111111............................");
    this.tiles.add("..............................................");
    this.tiles.add(".........1111111..............................");
    this.tiles.add("..............................................");
    this.tiles.add("..............................................");
    this.tiles.add("..............................................");
    this.tiles.add("..............................11111111........");
    this.tiles.add("..............................................");
    }
}</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0008"/>Tip</h3><p>The position of <code class="literal">p</code> for player in the <code class="literal">LevelCave</code> file is arbitrary. As long as it is on there, the <code class="literal">Player</code> object will be initialized. The actual spawn location of the player character is determined by the call to a <code class="literal">loadLevel</code> method, as we will soon see. I usually put the <code class="literal">p</code> for player as the first element on the first line of the map, then it is less likely to be forgotten.</p></div></div><p>Now, let's talk about how this<a class="indexterm" id="id00228"/> level design is going to work. We will enter alpha-numeric characters in the <code class="literal">LevelCave</code> class within the <code class="literal">tiles.add("..."</code> parts of the code. We will enter a different alpha-numeric character depending on which <code class="literal">GameObject</code> we want to place into the level. At the moment, we just have <code class="literal">p</code> to represent the <code class="literal">Player</code> object, a <code class="literal">1</code> to represent a <code class="literal">Grass</code> object, and a period (<code class="literal">.</code>) to represent an empty space of one game world meter square.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0009"/>Tip</h3><p>This implies that the positioning of the <code class="literal">Grass</code> objects with the <code class="literal">1</code> character in the previous block of code can be arranged exactly how you like. This is the case, and whenever we look at the code for our <code class="literal">LevelCave</code> class please feel free to improvise and experiment as you like.</p></div></div><p>As the project continues, we will add more than twenty different <code class="literal">GameObject</code> child classes. Some will be inanimate like <code class="literal">Grass</code>, others will be thinking, aggressive enemies. All will be placeable within our level design.</p><p>Now, we can implement the class to manage our levels. Create a new Java class and call it <code class="literal">LevelManager</code>. Enter the code for the <code class="literal">LevelManager</code> class as we go through, and discuss it a block at a time.</p><p>First, a few import directives.</p><div class="informalexample"><pre class="programlisting">import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Rect;
import java.util.ArrayList;</pre></div><p>Now, the constructor is where we have a <code class="literal">String</code> <code class="literal">level</code> to hold the name of the level, <code class="literal">mapWidth</code> and <code class="literal">mapHeight</code> to store the width and height in game world meters of the current level, a <code class="literal">Player</code> object because we know we will always have one of them, and an <code class="literal">int</code> type called <code class="literal">playerIndex</code>.</p><p>Soon, we will have an <code class="literal">ArrayList</code> object of many <code class="literal">GameObject</code> classes, and it will be handy to always have the index of the <code class="literal">Player</code> object.</p><p>Moving on, we have the <a class="indexterm" id="id00229"/>Boolean <code class="literal">playing</code> because we will need to know when the game is being played or being paused and a float called <code class="literal">gravity</code>.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0010"/>Tip</h3><p>In the context of this project, gravity will not be used to its full potential, but it can easily be manipulated so that different levels have a different gravity. This is why it is in the <code class="literal">LevelManager</code> class.</p></div></div><p>Finally, we declare an object of type <code class="literal">LevelData</code>, an <code class="literal">ArrayList</code> object to hold all our <code class="literal">GameObject</code> objects, an <code class="literal">ArrayList</code> object to hold representations of the players control buttons and a regular array to hold the majority of all the <code class="literal">Bitmap</code> objects we will need.</p><div class="informalexample"><pre class="programlisting">public class LevelManager {

    private String level;
    int mapWidth;
    int mapHeight;

    Player player;
    int playerIndex;

    private boolean playing;
    float gravity;

    LevelData levelData;
    ArrayList&lt;GameObject&gt; gameObjects;

    ArrayList&lt;Rect&gt; currentButtons;
    Bitmap[] bitmapsArray;</pre></div><p>Then, in the constructor, we examine the signature and see that it receives a <code class="literal">Context</code> object, <code class="literal">pixelsPerMetre</code> that will have been determined when the <code class="literal">Viewport</code> class was constructed, <code class="literal">screenWidth</code> again direct from the <code class="literal">Viewport</code> class, a copy of our <code class="literal">InputController</code> class, and then the name of the level to load. The <code class="literal">int</code> parameters, <code class="literal">px</code> and <code class="literal">py</code>, are the starting coordinates for the player.</p><p>We assign the level parameter to our member level, then we switch to determine which class will be our current level. Of course, at the moment, we only have <code class="literal">LevelCave</code>.</p><p>Then, we initialize<a class="indexterm" id="id00230"/> our <code class="literal">gameObject ArrayList</code> and our <code class="literal">bitmapsArray</code>. We then call <code class="literal">loadMapData()</code>, which is a method we will write shortly. After this, we set <code class="literal">playing</code> to <code class="literal">true</code>, and finally we have a getter method to find out what the state of <code class="literal">playing</code> is. Enter the code we have just discussed in the <code class="literal">LevelManager</code> class:</p><div class="informalexample"><pre class="programlisting">public LevelManager(Context context, 
    int pixelsPerMetre, int screenWidth, 
    InputController ic, 
    String level, 
    float px, float py) {

    this.level = level;

    switch (level) {
        case "LevelCave":
        levelData = new LevelCave();
        break;

        // We can add extra levels here

    }

    // To hold all our GameObjects
    gameObjects = new ArrayList&lt;&gt;();

    // To hold 1 of every Bitmap
    bitmapsArray = new Bitmap[25];

    // Load all the GameObjects and Bitmaps
    loadMapData(context, pixelsPerMetre, px, py);

    // Ready to play
    playing = true;
}


public boolean isPlaying() {
    return playing;
}</pre></div><p>Now, we have a really simple method which will enable us to get any <code class="literal">Bitmap</code> object based on the type of <code class="literal">GameObject</code> we are currently dealing with. This way, each <code class="literal">GameObject</code> does not have to hold its own <code class="literal">Bitmap</code> object. For example, we can design a level with hundreds of <code class="literal">Grass</code> objects. This can easily use up the memory of even a modern tablet.</p><p>Our <code class="literal">getBitmap</code> method <a class="indexterm" id="id00231"/>takes an <code class="literal">int</code> value as an index and returns a <code class="literal">Bitmap</code> object. We will see how we access the appropriate value for <code class="literal">index</code> in the next method:</p><div class="informalexample"><pre class="programlisting">    // Each index Corresponds to a bitmap
    public Bitmap getBitmap(char blockType) {

        int index;
        switch (blockType) {
            case '.':
                index = 0;
                break;

            case '1':
                index = 1;
                break;

            case 'p':
                index = 2;
                break;

            default:
                index = 0;
                break;
        }// End switch

        return bitmapsArray[index];

 }// End getBitmap</pre></div><p>This next method will enable us to get the <code class="literal">index</code> with which to call the <code class="literal">getBitmap</code> method. As long as the <code class="literal">char</code> cases correspond with the <code class="literal">type</code> values held by the various <code class="literal">GameObject</code> child classes we create, and the index returned by this method matches the index of the appropriate <code class="literal">Bitmap</code> held in the <code class="literal">bitmapsArray</code>, we will only ever need one copy of each <code class="literal">Bitmap</code> object.</p><div class="informalexample"><pre class="programlisting">// This method allows each GameObject which 'knows'
// its type to get the correct index to its Bitmap
// in the Bitmap array.
public int getBitmapIndex(char blockType) {

    int index;
        switch (blockType) {
            case '.':
                index = 0;
                break;

            case '1':
                index = 1;
                break;

            case 'p':
                index = 2;
                break;

            default:
                index = 0;
                break;
        
        }// End switch

        return index;
    }// End getBitmapIndex()</pre></div><p>Now, we do the real work<a class="indexterm" id="id00232"/> with the <code class="literal">LevelManager</code> class, and load our level from our design. The method needs the <code class="literal">pixelsPerMetre</code> and the <code class="literal">Player</code> objects coordinates in order to do its work. As this is a large method, the explanations and the code have been split into a few sections.</p><p>In this first part, we simply declare an <code class="literal">int</code> type called <code class="literal">index</code> and set it to <code class="literal">-1</code>. As we loop through our level design, it will help us keep track of where we are up to.</p><p>Then, we calculate the height and width of the map using the size of <code class="literal">ArrayList</code> and the length of the first element of <code class="literal">ArrayList</code>, respectively.</p><div class="informalexample"><pre class="programlisting">// For now we just load all the grass tiles
// and the player. Soon we will have many GameObjects
private void loadMapData(Context context, 
  int pixelsPerMetre, 
  float px, float py) {

   char c;

   //Keep track of where we load our game objects
   int currentIndex = -1;

   // how wide and high is the map? Viewport needs to know
   mapHeight = levelData.tiles.size();
   mapWidth = levelData.tiles.get(0).length();</pre></div><p>We enter a nested <code class="literal">for</code> loop starting with the first element of the first string in our <code class="literal">ArrayList</code> object. We work from left to right across the first string before moving on to the second string.</p><p>We check to see if an object other than an empty space (.) is present at the current location, and if it is, we enter a switch block to create the appropriate object at the designated location.</p><p>If we encounter a <code class="literal">1</code>, then<a class="indexterm" id="id00233"/> we add a new <code class="literal">Grass</code> object to <code class="literal">ArrayList</code>, and if we encounter a <code class="literal">p</code>, we initialize the <code class="literal">Player</code> object at the location passed in to the constructor of this <code class="literal">LevelManager</code> class. When a new <code class="literal">Player</code> object is created, we also initialize our <code class="literal">playerIndex</code> and <code class="literal">player</code> object ready for future use.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; levelData.tiles.size(); i++) {
            for (int j = 0; j &lt; 
                    levelData.tiles.get(i).length(); j++) {

                c = levelData.tiles.get(i).charAt(j);

                    // Don't want to load the empty spaces
                    if (c != '.'){ 
                      currentIndex++;
                      switch (c) {

                        case '1':
                            // Add grass to the gameObjects
                            gameObjects.add(new Grass(j, i, c));
                            break;

                        case 'p':
                            // Add a player to the gameObjects
                            gameObjects.add(new Player
                                (context, px, py, 
                                 pixelsPerMetre));

                            // We want the index of the player
                            playerIndex = currentIndex;
                            // We want a reference to the player
                            player = (Player)           
                            gameObjects.get(playerIndex);

                            break;


         
            }// End switch</pre></div><p>If a new object has been added to <code class="literal">gameObjects ArrayList</code>, we need to check if the corresponding bitmap has <a class="indexterm" id="id00234"/>been added to the <code class="literal">bitmapsArray</code>. If it hasn't, we add one using the <code class="literal">prepareBitmap</code> method of the current <code class="literal">GameObject</code> class under consideration. Here is the code to perform this check and prepare the bitmap, if necessary:</p><div class="informalexample"><pre class="programlisting">// If the bitmap isn't prepared yet
if (bitmapsArray[getBitmapIndex(c)] == null) {
    
    // Prepare it now and put it in the bitmapsArrayList
    bitmapsArray[getBitmapIndex(c)] =
        gameObjects.get(currentIndex).
        prepareBitmap(context,                                                
        gameObjects.get(currentIndex).                                                        
        getBitmapName(),                                     
        pixelsPerMetre);

}// End if
                
}// End if (c != '.'){ 
            
}// End for j
        
}// End for i
    
}// End loadMapData()

}// End LevelManager</pre></div><p>Back in the <code class="literal">PlatformView</code> class, to put all our level objects to use, we call <code class="literal">loadLevel()</code> just after where we initialized our <code class="literal">Viewport</code> class in the <code class="literal">PlatformView</code> constructor. The new code has been highlighted, and the existing code is provided for context:</p><div class="informalexample"><pre class="programlisting">  // Initialize the viewport
  vp = new Viewport(screenWidth, screenHeight);

<span class="strong"><strong>  // Load the first level</strong></span>
<span class="strong"><strong>  loadLevel("LevelCave", 15, 2);</strong></span>
  
}</pre></div><p>Of course, now we need to implement the <code class="literal">loadLevel</code> method within the <code class="literal">PlatformView</code> class.</p><p>The <code class="literal">loadLevel</code> method needs to know which level to load, so the <code class="literal">switch</code> statement in the <code class="literal">LevelManager</code> constructor can do its work, and it also needs the coordinates to spawn our hero Bob.</p><p>We initialize our <code class="literal">LevelManager</code> object by calling its constructor with the viewport data retrieved from <code class="literal">vp</code> and the level/player data we have just discussed.</p><p>We then create a new <code class="literal">InputController</code> class, again passing in some data from <code class="literal">vp</code>. We will see exactly what we do<a class="indexterm" id="id00235"/> with this data when we build our <code class="literal">InputController</code> class in <a class="link" href="ch15.html" title="Chapter 6. Platformer – Bob, Beeps, and Bumps">Chapter 6</a>, <span class="emphasis"><em>Bob, Beeps, and Bumps</em></span>. Finally, we call <code class="literal">vp.setWorldCentre()</code> and pass it in the player's location as the coordinates. This centers the screen on Bob.</p><div class="informalexample"><pre class="programlisting">public void loadLevel(String level, float px, float py) {
        
    
    lm = null;

    // Create a new LevelManager
    // Pass in a Context, screen details, level name 
    // and player location
    lm = new LevelManager(context, 
        vp.getPixelsPerMetreX(), 
        vp.getScreenWidth(), 
        ic, level, px, py);
        
    ic = new InputController(vp.getScreenWidth(),       
        vp.getScreenHeight());

    // Set the players location as the world centre     
    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)
        .getWorldLocation().x,
        lm.gameObjects.get(lm.playerIndex)
        .getWorldLocation().y);
    }</pre></div><p>We can add some code to our <code class="literal">update</code> method that will be first to utilize a primary function of our new <code class="literal">Viewport</code> class.</p></div><div class="section" title="The enhanced update method"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec023"/>The enhanced update method</h3></div></div></div><p>At last, we can use our <a class="indexterm" id="id00236"/>handy <code class="literal">ArrayList</code> of game objects and our <code class="literal">Viewport</code> functionality to flesh out our enhanced <code class="literal">update</code> method. In the code that follows, we simply use an enhanced <code class="literal">for</code> loop to go through each <code class="literal">GameObject</code>. We check if it <code class="literal">isActive()</code>, and then send the object's location and dimensions to <code class="literal">clipObjects()</code> wrapped in an <code class="literal">if</code> statement. If <code class="literal">clipObjects()</code> returns <code class="literal">false</code>, then the object is not clipped and the object is flagged as visible by calling <code class="literal">go.setVisible(true)</code>. Otherwise, it is flagged as not visible calling <code class="literal">go.setVisible(false)</code>. This is the only aspect of any object that is updated at the moment. We will see when we run the game, at the end of the chapter, that it is already useful. Enter the new code in the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">for (GameObject go : lm.gameObjects) {
        if (go.isActive()) {
            // Clip anything off-screen
            if (!vp.clipObjects(go.getWorldLocation().x,                                
                go.getWorldLocation().y, 
                go.getWidth(), 
                go.getHeight())) {

                // Set visible flag to true
                go.setVisible(true);

            } else {
                // Set visible flag to false
                go.setVisible(false);
                // Now draw() can ignore them
                
            }
        }

    }
}</pre></div></div><div class="section" title="The enhanced draw method"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec024"/>The enhanced draw method</h3></div></div></div><p>Now, we can be more <a class="indexterm" id="id00237"/>precise about which objects we need to draw. First, we declare and initialize a new <code class="literal">Rect</code> object called <code class="literal">toScreen2d</code>.</p><p>Then, we loop through our <code class="literal">gameObjects ArrayList</code> once for each layer starting with the lowest layer. This isn't strictly necessary at this stage because all our objects are, by default, currently on layer zero. We will add objects on layer -1 and 1 before the end of the project, and we don't want to have to rewrite code if we can help it.</p><p>Next, we check if the object is visible and on the current layer. If it is, we pass the current object's location and dimensions to the <code class="literal">worldToScreen</code> method, which returns the result to our previously prepared <code class="literal">toScreen2d Rect</code> object. Then, we call <code class="literal">drawBitmap()</code> using our <code class="literal">bitmapArray</code> to provide the appropriate bitmap, and pass in the coordinates of <code class="literal">toScreen2d</code>. Update <a class="indexterm" id="id00238"/>the <code class="literal">draw</code> method as highlighted:</p><div class="informalexample"><pre class="programlisting">private void draw() {

    if (ourHolder.getSurface().isValid()) {
        //First we lock the area of memory we will be drawing to
        canvas = ourHolder.lockCanvas();

        // Rub out the last frame with arbitrary color
        paint.setColor(Color.argb(255, 0, 0, 255));
        canvas.drawColor(Color.argb(255, 0, 0, 255));
<span class="strong"><strong>        // Draw all the GameObjects</strong></span>
<span class="strong"><strong>          Rect toScreen2d = new Rect();</strong></span>

<span class="strong"><strong>          // Draw a layer at a time</strong></span>
<span class="strong"><strong>          for (int layer = -1; layer &lt;= 1; layer++){</strong></span>
<span class="strong"><strong>          for (GameObject go : lm.gameObjects) {</strong></span>
<span class="strong"><strong>              //Only draw if visible and this layer</strong></span>
<span class="strong"><strong>              if (go.isVisible() &amp;&amp; go.getWorldLocation().z </strong></span>
<span class="strong"><strong>                == layer) { </strong></span>
<span class="strong"><strong>                                                                            </strong></span>
<span class="strong"><strong>                  toScreen2d.set(vp.worldToScreen</strong></span>
<span class="strong"><strong>                  (go.getWorldLocation().x,</strong></span>
<span class="strong"><strong>                  go.getWorldLocation().y,</strong></span>
<span class="strong"><strong>                  go.getWidth(),</strong></span>
<span class="strong"><strong>                  go.getHeight()));</strong></span>

<span class="strong"><strong>                // Draw the appropriate bitmap</strong></span>
<span class="strong"><strong>                canvas.drawBitmap(</strong></span>
<span class="strong"><strong>                   lm.bitmapsArray</strong></span>
<span class="strong"><strong>                   [lm.getBitmapIndex(go.getType())],</strong></span>
<span class="strong"><strong>                   toScreen2d.left,</strong></span>
<span class="strong"><strong>                   toScreen2d.top, paint);</strong></span>
<span class="strong"><strong>            }</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Now, still in the <code class="literal">draw</code> method, we print debugging info to the screen, including the size of our <code class="literal">gameObjects ArrayList</code> compared to the number of objects that were clipped this frame.</p><p>Then, we finish the <code class="literal">draw</code> method by the usual call to <code class="literal">unlockCanvasAndPost()</code>. Note that at the end of the <code class="literal">if(debugging)</code> block, we call <code class="literal">vp.resetNumClipped</code> to set the <code class="literal">numClipped</code> variable<a class="indexterm" id="id00239"/> back to zero ready for the next frame. Add this code straight after the previous block of code in the <code class="literal">draw</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Text for debugging</strong></span>
<span class="strong"><strong>if (debugging) {</strong></span>
<span class="strong"><strong>   paint.setTextSize(16);</strong></span>
<span class="strong"><strong>   paint.setTextAlign(Paint.Align.LEFT);</strong></span>
<span class="strong"><strong>   paint.setColor(Color.argb(255, 255, 255, 255));</strong></span>
<span class="strong"><strong>   canvas.drawText("fps:" + fps, 10, 60, paint);</strong></span>
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong>    canvas.drawText("num objects:" + </strong></span>
<span class="strong"><strong>        lm.gameObjects.size(), 10, 80, paint);</strong></span>
<span class="strong"><strong>                </strong></span>
<span class="strong"><strong>    canvas.drawText("num clipped:" + </strong></span>
<span class="strong"><strong>        vp.getNumClipped(), 10, 100, paint);</strong></span>
<span class="strong"><strong>                </strong></span>
<span class="strong"><strong>    canvas.drawText("playerX:" +                        </strong></span>
<span class="strong"><strong>        lm.gameObjects.get(lm.playerIndex).</strong></span>
<span class="strong"><strong>        getWorldLocation().x,</strong></span>
<span class="strong"><strong>        10, 120, paint);</strong></span>

<span class="strong"><strong>    canvas.drawText("playerY:" +            </strong></span>
<span class="strong"><strong>        lm.gameObjects.get(lm.playerIndex).</strong></span>
<span class="strong"><strong>        getWorldLocation().y, </strong></span>
<span class="strong"><strong>        10, 140, paint);</strong></span>

<span class="strong"><strong>    //for reset the number of clipped objects each frame</strong></span>
<span class="strong"><strong>    vp.resetNumClipped();</strong></span>

<span class="strong"><strong>}// End if(debugging)</strong></span>

// Unlock and draw the scene
ourHolder.unlockCanvasAndPost(canvas);

}// End (ourHolder.getSurface().isValid())
}// End draw()</pre></div><p>For the first time in this project, we can actually run our game and see some results:</p><div class="mediaobject"><img alt="The enhanced draw method" src="graphics/B04322_05_03.jpg"/></div><p>Note in the image<a class="indexterm" id="id00240"/> the precise layout of the grass from our <code class="literal">LevelCave</code> design. You can also see our squashed Bob sprite sheet and the fact that there are 28 objects, but 10 of them have been clipped. As our levels get bigger, the ratio of clipped to unclipped will dramatically increase in favor of the vast majority being clipped.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec034"/>Summary</h1></div></div></div><p>We have covered a lot of ground in this chapter, and now have a well fleshed-out game engine.</p><p>As we have done much of the setup work, from now on, most of the code we add will also have a visible (or audible) result and be much more satisfying, as we will be able to regularly run our game to see the improvements.</p><p>In the next chapter, we will add sound effects and input detection, thus bringing Bob to life. Then, we will see how dangerous his world can be, and will promptly add collision detection so that he can stand on a platform.</p></div>
<div class="chapter" title="Chapter&#xA0;6.&#xA0;Platformer &#x2013; Bob, Beeps, and Bumps"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 6. Platformer – Bob, Beeps, and Bumps</h1></div></div></div><p>Now that our basic game engine is set up, we can start making some fast progress. In this chapter, we will quickly add a <code class="literal">SoundManager</code> class that we will use to make a noise wherever and whenever we please. After that, we will put some meat on the bones of Bob and implement the core functionality we require in the <code class="literal">Player</code> class. Then, we can handle the second phase (after clipping) of our multiphase collision detection and give Bob the useful skill of being able to stand on a platform.</p><p>After we have achieved this significant feat, we will hand over control of Bob to the player by implementing the <code class="literal">InputController</code> class. Bob will at last be able to run around and jump. At the end of this chapter, we will animate Bob's sprite sheet so he actually appears to run, rather than slide everywhere.</p><div class="section" title="The SoundManager class"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec035"/>The SoundManager class</h1></div></div></div><p>Throughout the next<a class="indexterm" id="id00241"/> few chapters, we will be adding sound effects for various events. Sometimes these sounds will be triggered directly in the main <code class="literal">PlatformView</code> class, but other times, they will need to be triggered in more remote corners of your code like the <code class="literal">InputController</code> class and even within the <code class="literal">GameObject</code> class themselves. We will quickly make a simple <code class="literal">SoundManager</code> class that can be passed around and used as needed when a beep is required.</p><p>Create a new Java class and call it <code class="literal">SoundManager</code>. This class has three main parts. In the first part, we simply declare a <code class="literal">SoundPool</code> object and a bunch of <code class="literal">int</code> variables to hold a reference to each sound effect. Enter the first part of the code, the declaration, and members:</p><div class="informalexample"><pre class="programlisting">import android.content.Context;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;
import android.media.AudioManager;
import android.media.SoundPool;
import android.util.Log;

import java.io.IOException;

public class SoundManager {
    private SoundPool soundPool;
    int shoot = -1;
    int jump = -1;
    int teleport = -1;
    int coin_pickup = -1;
    int gun_upgrade = -1;
    int player_burn = -1;
    int ricochet = -1;
    int hit_guard = -1;
    int explode = -1;
    int extra_life = -1;</pre></div><p>The second part <a class="indexterm" id="id00242"/>of the class is the <code class="literal">loadSound</code> method, which unsurprisingly loads all the sounds into memory ready for playing. We will call this once we have initialized a <code class="literal">SoundManager</code> object in the <code class="literal">PlatformView</code> constructor. Enter this code next:</p><div class="informalexample"><pre class="programlisting">public void loadSound(Context context){
    soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);
    try{
        //Create objects of the 2 required classes
        AssetManager assetManager = context.getAssets();
        AssetFileDescriptor descriptor;

        //create our fx
        descriptor = assetManager.openFd("shoot.ogg");
        shoot = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("jump.ogg");
        jump = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("teleport.ogg");
        teleport = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("coin_pickup.ogg");
        coin_pickup = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("gun_upgrade.ogg");
        gun_upgrade = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("player_burn.ogg");
        player_burn = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("ricochet.ogg");
        ricochet = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("hit_guard.ogg");
        hit_guard = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("explode.ogg");
        explode = soundPool.load(descriptor, 0);

        descriptor = assetManager.openFd("extra_life.ogg");
        extra_life = soundPool.load(descriptor, 0);

    }catch(IOException e){
        //Print an error message to the console
        Log.e("error", "failed to load sound files");
        
    }
    
}</pre></div><p>Finally for <a class="indexterm" id="id00243"/>our <code class="literal">SoundManager</code> class, we need to be able to play any sound we like. This <code class="literal">playSound</code> method simply switches on a string passed in as a parameter. When we have a <code class="literal">SoundManager</code> object, we can just call <code class="literal">playSound()</code> with an appropriate string argument:</p><div class="informalexample"><pre class="programlisting">public void playSound(String sound){
        switch (sound){
            case "shoot":
                soundPool.play(shoot, 1, 1, 0, 0, 1);
                break;

            case "jump":
                soundPool.play(jump, 1, 1, 0, 0, 1);
                break;

            case "teleport":
                soundPool.play(teleport, 1, 1, 0, 0, 1);
                break;

            case "coin_pickup":
                soundPool.play(coin_pickup, 1, 1, 0, 0, 1);
                break;

            case "gun_upgrade":
                soundPool.play(gun_upgrade, 1, 1, 0, 0, 1);
                break;

            case "player_burn":
                soundPool.play(player_burn, 1, 1, 0, 0, 1);
                break;

            case "ricochet":
                soundPool.play(ricochet, 1, 1, 0, 0, 1);
                break;

            case "hit_guard":
                soundPool.play(hit_guard, 1, 1, 0, 0, 1);
                break;

            case "explode":
                soundPool.play(explode, 1, 1, 0, 0, 1);
                break;

            case "extra_life":
                soundPool.play(extra_life, 1, 1, 0, 0, 1);
                break;

        }

    }
}// End SoundManager</pre></div><p>Declare a <a class="indexterm" id="id00244"/>new object of type <code class="literal">SoundManager</code> after the <code class="literal">PlatformView</code> class declaration after your new game engine classes from the previous chapter.</p><div class="informalexample"><pre class="programlisting">// Our new engine classes
private LevelManager lm;
private Viewport vp;
InputController ic;
<span class="strong"><strong>SoundManager sm;</strong></span>
</pre></div><p>Next, initialize the <code class="literal">SoundManager</code> object and call <code class="literal">loadSound()</code> in the <code class="literal">PlatformView</code> constructor as shown:</p><div class="informalexample"><pre class="programlisting">// Initialize the viewport
vp = new Viewport(screenWidth, screenHeight);
       
<span class="strong"><strong>sm = new SoundManager();</strong></span>
<span class="strong"><strong>sm.loadSound(context);</strong></span>

loadLevel("LevelCave", 15, 2);</pre></div><p>You can<a class="indexterm" id="id00245"/> create all your own sounds using BFXR or just copy mine from the <code class="literal">Chapter6/assets</code> folder. Copy all the sounds to the <code class="literal">assets</code> folder in your Android Studio project. Create an <code class="literal">assets</code> folder in the <code class="literal">src/main</code> folder of your project in order to achieve this if the folder doesn't exist already.</p><p>Now, we can play sound effects wherever we like. It's time to bring our hero Bob to life.</p></div></div>
<div class="section" title="Introducing Bob"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec036"/>Introducing Bob</h1></div></div></div><p>Here, we can add <a class="indexterm" id="id00246"/>the meat to the bones of your <code class="literal">Player</code> class. However, this section won't be the last time we revisit the <code class="literal">Player</code> class. Now, we will add the necessary functionality to allow Bob to move. Immediately after we have done this, we will add the code to allow the player to use the forthcoming collision detection code and the <code class="literal">Animation</code> class.</p><p>First of all, we need to add some members to the <code class="literal">Player</code> class. The <code class="literal">Player</code> class will need to know how fast it can move, when the player is pressing the left or right controls, and if it is falling or jumping. In addition, the <code class="literal">Player</code> class needs to know how long it has been jumping and how long it should jump for.</p><p>The next block of code provides variables for us to monitor all these things. We will very soon see, how we use them to make Bob do what we want.</p><p>Now, we know what the variables are for. We can add this code right after the class declaration as shown:</p><div class="informalexample"><pre class="programlisting">public class Player extends GameObject {

<span class="strong"><strong>    final float MAX_X_VELOCITY = 10;</strong></span>
<span class="strong"><strong>    boolean isPressingRight = false;</strong></span>
<span class="strong"><strong>     boolean isPressingLeft = false;</strong></span>


<span class="strong"><strong>     public boolean isFalling;</strong></span>
<span class="strong"><strong>     private boolean isJumping;</strong></span>
<span class="strong"><strong>     private long jumpTime;</strong></span>
<span class="strong"><strong>     private long maxJumpTime = 700;// jump 7 10ths of second</strong></span>
</pre></div><p>Furthermore, there are some other movement-related conditions we will need to track, but they will be useful in other classes as well. Therefore, we will add them as members to the <code class="literal">GameObject</code> class. We will track the current horizontal and vertical speed, the direction the object is facing, and whether the object can move at all with the following variables. Add these to the <code class="literal">GameObject</code> class:</p><div class="informalexample"><pre class="programlisting">private float xVelocity;
private float yVelocity;
final int LEFT = -1;
final int RIGHT = 1;
private int facing;
private boolean moves = false;</pre></div><p>Now, in <a class="indexterm" id="id00247"/>the <code class="literal">GameObject</code> class, we will add a <code class="literal">move</code> method. This method simply checks that the velocity on either of the axes is not zero and if it is, it moves the object by changing its <code class="literal">worldLocation</code> object. This method uses the velocity (either <code class="literal">xVelocity</code> or <code class="literal">yVelocity</code>) divided by the current frames per second to calculate the distance to move each frame. This ensures that the movement will be exactly correct, regardless of the current frames per second. It doesn't matter if our game executes smoothly or fluctuates a bit, or how powerful or puny the CPU in the Android device is. We will very soon call this <code class="literal">move</code> method from within the <code class="literal">update</code> method of the <code class="literal">Player</code> class. Later in the project, we will call it from other classes as well.</p><div class="informalexample"><pre class="programlisting">void move(long fps){
        if(xVelocity != 0) {
            this.worldLocation.x += xVelocity / fps;
        }

        if(yVelocity != 0) {
            this.worldLocation.y += yVelocity / fps;
        }
    }</pre></div><p>Next, in the <code class="literal">GameObject</code> class, we have a bunch of getters and setters for the new variables we added previously. The only part to note is that the setters for the two velocity variables (<code class="literal">setxVelocity</code> and <code class="literal">setyVelocity</code>) check <code class="literal">if(moves)</code> before actually assigning a value. Add these new getters and setters to the <code class="literal">GameObject</code> class.</p><div class="informalexample"><pre class="programlisting">public int getFacing() {
  return facing;
}
    
public void setFacing(int facing) {
  this.facing = facing;
}

public float getxVelocity() {
  return xVelocity;
}

public void setxVelocity(float xVelocity) {
  // Only allow for objects that can move
  if(moves) {
    this.xVelocity = xVelocity;
  }
}

public float getyVelocity() {
  return yVelocity;
}

public void setyVelocity(float yVelocity) {
  // Only allow for objects that can move
  if(moves) {
    this.yVelocity = yVelocity;
  }
}

public boolean isMoves() {
  return moves;
}

public void setMoves(boolean moves) {
  this.moves = moves;
}

public void setActive(boolean active) {
  this.active = active;
}</pre></div><p>Now, back in <a class="indexterm" id="id00248"/>the <code class="literal">Player</code> class constructor, we can use some of these new methods to set up the object at creation time. Add the highlighted code to the <code class="literal">Player</code> constructor:</p><div class="informalexample"><pre class="programlisting">setHeight(HEIGHT); // 2 metre tall
setWidth(WIDTH); // 1 metre wide
<span class="strong"><strong>      </strong></span>
<span class="strong"><strong>// Standing still to start with</strong></span>
<span class="strong"><strong>setxVelocity(0);</strong></span>
<span class="strong"><strong>setyVelocity(0);</strong></span>
<span class="strong"><strong>setFacing(LEFT);</strong></span>
<span class="strong"><strong>isFalling = false;</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>// Now for the player's other attributes</strong></span>
<span class="strong"><strong>// Our game engine will use these</strong></span>
<span class="strong"><strong>setMoves(true);</strong></span>
<span class="strong"><strong>setActive(true);</strong></span>
<span class="strong"><strong>setVisible(true);</strong></span>
<span class="strong"><strong>//...</strong></span>
</pre></div><p>At last, we can make practical use of all this new code in the <code class="literal">Player</code> class's <code class="literal">update</code> method.</p><p>First, we handle what happens when <code class="literal">isPressingRight</code> or <code class="literal">isPressingLeft</code> is true. Of course, we still need to be able to set these variables via touches on the screen. Very simply, this next code block sets the horizontal velocity to <code class="literal">MAX_X_VELOCITY</code> if <code class="literal">isPressingRight</code> is true or to <code class="literal">-MAX_X_VELOCITY</code> if <code class="literal">isPressingLeft</code> is true. If neither is true, it sets the horizontal velocity to zero, which is standing still.</p><div class="informalexample"><pre class="programlisting">public void update(long fps, float gravity) {
<span class="strong"><strong>        if (isPressingRight) {</strong></span>
<span class="strong"><strong>            this.setxVelocity(MAX_X_VELOCITY);</strong></span>
<span class="strong"><strong>        } else if (isPressingLeft) {</strong></span>
<span class="strong"><strong>            this.setxVelocity(-MAX_X_VELOCITY);</strong></span>
<span class="strong"><strong>        } else {</strong></span>
<span class="strong"><strong>            this.setxVelocity(0);</strong></span>
<span class="strong"><strong>        }</strong></span>
</pre></div><p>Next, we check which way the player is moving and call <code class="literal">setFacing()</code> with either <code class="literal">RIGHT</code> or <code class="literal">LEFT</code> as the argument.</p><div class="informalexample"><pre class="programlisting">//which way is player facing?
if (this.getxVelocity() &gt; 0) {
  //facing right
  setFacing(RIGHT);
} else if (this.getxVelocity() &lt; 0) {
  //facing left
  setFacing(LEFT);
}//if 0 then unchanged</pre></div><p>Now, we <a class="indexterm" id="id00249"/>can handle jumping. When the player presses the jump button, if successful, <code class="literal">isJumping</code> will be set to true and <code class="literal">jumpTime</code> will be set to whatever the current system time is. So we can then enter the <code class="literal">if(isJumping)</code> block on each frame, test how long Bob has been jumping for, and if he has not exceeded <code class="literal">maxJumpTime</code> take one of two possible actions.</p><p>Action one is; if we are less than half way through the jump, the <span class="emphasis"><em>y</em></span> velocity is set to <code class="literal">-gravity</code> (going up). Action two is; if Bob is more than half way through the jump, his <span class="emphasis"><em>y</em></span> velocity is set to <code class="literal">gravity</code> (going down).</p><p>When <code class="literal">maxJumpTime</code> is exceeded, <code class="literal">isJumping</code> is set back to false until the next time the player taps the jump button. The final <code class="literal">else</code> clause in the following code executes whenever <code class="literal">isJumping</code> is false and sets the player's <code class="literal">y</code> velocity to <code class="literal">gravity</code>. Note that the additional line of code that sets <code class="literal">isFalling</code> to <code class="literal">true</code>. As we will see, this variable is used to control what happens when the player initially tries to jump and also in parts of our collision detection code. It basically stops the player from being able to jump in mid air.</p><div class="informalexample"><pre class="programlisting">// Jumping and gravity
if (isJumping) {
  long timeJumping = System.currentTimeMillis() - jumpTime;
  if (timeJumping &lt; maxJumpTime) {
    if (timeJumping &lt; maxJumpTime / 2) {
      this.setyVelocity(-gravity);//on the way up
       } else if (timeJumping &gt; maxJumpTime / 2) {
          this.setyVelocity(gravity);//going down
       }
  } else {
    isJumping = false;
  }
} else {
      this.setyVelocity(gravity);
      // Read Me!
      // Remove this next line to make the game easier
      // it means the long jumps are less punishing
      // because the player can take off just after the platform
      // They will also be able to cheat by jumping in thin air
      isFalling = true;
}</pre></div><p>Immediately <a class="indexterm" id="id00250"/>after we handle jumping, we call <code class="literal">move()</code> to update the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates, if they have changed.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  // Let's go!</strong></span>
<span class="strong"><strong>  this.move(fps);</strong></span>
}// end update()</pre></div><p>That was a bit of a mouthful, but apart from the actual controls, it is just about everything we need to allow the player to move. We just need to call the <code class="literal">update</code>() method from our <code class="literal">PlatformView</code> class's <code class="literal">update</code> method once each frame, and our player character will spring into action.</p><p>In the <code class="literal">update</code> method of the <code class="literal">PlatformView</code> class, add the following code as shown highlighted:</p><div class="informalexample"><pre class="programlisting">// Set visible flag to true
go.setVisible(true);

<span class="strong"><strong>if (lm.isPlaying()) {</strong></span>
<span class="strong"><strong>  // Run any un-clipped updates</strong></span>
<span class="strong"><strong>  go.update(fps, lm.gravity);</strong></span>
<span class="strong"><strong>}</strong></span>

} else {
  // Set visible flag to false
  //...</pre></div><p>Next, we can<a class="indexterm" id="id00251"/> see what is going on. Let's add some more text output to the <code class="literal">if(debugging)</code> block in the <code class="literal">draw</code> method of <code class="literal">PlatformView</code>. Add the new highlighted code as shown here:</p><div class="informalexample"><pre class="programlisting">canvas.drawText("playerY:" +   lm.gameObjects.get(lm.playerIndex).getWorldLocation().y,
  10, 140, paint);

<span class="strong"><strong>canvas.drawText("Gravity:" + </strong></span>
<span class="strong"><strong>  lm.gravity, 10, 160, paint);</strong></span>
<span class="strong"><strong>                </strong></span>
<span class="strong"><strong>canvas.drawText("X velocity:" +   lm.gameObjects.get(lm.playerIndex).getxVelocity(), </strong></span>
<span class="strong"><strong>  10, 180, paint);</strong></span>
<span class="strong"><strong>                </strong></span>
<span class="strong"><strong>canvas.drawText("Y velocity:" +   lm.gameObjects.get(lm.playerIndex).getyVelocity(), </strong></span>
<span class="strong"><strong>  10, 200, paint);</strong></span>
                
//for reset the number of clipped objects each frame</pre></div><p>Why not run the game now? You have probably noticed the next issue is that the player is gone.</p><div class="mediaobject"><img alt="Introducing Bob" src="graphics/B04322_06_01.jpg"/></div><p>This is because<a class="indexterm" id="id00252"/> we now have gravity, and also the thread that calls <code class="literal">update()</code> runs immediately as the application starts, even before our level and the player character is finished being set up.</p><p>We need to do two things. First, we only want <code class="literal">update()</code> to run when the <code class="literal">LevelManager</code> class has finished its work. Secondly, we need to update the focus of the <code class="literal">Viewport</code> class in every frame so that even if the player is falling to his death (as he will frequently) the screen will be centered on him, so we can watch his demise.</p><p>Let's start the game on paused mode so that the player isn't missing. First, we will add a method to our <code class="literal">LevelManager</code> class that will switch the playing status between playing and not playing. A good name may be <code class="literal">switchPlayingStatus()</code>. Add the new method to <code class="literal">LevelManager</code> as shown follows:</p><div class="informalexample"><pre class="programlisting">public void switchPlayingStatus() {
        playing = !playing;
        if (playing) {
            gravity = 6;
        } else {
            gravity = 0;
        }
    }</pre></div><p>Now, just delete or comment out the line of code in the <code class="literal">LevelManager</code> constructor that sets <code class="literal">playing</code> to <code class="literal">true</code>. Soon, this will be handled by screen touches and the method we just wrote:</p><div class="informalexample"><pre class="programlisting">// Load all the GameObjects and Bitmaps
loadMapData(context, pixelsPerMetre, px, py);

<span class="strong"><strong>//playing = true;</strong></span>
//..</pre></div><p>We will write a tiny bit of temporary code, just a tiny bit. We already know that we will eventually be delegating responsibility to monitor player input to our new <code class="literal">InputController</code> class. This little bit of code in the overridden <code class="literal">onTouchEvent</code> method is well worth the effort because we will be able to use a pause feature right now.</p><p>This code will <a class="indexterm" id="id00253"/>toggle the playing status using the method we just wrote each time we touch the screen. Add the overridden method to the <code class="literal">PlatformView</code> class. We will eventually replace some of this code later in the chapter.</p><div class="informalexample"><pre class="programlisting">@Override
public boolean onTouchEvent(MotionEvent motionEvent) {
  switch (motionEvent.getAction() &amp; MotionEvent.ACTION_MASK) {
    case MotionEvent.ACTION_DOWN:
         lm.switchPlayingStatus();
         break;
   }
return true;
}</pre></div><p>You can set <code class="literal">isPressingRight</code> in the <code class="literal">Player</code> class to true, following which you can run the game and tap the screen. We will then see the player fall like a ghost off the bottom, while moving to the right of the screen:</p><div class="mediaobject"><img alt="Introducing Bob" src="graphics/B04322_06_02.jpg"/></div><p>Now, let's update<a class="indexterm" id="id00254"/> the viewport per frame to remain centered on the player. Add this highlighted code to the very end of the <code class="literal">update</code> method in the <code class="literal">PlatformView</code> class:</p><div class="informalexample"><pre class="programlisting">if (lm.isPlaying()) {
    //Reset the players location as the centre of the viewport
    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)
        .getWorldLocation().x,
        lm.gameObjects.get(lm.playerIndex)
        .getWorldLocation().y);}
}// End of update()</pre></div><p>If you run the game now, although the player still falls to his doom and to the right, at least the screen stays focused on him to watch it happen.</p><p>We will deal with the perpetual falling problem.</p></div>
<div class="section" title="Multiphase collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec037"/>Multiphase collision detection</h1></div></div></div><p>We have seen that our player <a class="indexterm" id="id00255"/>character simply falls though the world and into oblivion. Of course we need the player to be able to stand on the platforms. Here is what we will do.</p><p>We will provide every object that matters with a hitbox as we can then provide methods in the <code class="literal">Player</code> class to test if a hitbox has made contact with the player. Once per frame, we will send all hitboxes that have not been clipped by the viewport to this new method where a collision can be tested for.</p><p>We do it like this for two main reasons. Firstly, by sending only unclipped hitboxes for collision testing, we drastically reduce the number of checks, as described in <a class="link" href="ch12.html" title="Chapter 3. Tappy Defender – Taking Flight">Chapter 3</a>, <span class="emphasis"><em>Tappy Defender – Taking Flight</em></span>, in the section <span class="emphasis"><em>Things that go bump – collision detection</em></span>. Secondly, by handling the checks within the <code class="literal">Player</code> class, we can give the player multiple different hitboxes and respond slightly differently according to which one is hit.</p><p>Let's create our own class for a hitbox, so we can make it just how we want it. It needs to use float coordinates, it needs an <code class="literal">intersects</code> method and a bunch of getters and setters as well. Create a new class and call it <code class="literal">RectHitbox</code>.</p><p>Here, we see that <code class="literal">RectHitbox</code> simply has a bunch of self explanatory getters and setters. It also has the <code class="literal">intersects</code> method, which returns <code class="literal">true</code> if the <code class="literal">RectHitbox</code> passed into it intersects with itself. For an explanation of how the <code class="literal">intersects()</code> code works, see <a class="link" href="ch12.html" title="Chapter 3. Tappy Defender – Taking Flight">Chapter 3</a>, <span class="emphasis"><em>Tappy Defender – Taking Flight</em></span>. Enter the following code into the new class:</p><div class="informalexample"><pre class="programlisting">public class RectHitbox {
    float top;
    float left;
    float bottom;
    float right;
    float height;

    boolean intersects(RectHitbox rectHitbox){
        boolean hit = false;

        if(this.right &gt; rectHitbox.left
                &amp;&amp; this.left &lt; rectHitbox.right ){
            // Intersecting on x axis

            if(this.top &lt; rectHitbox.bottom
                    &amp;&amp; this.bottom &gt; rectHitbox.top ){
                // Intersecting on y as well
                // Collision
                hit = true;
            }
        }


        return hit;
    }

    public void setTop(float top) {
        this.top = top;
    }

    public float getLeft() {
        return left;
    }

    public void setLeft(float left) {
        this.left = left;
    }

    public void setBottom(float bottom) {
        this.bottom = bottom;
    }

    public float getRight() {
        return right;
    }

    public void setRight(float right) {
        this.right = right;
    }

    public float getHeight() {
        return height;
    }

    public void setHeight(float height) {
        this.height = height;
    }
}</pre></div><p>Now, we can<a class="indexterm" id="id00256"/> add a <code class="literal">RectHitbox</code> class as a member of <code class="literal">GameObject</code>. Add it right after the class declaration.</p><div class="informalexample"><pre class="programlisting">private RectHitbox rectHitbox = new RectHitbox();</pre></div><p>Then, we add a method to initialize the hitbox and a method so that we can grab a copy of it when needed. Add these two methods to <code class="literal">GameObject</code>:</p><div class="informalexample"><pre class="programlisting">public void setRectHitbox() {
   rectHitbox.setTop(worldLocation.y);
   rectHitbox.setLeft(worldLocation.x);
   rectHitbox.setBottom(worldLocation.y + height);
   rectHitbox.setRight(worldLocation.x + width);
}

RectHitbox getHitbox(){
  return rectHitbox;
}</pre></div><p>Now for <a class="indexterm" id="id00257"/>our <code class="literal">Grass</code> object, we add a call to <code class="literal">setRectHitbox()</code> and then we can start bumping into it. Add this one line of highlighted code at the very end of the <code class="literal">Grass</code> class's constructor. It is important that the call to <code class="literal">setRectHitbox()</code> comes after the call to <code class="literal">setWorldLocation()</code> otherwise the hitbox won't be wrapped around the block of grass.</p><div class="informalexample"><pre class="programlisting">// Where does the tile start
// X and y locations from constructor parameters
setWorldLocation(worldStartX, worldStartY, 0);
<span class="strong"><strong>setRectHitbox();</strong></span>
}// End of Grass constructor</pre></div><p>Before we can begin to comprehend the code that will do the collision checking, we need the <code class="literal">Player</code> class to have its own set of hitboxes. We need to know the following things about the player character:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When the head bumps something above it</li><li class="listitem" style="list-style-type: disc">When the feet land on a platform below</li><li class="listitem" style="list-style-type: disc">When the player walks into something either side of it</li></ul></div><p>To achieve this, we will create four hitboxes; one for the head, one for the feet, and one for each of the left and right-hand sides. As they are unique to the player, we will create the hitboxes within the <code class="literal">Player</code> class.</p><p>Declare the four hitboxes as members just after the <code class="literal">Player</code> class declaration:</p><div class="informalexample"><pre class="programlisting">RectHitbox rectHitboxFeet;
RectHitbox rectHitboxHead;
RectHitbox rectHitboxLeft;
RectHitbox rectHitboxRight;</pre></div><p>Now in the constructor, we call new <code class="literal">RectHitbox()</code> to prepare them. Note that we haven't bothered assigning any values to the hitboxes. We will see how we do that soon. Add the four calls to <code class="literal">new()</code> at the end of the <code class="literal">Player</code> constructor like this:</p><div class="informalexample"><pre class="programlisting">rectHitboxFeet = new RectHitbox();
rectHitboxHead = new RectHitbox();
rectHitboxLeft = new RectHitbox();
rectHitboxRight = new RectHitbox();</pre></div><p>We will see were we will initialize them properly. The hitbox values in the code that follows, have been manually estimated based on the space taken up by the actual shape of the character within the rectangle that represents each frame of the character. If you use a different character graphic, you will likely need to adjust the precise values you use.</p><p>The diagram shows<a class="indexterm" id="id00258"/> an approximate graphical representation of the locations that each hitbox will be positioned at. The apparent lack of closeness for the left and right hitboxes is because different frames of the animation are slightly wider than this one. This is a compromise.</p><div class="mediaobject"><img alt="Multiphase collision detection" src="graphics/B04322_06_03_new.jpg"/></div><p>The code must be placed after the call to <code class="literal">move()</code> within the <code class="literal">update</code> method in the <code class="literal">Player</code> class. This way, the hitboxes are updated each and every time the player position has changed. Add the highlighted code in exactly the position shown, and then we are one step closer to being able to start bumping in to stuff.</p><div class="informalexample"><pre class="programlisting">// Let's go!
this.move(fps);

<span class="strong"><strong>// Update all the hitboxes to the new location</strong></span>
<span class="strong"><strong>// Get the current world location of the player</strong></span>
<span class="strong"><strong>// and save them as local variables we will use next</strong></span>
<span class="strong"><strong>Vector2Point5D location = getWorldLocation();</strong></span>
<span class="strong"><strong>float lx = location.x;</strong></span>
<span class="strong"><strong>float ly = location.y;</strong></span>

<span class="strong"><strong>//update the player feet hitbox</strong></span>
<span class="strong"><strong>rectHitboxFeet.top = ly + getHeight() * .95f;</strong></span>
<span class="strong"><strong>rectHitboxFeet.left = lx + getWidth() * .2f;</strong></span>
<span class="strong"><strong>rectHitboxFeet.bottom = ly + getHeight() * .98f;</strong></span>
<span class="strong"><strong>rectHitboxFeet.right = lx + getWidth() * .8f;</strong></span>

<span class="strong"><strong>// Update player head hitbox</strong></span>
<span class="strong"><strong>rectHitboxHead.top = ly;</strong></span>
<span class="strong"><strong>rectHitboxHead.left = lx + getWidth() * .4f;</strong></span>
<span class="strong"><strong>rectHitboxHead.bottom = ly + getHeight() * .2f;</strong></span>
<span class="strong"><strong>rectHitboxHead.right = lx + getWidth() * .6f;</strong></span>

<span class="strong"><strong>// Update player left hitbox</strong></span>
<span class="strong"><strong>rectHitboxLeft.top = ly + getHeight() * .2f;</strong></span>
<span class="strong"><strong>rectHitboxLeft.left = lx + getWidth() * .2f;</strong></span>
<span class="strong"><strong>rectHitboxLeft.bottom = ly + getHeight() * .8f;</strong></span>
<span class="strong"><strong>rectHitboxLeft.right = lx + getWidth() * .3f;</strong></span>

<span class="strong"><strong>// Update player right hitbox</strong></span>
<span class="strong"><strong>rectHitboxRight.top = ly + getHeight() * .2f;</strong></span>
<span class="strong"><strong>rectHitboxRight.left = lx + getWidth() * .8f;</strong></span>
<span class="strong"><strong>rectHitboxRight.bottom = ly + getHeight() * .8f;</strong></span>
<span class="strong"><strong>rectHitboxRight.right = lx + getWidth() * .7f;</strong></span>

}// End update()</pre></div><p>In the next stage, we can<a class="indexterm" id="id00259"/> detect some collisions and react to them. Collisions which only concern the player, such as falling, bumping his head, or trying to walk through a wall are handled directly in this next method, within the <code class="literal">Player</code> class. Note that the method also returns an <code class="literal">int</code> value to represent if there was a collision and where on the player that collision occurred so that other collisions with things like pickups or pits of fire can be handled outside the class.</p><p>The new <code class="literal">checkCollisions</code> method receives a <code class="literal">RectHitbox</code> as a parameter. This will be the <code class="literal">RectHitbox</code> of whichever object we are currently checking against for collisions. Add the <code class="literal">checkCollisions</code> method to the <code class="literal">Player</code> class.</p><div class="informalexample"><pre class="programlisting">public int checkCollisions(RectHitbox rectHitbox) {
    int collided = 0;// No collision

    // The left
    if (this.rectHitboxLeft.intersects(rectHitbox)) {
        // Left has collided
        // Move player just to right of current hitbox
        this.setWorldLocationX(rectHitbox.right - getWidth() * .2f);
        collided = 1;
    }

    // The right
    if (this.rectHitboxRight.intersects(rectHitbox)) {
        // Right has collided
        // Move player just to left of current hitbox
        this.setWorldLocationX(rectHitbox.left - getWidth() * .8f);
        collided = 1;
    }

    // The feet
    if (this.rectHitboxFeet.intersects(rectHitbox)) {
        // Feet have collided
        // Move feet to just above current hitbox
        this.setWorldLocationY(rectHitbox.top - getHeight());
        collided = 2;
    }

    // Now the head
    if (this.rectHitboxHead.intersects(rectHitbox)) {
        // Head has collided. Ouch!
        // Move head to just below current hitbox bottom
        this.setWorldLocationY(rectHitbox.bottom);
        collided = 3;
    }
    
    return collided;
}</pre></div><p>As the previous <a class="indexterm" id="id00260"/>code implies, we need to add some setter methods to the <code class="literal">GameObject</code> class so that the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> world coordinates can be changed when a collision is detected. Add the following two methods to the <code class="literal">GameObject</code> class:</p><div class="informalexample"><pre class="programlisting">public void setWorldLocationY(float y) {
  this.worldLocation.y = y;
}

public void setWorldLocationX(float x) {
  this.worldLocation.x = x;
}</pre></div><p>The final step is to select all relevant objects and test for collisions. We do this in the <code class="literal">update</code> method of the <code class="literal">PlatformView</code> class, following which we switch to take further actions based on which body part collides with what object type. Our switch block will only have a default case to begin with, since we have only one possible object type to collide with a grass platform. Note that when a collision with the feet is detected, we set our <code class="literal">isFalling</code> variable to <code class="literal">false</code>, enabling the player to jump. Enter the highlighted code where shown:</p><div class="informalexample"><pre class="programlisting">// Set visible flag to true
go.setVisible(true);

<span class="strong"><strong>// check collisions with player</strong></span>
<span class="strong"><strong>int hit = lm.player.checkCollisions(go.getHitbox());</strong></span>
<span class="strong"><strong>if (hit &gt; 0) {</strong></span>
<span class="strong"><strong>  //collision! Now deal with different types</strong></span>
<span class="strong"><strong>  switch (go.getType()) {</strong></span>

<span class="strong"><strong>    default:// Probably a regular tile</strong></span>
<span class="strong"><strong>          if (hit == 1) {// Left or right</strong></span>
<span class="strong"><strong>             lm.player.setxVelocity(0);</strong></span>
<span class="strong"><strong>             lm.player.setPressingRight(false);</strong></span>
<span class="strong"><strong>           }</strong></span>

<span class="strong"><strong>         if (hit == 2) {// Feet</strong></span>
<span class="strong"><strong>             lm.player.isFalling = false;</strong></span>
<span class="strong"><strong>         }</strong></span>

<span class="strong"><strong>         break;</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0020"/>Note</h3><p>We will make more use of the value that gets stored in <code class="literal">hit</code> for further collision-based decision making, as we progress with this project.</p></div></div><p>Let's take<a class="indexterm" id="id00261"/> control of the player for real.</p></div>
<div class="section" title="Player input"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec038"/>Player input</h1></div></div></div><p>First, let's add some <a class="indexterm" id="id00262"/>methods in the <code class="literal">Player</code> class that our input controller will be able to call, then manipulate the variables that the <code class="literal">Player</code> class's <code class="literal">update</code> method uses to move around.</p><p>We already played with the <code class="literal">isPressingRight</code> variable, and also have an <code class="literal">isPressingLeft</code> variable. Furthermore, we want to be able to jump. If you take a look at the <code class="literal">Player</code> class's <code class="literal">update</code> method, we already have the code to handle these situations. We just need the player to be able to initiate the movements via touches to the screen.</p><p>Our previous button layout design and the code we have written so far, suggests a method for going left, a method for going right, and a method for jumping.</p><p>You will also note <a class="indexterm" id="id00263"/>that we pass a copy of <code class="literal">SoundManager</code> into the <code class="literal">startJump</code> method, which allows us to play a neat retro jumping sound, if the jump attempt is successful. Add these three new methods to the <code class="literal">Player</code> class:</p><div class="informalexample"><pre class="programlisting">public void setPressingRight(boolean isPressingRight) {
        this.isPressingRight = isPressingRight;
    }

    public void setPressingLeft(boolean isPressingLeft) {
        this.isPressingLeft = isPressingLeft;
    }

    public void startJump(SoundManager sm) {
        if (!isFalling) {//can't jump if falling
            if (!isJumping) {//not already jumping
                isJumping = true;
                jumpTime = System.currentTimeMillis();
                sm.playSound("jump");
            }
        }
    }</pre></div><p>Now, we can focus on the <code class="literal">InputController</code> class. Let's pass control from the <code class="literal">onTouchEvent</code> method to our <code class="literal">InputController</code> class. Change the code in the <code class="literal">onTouchEvent</code> method to the following in the <code class="literal">PlatformView</code> class:</p><div class="informalexample"><pre class="programlisting">@Override
    public boolean onTouchEvent(MotionEvent motionEvent) {
        if (lm != null) {
            ic.handleInput(motionEvent, lm, sm, vp);
        }
        //invalidate();
        return true;
    }</pre></div><p>We have an error in our new method. This is simply because we have called the <code class="literal">handleInput</code> method but not implemented it yet. We will do that now.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0021"/>Note</h3><p>If you are wondering about the check for whether <code class="literal">lm != null</code>, that is because the <code class="literal">onTouchEvent</code> method is triggered from the Android UI thread and is not within our control. If we pass in <code class="literal">lm</code> and start trying to do things with it, when it is not initialized, the game will crash.</p></div></div><p>We can now get<a class="indexterm" id="id00264"/> everything that we need done within the <code class="literal">InputController</code> class. Open that class now, and we will plan what we are going to do.</p><p>We need a button to go left, a button to go right, a button to jump, a button to toggle pause, and later we will also need a button to fire a machine gun. Therefore, we really need to highlight different areas of the screen to represent each of these tasks.</p><p>To do this, we will declare four <code class="literal">Rect</code> objects, one for each task. Then in the constructor, we will define the points of these four <code class="literal">Rect</code> objects by carrying out some simple calculations based on the players screen resolution.</p><p>We define some handy variables, <code class="literal">buttonWidth</code>, <code class="literal">buttonHeight</code>, and <code class="literal">buttonPadding</code>, based on the device's screen resolution to help us arrange our <code class="literal">Rect</code> coordinates neatly. Enter the following members and the <code class="literal">InputController</code> constructor as shown next:</p><div class="informalexample"><pre class="programlisting">import android.graphics.Rect;
import android.view.MotionEvent;
import java.util.ArrayList;

public class InputController {

    Rect left;
    Rect right;
    Rect jump;
    Rect shoot;
    Rect pause;

    InputController(int screenWidth, int screenHeight) {

        //Configure the player buttons
        int buttonWidth = screenWidth / 8;
        int buttonHeight = screenHeight / 7;
        int buttonPadding = screenWidth / 80;

        left = new Rect(buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            buttonWidth,
            screenHeight - buttonPadding);

        right = new Rect(buttonWidth + buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            buttonWidth + buttonPadding + buttonWidth,
            screenHeight - buttonPadding);

        jump = new Rect(screenWidth - buttonWidth - buttonPadding,
            screenHeight - buttonHeight - buttonPadding -                           
            buttonHeight - buttonPadding,
            screenWidth - buttonPadding,
            screenHeight - buttonPadding - buttonHeight -                           
            buttonPadding);

        shoot = new Rect(screenWidth - buttonWidth - buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            screenWidth - buttonPadding,
            screenHeight - buttonPadding);

        pause = new Rect(screenWidth - buttonPadding -                          
            buttonWidth,
            buttonPadding,
            screenWidth - buttonPadding,
            buttonPadding + buttonHeight);

    }</pre></div><p>We will use the <a class="indexterm" id="id00265"/>four <code class="literal">Rect</code> objects to draw buttons on the screen. The <code class="literal">draw</code> method is going to need a copy of them. Enter the code for the <code class="literal">getButtons</code> method to achieve this:</p><div class="informalexample"><pre class="programlisting">public ArrayList getButtons(){
   //create an array of buttons for the draw method
   ArrayList&lt;Rect&gt; currentButtonList = new ArrayList&lt;&gt;();
   currentButtonList.add(left);
   currentButtonList.add(right);
   currentButtonList.add(jump);
   currentButtonList.add(shoot);
   currentButtonList.add(pause);
   return  currentButtonList;
}</pre></div><p>We can now handle the actual player input. This project is different to the previous one because there are lots of different possible player actions that need to be monitored and responded to, sometimes simultaneously. As you expect, the Android API has the functionality to make this as easy as possible for us.</p><p>The <code class="literal">MotionEvent</code> class has a lot more data tucked away in it than we have seen so far. Previously, we simply checked for the <code class="literal">ACTION_DOWN</code> and <code class="literal">ACTION_UP</code> events. Now, we need to dig a little deeper to grab more of the event data.</p><p>In order to record and pass on the details of multiple fingers, touching, leaving, and moving on the screen, the <code class="literal">MotionEvent</code> class stores them all in an array. When the first finger of the player touches the screen, the details, coordinates, and so on, are stored at position zero. Subsequent actions are then stored later in the array.</p><p>The position in the array related to any such finger's activity is not consistent. In some situations, such as detecting specific gestures, this can be a problem and the programmer needs to capture, remember, and respond to the ID of a finger, also held in the <code class="literal">MotionEvent</code> class.</p><p>Fortunately in this situation, we have our clearly defined areas of the screen that represent our buttons, and the most we will ever need to know is if the finger has pressed or released the screen within one of these predefined areas.</p><p>We just need to find out how many fingers have caused events and are therefore stored in the array by calling <code class="literal">motionEvent.getPointerCount()</code>. We then loop through each of these events while providing a <code class="literal">switch</code> block to handle them, whatever area of the screen, where <code class="literal">ACTION_DOWN</code> or <code class="literal">ACTION_UP</code> has occurred. It won't matter which position in the array our event is stored at, as long as we detect it and respond to it.</p><p>The only other<a class="indexterm" id="id00266"/> thing we need to know, before we can code our solution, is that the subsequent actions in the array are stored as <code class="literal">ACTION_POINTER_DOWN</code> and <code class="literal">ACTION_POINTER_UP</code>; therefore, with each pass through the loop, that we will shortly code, we need to check and handle both <code class="literal">ACTION_DOWN</code> and <code class="literal">ACTION_POINTER_DOWN</code>.</p><p>After all this talk, here is our <code class="literal">handleInput</code> method that gets called every time the screen is touched or released:</p><div class="informalexample"><pre class="programlisting">public void handleInput(MotionEvent motionEvent,LevelManager l,     
  SoundManager sound, Viewport vp){
        
    int pointerCount = motionEvent.getPointerCount();

    for (int i = 0; i &lt; pointerCount; i++) {

        int x = (int) motionEvent.getX(i);
        int y = (int) motionEvent.getY(i);

        if(l.isPlaying()) {
            switch  (motionEvent.getAction() &amp;
            MotionEvent.ACTION_MASK) {

            case MotionEvent.ACTION_DOWN:
                    if (right.contains(x, y)) {
                    l.player.setPressingRight(true);
                    l.player.setPressingLeft(false);
                
                    } else if (left.contains(x, y)) {
                    l.player.setPressingLeft(true);
                    l.player.setPressingRight(false);
                
                    } else if (jump.contains(x, y)) {
                    l.player.startJump(sound);
                        
                    } else if (shoot.contains(x, y)) {
                        
                    } else if (pause.contains(x, y)) {
                    l.switchPlayingStatus();
                    }

                break;


                case MotionEvent.ACTION_UP:
                    if (right.contains(x, y)) {
                    l.player.setPressingRight(false);
                        
                    } else if (left.contains(x, y)) {
                    l.player.setPressingLeft(false);
                }

                break;

                    
                case MotionEvent.ACTION_POINTER_DOWN:
                if (right.contains(x, y)) {
                    l.player.setPressingRight(true);
                    l.player.setPressingLeft(false);
                
                    } else if (left.contains(x, y)) {
                    l.player.setPressingLeft(true);
                        l.player.setPressingRight(false);
                        
                    } else if (jump.contains(x, y)) {
                    l.player.startJump(sound);
                        
                    } else if (shoot.contains(x, y)) {
                    //Handle shooting here
                   
                    } else if (pause.contains(x, y)) {
                    l.switchPlayingStatus();
                }
                
                    break;


                case MotionEvent.ACTION_POINTER_UP:
                    if (right.contains(x, y)) {
                    l.player.setPressingRight(false);
                   //Log.w("rightP:", "up" );
                   
                    } else if (left.contains(x, y)) {
                    l.player.setPressingLeft(false);
                   //Log.w("leftP:", "up" );
              
                    } else if (shoot.contains(x, y)) {
                    //Handle shooting here
                    } else if (jump.contains(x, y)) {
                   //Handle more jumping stuff here later
                }
                
                break;
}// End if(l.playing)

}else {// Not playing
    //Move the viewport around to explore the map
    switch (motionEvent.getAction() &amp; MotionEvent.ACTION_MASK) {

    case MotionEvent.ACTION_DOWN:

        if (pause.contains(x, y)) {
            l.switchPlayingStatus();
            //Log.w("pause:", "DOWN" );
        }

      break;
            }
        }
    }
}
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0022"/>Note</h3><p>If you are wondering why we bothered to set up two sets of control code, one for playing and one for not playing, it is because in <a class="link" href="ch17.html" title="Chapter 8. Platformer – Putting It All Together">Chapter 8</a>, <span class="emphasis"><em>Putting It All Together</em></span>, we will add a cool new feature for the game while it is paused. Of course, the <code class="literal">togglePlayingStatus</code> method did not need to be done like this, and it would have worked fine without the test for the status of playing. It just saves us making minor intricate amendments to our code later on.</p></div></div><p>Now all we <a class="indexterm" id="id00267"/>need to do is open up the <code class="literal">PlatformView</code> class, grab a copy of the array with all the control buttons in, and draw them to the screen. We use the <code class="literal">drawRoundRect</code> method to draw neat curved-corner rectangles to represent the areas of the screen that will respond to the player's touches. Enter this code in the <code class="literal">draw</code> method right before the call to <code class="literal">unlockCanvasAndPost()</code>:</p><div class="informalexample"><pre class="programlisting">//draw buttons
paint.setColor(Color.argb(80, 255, 255, 255));
ArrayList&lt;Rect&gt; buttonsToDraw;
buttonsToDraw = ic.getButtons();

for (Rect rect : buttonsToDraw) {
  RectF rf = new RectF(rect.left, rect.top, 
    rect.right, rect.bottom);
                
    canvas.drawRoundRect(rf, 15f, 15f, paint);
}</pre></div><p>Also, right before we call <code class="literal">unlockCanvasAndPost()</code>, let's draw a simple pause screen so that we know when the game is paused or playing.</p><div class="informalexample"><pre class="programlisting">//draw paused text
if (!this.lm.isPlaying()) {
    paint.setTextAlign(Paint.Align.CENTER);
    paint.setColor(Color.argb(255, 255, 255, 255));

    paint.setTextSize(120);
    canvas.drawText("Paused", vp.getScreenWidth() / 2,                       
    vp.getScreenHeight() / 2, paint);
}</pre></div><p>You can now jump and walk all over the place and a nice retro jumping sound plays as well. Why not add some more grass to the scene by editing <code class="literal">LevelCave</code> and replacing a few period characters (<code class="literal">.</code>) with a few more <code class="literal">1</code> characters. The next screenshot shows that the player has been jumping around a bit as well as the buttons used for controls:</p><div class="mediaobject"><img alt="Player input" src="graphics/B04322_06_04.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0023"/>Note</h3><p>We will design some real-playable levels, as well as link them together in <a class="link" href="ch17.html" title="Chapter 8. Platformer – Putting It All Together">Chapter 8</a>, <span class="emphasis"><em>Putting It All Together</em></span>. For now, just do whatever seems like fun with <code class="literal">LevelCave</code>.</p></div></div><p>Now, we <a class="indexterm" id="id00268"/>can get rid of that ugly squashed player graphic and make a neat little animation out of it.</p></div>
<div class="section" title="Animating Bob"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec039"/>Animating Bob</h1></div></div></div><p>Sprite sheet animations <a class="indexterm" id="id00269"/>work by quickly changing the image drawn to the screen. Exactly like a child may draw the phases of a stick-man moving on the corner of a book, and then quickly flicking through it to make it appear to move.</p><p>The frames of Bob's animation are already contained within the <code class="literal">player.png</code> file we have been using to represent him.</p><div class="mediaobject"><img alt="Animating Bob" src="graphics/B04322_06_05.jpg"/></div><p>All we need to do is <a class="indexterm" id="id00270"/>loop through them one at a time when the player is moving.</p><p>This is quite straightforward to implement. We will make a simple animation class that handles the function of keeping time and returning the appropriate part of the sprite sheet when requested. We can then initialize a new animation object for any <code class="literal">GameObject</code> that needs to be animated. In addition, when they are being drawn in the <code class="literal">draw</code> method of <code class="literal">PlatformView</code>, if the object is animated, we will handle it slightly differently.</p><p>In this section, we will also see how to use the facing variable that tracks which way the player is facing. It will enable us to reverse the sprite sheet depending on the way the player (or any future animated objects) is headed.</p><p>Let's start by making the animation class. Create a new Java class and call it <code class="literal">Animation</code>. The code that follows soon will declare variables that hold the bitmap to be manipulated, the name of the bitmap, and a <code class="literal">rect</code> parameter to define the area of the sprite sheet that is the coordinates of the currently relevant frame of animation.</p><p>In addition, we have <code class="literal">frameCount</code>, <code class="literal">currentFrame</code>, <code class="literal">frameTicker</code>, and <code class="literal">framePeriod</code> that hold and control the number of available frames, the current frame number, and the timing of the change of the frames. As you would expect, we also need to know the width and height of a frame of animation, these are held by <code class="literal">frameWidth</code> and <code class="literal">frameHeight</code>.</p><p>Furthermore, the <code class="literal">Animation</code> class will regularly refer to the number of pixels per meter; therefore, it makes sense to hold this value in a member variable.</p><p>Enter these member variables that we discussed in the <code class="literal">Animation</code> class:</p><div class="informalexample"><pre class="programlisting">import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Rect;

public class Animation {
    Bitmap bitmapSheet;
    String bitmapName;
    private Rect sourceRect;
    private int frameCount;
    private int currentFrame;
    private long frameTicker;
    private int framePeriod;
    private int frameWidth;
    private int frameHeight;
    int pixelsPerMetre;</pre></div><p>Next, we have the <a class="indexterm" id="id00271"/>constructor that prepares our animation object for use. We will see exactly how we prepare for the actual animation soon. Note that there are a fair few parameters in the signature indicating that the animation is quite configurable. Just note that FPS in this context is not referring to the frame rate of the game but the frame rate of the animation.</p><div class="informalexample"><pre class="programlisting">Animation(Context context, 
  String bitmapName, float frameHeight, 
  float frameWidth, int animFps, 
  int frameCount, int pixelsPerMetre){

   this.currentFrame = 0;
   this.frameCount = frameCount;
   this.frameWidth = (int)frameWidth * pixelsPerMetre;
   this.frameHeight = (int)frameHeight * pixelsPerMetre;
   sourceRect = new Rect(0, 0, this.frameWidth, this.frameHeight);
        
   framePeriod = 1000 / animFps;
   frameTicker = 0l;
   this.bitmapName = "" + bitmapName;
   this.pixelsPerMetre = pixelsPerMetre;
}</pre></div><p>We can deal with the real functionality of the class. The <code class="literal">getCurrentFrame</code> method first checks to see if the object is moving or if it is capable of moving. At this stage, this may seem a little odd as this method will only ever be called by a <code class="literal">GameObject</code> class that is animated. The odd looking check, therefore, is determining if a new frame is required at the moment.</p><p>If an object moves, (such as Bob), but is standing still, then we don't need to change the frame of animation. However, if the animated object has no velocity ever, like a roaring fire, then we need to animate it all the time. It will never have any velocity so the <code class="literal">moves</code> variable will be <code class="literal">false</code>, but the method will proceed.</p><p>The method then uses <code class="literal">time</code>, <code class="literal">frameTicker</code> and <code class="literal">framePeriod</code>, to determine if it is time to show the next frame of animation and if it increments the frame number to display. Then, if the animation is on the last frame, it goes back to the first frame.</p><p>Finally, the precise<a class="indexterm" id="id00272"/> left and right-hand positions that represent the portion of the sprite sheet that contains the needed frame, are calculated and returned to the calling code.</p><div class="informalexample"><pre class="programlisting">public Rect getCurrentFrame(long time, 
    float xVelocity, boolean moves){

    if(xVelocity!=0 || moves == false) {
    // Only animate if the object is moving 
    // or it is an object which doesn't move
    // but is still animated (like fire)
           
        if (time &gt; frameTicker + framePeriod) {
            frameTicker = time;
            currentFrame++;
            if (currentFrame &gt;= frameCount) {
                currentFrame = 0;
            }
        }
    }
        
    //update the left and right values of the source of
    //the next frame on the spritesheet
    this.sourceRect.left = currentFrame * frameWidth;
    this.sourceRect.right = this.sourceRect.left + frameWidth;

    return sourceRect;
    
}

}// End of Animation class</pre></div><p>Next, we can add some members to the <code class="literal">GameObject</code> class.</p><div class="informalexample"><pre class="programlisting">// Most objects only have 1 frame
// And don't need to bother with these
private Animation anim = null;
private boolean animated;
private int animFps = 1;</pre></div><p>Some methods to interact with our <code class="literal">Animation</code> class, which set and get variables, make the animation work and inform the <code class="literal">draw</code> method if the object is animated or not.</p><div class="informalexample"><pre class="programlisting">public void setAnimFps(int animFps) {
  this.animFps = animFps;
}

public void setAnimFrameCount(int animFrameCount) {
  this.animFrameCount = animFrameCount;
}

public boolean isAnimated() {
  return animated;
}</pre></div><p>Lastly in <code class="literal">GameObject</code>, there is a method which the objects that require animating can use to set up their whole <a class="indexterm" id="id00273"/>animation object. Note it is this <code class="literal">setAnimated</code> method that calls <code class="literal">new()</code> on a new animation object.</p><div class="informalexample"><pre class="programlisting">public void setAnimated(Context context, int pixelsPerMetre,  
  boolean animated){
        
 this.animated = animated;
 this.anim = new Animation(context, bitmapName,
     height,
     width,
     animFps,
     animFrameCount,
     pixelsPerMetre );
}</pre></div><p>The next method acts as a go between for the <code class="literal">draw</code> method of the <code class="literal">PlatformView</code> class and the <code class="literal">getRectToDraw</code> method of the <code class="literal">Animation</code> class.</p><div class="informalexample"><pre class="programlisting">public Rect getRectToDraw(long deltaTime){
  return anim.getCurrentFrame(
    deltaTime, 
    xVelocity, 
    isMoves());
}</pre></div><p>Then, we need to update the <code class="literal">Player</code> class in order to initialize its animation object according to its own specific required number of frames and frames per second. The new code in the <code class="literal">Player</code> class is highlighted:</p><div class="informalexample"><pre class="programlisting">setBitmapName("player");

<span class="strong"><strong>final int ANIMATION_FPS = 16;</strong></span>
<span class="strong"><strong>final int ANIMATION_FRAME_COUNT = 5;</strong></span>

<span class="strong"><strong>// Set this object up to be animated</strong></span>
<span class="strong"><strong>setAnimFps(ANIMATION_FPS);</strong></span>
<span class="strong"><strong>setAnimFrameCount(ANIMATION_FRAME_COUNT);</strong></span>
<span class="strong"><strong>setAnimated(context, pixelsPerMetre, true);</strong></span>

// X and y locations from constructor parameters
setWorldLocation(worldStartX, worldStartY, 0);</pre></div><p>We can use all<a class="indexterm" id="id00274"/> this new code from the <code class="literal">draw</code> method to implement our animations. The next block of code checks if the current <code class="literal">GameObject</code> being drawn <code class="literal">isAnimated()</code>. If it is, it gets the appropriate rectangle from the sprite sheet using the <code class="literal">getNextRect()</code> method via the <code class="literal">GameObject</code> class's <code class="literal">getRectToDraw</code> method.</p><p>Note that, the next code listing from the <code class="literal">draw</code> method that made the original call to <code class="literal">drawBitmap()</code>, is now wrapped in an <code class="literal">else</code> clause at the end of the new code. Basically, the logic is this. If animated, execute the new code, otherwise just do it the usual way.</p><p>In addition to the animation code we know about, we also check <code class="literal">if(go.getFacing() == 1)</code> and use the <code class="literal">Matrix</code> class to flip the bitmap when required by scaling it by -1 on the <span class="emphasis"><em>x</em></span> axis.</p><p>Here is all the new code, including the original <code class="literal">drawBitmap()</code> call wrapped in an <code class="literal">else</code> clause at the end:</p><div class="informalexample"><pre class="programlisting">toScreen2d.set(vp.worldToScreen
  go.getWorldLocation().x,
  go.getWorldLocation().y,
  go.getWidth(),
  go.getHeight()));

<span class="strong"><strong>if (go.isAnimated()) {</strong></span>
<span class="strong"><strong>    // Get the next frame of the bitmap</strong></span>
<span class="strong"><strong>    // Rotate if necessary</strong></span>
<span class="strong"><strong>    if (go.getFacing() == 1) {</strong></span>
<span class="strong"><strong>        // Rotate</strong></span>
<span class="strong"><strong>        Matrix flipper = new Matrix();</strong></span>
<span class="strong"><strong>        flipper.preScale(-1, 1);</strong></span>
<span class="strong"><strong>        Rect r = go.getRectToDraw(System.currentTimeMillis());</strong></span>
<span class="strong"><strong>        Bitmap b = Bitmap.createBitmap(</strong></span>
<span class="strong"><strong>        lm.bitmapsArray[lm.getBitmapIndex(go.getType())],</strong></span>
<span class="strong"><strong>        r.left,</strong></span>
<span class="strong"><strong>        r.top,</strong></span>
<span class="strong"><strong>        r.width(),</strong></span>
<span class="strong"><strong>        r.height(),</strong></span>
<span class="strong"><strong>        flipper,</strong></span>
<span class="strong"><strong>        true);</strong></span>
<span class="strong"><strong>        canvas.drawBitmap(b, toScreen2d.left, toScreen2d.top, paint);</strong></span>
<span class="strong"><strong>} else {</strong></span>
<span class="strong"><strong>        // draw it the regular way round</strong></span>
<span class="strong"><strong>        canvas.drawBitmap(</strong></span>
<span class="strong"><strong>        lm.bitmapsArray[lm.getBitmapIndex(go.getType())],</strong></span>
<span class="strong"><strong>        go.getRectToDraw(System.currentTimeMillis()),</strong></span>
<span class="strong"><strong>        toScreen2d, paint);</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>} else { // Just draw the whole bitmap</strong></span>
<span class="strong"><strong>        canvas.drawBitmap(</strong></span>
<span class="strong"><strong>        lm.bitmapsArray[lm.getBitmapIndex(go.getType())],</strong></span>
<span class="strong"><strong>        toScreen2d.left,</strong></span>
<span class="strong"><strong>        toScreen2d.top, paint);</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Now, you can run the<a class="indexterm" id="id00275"/> game and see Bob in all his animated glory. The screenshot can't show his movements, but you can see he is now perfectly formed:</p><div class="mediaobject"><img alt="Animating Bob" src="graphics/B04322_06_06.jpg"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec040"/>Summary</h1></div></div></div><p>Our game is steadily coming together. At this stage, we can build a huge level design in <code class="literal">LevelCave</code> and go running and jumping all over the place. However, we will save to postpone trying to make the game playable until we have added a load more neat features.</p><p>These neat features will include a machine gun, which can be upgraded through collectible pickups and some enemies that Bob can shoot at. We will get going with that in the next chapter.</p></div>
<div class="chapter" title="Chapter&#xA0;7.&#xA0;Platformer &#x2013; Guns, Life, Money, and the Enemy"><div class="titlepage"><div><div><h1 class="title"><a id="ch16"/>Chapter 7. Platformer – Guns, Life, Money, and the Enemy</h1></div></div></div><p>In this chapter, we will do many things. First, we will build a machine gun with a variable rate of fire and have it shoot bullets. Then, we will introduce pickups or collectibles. These give the player something to scavenge for while trying to escape into the next level.</p><p>Then, just as Bob was beginning to think that his life was a blissful one of grass and collectibles, we will build two adversaries for him to outsmart or kill. A homing drone and a patrolling guard. We will easily be able to add all these things into our level designs.</p><div class="section" title="Ready aim fire"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec041"/>Ready aim fire</h1></div></div></div><p>Now, we can give our hero<a class="indexterm" id="id00276"/> a gun, and later, we can give him enemies to shoot at. We will create a <code class="literal">MachineGun</code> class to do all the work and a <code class="literal">Bullet</code> class to represent the projectiles that it fires. The <code class="literal">Player</code> class will control the <code class="literal">MachineGun</code> class, and the <code class="literal">MachineGun</code> class will control and keep track of all the <code class="literal">Bullet</code> objects that it fires.</p><p>Create a new Java class and call it <code class="literal">Bullet</code>. Bullets are not complicated. Ours will need a <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> location, a horizontal velocity, and a direction to help calculate the velocity.</p><p>This implies the following simple class, constructor, and a bunch of getters and setters:</p><div class="informalexample"><pre class="programlisting">public class Bullet  {

    private float x;
    private float y;
    private float xVelocity;
    private int direction;

    Bullet(float x, float y, int speed, int direction){
        this.direction = direction;
        this.x = x;
        this.y = y;
        this.xVelocity = speed * direction;
    }

    public int getDirection(){
        return direction;
    }

    public void update(long fps, float gravity){
        x += xVelocity / fps;
    }

    public void hideBullet(){
        this.x = -100;
        this.xVelocity = 0;
    }

    public float getX(){
        return x;
    }

    public float getY(){
        return y;
    }

    
}</pre></div><p>Now let's<a class="indexterm" id="id00277"/> implement the <code class="literal">MachineGun</code> class.</p><p>Create a new<a class="indexterm" id="id00278"/> Java class and call it <code class="literal">MachineGun</code>. First, we add some members. The <code class="literal">maxBullets</code> variable is not the amount of shots a player has, that is unlimited, it is the number of bullet objects the <code class="literal">MachineGun</code> class can have. Ten is sufficient for a very fast firing gun, as we will see. The members <code class="literal">numBullets</code> and <code class="literal">nextBullet</code> help the class to keep track of its 10 bullets. The <code class="literal">rateOfFire</code> variable controls how fast the player will be able to tap the fire button, and <code class="literal">lastShotTime</code> will help enforce the <code class="literal">rateOfFire</code> by keeping track of the system time that the last bullet was fired. It is the rate of fire that will be the upgradeable aspect of the weapon.</p><p>Enter the code that we discussed as follows.</p><div class="informalexample"><pre class="programlisting">import java.util.concurrent.CopyOnWriteArrayList;

public class MachineGun extends GameObject{
    private int maxBullets = 10;
    private int numBullets;
    private int nextBullet;
    private int rateOfFire = 1;//bullets per second
    private long lastShotTime;

    private CopyOnWriteArrayList&lt;Bullet&gt; bullets;

    int speed = 25;</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0024"/>Note</h3><p>For functional purposes, we can think of the <code class="literal">CopyOnWriteArrayList</code> <code class="literal">bullets</code>, which stores our bullets, as a plain old <code class="literal">ArrayList</code> object. We use this more complex and slightly slower class because it is thread safe and bullets can be accessed potentially simultaneously from the UI thread, when the player taps the fire button as well as from our own thread. This article explains <code class="literal">CopyOnWriteArrayList</code>, if you want to <a class="indexterm" id="id00279"/>know more, visit:</p><p>
<a class="ulink" href="http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/">http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/</a>
</p></div></div><p>We have the <a class="indexterm" id="id00280"/>constructor that just initializes<a class="indexterm" id="id00281"/> bullets, <code class="literal">lastShotTime</code>, and <code class="literal">nextBullet</code>:</p><div class="informalexample"><pre class="programlisting">MachineGun(){
   bullets = new CopyOnWriteArrayList&lt;Bullet&gt;();
   lastShotTime = -1;
   nextBullet = -1;
}</pre></div><p>Here, we update all the <code class="literal">Bullet</code> objects controlled by the gun by calling the <code class="literal">bullet.update</code> method for each bullet.</p><div class="informalexample"><pre class="programlisting">public void update(long fps, float gravity){
        //update all the bullets
        for(Bullet bullet: bullets){
            bullet.update(fps, gravity);
        }
    }</pre></div><p>Next, we have some getters that will let us find out things about our gun and its bullets, to do things like collision detection, and drawing bullets.</p><div class="informalexample"><pre class="programlisting">public int getRateOfFire(){
  return rateOfFire;
}

public void setFireRate(int rate){
  rateOfFire = rate;
}

public int getNumBullets(){
  //tell the view how many bullets there are
  return numBullets;
}
    
public float getBulletX(int bulletIndex){
  if(bullets != null &amp;&amp; bulletIndex &lt; numBullets) {
       return bullets.get(bulletIndex).getX();
    }

  return -1f;
}
    
public float getBulletY(int bulletIndex){
  if(bullets != null) {
       return bullets.get(bulletIndex).getY();
     }
     return -1f;
}</pre></div><p>We also have a<a class="indexterm" id="id00282"/> quick helper method for when we <a class="indexterm" id="id00283"/>want to stop drawing a bullet. We hide it away until it is ready to be reassigned in our <code class="literal">shoot</code> method shortly.</p><div class="informalexample"><pre class="programlisting">public void hideBullet(int index){
  bullets.get(index).hideBullet();
}</pre></div><p>A getter that returns the direction of travel:</p><div class="informalexample"><pre class="programlisting">public int getDirection(int index){
  return bullets.get(index).getDirection();
}</pre></div><p>Now, we add a more comprehensive method that actually shoots a bullet. The method compares the time of the last fired shot against the current <code class="literal">rateOfFire</code>. It then proceeds to increment <code class="literal">nextBullet</code> and create a new <code class="literal">Bullet</code> object if permitted. The bullet is sent speeding off in the same direction as Bob is facing. Note that the method returns <code class="literal">true</code> if a bullet was successfully fired. This is so that the <code class="literal">InputController</code> class can play a sound effect to correspond with the player's button press.</p><div class="informalexample"><pre class="programlisting">public boolean shoot(float ownerX, float ownerY, 
    int ownerFacing, float ownerHeight){

    boolean shotFired = false;
    if(System.currentTimeMillis() - lastShotTime  &gt;                          
      1000/rateOfFire){
            
        //spawn another bullet;
        nextBullet ++;
        
            
        if(numBullets &gt;= maxBullets){
            numBullets = maxBullets;
        }
            
        if(nextBullet == maxBullets){
            nextBullet = 0;
        }
            
        lastShotTime = System.currentTimeMillis();
        bullets.add(nextBullet, 
                new Bullet(ownerX, 
                (ownerY+ ownerHeight/3), speed, ownerFacing));
                
        shotFired = true;
        numBullets++;
    }
    return shotFired;
}</pre></div><p>Finally, we have a <a class="indexterm" id="id00284"/>method to call when the player finds <a class="indexterm" id="id00285"/>a machine gun upgrade pickup. We will see more of them later in the chapter. Here, we simply increase <code class="literal">rateOfFire</code>, which enables the player to tap the fire button more furiously and still get results.</p><div class="informalexample"><pre class="programlisting">public void upgradeRateOfFire(){
  rateOfFire += 2;
}
}// End of MachineGun class</pre></div><p>Now, we will modify the <code class="literal">Player</code> class to carry a <code class="literal">MachineGun</code>. Give <code class="literal">Player</code> a member variable that is a <code class="literal">MachineGun</code>.</p><div class="informalexample"><pre class="programlisting">public MachineGun bfg;</pre></div><p>Next in the <code class="literal">Player</code> constructor, add a line of code to initialize our new <code class="literal">MachineGun</code> object:</p><div class="informalexample"><pre class="programlisting">bfg = new MachineGun();</pre></div><p>In the <code class="literal">Player</code> class's <code class="literal">update</code> method, add a call to the <code class="literal">MachineGun</code> class's <code class="literal">update</code> method just before we call <code class="literal">move()</code> for the player. As highlighted next:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bfg.update(fps, gravity);</strong></span>

// Let's go!
this.move(fps);</pre></div><p>Add a method to<a class="indexterm" id="id00286"/> the <code class="literal">Player</code> class, so <a class="indexterm" id="id00287"/>our <code class="literal">InputController</code> can access the virtual trigger. As we saw, the method returns <code class="literal">true</code> if a shot was successful so that the <code class="literal">InputController</code> class knows whether to play a shot sound or not.</p><div class="informalexample"><pre class="programlisting">public boolean pullTrigger() {
        //Try and fire a shot
        return bfg.shoot(this.getWorldLocation().x,  
           this.getWorldLocation().y, 
           getFacing(), getHeight());
}</pre></div><p>Now, we can make some minor additions to our <code class="literal">InputController</code> class so that the player can fire a shot. The code to add is shown highlighted amongst the existing code:</p><div class="informalexample"><pre class="programlisting">} else if (jump.contains(x, y)) {
  l.player.startJump(sound);

} else if (shoot.contains(x, y)) {
<span class="strong"><strong>  if (l.player.pullTrigger()) {</strong></span>
<span class="strong"><strong>       sound.playSound("shoot");</strong></span>
<span class="strong"><strong>     }</strong></span>
                        
} else if (pause.contains(x, y)) {
  l.switchPlayingStatus();

}</pre></div><p>Not forgetting the way that our new control system works, we also need to add the same piece of extra code further down the <code class="literal">InputController</code> class in the <code class="literal">MotionEvent.ACTION_POINTER_DOWN</code> case as well. As usual, here is the code highlighted and with plenty of context:</p><div class="informalexample"><pre class="programlisting">} else if (jump.contains(x, y)) {
  l.player.startJump(sound);
                        
} else if (shoot.contains(x, y)) {
<span class="strong"><strong>  if (l.player.pullTrigger()) {</strong></span>
<span class="strong"><strong>     sound.playSound("shoot");</strong></span>
<span class="strong"><strong>}</strong></span>
                        
} else if (pause.contains(x, y)) {
  l.switchPlayingStatus();
}</pre></div><p>Now we have a gun, it's loaded, and we know how to pull the trigger. We just need to draw the bullets.</p><p>Add the new code in the <code class="literal">draw</code> method, just before we draw the debugging text, as shown:</p><div class="informalexample"><pre class="programlisting">//draw the bullets
paint.setColor(Color.argb(255, 255, 255, 255));
for (int i = 0; i &lt; lm.player.bfg.getNumBullets(); i++) {
   // Pass in the x and y coords as usual
   // then .25 and .05 for the bullet width and height
   toScreen2d.set(vp.worldToScreen
            (lm.player.bfg.getBulletX(i),
            lm.player.bfg.getBulletY(i),
            .25f,
            .05f));

        canvas.drawRect(toScreen2d, paint);
}
            
// Text for debugging
if (debugging) {
// etc</pre></div><p>We will now fire some bullets. Note that the rate of fire is unsatisfying and slow. We will add some pickups, which the player can get to increase the rate of fire of his gun.</p><div class="section" title="Pickups"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec053"/>Pickups</h2></div></div></div><p>Pickups<a class="indexterm" id="id00288"/> are game objects that can be collected by the player. They include things like upgrades, extra lives, money, and so on. We will now implement one of each of those collectibles. As our game engine is setup the way it is, this will be surprisingly easy.</p><p>The first thing we will do is create a class to hold the state of the current player. We want to monitor the money collected, power of machine gun, and lives remaining. Let's call it <code class="literal">PlayerState</code>. Create a new Java class and name it <code class="literal">PlayerState</code>.</p><p>In addition to the variables, we have just talked about, we also want the <code class="literal">PlayerState</code> class to remember an <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> location to respawn at, when the player loses a life. Enter these member variables and the simple constructor:</p><div class="informalexample"><pre class="programlisting">import android.graphics.PointF;

public class PlayerState {

    private int numCredits;
    private int mgFireRate;
    private int lives;
    private float restartX;
    private float restartY;

    PlayerState() {
        lives = 3;
        mgFireRate = 1;
        numCredits = 0;
    }</pre></div><p>Now, we need a <a class="indexterm" id="id00289"/>method that we can call to initialize the respawn location. We will use this later when we call this method. Also, we need a method to reload the location. These are our next two methods for the <code class="literal">PlayerState</code> class:</p><div class="informalexample"><pre class="programlisting">public void saveLocation(PointF location) {
   // The location saves each time the player uses a teleport
     restartX = location.x;
     restartY = location.y;
}

public PointF loadLocation() {
   // Used every time the player loses a life
   return new PointF(restartX, restartY);
}</pre></div><p>We just need a whole bunch of getters and setters to give us access to the members of this class:</p><div class="informalexample"><pre class="programlisting">public int getLives(){
  return lives;
}

public int getFireRate(){
  return mgFireRate;
}

public void increaseFireRate(){
  mgFireRate += 2;
}

public void gotCredit(){
  numCredits ++;
}

public int getCredits(){
  return numCredits;
}

public void loseLife(){
  lives--;
}

public void addLife(){
  lives++;
}

public void resetLives(){
  lives = 3;
}
public void resetCredits(){
  lives = 0;
}

}// End PlayerState class</pre></div><p>Next, declare <a class="indexterm" id="id00290"/>an object of the <code class="literal">PlayerState</code> type as a member of the <code class="literal">PlatformView</code> class:</p><div class="informalexample"><pre class="programlisting">// Our new engine classes
private LevelManager lm;
private Viewport vp;
InputController ic;
SoundManager sm;
<span class="strong"><strong>private PlayerState ps;</strong></span>
</pre></div><p>Initialize it in the <code class="literal">PlatformView</code> constructor:</p><div class="informalexample"><pre class="programlisting">vp = new Viewport(screenWidth, screenHeight);
sm = new SoundManager();
sm.loadSound(context);
ps = new PlayerState();

loadLevel("LevelCave", 10, 2);</pre></div><p>Now in the <code class="literal">loadLevel</code> method, create a <code class="literal">RectF</code> object, store the players starting location, and pass it in to the <code class="literal">PlayerState</code> object, <code class="literal">ps</code>, for safe keeping. Each time the player dies, he can be respawned using this location.</p><div class="informalexample"><pre class="programlisting">ic = new InputController(vp.getScreenWidth(), vp.getScreenHeight());

<span class="strong"><strong>PointF location = new PointF(px, py);</strong></span>
<span class="strong"><strong>ps.saveLocation(location);</strong></span>
        
//set the players location as the world centre of the viewport</pre></div><p>Now we will <a class="indexterm" id="id00291"/>create three classes, one for each of our pickups. These classes are very simple. They extend <code class="literal">GameObject</code>, set a bitmap, have a hitbox, and a location in the world. Also note that they all receive a type in the constructor and use <code class="literal">setType()</code> to store this value. We will soon see how to use their type to handle what happens when the player "picks them up". Create three new Java classes: <code class="literal">Coin</code>, <code class="literal">ExtraLife</code>, and <code class="literal">MachineGunUpgrade</code>. Note that the pickups are a little smaller than a platform, perhaps as we may expect. Enter the code for each of them in turn.</p><p>The following is the code for <code class="literal">Coin</code>:</p><div class="informalexample"><pre class="programlisting">public class Coin extends GameObject{
    
    Coin(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = .5f;
        final float WIDTH = .5f;

        setHeight(HEIGHT); 
        setWidth(WIDTH); 

        setType(type);

        // Choose a Bitmap
        setBitmapName("coin");

        // Where does the tile start
        // X and y locations from constructor parameters
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity){}
}</pre></div><p>Now, for <code class="literal">ExtraLife</code>:</p><div class="informalexample"><pre class="programlisting">public class ExtraLife extends GameObject{

    ExtraLife(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = .8f;
        final float WIDTH = .65f;

        setHeight(HEIGHT); 
        setWidth(WIDTH); 

        setType(type);

        // Choose a Bitmap

        setBitmapName("life");

        // Where does the tile start
        // X and y locations from constructor parameters
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity){}
}</pre></div><p>Finally, the<a class="indexterm" id="id00292"/> <code class="literal">MachineGunUpgrade</code> class:</p><div class="informalexample"><pre class="programlisting">public class MachineGunUpgrade extends GameObject{
    MachineGunUpgrade(float worldStartX, 
        float worldStartY, 
        char type) {

        final float HEIGHT = .5f;
        final float WIDTH = .5f;

        setHeight(HEIGHT); 
        setWidth(WIDTH); 

        setType(type);

        // Choose a Bitmap

        setBitmapName("clip");

        // Where does the tile start
        // X and y locations from constructor parameters
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity){}
}</pre></div><p>Now, update the <code class="literal">LevelManager</code> class to expect these three new objects in our level designs and add them to <code class="literal">ArrayList</code> of <code class="literal">GameObjects</code>. To do this, we need to update the <code class="literal">LevelManager</code> class in three places: <code class="literal">getBitmap()</code>, <code class="literal">getBitmapIndex()</code>, and <code class="literal">loadMapData()</code>. Here are each of these minor updates, with the new code highlighted amongst the existing code.</p><p>Make the <a class="indexterm" id="id00293"/>following additions to <code class="literal">getBitmap()</code>:</p><div class="informalexample"><pre class="programlisting">case 'p':
  index = 2;
  break;
            
<span class="strong"><strong>case 'c':</strong></span>
<span class="strong"><strong>  index = 3;</strong></span>
<span class="strong"><strong>  break;</strong></span>

<span class="strong"><strong>case 'u':</strong></span>
<span class="strong"><strong>  index = 4;</strong></span>
<span class="strong"><strong>  break;</strong></span>

<span class="strong"><strong>case 'e':</strong></span>
<span class="strong"><strong>  index = 5;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>Make identical additions, but this time to <code class="literal">getBitmapIndex()</code>:</p><div class="informalexample"><pre class="programlisting">case 'p':
  index = 2;
  break;

<span class="strong"><strong>case 'c':</strong></span>
<span class="strong"><strong>  index = 3;</strong></span>
<span class="strong"><strong>  break;</strong></span>

<span class="strong"><strong>case 'u':</strong></span>
<span class="strong"><strong>  index = 4;</strong></span>
<span class="strong"><strong>  break;</strong></span>

<span class="strong"><strong>case 'e':</strong></span>
<span class="strong"><strong>  index = 5;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>Make the final <a class="indexterm" id="id00294"/>changes within <code class="literal">LevelManager</code> with the following additions to <code class="literal">loadMapData()</code>:</p><div class="informalexample"><pre class="programlisting">case 'p':// a player
    // Add a player to the gameObjects
    gameObjects.add(new Player(context, px, py, pixelsPerMetre));
    // We want the index of the player
    playerIndex = currentIndex;
    // We want a reference to the player object
    player = (Player) gameObjects.get(playerIndex);
    break;

<span class="strong"><strong>case 'c':</strong></span>
<span class="strong"><strong>    // Add a coin to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Coin(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'u':</strong></span>
<span class="strong"><strong>    // Add a machine gun upgrade to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new MachineGunUpgrade(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'e':</strong></span>
<span class="strong"><strong>    // Add an extra life to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new ExtraLife(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Now, we can add the three appropriately named graphics to the drawable folder and start adding them to our <code class="literal">LevelCave</code> design. Go ahead and copy <code class="literal">clip.png</code>, <code class="literal">coin.png</code>, and <code class="literal">life.png</code> from the <code class="literal">Chapter7/drawables</code> folder in the download bundle to the <code class="literal">drawable</code> folder of your Android Studio project.</p><p>Add a handy list of comments that identify all the types of game object. We will add these over the course of this project and the alpha-numeric code that will represent them on our level designs. Add the following comments to the <code class="literal">LevelData</code> class:</p><div class="informalexample"><pre class="programlisting">// Tile types
// . = no tile
// 1 = Grass
<span class="strong"><strong>// 2 = Snow</strong></span>
<span class="strong"><strong>// 3 = Brick</strong></span>
<span class="strong"><strong>// 4 = Coal</strong></span>
<span class="strong"><strong>// 5 = Concrete</strong></span>
<span class="strong"><strong>// 6 = Scorched</strong></span>
<span class="strong"><strong>// 7 = Stone</strong></span>

<span class="strong"><strong>//Active objects</strong></span>
<span class="strong"><strong>// g = guard</strong></span>
<span class="strong"><strong>// d = drone</strong></span>
<span class="strong"><strong>// t = teleport</strong></span>
<span class="strong"><strong>// c = coin</strong></span>
<span class="strong"><strong>// u = upgrade</strong></span>
<span class="strong"><strong>// f = fire</strong></span>
<span class="strong"><strong>// e  = extra life</strong></span>

<span class="strong"><strong>//Inactive objects</strong></span>
<span class="strong"><strong>// w = tree</strong></span>
<span class="strong"><strong>// x = tree2 (snowy)</strong></span>
<span class="strong"><strong>// l = lampost</strong></span>
<span class="strong"><strong>// r = stalactite</strong></span>
<span class="strong"><strong>// s = stalacmite</strong></span>
<span class="strong"><strong>// m = mine cart</strong></span>
<span class="strong"><strong>// z = boulders</strong></span>
</pre></div><p>Before we <a class="indexterm" id="id00295"/>enhance our <code class="literal">LevelCave</code> class to use our new objects, we want to detect when the player collects them or collides with them and take appropriate action. We will first add a quick helper method to the <code class="literal">Player</code> class. The reason for this is because when the player collides with another object, the default action in the <code class="literal">Player</code> class's <code class="literal">checkCollisions</code> method is to stop the character moving. We don't want this to happen for pickups because it will be irritating for the player. Therefore, we will quickly add a <code class="literal">restorePreviousVelocity</code> method to the <code class="literal">Player</code> class that we can call whenever we don't want this default action to occur. Add this method to the <code class="literal">Player</code> class:</p><div class="informalexample"><pre class="programlisting">public void restorePreviousVelocity() {
  if (!isJumping &amp;&amp; !isFalling) {
       if (getFacing() == LEFT) {
           isPressingLeft = true;
           setxVelocity(-MAX_X_VELOCITY);
         } else {
           isPressingRight = true;
                     setxVelocity(MAX_X_VELOCITY);
       }
    }
}</pre></div><p>Now, we can handle the collisions for each of our pickups in turn. Add these cases to handle our <a class="indexterm" id="id00296"/>three pickups within the switch block that handles our collisions in the <code class="literal">update</code> method of the <code class="literal">PlatformView</code> class:</p><div class="informalexample"><pre class="programlisting">switch (go.getType()) {
<span class="strong"><strong>    case 'c':</strong></span>
<span class="strong"><strong>        sm.playSound("coin_pickup");</strong></span>
<span class="strong"><strong>        go.setActive(false);</strong></span>
<span class="strong"><strong>        go.setVisible(false);</strong></span>
<span class="strong"><strong>        ps.gotCredit();</strong></span>
  
<span class="strong"><strong>    // Now restore state that was </strong></span>
<span class="strong"><strong>    // removed by collision detection</strong></span>
<span class="strong"><strong>    if (hit != 2) {// Any hit except feet</strong></span>
<span class="strong"><strong>        lm.player.restorePreviousVelocity();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'u':</strong></span>
<span class="strong"><strong>    sm.playSound("gun_upgrade");</strong></span>
<span class="strong"><strong>    go.setActive(false);</strong></span>
<span class="strong"><strong>    go.setVisible(false);</strong></span>
<span class="strong"><strong>    lm.player.bfg.upgradeRateOfFire();</strong></span>
<span class="strong"><strong>    ps.increaseFireRate();</strong></span>
<span class="strong"><strong>    if (hit != 2) {// Any hit except feet</strong></span>
<span class="strong"><strong>        lm.player.restorePreviousVelocity();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'e':</strong></span>
<span class="strong"><strong>    //extralife</strong></span>
<span class="strong"><strong>    go.setActive(false);</strong></span>
<span class="strong"><strong>    go.setVisible(false);</strong></span>
<span class="strong"><strong>    sm.playSound("extra_life");</strong></span>
<span class="strong"><strong>    ps.addLife();</strong></span>
<span class="strong"><strong>          </strong></span>
<span class="strong"><strong>    if (hit != 2) {</strong></span>
<span class="strong"><strong>        lm.player.restorePreviousVelocity();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:// Probably a regular tile
    if (hit == 1) {// Left or right
        lm.player.setxVelocity(0);
        lm.player.setPressingRight(false);
    }

    if (hit == 2) {// Feet
        lm.player.isFalling = false;
    }
    break;
}</pre></div><p>Finally, add the new objects to our <code class="literal">LevelCave</code> class.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0011"/>Tip</h3><p>The following code snippet, I suggest, is for a simple new layout that demonstrates our new objects, but your layout can be as big or elaborate as you like. We will do something more elaborate in the next chapter when we design and link some levels.</p></div></div><p>Enter the <a class="indexterm" id="id00297"/>following code into <code class="literal">LevelCave</code> or elaborate with your own design:</p><div class="informalexample"><pre class="programlisting">public class LevelCave extends LevelData{
  LevelCave() {
    tiles = new ArrayList&lt;String&gt;();
<span class="strong"><strong>    this.tiles.add("p.............................................");</strong></span>
<span class="strong"><strong>    this.tiles.add("..............................................");</strong></span>
<span class="strong"><strong>    this.tiles.add("..............................................");</strong></span>
<span class="strong"><strong>    this.tiles.add("..............................................");</strong></span>
<span class="strong"><strong>    this.tiles.add("....................c.........................");</strong></span>
<span class="strong"><strong>    this.tiles.add("....................1........u................");</strong></span>
<span class="strong"><strong>    this.tiles.add(".................c..........u1................");</strong></span>
<span class="strong"><strong>    this.tiles.add(".................1.........u1.................");</strong></span>
<span class="strong"><strong>    this.tiles.add("..............c...........u1..................");</strong></span>
<span class="strong"><strong>    this.tiles.add("..............1..........u1...................");</strong></span>
<span class="strong"><strong>    this.tiles.add("......................e..1....e.....e.........");</strong></span>
<span class="strong"><strong>    this.tiles.add("....11111111111111111111111111111111111111....");</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>This is what the simple layout will look like:</p><div class="mediaobject"><img alt="Pickups" src="graphics/B04322_07_01.jpg"/></div><p>Try collecting the <a class="indexterm" id="id00298"/>pickups, and you will hear the pleasing sound effects. In addition, each time we collect a pickup, the <code class="literal">PlayerState</code> class stores an update. This will be useful when we build a HUD in the next chapter. Most fun of all; if you collect the machine gun upgrades, then try shooting your gun, you will find it much more satisfying to wield.</p><p>We better make those bullets do something. However, before we do that, let's give the player a bit more cannon fodder in the form of a couple of enemies.</p><div class="section" title="The drone"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec025"/>The drone</h3></div></div></div><p>The drone<a class="indexterm" id="id00299"/> is a <a class="indexterm" id="id00300"/>simple but evil enemy. It will detect the player when it is within the viewport and fly straight at him. If the drone touches the player, death is immediate.</p><p>Let's build a <code class="literal">Drone</code> class. Create a new Java class and call it <code class="literal">Drone</code>. We need member variables to remember when we set the last waypoint. This will restrict the frequency with which the drone will get a navigation update of Bob's coordinates. This stops the drone from being too deadly accurate. It needs a waypoint/target coordinate and also needs to know the speed limit via <code class="literal">MAX_X_VELOCITY</code> and <code class="literal">MAX_Y_VELOCITY</code>.</p><div class="informalexample"><pre class="programlisting">import android.graphics.PointF;

public class Drone extends GameObject {

    long lastWaypointSetTime;
    PointF currentWaypoint;

    final float MAX_X_VELOCITY = 3;
    final float MAX_Y_VELOCITY = 3;</pre></div><p>Now in <a class="indexterm" id="id00301"/>the <code class="literal">Drone</code> <a class="indexterm" id="id00302"/>constructor, initialize the usual <code class="literal">GameObject</code> members and specifically, the <code class="literal">Drone</code> class ones such as <code class="literal">currentWaypoint</code>. Not forgetting, that if we are going to shoot the drone, it will need a hitbox and we call <code class="literal">setRectHitBox()</code> after we have called <code class="literal">setWorldLocation()</code>.</p><div class="informalexample"><pre class="programlisting">Drone(float worldStartX, float worldStartY, char type) {
    final float HEIGHT = 1;
    final float WIDTH = 1;
    setHeight(HEIGHT); // 1 metre tall
    setWidth(WIDTH); // 1 metres wide

    setType(type);

    setBitmapName("drone");
    setMoves(true);
    setActive(true);
    setVisible(true);

    currentWaypoint = new PointF();
        
    // Where does the drone start
    // X and y locations from constructor parameters
    setWorldLocation(worldStartX, worldStartY, 0);
    setRectHitbox();
    setFacing(RIGHT);
}</pre></div><p>Here is the implementation of the <code class="literal">update</code> method, which compares the drone's coordinates with its <code class="literal">currentWaypoint</code> variable and changes its velocity accordingly. Then, we end <code class="literal">update()</code> by calling <code class="literal">move()</code> then <code class="literal">setRectHitbox()</code>.</p><div class="informalexample"><pre class="programlisting">public void update(long fps, float gravity) {
  if (currentWaypoint.x &gt; getWorldLocation().x) {
       setxVelocity(MAX_X_VELOCITY);
   } else if (currentWaypoint.x &lt; getWorldLocation().x) {
       setxVelocity(-MAX_X_VELOCITY);
   } else {
       setxVelocity(0);
   }

    if (currentWaypoint.y &gt;= getWorldLocation().y) {
       setyVelocity(MAX_Y_VELOCITY);
     } else if (currentWaypoint.y &lt; getWorldLocation().y) {
       setyVelocity(-MAX_Y_VELOCITY);
     } else {
       setyVelocity(0);
  }


  move(fps);

  // update the drone hitbox
   setRectHitbox();

}</pre></div><p>In our last<a class="indexterm" id="id00303"/> method <a class="indexterm" id="id00304"/>for the <code class="literal">Drone</code> class, update the <code class="literal">currentWaypoint</code> variable by passing in Bob's coordinates as a parameter. Note that we check if enough time has elapsed for an update to make sure our drone is not too accurate.</p><div class="informalexample"><pre class="programlisting">public void setWaypoint(Vector2Point5D playerLocation) {
  if (System.currentTimeMillis() &gt; lastWaypointSetTime + 2000) {//Has 2 seconds passed
        lastWaypointSetTime = System.currentTimeMillis();
        currentWaypoint.x = playerLocation.x;
        currentWaypoint.y = playerLocation.y;
     }
}
}// End Drone class</pre></div><p>Add the drone graphic <code class="literal">drone.png</code> from <code class="literal">Chapter7/drawable</code> into the <code class="literal">drawable</code> folder of your project.</p><p>We then need to add drones to our <code class="literal">LevelManager</code> class in the usual three places, just as we did for each of our pickups. Now, add code to <code class="literal">getBitmap()</code>, <code class="literal">getBitmapIndex()</code>, and <code class="literal">loadMapData()</code>. These are the three minor code additions in order.</p><p>Add the highlighted code in the <code class="literal">getBitmap</code> method:</p><div class="informalexample"><pre class="programlisting">case 'e':
  index = 5;
  break;

<span class="strong"><strong>case 'd':</strong></span>
<span class="strong"><strong>  index = 6;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>Add the highlighted code in the <code class="literal">getBitmapIndex</code> method:</p><div class="informalexample"><pre class="programlisting">case 'e':
  index = 5;
  break;

<span class="strong"><strong>case 'd':</strong></span>
<span class="strong"><strong>  index = 6;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>Add the highlighted code in the <code class="literal">loadMapData</code> method:</p><div class="informalexample"><pre class="programlisting">case 'e':
   // Add an extra life to the gameObjects
   gameObjects.add(new ExtraLife(j, i, c));
   break;

<span class="strong"><strong>case 'd':</strong></span>
<span class="strong"><strong>   // Add a drone to the gameObjects</strong></span>
<span class="strong"><strong>   gameObjects.add(new Drone(j, i, c));</strong></span>
<span class="strong"><strong>   break;</strong></span>
</pre></div><p>The burning<a class="indexterm" id="id00305"/> question <a class="indexterm" id="id00306"/>is; how does the drone know where to go? In each frame, if there is a drone within the viewport, we can send the coordinates of the player. Do what is shown in this next code block within the <code class="literal">update</code> method of the <code class="literal">PlatformView</code> class.</p><p>As usual, the new code is shown highlighted and in the context of the existing code. If you remember the <code class="literal">setWaypoint()</code> code from the <code class="literal">Drone</code> class, it only accepts updates every 2 seconds. This stops the drone from being too accurate.</p><div class="informalexample"><pre class="programlisting">if (lm.isPlaying()) {
   // Run any un-clipped updates
   go.update(fps, lm.gravity);

<span class="strong"><strong>   if (go.getType() == 'd') {</strong></span>
<span class="strong"><strong>       // Let any near by drones know where the player is</strong></span>
<span class="strong"><strong>       Drone d = (Drone) go;</strong></span>
<span class="strong"><strong>       d.setWaypoint(lm.player.getWorldLocation());</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Now, these evil drones can be strategically placed around the level, and they will home in on the player. The last thing we need to do to make the drones fully operational is to detect when they actually collide with the player. This is nice and easy. Just add a case for drones in our<a class="indexterm" id="id00307"/> collision<a class="indexterm" id="id00308"/> detection <code class="literal">switch</code> block in the <code class="literal">update</code> method of the <code class="literal">PlatformView</code> class:</p><div class="informalexample"><pre class="programlisting">case 'e':
  //extralife
   go.setActive(false);
   go.setVisible(false);
   sm.playSound("extra_life");
   ps.addLife();
   if (hit != 2) {// Any hit except feet
       lm.player.restorePreviousVelocity();
   }
   break;

<span class="strong"><strong>case 'd':</strong></span>
<span class="strong"><strong>     PointF location;</strong></span>
<span class="strong"><strong>     //hit by drone</strong></span>
<span class="strong"><strong>     sm.playSound("player_burn");</strong></span>
<span class="strong"><strong>     ps.loseLife();</strong></span>
<span class="strong"><strong>     location = new PointF(ps.loadLocation().x, </strong></span>
<span class="strong"><strong>         ps.loadLocation().y);</strong></span>
<span class="strong"><strong>     lm.player.setWorldLocationX(location.x);</strong></span>
<span class="strong"><strong>     lm.player.setWorldLocationY(location.y);</strong></span>
<span class="strong"><strong>     lm.player.setxVelocity(0);</strong></span>
<span class="strong"><strong>     break;</strong></span>

default:// Probably a regular tile
  if (hit == 1) {// Left or right
       lm.player.setxVelocity(0);
       lm.player.setPressingRight(false);
  }

   if (hit == 2) {// Feet
       lm.player.isFalling = false;
   }</pre></div><p>Go ahead and add a whole bunch of drones to <code class="literal">LevelCave</code> and watch them fly at the player. Note that if a drone catches the player, he dies and respawns.</p><div class="mediaobject"><img alt="The drone" src="graphics/B04322_07_02.jpg"/></div><p>Now, as if the<a class="indexterm" id="id00309"/> world wasn't <a class="indexterm" id="id00310"/>a dangerous enough place with all those enemy drones, let's add another type of enemy.</p></div><div class="section" title="The guard"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec026"/>The guard</h3></div></div></div><p>The guard <a class="indexterm" id="id00311"/>enemy will be an exercise in scripting. We will have our <code class="literal">LevelManager</code> class <a class="indexterm" id="id00312"/>automatically generate a simple script, which generates a route for our guard to patrol.</p><p>The route will be the<a class="indexterm" id="id00313"/> simplest one possible; it will be just two waypoints that the <a class="indexterm" id="id00314"/>guard will walk between continuously. It will be much quicker and simpler to preprogram our guards with two predetermined waypoints. However, by taking the time to have it automatically generated, we can place guards wherever we like (within certain parameters) on any level we design, and the behavior will be taken care of for us.</p><p>Our guard will be animated, so we will be using a sprite sheet and configuring the animation details in the constructor; just as we did for the <code class="literal">Player</code> class.</p><p>Create a new class and call it <code class="literal">Guard</code>. First, handle the member variables. Our <code class="literal">Guard</code> class will not only need two waypoints, but also a variable to indicate which one the current waypoint is. Like other moving objects, it will need velocity. Here is the class declaration and member variables to start coding your class:</p><div class="informalexample"><pre class="programlisting">import android.content.Context;

public class Guard extends GameObject {

    // Guards just move on x axis between 2 waypoints

    private float waypointX1;// always on left
    private float waypointX2;// always on right
    private int currentWaypoint;
    final float MAX_X_VELOCITY = 3;</pre></div><p>We need to set up <a class="indexterm" id="id00315"/>our guards via the constructor. First, setup our <a class="indexterm" id="id00316"/>animation variables, bitmap, and sizes. Then as usual, set the<a class="indexterm" id="id00317"/> guard's position in the level, its hitbox, and the way that it is facing. However, in the last line of the constructor we set <code class="literal">currentWaypoint</code> to <code class="literal">1</code>; this is new. We will see how this informs our guard's behavior in this class's <code class="literal">update</code> method.</p><div class="informalexample"><pre class="programlisting">Guard(Context context, float worldStartX, 
  float worldStartY, char type, 
  int pixelsPerMetre) {
        
        final int ANIMATION_FPS = 8;
        final int ANIMATION_FRAME_COUNT = 5;
        final String BITMAP_NAME = "guard";
        final float HEIGHT = 2f;
        final float WIDTH = 1;

        setHeight(HEIGHT); // 2 metre tall
        setWidth(WIDTH); // 1 metres wide

        setType(type);

        setBitmapName("guard");
        // Now for the player's other attributes
        // Our game engine will use these
        setMoves(true);
        setActive(true);
        setVisible(true);

        // Set this object up to be animated
        setAnimFps(ANIMATION_FPS);
        setAnimFrameCount(ANIMATION_FRAME_COUNT);
        setBitmapName(BITMAP_NAME);
        setAnimated(context, pixelsPerMetre, true);

        // Where does the tile start
        // X and y locations from constructor parameters
        setWorldLocation(worldStartX, worldStartY, 0);
        setxVelocity(-MAX_X_VELOCITY);
        currentWaypoint = 1;
}</pre></div><p>Next, add a method that our <code class="literal">LevelManager</code> class will use to let the <code class="literal">Guard</code> class know what its two waypoints are:</p><div class="informalexample"><pre class="programlisting">public void setWaypoints(float x1, float x2){
  waypointX1 = x1;
  waypointX2 = x2;
}</pre></div><p>Now, we will code<a class="indexterm" id="id00318"/> the "brains" of our <code class="literal">Guard</code> class, that is, its <code class="literal">update</code> <a class="indexterm" id="id00319"/>method. You can basically break this method into two main parts. First, <code class="literal">if(currentWaypoint == 1)</code> and secondly, <code class="literal">if(currentWaypoint == 2)</code>. Inside each <a class="indexterm" id="id00320"/>of these <code class="literal">if</code> blocks, simply check if the guard has reached or passed the appropriate waypoint. If it has, switch waypoints, reverse the velocity, and make the guard face the other way.</p><p>Finally, call <code class="literal">move()</code> then <code class="literal">setRectHitbox()</code> to update the hitbox to the new location of the guard. Add the code for the <code class="literal">update</code> method and then we will see how to put it to work.</p><div class="informalexample"><pre class="programlisting">public void update(long fps, float gravity) {
  if(currentWaypoint == 1) {// Heading left
       if (getWorldLocation().x &lt;= waypointX1) {
          // Arrived at waypoint 1
           currentWaypoint = 2;
           setxVelocity(MAX_X_VELOCITY);
           setFacing(RIGHT);
      }
  }

  if(currentWaypoint == 2){
    if (getWorldLocation().x &gt;= waypointX2) {
         // Arrived at waypoint 2
          currentWaypoint = 1;
          setxVelocity(-MAX_X_VELOCITY);
          setFacing(LEFT);
      }
  }

  move(fps);
   // update the guards hitbox
   setRectHitbox();
}
}// End Guard class</pre></div><p>Remember to add <code class="literal">guard.png</code> from the <code class="literal">Chapter7/drawables</code> folder of the download bundle to the <code class="literal">drawable</code> folder of the project.</p><p>Now, we can make the usual three additions to the <code class="literal">LevelManager</code> class to load any guards that may be found in<a class="indexterm" id="id00321"/> our level designs.</p><p>In <code class="literal">getBitmap()</code>, add <a class="indexterm" id="id00322"/>the highlighted code:</p><div class="informalexample"><pre class="programlisting">case 'd':
  index = 6;
  break;

<span class="strong"><strong>case 'g':</strong></span>
<span class="strong"><strong>  index = 7;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>In <code class="literal">getBitmapIndex()</code>, add<a class="indexterm" id="id00323"/> the highlighted code:</p><div class="informalexample"><pre class="programlisting">case 'd':
  index = 6;
  break;

<span class="strong"><strong>case 'g':</strong></span>
<span class="strong"><strong>  index = 7;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>In <code class="literal">loadMapData()</code>, add the highlighted code:</p><div class="informalexample"><pre class="programlisting">case 'd':
     // Add a drone to the gameObjects
     gameObjects.add(new Drone(j, i, c));
     break;
<span class="strong"><strong>case 'g':</strong></span>
<span class="strong"><strong>   // Add a guard to the gameObjects</strong></span>
<span class="strong"><strong>   gameObjects.add(new Guard(context, j, i, c, pixelsPerMetre));</strong></span>
<span class="strong"><strong>   break;</strong></span>
</pre></div><p>We will soon add something totally new to <code class="literal">LevelManager</code>. That is a method that will create the script (set two waypoints to patrol). For this new method to work, it needs to know if the tile is suitable for <a class="indexterm" id="id00324"/>walking on. We will add a new property, a getter, and a setter to <code class="literal">GameObject</code> so that this is easily discoverable.</p><p>Add this new member to the <code class="literal">GameObject</code> class right after the class declaration:</p><div class="informalexample"><pre class="programlisting">private boolean traversable = false;</pre></div><p>Add these two methods to the <code class="literal">GameObject</code> class to get and set this variable:</p><div class="informalexample"><pre class="programlisting">public void setTraversable(){
  traversable = true;
}

public boolean isTraversable(){
  return traversable;
}</pre></div><p>Now in the <code class="literal">Grass</code><a class="indexterm" id="id00325"/> class constructor, add a call to <code class="literal">setTraversable()</code>. We <a class="indexterm" id="id00326"/>must remember to do this for all future <code class="literal">GameObject</code> derived classes that we design, if we want our guards to be able to patrol on them. In <code class="literal">Grass</code>, add this line at the top of the constructor:</p><div class="informalexample"><pre class="programlisting">setTraversable();</pre></div><p>Next, we will look at the new <code class="literal">setWaypoints</code> method for our <code class="literal">LevelManager</code> class. It needs to examine the level design and calculate two waypoints for any <code class="literal">Guard</code> objects present in that level.</p><p>We will break this method into a few parts, so we can see what's happening at each stage.</p><p>First, we need to loop through all the <code class="literal">gameObjects</code> classes looking for the <code class="literal">Guard</code> objects.</p><div class="informalexample"><pre class="programlisting">public void setWaypoints() {
  // Loop through all game objects looking for Guards
    for (GameObject guard : this.gameObjects) {
       if (guard.getType() == 'g') {</pre></div><p>If we reach this point in the code, it means we have found a guard who will need two waypoints to be set. First, we need to find the tile which the guard is "standing on". Then, we calculate the coordinate of the last traversable tile on either side, but with a maximum range of five tiles each way. These will be the two waypoints. Here, is the code to add to the <code class="literal">setWaypoints</code> method. It is heavily commented to make clear what is going on without interrupting the flow by stopping to talk about it.</p><div class="informalexample"><pre class="programlisting">// Set waypoints for this guard
// find the tile beneath the guard
// this relies on the designer putting 
// the guard in sensible location

int startTileIndex = -1;
int startGuardIndex = 0;
float waypointX1 = -1;
float waypointX2 = -1;
           
for (GameObject tile : this.gameObjects) {
    startTileIndex++;
    if (tile.getWorldLocation().y == 
            guard.getWorldLocation().y + 2) {
                        
        // Tile is two spaces below current guard
        // Now see if has same x coordinate
        if (tile.getWorldLocation().x == 
            guard.getWorldLocation().x) {
                            
            // Found the tile the guard is "standing" on
            // Now go left as far as possible 
            // before non travers-able tile is found
            // Either on guards row or tile row
            // upto a maximum of 5 tiles. 
            //  5 is an arbitrary value you can
            // change it to suit

            for (int i = 0; i &lt; 5; i++) {// left for loop
                if (!gameObjects.get(startTileIndex -
                    i).isTraversable()) {
                
                    //set the left waypoint
                    waypointX1 = gameObjects.get(startTileIndex - 
                        (i + 1)).getWorldLocation().x;
                                                                                            
                     break;// Leave left for loop
                     } else {
                    // Set to max 5 tiles as 
                    // no non traversible tile found
                    waypointX1 = gameObjects.get(startTileIndex -
                        5).getWorldLocation().x;
               }
                }// end get left waypoint

                for (int i = 0; i &lt; 5; i++) {// right for loop
                    if (!gameObjects.get(startTileIndex +
                        i).isTraversable()) {
                
                        //set the right waypoint
                        waypointX2 = gameObjects.get(startTileIndex +
                            (i - 1)).getWorldLocation().x;
                      
                    break;// Leave right for loop
                    } else {
                    //set to max 5 tiles away
                    waypointX2 = gameObjects.get(startTileIndex +
                       5).getWorldLocation().x;
                }

                }// end get right waypoint
             
        Guard g = (Guard) guard;
        g.setWaypoints(waypointX1, waypointX2);
    }
}
}
}
}
}// End setWaypoints()</pre></div><p>Now, we can call our <a class="indexterm" id="id00327"/>new <code class="literal">setWaypoints</code> method as the last thing to do in <a class="indexterm" id="id00328"/>the <code class="literal">LevelManager</code> constructor. We need to call<a class="indexterm" id="id00329"/> this method after the <code class="literal">GameObject</code> class's <code class="literal">ArrayList</code> has been populated or there will be no guards in it. Add the call to <code class="literal">setWaypoints()</code> as highlighted:</p><div class="informalexample"><pre class="programlisting">// Load all the GameObjects and Bitmaps
loadMapData(context, pixelsPerMetre, px, py);
<span class="strong"><strong>// Set waypoints for our guards</strong></span>
<span class="strong"><strong>setWaypoints();</strong></span>
</pre></div><p>Next, add this code to the collision detection switch block in the <code class="literal">update</code> method of the <code class="literal">PlatformView</code> class, so we can bump into the guards.</p><div class="informalexample"><pre class="programlisting">case 'd':
    PointF location;
    //hit by drone
    sm.playSound("player_burn");
    ps.loseLife();
    location = new PointF(ps.loadLocation().x, 
        ps.loadLocation().y);
   
    lm.player.setWorldLocationX(location.x);
    lm.player.setWorldLocationY(location.y);
    lm.player.setxVelocity(0);
    break;

<span class="strong"><strong>case 'g':</strong></span>
<span class="strong"><strong>    // Hit by guard</strong></span>
<span class="strong"><strong>    sm.playSound("player_burn");</strong></span>
<span class="strong"><strong>    ps.loseLife();</strong></span>
<span class="strong"><strong>    location = new PointF(ps.loadLocation().x,</strong></span>
<span class="strong"><strong>        ps.loadLocation().y);</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>    lm.player.setWorldLocationX(location.x);</strong></span>
<span class="strong"><strong>    lm.player.setWorldLocationY(location.y);</strong></span>
<span class="strong"><strong>    lm.player.setxVelocity(0);</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:// Probably a regular tile
    if (hit == 1) {// Left or right
        lm.player.setxVelocity(0);
        lm.player.setPressingRight(false);
    }
    if (hit == 2) {// Feet
        lm.player.isFalling = false;
    }</pre></div><p>Finally, add some <code class="literal">g</code> letters to <a class="indexterm" id="id00330"/>the <code class="literal">LevelCave</code> class. Make sure to place them with one <a class="indexterm" id="id00331"/>space above the platform, because they are 2 meters <a class="indexterm" id="id00332"/>high as in this pseudo code:</p><div class="informalexample"><pre class="programlisting">................g............................
...........................d.................
111111111111111111111111111111111111111111111</pre></div><div class="mediaobject"><img alt="The guard" src="graphics/B04322_07_03.jpg"/></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec042"/>Summary</h1></div></div></div><p>We implemented guns, pickups, drones, and guards. This means we now have plenty of dangers, but have a machine gun that can't do any damage. We will change that first thing in the next chapter, by implementing collision detection for our bullets. However, we will go slightly further than merely having them hit our enemies.</p></div>
<div class="chapter" title="Chapter&#xA0;8.&#xA0;Platformer &#x2013; Putting It All Together"><div class="titlepage"><div><div><h1 class="title"><a id="ch17"/>Chapter 8. Platformer – Putting It All Together</h1></div></div></div><p>Finally, we will make the bullets do some damage. The ricochet sound is very satisfying when the bullets energy is absorbed by a clump of grass. We will add an abundance of new platform types and inanimate scenery objects to make our levels more interesting. We will provide a real sense of motion and immersion by implementing multiple scrolling parallax backgrounds.</p><p>We will also add an animated fire tile for the player to avoid, and in addition, a special <code class="literal">Teleport</code> class to link levels together into one playable game. Then, we will use all of our game objects and backgrounds to create four, linked, and fully playable levels.</p><p>Then, we will add a HUD to keep track of pickups and lives. Finally, we will discuss some of the neat things that couldn't be fitted into this project in just four chapters.</p><div class="section" title="Bullet collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec043"/>Bullet collision detection</h1></div></div></div><p>Detecting bullet collisions is<a class="indexterm" id="id00333"/> fairly straightforward. We loop through all the existing <code class="literal">Bullet</code> objects held by our <code class="literal">MachineGun</code> object. Next, we convert the points of each bullet into a <code class="literal">RectHitBox</code> object and test it using <code class="literal">intersects()</code> against each object in our viewport.</p><p>If we get a hit, we check to see what type of object it has hit. We then switch to handle each type of object that we care about. If it is a <code class="literal">Guard</code> object, we knock it back a bit, if it is a <code class="literal">Drone</code> object, we destroy it, and if it is anything else, we just make the bullet disappear and play a kind of thudding/ricochet sound.</p><p>We simply place this logic we discussed after our <code class="literal">switch</code> block that handles collisions with the player, but before, we call <code class="literal">update()</code> on all our unclipped objects as shown next:</p><div class="informalexample"><pre class="programlisting">default:// Probably a regular tile
    if (hit == 1) {// Left or right
        lm.player.setxVelocity(0);
        lm.player.setPressingRight(false);
    }

   if (hit == 2) {// Feet
        lm.player.isFalling = false;
    }
    break;
}
}

<span class="strong"><strong>//Check bullet collisions</strong></span>
<span class="strong"><strong>for (int i = 0; i &lt; lm.player.bfg.getNumBullets(); i++) {</strong></span>
<span class="strong"><strong>    //Make a hitbox out of the the current bullet</strong></span>
<span class="strong"><strong>    RectHitbox r = new RectHitbox();</strong></span>
<span class="strong"><strong>    r.setLeft(lm.player.bfg.getBulletX(i));</strong></span>
<span class="strong"><strong>    r.setTop(lm.player.bfg.getBulletY(i));</strong></span>
<span class="strong"><strong>    r.setRight(lm.player.bfg.getBulletX(i) + .1f);</strong></span>
<span class="strong"><strong>    r.setBottom(lm.player.bfg.getBulletY(i) + .1f);</strong></span>

<span class="strong"><strong>    if (go.getHitbox().intersects(r)) {</strong></span>
<span class="strong"><strong>        // Collision detected</strong></span>
<span class="strong"><strong>        // make bullet disappear until it </strong></span>
<span class="strong"><strong>        // is respawned as a new bullet</strong></span>
<span class="strong"><strong>        lm.player.bfg.hideBullet(i);</strong></span>

<span class="strong"><strong>        //Now respond depending upon the type of object hit</strong></span>
<span class="strong"><strong>        if (go.getType() != 'g' &amp;&amp; go.getType() != 'd') {</strong></span>
<span class="strong"><strong>            sm.playSound("ricochet");</strong></span>
<span class="strong"><strong>      </strong></span>
<span class="strong"><strong>        } else if (go.getType() == 'g') {</strong></span>
<span class="strong"><strong>            // Knock the guard back</strong></span>
<span class="strong"><strong>            go.setWorldLocationX(go.getWorldLocation().x +</strong></span>
<span class="strong"><strong>                2 * (lm.player.bfg.getDirection(i)));</strong></span>
<span class="strong"><strong>            </strong></span>
<span class="strong"><strong>            sm.playSound("hit_guard");</strong></span>
<span class="strong"><strong>      </strong></span>
<span class="strong"><strong>        } else if (go.getType() == 'd') {</strong></span>
<span class="strong"><strong>            //destroy the droid</strong></span>
<span class="strong"><strong>            sm.playSound("explode");</strong></span>
<span class="strong"><strong>            //permanently clip this drone</strong></span>
<span class="strong"><strong>            go.setWorldLocation(-100, -100, 0);</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>}</strong></span>

if (lm.isPlaying()) {
    // Run any un-clipped updates
    go.update(fps, lm.gravity);
        //...</pre></div><p>Try it out, it is really<a class="indexterm" id="id00334"/> satisfying, especially with a high rate of fire.</p></div></div>
<div class="section" title="Adding some fire tiles"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec044"/>Adding some fire tiles</h1></div></div></div><p>These new <code class="literal">GameObject</code> derived objects <a class="indexterm" id="id00335"/>will mean instant death to Bob. They won't move, but they will be animated. We will see we can achieve this just by setting the already existing properties of <code class="literal">GameObject</code>.</p><p>Adding this feature into our game is simple because we have already implemented all the features we need. We already have a way to locate and add new tiles, a way to detect and respond to a collision, sprite sheet animation, and so on. Let's do it step-by-step, then we can add these dangerous and life-threatening elements into our world.</p><p>We can put the entire functionality of the class into its constructor. All we do is configure the object much like we did our <code class="literal">Grass</code> object, but in addition, we configure it with all the animation settings, like we did to the <code class="literal">Player</code> and <code class="literal">Guard</code> objects. The <code class="literal">fire.png</code> sprite sheet has three frames of animation that we want to play over the course of one second.</p><div class="mediaobject"><img alt="Adding some fire tiles" src="graphics/B04322_08_01.jpg"/></div><p>Create a new class, call it <code class="literal">Fire</code>, and add the following code to it:</p><div class="informalexample"><pre class="programlisting">import android.content.Context;

public class Fire extends GameObject{

    Fire(Context context, float worldStartX, 
    float worldStartY, char type, int pixelsPerMetre) {

        final int ANIMATION_FPS = 3;
        final int ANIMATION_FRAME_COUNT = 3;
        final String BITMAP_NAME = "fire";

        final float HEIGHT = 1;
        final float WIDTH = 1;

        setHeight(HEIGHT); // 1 metre tall
        setWidth(WIDTH); // 1 metre wide

        setType(type);
        // Now for the player's other attributes
        // Our game engine will use these
        setMoves(false);
        setActive(true);
        setVisible(true);

        // Choose a Bitmap
        setBitmapName(BITMAP_NAME);
        // Set this object up to be animated
        setAnimFps(ANIMATION_FPS);
        setAnimFrameCount(ANIMATION_FRAME_COUNT);
        setBitmapName(BITMAP_NAME);
        setAnimated(context, pixelsPerMetre, true);

        // Where does the tile start
        // X and y locations from constructor parameters
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

 public void update(long fps, float gravity) {
 }
}</pre></div><p>Now, of course, we need to<a class="indexterm" id="id00336"/> add the <code class="literal">fire.png</code> sprite sheet from <code class="literal">Chapter8/drawable</code> in the download bundle to the <code class="literal">drawable</code> folder of the project.</p><p>Then, we add to our <code class="literal">LevelManager</code> class, in the usual three ways that we have done for all our new <code class="literal">GameObject</code> derived classes.</p><p>In the <code class="literal">getBitmap</code> method, add the highlighted code:</p><div class="informalexample"><pre class="programlisting">case 'g':
    index = 7;
    break;

<span class="strong"><strong>case 'f':</strong></span>
<span class="strong"><strong>    index = 8;</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:
    index = 0;
    break;</pre></div><p>In the <code class="literal">getBitmapIndex</code> method:</p><div class="informalexample"><pre class="programlisting">case 'g':
    index = 7;
    break;

<span class="strong"><strong>case 'f':</strong></span>
<span class="strong"><strong>    index = 8;</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:
    index = 0;
    break;</pre></div><p>In the <code class="literal">loadMapData()</code> method:</p><div class="informalexample"><pre class="programlisting">case 'g':
     // Add a guard to the gameObjects
     gameObjects.add(new Guard(context, j, i, c, pixelsPerMetre));
     break;

<span class="strong"><strong>   case 'f':</strong></span>
<span class="strong"><strong>      // Add a fire tile the gameObjects</strong></span>
<span class="strong"><strong>      gameObjects.add(new Fire</strong></span>
<span class="strong"><strong>      (context, j, i, c, pixelsPerMetre));</strong></span>
<span class="strong"><strong>      </strong></span>
<span class="strong"><strong>      break;</strong></span>
</pre></div><p>Finally, we add to our <a class="indexterm" id="id00337"/>collision detection <code class="literal">switch</code> block to handle the consequences of touching this terrible tile.</p><div class="informalexample"><pre class="programlisting">case 'g':
    //hit by guard
    sm.playSound("player_burn");
    ps.loseLife();
    location = new PointF(ps.loadLocation().x,
        ps.loadLocation().y);
    lm.player.setWorldLocationX(location.x);
    lm.player.setWorldLocationY(location.y);
    lm.player.setxVelocity(0);
    break;

<span class="strong"><strong>case 'f':</strong></span>
<span class="strong"><strong>    sm.playSound("player_burn");</strong></span>
<span class="strong"><strong>    ps.loseLife();</strong></span>
<span class="strong"><strong>    location = new PointF(ps.loadLocation().x,</strong></span>
<span class="strong"><strong>        ps.loadLocation().y);</strong></span>
<span class="strong"><strong>    lm.player.setWorldLocationX(location.x);</strong></span>
<span class="strong"><strong>    lm.player.setWorldLocationY(location.y);</strong></span>
<span class="strong"><strong>    lm.player.setxVelocity(0);</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:// Probably a regular tile
    if (hit == 1) {// Left or right
        lm.player.setxVelocity(0);
        lm.player.setPressingRight(false);
    }

    if (hit == 2) {// Feet
        lm.player.isFalling = false;
    }
    break;</pre></div><p>Why not add a <a class="indexterm" id="id00338"/>few <code class="literal">f</code> tiles to <code class="literal">LevelCave</code> and experiment with what the player is able to jump over. It will help us design some challenging levels later in the chapter.</p><div class="mediaobject"><img alt="Adding some fire tiles" src="graphics/B04322_08_02.jpg"/></div><p>We don't want <a class="indexterm" id="id00339"/>our player to be walking on the grass the whole time, so let's add some more variety.</p></div>
<div class="section" title="Eye candy"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec045"/>Eye candy</h1></div></div></div><p>The next three sections in<a class="indexterm" id="id00340"/> this chapter will be purely aesthetic. We will add a whole bunch of different tile graphics with matching classes so that we can use a whole lot more artistic license to make our levels more interesting. The difference between the tiles will be purely visual, but it will be fairly simple to make them more functional than that.</p><p>For example, we can easily detect collision with a snow tile and have the player keep moving briefly after stopping to simulate skidding, or perhaps; the concrete tile can allow the player to move faster and therefore change the way we design big jumps and so on. The point is that you don't have to just copy paste the classes as they will be presented here.</p><p>We will also add some completely aesthetic props: mine carts, boulders, stalactites, and more. There will be no collision detection for these objects. They will allow the level designer to make the levels more visually interesting.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0012"/>Tip</h3><p>It would be simple to make these aesthetics more functional. Just add a hitbox and a case in the collision detection switch block to handle the consequences.</p></div></div><p>Probably, the most <a class="indexterm" id="id00341"/>visually significant improvement we add, will be scrolling backgrounds. We will add some classes to allow the level designer to add multiple different scrolling backgrounds to a level design.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0013"/>Tip</h3><p>Why not add all the graphics from the <code class="literal">Chapter8/drawable</code> folder of the download bundle to the <code class="literal">drawable</code> folder of your project. Then, you will have all the graphics ready and in place, for this and the next two sections as well.</p></div></div><div class="section" title="The new platform tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec054"/>The new platform tiles</h2></div></div></div><p>Now, add all these classes with the <a class="indexterm" id="id00342"/>filenames as shown. I have removed all comments from the code because they are all functionally the same as the <code class="literal">Grass</code> class. Create each of the following classes with the name shown and enter the code:</p><p>Here is the code for the <code class="literal">Brick</code> class:</p><div class="informalexample"><pre class="programlisting">public class Brick extends GameObject {

    Brick(float worldStartX, float worldStartY, char type) {
        setTraversable();
        final float HEIGHT = 1;
        final float WIDTH = 1;
        setHeight(HEIGHT); 
        setWidth(WIDTH); 
        setType(type);
        setBitmapName("brick");
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>This is the code for the <code class="literal">Coal</code> class:</p><div class="informalexample"><pre class="programlisting">public class Coal extends GameObject {

    Coal(float worldStartX, float worldStartY, char type) {
        setTraversable();
        final float HEIGHT = 1;
        final float WIDTH = 1;
        setHeight(HEIGHT); 
        setWidth(WIDTH);
        setType(type);
        setBitmapName("coal");
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>Here is the code<a class="indexterm" id="id00343"/> for the <code class="literal">Concrete</code> class:</p><div class="informalexample"><pre class="programlisting">public class Concrete extends GameObject {

    Concrete(float worldStartX, float worldStartY, char type) {
        setTraversable();
        final float HEIGHT = 1;
        final float WIDTH = 1;
        setHeight(HEIGHT);
        setWidth(WIDTH);
        setType(type);
        setBitmapName("concrete");
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>The following is the code for the <code class="literal">Scorched</code> class:</p><div class="informalexample"><pre class="programlisting">public class Scorched extends GameObject {

    Scorched(float worldStartX, float worldStartY, char type) {
        setTraversable();
        final float HEIGHT = 1;
        final float WIDTH = 1;
        setHeight(HEIGHT);
        setWidth(WIDTH);
        setType(type);
        setBitmapName("scorched");
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>This is the code <a class="indexterm" id="id00344"/>for the <code class="literal">Snow</code> class:</p><div class="informalexample"><pre class="programlisting">public class Snow extends GameObject {

    Snow(float worldStartX, float worldStartY, char type) {
        setTraversable();
        final float HEIGHT = 1;
        final float WIDTH = 1;
        setHeight(HEIGHT);
        setWidth(WIDTH);
        setType(type);
        setBitmapName("snow");
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>Here is the code for the <code class="literal">Stone</code> class:</p><div class="informalexample"><pre class="programlisting">public class Stone extends GameObject {

    Stone(float worldStartX, float worldStartY, char type) {
        setTraversable();
        final float HEIGHT = 1;
        final float WIDTH = 1;
        setHeight(HEIGHT);
        setWidth(WIDTH); 
        setType(type);
        setBitmapName("stone");
        setWorldLocation(worldStartX, worldStartY, 0);
        setRectHitbox();
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>Now, as we are getting used to, we need to add them all into our <code class="literal">LevelManager</code> in the usual three places.</p><p>In <code class="literal">getBitmap()</code>, we <a class="indexterm" id="id00345"/>simply add them in as normal. Note that although the values are arbitrary, we will use numbers for the type 2,3,4, and so on. This makes it easy to remember, while designing levels, that all our actual platforms are numbers. The actual index numbers are unimportant to us, as long as they are the same as in the <code class="literal">getBitmapIndex</code> method. Also, remember that we have a list of types in our <code class="literal">LevelData</code> class's comments, for easy reference when designing levels.</p><div class="informalexample"><pre class="programlisting">case 'f':
    index = 8;
    break;

<span class="strong"><strong>case '2':</strong></span>
<span class="strong"><strong>    index = 9;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '3':</strong></span>
<span class="strong"><strong>    index = 10;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '4':</strong></span>
<span class="strong"><strong>    index = 11;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '5':</strong></span>
<span class="strong"><strong>    index = 12;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '6':</strong></span>
<span class="strong"><strong>    index = 13;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '7':</strong></span>
<span class="strong"><strong>    index = 14;</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:
    index = 0;
    break;</pre></div><p>In <code class="literal">getBitmapIndex()</code>, we do the same thing:</p><div class="informalexample"><pre class="programlisting">case 'f':
    index = 8;
    break;

<span class="strong"><strong>case '2':</strong></span>
<span class="strong"><strong>    index = 9;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '3':</strong></span>
<span class="strong"><strong>    index = 10;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '4':</strong></span>
<span class="strong"><strong>    index = 11;</strong></span>
<span class="strong"><strong>   break;</strong></span>

<span class="strong"><strong>case '5':</strong></span>
<span class="strong"><strong>    index = 12;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '6':</strong></span>
<span class="strong"><strong>    index = 13;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '7':</strong></span>
<span class="strong"><strong>    index = 14;</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:
    index = 0;
    break;</pre></div><p>In <code class="literal">loadMapData()</code>, we just <a class="indexterm" id="id00346"/>call <code class="literal">new()</code> on our new <code class="literal">GameObjects</code> to add them to our <code class="literal">gameObjects</code> list.</p><div class="informalexample"><pre class="programlisting">case 'f':
    // Add a fire tile the gameObjects
    gameObjects.add(new Fire(context, j, i, c, pixelsPerMetre));
    break;

<span class="strong"><strong>case '2':</strong></span>
<span class="strong"><strong>    // Add a tile to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Snow(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '3':</strong></span>
<span class="strong"><strong>    // Add a tile to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Brick(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '4':</strong></span>
<span class="strong"><strong>    // Add a tile to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Coal(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '5':</strong></span>
<span class="strong"><strong>    // Add a tile to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Concrete(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '6':</strong></span>
<span class="strong"><strong>    // Add a tile to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Scorched(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case '7':</strong></span>
<span class="strong"><strong>    // Add a tile to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Stone(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>
</pre></div><p>Now, go wild adding <a class="indexterm" id="id00347"/>different terrains to the <code class="literal">LevelCave</code> class:</p><div class="mediaobject"><img alt="The new platform tiles" src="graphics/B04322_08_03.jpg"/></div><p>Now, to add <a class="indexterm" id="id00348"/>some scenery objects.</p></div><div class="section" title="The new scenery objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec055"/>The new scenery objects</h2></div></div></div><p>Here, we will add <a class="indexterm" id="id00349"/>some objects that don't do anything but look pretty. We will let the game engine know by simply not adding a hitbox and setting them randomly to either z layer -1, or 1. Then the player can appear either in front or behind them.</p><p>We will first add all the classes, and then update <code class="literal">LevelManager</code> in the usual three places. Create each of the new classes as follows:</p><p>Here is the <code class="literal">Boulders</code> class:</p><div class="informalexample"><pre class="programlisting">public class Boulders extends GameObject {

    Boulders(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = 1;
        final float WIDTH = 3;

        setHeight(HEIGHT); // 1 metre tall
        setWidth(WIDTH); // 1 metre wide

        setType(type);

        // Choose a Bitmap
        setBitmapName("boulder");
        setActive(false);//don't check for collisions etc
        
        // Randomly set the tree either just in front or just 
        //behind the player -1 or 1
        Random rand = new Random();
        if(rand.nextInt(2)==0) {
            setWorldLocation(worldStartX, worldStartY, -1);
        }else{
            setWorldLocation(worldStartX, worldStartY, 1);//
        }
        //No hitbox!!
        
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>From now on, I<a class="indexterm" id="id00350"/> removed all the comments to save digital ink. The class functionality is the same as it is in <code class="literal">Boulders</code>, just the attributes vary a bit.</p><p>Here is the <code class="literal">Cart</code> class:</p><div class="informalexample"><pre class="programlisting">public class Cart extends GameObject {

  Cart(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = 2;
        final float WIDTH = 3;
        setWidth(WIDTH);
        setHeight(HEIGHT);
        setType(type);
        setBitmapName("cart");
        setActive(false);
        Random rand = new Random();
        if(rand.nextInt(2)==0) {
          setWorldLocation(worldStartX, worldStartY, -1);
        }else{
          setWorldLocation(worldStartX, worldStartY, 1);
        }
     }
    
  public void update(long fps, float gravity) {
     }
}</pre></div><p>This is the <a class="indexterm" id="id00351"/>code for the <code class="literal">Lampost</code> class:</p><div class="informalexample"><pre class="programlisting">public class Lampost extends GameObject {

  Lampost(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = 3;
        final float WIDTH = 1;
        setHeight(HEIGHT);
        setWidth(WIDTH); 
        setType(type);
        setBitmapName("lampost");
        setActive(false);
        Random rand = new Random();
        if(rand.nextInt(2)==0) {
          setWorldLocation(worldStartX, worldStartY, -1);
        }else{
          setWorldLocation(worldStartX, worldStartY, 1);
        }
  }

    public void update(long fps, float gravity) {
   }
}</pre></div><p>Here is the <code class="literal">Stalagmite</code> class:</p><div class="informalexample"><pre class="programlisting">import java.util.Random;

public class Stalagmite extends GameObject {

  Stalagmite(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = 3;
        final float WIDTH = 2;
        setHeight(HEIGHT);
        setWidth(WIDTH);
        setType(type);
        setBitmapName("stalacmite");
        setActive(false);
        Random rand = new Random();
        if(rand.nextInt(2)==0) {
         setWorldLocation(worldStartX, worldStartY, -1);
        }else{
         setWorldLocation(worldStartX, worldStartY, 1);
        }
    }

    public void update(long fps, float gravity) {
    }
}</pre></div><p>This is the<a class="indexterm" id="id00352"/> <code class="literal">Stalactite</code> class:</p><div class="informalexample"><pre class="programlisting">import java.util.Random;

public class Stalactite extends GameObject {

  Stalactite(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = 3;
        final float WIDTH = 2;
        setHeight(HEIGHT);
        setWidth(WIDTH);
        setType(type);
        setBitmapName("stalactite");
        setActive(false);
        Random rand = new Random();
        if(rand.nextInt(2)==0) {
          setWorldLocation(worldStartX, worldStartY, -1);
        }else{
          setWorldLocation(worldStartX, worldStartY, 1);
        }
  }

     public void update(long fps, float gravity) {
     }
}</pre></div><p>Here is the <code class="literal">Tree</code> class:</p><div class="informalexample"><pre class="programlisting">import java.util.Random;

public class Tree extends GameObject {

  Tree(float worldStartX, float worldStartY, char type) {

       final float HEIGHT = 4;
       final float WIDTH = 2;
       setWidth(WIDTH);
        setHeight(HEIGHT);
        setType(type);
        setBitmapName("tree1");
        setActive(false);
        Random rand = new Random();
        if(rand.nextInt(2)==0) {
          setWorldLocation(worldStartX, worldStartY, -1);
        }else{
          setWorldLocation(worldStartX, worldStartY, 1);
        }
     }

     public void update(long fps, float gravity) {
     }
}</pre></div><p>And this is<a class="indexterm" id="id00353"/> the <code class="literal">Tree2</code> class:</p><div class="informalexample"><pre class="programlisting">import java.util.Random;

public class Tree2 extends GameObject {

  Tree2(float worldStartX, float worldStartY, char type) {

        final float HEIGHT = 4;
        final float WIDTH = 2;
        setWidth(WIDTH);
        setHeight(HEIGHT);
        setType(type);
        setBitmapName("tree2");
        setActive(false);
        Random rand = new Random();
        if(rand.nextInt(2)==0) {
          setWorldLocation(worldStartX, worldStartY, -1);
        }else{
          setWorldLocation(worldStartX, worldStartY, 1);
        }
  }

     public void update(long fps, float gravity) {
     }
}</pre></div><p>That's all the new classes for the scenery objects. Now, we can update the <code class="literal">getBitmap</code> method with the seven new types in the <code class="literal">LevelManager</code> class.</p><div class="informalexample"><pre class="programlisting">case '7':
    index = 14;
    break;

<span class="strong"><strong>case 'w':</strong></span>
<span class="strong"><strong>    index = 15;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'x':</strong></span>
<span class="strong"><strong>    index = 16;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'l':</strong></span>
<span class="strong"><strong>    index = 17;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'r':</strong></span>
<span class="strong"><strong>    index = 18;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 's':</strong></span>
<span class="strong"><strong>    index = 19;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'm':</strong></span>
<span class="strong"><strong>    index = 20;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'z':</strong></span>
<span class="strong"><strong>    index = 21;</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:
    index = 0;
    break;</pre></div><p>Update the <code class="literal">getBitmapIndex</code> <a class="indexterm" id="id00354"/>method in the same way:</p><div class="informalexample"><pre class="programlisting">case '7':
    index = 14;
    break;

<span class="strong"><strong>case 'w':</strong></span>
<span class="strong"><strong>    index = 15;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'x':</strong></span>
<span class="strong"><strong>    index = 16;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'l':</strong></span>
<span class="strong"><strong>    index = 17;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'r':</strong></span>
<span class="strong"><strong>    index = 18;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 's':</strong></span>
<span class="strong"><strong>    index = 19;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'm':</strong></span>
<span class="strong"><strong>    index = 20;</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'z':</strong></span>
<span class="strong"><strong>    index = 21;</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:
    index = 0;
    break;</pre></div><p>Finally, make sure our<a class="indexterm" id="id00355"/> new scenery items are added to our <code class="literal">gameObjects</code> array list:</p><div class="informalexample"><pre class="programlisting">case '7':
    // Add a tile to the gameObjects
    gameObjects.add(new Stone(j, i, c));
    break;

<span class="strong"><strong>case 'w':</strong></span>
<span class="strong"><strong>    // Add a tree to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Tree(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'x':</strong></span>
<span class="strong"><strong>    // Add a tree2 to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Tree2(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'l':</strong></span>
<span class="strong"><strong>    // Add a tree to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Lampost(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'r':</strong></span>
<span class="strong"><strong>    // Add a stalactite to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Stalactite(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 's':</strong></span>
<span class="strong"><strong>    // Add a stalagmite to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Stalagmite(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'm':</strong></span>
<span class="strong"><strong>    // Add a cart to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Cart(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>

<span class="strong"><strong>case 'z':</strong></span>
<span class="strong"><strong>    // Add a boulders to the gameObjects</strong></span>
<span class="strong"><strong>    gameObjects.add(new Boulders(j, i, c));</strong></span>
<span class="strong"><strong>    break;</strong></span>
</pre></div><p>Now, we can<a class="indexterm" id="id00356"/> design levels with scenery. Note the slight difference in appearance when an object is drawn on layer zero compared to layer one and how the player character passes either in front or behind:</p><div class="mediaobject"><img alt="The new scenery objects" src="graphics/B04322_08_04.jpg"/></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0014"/>Tip</h3><p>Of course, if you want to bump into lamposts, get skewered by stalagmites, or jump on top of mine carts, then just give them a hitbox.</p></div></div><p>We have <a class="indexterm" id="id00357"/>one more way to beautify our game world.</p></div><div class="section" title="Scrolling parallax backgrounds"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec056"/>Scrolling parallax backgrounds</h2></div></div></div><p>Parallax backgrounds are <a class="indexterm" id="id00358"/>scrolling backgrounds, where we scroll them slower the farther away they are. So, if we have a grass verge at the player's feet, we will scroll it quickly. However, if we have a mountain range in the distance, we will scroll it slowly. This effect can give the sense of motion to the player.</p><p>To implement them, we will first add a data structure to represent the parameters of a background. We will call this class <code class="literal">BackgroundData</code>, we will then implement a <code class="literal">Background</code> class, which has the functionality necessary to control the scrolling and then we will see how to position and define backgrounds in our level design. Finally, we will write a <code class="literal">drawBackground</code> method that we will call from our regular <code class="literal">draw</code> method.</p><p>Make sure you added all the graphics from the <code class="literal">Chapter8/drawable</code> folder of the download bundle to the <code class="literal">drawable</code> folder of your project.</p><p>First, let's build a simple class to hold the data structure which will define our backgrounds. As <a class="indexterm" id="id00359"/>we can see in the next block of code, we have quite a large number of parameters and member variables. We will need to know which bitmap will represent a background, which layer on the <span class="emphasis"><em>z</em></span> axis to draw it (in front on 1 or behind on -1), where in the world on the <span class="emphasis"><em>y</em></span> axis it starts and finishes, how fast the background will scroll, and how high the background will be.</p><p>The <code class="literal">isParallax</code> Boolean is intended to give the option to have a background which is static, but we will not be implementing this feature. When you see the code for the background class, you will see it is simple to add this functionality if you want to.</p><p>Create a new class and call it <code class="literal">BackgroundData</code>, then implement it with the following code:</p><div class="informalexample"><pre class="programlisting">public class BackgroundData {
  String bitmapName;
     boolean isParallax;
     //layer 0 is the map
     int layer;
     float startY;
     float endY;
     float speed;
     int height;
     int width;

     BackgroundData(String bitmap, boolean isParallax, 
     int layer, float startY, float endY, 
     float speed, int height){
      
      this.bitmapName = bitmap;
      this.isParallax = isParallax;
      this.layer = layer;
      this.startY = startY;
      this.endY = endY;
      this.speed = speed;
      this.height = height;
  }
}</pre></div><p>Now, we add an <code class="literal">ArrayList</code> of our new type to the <code class="literal">LevelData</code> class:</p><div class="informalexample"><pre class="programlisting">ArrayList&lt;String&gt; tiles;
<span class="strong"><strong>ArrayList&lt;BackgroundData&gt; backgroundDataList;</strong></span>

// This class will evolve along with the project</pre></div><p>Next, let's create the <code class="literal">Background</code> class itself. Create a new class and name it <code class="literal">Background</code>. First, we set up a bunch of variables to hold a copy of the background image along with a reversed copy. We will make the backgrounds seem <span class="emphasis"><em>endless</em></span> by putting the images back to back alternating between the regular image and a reversed image. We will see how to achieve this further on in the code.</p><p>We also have <a class="indexterm" id="id00360"/>variables for the width and height of the image in pixels. The <code class="literal">reversedFirst</code> Boolean will determine which copy of the image is currently drawn on the left-hand side of the screen (first) and will change as the player moves and the image scrolls. The <code class="literal">xClip</code> variable will hold the precise pixel of the <span class="emphasis"><em>x</em></span> axis (of the image), where we will cut the image and start to draw it from the left hand edge of the screen.</p><p>The <code class="literal">y</code>, <code class="literal">endY</code>, <code class="literal">z</code>, and <code class="literal">speed</code> member variables are to hold the related values passed in as parameters:</p><div class="informalexample"><pre class="programlisting">import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;

public class Background {

     Bitmap bitmap;
     Bitmap bitmapReversed;

     int width;
     int height;

     boolean reversedFirst;
     int xClip;// controls where we clip the bitmaps each frame
     float y;
     float endY;
     int z;

     float speed;
     boolean isParallax;//Not currently used</pre></div><p>Now, in the constructor, we create an Android resource ID from the name of the graphic file passed in as a parameter. Then, create the actual bitmap by calling <code class="literal">BitmapFactory.decodeResource()</code>. We set <code class="literal">reversedFirst</code> to <code class="literal">false</code>, so we will start with the regular (non-reversed) copy of the image on the left-hand side of the screen. We initialize our member variables and then scale the bitmap we just created by calling <code class="literal">Bitmap.createScaledBitmap()</code> and passing in bitmap, the width of the screen and the height (in the game world) of our background multiplied by the <code class="literal">pixelsPerMetre</code>, making the bitmap exactly the right size for the current devices screen.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0015"/>Tip</h3><p>Note that we must choose appropriate heights for our background designs or they will appear stretched.</p></div></div><p>The last thing<a class="indexterm" id="id00361"/> we do in the constructor is create a <code class="literal">Matrix</code> object and send it to the <code class="literal">createScaledBitmap</code> method along with the bitmap, so we now have a reversed copy of our background image stored in the <code class="literal">bitmapReversed Bitmap</code> object.</p><div class="informalexample"><pre class="programlisting">  Background(Context context, int yPixelsPerMetre, 
    int screenWidth, BackgroundData data){

      int resID =   context.getResources().getIdentifier
      (data.bitmapName, "drawable", 
      context.getPackageName());

          bitmap = BitmapFactory.decodeResource
          (context.getResources(), resID);

          // Which version of background (reversed or regular) is // currently drawn first (on left)
          reversedFirst = false;

          //Initialize animation variables.
          xClip = 0;  //always start at zero
          y = data.startY;
          endY = data.endY;
          z = data.layer;
          isParallax = data.isParallax;
          speed = data.speed; //Scrolling background speed

          //Scale background to fit the screen.
          bitmap = Bitmap.createScaledBitmap(bitmap, screenWidth,
                data.height * yPixelsPerMetre
                , true); 

          width = bitmap.getWidth();
          height = bitmap.getHeight();

          // Create a mirror image of the background
          Matrix matrix = new Matrix();  
          matrix.setScale(-1, 1); //Horizontal mirror effect.
          bitmapReversed = Bitmap.createBitmap(
          bitmap, 0, 0, width, height, matrix, true);

    }
}</pre></div><p>Now, we add two backgrounds to our level design. We fill out the required parameters that we have<a class="indexterm" id="id00362"/> already discussed. Note that the "grass" background on layer 1 scrolls much faster than the "skyline" background on layer -1. This will create the desired parallax effect. Add this code right at the end of the <code class="literal">LevelCave</code> constructor:</p><div class="informalexample"><pre class="programlisting">backgroundDataList = new ArrayList&lt;BackgroundData&gt;();
// note that speeds less than 2 cause problems
this.backgroundDataList.add(
  new BackgroundData("skyline", true, -1, 3, 18, 10, 15 ));

this.backgroundDataList.add(
  new BackgroundData("grass", true, 1, 20, 24, 24, 4 ));</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0025"/>Note</h3><p>It is certainly true that most caves do not have grass and a skyline. This is just a demonstration and to get the code working. We will redesign <code class="literal">LevelCave</code> and design some more appropriate levels a little later in this chapter.</p></div></div><p>Now, we load them with our <code class="literal">LevelManager</code> class by declaring a new <code class="literal">Arraylist</code> object as a member of our <code class="literal">LevelManager</code> class.</p><div class="informalexample"><pre class="programlisting">LevelData levelData;
ArrayList&lt;GameObject&gt; gameObjects;
<span class="strong"><strong>ArrayList&lt;Background&gt; backgrounds;</strong></span>
</pre></div><p>Then, add a new method in <code class="literal">LevelManager</code> to load the background data:</p><div class="informalexample"><pre class="programlisting">private void loadBackgrounds(Context context, 
  int pixelsPerMetre, int screenWidth) {
        
  backgrounds = new ArrayList&lt;Background&gt;();
     //load the background data into the Background objects and
     // place them in our GameObject arraylist
     for (BackgroundData bgData : levelData.backgroundDataList) {
            backgrounds.add(new Background(context,       
            pixelsPerMetre, screenWidth, bgData));
     }
}</pre></div><p>We call the new method in the <code class="literal">LevelManager</code> constructor:</p><div class="informalexample"><pre class="programlisting">// Load all the GameObjects and Bitmaps
loadMapData(context, pixelsPerMetre, px, py);
<span class="strong"><strong>loadBackgrounds(context, pixelsPerMetre, screenWidth);</strong></span>
</pre></div><p>And, not for the last<a class="indexterm" id="id00363"/> time, we will upgrade our <code class="literal">Viewport</code> class to enable our <code class="literal">PlatformView</code> methods to get the information they need, to draw the parallax backgrounds.</p><div class="informalexample"><pre class="programlisting">public int getPixelsPerMetreY(){
  return  pixelsPerMetreY;
}
    
public int getyCentre(){
  return screenCentreY;
}

public float getViewportWorldCentreY(){
  return currentViewportWorldCentre.y;
}</pre></div><p>Then, we will add a method which actually does the drawing in the <code class="literal">PlatformView</code> class. We will call this method from <code class="literal">onDraw()</code>, in just the right places, next. Note that we are using the new methods that we just added to the <code class="literal">Viewport</code> class.</p><p>First, we define four <code class="literal">Rect</code> objects that we will use to hold the start and end points of <code class="literal">bitmap</code> and <code class="literal">reversedBitmap</code>.</p><p>Implement the first part of the <code class="literal">drawBackground</code> method as shown:</p><div class="informalexample"><pre class="programlisting">private void drawBackground(int start, int stop) {

     Rect fromRect1 = new Rect();
     Rect toRect1 = new Rect();
     Rect fromRect2 = new Rect();
     Rect toRect2 = new Rect();</pre></div><p>Now, we simply loop through all our backgrounds using the <code class="literal">start</code> and <code class="literal">stop</code> parameters to decide which backgrounds have a <span class="emphasis"><em>z</em></span> layer that we are currently interested in drawing.</p><div class="informalexample"><pre class="programlisting">     for (Background bg : lm.backgrounds) {
     if (bg.z &lt; start &amp;&amp; bg.z &gt; stop) {
          </pre></div><p>Next, we send the world coordinates of the background to the <code class="literal">Viewport</code> class for clipping. If it isn't clipped (and should be drawn), we get the starting pixel coordinates, and ending pixel coordinates on the <span class="emphasis"><em>y</em></span> axis with the help of the new methods we added to our <code class="literal">Viewport</code> class previously. Note that we cast the results to <code class="literal">int</code> variables ready to be drawn to the screen.</p><div class="informalexample"><pre class="programlisting">          // Is this layer in the viewport?
            // Clip anything off-screen
            if (!vp.clipObjects(-1, bg.y, 1000, bg.height)) {
                float floatstartY = ((vp.getyCentre() -                     
                    ((vp.getViewportWorldCentreY() - bg.y) * 
                    vp.getPixelsPerMetreY())));
                    
                int startY = (int) floatstartY;
                
                float floatendY = ((vp.getyCentre() -           
                    ((vp.getViewportWorldCentreY() - bg.endY) *                                 
                    vp.getPixelsPerMetreY())));
            
                int endY = (int) floatendY;</pre></div><p>This next block of <a class="indexterm" id="id00364"/>code is where the real action takes place. We initialize the four <code class="literal">Rect</code> objects with the starting and ending coordinates of the first and second of our two <code class="literal">Bitmap</code> objects. Note that the point (or pixel) that is calculated, is determined by <code class="literal">xClip</code>, which is initially zero. So, to start with, we will simply see <code class="literal">background</code> (if it is not clipped) stretched across the width of the screen. Soon, we will see that we modify <code class="literal">xClip</code> based on Bob's velocity and cause different regions from each bitmap to be shown:</p><div class="informalexample"><pre class="programlisting">        // Define what portion of bitmaps to capture 
        // and what coordinates to draw them at
        fromRect1 = new Rect(0, 0, bg.width - bg.xClip,     
          bg.height);
                    
        toRect1 = new Rect(bg.xClip, startY, bg.width, endY);
             fromRect2 = new Rect(bg.width - bg.xClip, 0, bg.width, bg.height);
                    
        toRect2 = new Rect(0, startY, bg.xClip, endY);
        }// End if (!vp.clipObjects...</pre></div><p>Now, we determine which background (regular or reversed) is currently being drawn first, and then draw that one first followed by the other.</p><div class="informalexample"><pre class="programlisting">          //draw backgrounds
            if (!bg.reversedFirst) {
                             
                canvas.drawBitmap(bg.bitmap,
                    fromRect1, toRect1, paint);
                canvas.drawBitmap(bg.bitmapReversed, 
                    fromRect2, toRect2, paint);
            
            } else {
                canvas.drawBitmap(bg.bitmap, 
                    fromRect2, toRect2, paint);
                    
                canvas.drawBitmap(bg.bitmapReversed, 
                    fromRect1, toRect1, paint);
            }</pre></div><p>We can scroll along<a class="indexterm" id="id00365"/> based on the speed and direction of Bob, <code class="literal">lv.player.getxVelocity()</code> and if <code class="literal">xClip</code> has reached the end of the current first background, <code class="literal">if (bg.xClip &gt;= bg.width)</code>, simply set <code class="literal">xClip</code> to zero and change which bitmap we show first.</p><div class="informalexample"><pre class="programlisting">          // Calculate the next value for the background's
            // clipping position by modifying xClip
            // and switching which background is drawn first,
            // if necessary.
            bg.xClip -= lm.player.getxVelocity() / (20 / bg.speed);
            if (bg.xClip &gt;= bg.width) {
                bg.xClip = 0;
                bg.reversedFirst = !bg.reversedFirst;
            } 
            else if (bg.xClip &lt;= 0) {
                bg.xClip = bg.width;
                bg.reversedFirst = !bg.reversedFirst;

            }
        }
    }
}</pre></div><p>Then, we add a call to <code class="literal">drawBackground()</code> just before our game objects for backgrounds with a <span class="emphasis"><em>z</em></span> layer less than zero.</p><div class="informalexample"><pre class="programlisting">// Rub out the last frame with arbitrary color
paint.setColor(Color.argb(255, 0, 0, 255));
canvas.drawColor(Color.argb(255, 0, 0, 255));

<span class="strong"><strong>// Draw parallax backgrounds from -1 to -3</strong></span>
<span class="strong"><strong>drawBackground(0, -3);</strong></span>
            
// Draw all the GameObjects
Rect toScreen2d = new Rect();</pre></div><p>Just after the bullets are drawn, but before the debugging text for those backgrounds with a <span class="emphasis"><em>z</em></span> order more than zero.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Draw parallax backgrounds from layer 1 to 3</strong></span>
<span class="strong"><strong>drawBackground(4, 0);</strong></span>
            
// Text for debugging</pre></div><p>Now, we can really <a class="indexterm" id="id00366"/>start to get creative with our level designs.</p><div class="mediaobject"><img alt="Scrolling parallax backgrounds" src="graphics/B04322_08_05.jpg"/></div><p>Very soon, we will make some real playable levels that use all the features we have implemented over the last four chapters. Before we do that, let's have a bit of fun with the <code class="literal">Viewport</code> class.</p><p>It will be really useful for the player to scan around a level and plan a route. Equally, it will be helpful when designing levels, to zoom around the level to see how a particular part of the level looks without having to get the player character to that part in order to see it on the screen. So, let's make the pause screen into a moveable viewport.</p></div><div class="section" title="Pause menu with moveable viewport"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec057"/>Pause menu with moveable viewport</h2></div></div></div><p>This is nice and quick. We will just add a <a class="indexterm" id="id00367"/>bunch of new methods to our <code class="literal">Viewport</code> class to change the center of focus. Then, we will call them from <code class="literal">InputController</code>.</p><p>If you remember when we implemented the <code class="literal">InputController</code> class back in <a class="link" href="ch15.html" title="Chapter 6. Platformer – Bob, Beeps, and Bumps">Chapter 6</a>, <span class="emphasis"><em>Platformer – Bob, Beeps and Bumps</em></span>, we wrapped all the control logic in an <code class="literal">if(playing)</code> test. We also implemented the pause button already in the <code class="literal">else</code> clause. All we will do is use the left, right, jump, and shoot buttons as left, right, up, and down, respectively, for moving<a class="indexterm" id="id00368"/> the viewport.</p><p>First, add these methods to the <code class="literal">Viewport</code> class:</p><div class="informalexample"><pre class="programlisting">public void moveViewportRight(int maxWidth){
  if(currentViewportWorldCentre.x &lt; maxWidth -       
    (metresToShowX/2)+3) {

     currentViewportWorldCentre.x += 1;
  }
}

public void moveViewportLeft(){
  if(currentViewportWorldCentre.x &gt; (metresToShowX/2)-3){
    currentViewportWorldCentre.x -= 1;
     }
}

public void moveViewportUp(){
  if(currentViewportWorldCentre.y &gt; (metresToShowY /2)-3) {
        currentViewportWorldCentre.y -= 1;
   }
}

public void moveViewportDown(int maxHeight){
  if(currentViewportWorldCentre.y &lt; 
    maxHeight - (metresToShowY / 2)+3) {
            
    currentViewportWorldCentre.y += 1;
  }
}</pre></div><p>Now, add these calls to the methods from the <code class="literal">else</code> clause of the <code class="literal">if</code> condition in the <code class="literal">InputController</code> class that we were just discussing.</p><div class="informalexample"><pre class="programlisting">//Move the viewport around to explore the map
switch (motionEvent.getAction() &amp; MotionEvent.ACTION_MASK) {
  case MotionEvent.ACTION_DOWN:
<span class="strong"><strong>       if (right.contains(x, y)) {</strong></span>
<span class="strong"><strong>          vp.moveViewportRight(l.mapWidth);</strong></span>
<span class="strong"><strong>        } else if (left.contains(x, y)) {</strong></span>
<span class="strong"><strong>          vp.moveViewportLeft();</strong></span>
<span class="strong"><strong>        } else if (jump.contains(x, y)) {</strong></span>
<span class="strong"><strong>          vp.moveViewportUp();</strong></span>
<span class="strong"><strong>        } else if (shoot.contains(x, y)) {</strong></span>
<span class="strong"><strong>          vp.moveViewportDown(l.mapHeight);</strong></span>
<span class="strong"><strong>        } else if (pause.contains(x, y)) {</strong></span>
<span class="strong"><strong>          l.switchPlayingStatus();</strong></span>
<span class="strong"><strong>        }</strong></span>
      break;
}</pre></div><p>On the pause <a class="indexterm" id="id00369"/>screen, the player can look around and plan their route when they are on more complicated levels. They are probably going to need to.</p></div><div class="section" title="Levels and game rules"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec058"/>Levels and game rules</h2></div></div></div><p>We have <a class="indexterm" id="id00370"/>implemented so<a class="indexterm" id="id00371"/> many features, but we still don't have a way to put them altogether into a playable game. We need to be able to travel between levels, and have the player state persist when we do.</p><div class="section" title="Traveling between levels"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec027"/>Traveling between levels</h3></div></div></div><p>As we are going to design<a class="indexterm" id="id00372"/> four levels, we want the player to be able to travel between them. First, let's add code to the <code class="literal">switch</code> statement at the start of the <code class="literal">LevelManager</code> constructor to include all four levels that we are about to build:</p><div class="informalexample"><pre class="programlisting">switch (level) {
  case "LevelCave":
     levelData = new LevelCave();
     break;

<span class="strong"><strong>// We can add extra levels here</strong></span>
<span class="strong"><strong>case "LevelCity": </strong></span>
<span class="strong"><strong>    levelData = new LevelCity();  </strong></span>
<span class="strong"><strong>    break; </strong></span>

<span class="strong"><strong>case "LevelForest": </strong></span>
<span class="strong"><strong>    levelData = new LevelForest(); </strong></span>
<span class="strong"><strong>    break;</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>case "LevelMountain": </strong></span>
<span class="strong"><strong>    levelData = new LevelMountain(); </strong></span>
<span class="strong"><strong>    break;</strong></span>
}</pre></div><p>As we know, we start the game by calling <code class="literal">loadLevel()</code> from the <code class="literal">PlatformView</code> constructor. The arguments include the name of the level and the coordinates to spawn the player. If you are designing your own levels, then you need to decide which level and coordinates to start with. If <a class="indexterm" id="id00373"/>you will be following along with the levels I have provided, set the call to <code class="literal">loadLevel()</code> in the constructor of <code class="literal">PlatformView</code> as follows:</p><div class="informalexample"><pre class="programlisting">loadLevel("LevelCave", 1, 16);</pre></div><p>In the <code class="literal">if(lm.isPlaying())</code> block, in the <code class="literal">update</code> method, where we set the viewport to center on the player each frame; add the following code to detect (and brutally kill) the player if he falls out of the map as well as cause the game to restart with three lives, zero money, and no upgrades should he run out of lives:</p><div class="informalexample"><pre class="programlisting">if (lm.isPlaying()) {
    // Reset the players location as 
    // the world centre of the viewport
    //if game is playing
    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)
        .getWorldLocation().x,
        lm.gameObjects.get(lm.playerIndex)
        .getWorldLocation().y);

<span class="strong"><strong>    //Has player fallen out of the map?</strong></span>
<span class="strong"><strong>    if (lm.player.getWorldLocation().x &lt; 0 ||</strong></span>
<span class="strong"><strong>        lm.player.getWorldLocation().x &gt; lm.mapWidth ||</strong></span>
<span class="strong"><strong>        lm.player.getWorldLocation().y &gt; lm.mapHeight) {</strong></span>

<span class="strong"><strong>        sm.playSound("player_burn");</strong></span>
<span class="strong"><strong>        ps.loseLife();</strong></span>
<span class="strong"><strong>        PointF location = new PointF(ps.loadLocation().x,</strong></span>
<span class="strong"><strong>         ps.loadLocation().y);</strong></span>
<span class="strong"><strong>         </strong></span>
<span class="strong"><strong>        lm.player.setWorldLocationX(location.x);</strong></span>
<span class="strong"><strong>        lm.player.setWorldLocationY(location.y);</strong></span>
<span class="strong"><strong>        lm.player.setxVelocity(0);</strong></span>
<span class="strong"><strong>    }</strong></span>

<span class="strong"><strong>    // Check if game is over</strong></span>
<span class="strong"><strong>    if (ps.getLives() == 0) {</strong></span>
<span class="strong"><strong>        ps = new PlayerState();</strong></span>
<span class="strong"><strong>        loadLevel("LevelCave", 1, 16);</strong></span>
<span class="strong"><strong>    }</strong></span>
}</pre></div><p>Now, we can create a special <code class="literal">GameObject</code> class that when touched sends the player to a predetermined level and location. We can then strategically add these objects to our level designs, and they will act as the link between our levels. Create a new class and call it <code class="literal">Teleport</code>. If you haven't already done so, add the <code class="literal">door.png</code> file from <code class="literal">Chapter8/drawable</code> to the <code class="literal">drawable</code> folder of the project.</p><p>This is how our <code class="literal">Teleport</code> object will<a class="indexterm" id="id00374"/> appear in the game:</p><div class="mediaobject"><img alt="Traveling between levels" src="graphics/B04322_08_06.jpg"/></div><p>Let's make a simple class to hold the data that each <code class="literal">Teleport</code> object will need. Create a new class called <code class="literal">Location</code> like this:</p><div class="informalexample"><pre class="programlisting">public class Location {
     String level;
     float x;
     float y;

     Location(String level, float x, float y){
        this.level = level;
        this.x = x;
        this.y = y;
     }
}</pre></div><p>The actual <code class="literal">Teleport</code> class looks just like any other <code class="literal">GameObject</code> class, but note that it also has a member <code class="literal">Location</code> variable. We will see how the level design will hold the destination of the <code class="literal">Teleport</code>, the <code class="literal">LevelManager</code> class will initialize it, and then when the player collides with it, we can load the new location, sending the player off to his destination.</p><div class="informalexample"><pre class="programlisting">public class Teleport extends GameObject {

    Location target;

    Teleport(float worldStartX, float worldStartY, 
        char type, Location target) {

        final float HEIGHT = 2;
        final float WIDTH = 2;
        setHeight(HEIGHT); // 2 metres tall
        setWidth(WIDTH); // 1 metre wide
        setType(type);
        setBitmapName("door");
       
        this.target = new Location(target.level, 
            target.x, target.y);

        // Where does the tile start
        // X and y locations from constructor parameters
        setWorldLocation(worldStartX, worldStartY, 0);

        setRectHitbox();
    }

    public Location getTarget(){
        return target;
    }

    public void update(long fps, float gravity){
    }
}</pre></div><p>To make our <code class="literal">Teleport</code> class <a class="indexterm" id="id00375"/>work in a way that lets the level designer decide what it will do exactly, we need to add to our <code class="literal">LevelData</code> class like this:</p><div class="informalexample"><pre class="programlisting">ArrayList&lt;String&gt; tiles;
ArrayList&lt;BackgroundData&gt; backgroundDataList;
<span class="strong"><strong>ArrayList&lt;Location&gt; locations;</strong></span>

// This class will evolve along with the project</pre></div><p>Then, we need to add a <code class="literal">t</code> to the level design wherever we want our teleport/door, and an entry like the next line of code, within the constructor of the class of the level we are designing.</p><p>Note that you can have as many <code class="literal">Teleport</code> objects as you like in a map, as long as the order they are defined in code matches the order they appear in the design. We will see exactly how this works when we look at our actual level designs in a minute, but the code will look like this:</p><div class="informalexample"><pre class="programlisting">// Declare the values for the teleports in order of appearance
locations = new ArrayList&lt;Location&gt;();
this.locations.add(new Location("LevelCity", 118f, 18f));</pre></div><p>As usual, we need to update <a class="indexterm" id="id00376"/>the <code class="literal">LevelManager</code> class to load and locate our teleport(s). Here is the new code for <code class="literal">getBitmap()</code>:</p><div class="informalexample"><pre class="programlisting">case 'z':
  index = 21;
  break;

<span class="strong"><strong>case 't':</strong></span>
<span class="strong"><strong>  index = 22;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>New code for <code class="literal">getBitmapIndex()</code>:</p><div class="informalexample"><pre class="programlisting">case 'z':
  index = 21;
     break;

<span class="strong"><strong>case 't':</strong></span>
<span class="strong"><strong>  index = 22;</strong></span>
<span class="strong"><strong>  break;</strong></span>

default:
  index = 0;
  break;</pre></div><p>We also need to keep track of our <code class="literal">Teleport</code> objects during the loading phase in case there is more than one. So, add a new local variable as shown in the <code class="literal">loadMapData</code> method:</p><div class="informalexample"><pre class="programlisting">//Keep track of where we load our game objects
int currentIndex = -1;
<span class="strong"><strong>int teleportIndex = -1;</strong></span>
// how wide and high is the map? Viewport needs to know</pre></div><p>Finally for the <code class="literal">LevelManager</code> class, we initialize all the teleport data from the level design, tuck it away in the object and add it to our <code class="literal">gameObject ArrayList</code>.</p><div class="informalexample"><pre class="programlisting">case 'z':
    // Add a boulders to the gameObjects
    gameObjects.add(new Boulders(j, i, c));
    break;

<span class="strong"><strong>    case 't':</strong></span>
<span class="strong"><strong>        // Add a teleport to the gameObjects</strong></span>
<span class="strong"><strong>        teleportIndex++;</strong></span>
<span class="strong"><strong>        gameObjects.add(new Teleport(j, i, c,</strong></span>
<span class="strong"><strong>        levelData.locations.get(teleportIndex)));</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>        break;</strong></span>
</pre></div><p>We are really close to <a class="indexterm" id="id00377"/>being able to teleport all over the place. We need to detect a collision with a teleport, and then load a new level with the player at the desired location. This code will go in our collision detection switch block in the <code class="literal">PlatformView</code> class like this:</p><div class="informalexample"><pre class="programlisting">case 'f':
    sm.playSound("player_burn");
    ps.loseLife();
    location = new PointF(ps.loadLocation().x,
      ps.loadLocation().y); 
    lm.player.setWorldLocationX(location.x);
    lm.player.setWorldLocationY(location.y);
    lm.player.setxVelocity(0);
    break;

<span class="strong"><strong>case 't':</strong></span>
<span class="strong"><strong>    Teleport teleport = (Teleport) go;</strong></span>
<span class="strong"><strong>    Location t = teleport.getTarget();</strong></span>
<span class="strong"><strong>    loadLevel(t.level, t.x, t.y);</strong></span>
<span class="strong"><strong>    sm.playSound("teleport");</strong></span>
<span class="strong"><strong>    break;</strong></span>

default:// Probably a regular tile
    if (hit == 1) {// Left or right
        lm.player.setxVelocity(0);
        lm.player.setPressingRight(false);
    }
    if (hit == 2) {// Feet
        lm.player.isFalling = false;
    }
    break;</pre></div><p>When a new level is loaded, the <code class="literal">Player</code>, <code class="literal">MachineGun</code>, and <code class="literal">Bullet</code> objects are all created from scratch. Therefore, we need to add a line to our <code class="literal">loadLevel</code> method to reload the current machine gun fire rate from the <code class="literal">PlayerState</code> class into the <code class="literal">MachineGun</code> class. Add the highlighted code:</p><div class="informalexample"><pre class="programlisting">ps.saveLocation(location);

<span class="strong"><strong>// Reload the players current fire rate from the player state</strong></span>
<span class="strong"><strong>lm.player.bfg.setFireRate(ps.getFireRate());</strong></span>
</pre></div><p>Now, we can work<a class="indexterm" id="id00378"/> on the level designs for real.</p></div></div><div class="section" title="The level designs"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec059"/>The level designs</h2></div></div></div><p>You can just copy and paste<a class="indexterm" id="id00379"/> four classes from the <code class="literal">Chapter8/java</code> folder into your <a class="indexterm" id="id00380"/>project and start playing, or you can start from the beginning and design your own. The levels are quite large, intricate, and tough to beat. It is not physically possible to print the level designs in a book or e-book in any meaningful way, so you will need to open up the <code class="literal">LevelCave</code>, <code class="literal">LevelCity</code>, <code class="literal">LevelForest</code>, and <code class="literal">LevelMountain</code> design files in order to see the detail of the four levels.</p><p>However, a brief discussion of the levels, pictures, and some screenshots, but not actual code from the four designs follows.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0026"/>Note</h3><p>Note that the following screenshots feature the new HUD that is the last thing we will cover in this chapter.</p></div></div><div class="section" title="The cave"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec028"/>The cave</h3></div></div></div><p>The cave level is<a class="indexterm" id="id00381"/> where the whole thing starts. It not only features modestly frustrating jumps, but also plenty of fire making a fall potentially deadly.</p><div class="mediaobject"><img alt="The cave" src="graphics/B04322_08_07.jpg"/></div><p>As the player starts with<a class="indexterm" id="id00382"/> a puny machine gun, only a few drones are present in the level. But there are two awkward guards that will require vaulting.</p><div class="mediaobject"><img alt="The cave" src="graphics/B04322_08_08.jpg"/></div></div><div class="section" title="The city"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec029"/>The city</h3></div></div></div><p>The city <a class="indexterm" id="id00383"/>holds vast rewards, especially in the bottom left-hand corner for coins and the top-left for machine gun upgrades.</p><div class="mediaobject"><img alt="The city" src="graphics/B04322_08_09.jpg"/></div><p>However, there is a very awkward-to-jump guard on the bottom level should the player want to get all those stray coins and not opt for leaving them behind. The near vertical ascent that must be traversed up the left-hand side is likely to frustrate and if the player opts not to go for the machine gun upgrades, he will probably struggle with the double-guard just outside<a class="indexterm" id="id00384"/> the door to the next level.</p><div class="mediaobject"><img alt="The city" src="graphics/B04322_08_10.jpg"/></div></div><div class="section" title="The forest"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec030"/>The forest</h3></div></div></div><p>The forest <a class="indexterm" id="id00385"/>may be the overall toughest level of them all with a brutally long run of jumps, which are very easy to over or under jump.</p><div class="mediaobject"><img alt="The forest" src="graphics/B04322_08_11.jpg"/></div><p>And with in<a class="indexterm" id="id00386"/> excess of a dozen drones waiting to swoop on Bob, as his pixels hang precariously off a platform.</p><div class="mediaobject"><img alt="The forest" src="graphics/B04322_08_12.jpg"/></div></div><div class="section" title="The mountains"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec031"/>The mountains</h3></div></div></div><p>The fresh mountain<a class="indexterm" id="id00387"/> air means Bob has almost made it. Not a guard or a drone in sight.</p><div class="mediaobject"><img alt="The mountains" src="graphics/B04322_08_13.jpg"/></div><p>However, look at that winding path of jumps, most of which will see Bob thrown right back to the bottom if he puts a pixel out of place.</p><div class="mediaobject"><img alt="The mountains" src="graphics/B04322_08_14.jpg"/></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0016"/>Tip</h3><p>If you want to try<a class="indexterm" id="id00388"/> out each of the levels without completing the grueling level(s) that precede it, you can of course, just start at the level and location of your choice. To do this, just change the call to <code class="literal">loadLevel()</code> in the <code class="literal">PlatformView</code> constructor to one of the following:</p><div class="informalexample"><pre class="programlisting">loadLevel("LevelMountain", 118, 17);
loadLevel("LevelForest", 1, 17);
loadLevel("LevelCity", 118, 18);
loadLevel("LevelCave", 1, 16);</pre></div></div></div></div><div class="section" title="The HUD"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec032"/>The HUD</h3></div></div></div><p>The finishing touch is to add a<a class="indexterm" id="id00389"/> HUD. This code in the <code class="literal">draw</code> method of <code class="literal">PlatformView</code> uses the graphics from some of the existing game objects.</p><p>Add the code after the last call to <code class="literal">drawBackground()</code> and before the debugging text is drawn:</p><div class="informalexample"><pre class="programlisting">// Draw the HUD
// This code needs bitmaps: extra life, upgrade and coin
// Therefore there must be at least one of each in the level
            
int topSpace = vp.getPixelsPerMetreY() / 4;
int iconSize = vp.getPixelsPerMetreX();
int padding = vp.getPixelsPerMetreX() / 5;
int centring = vp.getPixelsPerMetreY() / 6;
paint.setTextSize(vp.getPixelsPerMetreY()/2);
paint.setTextAlign(Paint.Align.CENTER);

paint.setColor(Color.argb(100, 0, 0, 0));
canvas.drawRect(0,0,iconSize * 7.0f, topSpace*2 + iconSize,paint);
paint.setColor(Color.argb(255, 255, 255, 0));

canvas.drawBitmap(lm.getBitmap('e'), 0, topSpace, paint);
canvas.drawText("" + ps.getLives(), (iconSize * 1) + padding, 
  (iconSize) - centring, paint);

canvas.drawBitmap(lm.getBitmap('c'), (iconSize * 2.5f) + padding, 
  topSpace, paint);

canvas.drawText("" + ps.getCredits(), (iconSize * 3.5f) + padding * 2, (iconSize) - centring, paint);

canvas.drawBitmap(lm.getBitmap('u'), (iconSize * 5.0f) + padding, 
  topSpace, paint);

canvas.drawText("" + ps.getFireRate(), (iconSize * 6.0f) + padding * 2, (iconSize) - centring, paint);</pre></div><p>I think we<a class="indexterm" id="id00390"/> are done!</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec046"/>Summary</h1></div></div></div><p>We finished the platform game because that is all there is space for. Why not try to implement some or all of the following improvements and features?</p><p>Change the code in the <code class="literal">Player</code> class to make Bob gradually accelerate and decelerate instead of always running at full speed. Simply increment the velocity for each frame that the player is holding down left or right, and decrement it for each frame they are not.</p><p>Once you have achieved this, add the preceding code to the collision detection <code class="literal">switch</code> block in the <code class="literal">update</code> method to make the player skid on snow, speed up on concrete, and have a different walking/landing sound effect for each tile type.</p><p>Draw a gun on Bob, and adjust the height that the <code class="literal">Bullet</code> object is spawned at to appear as if it is coming from the barrel of his machine gun.</p><p>Make some objects pushable. Add an <code class="literal">isPushable</code> member to <code class="literal">GameObject</code> and make the collision detection simply knock the object back a little. Perhaps, Bob could push mine carts into fire to jump over extra wide fire pits. Note that pushing objects that fall down to another level will be more complicated than pushing objects that remain at the same <span class="emphasis"><em>y</em></span> coordinate.</p><p>Destructible tiles sound like fun. Give them a strength variable that decrements when hit by a bullet and is removed from <code class="literal">gameObjects</code> when it reaches zero.</p><p>Moving platforms are a staple of great platformers. Simply add waypoints to a tile object and add the move code to the <code class="literal">update</code> method. The challenge will be assigning the waypoints. You can either have them all move a set number of spaces left and right or up and down, or do some kind of <code class="literal">setTileWaypoint</code> method similar to how we scripted the <code class="literal">Guard</code> object.</p><p>Make the game more persistent by saving the total number of coins collected ever, remembering which levels are unlocked, and offering access to replay any unlocked levels from the menu screen.</p><p>Make the game easier with teleports used as waypoints. Adjust the viewport zoom for different screen sizes. The current zoom can be a little too low for some small phones.</p><p>Add timed runs for high scores, leaderboards, and achievements, and add more levels.</p><p>In the next chapter, we will look at a much smaller project, but still an interesting one, as we will be using OpenGL ES for super-fast, smooth drawing.</p></div>
<div class="chapter" title="Chapter&#xA0;9.&#xA0;Asteroids at 60 FPS with OpenGL ES 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch18"/>Chapter 9. Asteroids at 60 FPS with OpenGL ES 2</h1></div></div></div><p>Welcome to the final project. Over the course of the next three chapters, we will build an Asteroids-like game using the OpenGL ES 2 graphics API. If you are wondering exactly what OpenGL ES 2 is, then we will discuss the details later in this chapter.</p><p>We will build a very simple but fun and challenging game, where we can draw and animate hundreds of objects at a time, even on quite old Android devices.</p><p>With OpenGL, we will take our drawing efficiency to a much higher level, and with some not-too-tricky math, our movement and collision detection will be greatly enhanced compared to our previous projects.</p><p>By the end of this chapter, we will have a basic working OpenGL ES 2 engine drawing our simple but temporarily static spaceship to the screen; at 60 FPS or higher.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0017"/>Tip</h3><p>If you have never seen <a class="indexterm" id="id00391"/>or played the '80s arcade hit (released in November 1979) Asteroids, why not go and check out a clone of it or a video now?</p><p>Free web game at <a class="ulink" href="http://www.freeasteroids.org/">http://www.freeasteroids.org/</a>.</p><p>On YouTube at <a class="ulink" href="https://www.youtube.com/watch?v=WYSupJ5r2zo">https://www.youtube.com/watch?v=WYSupJ5r2zo</a>.</p></div></div><p>Let's discuss exactly what we intend to build.</p><div class="section" title="Asteroids simulator"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec048"/>Asteroids simulator</h1></div></div></div><p>Our game will be set in<a class="indexterm" id="id00392"/> a four directional scrolling world that the player will be able to traverse while hunting for asteroids. The world will be enclosed in a rectangular border to keep the asteroids from drifting off too far, and the border will also serve as another hazard for the player to avoid.</p><div class="section" title="The game controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec060"/>The game controls</h2></div></div></div><p>We will reuse<a class="indexterm" id="id00393"/> our <code class="literal">InputController</code> class with a few simple modifications and can even keep the same button layout. As we will see, however, we will draw the buttons on screen in a very different manner to our retro platformer. Also, instead of walking left and right, the player will rotate the ship left and right through 360 degrees. The jump button will become a thrust toggle switch to turn on and off forward motion, and the shoot button will remain just that. We will also have the pause button in the same place.</p></div><div class="section" title="Rules for the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec061"/>Rules for the game</h2></div></div></div><p>When an asteroid hits<a class="indexterm" id="id00394"/> the border, it will bounce back into the game world. If the player hits the border, a life will be lost and the ship will respawn in the center of the screen. If an asteroid hits the ship this will be fatal too.</p><p>The player will start with three lives and must clear the asteroids simulator of all asteroids. The HUD will show a tally of the remaining asteroids and lives. If the player clears all the asteroids, then the next wave will start with more than the last. They will also move a little faster. Each wave cleared will be rewarded with an extra life.</p><p>We will implement these rules as we proceed through the project.</p></div></div></div>
<div class="section" title="Introducing OpenGL ES 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec049"/>Introducing OpenGL ES 2</h1></div></div></div><p>OpenGL ES 2<a class="indexterm" id="id00395"/> is the second major version of the <span class="strong"><strong>Open Graphics Library</strong></span> (<span class="strong"><strong>OpenGL</strong></span>) for embedded systems. It is the mobile incarnation of OpenGL for desktop systems.</p><div class="section" title="Why use it and how does it work?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec062"/>Why use it and how does it work?</h2></div></div></div><p>OpenGL<a class="indexterm" id="id00396"/> runs as a native process, not on the Dalvik virtual machine like the rest of our Java. This is one of the <a class="indexterm" id="id00397"/>reasons it is super fast. The OpenGL ES API takes away all of the complexity of interacting with native code, and OpenGL itself also provides very efficient and fast algorithms within its native code base.</p><p>The first version of OpenGL was completed in 1992. The point is that even back then OpenGL used arguably the most efficient code and algorithms to draw graphics. Now, more than 20 years on, it has been continually refined and improved as well as adapted to work with the latest graphics hardware, both mobile and desktop. All the mobile GPU manufacturers specifically design their hardware to be compatible with the latest version of OpenGL ES.</p><p>Trying to improve on OpenGL ES is, therefore, probably a fool's errand.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0018"/>Tip</h3><p>There is another viable Graphics API option when developing exclusively for Windows devices called DirectX.</p></div></div></div><div class="section" title="What is neat about Version 2?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec063"/>What is neat about Version 2?</h2></div></div></div><p>The first version of OpenGL ES certainly impressed at the time. I remember almost falling off my chair when I first played a 3D shooter on a phone! Now this is of course commonplace. However, compared to the desktop version of OpenGL, OpenGL ES 1 had a major drawback.</p><p>OpenGL ES 1<a class="indexterm" id="id00398"/> had, what is known as, a fixed function pipeline. The geometry to draw went into the GPU and it was drawn, but any further manipulation of individual pixels needed to take place before OpenGL ES took over the drawing of a frame of the game.</p><p>Now, with OpenGL ES 2, we <a class="indexterm" id="id00399"/>have access to what is called a programmable pipeline. That is, we can send our graphics off to be drawn, but we can also write code that runs on the GPU that is capable of manipulating each and every pixel independently. This is a very powerful feature, although we will not get to explore it in much depth.</p><p>This extra code that runs on the GPU is called a <a class="indexterm" id="id00400"/>
<span class="strong"><strong>shader</strong></span> program. We can write code to manipulate the geometry (position) of our graphics in what is called a<a class="indexterm" id="id00401"/> <span class="strong"><strong>vertex shader</strong></span>. We can also write code that manipulates the appearance of each and every pixel individually called a <a class="indexterm" id="id00402"/>
<span class="strong"><strong>fragment shader</strong></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0027"/>Note</h3><p>Actually, we can do better than even pixel manipulation. A fragment is not necessarily a pixel. It depends on the hardware and the specific nature of the graphics being processed. It can be more than one pixel or a sub-pixel: one light of several that makes up a pixel in the screen hardware.</p></div></div><p>The disadvantage of OpenGL ES 2 for simple games like this is that you must provide at least one vertex and one fragment shader, even if you are not going to do a whole lot with them. As we will see, however, this is not very difficult. Although we will not be exploring shaders in any depth, we will write some shader code using <span class="strong"><strong>GL Shader Language</strong></span> (<span class="strong"><strong>GLSL</strong></span>) <a class="indexterm" id="id00403"/>and get a glimpse at the possibilities they offer.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0019"/>Tip</h3><p>If the power of programmable graphics pipelines and shaders is just too exciting to leave for another day, then I can highly recommend <span class="emphasis"><em>GLSL Essentials</em></span> by Jacobo Rodríguez.</p><p>
<a class="ulink" href="https://www.packtpub.com/hardware-and-creative/glsl-essentials">https://www.packtpub.com/hardware-and-creative/glsl-essentials</a>
</p><p>The book explores OpenGL shaders on the desktop and is highly accessible to any reader with basic programming knowledge and a willingness to learn a different language (GLSL), yet one with some syntax similarities to Java.</p></div></div><p>How will we be using OpenGL ES 2?</p></div><div class="section" title="How we will use OpenGL ES 2?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec064"/>How we will use OpenGL ES 2?</h2></div></div></div><p>In OpenGL, everything is a <a class="indexterm" id="id00404"/>point, a line, or a triangle. In addition, we can attach colors and textures to this basic geometry and also combine these elements to make the complex graphics that we see in today's modern mobile games.</p><p>We will use some of each type of element (points, lines, and triangles) that are collectively referred to as primitives.</p><p>We will not be using textures on this project. Fortunately, the appearance of untextured primitives is appropriate for building our Asteroids-like game.</p><p>In addition to primitives, Open GL uses matrices. <span class="strong"><strong>Matrices</strong></span> <a class="indexterm" id="id00405"/>are a method and structure for performing arithmetic. This arithmetic can range from extremely simple high-school level calculations to move (translate) a coordinate or it can be quite complex to perform more advanced mathematics to convert our game world coordinates into OpenGL screen coordinates that the GPU can use.</p><p>The point is that both the matrices and methods to use them are entirely provided by the OpenGL API. This means that we just have to learn what methods do which graphical manipulation and do not have to concern ourselves with the potentially complex math that goes on behind the scenes (on the GPU).</p><p>The best way to learn about shaders, primitives, and matrices in OpenGL is to go ahead and start using them.</p></div></div>
<div class="section" title="Preparing OpenGL ES 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec050"/>Preparing OpenGL ES 2</h1></div></div></div><p>First we start off with <a class="indexterm" id="id00406"/>our <code class="literal">Activity</code> class, which as before is the entry point into our game. Create a new project and in the <span class="strong"><strong>Application Name</strong></span> field enter <code class="literal">C9 Asteroids</code>. Choose <span class="strong"><strong>Phones and tablets</strong></span>, then <span class="strong"><strong>Blank Activity</strong></span> when prompted. In the <span class="strong"><strong>Activity Name</strong></span> field type <code class="literal">AsteroidsActivity</code>.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0020"/>Tip</h3><p>Obviously you don't have to follow my exact naming choices but just remember to make the minor alterations in code to reflect your own naming choices.</p></div></div><p>You can delete <code class="literal">activity_asteroids.xml</code> from the <code class="literal">layout</code> folder. You can also delete all the code within the <code class="literal">AsteroidsActivity.java</code> file. Just leave the package declaration.</p><div class="section" title="Locking the layout to landscape"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec065"/>Locking the layout to landscape</h2></div></div></div><p>Just as we did for the <a class="indexterm" id="id00407"/>previous two projects, we will make sure the game runs in landscape mode only. We will make our <code class="literal">AndroidManifest.xml</code> file, force our <code class="literal">AsteroidsActivity</code> class to run with a full screen, and lock it to a landscape orientation. Let's make these changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">manifests</code> folder now and double-click the <code class="literal">AndroidManifest.xml</code> file to open it in the code editor.</li><li class="listitem">In the <code class="literal">AndroidManifest.xml</code> file, find the following line of code:<div class="informalexample"><pre class="programlisting">android:name=".AsteroidsActivity"</pre></div></li><li class="listitem">Immediately, type or copy and paste these two lines to make <code class="literal">PlatformActivity</code> run in full screen and lock it in the landscape orientation:<div class="informalexample"><pre class="programlisting">android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
android:screenOrientation="landscape"</pre></div></li></ol></div><p>Now we can move on to implementing our Asteroids simulator game with OpenGL.</p></div><div class="section" title="Activity"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec066"/>Activity</h2></div></div></div><p>First of all, we have our <a class="indexterm" id="id00408"/>familiar <code class="literal">Activity</code> class. The only thing that is new here is the type of our view class. We declare a member called <code class="literal">asteroidsView</code> of type <code class="literal">GLSurfaceView</code>. This is the class that will provide us with easy access to OpenGL. We will see exactly how very soon. Note that all we do is initialize <code class="literal">GLSurfaceView</code> by passing in the <code class="literal">Activity</code> context and the screen resolution that we obtain in the usual manner. Implement the <code class="literal">AsteroidsActivity</code> class as shown:</p><div class="informalexample"><pre class="programlisting">package com.gamecodeschool.c9asteroids;

import android.app.Activity;
import android.graphics.Point;
import android.opengl.GLSurfaceView;
import android.os.Bundle;
import android.view.Display;

public class AsteroidsActivity extends Activity {

    private GLSurfaceView asteroidsView;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Get a Display object to access screen details
        Display display = getWindowManager().getDefaultDisplay();

        // Load the resolution into a Point object
        Point resolution = new Point();
        display.getSize(resolution);

        asteroidsView = new AsteroidsView 
          (this, resolution.x, resolution.y); 

        setContentView(asteroidsView);
    }

    @Override
    protected void onPause() {
        super.onPause();

        asteroidsView.onPause();

    }

    @Override
    protected void onResume() {
        super.onResume();

        asteroidsView.onResume();

  
    }
}</pre></div><p>Next, we will get to see some OpenGL code.</p></div><div class="section" title="The view"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec067"/>The view</h2></div></div></div><p>Here, we will <a class="indexterm" id="id00409"/>implement the <code class="literal">GLSurfaceView</code> class. Actually, this isn't where the real action will take place but it does allow us to attach an OpenGL renderer. This is a class that implements the <code class="literal">Renderer</code> interface. As well as in this critical <code class="literal">Renderer</code>, the <code class="literal">GLSurfaceView</code> class enables us to override the <code class="literal">onTouchListener</code> method that will allow us to detect player input in the same way that <code class="literal">SurfaceView</code> did in the previous projects.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0028"/>Note</h3><p>Android Studio does not auto-import or even suggest all of the OpenGL imports required. Therefore, I included all of the imports for some classes in the code listings. In addition, you will note that sometimes we use static imports. This will make the code more readable too.</p></div></div><p>In the code that <a class="indexterm" id="id00410"/>follows, we declare and initialize a new object of type <code class="literal">GameManager</code> that we will implement soon. We set the OpenGL version to two by calling <code class="literal">setEGLContextClientVersion(2)</code>, and we set our vital renderer object by calling <code class="literal">setRenderer()</code> and passing in our <code class="literal">GameManager</code> object. Create a new class called <code class="literal">AsteroidsView</code> and implement it as follows:</p><div class="informalexample"><pre class="programlisting">import android.content.Context;
import android.opengl.GLSurfaceView;

public class AsteroidsView extends GLSurfaceView{

    GameManager gm;

    public AsteroidsView(Context context, int screenX, int screenY) {
        super(context);

        gm = new GameManager(screenX, screenY);

        // Which version of OpenGl we are using
        setEGLContextClientVersion(2);

        // Attach our renderer to the GLSurfaceView
        setRenderer(new AsteroidsRenderer(gm));

    }

}</pre></div><p>Now, we can take a look at what is involved in our <code class="literal">GameManager</code> class.</p></div><div class="section" title="A class to manage our game"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec068"/>A class to manage our game</h2></div></div></div><p>This class will <a class="indexterm" id="id00411"/>control things like the level the player is on, the number of lives, as well as things like the overall size of the game world. It will evolve a little as the project progresses, but it will remain quite simple in comparison to the combined depth of the LevelManager and PlayerState classes from the previous project, although it effectively replaces both.</p><p>In the code that follows, we declare <code class="literal">int</code> members to hold the width and height of the game world; we can make this much bigger or smaller as we see fit. We keep track of the games status with the Boolean <code class="literal">playing</code>.</p><p>The <code class="literal">GameManager</code> class also needs to know the height and width of the screen in pixels, and this information is passed in to the constructor when the object is initialized back in the <code class="literal">AsteroidsView</code> class.</p><p>Note also the <code class="literal">metresToShowX</code> and <code class="literal">metresToShowY</code> member variables. These probably sound familiar from our <code class="literal">Viewport</code> class from the last project. These variables will be used for exactly the same thing: defining the current viewable area of the game world. This time, however, OpenGL will take care of what objects to clip before drawing (using a matrix). We will <a class="indexterm" id="id00412"/>soon see where this happens.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0029"/>Note</h3><p>Note that although OpenGL takes care of clipping and scaling the area of the game world that we want to show, it doesn't have any effect on which objects are updated each frame. As we will see, however, this is just what we want for this game because we want all our objects to update themselves each frame, even when they are offscreen. Therefore, no <code class="literal">Viewport</code> class is necessary for this game.</p></div></div><p>Lastly, we want a convenient way to pause and unpause the game, and we provide this functionality with the <code class="literal">switchPlayingStatus</code> method. Create a new class called <code class="literal">GameManager</code> and implement it as shown:</p><div class="informalexample"><pre class="programlisting">public class GameManager {

    int mapWidth = 600;
    int mapHeight = 600;
    private boolean playing = false;

    // Our first game object
    SpaceShip ship;

    int screenWidth;
    int screenHeight;

    // How many metres of our virtual world
    // we will show on screen at any time.
    int metresToShowX = 390;
    int metresToShowY = 220;

    public GameManager(int x, int y){

        screenWidth = x;
        screenHeight = y;

    }

    public void switchPlayingStatus() {
        playing = !playing;

    }

    public boolean isPlaying(){
        return playing;
    }
}</pre></div><p>We can now take our <a class="indexterm" id="id00413"/>first look at these all powerful shaders and how we will manage them.</p></div><div class="section" title="Managing simple shaders"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec069"/>Managing simple shaders</h2></div></div></div><p>An application<a class="indexterm" id="id00414"/> can have many shaders. We can then attach different shaders to different game objects to create the desired effects.</p><p>We will only have one vertex and one fragment shader in this game. However, when you see how to attach a shader to primitives, it will be plain that it is simple to have more shaders.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we need the code for the shader that will be executed in the GPU.</li><li class="listitem">Then we need to compile that code.</li><li class="listitem">Finally, we need to link together the two compiled shaders into a GL program.</li></ol></div><p>As we implement this next simple class, we will see how we can bundle up this functionality into a single method call, which can be made by an object from our game and have the ready-to-run GL program returned to the game object. When we build our <code class="literal">GameObject</code> class later in the chapter, we will see how we use this GL program.</p><p>Let's go ahead and implement the necessary three steps in a new class. Create a new class and call it <code class="literal">GLManager</code>. Add the static imports as shown here:</p><div class="informalexample"><pre class="programlisting">import static android.opengl.GLES20.GL_FRAGMENT_SHADER;
import static android.opengl.GLES20.GL_VERTEX_SHADER;
import static android.opengl.GLES20.glAttachShader;
import static android.opengl.GLES20.glCompileShader;
import static android.opengl.GLES20.glCreateProgram;
import static android.opengl.GLES20.glCreateShader;
import static android.opengl.GLES20.glLinkProgram;
import static android.opengl.GLES20.glShaderSource;</pre></div><p>Next, we will add some public static final member variables that we can use in our <code class="literal">GameObject</code> class later in the chapter. Although we will see exactly how they work when we get around to using them, here is a quick preliminary explanation.</p><p>
<code class="literal">COPONENTS_PER_VERTEX</code> is the number of values that will be used to represent a single vertex (point) in our primitives that will make up our game objects. As you can see, we initialize this to three coordinates: <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span>.</p><p>We also<a class="indexterm" id="id00415"/> have <code class="literal">FLOAT_SIZE</code>, which is initialized to <code class="literal">4</code>. This is the number of bytes in a Java float. As we will see soon, OpenGL likes all its primitives passed into it in the form of a <code class="literal">ByteBuffer</code>. We need to make sure we are precise about where in the <code class="literal">ByteBuffer</code> each piece of information is.</p><p>Next, we declare <code class="literal">STRIDE</code> and initialize it to <code class="literal">COMPONENTS_PER_VERTEX * FLOAT_SIZE</code>. As OpenGL uses the float type to hold virtually all of the data it works with, <code class="literal">STRIDE</code> now equals the size in bytes of the data that represents a single vertex of an object. Go ahead and add these members at the top of the class:</p><div class="informalexample"><pre class="programlisting">public class GLManager {

     // Some constants to help count the number of bytes between
     // elements of our vertex data arrays
     public static final int COMPONENTS_PER_VERTEX = 3;
     public  static final int FLOAT_SIZE = 4;
     public static final int STRIDE =
       (COMPONENTS_PER_VERTEX)
        * FLOAT_SIZE;

     public static final int ELEMENTS_PER_VERTEX = 3;// x,y,z</pre></div><p>GLSL<a class="indexterm" id="id00416"/> is a language in its own right and it also has its own types, and variables of those types can be utilized. Here, we declare and initialize some strings that we can use to refer to these variables more cleanly in our code.</p><p>Discussion of these types is beyond the scope of this book, but simply explained they will represent a matrix (<code class="literal">u_matrix</code>), a location (<code class="literal">a_position</code>), and a color (<code class="literal">u_Color</code>). We will see examples of the actual GLSL types these variables are in our shader code very soon.</p><p>After the strings, we declare three <code class="literal">int</code> types. These three public static (but not final) members will be used to store the location of there namesake types within our shaders. This allows us to manipulate the values within the shader program before we give OpenGL the final instruction to draw our primitives.</p><div class="informalexample"><pre class="programlisting">// Some constants to represent GLSL types in our shaders
public static final String U_MATRIX = "u_Matrix";
public static final String A_POSITION = "a_Position";
public static final String U_COLOR = "u_Color";

// Each of the above constants also has a matching int
// which will represent its location in the open GL glProgram
public static int uMatrixLocation;
public static int aPositionLocation;
public static int uColorLocation;</pre></div><p>At last, we <a class="indexterm" id="id00417"/>come to our GLSL code that is a vertex shader packed up in a string. Note that we declare a variable called <code class="literal">u_Matrix</code> of type uniform <code class="literal">mat4</code> and <code class="literal">a_Position</code> of type attribute <code class="literal">vec4</code>. We will see in our <code class="literal">GameObject</code> class later how to get the locations of these variables to enable us to pass in values for them from our Java code.</p><p>The line in the code that starts with <code class="literal">void main()</code> is were the actual shader code executes from. Note that <code class="literal">gl_position</code> is assigned the value of the product of the two variables we just declared. Also <code class="literal">gl_PointSize</code> is assigned the value of <code class="literal">3.0</code>. This will be the size we draw all our point primitives. Enter the code for the vertex shader right after the previous block of code:</p><div class="informalexample"><pre class="programlisting">// A very simple vertexShader glProgram
// that we can define with a String

private static String vertexShader =
     "uniform mat4 u_Matrix;" +
     "attribute vec4 a_Position;" +

     "void main()" +
     "{" +
       "gl_Position = u_Matrix * a_Position;" +
       "gl_PointSize = 3.0;"+
  "}";</pre></div><p>Next, we will implement the fragment shader. A few things are happening here. First, the line precision <code class="literal">mediump</code> float tells OpenGL to draw with medium precision and therefore medium speed. Then we can see our variable <code class="literal">u_Color</code> being declared to type uniform <code class="literal">vec4</code>. We will see how we can pass a <code class="literal">color</code> value to this variable in the <code class="literal">GameObject</code> class soon.</p><p>When execution begins at <code class="literal">void main()</code>, we simply assign <code class="literal">u_Color</code> to <code class="literal">gl_FragColor</code>. So, whatever color is assigned to <code class="literal">u_Colour</code>, all the fragments will be that color. Just after the fragment shader, we declare an <code class="literal">int</code> called <code class="literal">program</code> that will act as a handle to our GL program.</p><p>Enter the code for the fragment shader right after the previous block of code:</p><div class="informalexample"><pre class="programlisting">// A very simple fragment Shader
// that we can define with a String

private static String fragmentShader = 
    "precision mediump float;" + 
    "uniform vec4 u_Color;" + 
    "void main()" + 
    "{" + 
        "gl_FragColor = u_Color;" + 
    "}";

// A handle to the GL glProgram public static int program; </pre></div><p>This is a getter method that returns a handle to the GL program:</p><div class="informalexample"><pre class="programlisting">public static int program;
public static int getGLProgram(){
return program;
}</pre></div><p>This next method<a class="indexterm" id="id00418"/> may look complex, but all it does is return a compiled and linked program to the caller. It does so by calling the OpenGL's <code class="literal">linkProgram</code> method with <code class="literal">compileVertexShader()</code> and <code class="literal">compileFragmentShader()</code> as arguments. Next, we see these two new methods and that all they need to do is call our method <code class="literal">compileShader()</code> with the OpenGL constant representing the type of shader and the appropriate string that holds the matching shader GLSL code.</p><p>Enter the three methods that we have just discussed into the <code class="literal">GLManager</code> class:</p><div class="informalexample"><pre class="programlisting">public static int buildProgram(){
    // Compile and link our shaders into a GL glProgram object
    return linkProgram(compileVertexShader(),compileFragmentShader());
    
}

private static int compileVertexShader() {
    return compileShader(GL_VERTEX_SHADER, vertexShader);
}

private static int compileFragmentShader() {
    return compileShader(GL_FRAGMENT_SHADER, fragmentShader);
}</pre></div><p>Now we see what happens when our methods called <code class="literal">compileShader()</code>. First, we create a handle to a shader based on the <code class="literal">type</code> parameter. Then, we pass in that handle and the code to <code class="literal">glShaderSource()</code>. Finally, we compile the shader with <code class="literal">glCompileShader()</code> and return a handle to the calling method:</p><div class="informalexample"><pre class="programlisting">private static int compileShader(int type, String shaderCode) {

    // Create a shader object and store its ID
    final int shader = glCreateShader(type);

    // Pass in the code then compile the shader
    glShaderSource(shader, shaderCode);
    glCompileShader(shader);

    return shader;
}</pre></div><p>Now we can see the<a class="indexterm" id="id00419"/> final step in the process. We create an empty program with <code class="literal">glCreateProgram()</code>. Then we attach each of the compiled shaders in turn with <code class="literal">glAttachShader()</code>, and finally link them into a program we can actually use with <code class="literal">glLinkProgram()</code>:</p><div class="informalexample"><pre class="programlisting">private static int linkProgram(int vertexShader, int fragmentShader) {

  // A handle to the GL glProgram -
  // the compiled and linked shaders
     program = glCreateProgram();

     // Attach the vertex shader to the glProgram.
     glAttachShader(program, vertexShader);

     // Attach the fragment shader to the glProgram.
     glAttachShader(program, fragmentShader);

     // Link the two shaders together into a glProgram.
     glLinkProgram(program);

     return program;
}
}// End GLManager</pre></div><p>Note that we created a program and we have access to it via its handle and the <code class="literal">getProgram</code> method. We also have access to all those public static members we created, so we will be able to tinker with the variables in the shader programs from our Java code.</p></div><div class="section" title="The game's main loop – the renderer"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec070"/>The game's main loop – the renderer</h2></div></div></div><p>Now we will see where the <a class="indexterm" id="id00420"/>real meat of our code will go. Create a new class and call it <code class="literal">AsteroidsRenderer</code>. This is the class that we attached as our renderer to the <code class="literal">GLSurfaceView</code>. Add the import statements as follows, noting that some of them are static:</p><div class="informalexample"><pre class="programlisting">import android.graphics.PointF;
import android.opengl.GLSurfaceView.Renderer;
import android.util.Log;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;
import static android.opengl.GLES20.GL_COLOR_BUFFER_BIT;
import static android.opengl.GLES20.glClear;
import static android.opengl.GLES20.glClearColor;
import static android.opengl.GLES20.glViewport;
import static android.opengl.Matrix.orthoM;</pre></div><p>Now we will build the class. The first thing to note that we have mentioned before is that the class implements <code class="literal">Renderer</code>, so we need to override three methods. They are <code class="literal">onSurfaceCreated()</code>, <code class="literal">onSurfaceChanged()</code>, and <code class="literal">onDrawFrame()</code>. Also, into this class, we will initially add a constructor to get everything set up, a <code class="literal">createObjects</code> method where we will eventually initialize all our game objects, an <code class="literal">update</code> method were we will update all our objects each frame, and a <code class="literal">draw</code> method were we will draw all our objects each frame.</p><p>We will explore and explain each method as we implement it, and we will also see how our methods fit in to the OpenGL renderer system, which dictates the flow of this class.</p><p>To get started, we have some member variables that are worth looking at quite closely.</p><p>The Boolean debugging will be used to toggle output to the console on and off. The <code class="literal">frameCounter</code>, <code class="literal">averageFPS</code>, and <code class="literal">fps</code> variables will not only be used for checking what frame rates we are reaching but also for passing to our game objects that will update themselves based on the elapsed time each frame.</p><p>Our first really interesting variable is the float array <code class="literal">viewportMatrix</code>. As the name suggests, it will hold a matrix that OpenGL can use to calculate the viewport into our game world.</p><p>We have a <code class="literal">GameManager</code> to hold a reference to the <code class="literal">GameManager</code> object, that <code class="literal">AsteroidsView</code> passed into this class's constructor. Finally, we have two <code class="literal">PointF</code> objects.</p><p>We will initialize the <code class="literal">PointF</code> objects in the constructor and use them for a few different things to avoid dereferencing any objects in the main game loop. When the garbage collector starts cleaning up discarded objects, even OpenGL will slow down. Avoiding summoning the garbage collector will be a goal for the entire game.</p><p>Enter the member variables at the top of the <code class="literal">AsteroidsRenderer</code> class:</p><div class="informalexample"><pre class="programlisting">public class AsteroidsRenderer implements Renderer {

// Are we debugging at the moment

boolean debugging = true;

// For monitoring and controlling the frames per second

long frameCounter = 0;
long averageFPS = 0;
private long fps;

// For converting each game world coordinate
// into a GL space coordinate (-1,-1 to 1,1)
// for drawing on the screen

private final float[] viewportMatrix = new float[16];

// A class to help manage our game objects
// current state.

private GameManager gm;

// For capturing various PointF details without
// creating new objects in the speed critical areas

PointF handyPointF;
PointF handyPointF2;</pre></div><p>Here is our constructor, where <a class="indexterm" id="id00421"/>we initialize our <code class="literal">GameManager</code> reference from the parameter and create our two handy <code class="literal">PointF</code> objects ready for use:</p><div class="informalexample"><pre class="programlisting">public AsteroidsRenderer(GameManager gameManager) {

     gm = gameManager;

     handyPointF = new PointF();
     handyPointF2 = new PointF();

}</pre></div><p>This is the first overridden method. It is called every time a <code class="literal">GLSurfaceView</code> class with attached renderer is created. We call <code class="literal">glClearColor()</code> to set which color OpenGL will use each time it clears the screen. We then build our shader program using our <code class="literal">GLManager.buildProgram()</code> method and call our <code class="literal">createObjects</code> method that we will code soon.</p><div class="informalexample"><pre class="programlisting">@Override
public void onSurfaceCreated(GL10 glUnused, EGLConfig config) {

   // The color that will be used to clear the
   // screen each frame in onDrawFrame()
   glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

   // Get GLManager to compile and link the shaders into an object
   GLManager.buildProgram();

   createObjects();

}</pre></div><p>This next overridden <a class="indexterm" id="id00422"/>method is called once after <code class="literal">onSurfaceCreated()</code> and any time the screen orientation changes. Here, we call the <code class="literal">glViewport()</code> method to tell OpenGL the pixel coordinates to map the OpenGL coordinate system onto.</p><p>The OpenGL coordinate system is very different from the pixel coordinates we are used to deal with in the previous two projects. The center of the screen is 0,0, the left and bottom are -1, and the top and right are 1.</p><div class="mediaobject"><img alt="The game's main loop – the renderer" src="graphics/B04322_09_01.jpg"/></div><p>The preceding situation is further complicated by the fact that most screens are not square, yet the range -1 to 1 must represent both <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes. Fortunately, our <code class="literal">glViewport()</code> has dealt with this for us.</p><p>The last thing we see in this method is calling the <code class="literal">orthoM</code> method with our <code class="literal">viewportMatrix</code> as the first parameter. OpenGL will now prepare <code class="literal">viewportMatrix</code> for use within OpenGL itself. The method <code class="literal">orthoM()</code> creates a matrix to convert coordinates into an orthographic<a class="indexterm" id="id00423"/> view. If our coordinates are three-dimensional, it will have the effect of making all the objects appear the same distance away. As we are making a two-dimensional game, this is also suitable for us.</p><p>Enter the code for the <code class="literal">onSurfaceChanged</code> method:</p><div class="informalexample"><pre class="programlisting">@Override
    public void onSurfaceChanged(GL10 glUnused, int width, int height) {

        // Make full screen
        glViewport(0, 0, width, height);

        /*
            Initialize our viewport matrix by passing in the starting
            range of the game world that will be mapped, by OpenGL to
            the screen. We will dynamically amend this as the player
            moves around.

            The arguments to setup the viewport matrix:
            our array,
            starting index in array,
            min x, max x,
            min y, max y,
            min z, max z)
        */

            orthoM(viewportMatrix, 0, 0, 
        gm.metresToShowX, 0, 
        gm.metresToShowY, 0f, 1f);
}</pre></div><p>Here is our <code class="literal">createObjects</code> method and, as you can see, we create an object of type <code class="literal">SpaceShip</code> and pass in the map height and width to the constructor. We will build the <code class="literal">SpaceShip</code> class and its parent class <code class="literal">GameObject</code> later in this chapter. Enter the <code class="literal">createObjects</code> method:</p><div class="informalexample"><pre class="programlisting">    private void createObjects() {
        // Create our game objects

        // First the ship in the center of the map
        gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);
    }</pre></div><p>This is the overridden <code class="literal">onDrawFrame</code> method. It is called continuously by the system. We can control when this is called by setting a render mode when we attach the <code class="literal">AsteroidsRenderer</code> to the view but the default OpenGL controlled continuous calling is exactly what we need.</p><p>We set <code class="literal">startFrameTime</code> to whatever the current system time is. Then, if <code class="literal">isPlaying()</code> returns <code class="literal">true</code>, we call our soon-to-be-implemented <code class="literal">update</code> method. Then, we call <code class="literal">draw()</code>, which will tell all of our objects to draw themselves.</p><p>We then update <code class="literal">timeThisFrame</code> and <code class="literal">fps</code> optionally outputting the average frames per second, every 100 frames, if we are debugging.</p><p>Now we know that OpenGL will call <code class="literal">onDrawFrame()</code> up to hundreds of times per second. We will conditionally call our <code class="literal">update</code> method each time as well as call our <code class="literal">draw</code> method. We have effectively implemented our game loop apart from the actual <code class="literal">draw</code> and update methods <a class="indexterm" id="id00424"/>themselves.</p><p>Add the <code class="literal">onDrawFrame</code> method to the class:</p><div class="informalexample"><pre class="programlisting">@Override
public void onDrawFrame(GL10 glUnused) {

        long startFrameTime = System.currentTimeMillis();

        if (gm.isPlaying()) {
            update(fps);
        }

        draw();

        // Calculate the fps this frame
        // We can then use the result to
        // time animations and more.
        long timeThisFrame = System.currentTimeMillis() - startFrameTime;
        if (timeThisFrame &gt;= 1) {
            fps = 1000 / timeThisFrame;
        }

        // Output the average frames per second to the console
        if (debugging) {
            frameCounter++;
            averageFPS = averageFPS + fps;
            if (frameCounter &gt; 100) {
                averageFPS = averageFPS / frameCounter;
                frameCounter = 0;
                Log.e("averageFPS:", "" + averageFPS);
            }
        }
    }</pre></div><p>Here is our <code class="literal">update</code> method, leave an empty body for now:</p><div class="informalexample"><pre class="programlisting">    private void update(long fps) {

    }</pre></div><p>Now, we come to<a class="indexterm" id="id00425"/> our <code class="literal">draw</code> method, which is called once per frame from the <code class="literal">onDrawFrame</code> method. Here, we load up the ships current location into one of our handy <code class="literal">PointF</code> objects. Clearly, as we haven't implemented our <code class="literal">SpaceShip</code> class yet, this method call will produce an error.</p><p>The next thing we do in <code class="literal">draw()</code> is quite interesting. We modify our <code class="literal">viewportMatrix</code> based on the current location in the game world and the values assigned to <code class="literal">metresToShowX</code> and <code class="literal">metresToShowY</code>. Simply, we are centering on wherever the ship is and extending out by half the distance we wish to show in all four directions. Remember that, this happens in every frame, so our viewport will constantly follow the player ship.</p><p>Next, we call <code class="literal">glClear()</code> to clear the screen with the color we set in <code class="literal">onSurfaceCreated()</code>. The last thing we do in <code class="literal">draw()</code> is call a <code class="literal">draw</code> method on our <code class="literal">SpaceShip</code> object. This implies quite a fundamental design change from both of our previous games.</p><p>We mentioned this already, but here we can see it in action: each object will draw itself. Also, notice that we pass in our newly configured <code class="literal">viewportMatrix</code>.</p><p>Enter the code for the <code class="literal">draw</code> method:</p><div class="informalexample"><pre class="programlisting">private void draw() {

    // Where is the ship?
    handyPointF = gm.ship.getWorldLocation();

    // Modify the viewport matrix orthographic projection
    // based on the ship location
    orthoM(viewportMatrix, 0,
        handyPointF.x - gm.metresToShowX / 2,
        handyPointF.x + gm.metresToShowX / 2,
        handyPointF.y - gm.metresToShowY / 2,
        handyPointF.y + gm.metresToShowY / 2,
        0f, 1f);

    // Clear the screen
    glClear(GL_COLOR_BUFFER_BIT);

    // Start drawing!

    // Draw the ship
    gm.ship.draw(viewportMatrix);
}
}</pre></div><p>Now, we can build <a class="indexterm" id="id00426"/>our <code class="literal">GameObject</code> super class, closely followed by its first child, <code class="literal">SpaceShip</code>. We will see how these objects will manage to use OpenGL to draw themselves.</p></div></div>
<div class="section" title="Building an OpenGL-friendly, GameObject super class"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec051"/>Building an OpenGL-friendly, GameObject super class</h1></div></div></div><p>Let's dive straight into the <a class="indexterm" id="id00427"/>code. As we will see, this <code class="literal">GameObject</code> will have a lot in common with the <code class="literal">GameObject</code> class from the previous project. The most significant difference will be that this latest <code class="literal">GameObject</code> will of course draw itself using a handle to the GL program, primitive (vertex) data from a child class, and the viewport matrix contained in <code class="literal">viewportMatrix</code>.</p><p>Create a new class, call it <code class="literal">GameObject</code>, and enter these import statements, noting again that that some of them are static:</p><div class="informalexample"><pre class="programlisting">import android.graphics.PointF;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import static android.opengl.GLES20.GL_FLOAT;
import static android.opengl.GLES20.GL_LINES;
import static android.opengl.GLES20.GL_POINTS;
import static android.opengl.GLES20.GL_TRIANGLES;
import static android.opengl.GLES20.glDrawArrays;
import static android.opengl.GLES20.glEnableVertexAttribArray;
import static android.opengl.GLES20.glGetAttribLocation;
import static android.opengl.GLES20.glGetUniformLocation;
import static android.opengl.GLES20.glUniform4f;
import static android.opengl.GLES20.glUniformMatrix4fv;
import static android.opengl.GLES20.glUseProgram;
import static android.opengl.Matrix.multiplyMM;
import static android.opengl.Matrix.setIdentityM;
import static android.opengl.Matrix.setRotateM;
import static android.opengl.Matrix.translateM;
import static android.opengl.GLES20.glVertexAttribPointer;
import static com.gamecodeschool.c9asteroids.GLManager.*;</pre></div><p>There are lots of member variables, many are self-explanatory and commented just to refresh our memories, but there are some totally new ones as well.</p><p>For example, we have <a class="indexterm" id="id00428"/>an <code class="literal">enum</code> to represent each type of <code class="literal">GameObject</code> we will create. The reason for this is we will draw some objects as points, some as lines, and one as a triangle. The way that we use OpenGL is consistent between different types of primitive; hence, it is why we have bundled the code into this parent class. However, the final call to draw the primitive varies dependent on the type of primitive. We can use the <code class="literal">type</code> variable in a <code class="literal">switch</code> statement to execute the correct type of a <code class="literal">draw</code> method.</p><p>We also have an <code class="literal">int numElements</code> and <code class="literal">numVertices</code> that holds the number of points that make up any given <code class="literal">GameObject</code>. These will be set from the child class as we will see soon.</p><p>We have another float array called <code class="literal">modelVertices</code>, which will hold all the vertices that make up a model.</p><p>Enter the first batch of member variables in the <code class="literal">GameObject</code> class and take a look at the comments to refresh your memory or make clear what the various members will eventually be used for:</p><div class="informalexample"><pre class="programlisting">public class GameObject {

    boolean isActive;

    public enum Type {SHIP, ASTEROID, BORDER, BULLET, STAR}

    private Type type;

    private static int glProgram =-1;

    // How many vertices does it take to make
    // this particular game object?
    private int numElements;
    private int numVertices;

    // To hold the coordinates of the vertices that
    // define our GameObject model
    private float[] modelVertices;


    // Which way is the object moving and how fast?
    private float xVelocity = 0f;
    private float yVelocity = 0f;
    private float speed = 0;
    private float maxSpeed = 200;

    // Where is the object centre in the game world?
    private PointF worldLocation = new PointF();</pre></div><p>Next, we will add another batch of member variables. First, and most notably, we have a <code class="literal">FloatBuffer</code> called <code class="literal">vertices</code>. As we know, OpenGL executes in native code and <code class="literal">FloatBuffers</code> are how it likes to consume its data. We will see how we pack all our vertices into this <code class="literal">FloatBuffer</code>. </p><p>We will also use all the public static members from our <code class="literal">GLManager</code> class to help us get it right.</p><p>Probably the second most <a class="indexterm" id="id00429"/>interesting new member where OpenGL is concerned is we have another three float arrays called <code class="literal">modelMatrix</code>, <code class="literal">viewportModelMatrix</code>, and <code class="literal">rotateViewportModelMatrix</code>. These will be instrumental in helping OpenGL to draw the <code class="literal">GameObject</code> class exactly as required. We will examine exactly how they are initialized and used when we get to the <code class="literal">draw</code> method of this class.</p><p>We also have a bunch of members that hold different angles and rotation rates. How we use and update these in order to inform OpenGL of the orientation of our objects, we will see soon:</p><div class="informalexample"><pre class="programlisting">    // This will hold our vertex data that is
    // passed into the openGL glProgram
    // OPenGL likes FloatBuffer
    private FloatBuffer vertices;

    // For translating each point from the model (ship, asteroid etc)
    // to its game world coordinates
    private final float[] modelMatrix = new float[16];

    // Some more matrices for Open GL transformations
    float[] viewportModelMatrix = new float[16];
    float[] rotateViewportModelMatrix = new float[16];

    // Where is the GameObject facing?
    private float facingAngle = 90f;

    // How fast is it rotating?
    private float rotationRate = 0f;

    // Which direction is it heading?
    private float travellingAngle = 0f;

    // How long and wide is the GameObject?
    private float length;
    private float width;</pre></div><p>We now implement the constructor. First, we check if we have previously compiled the shaders, because we only need to do it once. If we haven't, this is what happens inside the <code class="literal">if(glProgarm == -1)</code> block.</p><p>We call <code class="literal">setGLProgram()</code> followed by <code class="literal">glUseProgram()</code> with <code class="literal">glProgram</code> as the argument. That is all we <a class="indexterm" id="id00430"/>have to do, <code class="literal">GLManager</code> does the rest and our OpenGL program is ready to use.</p><p>Before we go on, however, we save the locations of our key shader variables by calling the respective methods (<code class="literal">glGetUniformLocation()</code> and <code class="literal">glGetAttrtibuteLocation</code>) to get their locations within our GL program. We will see in the <code class="literal">draw</code> method of this class how we use those locations to manipulate values within the shaders.</p><p>Finally, we set <code class="literal">isActive</code> to <code class="literal">true</code>. Enter this method into the <code class="literal">GameObject</code> class:</p><div class="informalexample"><pre class="programlisting">public GameObject(){
    // Only compile shaders once
    if (glProgram == -1){
        setGLProgram();

        // tell OpenGl to use the glProgram
        glUseProgram(glProgram);

        // Now we have a glProgram we need the locations
        // of our three GLSL variables.
        // We will use these when we call draw on the object.
        uMatrixLocation = glGetUniformLocation(glProgram, U_MATRIX);
        aPositionLocation = glGetAttribLocation(glProgram, A_POSITION);
        uColorLocation = glGetUniformLocation(glProgram, U_COLOR);
    }

    // Set the object as active
    isActive = true;

}</pre></div><p>Now we have a few getters and setters including <code class="literal">getWorldLocation()</code>, which we called from the <code class="literal">draw</code> method in <code class="literal">AsteroidsRenderer</code> and <code class="literal">setGLProgram()</code>. This uses the <code class="literal">GLManager</code> class's static method <code class="literal">getGLProgram()</code> to get the handle to our GL program.</p><p>Enter all these methods<a class="indexterm" id="id00431"/> into the <code class="literal">GameObject</code> class:</p><div class="informalexample"><pre class="programlisting">public boolean isActive() {
  return isActive;
}

public void setActive(boolean isActive) {
  this.isActive = isActive;
}

public void setGLProgram(){
  glProgram = GLManager.getGLProgram();
}

public Type getType() {
  return type;
}

public void setType(Type t) {
  this.type = t;
}

public void setSize(float w, float l){
  width = w;
  length = l;

}

public PointF getWorldLocation() {
  return worldLocation;
}

public void setWorldLocation(float x, float y) {
  this.worldLocation.x = x;
  this.worldLocation.y = y;
}</pre></div><p>The next method, <code class="literal">setVertices()</code> is a vital step in preparing an object to be drawn by OpenGL. In each of our child classes, we will build an array of float types to represent the vertices that make up the shape of the game object. Each game object will obviously be different in shape, but the <code class="literal">setVertices</code> method does not need to appreciate the difference, it just needs the data.</p><p>As we can see in the next block of code, the method receives a float array as a parameter. It then stores the number of elements that is equal to the length of the array in <code class="literal">numElements</code>. Note that the number of elements is different from the number of vertices the elements represent. It takes three elements (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span>) to make one vertex. Therefore, we can store into <code class="literal">numVertices</code> the correct value by dividing <code class="literal">numElements</code> by <code class="literal">ELEMENTS_PER_VERTEX</code>.</p><p>Now we can actually initialize up our <code class="literal">ByteBuffer</code> by calling <code class="literal">allocateDirect()</code> and passing in our newly initialized variables along with <code class="literal">FLOAT_SIZE</code>. The <code class="literal">ByteOrder.nativeOrder</code> method simply detects if the particular system's endianness, and <code class="literal">asFloatBuffer()</code> tells <code class="literal">ByteBuffer</code> the type of data that will stored. We can now store our array of vertices into our vertices <code class="literal">ByteBuffer</code> by calling <code class="literal">vertices.put(modelVertices)</code>. This <a class="indexterm" id="id00432"/>data is now ready to be passed to OpenGL.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0021"/>Tip</h3><p>If you want to learn more about <a class="indexterm" id="id00433"/>endianness, take a look at this Wikipedia article:</p><p>
<a class="ulink" href="http://en.wikipedia.org/wiki/Endianness">http://en.wikipedia.org/wiki/Endianness</a>
</p></div></div><p>Enter the <code class="literal">setVertices</code> method into the <code class="literal">GameObject</code> class:</p><div class="informalexample"><pre class="programlisting">public void setVertices(float[] objectVertices){

    modelVertices = new float[objectVertices.length];
    modelVertices = objectVertices;

    // Store how many vertices and elements there is for future use
    numElements = modelVertices.length;

    numVertices = numElements/ELEMENTS_PER_VERTEX;

    // Initialize the vertices ByteBuffer object based on the
    // number of vertices in the ship design and the number of
    // bytes there are in the float type
    vertices = ByteBuffer.allocateDirect(
            numElements
            * FLOAT_SIZE)
            .order(ByteOrder.nativeOrder()).asFloatBuffer();

    // Add the ship into the ByteBuffer object
    vertices.put(modelVertices);

}</pre></div><p>Now we get to see how we actually draw the contents of our <code class="literal">ByteBuffer</code>. At a glance, the following code may look complex, but when we discuss the nature of the data in our <code class="literal">ByteBuffer</code> and the steps that OpenGL goes through to draw this data, we will see that it is actually quite straightforward.</p><p>As we have not written the code for our first <code class="literal">GameObject</code> child class, there is one key thing to point out. The vertices that represent the shape of a game object are zero based on its own center. </p><p>The OpenGL coordinate system has <span class="strong"><strong>0,0</strong></span> as its center but, to make it clear, this is not related. This is called model space. The next image is a representation of our spaceship, in model space, that we will soon create:</p><div class="mediaobject"><img alt="Building an OpenGL-friendly, GameObject super class" src="graphics/B04322_09_02.jpg"/></div><p>It is this data that is<a class="indexterm" id="id00434"/> contained within our <code class="literal">ByteBuffer</code>. This data takes no account of orientation (is the ship or asteroid rotated), it takes no account of its position in the game world and, as a reminder, it is totally unrelated to the OpenGL coordinate system.</p><p>Therefore, before we draw our <code class="literal">ByteBuffer</code>, we need to convert this data, or, more accurately, we need to prepare an appropriate matrix, which we will pass into OpenGL with the data so that OpenGL will know how to use or convert the data.</p><p>I have split the <code class="literal">draw</code> method up into six chunks to talk about how we do this. Note that our <code class="literal">viewPort</code> matrix is prepared in our <code class="literal">AsteroidsRenderer</code> class's <code class="literal">draw</code> method, which is centered upon the location of the ship and based around the proportion of game world we want to show and is passed in as a parameter.</p><p>First, we call <code class="literal">glUseProgram()</code> and pass in the handle to our program. Then we set the internal pointer of our <code class="literal">ByteBuffer</code> to the start with <code class="literal">vertices.position(0)</code>.</p><p>The <code class="literal">glVertexAttributePointer</code> method uses our <code class="literal">aPositionLocation</code> variable along with our <code class="literal">GLManager</code> static constants and of course the <code class="literal">vertices</code> <code class="literal">ByteBuffer</code> to associate our vertices with the <code class="literal">aPosition</code> variable in the vertex shader. Finally, for this chunk of code, we tell <a class="indexterm" id="id00435"/>OpenGL to enable the attribute array:</p><div class="informalexample"><pre class="programlisting">    public void draw(float[] viewportMatrix){

        // tell OpenGl to use the glProgram
        glUseProgram(glProgram);

        // Set vertices to the first byte
        vertices.position(0);

        glVertexAttribPointer(
              aPositionLocation,
              COMPONENTS_PER_VERTEX,
              GL_FLOAT,
              false,
              STRIDE,
              vertices);

        glEnableVertexAttribArray(aPositionLocation);</pre></div><p>Now, we put our matrices to work. We create an identity matrix out of our <code class="literal">modelMatrix</code> array by calling <code class="literal">setIndentityM()</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0030"/>Note</h3><p>As we will see, we are going to be using and combining quite a lot of matrices. An identity matrix acts as a starting point or container on which we can build a matrix, which combines all the transformations that we need to occur. A very simple but not entirely accurate way of thinking about an identity matrix is that it is like the number 1. When you multiply by an identity matrix, it doesn't cause any alteration to the other part of the sum. However, the answer is correct for moving on to the next part of the equation. If this is annoying you and you want to know more, take a look at these really quick tutorials on matrices and the identity <a class="indexterm" id="id00436"/>matrix. </p><p>Matrices:</p><p>
<a class="ulink" href="https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix">https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix</a>
</p><p>Identity<a class="indexterm" id="id00437"/> matrix:</p><p>
<a class="ulink" href="https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix">https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix</a>
</p></div></div><p>We then pass our <a class="indexterm" id="id00438"/>new <code class="literal">modelMatrix</code> into the <code class="literal">translateM</code> method. Translate is math speak for move. Look closely at the arguments passed into <code class="literal">translateM()</code>. We are passing in the <span class="emphasis"><em>x</em></span> any <span class="emphasis"><em>y</em></span> world locations of the object. This is how OpenGL knows where the object is:</p><div class="informalexample"><pre class="programlisting">    // Translate model coordinates into world coordinates
    // Make an identity matrix to base our future calculations on
    // Or we will get very strange results
    setIdentityM(modelMatrix, 0);
    // Make a translation matrix
   
    /*
        Parameters:
        m   matrix
        mOffset index into m where the matrix starts
        x   translation factor x
        y   translation factor y
        z   translation factor z
    */
    translateM(modelMatrix, 0, worldLocation.x, worldLocation.y, 0);</pre></div><p>We know that OpenGL has a matrix to translate our object to its world location. It also has a <code class="literal">ByteBuffer</code> class with the model space coordinates, but how does it convert translated model space coordinates to our viewport drawn using OpenGL coordinate system?</p><p>It uses the viewport matrix, which is modified by each frame and passed into this method. All we need to do is multiply <code class="literal">viewportMatrix</code> and the recently translated <code class="literal">modelMatrix</code> together using <code class="literal">multiplyMM()</code>. This method creates the combined or multiplied matrix and stores the result in <code class="literal">viewportModelMatrix</code>:</p><div class="informalexample"><pre class="programlisting">   // Combine the model with the viewport
   // into a new matrix
   multiplyMM(viewportModelMatrix, 0, 
      viewportMatrix, 0, modelMatrix, 0);</pre></div><p>We are almost done creating our matrix. The only other possible distortion that OpenGL will need to make to the vertices in the <code class="literal">ByteBuffer</code> is to rotate them to the <code class="literal">facingAngle</code> parameter.</p><p>Next, we create a rotation matrix appropriate to the current object's facing angle and storing the result back in <code class="literal">modelMatrix</code>.</p><p>Then, we combine or multiply the newly rotated <code class="literal">modelMatrix</code> with our <code class="literal">viewportModelMatrix</code> and store the result in <code class="literal">rotateViewportModelMatrix</code>. This is our final matrix <a class="indexterm" id="id00439"/>that we will pass into the OpenGL system:</p><div class="informalexample"><pre class="programlisting">   /*
        Now rotate the model - just the ship model

        Parameters
        rm  returns the result
        rmOffset    index into rm where the result matrix starts
        a   angle to rotate in degrees
        x   X axis component
        y   Y axis component
        z   Z axis component
    */
    setRotateM(modelMatrix, 0, facingAngle, 0, 0, 1.0f);

    // And multiply the rotation matrix into the model-viewport 
    // matrix
    multiplyMM(rotateViewportModelMatrix, 0, 
      viewportModelMatrix, 0, modelMatrix, 0);</pre></div><p>Now we pass in the matrix using the <code class="literal">glUniformMatrix4fv()</code> method and use the <code class="literal">uMatrixLocation</code> variable (which is the location of the matrix-related variable in the vertex shader) and our final matrix in the arguments.</p><p>We also choose the color by calling <code class="literal">glUniform4f()</code> with the <code class="literal">uColorLocation</code> and an RGBT (Red, Green, Blue, Transparency) value. All values are set to 1.0, so the fragment shader will draw white.</p><div class="informalexample"><pre class="programlisting">   // Give the matrix to OpenGL
        
    glUniformMatrix4fv(uMatrixLocation, 1, false,                                        
    rotateViewportModelMatrix, 0);
        
    // Assign a color to the fragment shader
    glUniform4f(uColorLocation, 1.0f, 1.0f, 1.0f, 1.0f);</pre></div><p>Finally, we switch based on the object type and draw either points, lines, or triangle primitives:</p><div class="informalexample"><pre class="programlisting">   // Draw the point, lines or triangle
    switch (type){
        case SHIP:
        glDrawArrays(GL_TRIANGLES, 0, numVertices);
        break;

        case ASTEROID:
        glDrawArrays(GL_LINES, 0, numVertices);
        break;

        case BORDER:
        glDrawArrays(GL_LINES, 0, numVertices);
        break;

       case STAR:
        glDrawArrays(GL_POINTS, 0, numVertices);
        break;

        case BULLET:
        glDrawArrays(GL_POINTS, 0, numVertices);
        break;
    }

} // End draw()

}// End class</pre></div><p>Now that we have <a class="indexterm" id="id00440"/>the fundamentals of our <code class="literal">GameObject</code> class, we can make a class to represent our spaceship and draw it to the screen.</p></div>
<div class="section" title="The spaceship"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec052"/>The spaceship</h1></div></div></div><p>This class is<a class="indexterm" id="id00441"/> nice and simple, although it will evolve with the project. The constructor receives the starting location within the game world. We set the ship's type and world location using the methods from the <code class="literal">GameObject</code> class, and we set a width and height.</p><p>We declare and initialize some variables to simplify the initialization of the model space coordinates, and then we go ahead and initialize a float array with three vertices that represent the triangle that is our ship. Note that the values are based around a center of <span class="emphasis"><em>x = 0</em></span> and <span class="emphasis"><em>y = 0</em></span>.</p><p>All we do next is, call <code class="literal">setVertices()</code>, and <code class="literal">GameObject</code> will prepare the <code class="literal">ByteBuffer</code> ready for OpenGL:</p><div class="informalexample"><pre class="programlisting">public class SpaceShip extends GameObject{

  public SpaceShip(float worldLocationX, float worldLocationY){
       super();

        // Make sure we know this object is a ship
        // So the draw() method knows what type
        // of primitive to construct from the vertices

        setType(Type.SHIP);

        setWorldLocation(worldLocationX,worldLocationY);

        float width = 15;
        float length = 20;

        setSize(width, length);

        // It will be useful to have a copy of the
        // length and width/2 so we don't have to keep dividing by 2
        float halfW = width / 2;
        float halfL = length / 2;

        // Define the space ship shape
        // as a triangle from point to point
        // in anti clockwise order
        float [] shipVertices = new float[]{

               - halfW, - halfL, 0,
               halfW, - halfL, 0,
               0, 0 + halfL, 0

      };


       setVertices(shipVertices);

     }

}</pre></div><p>At last, we can see the<a class="indexterm" id="id00442"/> fruits of our labor.</p></div>
<div class="section" title="Drawing at 60 + FPS"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec053"/>Drawing at 60 + FPS</h1></div></div></div><p>In three simple steps, we will<a class="indexterm" id="id00443"/> be able to glimpse our spaceship:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add a <code class="literal">SpaceShip</code> object to the <code class="literal">GameManager</code> member variables:<div class="informalexample"><pre class="programlisting">private boolean playing = false;

<span class="strong"><strong>  // Our first game object</strong></span>
<span class="strong"><strong>     SpaceShip ship;</strong></span>

     int screenWidth;</pre></div></li><li class="listitem" style="list-style-type: disc">Add a call to the new <code class="literal">SpaceShip()</code> to the <code class="literal">createObjects</code> method:<div class="informalexample"><pre class="programlisting">private void createObjects() {
        
  // Create our game objects
<span class="strong"><strong>  // First the ship in the center of the map</strong></span>
<span class="strong"><strong>     gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);</strong></span>
}</pre></div></li><li class="listitem" style="list-style-type: disc">Add the call to draw the spaceship in each frame in the <code class="literal">draw</code> method of <code class="literal">AsteroidsRenderer</code>:<div class="informalexample"><pre class="programlisting">// Start drawing!
<span class="strong"><strong>// Draw the ship</strong></span>
<span class="strong"><strong>gm.ship.draw(viewportMatrix);</strong></span>
</pre></div></li></ul></div><p>Run the game and see the output:</p><div class="mediaobject"><img alt="Drawing at 60 + FPS" src="graphics/B04322_09_03.jpg"/></div><p>Not exactly impressive <a class="indexterm" id="id00444"/>visuals, but it is running between 67 and 212 frames per second in debug mode while outputting to the console on an ageing Samsung Galaxy S2 phone.</p><div class="mediaobject"><img alt="Drawing at 60 + FPS" src="graphics/B04322_09_04.jpg"/></div><p>It will be our aim<a class="indexterm" id="id00445"/> throughout the project to add hundreds of objects and keep the frames per second over 60.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0022"/>Tip</h3><p>One of the book's reviewers reported frame rates in excess of 1000 per second on a Nexus 5! It will therefore be worth considering a maximum frame rate locking strategy to save battery life if you were planning to release this to the Google Play store.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec054"/>Summary</h1></div></div></div><p>Setting up a drawing system was a little bit long-winded. However, now that it is done, we can churn out new objects much more easily. All we have to do is define the type and the vertices, then we can draw them with ease.</p><p>It is because of this ground work that the next chapter will be much more visually rewarding. Next, we will create blinking stars, a game world border, spinning and moving asteroids, whizzing bullets, and a HUD, as well as add full controls and motion to the spaceship.</p></div>
<div class="chapter" title="Chapter&#xA0;10.&#xA0;Move and Draw with OpenGL ES 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch19"/>Chapter 10. Move and Draw with OpenGL ES 2</h1></div></div></div><p>In this chapter, we will implement all the graphics, game play, and movement. In just over 30 pages, we will complete everything except collision detection. We can achieve this much because of the groundwork we laid in the last chapter.</p><p>First, we will draw a static border around our game world, then some blinking stars, followed by adding movement to our spaceship as well as some bullets. After that, we will quickly add controls for the player and we will be whizzing around the screen.</p><p>We will also make some noise by implementing our <code class="literal">SoundManager</code> class with some new sound FX.</p><p>Once this is done, we will add randomly shaped asteroids that move across the world while spinning around at the same time.</p><p>Then, we can add a HUD to highlight the touchable areas of the screen and provide a tally of the remaining player lives and asteroids that need destroying before the next level.</p><div class="section" title="Drawing a static game border"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec055"/>Drawing a static game border</h1></div></div></div><p>In this simple class, we <a class="indexterm" id="id00446"/>define four sets of points that will represent four lines. Unsurprisingly, the <code class="literal">GameObject</code> class will draw the border using these points as the end points of lines.</p><p>In the constructor, which is the entirety of the class, we set the type by calling <code class="literal">setType()</code>, the world location as the center of the map, and <code class="literal">height</code> and <code class="literal">width</code> as the height and width of the entire map.</p><p>Then, we define the four lines in a float array and call <code class="literal">setVertices()</code> to prepare a <code class="literal">FloatBuffer</code>.</p><p>Create a new class called <code class="literal">Border</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">public class Border extends GameObject{

  public Border(float mapWidth, float mapHeight){

        setType(Type.BORDER);
        //border center is the exact center of map
        setWorldLocation(mapWidth/2,mapHeight/2);

        float w = mapWidth;
        float h = mapHeight;
        setSize(w, h);

       // The vertices of the border represent four lines
       // that create a border of a size passed into the constructor
       float[] borderVertices = new float[]{
           // A line from point 1 to point 2
            - w/2, -h/2, 0,
            w/2, -h/2, 0,
            // Point 2 to point 3
            w/2, -h/2, 0,
            w/2, h/2, 0,
            // Point 3 to point 4
            w/2, h/2, 0,
            -w/2, h/2, 0,
            // Point 4 to point 1
            -w/2, h/2, 0,
            - w/2, -h/2, 0,
    };

        setVertices(borderVertices);

  }

}</pre></div><p>We can then declare <a class="indexterm" id="id00447"/>a <code class="literal">Border</code> object as a member of <code class="literal">GameManager</code> like this:</p><div class="informalexample"><pre class="programlisting">// Our game objects
SpaceShip ship;
<span class="strong"><strong>Border border;</strong></span>
</pre></div><p>Initialize it in the <code class="literal">createObjects</code> method of <code class="literal">AsteroidsRenderer</code> like this:</p><div class="informalexample"><pre class="programlisting">// Create our game objects

// First the ship in the center of the map
gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);

<span class="strong"><strong>// The deadly border</strong></span>
<span class="strong"><strong>gm.border = new Border(gm.mapWidth, gm.mapHeight);</strong></span>
</pre></div><p>Now, we can draw our border by adding a line of code into the <code class="literal">draw</code> method of the <code class="literal">AsteroidsRendrer</code> class:</p><div class="informalexample"><pre class="programlisting">gm.ship.draw(viewportMatrix);
<span class="strong"><strong>gm.border.draw(viewportMatrix);</strong></span>
</pre></div><p>You can now run the <a class="indexterm" id="id00448"/>game. If you want to actually see the border, you can change the location to which we initialize the ship to somewhere near the border. Remember that in the <code class="literal">draw</code> method, we center the viewport around the ship. To see the border, change this one line in the <code class="literal">SpaceShip</code> class to this:</p><div class="informalexample"><pre class="programlisting">setWorldLocation(10,10);</pre></div><p>Run the game to take a look.</p><div class="mediaobject"><img alt="Drawing a static game border" src="graphics/B043422_10_01.jpg"/></div><p>Change it back to this:</p><div class="informalexample"><pre class="programlisting">setWorldLocation(worldLocationX,worldLocationY);</pre></div><p>Now, we will fill up the area within the border with stars.</p></div></div>
<div class="section" title="Twinkling stars"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec056"/>Twinkling stars</h1></div></div></div><p>We will get a bit more mobile than a static<a class="indexterm" id="id00449"/> border. Here, we will add an <code class="literal">update</code> method to a simple <code class="literal">Star</code> class, which can be used to randomly switch the star on and off.</p><p>We set the type as <code class="literal">normal</code> and create a random location for the star within the confines of the border and call <code class="literal">setWorldLocation()</code> as always.</p><p>Stars will be drawn as points, so our vertex array will simply contain one vertex at model space 0,0,0. Then, we call <code class="literal">setVertices()</code> as usual.</p><p>Create a new class, call it <code class="literal">Star</code>, and enter the discussed code:</p><div class="informalexample"><pre class="programlisting">public class Star extends GameObject{

    // Declare a random object here because
    // we will use it in the update() method
    // and we don't want GC to have to keep clearing it up
    Random r;

    public Star(int mapWidth, int mapHeight){
    setType(Type.STAR);
    r = new Random();
    setWorldLocation(r.nextInt(mapWidth),r.nextInt(mapHeight));

    // Define the star
    // as a single point
    // in exactly the coordinates as its world location
    float[] starVertices = new float[]{

                0,
                0,
                0

    };

    setVertices(starVertices);


    }</pre></div><p>Here is our <code class="literal">Star</code> class's <code class="literal">update</code> method. As we can see, there is a one in a 1000 chance in each frame that the star will switch its status. For more blinking, use a lower seed, and for less blinking, use a higher seed.</p><div class="informalexample"><pre class="programlisting">public void update(){

  // Randomly twinkle the stars
     int n = r.nextInt(1000);
     if(n == 0){
       // Switch on or off
       if(isActive()){
         setActive(false);
        }else{
          setActive(true);
        }
   }

}</pre></div><p>We then declare a <code class="literal">Star</code> array, as <a class="indexterm" id="id00450"/>a member of <code class="literal">GameManager</code>, and an extra <code class="literal">int</code> variable to control how many stars we want to draw, as follows:</p><div class="informalexample"><pre class="programlisting">// Our game objects
SpaceShip ship;
Border border;
<span class="strong"><strong>Star[] stars;</strong></span>
<span class="strong"><strong>int numStars = 200;</strong></span>
</pre></div><p>Initialize the array of <code class="literal">Star</code> objects in the <code class="literal">createObjects</code> method of <code class="literal">AsteroidsRenderer</code> as follows:</p><div class="informalexample"><pre class="programlisting">// The deadly border
gm.border = new Border(gm.mapWidth, gm.mapHeight);

<span class="strong"><strong>// Some stars</strong></span>
<span class="strong"><strong>gm.stars = new Star[gm.numStars];</strong></span>
<span class="strong"><strong>for (int i = 0; i &lt; gm.numStars; i++) {</strong></span>

<span class="strong"><strong>    // Pass in the map size so the stars no where to spawn</strong></span>
<span class="strong"><strong>    gm.stars[i] = new Star(gm.mapWidth, gm.mapHeight);</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Now, we can draw our stars by adding these lines of code into the <code class="literal">draw</code> method of the <code class="literal">AsteroidsRenderer</code> class. Note that we draw the stars first as they are in the background.</p><div class="informalexample"><pre class="programlisting">// Start drawing!
        
<span class="strong"><strong>// Some stars</strong></span>
<span class="strong"><strong>for (int i = 0; i &lt; gm.numStars; i++) {</strong></span>

<span class="strong"><strong>     // Draw the star if it is active</strong></span>
<span class="strong"><strong>     if(gm.stars[i].isActive()) {</strong></span>
<span class="strong"><strong>        gm.stars[i].draw(viewportMatrix);</strong></span>
<span class="strong"><strong>     }</strong></span>
<span class="strong"><strong>}</strong></span>

gm.ship.draw(viewportMatrix);
gm.border.draw(viewportMatrix);</pre></div><p>Of course, to make them<a class="indexterm" id="id00451"/> blink, we call their <code class="literal">update</code> method from the <code class="literal">AsteroidsRenderer</code> class's <code class="literal">update</code> method like this:</p><div class="informalexample"><pre class="programlisting">private void update(long fps) {
        
<span class="strong"><strong>        // Update (twinkle) the stars</strong></span>
<span class="strong"><strong>        for (int i = 0; i &lt; gm.numStars; i++) {</strong></span>
<span class="strong"><strong>        gm.stars[i].update();</strong></span>
<span class="strong"><strong>        }</strong></span>

    
}</pre></div><p>You can now run the game:</p><div class="mediaobject"><img alt="Twinkling stars" src="graphics/B043422_10_02.jpg"/></div></div>
<div class="section" title="Bringing the spaceship to life"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec057"/>Bringing the spaceship to life</h1></div></div></div><p>First, we need to add a bit <a class="indexterm" id="id00452"/>more functionality to our <code class="literal">GameObject</code> class. We do so<a class="indexterm" id="id00453"/> in <code class="literal">GameObject</code> because bullets and asteroids share a surprising amount of similarities with a spaceship.</p><p>We need a bunch of getters and setters to get and set the rotation rate, traveling angle, and facing angle. Add the following methods to the <code class="literal">GameObject</code> class:</p><div class="informalexample"><pre class="programlisting">public void setRotationRate(float rotationRate) {
  this.rotationRate = rotationRate;
}

public float getTravellingAngle() {
  return travellingAngle;
}

public void setTravellingAngle(float travellingAngle) {
  this.travellingAngle = travellingAngle;
}

public float getFacingAngle() {
  return facingAngle;
}

public void setFacingAngle(float facingAngle) {
  this.facingAngle = facingAngle;
}</pre></div><p>Now, we add a <code class="literal">move</code> method, which adjusts the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates as well as the <code class="literal">facingAngle</code> of the object based on the current frames per second. Add the <code class="literal">move</code> method:</p><div class="informalexample"><pre class="programlisting">void move(float fps){
  if(xVelocity != 0) {
       worldLocation.x += xVelocity / fps;
    }

     if(yVelocity != 0) {
       worldLocation.y += yVelocity / fps;
    }

     // Rotate
     if(rotationRate != 0) {
       facingAngle = facingAngle + rotationRate / fps;
    }

}</pre></div><p>To complete our additions to the <code class="literal">GameObject</code> class, add these getters and setters for velocity, speed, and maximum speed:</p><div class="informalexample"><pre class="programlisting">public float getxVelocity() {
  return xVelocity;
}

public void setxVelocity(float xVelocity) {
  this.xVelocity = xVelocity;
}

public float getyVelocity() {
  return yVelocity;
}

public void setyVelocity(float yVelocity) {
  this.yVelocity = yVelocity;
}

public float getSpeed() {
  return speed;
}

public void setSpeed(float speed) {
  this.speed = speed;
}

public float getMaxSpeed() {
  return maxSpeed;
}

public void setMaxSpeed(float maxSpeed) {
  this.maxSpeed = maxSpeed;
}</pre></div><p>We can make some<a class="indexterm" id="id00454"/> additions to the <code class="literal">SpaceShip</code> class. Add these three members<a class="indexterm" id="id00455"/> to the <code class="literal">SpaceShip</code> class to control if the player's ship is turning or moving forward:</p><div class="informalexample"><pre class="programlisting">boolean isThrusting;
private boolean isPressingRight = false;
private boolean isPressingLeft = false;</pre></div><p>Now, inside the <code class="literal">SpaceShip</code> constructor, let's set the maximum speed of the ship. I have highlighted the new line of code among the existing code:</p><div class="informalexample"><pre class="programlisting">setSize(width, length);

<span class="strong"><strong>setMaxSpeed(150);</strong></span>

// It will be useful to have a copy of the</pre></div><p>Next, in the <code class="literal">SpaceShip</code> class, we add an <code class="literal">update</code> method that, first of all, increases and decreases the speed based on whether <code class="literal">isThrusting</code> is true or false.</p><div class="informalexample"><pre class="programlisting">public void update(long fps){

float speed = getSpeed();
if(isThrusting) {
  if (speed &lt; getMaxSpeed()){
       setSpeed(speed + 5);
     }

     }else{
       if(speed &gt; 0) {
         setSpeed(speed - 3);
        }else {
         setSpeed(0);
        }
}</pre></div><p>Then, we set<a class="indexterm" id="id00456"/> the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> <a class="indexterm" id="id00457"/>velocity based on the angle, which way the ship is facing, and the speed.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0031"/>Note</h3><p>We use speed multiplied by the cosine of the angle the ship is facing to set the velocity on the <span class="emphasis"><em>x</em></span> axis. This works because the cosine function is a perfect variant that will return a value of -1 or 1, when the ship is facing exactly left or right, respectively; the variant returns a precise value of 0 when the ship is pointing exactly up or down. It also returns fine values in between as well. The sine of the angle works in exactly<a class="indexterm" id="id00458"/> the same way on the <span class="emphasis"><em>y</em></span> axis. The slightly convoluted looking code is because we need to convert our angle to radians and we must add 90 degrees to our <code class="literal">facingAngle</code> because 0 degrees is pointing to three o'clock. This fact is not conducive to using it on an <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> plane the way we have it, so we modify it by 90 degrees and the ship moves as expected. For more information about how this works check out this tutorial:</p><p>
<a class="ulink" href="http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/">http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/</a>
</p></div></div><div class="informalexample"><pre class="programlisting">setxVelocity((float) 
  (speed* Math.cos(Math.toRadians(getFacingAngle() + 90))));
        
setyVelocity((float) 
  (speed* Math.sin(Math.toRadians(getFacingAngle() + 90))));

        </pre></div><p>Now, we set the rotation rate based on whether the player is turning left or right. Finally, we call <code class="literal">move()</code> to put all the updates into effect.</p><div class="informalexample"><pre class="programlisting">if(isPressingLeft){
  setRotationRate(360);
}

else if(isPressingRight){
  setRotationRate(-360);
     }else{
       setRotationRate(0);
    }

     move(fps);
}</pre></div><p>Now, we need to add a <code class="literal">pullTrigger</code> method, which<a class="indexterm" id="id00459"/> for now, we just<a class="indexterm" id="id00460"/> return <code class="literal">true</code>. We also provide three methods for our future <code class="literal">InputController</code> to call and trigger the <code class="literal">update</code> method to make its various changes.</p><div class="informalexample"><pre class="programlisting">public boolean pullTrigger() {
  //Try and fire a shot
  // We could control rate of fire from here
  // But lets just return true for unrestricted rapid fire
  // You could remove this method and any code which calls it
  
   return true;
}


public void setPressingRight(boolean pressingRight) {
  isPressingRight = pressingRight;
}

public void setPressingLeft(boolean pressingLeft) {
  isPressingLeft = pressingLeft;
}

public void toggleThrust() {
  isThrusting = ! isThrusting;
}</pre></div><p>We are already drawing the<a class="indexterm" id="id00461"/> ship in each frame, but we need to add <a class="indexterm" id="id00462"/>one line of code in the <code class="literal">AsteroidsRenderer</code> class's <code class="literal">update</code> method. Add this line of code to call the <code class="literal">SpaceShip</code> class's <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">// Update (twinkle) the stars
for (int i = 0; i &lt; gm.numStars; i++) {
  gm.stars[i].update();
}

<span class="strong"><strong>// Run the ship,s update() method</strong></span>
<span class="strong"><strong>gm.ship.update(fps);</strong></span>
</pre></div><p>Obviously, we can't actually move until we add the player controls. Let's quickly add some bullets to the game. Then, we will add sound and controls so that we can see and hear the cool new features we added.</p></div>
<div class="section" title="Rapid fire bullets"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec058"/>Rapid fire bullets</h1></div></div></div><p>I've been addicted to games<a class="indexterm" id="id00463"/> since Pong in the '70s, and remember my delight when a friend actually had a Space Invaders machine in his home for about a week. Although what really made asteroids so much better than Space Invaders, was how quickly you could shoot. In that tradition, we will make a satisfying, rapid fire stream of bullets.</p><p>Create a new class called <code class="literal">Bullet</code>, which has one vertex and will be drawn with a point. Note that we also declare and initialize an <code class="literal">inFlight</code> Boolean.</p><div class="informalexample"><pre class="programlisting">public class Bullet extends GameObject {

  private boolean inFlight = false;

  public Bullet(float shipX, float shipY) {
       super();

       setType(Type.BULLET);

       setWorldLocation(shipX, shipY);

       // Define the bullet
       // as a single point
       // in exactly the coordinates as its world location
       float[] bulletVertices = new float[]{

                0,
                0,
                0

       };
    
    setVertices(bulletVertices);

        
}</pre></div><p>Next, we have the <code class="literal">shoot</code> method that sets the <code class="literal">facingAngle</code> of the bullet to that of the ship. This will cause the bullet to move in the direction the ship was facing at the time the fire button was pressed. We also set <code class="literal">inFlight</code> to true and see how this is used in the <code class="literal">update</code> method. Finally, we <a class="indexterm" id="id00464"/>set the speed to <code class="literal">300</code>.</p><p>We also add a <code class="literal">resetBullet</code> method, which sets the bullet inside the ship and cancels its velocity and speed. This gives us a clue as to how we will implement our bullets. The bullets will sit invisibly inside the ship until they are fired.</p><div class="informalexample"><pre class="programlisting">public void shoot(float shipFacingAngle){
        
     setFacingAngle(shipFacingAngle);
     inFlight = true;
     setSpeed (300);
}

public void resetBullet(PointF shipLocation){
  
     // Stop moving if bullet out of bounds
     inFlight = false;
     setxVelocity(0);
     setyVelocity(0);
     setSpeed(0);
     setWorldLocation(shipLocation.x, shipLocation.y);

}

public boolean isInFlight(){
  return  inFlight;
}</pre></div><p>Now, we move the bullet based on its <code class="literal">facingAngle</code> and speed, only if <code class="literal">inFlight</code> is true. Otherwise, we keep the bullet inside the ship. Then, we call <code class="literal">move()</code>.</p><div class="informalexample"><pre class="programlisting">public void update(long fps, PointF shipLocation){
        // Set the velocity if bullet in flight
        if(inFlight){
            setxVelocity((float)(getSpeed()* 
               Math.cos(Math.toRadians(getFacingAngle() + 90))));
            setyVelocity((float)(getSpeed()* 
               Math.sin(Math.toRadians(getFacingAngle() + 90))));
        }else{
            // Have it sit inside the ship
            setWorldLocation(shipLocation.x, shipLocation.y);
        }

        move(fps);
    }
}</pre></div><p>Now, we have a <code class="literal">Bullet</code> class<a class="indexterm" id="id00465"/>, we can declare an array, to hold a bunch of objects of this type in our <code class="literal">GameManager</code> class.</p><div class="informalexample"><pre class="programlisting">int numStars = 200;
<span class="strong"><strong>Bullet [] bullets;</strong></span>
<span class="strong"><strong>int numBullets = 20;</strong></span>
</pre></div><p>Initialize them in <code class="literal">createObjects()</code> right after our stars from the last section in <code class="literal">AsteroidsRenderer</code>. Note how we initialize their location in the game world as the center of the ship.</p><div class="informalexample"><pre class="programlisting">// Some bullets
gm.bullets = new Bullet[gm.numBullets];
for (int i = 0; i &lt; gm.numBullets; i++) {
  gm.bullets[i] = new Bullet(
     gm.ship.getWorldLocation().x,
     gm.ship.getWorldLocation().y);
}</pre></div><p>Update them in the <code class="literal">update</code> method, again right after our blinking stars.</p><div class="informalexample"><pre class="programlisting">// Update all the bullets
for (int i = 0; i &lt; gm.numBullets; i++) {

    // If not in flight they will need the ships location
    gm.bullets[i].update(fps, gm.ship.getWorldLocation());

}</pre></div><p>Draw them in the <code class="literal">draw</code> method, once more, after the stars.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; gm.numBullets; i++) {
  gm.bullets[i].draw(viewportMatrix);
}</pre></div><p>The bullets are now ready to be fired!</p><p>We will add a <code class="literal">SoundManager</code> and <code class="literal">InputController</code> class, then we can see our ship and its rapid fire <a class="indexterm" id="id00466"/>gun in action.</p></div>
<div class="section" title="Reusing existing classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec059"/>Reusing existing classes </h1></div></div></div><p>Let's quickly add<a class="indexterm" id="id00467"/> our <code class="literal">SoundManager</code> and <code class="literal">InputController</code> classes to this project because they only need a little tweak to accommodate our needs here too.</p><p>Add a member for a <code class="literal">SoundManager</code> and an <code class="literal">InputController</code> object in both the <code class="literal">AsteroidsView</code> and <code class="literal">AsteroidsRenderer</code> classes.</p><div class="informalexample"><pre class="programlisting">private InputController ic;
private SoundManager sm;</pre></div><p>Initialize the new objects in the <code class="literal">onCreate</code> method of the <code class="literal">AsteroidsView</code> class and call the <code class="literal">loadSound</code> method like this:</p><div class="informalexample"><pre class="programlisting">public AsteroidsView(Context context, int screenX, int screenY) {
  super(context);

<span class="strong"><strong>     sm = new SoundManager();</strong></span>
<span class="strong"><strong>     sm.loadSound(context);</strong></span>
<span class="strong"><strong>     ic = new InputController(screenX, screenY);</strong></span>
     gm = new GameManager(screenX, screenY);</pre></div><p>Also in <code class="literal">AsteroidsView</code>, add an extra two arguments to the call to the <code class="literal">AsteroidsRenderer</code> constructor to pass in references to the <code class="literal">SoundManager</code> and <code class="literal">InputController</code> objects.</p><div class="informalexample"><pre class="programlisting">setEGLContextClientVersion(2);
<span class="strong"><strong>setRenderer(new AsteroidsRenderer(gm,sm,ic));</strong></span>
</pre></div><p>Now in the <code class="literal">AsteroidsRenderer</code> constructor add the two extra parameters and initialize the two new members like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>public AsteroidsRenderer(GameManager gameManager,</strong></span>
<span class="strong"><strong>  SoundManager soundManager, InputController inputController) {</strong></span>

        gm = gameManager;
<span class="strong"><strong>        sm = soundManager;</strong></span>
<span class="strong"><strong>        ic = inputController;</strong></span>

       handyPointF = new PointF();
       handyPointF2 = new PointF();

}</pre></div><p>You will have errors in your IDE until we add the two classes. We will do that now.</p><div class="section" title="Adding the SoundManager class"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec071"/>Adding the SoundManager class</h2></div></div></div><p>The <code class="literal">SoundManager</code> class <a class="indexterm" id="id00468"/>works exactly the same way as it did with the <a class="indexterm" id="id00469"/>previous project, so there is nothing new to explain here.</p><p>Add all the sound files from the download bundle <code class="literal">Chapter10/assets</code> folder to the assets folder of your project. As in the last two projects, you may need to create the assets folder in the <code class="literal">.../app/src/main</code> folder of your project.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0023"/>Tip</h3><p>As usual, you can use the sound effects provided or create your own.</p></div></div><p>Now, add a new class to the project called <code class="literal">SoundManager</code>. Note that the functionality of the class is identical to the last project, but the code is different simply because of the names of the sound files and their related variables. Add this code to the <code class="literal">SoundManager</code> class:</p><div class="informalexample"><pre class="programlisting">public class SoundManager {
    private SoundPool soundPool;
    private int shoot = -1;
    private int thrust = -1;
    private int explode = -1;
    private int shipexplode = -1;
    private int ricochet = -1;
    private int blip = -1;
    private int nextlevel = -1;
    private int gameover = -1;

    public void loadSound(Context context){
        soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);
        try{
            //Create objects of the 2 required classes
            AssetManager assetManager = context.getAssets();
            AssetFileDescriptor descriptor;

            //create our fx
            descriptor = assetManager.openFd("shoot.ogg");
            shoot = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("thrust.ogg");
            thrust = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("explode.ogg");
            explode = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("shipexplode.ogg");
            shipexplode = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("ricochet.ogg");
            ricochet = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("blip.ogg");
            blip = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("nextlevel.ogg");
            nextlevel = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("gameover.ogg");
            gameover = soundPool.load(descriptor, 0);

        }catch(IOException e){
            //Print an error message to the console
            Log.e("error", "failed to load sound files");
        }
    }

    public void playSound(String sound){
        switch (sound){
            case "shoot":
                soundPool.play(shoot, 1, 1, 0, 0, 1);
                break;

            case "thrust":
                soundPool.play(thrust, 1, 1, 0, 0, 1);
                break;

            case "explode":
                soundPool.play(explode, 1, 1, 0, 0, 1);
                break;

            case "shipexplode":
                soundPool.play(shipexplode, 1, 1, 0, 0, 1);
                break;

            case "ricochet":
                soundPool.play(ricochet, 1, 1, 0, 0, 1);
                break;

            case "blip":
                soundPool.play(blip, 1, 1, 0, 0, 1);
                break;

            case "nextlevel":
                soundPool.play(nextlevel, 1, 1, 0, 0, 1);
                break;

            case "gameover":
                soundPool.play(gameover, 1, 1, 0, 0, 1);
                break;


        }

    }
}</pre></div><p>We are now ready<a class="indexterm" id="id00470"/> to call <code class="literal">playSound()</code> from anywhere we have a reference to our <a class="indexterm" id="id00471"/>new class.</p></div><div class="section" title="Adding the InputController class"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec072"/>Adding the InputController class</h2></div></div></div><p>This works the same way <a class="indexterm" id="id00472"/>as it did in the last project, except that we call the <a class="indexterm" id="id00473"/>appropriate <code class="literal">PlayerShip</code> methods instead of Bob's. Furthermore, we will not be moving the viewport while paused, so it is not necessary to handle the screen touches differently when the game is paused; making this <code class="literal">InputController</code> a little simpler and shorter.</p><p>Add the <code class="literal">onTouchEvent</code> method to the <code class="literal">AsteroidsView</code> class to pass responsibility for handling touches to <code class="literal">InputController</code>:</p><div class="informalexample"><pre class="programlisting">@Override
    public boolean onTouchEvent(MotionEvent motionEvent) {
        ic.handleInput(motionEvent, gm, sm);
        return true;
    }</pre></div><p>Add a new class called <code class="literal">InputController</code>, and add the following code which is straightforward, except for the way that we handle the player firing a shot.</p><p>We declare a member <code class="literal">int currentBullet</code> that keeps track of which bullet from our soon-to-be-declared array we are going to shoot next. Then, we can count the bullets out when the fire button is pressed and go back to the first bullet, right after the last one in the array is fired.</p><p>Create a <a class="indexterm" id="id00474"/>new class called <code class="literal">InputController</code> and enter the<a class="indexterm" id="id00475"/> following code:</p><div class="informalexample"><pre class="programlisting">public class InputController {

    private int currentBullet;

    Rect left;
    Rect right;
    Rect thrust;
    Rect shoot;
    Rect pause;

    InputController(int screenWidth, int screenHeight) {

        //Configure the player buttons
        int buttonWidth = screenWidth / 8;
        int buttonHeight = screenHeight / 7;
        int buttonPadding = screenWidth / 80;

        left = new Rect(buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            buttonWidth,
            screenHeight - buttonPadding);

        right = new Rect(buttonWidth + buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            buttonWidth + buttonPadding + buttonWidth,
            screenHeight - buttonPadding);

        thrust = new Rect(screenWidth - buttonWidth - 
            buttonPadding,
            screenHeight - buttonHeight - buttonPadding - 
            buttonHeight - buttonPadding,
            screenWidth - buttonPadding,
            screenHeight - buttonPadding - buttonHeight - 
            buttonPadding);

        shoot = new Rect(screenWidth - buttonWidth - 
            buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            screenWidth - buttonPadding,
            screenHeight - buttonPadding);

        pause = new Rect(screenWidth - buttonPadding - 
            buttonWidth,
            buttonPadding,
            screenWidth - buttonPadding,
            buttonPadding + buttonHeight);</pre></div><p>Let's bundle all our<a class="indexterm" id="id00476"/> buttons together in a list and make them available <a class="indexterm" id="id00477"/>with a public method.</p><div class="informalexample"><pre class="programlisting">    }    
    public ArrayList getButtons(){
   
        //create an array of buttons for the draw method
        ArrayList&lt;Rect&gt; currentButtonList = new ArrayList&lt;&gt;();
        currentButtonList.add(left);
        currentButtonList.add(right);
        currentButtonList.add(thrust);
        currentButtonList.add(shoot);
        currentButtonList.add(pause);
        return  currentButtonList;
    }</pre></div><p>Next, we handle the input as we have before, except we call our <code class="literal">Ship</code> class's methods.</p><div class="informalexample"><pre class="programlisting">public void handleInput(MotionEvent motionEvent,GameManager l,                                      
  SoundManager sound){
        
        int pointerCount = motionEvent.getPointerCount();

        for (int i = 0; i &lt; pointerCount; i++) {
        int x = (int) motionEvent.getX(i);
        int y = (int) motionEvent.getY(i);

          switch (motionEvent.getAction() &amp; 
             MotionEvent.ACTION_MASK) {

            case MotionEvent.ACTION_DOWN:
                    if (right.contains(x, y)) {
                    l.ship.setPressingRight(true);
                    l.ship.setPressingLeft(false);
                 } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(true);
                    l.ship.setPressingRight(false);
                    } else if (thrust.contains(x, y)) {
                    l.ship.toggleThrust();
                    } else if (shoot.contains(x, y)) {
                        if (l.ship.pullTrigger()) {
                        l.bullets[currentBullet].shoot
                                (l.ship.getFacingAngle());
                        
                            currentBullet++;
                       // If we are on the last bullet restart
                       // from the first one again
                       if(currentBullet == l.numBullets){
                            currentBullet = 0;
                        }
                       
                           sound.playSound("shoot");
                    }
                        
                    } else if (pause.contains(x, y)) {
                    l.switchPlayingStatus();
                    }
                    break;

            case MotionEvent.ACTION_UP:
            if (right.contains(x, y)) {
                    l.ship.setPressingRight(false);
                } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(false);
                }

                break;


            case MotionEvent.ACTION_POINTER_DOWN:
            if (right.contains(x, y)) {
                    l.ship.setPressingRight(true);
                    l.ship.setPressingLeft(false);
                } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(true);
                 l.ship.setPressingRight(false);
                } else if (thrust.contains(x, y)) {
                    l.ship.toggleThrust();
                } else if (shoot.contains(x, y)) {
                    if (l.ship.pullTrigger()) {
                    l.bullets[currentBullet].shoot
                            (l.ship.getFacingAngle());
                                
                        currentBullet++;
                    // If we are on the last bullet restart
                    // from the first one again
                    if(currentBullet == l.numBullets){
                        currentBullet = 0;
                    }
                    sound.playSound("shoot");
                    }
                } else if (pause.contains(x, y)) {
                    l.switchPlayingStatus();
                }
                break;


            case MotionEvent.ACTION_POINTER_UP:
            if (right.contains(x, y)) {
                    l.ship.setPressingRight(false);
                } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(false);
                }
                
                break;
            }
         }

    }
}</pre></div><p>Now, we can fly <a class="indexterm" id="id00478"/>around and loose off a few space rounds! Of course, you<a class="indexterm" id="id00479"/> will have to estimate the screen positions until we get our HUD drawn later in this chapter. Don't forget that the player needs to tap the pause button (top-right) first.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0032"/>Note</h3><p>Note that at the moment, we don't use the <code class="literal">resetBullet</code> method, and that once you have shot your twenty bullets, you will not be able to shoot any more. We can do a quick check to see if the bullet was at a location outside the border and then call <code class="literal">resetBullet</code>, but we will handle this fully, in conjunction with all the collision detection, in the next chapter.</p></div></div><p>Of course, we can't have an asteroids game without any asteroids.</p></div></div>
<div class="section" title="Drawing and moving the asteroids"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec060"/>Drawing and moving the asteroids</h1></div></div></div><p>At last, we will add<a class="indexterm" id="id00480"/> our cool, spinning asteroids. First, we will look at the constructor<a class="indexterm" id="id00481"/> that is fairly similar to the other game object constructors, except that we set the world location randomly. However, take a little extra care not to spawn them in the center of the map, where the spaceship starts the game.</p><p>Create a new class called <code class="literal">Asteroid</code> and add this constructor. Note that we have not defined any vertices. We delegate this to the <code class="literal">generatePoints</code> method that we will see soon.</p><div class="informalexample"><pre class="programlisting">public class Asteroid extends GameObject{

    PointF[] points;

    public Asteroid(int levelNumber, int mapWidth, int mapHeight){
        super();

        // set a random rotation rate in degrees per second
        Random r = new Random();
        setRotationRate(r.nextInt(50 * levelNumber) + 10);

        // travel at any random angle
        setTravellingAngle(r.nextInt(360));

        // Spawn asteroids between 50 and 550 on x and y
        // And avoid the extreme edges of map
        int x = r.nextInt(mapWidth - 100)+50;
        int y = r.nextInt(mapHeight - 100)+50;

        // Avoid the center where the player spawns
        if(x &gt; 250 &amp;&amp; x &lt; 350){ x = x + 100;}
        if(y &gt; 250 &amp;&amp; y &lt; 350){ y = y + 100;}

        // Set the location
        setWorldLocation(x,y);

        // Make them a random speed with the maximum
        // being appropriate to the level number
        setSpeed(r.nextInt(25 * levelNumber)+1);

        setMaxSpeed(140);

        // Cap the speed
        if (getSpeed() &gt; getMaxSpeed()){
            setSpeed(getMaxSpeed());
        }

        // Make sure we know this object is a ship
        setType(Type.ASTEROID);

        // Define a random asteroid shape
        // Then call the parent setVertices()
        generatePoints();

        
    }</pre></div><p>Our update method <a class="indexterm" id="id00482"/>simply calculates the velocity based on speed and traveling angle <a class="indexterm" id="id00483"/>as we did for the <code class="literal">SpaceShip</code> class. It then calls <code class="literal">move()</code> in the usual way.</p><div class="informalexample"><pre class="programlisting">public void update(float fps){

  setxVelocity ((float) (getSpeed() * Math.cos(Math.toRadians  (getTravellingAngle() + 90))));
        
  setyVelocity ((float) (getSpeed() * Math.sin(Math.toRadians(getTravellingAngle() + 90))));

     move(fps);

}</pre></div><p>Here we see the <code class="literal">generatePoints</code> method, which will create a randomly shaped asteroid. Simply explained, each asteroid will have six vertices. Each vertex has a randomly generated position but within fairly strict limits, so we don't get any overlapping lines.</p><div class="informalexample"><pre class="programlisting">// Create a random asteroid shape
public void generatePoints(){
  points = new PointF[7];

   Random r = new Random();
   int i;

     // First a point roughly centre below 0
     points[0] = new PointF();
     i = (r.nextInt(10))+1;
     if(i % 2 == 0){i = -i;}
     points[0].x = i;
     i = -(r.nextInt(20)+5);
     points[0].y = i;

     // Now a point still below centre but to the right and up a bit
     points[1] = new PointF();
     i = r.nextInt(14)+11;
     points[1].x = i;
     i = -(r.nextInt(12)+1);
     points[1].y =  i;

     // Above 0 to the right
     points[2] = new PointF();
     i = r.nextInt(14)+11;
     points[1].x = i;
     i = r.nextInt(12)+1;
     points[2].y = i;

     // A point roughly centre above 0
     points[3] = new PointF();
     i = (r.nextInt(10))+1;
     if(i % 2 == 0){i = -i;}
     points[3].x = i;
     i = r.nextInt(20)+5;
     points[3].y =  i;

     // left above 0
     points[4] = new PointF();
     i = -(r.nextInt(14)+11);
     points[4].x = i;
     i = r.nextInt(12)+1;
     points[4].y = i ;

     // left below 0
     points[5] = new PointF();
     i = -(r.nextInt(14)+11);
     points[5].x =  i;
     i = -(r.nextInt(12)+1);

     points[5].y = i;</pre></div><p>Now, we have our six <a class="indexterm" id="id00484"/>points that we use to build our array of floats that represent the <a class="indexterm" id="id00485"/>vertices. Finally, we call <code class="literal">setVertices()</code> to create our <code class="literal">ByteBuffer</code>. Note that the asteroids will be drawn as a series of lines, which is why the last vertex in the array is the same as the first.</p><div class="informalexample"><pre class="programlisting">  // Now use these points to draw our asteroid
  float[] asteroidVertices = new float[]{
     // First point to second point
     points[0].x, points[0].y, 0,
     points[1].x, points[1].y, 0,

     // 2nd to 3rd
     points[1].x, points[1].y, 0,
     points[2].x, points[2].y, 0,

     // 3 to 4
     points[2].x, points[2].y, 0,
     points[3].x, points[3].y, 0,

     // 4 to 5
     points[3].x, points[3].y, 0,
     points[4].x, points[4].y, 0,

     // 5 to 6
     points[4].x, points[4].y, 0,
     points[5].x, points[5].y, 0,

     // 6 back to 1
     points[5].x, points[5].y, 0,
     points[0].x, points[0].y, 0,
};

setVertices(asteroidVertices);

}// End method

}// End class</pre></div><p>Now as you have<a class="indexterm" id="id00486"/> probably come to expect, we add an array to <code class="literal">GameManager</code> to hold all <a class="indexterm" id="id00487"/>our asteroids. At the same time, we will declare some variables which will hold the level the player is currently on, as well as the starting (base) number of asteroids. Then soon, when we initialize all our asteroids, we will see how we will determine the number of asteroids that will need to be destroyed to clear a level.</p><div class="informalexample"><pre class="programlisting">Asteroid [] asteroids;
int numAsteroids;
int numAsteroidsRemaining;
int baseNumAsteroids = 10;
int levelNumber = 1;</pre></div><p>Initialize the array in the <code class="literal">GameManager</code> constructor:</p><div class="informalexample"><pre class="programlisting">// For all our asteroids
asteroids = new Asteroid[500];</pre></div><p>Initialize the objects<a class="indexterm" id="id00488"/> themselves in the <code class="literal">createObjects</code> method using our previously <a class="indexterm" id="id00489"/>declared variables to determine the number of asteroids based on the current level.</p><div class="informalexample"><pre class="programlisting">// Determine the number of asteroids
gm.numAsteroids = gm.baseNumAsteroids * gm.levelNumber;
// Set how many asteroids need to be destroyed by player
gm.numAsteroidsRemaining = gm.numAsteroids;
// Spawn the asteroids

for (int i = 0; i &lt; gm.numAsteroids * gm.levelNumber; i++) {
     // Create a new asteroid
     // Pass in level number so they can be made
     // appropriately dangerous.
     gm.asteroids[i] = new Asteroid
      (gm.levelNumber, gm.mapWidth, gm.mapHeight);

}</pre></div><p>Update them in the <code class="literal">update</code> method.</p><div class="informalexample"><pre class="programlisting">// Update all the asteroids
for (int i = 0; i &lt; gm.numAsteroids; i++) {
  if (gm.asteroids[i].isActive()) {
    gm.asteroids[i].update(fps);
  }
}</pre></div><p>Finally, we can draw all our asteroids in the <code class="literal">draw</code> method.</p><div class="informalexample"><pre class="programlisting">// The bullets
for (int i = 0; i &lt; gm.numBullets; i++) {
  gm.bullets[i].draw(viewportMatrix);
}

<span class="strong"><strong>for (int i = 0; i &lt; gm.numAsteroids; i++) {</strong></span>
<span class="strong"><strong>  if (gm.asteroids[i].isActive()) {</strong></span>
<span class="strong"><strong>       gm.asteroids[i].draw(viewportMatrix);</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Now, run the game and check out those smooth, 60+ FPS, spinning asteroids.</p><div class="mediaobject"><img alt="Drawing and moving the asteroids" src="graphics/B043422_10_03.jpg"/></div><p>Now, we need to<a class="indexterm" id="id00490"/> make it easy to control the ship by adding button graphics, as well as<a class="indexterm" id="id00491"/> some other overlay information, with a HUD.</p></div>
<div class="section" title="Scores and the HUD"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec061"/>Scores and the HUD</h1></div></div></div><p>The HUD objects<a class="indexterm" id="id00492"/> will never be rotated. In addition, they are defined in the <code class="literal">InputController</code> class based <a class="indexterm" id="id00493"/>on screen coordinates, not the game world or even Open GL coordinates. Therefore, our <code class="literal">GameObject</code> class is not a suitable parent class.</p><p>For the sake of simplicity, each of the three HUD classes will have their own <code class="literal">draw</code> method. We will see how we draw them at a consistent size and screen position using a new viewport matrix.</p><p>Once we have created all three of our HUD classes, we will add all of the object declarations, initializations, and drawing code.</p><div class="section" title="Adding control buttons"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec073"/>Adding control buttons</h2></div></div></div><p>The first <a class="indexterm" id="id00494"/>HUD object we will make<a class="indexterm" id="id00495"/> a class for, is a simple button.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0033"/>Note</h3><p>I am showing all the imports explicitly, as they do not get imported automatically. Note that the next two classes will need these as well. The code is all in the download bundle as usual, if you wish to just copy and paste it.</p></div></div><p>Create a new class and call it <code class="literal">GameButton</code>, then add the following import statements. Be sure to state the correct <a class="indexterm" id="id00496"/>package name based on which chapter's <a class="indexterm" id="id00497"/>code you are using or the name you gave your project.</p><div class="informalexample"><pre class="programlisting">import android.graphics.PointF;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import static android.opengl.GLES20.GL_FLOAT;
import static android.opengl.GLES20.GL_LINES;
import static android.opengl.GLES20.glDrawArrays;
import static android.opengl.GLES20.glEnableVertexAttribArray;
import static android.opengl.GLES20.glGetAttribLocation;
import static android.opengl.GLES20.glGetUniformLocation;
import static android.opengl.GLES20.glUniform4f;
import static android.opengl.GLES20.glUniformMatrix4fv;
import static android.opengl.GLES20.glUseProgram;
import static android.opengl.Matrix.orthoM;
import static android.opengl.GLES20.glVertexAttribPointer;
import static com.gamecodeschool.c10asteroids.GLManager.A_POSITION;
import static com.gamecodeschool.c10asteroids.GLManager.COMPONENTS_PER_VERTEX;
import static com.gamecodeschool.c10asteroids.GLManager.FLOAT_SIZE;
import static com.gamecodeschool.c10asteroids.GLManager.STRIDE;
import static com.gamecodeschool.c10asteroids.GLManager.U_COLOR;
import static com.gamecodeschool.c10asteroids.GLManager.U_MATRIX;</pre></div><p>First, we declare some members; <code class="literal">viewportMatrix</code> into which we will put our new matrix for the viewport transformation from the <code class="literal">InputController</code> class's screen based coordinates—An int <code class="literal">glprogram</code> value, an <code class="literal">int numVertices</code> value, and a <code class="literal">FloatBuffer</code> class.</p><div class="informalexample"><pre class="programlisting">public class GameButton {

    // For button coordinate
    // into a GL space coordinate (-1,-1 to 1,1)
    // for drawing on the screen
    private final float[] viewportMatrix = new float[16];

    // A handle to the GL glProgram -
    // the compiled and linked shaders
    private static int glProgram;

    // How many vertices does it take to make
    // our button
    private int numVertices;

    // This will hold our vertex data that is
    // passed into openGL glProgram
    private FloatBuffer vertices;</pre></div><p>The first thing we do in the <a class="indexterm" id="id00498"/>constructor is make our viewport matrix by<a class="indexterm" id="id00499"/> calling <code class="literal">orthoM()</code> with the screen height and width as <code class="literal">0,0</code>. This makes OpenGL map a coordinate range that is identical to the device resolution over the top of the OpenGL coordinate range.</p><p>We then get the coordinates of the passed in button and shrink it down to make it smaller. Then, we initialize a vertex array as four lines to represent a button. Clearly, we will need to create a new button object to represent each and every button from our <code class="literal">InputController</code> class.</p><div class="informalexample"><pre class="programlisting">public GameButton(int top, int left, 
    int bottom, int right, GameManager gm){

    //The HUD needs its own viewport
    // notice we set the screen height in pixels as the
    // starting y coordinates because
    // OpenGL is upside down world :-)
    orthoM(viewportMatrix, 0, 0, 
        gm.screenWidth, gm.screenHeight, 0, 0, 1f);

        // Shrink the button visuals to make
        // them less obtrusive while leaving
        // the screen area they represent the same.
        int width = (right - left) / 2;
        int height = (top - bottom) / 2;
        left = left + width / 2;
        right = right - width / 2;
        top = top - height / 2;
        bottom = bottom + height / 2;

        PointF p1 = new PointF();
        p1.x = left;
        p1.y = top;

        PointF p2 = new PointF();
        p2.x = right;
        p2.y = top;

        PointF p3 = new PointF();
        p3.x = right;
        p3.y = bottom;

        PointF p4 = new PointF();
        p4.x = left;
        p4.y = bottom;

        // Add the four points to an array of vertices
        // This time, because we don't need to animate the border
        // we can just declare the world space coordinates, the
        // same as above.
        float[] modelVertices = new float[]{
                // A line from point 1 to point 2
                p1.x, p1.y, 0,
                p2.x, p2.y, 0,
                // Point 2 to point 3
                p2.x, p2.y, 0,
                p3.x, p3.y, 0,
                // Point 3 to point 4
                p3.x, p3.y, 0,
                p4.x, p4.y, 0,
                // Point 4 to point 1
                p4.x, p4.y, 0,
                p1.x, p1.y, 0
        };</pre></div><p>Now, we duplicate a little <a class="indexterm" id="id00500"/>of the code from <code class="literal">GameObject</code> to prepare <code class="literal">ByteBuffer</code>, but<a class="indexterm" id="id00501"/> still we use our static <code class="literal">GLManager.getGLProgram()</code> to get a handle to a GL program.</p><div class="informalexample"><pre class="programlisting">       // Store how many vertices and 
       // elements there is for future use
       final int ELEMENTS_PER_VERTEX = 3;// x,y,z
       int numElements = modelVertices.length;
       numVertices = numElements/ELEMENTS_PER_VERTEX;

       // Initialize the vertices ByteBuffer object based on the
       // number of vertices in the button and the number of
       // bytes there are in the float type
       vertices = ByteBuffer.allocateDirect(
                numElements
                * FLOAT_SIZE)
                .order(ByteOrder.nativeOrder()).asFloatBuffer();

       // Add the button into the ByteBuffer object
       vertices.put(modelVertices);

       glProgram = GLManager.getGLProgram();

}</pre></div><p>Finally, we implement<a class="indexterm" id="id00502"/> the <code class="literal">draw</code> method, which is a simplified <a class="indexterm" id="id00503"/>version of the <code class="literal">draw</code> method from <code class="literal">GameObject</code>. Note that we don't need to mess around with model, translation, and rotation matrices, and also that we pass a different color to the fragment shader.</p><div class="informalexample"><pre class="programlisting">public void draw(){

    // And tell OpenGl to use the glProgram
    glUseProgram(glProgram);

    // Now we have a glProgram we need the locations
    // of our three GLSL variables
    int uMatrixLocation = glGetUniformLocation(glProgram, U_MATRIX);
    
    int aPositionLocation = 
        glGetAttribLocation(glProgram, A_POSITION);
        
    int uColorLocation = glGetUniformLocation(glProgram, U_COLOR);

    vertices.position(0);

    glVertexAttribPointer(
        aPositionLocation,
        COMPONENTS_PER_VERTEX,
        GL_FLOAT,
        false,
        STRIDE,
        vertices);

    glEnableVertexAttribArray(aPositionLocation);

    // give the new matrix to OpenGL
    glUniformMatrix4fv(uMatrixLocation, 1, false, viewportMatrix, 0);
    
    // Assign a different color to the fragment shader
    glUniform4f(uColorLocation, 0.0f, 0.0f, 1.0f, 1.0f);
      
    // Draw the lines
    // start at the first element of the
    // vertices array and read in all vertices
    glDrawArrays(GL_LINES, 0, numVertices);
    
}
}// End class</pre></div></div><div class="section" title="Tally icons"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec074"/>Tally icons</h2></div></div></div><p>This class is the same as <code class="literal">GameButton</code>, except that a tally icon will be a single straight vertical line; therefore, we only need two vertices.</p><p>However, note that we have a<a class="indexterm" id="id00504"/> parameter in the constructor called <code class="literal">nthIcon</code>. It will<a class="indexterm" id="id00505"/> be the responsibility of the calling code to let <code class="literal">TallyIcon</code> know the total quantity of already created <code class="literal">TallyIcon</code> objects, plus one. Then, the current <code class="literal">TallyIcon</code> object can use the padding variable to position itself appropriately.</p><p>Create a new class called <code class="literal">TallyIcon</code> and enter the following code. As we have, previously, include the static imports as required. Here is the code for all the declarations and the constructor:</p><div class="informalexample"><pre class="programlisting">public class TallyIcon {

    // For button coordinate
    // into a GL space coordinate (-1,-1 to 1,1)
    // for drawing on the screen
    private final float[] viewportMatrix = new float[16];

    // A handle to the GL glProgram -
    // the compiled and linked shaders
    private static int glProgram;

    // How many vertices does it take to make
    // our button
    private int numVertices;

    // This will hold our vertex data that is
    // passed into openGL glProgram
    //private final FloatBuffer vertices;
    private FloatBuffer vertices;

    public TallyIcon(GameManager gm, int nthIcon){

        // The HUD needs its own viewport
        // notice we set the screen height in pixels as the
        // starting y coordinates because
        // OpenGL is upside down world :-)
        orthoM(viewportMatrix, 0, 0,
          gm.screenWidth, gm.screenHeight, 0, 0f, 1f);

        float padding = gm.screenWidth / 160;
        float iconHeight = gm.screenHeight / 15;
        float iconWidth = 1; // square icons
        float startX = 10 + (padding + iconWidth)* nthIcon;
        float startY = iconHeight * 2 + padding;

        PointF p1 = new PointF();
        p1.x = startX;
        p1.y = startY;

        PointF p2 = new PointF();
        p2.x = startX;
        p2.y = startY - iconHeight;

        // Add the four points to an array of vertices
        // This time, because we don't need to animate the border
        // we can just declare the world space coordinates, the
        // same as above.
        float[] modelVertices = new float[]{
                // A line from point 1 to point 2
                p1.x, p1.y, 0,
                p2.x, p2.y, 0,


        };


        // Store how many vertices and 
        //elements there is for future use
        final int ELEMENTS_PER_VERTEX = 3;// x,y,z
        int numElements = modelVertices.length;
        numVertices = numElements/ELEMENTS_PER_VERTEX;

        // Initialize the vertices ByteBuffer object based on the
        // number of vertices in the button and the number of
        // bytes there are in the float type
        vertices = ByteBuffer.allocateDirect(
                numElements
                * FLOAT_SIZE)
                .order(ByteOrder.nativeOrder()).asFloatBuffer();

        // Add the button into the ByteBuffer object
        vertices.put(modelVertices);

        glProgram = GLManager.getGLProgram();
    }</pre></div><p>This is the draw method<a class="indexterm" id="id00506"/> which is <a class="indexterm" id="id00507"/>probably looking quite familiar by now.</p><div class="informalexample"><pre class="programlisting">    public void draw(){

        // And tell OpenGl to use the glProgram
        glUseProgram(glProgram);

        // Now we have a glProgram we need the locations
        // of our three GLSL variables
        int uMatrixLocation = 
        glGetUniformLocation(glProgram, U_MATRIX);

        int aPositionLocation = 
        glGetAttribLocation(glProgram, A_POSITION);

        int uColorLocation = 
        glGetUniformLocation(glProgram, U_COLOR);

        vertices.position(0);

        glVertexAttribPointer(
                aPositionLocation,
                COMPONENTS_PER_VERTEX,
                GL_FLOAT,
                false,
                STRIDE,
                vertices);

        glEnableVertexAttribArray(aPositionLocation);

        // Just give the passed in matrix to OpenGL
        glUniformMatrix4fv(uMatrixLocation, 1, 
          false, viewportMatrix, 0);

        // Assign a color to the fragment shader
        glUniform4f(uColorLocation, 1.0f, 1.0f, 0.0f, 1.0f);

        // Draw the lines
        // start at the first element of the vertices array and read in all vertices
        glDrawArrays(GL_LINES, 0, numVertices);
    }</pre></div><p>Now for the final <a class="indexterm" id="id00508"/>HUD <a class="indexterm" id="id00509"/>element.</p></div><div class="section" title="Life icons"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec075"/>Life icons</h2></div></div></div><p>Our last icon will be a kind of mini-ship to<a class="indexterm" id="id00510"/> indicate how many lives the player has<a class="indexterm" id="id00511"/> remaining.</p><p>We will construct a triangle shape out of lines to create a nice hollow effect. Note that the <code class="literal">LifeIcon</code> constructor also uses an <code class="literal">nthIcon</code> element to control the padding and on screen position.</p><p>Create a new class called <code class="literal">LifeIcon</code> and enter the following code, remembering all the imports that will not auto-import. Here are the declarations and the constructor:</p><div class="informalexample"><pre class="programlisting">public class LifeIcon {

     // Remember the static import for GLManager

     // For button coordinate
     // into a GL space coordinate (-1,-1 to 1,1)
     // for drawing on the screen
     private final float[] viewportMatrix = new float[16];

     // A handle to the GL glProgram -
     // the compiled and linked shaders
     private static int glProgram;

     // Each of the above constants also has a matching int
     // which will represent its location in the open GL glProgram
     // In GameButton they are declared as local variables

     // How many vertices does it take to make
     // our button
     private int numVertices;

     // This will hold our vertex data that is
     // passed into openGL glProgram
     //private final FloatBuffer vertices;
     private FloatBuffer vertices;

     public LifeIcon(GameManager gm, int nthIcon){

     // The HUD needs its own viewport
     // notice we set the screen height in pixels as the
     // starting y coordinates because
     // OpenGL is upside down world :-)
     orthoM(viewportMatrix, 0, 0,
       gm.screenWidth, gm.screenHeight, 0, 0f, 1f);

     float padding = gm.screenWidth / 160;
     float iconHeight = gm.screenHeight / 15;
     float iconWidth = gm.screenWidth / 30;
     float startX = 10 + (padding + iconWidth)* nthIcon;
     float startY = iconHeight;

     PointF p1 = new PointF();
     p1.x = startX;
     p1.y = startY;

     PointF p2 = new PointF();
     p2.x = startX + iconWidth;
     p2.y = startY;

     PointF p3 = new PointF();
     p3.x = startX + iconWidth/2;
     p3.y = startY - iconHeight;


     // Add the four points to an array of vertices
     // This time, because we don't need to animate the border
     // we can just declare the world space coordinates, the
     // same as above.
     float[] modelVertices = new float[]{
               // A line from point 1 to point 2
               p1.x, p1.y, 0,
               p2.x, p2.y, 0,
               // Point 2 to point 3
               p2.x, p2.y, 0,
               p3.x, p3.y, 0,
               // Point 3 to point 1
               p3.x, p3.y, 0,
               p1.x, p1.y, 0,

  };

     // Store how many vertices and elements there is for future 
     // use
     final int ELEMENTS_PER_VERTEX = 3;// x,y,z
     int numElements = modelVertices.length;
     numVertices = numElements/ELEMENTS_PER_VERTEX;

     // Initialize the vertices ByteBuffer object based on the
     // number of vertices in the button and the number of
     // bytes there are in the float type
     vertices = ByteBuffer.allocateDirect(
              numElements
              * FLOAT_SIZE)
              .order(ByteOrder.nativeOrder()).asFloatBuffer();

     // Add the button into the ByteBuffer object
     vertices.put(modelVertices);

       glProgram = GLManager.getGLProgram();
     }</pre></div><p>Here is the <code class="literal">draw</code> method<a class="indexterm" id="id00512"/> of <a class="indexterm" id="id00513"/>the <code class="literal">LifeIcon</code> class:</p><div class="informalexample"><pre class="programlisting">    public void draw(){

            // And tell OpenGl to use the glProgram
            glUseProgram(glProgram);

            // Now we have a glProgram we need the locations
            // of our three GLSL variables
            int uMatrixLocation = glGetUniformLocation 
              (glProgram, U_MATRIX);
            int aPositionLocation = glGetAttribLocation 
              (glProgram, A_POSITION);
            int uColorLocation = glGetUniformLocation 
               (glProgram, U_COLOR);

            vertices.position(0);

            glVertexAttribPointer(
                    aPositionLocation,
                    COMPONENTS_PER_VERTEX,
                    GL_FLOAT,
                    false,
                    STRIDE,
                    vertices);

            glEnableVertexAttribArray(aPositionLocation);

            // Just give the passed in matrix to OpenGL
            glUniformMatrix4fv(uMatrixLocation, 1, 
              false, viewportMatrix, 0);
            // Assign a color to the fragment shader
            glUniform4f(uColorLocation, 1.0f, 
              1.0f, 0.0f, 1.0f);
            // Draw the lines
            // start at the first element of 
            // the vertices array and read in all vertices
            glDrawArrays(GL_LINES, 0, numVertices);
        }

}</pre></div><p>We have our three <a class="indexterm" id="id00514"/>HUD <a class="indexterm" id="id00515"/>classes, and we can draw them to the screen.</p><div class="section" title="Declaring, initializing, and drawing the HUD objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec033"/>Declaring, initializing, and drawing the HUD objects</h3></div></div></div><p>We will declare, initialize, and draw our HUD objects just like all the <code class="literal">GameObject</code> classes. However, note <a class="indexterm" id="id00516"/>that, as expected, we don't pass a viewport matrix to the <code class="literal">draw</code> <a class="indexterm" id="id00517"/>method because the HUD classes provide their<a class="indexterm" id="id00518"/> own.</p><p>Add these members to <code class="literal">GameManager</code>:</p><div class="informalexample"><pre class="programlisting">TallyIcon[] tallyIcons;
int numLives = 3;
LifeIcon[] lifeIcons;</pre></div><p>As we did with the <code class="literal">asteroids</code> array, initialize <code class="literal">tallyIcons</code> and <code class="literal">lifeIcons</code> in the <code class="literal">GameManager</code> constructor:</p><div class="informalexample"><pre class="programlisting">lifeIcons = new LifeIcon[50];
tallyIcons = new TallyIcon[500];</pre></div><p>Add a new<a class="indexterm" id="id00519"/> member array to the <code class="literal">AsteroidsRenderer</code> class:</p><div class="informalexample"><pre class="programlisting">// This will hold our game buttons
private final GameButton[] gameButtons = new GameButton[5];</pre></div><p>Add this code to create<a class="indexterm" id="id00520"/> objects of all our new HUD classes. Add it to the <code class="literal">createObjects</code> method <a class="indexterm" id="id00521"/>just before the closing curly brace:</p><div class="informalexample"><pre class="programlisting">// Now for the HUD objects
// First the life icons
for(int i = 0; i &lt; gm.numLives; i++) {
    // Notice we send in which icon this represents
    // from left to right so padding and positioning is correct.
    gm.lifeIcons[i] = new LifeIcon(gm, i);
}

// Now the tally icons (1 at the start)
for(int i = 0; i &lt; gm.numAsteroidsRemaining; i++) {
    // Notice we send in which icon this represents
    // from left to right so padding and positioning is correct.
    gm.tallyIcons[i] = new TallyIcon(gm, i);
}

// Now the buttons
ArrayList&lt;Rect&gt; buttonsToDraw = ic.getButtons();
int i = 0;
for (Rect rect : buttonsToDraw) {
    gameButtons[i] = new GameButton(rect.top, rect.left, 
        rect.bottom, rect.right, gm);
    
    i++;
        
}</pre></div><p>Now we can draw our HUD based on the number of lives remaining and the number of asteroids left before the next level. Add this code to the end of the <code class="literal">draw</code> method:</p><div class="informalexample"><pre class="programlisting">// the buttons
for (int i = 0; i &lt; gameButtons.length; i++) {
  gameButtons[i].draw();
}

// Draw the life icons
for(int i = 0; i &lt; gm.numLives; i++) {
     // Notice we send in which icon this represents
     // from left to right so padding and positioning is correct.
     gm.lifeIcons[i].draw();
}

// Draw the level icons
for(int i = 0; i &lt; gm.numAsteroidsRemaining; i++) {
  // Notice we send in which icon this represents
  // from left to right so padding and positioning is correct.
  gm.tallyIcons[i].draw();
}</pre></div><p>You can now fly <a class="indexterm" id="id00522"/>around <a class="indexterm" id="id00523"/>and admire your new <a class="indexterm" id="id00524"/>HUD.</p><div class="mediaobject"><img alt="Declaring, initializing, and drawing the HUD objects" src="graphics/B043422_10_04.jpg"/></div><p>Obviously, if we are going to make any use of our lives and asteroid tally indicators, then we first need to be able to shoot asteroids as well as detect them when the ship gets hit.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec062"/>Summary</h1></div></div></div><p>We achieved lots in this chapter, and indeed it would be simple to quickly add more game objects. Perhaps, an occasional UFO like in the original arcade classic.</p><p>In the next chapter we will use what we learned in previous projects to set up collision detection and finish off the game. However, a game with precise, clean, smooth moving lines deserves much more accurate collision detection than we used so far.</p><p>So, we will concentrate solely on implementing precise, efficient collision detection that will make our Asteroids simulator complete.</p></div>
<div class="chapter" title="Chapter&#xA0;11.&#xA0;Things That Go Bump &#x2013; Part II"><div class="titlepage"><div><div><h1 class="title"><a id="ch20"/>Chapter 11. Things That Go Bump – Part II</h1></div></div></div><p>The collision detection in this game is much more complex than the previous two. For this reason, the code will be quite heavily commented. Sometimes the comments will explain things in a bit more detail or in a slightly different way.</p><p>However, that doesn't mean it needs to be hard work. What we need to do is take a moment to consider a strategy that will work for us.</p><p>Hopefully, this approach will mean that by the end of the chapter, our collision detection solutions will appear straightforward.</p><div class="section" title="Planning for collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec063"/>Planning for collision detection</h1></div></div></div><p>What we are trying to achieve<a class="indexterm" id="id00525"/> can be put into the following two categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What we want for the border:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Asteroids, bullets, and the ship need to know when they have collided with the border</li><li class="listitem" style="list-style-type: disc">Asteroids should reverse and head back into the game area when they touch the border</li><li class="listitem" style="list-style-type: disc">A bullet should reset itself at the border</li><li class="listitem" style="list-style-type: disc">The ship should subtract a life and then respawn in the centre</li></ul></div></li><li class="listitem" style="list-style-type: disc">What we want for the asteroids. We need to know and respond when:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ship touches an asteroid </li><li class="listitem" style="list-style-type: disc">When a bullet touches an asteroid</li><li class="listitem" style="list-style-type: disc">As in the original Asteroids game, we will not respond to asteroids bumping into each other</li></ul></div></li></ul></div><p>Although we will not be detecting an asteroid on asteroid collisions, you will see that when our collision detection nears completion, achieving asteroid on asteroid collision detection will not present much of an extra challenge. However, it will put extra strain on the device's CPU.</p><p>We know that <a class="indexterm" id="id00526"/>we have object on border collisions to detect and object on asteroid collisions to detect.</p><div class="section" title="Colliding with the border"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec076"/>Colliding with the border</h2></div></div></div><p>It may sound obvious, but the border is simply four static straight lines. This makes a border collision<a class="indexterm" id="id00527"/> a different problem to an asteroid collision.</p><p>All of the objects that we are interested in have vertices (or one vertex in the case of a bullet). This may at first suggest that we can simply compute the world location of each vertex from the model space and the centre of the object stored in <code class="literal">worldLocation</code>. We can, but this overlooks the fact that the asteroids and the ship rotate, which constantly causes a variation in the actual world locations of all the vertices.</p><p>We will need to translate and rotate the model space vertices, and then test if any of them have touched the border. We can do this in the object's <code class="literal">update</code> method for each frame, but we only need the rotated coordinates occasionally, when the object is very close to the border.</p><div class="section" title="The first phase of border collision detection"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec034"/>The first phase of border collision detection</h3></div></div></div><p>This suggests that a preliminary <a class="indexterm" id="id00528"/>check, a first phase of collision detection, is more efficient. It implies that the translation and rotation of the vertices will need to take place outside of the object itself.</p><p>What we will do is use a simple rectangle intersect check based on the centre of the object and its width and height. If this cheap method returns a hit, we will then rotate and translate each vertex and check their real-world coordinates individually against the location of the border.</p><p>Once the rotated game world locations of the vertices are calculated, the collision detection is simple.</p><div class="informalexample"><pre class="programlisting">if (any point falls outside the border){collision has occurred}</pre></div><p>As we will see, a two-stage solution is appropriate for the asteroid detection as well. Also, rotation and translation is involved but it is far less important.</p></div></div><div class="section" title="Colliding with an asteroid"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec077"/>Colliding with an asteroid</h2></div></div></div><p>Testing for collision with an<a class="indexterm" id="id00529"/> asteroid is similar in some respects. We need to find out if any single vertex from the ship or a bullet crosses into the space contained by the vertices of the asteroid.</p><p>The first problem is that the asteroid is not only a moving target, but also a rotating one. We will not only have to rotate and translate all the vertices of the objects, but the asteroids as well.</p><p>We also need to calculate <a class="indexterm" id="id00530"/>the line made between each pair of vertices on the asteroid. Fortunately, at this point, we can fall back on a clever algorithm devised and refined by mathematicians far greater than myself. We will use the crossing number algorithm. This is how it works.</p><div class="section" title="The crossing number"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec035"/>The crossing number</h3></div></div></div><p>We compute the line<a class="indexterm" id="id00531"/> made by a pair of vertices and use the crossing number algorithm to see if a particular vertex from the object being tested crossed that line. If it did, we increment a variable from 0 to 1.</p><p>We test the same point against each and every line made by each vertex pair from an asteroid, incrementing our variable each time it does. If our variable is odd after testing the vertex against every line with the crossing number algorithm, we have a hit. If it is even, no collision has occurred.</p><p>Of course if no collision has occurred, we must proceed to test each and every vertex from the object being tested against each and every line formed out of the vertex pairs on the asteroid.</p><p>Here is a visual representation of the crossing number algorithm in action.</p><div class="mediaobject"><img alt="The crossing number" src="graphics/B043422_11_01.jpg"/></div><p>Of course with all these complex calculations going on, we will definitely want to do a simple first phase test to see <a class="indexterm" id="id00532"/>if it is likely there has been a collision before doing the complex tests.</p></div><div class="section" title="The first phase and overview of asteroid collision detection"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec036"/>The first phase and overview of asteroid collision detection</h3></div></div></div><p>The radius overlap test is <a class="indexterm" id="id00533"/>quite appropriate when testing a single vertex, such <a class="indexterm" id="id00534"/>as a bullet, a spinning triangle like a ship, or a rotating asteroid.</p><p>This is an overview of the whole process we will use for testing the collisions against asteroids:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Is the radius of the object being tested overlapped with the radius of an asteroid?</li><li class="listitem">If yes, has the first vertex of the object crossed the first line of the asteroid?</li><li class="listitem">If yes, <code class="literal">crossingNumber ++</code>.</li><li class="listitem">Repeat step 2 with each line on the object.</li><li class="listitem">If <code class="literal">crossingNumber</code> is odd, return true to calling code because a collision has occurred.</li><li class="listitem">If <code class="literal">crossingNumber</code> is even, no collision has occurred (yet) repeat steps 2, 3, and 4 with the next vertex of the object being tested.</li><li class="listitem">If all vertices tested and we reached here then no collision has occurred.</li></ol></div><p>We will set up a collision detection class called <code class="literal">CD</code> with two static methods. The <code class="literal">detect</code> method will test for collisions with asteroids and be called for each bullet and ship against each and every asteroid in each frame.</p><p>The <code class="literal">contain</code> method will check for collisions with every asteroid, bullet, and ship against the border.</p><p>Doing the calculations outside the objects themselves means that we will need a whole bunch of data for the objects we will be testing, and the ones made accessible to the new <code class="literal">CD</code> class's methods.</p></div></div><div class="section" title="The CollisionPackage class"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec078"/>The CollisionPackage class</h2></div></div></div><p>We know that we need a certain set of <a class="indexterm" id="id00535"/>data to carry out detections properly. This next class will hold all the data that our collision detection class's methods will need in order to do its job, and every object that we need to detect collisions for will have one.</p><p>When the time comes to rotate all the points to their real-world location, our collision package will need to know which way the object is facing. We have a float called <code class="literal">facingAngle</code>.</p><p>We will obviously need a copy of the model space vertices. As with the rotated location, we will not go through the trouble of updating every frame and will do so only after the first phase of collision detection shows that a collision is likely.</p><p>We will also hold the precomputed value for the length of the array that holds these vertices. It can potentially save time in the collision detection process.</p><p>Therefore, we will also need the world coordinates of the object. This, we will update every frame.</p><p>Each object will have a precomputed <code class="literal">radius</code> variable, which is the size of the object from its centre to its furthest vertex. This will be used in our <code class="literal">detect</code> method for radius overlapping, phase one detection.</p><p>We will also have a<a class="indexterm" id="id00536"/> couple of <code class="literal">PointF</code> objects, <code class="literal">currentPoint</code>, and <code class="literal">currentPoint2,</code> which are just handy objects that will avoid us potentially summoning the garbage collector during an intensive part of the two collision detection methods.</p><p>Create a new class, call it <code class="literal">CollisionPackage</code>, and implement the members we have just discussed:</p><div class="informalexample"><pre class="programlisting">// All objects which can collide have a collision package.
// Asteroids, ship, bullets. The structure seems like slight
// overkill for bullets but it keeps the code generic,
// and the use of vertexListLength means there isn't any
// actual speed overhead. Also if we wanted line, triangle or
// even spinning bullets the code wouldn't need to change.

public class CollisionPackage {

    // All the members are public to avoid multiple calls
    // to getters and setters.

    // The facing angle allows us to calculate the
    // current world coordinates of each vertex using
    // the model-space coordinates in vertexList.
    public float facingAngle;

    // The model-space coordinates
    public PointF[] vertexList;

    /* 
    The number of vertices in vertexList
    is kept in this next int because it is pre-calculated
    and we can use it in our loops instead of
    continually calling vertexList.length.
   */
    public int vertexListLength;

    // Where is the centre of the object?
    public PointF worldLocation;

    /* 
    This next float will be used to detect if the circle shaped
    hitboxes collide. It represents the furthest point
    from the centre of any given object.
    Each object will set this slightly differently.
    The ship will use height/2 an asteroid will use 25
    To allow for a max length rotated coordinate.
   */
    public float radius;

    // A couple of points to store results and avoid creating new
    // objects during intensive collision detection
    public PointF currentPoint = new PointF();
    public PointF currentPoint2 = new PointF();</pre></div><p>Next, we have a <a class="indexterm" id="id00537"/>simple constructor that will receive all the necessary data from each object at the end of each object's constructor. Implement the <code class="literal">CollisionPackage</code> constructor as shown here:</p><div class="informalexample"><pre class="programlisting">public CollisionPackage(PointF[] vertexList, PointF worldLocation, 
  float radius, float facingAngle){ 

        vertexListLength = vertexList.length;
        this.vertexList = new PointF[vertexListLength];
        // Make a copy of the array

        for (int i = 0; i &lt; vertexListLength; i++) {
            this.vertexList[i] = new PointF();
            this.vertexList[i].x = vertexList[i].x;
            this.vertexList[i].y = vertexList[i].y;
        }


        

        this.worldLocation = new PointF();
        this.worldLocation = worldLocation;

        this.radius = radius;

        this.facingAngle = facingAngle;

    }


}</pre></div><p>That's all the data we <a class="indexterm" id="id00538"/>need for advanced collision detection.</p><div class="section" title="Adding collision packages to the objects and making them accessible"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec037"/>Adding collision packages to the objects and making them accessible</h3></div></div></div><p>Now, we have <a class="indexterm" id="id00539"/>our <code class="literal">CollisionPackage</code> class. We will see how to <a class="indexterm" id="id00540"/>add one to each object we need to <a class="indexterm" id="id00541"/>monitor.</p><div class="section" title="Adding a collision package to the Bullet class"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec001"/>Adding a collision package to the Bullet class</h4></div></div></div><p>Open up the <code class="literal">Bullet</code> class, and we will see how to make use of our <code class="literal">CollisionPackage</code> constructor on the <a class="indexterm" id="id00542"/>simplest case (just a point). Add a new member for the <a class="indexterm" id="id00543"/>collision package.</p><p>Add a new member of type <code class="literal">CollisionPackage</code> to the <code class="literal">Bullet</code> class:</p><div class="informalexample"><pre class="programlisting">CollisionPackage cp;</pre></div><p>Now, we create a structure to pass in to our <code class="literal">CollisionPackage</code> constructor and initialize the collision package. Note that we send in a single element array with the model space coordinates that will be 0,0,0. Then, we send in the world location, 1, for the radius and the angle the bullet is facing. Enter the following code at the end of the <code class="literal">Bullet</code> class's constructor:</p><div class="informalexample"><pre class="programlisting">// Initialize the collision package
// (the object space vertex list, x any world location
// the largest possible radius, facingAngle)

// First, build a one element array
PointF point = new PointF(0,0);
PointF[] points = new PointF[1];
points[0] = point;

// 1.0f is an approximate representation 
//of the size of a bullet
cp = new CollisionPackage(points, getWorldLocation(),
1.0f, getFacingAngle());</pre></div><p>Finally for the <code class="literal">Bullet</code> class, we <a class="indexterm" id="id00544"/>update the collision package in each frame by<a class="indexterm" id="id00545"/> adding this code to the very end of the <code class="literal">Bullet</code> class's <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">        move(fps);

<span class="strong"><strong>        // Update the collision package</strong></span>
<span class="strong"><strong>        cp.facingAngle = getFacingAngle();</strong></span>
<span class="strong"><strong>        cp.worldLocation = getWorldLocation();</strong></span>
</pre></div><p>Now, our bullets are all set for detection.</p></div><div class="section" title="Adding a collision package to the SpaceShip class"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec002"/>Adding a collision package to the SpaceShip class</h4></div></div></div><p>Open up the <code class="literal">SpaceShip</code> class<a class="indexterm" id="id00546"/> and add these members. We will then see <a class="indexterm" id="id00547"/>how to use them in the <code class="literal">SpaceShip</code> constructor:</p><div class="informalexample"><pre class="programlisting">CollisionPackage cp;

// Next, a 2d representation using PointF of
// the vertices. Used to build shipVertices
// and to pass to the CollisionPackage constructor
PointF[] points;</pre></div><p>Here, we do something extra compared to the <code class="literal">Bullet</code> class. We add three more model space coordinates. OpenGL will not know about these and doesn't need them. They are positioned in the middle of each of the three lines, which make the ship. We do this to make it harder for a vertex of an asteroid to drift inside the ship without a vertex of the ship being inside the asteroid. This is a visual representation of the problem that we are solving. The ships vertices are heavily emphasized to highlight the problem. Refer to the following diagram:</p><div class="mediaobject"><img alt="Adding a collision package to the SpaceShip class" src="graphics/B043422_11_02.jpg"/></div><p>We can completely solve this problem by testing all the asteroids vertices against all of the ship's lines as well as what we are planning to do; test all the ship's vertices against all the asteroids lines. However, just adding a few extra points to the ship does produce near-perfect detection as shown next:</p><div class="mediaobject"><img alt="Adding a collision package to the SpaceShip class" src="graphics/B043422_11_03.jpg"/></div><p>Now, right after<a class="indexterm" id="id00548"/> the call to <code class="literal">setVertices()</code> in<a class="indexterm" id="id00549"/> the <code class="literal">SpaceShip</code> constructor implement the code we just discussed:</p><div class="informalexample"><pre class="programlisting">setVertices(shipVertices);

<span class="strong"><strong>// Initialize the collision package</strong></span>
<span class="strong"><strong>// (the object space vertex list, x any world location</strong></span>
<span class="strong"><strong>// the largest possible radius, facingAngle)</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>points = new PointF[6];</strong></span>
<span class="strong"><strong>points[0] = new PointF(- halfW, - halfL);</strong></span>

<span class="strong"><strong>points[2] = new PointF(halfW, - halfL);</strong></span>
<span class="strong"><strong>points[4] = new PointF(0, 0 + halfL);</strong></span>

<span class="strong"><strong>// To make collision detection more accurate we will define some</strong></span>
<span class="strong"><strong>// more points on the midpoints of all our sides.</strong></span>
<span class="strong"><strong>// It is possible that the point of an asteroid will pass through</strong></span>
<span class="strong"><strong>// the side of the ship and we do not test for this!</strong></span>
<span class="strong"><strong>// We only test for the point of a ship </strong></span>
<span class="strong"><strong>// passing through the side of an asteroid!!</strong></span>
<span class="strong"><strong>// This is computationally cheaper than running both tests.</strong></span>
<span class="strong"><strong>// Although not as accurate we will see it is very close.</strong></span>
<span class="strong"><strong>// We can think of this visually as </strong></span>
<span class="strong"><strong>// adding extra sensors on the sides of our ship</strong></span>
<span class="strong"><strong>// Here we use an equation to find the midpoint </strong></span>
<span class="strong"><strong>// of a line which you can find an explanation of</strong></span>
<span class="strong"><strong>// on most good high school math web sites.</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>points[1] = new PointF(points[0].x + </strong></span>
<span class="strong"><strong>  points[2].x/2,(points[0].y + points[2].y)/2);</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>points[3] = new PointF((points[2].x + points[4].x)/2,</strong></span>
<span class="strong"><strong>  (points[2].y + points[4].y)/2);</strong></span>

<span class="strong"><strong>points[5] = new PointF((points[4].x + points[0].x)/2,</strong></span>
<span class="strong"><strong>  (points[4].y + points[0].y)/2);</strong></span>

<span class="strong"><strong>cp = new CollisionPackage(points, getWorldLocation(), </strong></span>
<span class="strong"><strong>  length/2, getFacingAngle());</strong></span>

}// End SpaceShip constructor</pre></div><p>Next as we did<a class="indexterm" id="id00550"/> for the <code class="literal">Bullet</code> class, we <a class="indexterm" id="id00551"/>synchronize the collision package each frame in the <code class="literal">SpaceShip</code> class's <code class="literal">update</code> method. We do this at the very end of the method after the call to <code class="literal">move()</code> has updated the ship's coordinates.</p><div class="informalexample"><pre class="programlisting">move(fps);

<span class="strong"><strong>    // Update the collision package</strong></span>
<span class="strong"><strong>    cp.facingAngle = getFacingAngle();</strong></span>
<span class="strong"><strong>    cp.worldLocation = getWorldLocation();</strong></span>

}// End SpaceShip update()</pre></div><p>Finally, we will add a collision package to the asteroids.</p></div><div class="section" title="Adding a collision package to the Asteroid class"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl4sec003"/>Adding a collision package to the Asteroid class</h4></div></div></div><p>Open up<a class="indexterm" id="id00552"/> the <code class="literal">Asteroid</code> class and<a class="indexterm" id="id00553"/> add a <code class="literal">CollisionPackage</code> member:</p><div class="informalexample"><pre class="programlisting">CollisionPackage cp;</pre></div><p>At the end of the <code class="literal">Asteroid</code> constructor, just after the call to <code class="literal">generatePoints()</code>, we initialize the <code class="literal">CollisionPackage</code> object:</p><div class="informalexample"><pre class="programlisting">// Define a random asteroid shape
// Then call the parent setVertices()
generatePoints();

<span class="strong"><strong>// Initialize the collision package</strong></span>
<span class="strong"><strong>// (the object space vertex list, x any world location</strong></span>
<span class="strong"><strong>// the largest possible radius, facingAngle)</strong></span>
<span class="strong"><strong>cp = new CollisionPackage</strong></span>
<span class="strong"><strong>  (points, getWorldLocation(), 25, getFacingAngle());</strong></span>
</pre></div><p>Next, we add a <a class="indexterm" id="id00554"/>helper method that reverses the direction of <a class="indexterm" id="id00555"/>travel and <span class="emphasis"><em>bounces</em></span> the asteroid back by a few pixels when a collision has been detected. We will call this method when we detect a collision with the border. Add the <code class="literal">bounce</code> method to the <code class="literal">Asteroid</code> class:</p><div class="informalexample"><pre class="programlisting">public void bounce(){

  // Reverse the travelling angle
    if(getTravellingAngle() &gt;= 180){
      setTravellingAngle(getTravellingAngle()-180);
     }else{
      setTravellingAngle(getTravellingAngle() + 180);
    }

    // Reverse velocity because occasionally they get stuck
    setWorldLocation((getWorldLocation().x + -getxVelocity()/3), (getWorldLocation().y + -getyVelocity()/3));

    // Speed up by 10%
    setSpeed(getSpeed() * 1.1f);

    // Not too fast though
    if(getSpeed() &gt; getMaxSpeed()){
      setSpeed(getMaxSpeed());
    

}</pre></div><p>As with the <code class="literal">SpaceShip</code> and <code class="literal">Bullet</code> classes, we will update the collision package in the <code class="literal">update</code> method just after the call to <code class="literal">move</code> at the very end of the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">move(fps);

<span class="strong"><strong>// Update the collision package</strong></span>
<span class="strong"><strong>cp.facingAngle = getFacingAngle();</strong></span>
<span class="strong"><strong>cp.worldLocation = getWorldLocation();</strong></span>

}</pre></div><p>Now, we need to do something that we didn't need to do for the other classes. Our crossing number algorithm uses lines not vertices, so we need to make a line out of the last vertex by joining it with the first. We didn't need to do this with the <code class="literal">SpaceShip</code> class because of the way our collision data code worked. The collision data code will test the points of the bullets and ship against the lines of the asteroids. Not the other way around.</p><p>Here is the extra<a class="indexterm" id="id00556"/> code to add to the seventh point in <a class="indexterm" id="id00557"/>the <code class="literal">generatePoints</code> method. In the following code, I have included the existing code on either side of the new highlighted code:</p><div class="informalexample"><pre class="programlisting">// left below 0
points[5] = new PointF();
i = -(r.nextInt(14)+11);
points[5].x =  i;
i = -(r.nextInt(12)+1);

points[5].y = i;

<span class="strong"><strong>// We add on an extra point that we won't use in asteroidVertices[].</strong></span>
<span class="strong"><strong>// The point is the same as the first. </strong></span>
<span class="strong"><strong>// This is because the last vertex</strong></span>
<span class="strong"><strong>// links back to the first to create a line. </strong></span>
<span class="strong"><strong>// This line will need to be</strong></span>
<span class="strong"><strong>// used in calculations when we do our collision detection.</strong></span>

<span class="strong"><strong>// Here is the extra vertex- same as the first.</strong></span>
<span class="strong"><strong>points[6] = new PointF();</strong></span>
<span class="strong"><strong>points[6].x = points[0].x;</strong></span>
<span class="strong"><strong>points[6].x = points[0].x;</strong></span>

// Now use these points to draw our asteroid
float[] asteroidVertices = new float[]{
// First point to second point
points[0].x, points[0].y, 0,
points[1].x, points[1].y, 0,</pre></div><p>Now, we can talk about building the collision detection class itself.</p></div></div></div><div class="section" title="The CD class outline"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec079"/>The CD class outline</h2></div></div></div><p>We will now implement the<a class="indexterm" id="id00558"/> first phase of collision detection. As discussed, the algorithms we will use are computationally expensive, and we only want to use them when there is a realistic chance of a collision.</p><p>Therefore, we will check each bullet and the ship against every asteroid using the radius overlapping method discussed in <a class="link" href="ch12.html" title="Chapter 3. Tappy Defender – Taking Flight">Chapter 3</a>, <span class="emphasis"><em>Tappy Defender – Taking Flight</em></span>. We will check the asteroids, ship, and bullets against the border using a simplified rectangle intersection method.</p><p>After the next two sections, you will actually be able to play the game, but you will see that the basic collision detection that we have used so far is not satisfying enough for this type of game.</p><p>These first checks will decide whether we then move on to do the more accurate and computationally expensive checks.</p><p>We will implement these second phase checks in the sections <span class="emphasis"><em>Precise collision detection with the border</em></span> and <span class="emphasis"><em>Precise collision detection with an asteroid</em></span>, which will use the more advanced algorithms and put the data in our collision packages to full use.</p><p>To get started, create a new class and call it <code class="literal">CD</code>. Add a member <code class="literal">PointF</code> object and initialize it. We will use it to avoid creating new objects during the critical parts of the code.</p><div class="informalexample"><pre class="programlisting">private static PointF rotatedPoint = new PointF();</pre></div><p>Now, let's discuss the methods.</p><div class="section" title="Implementing radius overlapping for asteroids and ships"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec038"/>Implementing radius overlapping for asteroids and ships</h3></div></div></div><p>Let's add our first method<a class="indexterm" id="id00559"/> to the <code class="literal">CD</code> class, to <a class="indexterm" id="id00560"/>detect collisions between bullets and asteroids as well as the ship and asteroids. As we discussed, we are only implementing the first part of this method for now. Here is the implementation of the radius overlapping code.</p><p>The code works by making a hypothetical triangle with a missing side, and then using Pythagoras' theorem to calculate the missing side that is the distance between the centre points of the two objects. If the combined radii of the two objects is greater than the distance between the two object centers, we have an overlap.</p><p>Add the <code class="literal">detect</code> method with the radius overlapping code. Note that we return <code class="literal">true</code> if the radii overlap. This one line of code will be replaced with the more accurate detection later in this chapter.</p><div class="informalexample"><pre class="programlisting">public static boolean detect(CollisionPackage cp1, 
    CollisionPackage cp2) {
        
    boolean collided = false;

   // Check circle collision between the two objects

   // Get the distance of the two objects from
   // the centre of the circles on the x axis
   float distanceX = (cp1.worldLocation.x)
        - (cp2.worldLocation.x);

   // Get the distance of the two objects from
   // the centre of the circles on the y axis
   float distanceY = (cp1.worldLocation.y)
        - (cp2.worldLocation.y);

        // Calculate the distance between the center of each circle
        double distance = Math.sqrt
            (distanceX * distanceX + distanceY * distanceY);

        // Finally see if the two circles overlap
        // If they do it is worth doing the more intensive
        // and accurate check.
        if (distance &lt; cp1.radius + cp2.radius) {
            
         // Log.e("Circle collision:","true");
         // todo  Eventually we will add the 
         // more accurate code here
         // todo and delete the line below.
            
            collided = true;
        }
        
        return collided;
    }</pre></div><p>Now, let's <a class="indexterm" id="id00561"/>discuss <a class="indexterm" id="id00562"/>the border.</p></div><div class="section" title="Implementing rectangle intersection for the border"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec039"/>Implementing rectangle intersection for the border</h3></div></div></div><p>We will see if any <a class="indexterm" id="id00563"/>asteroids, bullets, or the ship need containing within the border. As discussed, we will carry out a simple rectangle intersect test and return <code class="literal">true</code> if detected. Later, we will delete the return <code class="literal">true</code> and add the more sophisticated code.</p><p>Implement the <code class="literal">contain</code> method as shown next:</p><div class="informalexample"><pre class="programlisting">// Check if anything hits the border
public static boolean contain(float mapWidth, float mapHeight,                                              
  CollisionPackage cp) {

   boolean possibleCollision = false;

    // Check if any corner of a virtual rectangle
    // around the centre of the object is out of bounds.
    // Rectangle is best because we are testing 
    // against straight sides (the border)
    // If it is we have a possible collision.
   
    if (cp.worldLocation.x - cp.radius &lt; 0) {
            possibleCollision = true;
        } else if (cp.worldLocation.x + cp.radius &gt; mapWidth) {
            possibleCollision = true;
        } else if (cp.worldLocation.y - cp.radius &lt; 0) {
            possibleCollision = true;
        } else if (cp.worldLocation.y + cp.radius &gt; mapHeight) {
            possibleCollision = true;
        }

        if (possibleCollision) {
            // todo For now we return true
            return true;
        }

        return false; // No collision
}</pre></div><p>Now, we have two <a class="indexterm" id="id00564"/>methods that we just need to call them on all the appropriate object combinations.</p></div></div></div></div>
<div class="section" title="Performing the checks"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec064"/>Performing the checks</h1></div></div></div><p>We are really close to<a class="indexterm" id="id00565"/> being able to play our game, albeit with simplified collision detection. First add some methods that handle what happens when certain collisions are detected and then see how we actually use our <code class="literal">CD</code> class.</p><div class="section" title="Helper methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec080"/>Helper methods</h2></div></div></div><p>First of all, we need a <a class="indexterm" id="id00566"/>couple of helper methods to respond, when we detect various types of collisions.</p><p>We need a method for when the ship is destroyed and a method for when an asteroid is destroyed. The next two subsections cover this.</p><div class="section" title="Destroying a ship"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec040"/>Destroying a ship</h3></div></div></div><p>The death of a ship can be <a class="indexterm" id="id00567"/>detected in two places, so it makes sense to add a method to handle the events that follow. In this next method, we reset the ship's location to the center of the map, play a sound, and decrement <code class="literal">numLives</code>.</p><p>If <code class="literal">numLives</code> is equal to zero, set <code class="literal">levelNumber</code> back to one, <code class="literal">numLives</code> to three, call <code class="literal">createObjects()</code> to redraw a level, pause the game, and then play a sound suitable to let the player know that he is starting again.</p><p>Now, add the <code class="literal">lifeLost</code> method to the <code class="literal">AsteroidsRenderer</code> class:</p><div class="informalexample"><pre class="programlisting">public void lifeLost(){
        // Reset the ship to the center
        gm.ship.setWorldLocation(gm.mapWidth/2, gm.mapHeight/2);
        // Play a sound
        sm.playSound("shipexplode");

        // Deduct a life
        gm.numLives = gm.numLives -1;


        if(gm.numLives == 0){
            gm.levelNumber = 1;
            gm.numLives = 3;
            createObjects();
            gm.switchPlayingStatus();
            sm.playSound("gameover");
        }
    }</pre></div><p>We will handle what happens when an asteroid dies.</p></div><div class="section" title="Destroying an asteroid"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec041"/>Destroying an asteroid</h3></div></div></div><p>This method will be<a class="indexterm" id="id00568"/> called when the ship or a bullet hits an asteroid. First, we set the asteroid that triggered the collision to <code class="literal">setActive(false)</code>. It will not be drawn or updated any more.</p><p>Next, we play a sound and decrement <code class="literal">numAsteroidsRemaining</code>. Finally if <code class="literal">numAsteroidsRemaining</code> is equal to zero, the player has cleared an entire level. In that case, we increment <code class="literal">levelNumber</code> and <code class="literal">numLives</code>, play a victorious sound, and start a harder level by calling <code class="literal">createObjects()</code>.</p><p>Now, add the <code class="literal">destroyAsteroid()</code> method to the <code class="literal">AsteroidsRenderer</code> class:</p><div class="informalexample"><pre class="programlisting">public void destroyAsteroid(int asteroidIndex){

  gm.asteroids[asteroidIndex].setActive(false);
     // Play a sound
     sm.playSound("explode");
     // Reduce the number of active asteroids
     gm.numAsteroidsRemaining --;

     // Has the player cleared them all?
     if(gm.numAsteroidsRemaining == 0){
     // Play a victory sound

     // Increment the level number
     gm.levelNumber ++;

     // Extra life
     gm.numLives ++;

     sm.playSound("nextlevel");
     // Respawn everything
     // With more asteroids
     createObjects();


}
}
}// End class</pre></div><p>We can now call our<a class="indexterm" id="id00569"/> new <code class="literal">CD</code> class's static methods and respond when we get a collision.</p></div></div><div class="section" title="Testing for collisions in update()"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec081"/>Testing for collisions in update()</h2></div></div></div><p>First, we will check<a class="indexterm" id="id00570"/> to see if the ship needs containing. We simply call <code class="literal">CD.contain()</code> with the <code class="literal">mapWidth</code>, <code class="literal">mapHeight</code>, and the ship's collision package. If there is a collision, the code calls <code class="literal">lifeLost()</code>.</p><p>Add the collision detection code after all the code that updates the objects in the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">// End of all updates!!

// All objects are in their new locations
// Start collision detection

// Check if the ship needs containing
if (CD.contain(gm.mapWidth, gm.mapHeight, gm.ship.cp)) {

  lifeLost();

}</pre></div><p>This is the code that <a class="indexterm" id="id00571"/>detects if any of the asteroids are attempting to leave the asteroid simulator. It works exactly the same way as the previous block of code except that we loop through each asteroid, check if it is active, and call bounce on the asteroid if we detect a collision.</p><div class="informalexample"><pre class="programlisting">// Check if an asteroid needs containing
for (int i = 0; i &lt; gm.numAsteroids; i++) {
  if (gm.asteroids[i].isActive()) {
       if (CD.contain(gm.mapWidth, gm.mapHeight, 
       gm.asteroids[i].cp)) {

          // Bounce the asteroid back into the game
          gm.asteroids[i].bounce();

          // Play a sound
          sm.playSound("blip");

       }
    }


}</pre></div><p>The code for the bullets looks a little more complicated, but it isn't really. The call to <code class="literal">CD.contain()</code> is identical, and we do so for each bullet. However, some last minute balancing of the game play is necessary for the bullet to be reset as it left the viewport (if that was before the border), because otherwise the ship can just spin round and destroy the asteroids from a great distance.</p><p>Enter the code to detect bullet collisions with the border and the edge of the viewport:</p><div class="informalexample"><pre class="programlisting">// Check if bullet needs containing
// But first see if the bullet is out of sight
// If it is reset it to make game harder
for (int i = 0; i &lt; gm.numBullets; i++) {

    // Is the bullet in flight?
    if (gm.bullets[i].isInFlight()) {

   // Comment the next block to make the game easier!!!
   // It will allow the bullets to go all the way from
   // ship to border without being reset. 
   // These lines reset the bullet when
   // shortly after they leave the players view.
   // This forces the player to go 'hunting' for the
   // asteroids instead of spinning round spamming the
   // fire button...
   // This code would be better with a viewport.clip() method
   // like in project 2 but seems a bit excessive just for these
   // few 15ish lines of code.

   // Start comment out to make easier
   handyPointF = gm.bullets[i].getWorldLocation();
   handyPointF2 = gm.ship.getWorldLocation();
   
   if(handyPointF.x &gt; handyPointF2.x + gm.metresToShowX / 2){
        // Reset the bullet
        gm.bullets[i].resetBullet(gm.ship.getWorldLocation());
       
    }else
        if(handyPointF.x &lt; handyPointF2.x - gm.metresToShowX / 2){
            // Reset the bullet
            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());
        
        }else
        if(handyPointF.y &gt; handyPointF2.y + gm.metresToShowY/ 2){
            // Reset the bullet
            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());
       }else
        if(handyPointF.y &lt; handyPointF2.y - gm.metresToShowY / 2){
            // Reset the bullet
            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());
                }
            // End comment out to make easier

            // Does bullet need containing?
            if (CD.contain(gm.mapWidth, gm.mapHeight,      
                gm.bullets[i].cp)) {

                 // Reset the bullet
                 gm.bullets[i].resetBullet
                    (gm.ship.getWorldLocation());
                 // Play a sound
                 sm.playSound("ricochet");
          }

     }

}</pre></div><p>You can run the game <a class="indexterm" id="id00572"/>now and see how the <code class="literal">CD.contain()</code> method does a fairly good job of keeping everything within the asteroid simulator.</p><p>We will call our <code class="literal">detect</code> method to see if anything is bumping into an asteroid.</p><p>First, check the bullets. Note that we do a preliminary check to make sure the bullet is in flight, and the asteroid is active before we trouble our <code class="literal">CD.detect</code> method. Then, we just pass in the two collision packages and <code class="literal">CD.detect</code> does the rest. If a bullet collides with the border, we call <code class="literal">resetBullet()</code> on the appropriate bullet.</p><div class="informalexample"><pre class="programlisting">// Now we see if anything has hit an asteroid

// Check collisions between asteroids and bullets
// Loop through each bullet and asteroid in turn
        
for (int bulletNum = 0; bulletNum &lt; gm.numBullets; bulletNum++) {
    for (int asteroidNum = 0; asteroidNum &lt; gm.numAsteroids;                            
        asteroidNum++) {

        // Check that the current bullet is in flight
        // and the current asteroid is 
        // active before proceeding
        if (gm.bullets[bulletNum].isInFlight() &amp;&amp;                                           
            gm.asteroids[asteroidNum].isActive())

            // Perform the collision checks by 
            // passing in the collision packages

            // A Bullet only has one vertex. 
            // Our collision detection works on vertex pairs
                    
          if (CD.detect(gm.bullets[bulletNum].cp,                                           
              gm.asteroids[asteroidNum].cp)) {

                // If we get a hit...
                destroyAsteroid(asteroidNum);
                
                // Reset the bullet
                gm.bullets[bulletNum].resetBullet
                    (gm.ship.getWorldLocation());
           }
            
    }
}</pre></div><p>Now, we test for the ship. If <a class="indexterm" id="id00573"/>a collision is detected, we call <code class="literal">destroyAsteroid()</code> followed by <code class="literal">lifeLost()</code>.</p><div class="informalexample"><pre class="programlisting">// Check collisions between asteroids and ship
// Loop through each asteroid in turn
        
for (int asteroidNum = 0; asteroidNum &lt; gm.numAsteroids;                            
     asteroidNum++) {

    // Is the current asteroid active before proceeding
    if (gm.asteroids[asteroidNum].isActive()) {

        // Perform the collision checks by
        // passing in the collision packages
        if (CD.detect(gm.ship.cp, gm.asteroids[asteroidNum].cp)) {

        // hit!
        destroyAsteroid(asteroidNum);
        lifeLost();
       }
    }
}</pre></div><p>At this point, you can play the game and our rudimentary collision detection will work. However, fly too close to an asteroid, and you will lose a life without touching it or merely shoot a bullet close and the asteroid is gone. We need to be able to skim the surface of the border or asteroid and only get a hit when a point actually crosses into the exact space of another object.</p></div></div>
<div class="section" title="Precise collision detection with the border"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec065"/>Precise collision detection with the border</h1></div></div></div><p>To upgrade our <code class="literal">detect</code> method, we <a class="indexterm" id="id00574"/>need to replace the return statement<a class="indexterm" id="id00575"/> in the <code class="literal">if(possibleCollision)</code> block with the more precise detection code.</p><p>First, initialize <code class="literal">radianAngle</code> to be the radian equivalent of whichever direction (in degrees) our object is facing. The <code class="literal">Math</code> class uses radians as they are more mathematically useful in calculations than the easier to visualize degree measurement.</p><p>The variables <code class="literal">cosAngle</code> and <code class="literal">sinAngle</code> are just what the name suggests, and are used in the block of code which follows this one.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0024"/>Tip</h3><p>It is worth mentioning that the <code class="literal">Math.cos()</code> and <code class="literal">Math.sin()</code> methods are relatively time consuming. We can speed up our collision detection class by precomputing 360 values for both <code class="literal">sin</code> and <code class="literal">cos</code> and then using a simple lookup method instead of this calculation.</p><p>However, we maintain our goal of over 60 frames per second, so don't do so here.</p></div></div><p>Delete the return statement and add this code in the <code class="literal">if(possibleCollision)</code> block:</p><div class="informalexample"><pre class="programlisting">if (possibleCollision) {
 
<span class="strong"><strong>     double radianAngle = ((cp.facingAngle/180)*Math.PI);</strong></span>
<span class="strong"><strong>     double cosAngle = Math.cos(radianAngle);</strong></span>
<span class="strong"><strong>     double sinAngle = Math.sin(radianAngle);</strong></span>
</pre></div><p>In the next block of code, enter a <code class="literal">for</code> loop that loops through each of the object's vertices, translates them from model-space to world-space coordinates, then uses our previously computed values for cosine and sine of the <code class="literal">facingAngle</code> object to rotate them to their precise locations in the game world.</p><div class="informalexample"><pre class="programlisting">    //Rotate each and every vertex then check for a collision
    // If just one is then we have a collision.
    // Once we have a collision no need to check further
    for (int i = 0 ; i &lt; cp.vertexListLength; i++){
        // First update the regular un-rotated model space coordinates
        // relative to the current world location (centre of object)
        float worldUnrotatedX = 
                cp.worldLocation.x + cp.vertexList[i].x;
                
        float worldUnrotatedY =  
                cp.worldLocation.y + cp.vertexList[i].y;

       
        // Now rotate the newly updated point, stored in currentPoint
        // around the centre point of the object (worldLocation)
        cp.currentPoint.x = cp.worldLocation.x + (int)                                   
            ((worldUnrotatedX - cp.worldLocation.x)
            * cosAngle - (worldUnrotatedY - cp.worldLocation.y)
            * sinAngle);

        cp.currentPoint.y = cp.worldLocation.y + (int)                                   
            ((worldUnrotatedX - cp.worldLocation.x)
            * sinAngle+(worldUnrotatedY - cp.worldLocation.y)
            * cosAngle);</pre></div><p>Now all we do is see if the rotated and translated vertex falls outside of either the left, right, top, or bottom of the border/map. If it does, we return <code class="literal">true</code>; if not, the loop continues to check<a class="indexterm" id="id00576"/> each and every vertex the same <a class="indexterm" id="id00577"/>way (translate, rotate, check, and so on).</p><div class="informalexample"><pre class="programlisting">     // Check the rotated vertex for a collision
     if (cp.currentPoint.x &lt; 0) {
                    
       return true;
     } else if (cp.currentPoint.x &gt; mapWidth) {
                 
       return true;
     } else if (cp.currentPoint.y &lt; 0) {
                    
       return true;
     } else if (cp.currentPoint.y &gt; mapHeight) {
                    
       return true;
   }

}</pre></div><p>You can run the game now and watch the bullets disappear with a satisfying thud into the border or fly your ship deadly close to the border.</p><p>Let's improve our asteroid collisions.</p></div>
<div class="section" title="Precise collision detection with an asteroid"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec066"/>Precise collision detection with an asteroid</h1></div></div></div><p>We did this last <a class="indexterm" id="id00578"/>because there is a more complicated final step. As <a class="indexterm" id="id00579"/>in the border detection, we will need to translate and rotate our object's vertices. However this time, we will need to do it for two objects.</p><p>Furthermore, once we rotated and translated the asteroid's vertices, we will need to handle them in pairs of vertices that form a line. These are lines that we will test against each and every vertex from the other object. This test is of course our crossing number method that we discussed.</p><p>We need to do all of this within the body of the <code class="literal">if (distance &lt; cp1.radius + cp2.radius) { ...}</code>, where we previously just set the <code class="literal">collided</code> Boolean to <code class="literal">true</code>.</p><p>There is quite a lot of code, so we will split it into chunks and see what is going on at each stage. Also, the code indentation will not always be consistent from block to block in order to format it in the most readable way possible.</p><p>The next few blocks of code are the entire contents of the aforementioned, <code class="literal">if</code> block that needs replacing.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip0025"/>Tip</h3><p>As mentioned previously, we can use a sine and cosine lookup table here too.</p></div></div><p>We could make a method to rotate angles as we do this so often. But this is not as straightforward as it may seem. If we put the rotation code in a method, we will either have to put the following sine and cosine calculations in it, which will make it slow or precompute it before the method call and the <code class="literal">for</code> loops which is kind of untidy itself.</p><p>Also, if you consider that we need more than one value for both the sine and cosine of an angle, the method needs to <span class="emphasis"><em>know </em></span>which value to use, and this isn't rocket science, but it starts to get even less compact than we might have initially imagined. So, I opted to avoid the method call altogether, even if the code is a little sprawling. Actually, if you place the whole lot in a method call, you still get nearly 60 FPS on an old Galaxy S2 phone. So if you want to tidy things up, go ahead; I just thought it was worth discussing why I did things this way.</p><p>Before we jump into the <code class="literal">for</code> loops, as we did with the border detection, we will compute a few things that won't change for the duration of this method. The sine and cosine of the facing angle from each of the two collision packages.</p><div class="informalexample"><pre class="programlisting">     if (distance &lt; cp1.radius + cp2.radius) {

            double radianAngle1 = ((cp1.facingAngle / 180) * Math.PI);
            double cosAngle1 = Math.cos(radianAngle1);
            double sinAngle1 = Math.sin(radianAngle1);

            double radianAngle2 = ((cp2.facingAngle / 180) * Math.PI);
            double cosAngle2 = Math.cos(radianAngle2);
            double sinAngle2 = Math.sin(radianAngle2);

            int numCrosses = 0;    // The number of times we cross a side

            float worldUnrotatedX;
            float worldUnrotatedY;</pre></div><p>Now, we loop through all the vertices from <code class="literal">cp2</code>, then test each in turn with all the sides (vertex pairs) from <code class="literal">cp1</code>. Remember an asteroid has an extra vertex of padding that is the same as the first. Therefore, we can test the last side of the asteroid. We must always pass in the asteroid collision package as the <span class="emphasis"><em>second</em></span> argument when calling <code class="literal">CD.detect()</code>.</p><p>In the next block of code, translate and then rotate the object being tested against an asteroid.</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; cp1.vertexListLength; i++) {

    worldUnrotatedX = cp1.worldLocation.x + cp1.vertexList[i].x;
    worldUnrotatedY = cp1.worldLocation.y + cp1.vertexList[i].y;

    // Now rotate the newly updated point, stored in currentPoint
    // around the centre point of the object (worldLocation)
    cp1.currentPoint.x = cp1.worldLocation.x +
        (int) ((worldUnrotatedX - cp1.worldLocation.x)
        * cosAngle1 - (worldUnrotatedY - cp1.worldLocation.y) *
        sinAngle1);

    cp1.currentPoint.y = cp1.worldLocation.y + 
        (int) ((worldUnrotatedX - cp1.worldLocation.x)
        * sinAngle1 + (worldUnrotatedY - cp1.worldLocation.y) *                   
         cosAngle1);

    // cp1.currentPoint now hold the x/y 
    // world coordinates of the first point to test</pre></div><p>Now using a pair<a class="indexterm" id="id00580"/> of vertices at a time, from the asteroid, translate <a class="indexterm" id="id00581"/>and rotate both to their final world-space coordinates ready for the next block of code, where we will use the vertex locations calculated in the previous block and this block.</p><div class="informalexample"><pre class="programlisting">// Use two vertices at a time to represent the line we are testing
// We don't test the last vertex because we are testing pairs
// and the last vertex of cp2 is the padded extra vertex.
// It will form part of the last side when we test vertexList[5]

for (int j = 0; j &lt; cp2.vertexListLength - 1; j++) {

    // Now we get the rotated coordinates of 
    // BOTH the current 2 points being
    // used to form a side from cp2 (the asteroid)
    // First we need to rotate the model-space 
    // coordinate we are testing
    // to its current world position
    // First update the regular un-rotated model space coordinates
    // relative to the current world location (centre of object)
   
    worldUnrotatedX = cp2.worldLocation.x + cp2.vertexList[j].x;
    worldUnrotatedY = cp2.worldLocation.y + cp2.vertexList[j].y;

    // Now rotate the newly updated point, stored in worldUnrotatedX/y
    // around the centre point of the object (worldLocation)

    cp2.currentPoint.x = cp2.worldLocation.x + 
          (int) ((worldUnrotatedX - cp2.worldLocation.x)
          * cosAngle2 - (worldUnrotatedY - cp2.worldLocation.y) *                   
          sinAngle2);

    cp2.currentPoint.y = cp2.worldLocation.y + 
          (int) ((worldUnrotatedX - cp2.worldLocation.x)
          * sinAngle2 + (worldUnrotatedY - cp2.worldLocation.y) *                   
          cosAngle2);

    // cp2.currentPoint now hold the x/y world coordinates
    // of the first point that
    // will represent a line from the asteroid

    // Now we can do exactly the same for the 
    // second vertex and store it in
    // currentPoint2. We will then have a point and a line (two 
    // vertices)we can use the
    // crossing number algorithm on.

    worldUnrotatedX = cp2.worldLocation.x + cp2.vertexList[i + 1].x;
    worldUnrotatedY = cp2.worldLocation.y + cp2.vertexList[i + 1].y;

    // Now rotate the newly updated point, stored in worldUnrotatedX/Y
    // around the centre point of the object (worldLocation)
    cp2.currentPoint2.x = cp2.worldLocation.x + 
          (int) ((worldUnrotatedX - cp2.worldLocation.x)
          * cosAngle2 - (worldUnrotatedY - cp2.worldLocation.y) *                   
          sinAngle2);

    cp2.currentPoint2.y = cp2.worldLocation.y + 
          (int) ((worldUnrotatedX - cp2.worldLocation.x)
          * sinAngle2 + (worldUnrotatedY - cp2.worldLocation.y) *                   
           cosAngle2);</pre></div><p>Here, we detect if the current vertex from either the ship or a bullet crosses the line formed by the current vertex pair of the asteroid. If it does, we increment <code class="literal">numCrosses</code>.</p><div class="informalexample"><pre class="programlisting">// And now we can test the rotated point from cp1 against the
// rotated points which form a side from cp2

if (((cp2.currentPoint.y &gt; cp1.currentPoint.y) !=                               
       (cp2.currentPoint2.y &gt; cp1.currentPoint.y)) &amp;&amp;
       (cp1.currentPoint.x &lt; (cp2.currentPoint2.x -                                
     cp2.currentPoint2.x)    *(cp1.currentPoint.y - 
        cp2.currentPoint.y) / (cp2.currentPoint2.y  -                               
  cp2.currentPoint.y) + cp2.currentPoint.x)){
   
        numCrosses++;
    
}</pre></div><p>Finally, we use the <a class="indexterm" id="id00582"/>modulus operator to determine if <code class="literal">numCrosses</code> is <a class="indexterm" id="id00583"/>odd or even. As discussed, we return <code class="literal">true</code> (collision) for odd and <code class="literal">false</code> (no collision) for even.</p><div class="informalexample"><pre class="programlisting">            }
            }
            // So do we have a collision?
            if (numCrosses % 2 == 0) {
                // even number of crosses(outside asteroid)
                collided = false;
            } else {
                // odd number of crosses(inside asteroid)
                collided = true;
            }

        }// end if</pre></div><p>You can now fly your ship right up to the asteroids and only get hit when it really looks like you should. Refer to the following screenshot:</p><div class="mediaobject"><img alt="Precise collision detection with an asteroid" src="graphics/B043422_11_04.jpg"/></div><p>Now, all of our<a class="indexterm" id="id00584"/> collision detection and our Asteroids simulator <a class="indexterm" id="id00585"/>game is done!</p></div>
<div class="section" title="Finishing touches"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec067"/>Finishing touches</h1></div></div></div><p>We can continue to<a class="indexterm" id="id00586"/> improve our game. For example, it wouldn't be too hard to spawn two or three smaller asteroids when the current asteroid is destroyed. We just need an array to hold the smaller asteroids. When we deactivate the regular asteroid, the array activates some previously instantiated smaller ones at the same location as the regular one. We can then make some minor modifications to the way we count asteroids, and we will have a neat new feature.</p><p>The arcade classic, Asteroids, had a mean UFO that would turn up occasionally. It would be simple to design a UFO shape from lines, and have it randomly proceed from left to right, or right to left, moving up and down a bit as well.</p><p>Finally, we can add a hyperspace button. This is a kind of last resort for the player when they are sure that death is imminent. Tap the hyperspace button and the ship will respawn in a random location. We will just need to add a button to the array in the <code class="literal">InputController</code> class and a call to a new, simple <code class="literal">randomHyperspaceJUmp</code> method in the <code class="literal">Ship</code> class.</p><p>We can also add Google Play achievements and leaderboards and then publish the game. If you publish a game that uses OpenGL, you need to add this declaration to the <code class="literal">AndroidManifest.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt;</pre></div><p>Try and add some <a class="indexterm" id="id00587"/>of the improvements we talked about and perhaps some more of your own. If you publish your game or even if you don't, I would love to hear your ideas or see a link to your projects on <a class="ulink" href="http://gamecodeschool.com">gamecodeschool.com</a>.</p><p>I think we are done!</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec068"/>Summary</h1></div></div></div><p>I hope you have enjoyed our whirl-wind tour, making games for Android, and I hope you keep making lots of new games!</p></div></body></html>