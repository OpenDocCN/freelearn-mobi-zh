<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Parse Objects and Queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Parse Objects and Queries</h1></div></div></div><p>Parse helps you to manage your complete backend structure for mobile applications and discard the requirement of developing complex server-side code and their maintenance. Parse provides you with the database structures in the form of objects. It saves all your data in the form of objects and will return the same object while retrieving back from Parse.</p><p>Every application has a different and specific <span class="strong"><strong>Application ID</strong></span> associated with the <span class="strong"><strong>Client Key</strong></span>, which remains same for all the applications of the same user.</p><p>Parse is based on object-oriented principles. All the operations on Parse will be done in the form of objects. Parse saves your data in the form of objects you send, and helps you to fetch the data in the same format again. In this chapter, you will learn about objects and operations that can be performed on Parse objects.</p><p>In this chapter, we will learn how to work with Parse objects along with writing queries to set and get data from Parse.</p><div class="section" title="Parse objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Parse objects</h1></div></div></div><p>All the<a id="id19" class="indexterm"/> data in Parse is saved in the form of PFObject. When you fetch any data from Parse by firing a query, the result will be in the form of PFObject. The detailed concept of PFObject is explained in the following section.</p><div class="section" title="PFObject"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>PFObject</h2></div></div></div><p>Data <a id="id20" class="indexterm"/>stored on Parse is in the form of objects and it's developed <a id="id21" class="indexterm"/>around PFObject. PFObject can be defined as the key-value (dictionary format) pair of JSON data. The Parse data is schemaless, which means that you don't need to specify ahead of time what keys exist on each PFObject. Parse backend will take care of storing your data simply as a set of whatever key-value pair you want.</p><p>Let's say you are tracking the visited count of the username with a user ID using your application. A single PFObject could contain the following code:</p><div class="informalexample"><pre class="programlisting">visitedCount:1122, userName:"Jack Samuel", userId:1232333332</pre></div><p>Parse accepts only string as <code class="literal">Key</code>. Values can be strings, numbers, Booleans, or even arrays, and dictionaries—anything that can be JSON encoded.</p><p>The <a id="id22" class="indexterm"/>class<a id="id23" class="indexterm"/> name of PFObject is used to distinguish different sorts of data. Let's say you call the <code class="literal">visitedCounts</code> object of the user. Parse recommends you to write your class name <code class="literal">NameYourClassLikeThis</code> and <code class="literal">nameYourKeysLikeThis</code> just to provide readability to the code. As you have seen in the previous example, we have used <code class="literal">visitedCounts</code> to represent the visited count key.</p></div></div></div>
<div class="section" title="Operations on Parse objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Operations on Parse objects</h1></div></div></div><p>You <a id="id24" class="indexterm"/>can perform save, update, and delete operations on Parse objects. Following is the detailed explanation of the operations that can be performed on Parse objects.</p><div class="section" title="Saving objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Saving objects</h2></div></div></div><p>To save <a id="id25" class="indexterm"/>your <code class="literal">User</code> table on the Parse Cloud with additional fields, you need to follow the coding convention similar to the <code class="literal">NSMutableDictionary</code> method. After updating the data you have to call the <code class="literal">saveInBackground</code> method to save it on the Parse Cloud. Here is the example that explains how to save additional data on the Parse Cloud:</p><div class="informalexample"><pre class="programlisting">PFObject *userObject = [PFObject currentUser];
[userObject setObject:[NSNumber numberWithInt:1122] forKey:@"visitedCount"];
[userObject setObject:@"Jack Samuel" forKey:@"userName"];
[userObject setObject:@"1232333332" forKey:@"userId"];
[userObject saveInBackground];</pre></div><p>Just after executing the preceding piece of code, your data is saved on the Parse Cloud. You can check your data in <span class="strong"><strong>Data Browser</strong></span> of your application on Parse. It should be something similar to the following line of code:</p><div class="informalexample"><pre class="programlisting">objectId: "xWMyZ4YEGZ", visitedCount: 1122, userName: "Jack Samuel", userId: "1232333332",
createdAt:"2011-06-10T18:33:42Z", updatedAt:"2011-06-10T18:33:42Z"</pre></div><p>There are two things to note here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You don't have to configure or set up a new class called User before running your code. Parse will automatically create the class when it first encounters it.</li><li class="listitem" style="list-style-type: disc">There are also a few fields you don't need to specify, those are provided as a convenience:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">objectId</code> is a unique identifier for each saved object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">createdAt</code> and <code class="literal">updatedAt</code> represent the time that each object was created and last modified in the Parse Cloud. Each of these fields is filled in by <a id="id26" class="indexterm"/>Parse, so they don't exist on PFObject until a save operation has completed.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>You can provide additional logic after the success or failure of the callback operation using the <code class="literal">saveInBackgroundWithBlock</code> or <code class="literal">saveInBackgroundWithTarget:selector:</code> methods provided by Parse:</p><div class="informalexample"><pre class="programlisting">[userObject saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
        if (succeeded)
            NSLog(@"Success");
        else
            NSLog(@"Error  %@",error);
    }];</pre></div></div></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="Fetching objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Fetching objects</h2></div></div></div><p>To fetch <a id="id27" class="indexterm"/>the saved data from the Parse Cloud is even easier than saving data. You can fetch the data from the Parse Cloud in the following way.</p><p>You can fetch the complete object from its <code class="literal">objectId</code> using PFQuery. Methods to fetch data from the cloud are asynchronous. You can implement this either by using block-based or callback-based methods provided by Parse:</p><div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"GameScore"]; // 1
[query getObjectInBackgroundWithId:@"xWMyZ4YEGZ" block:^(PFObject  *gameScore, NSError *error) { //2
    // Do something with the returned PFObject in the gameScore variable.
   int score = [[gameScore objectForKey:@"score"] intValue];
   NSString *playerName = [gameScore objectForKey:@"playerName"]; //3
   BOOL cheatMode = [[gameScore objectForKey:@"cheatMode"] boolValue];
         NSLog(@"%@", gameScore);
}];
// The InBackground methods are asynchronous, so the code written after this will be executed
// immediately.  The codes which are dependent on the query result should be moved
// inside the completion block above.</pre></div><p>Let's <a id="id28" class="indexterm"/>analyze each line in here, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Line 1: It creates a query object pointing to the class name given in the argument.</li><li class="listitem" style="list-style-type: disc">Line 2: It calls an asynchronous method on the query object created in line 1 to download the complete object for <code class="literal">objectId</code>, provided as an argument. As we are using the block-based method, we can provide code inside the block, which will execute on success or failure.</li><li class="listitem" style="list-style-type: disc">Line 3: It reads data from <code class="literal">PFObject</code> that we got in response to the query.</li></ul></div><p>Parse provides some common values of all Parse objects as properties:</p><div class="informalexample"><pre class="programlisting">NSString *objectId = gameScore.objectId;
NSDate *updatedAt = gameScore.updatedAt;
NSDate *createdAt = gameScore.createdAt;</pre></div><p>To refresh the current Parse object, type:</p><div class="informalexample"><pre class="programlisting">[myObject refresh];</pre></div><p>This method can be called on any Parse object, which is useful when you want to refresh the data of the object. Let's say you want to re-authenticate a user, so you can call the <code class="literal">refresh</code> method on the user object to refresh it.</p></div><div class="section" title="Saving objects offline"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Saving objects offline</h2></div></div></div><p>Parse <a id="id29" class="indexterm"/>provides you with the functions to save your data when the user is offline. So when the user is not connected to the Internet, the data will be saved locally in the objects, and as soon as the user is connected to the Internet, data will be saved automatically on the Parse Cloud. If your application is forcefully closed before establishing the connection, Parse will try again to save the object next time the application is opened. For such operations, Parse provides you with the <code class="literal">saveEventually</code> method, so that you will not lose any data even when the user is not connected to the Internet. Eventually all calls are executed in the order the request is made. The following code demonstrates the <code class="literal">saveEventually</code> call:</p><div class="informalexample"><pre class="programlisting">// Create the object.
PFObject *gameScore = [PFObject objectWithClassName:@"GameScore"];
[gameScore setObject:[NSNumber numberWithInt:1337] forKey:@"score"];
[gameScore setObject:@"Sean Plott" forKey:@"playerName"];
[gameScore setObject:[NSNumber numberWithBool:NO] forKey:@"cheatMode"];
[gameScore saveEventually];</pre></div></div><div class="section" title="Updating objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Updating objects</h2></div></div></div><p>For <a id="id30" class="indexterm"/>updating objects on Parse, we just need to feed the new data to Parse by calling any of the save functions.</p><p>For example, suppose you have <code class="literal">objectId</code> of the object saved on Parse. We can fetch the corresponding <code class="literal">PFObject</code> using <code class="literal">PFQuery</code> from Parse:</p><div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
 
// Retrieve the object by id
[query getObjectInBackgroundWithId:@"xWMyZ4YEGZ" block:^(PFObject *gameScore, NSError *error) {
 
    // Now let's update it with some new data. In this case, only cheatMode and score
    // will get sent to the cloud. playerName hasn't changed.
    [gameScore setObject:[NSNumber numberWithBool:YES] forKey:@"cheatMode"];
    [gameScore setObject:[NSNumber numberWithInt:1338] forKey:@"score"];
    [gameScore saveInBackground];
 
}];</pre></div><p>After executing the previous code, the Parse client will automatically detect the fields that are changed and will send only the changed fields to Parse for update. Here, we are using the <code class="literal">saveInBackground</code> method to asynchronously save our data on the Parse Cloud.</p></div><div class="section" title="Updating counters"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Updating counters</h2></div></div></div><p>In some cases<a id="id31" class="indexterm"/>, you may want to update the counters such as in the case of a game score. Then, in those cases, for incrementing the value of the key, you can use the <code class="literal">incrementKey</code> method, and for decrementing the value, you can use the <code class="literal">decrementKey</code> method over PFObject:</p><div class="informalexample"><pre class="programlisting">[gameScore incrementKey:@"score"];
[gameScore saveInBackground];</pre></div><p>We can even increase or decrease the value of counters by any specific number by using the following line of code:</p><div class="informalexample"><pre class="programlisting">[gameScore incrementKey:@"score" byAmount:8];</pre></div><p>The previous line of code will increment the <code class="literal">"score"</code> key by <code class="literal">8</code>.</p></div><div class="section" title="Storing data in an array format"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Storing data in an array format</h2></div></div></div><p>To <a id="id32" class="indexterm"/>store data in array format, Parse provides several methods for saving the data. To add the data into your existing value of key, you can use the following code snippet. This code will add the <code class="literal">"flying"</code> object in your <code class="literal">"skills"</code> key:</p><div class="informalexample"><pre class="programlisting">[gameScore addObject:@"flying" forKey:@"skills"];</pre></div><p>The following line of code will add the provided array of objects to the existing array on the cloud. (It can have duplicate data for the value of key.):</p><div class="informalexample"><pre class="programlisting">[gameScore addObjectsFromArray:[NSArray arrayWithObjects:@"flying", @"kungfu", nil] forKey:@"skills"];</pre></div><p>In the previous line of code, the data of the array will be appended to the existing cloud data without any check for the uniqueness of the value of the array. In case you want to avoid the duplicate values to be saved on the cloud, you can use the <code class="literal">addUniqueObjectsFromArray</code> method to save your array. This method will ensure that only unique values are saved on the cloud for the key. The following line of code will add the provided array of objects to the existing array if they are not already added:</p><div class="informalexample"><pre class="programlisting">[gameScore addUniqueObjectsFromArray:[NSArray arrayWithObjects:@"flying", @"kungfu", nil] forKey:@"skills"];
[gameScore saveInBackground];</pre></div></div><div class="section" title="Deleting objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Deleting objects</h2></div></div></div><p>The <a id="id33" class="indexterm"/>following line of code will help you to delete objects from the Parse Cloud. This method will delete your object asynchronously:</p><div class="informalexample"><pre class="programlisting">[myObject deleteInBackground];</pre></div><p>You can use the <code class="literal">deleteInBackgroundWithBlock:</code> method to get a callback after the deletion of the object.</p><p>The following code will delete the object in the background and return the success or error message in response:</p><div class="informalexample"><pre class="programlisting">[ myObject deleteInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
        if (error) {
            // handle error
        }
        if (succeeded) {
            //code on success
        }
    }];</pre></div></div></div>
<div class="section" title="Relations and data types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Relations and data types</h1></div></div></div><p>Just like our relations in the database, we have multiple tables that have a relationship with each other. Parse provides us with the facility to establish relations in between our Parse classes as well. Relations in Parse are explained in detail in the following section.</p><div class="section" title="Relations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Relations</h2></div></div></div><p>You <a id="id34" class="indexterm"/>can add<a id="id35" class="indexterm"/> a relationship between two Parse objects. To implement this, we can add one <code class="literal">PFObject</code> as the value of another <code class="literal">PFObject</code>.</p><p>Let's take an example, we have both <code class="literal">Course</code> and <code class="literal">Student</code> objects, and we can associate a course with a student by establishing the relationship between both of their classes:</p><div class="informalexample"><pre class="programlisting">// Create course data
PFObject *myCourse = [PFObject objectWithClassName:@"Course"];
[myCourse setObject:@"MBA" forKey:@"courseName"];
[myCourse setObject:@"2 years" forKey:@"courseDuration"];

// Create student data
PFObject *studentData = [PFObject objectWithClassName:@"Student"];
[studentData setObject:@"Jack Samuel" forKey:@"name"];
[studentData setObject:[NSNumber numberWithInt:22] forKey:@"age"];
 
// Add a relation between the student and course
[studentData setObject:myCourse forKey:@"registeredCourse"];
 
// This will save both myPost and myComment
[studentData saveInBackground];</pre></div><p>Relations between objects can also be achieved by using <code class="literal">objectId</code>s as well:</p><div class="informalexample"><pre class="programlisting">// Add a relation between the Post with objectId "1zEcyElZ80" and the comment
[studentData setObject:[PFObject objectWithoutDataWithClassName:@"Course" objectId:@"1zEcyElZ80"] 
              forKey:@"registeredCourse"];</pre></div></div><div class="section" title="Data types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Data types</h2></div></div></div><p>Parse<a id="id36" class="indexterm"/> supports<a id="id37" class="indexterm"/> all the data type formats such as <code class="literal">NSString</code>, <code class="literal">NSData</code>, <code class="literal">NSNumber</code>, <code class="literal">PFObject</code>, <code class="literal">NSDate</code>, <code class="literal">NSNull</code>, and <code class="literal">NSData</code>. You can even create nested objects in the form of <code class="literal">NSDictionary</code> and <code class="literal">NSArray</code> to store structured data within a single <code class="literal">PFObject</code>.</p><p>Let's create some random variables shown as follows:</p><div class="informalexample"><pre class="programlisting">NSNumber *number = [NSNumber numberWithInt:42];
NSString *string = [NSString stringWithFormat:@"the number is %i", number];
NSDate *date = [NSDate date];
NSData *data = [@"foo" dataUsingEncoding:NSUTF8StringEncoding];
NSArray *array = [NSArray arrayWithObjects:string, number, nil];
NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:number, @"number",string, @"string",
nil];
NSNull *null = [NSNull null];
 
PFObject *bigObject = [PFObject objectWithClassName:@"BigObject"];
[bigObject setObject:number     forKey:@"myNumber"];
[bigObject setObject:string     forKey:@"myString"];
[bigObject setObject:date       forKey:@"myDate"];
[bigObject setObject:data       forKey:@"myData"];
[bigObject setObject:array      forKey:@"myArray"];
[bigObject setObject:dictionary forKey:@"myDictionary"];
[bigObject setObject:null       forKey:@"myNull"];
[bigObject saveInBackground];</pre></div></div></div>
<div class="section" title="Working with queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Working with queries</h1></div></div></div><p>To <a id="id38" class="indexterm"/>fetch the <a id="id39" class="indexterm"/>saved data from the cloud, we can use the queries to get the required data.</p><p>Let's begin <a id="id40" class="indexterm"/>with simple queries. We can fetch data from Parse asynchronously by executing these simple lines of code:</p><div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"GameScore"];
 
// Retrieve the object by id
[query getObjectInBackgroundWithId:@"xWMyZ4YEGZ" block:^(PFObject *gameScore, NSError *error) {
 
    // Now let's update it with some new data. In this case, only cheatMode and score
    // will get sent to the cloud. playerName hasn't changed.
    [gameScore setObject:[NSNumber numberWithBool:YES] forKey:@"cheatMode"];
    [gameScore setObject:[NSNumber numberWithInt:1338] forKey:@"score"];
    [gameScore saveInBackground];
 
}];</pre></div><p>Suppose you want to filter the results while fetching from Parse, you can add conditions over<a id="id41" class="indexterm"/> the query object and retrieve the <code class="literal">NSArray</code> of the filtered <code class="literal">PFObject</code>. You can use the following method to find the data from the Parse Cloud:</p><div class="informalexample"><pre class="programlisting">findObjectsInBackgroundWithBlock: </pre></div><p>Or you can use:</p><div class="informalexample"><pre class="programlisting">findObjectsInBackgroundWithTarget:selector:</pre></div><p>Both methods are asynchronous and will execute callback on the main thread. There is one method called <code class="literal">[query findObjects]</code>; this method will block the thread on which it is executed.</p><p>For example, if you want to fetch the list of students registered for an MBA course, we can use the following code:</p><div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"Student"];
[query whereKey:@"registeredCourse" equalTo:@"MBA"];
[query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
  if (!error) {
    // The find succeeded.
    NSLog(@"Successfully retrieved list of %d students.", objects.count);
  } else {
    // Log details of the failure
    NSLog(@"Error: %@ %@", error, [error userInfo]);
  }
}];</pre></div><div class="section" title="Using predicates"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Using predicates</h2></div></div></div><p>To add constraint to the<a id="id42" class="indexterm"/> result of the query we can use the following methods:</p><div class="informalexample"><pre class="programlisting">NSPredicate *predicate = [NSPredicate predicateWithFormat:@"studentName = 'Jack Samuel'"];
PFQuery *query = [PFQuery queryWithClassName:@"Student" predicate:predicate];</pre></div><p>The following <a id="id43" class="indexterm"/>types of predicate features are supported by Parse:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can use comparisons such as =, !=, &lt;, &gt;, &lt;=, &gt;=, and BETWEEN with a key and a constant</li><li class="listitem" style="list-style-type: disc">Containment predicates, such as x IN {1, 2, 3}</li><li class="listitem" style="list-style-type: disc">Key-existence predicates, such as x IN SELF</li><li class="listitem" style="list-style-type: disc">BEGINSWITH expressions</li><li class="listitem" style="list-style-type: disc">Compound predicates with AND, OR, and NOT</li><li class="listitem" style="list-style-type: disc">Sub-queries with "key IN %@", subquery</li></ul></div><p>The following<a id="id44" class="indexterm"/> types of predicates are not supported by Parse:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Aggregate operations, such as ANY, SOME, ALL, or NONE</li><li class="listitem" style="list-style-type: disc">Regular expressions, such as LIKE, MATCHES, CONTAINS, or ENDSWITH</li><li class="listitem" style="list-style-type: disc">Predicates comparing one key to another</li><li class="listitem" style="list-style-type: disc">Complex predicates with many ORed clauses</li></ul></div></div><div class="section" title="Adding query constraints"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Adding query constraints</h2></div></div></div><p>There <a id="id45" class="indexterm"/>are <a id="id46" class="indexterm"/>various ways to add constraint to the query results. Following are the few ways to implement constraints:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To find all the students excluding the specified one in the query, Parse provides the <code class="literal">whereKey:notEqualTo:</code> method to get the selective filtered data from the Parse Cloud. This method is available in various combinations. The following code will get the objects where the student name is not John Simon:<div class="informalexample"><pre class="programlisting">[query whereKey:@"studentName" notEqualTo:@"John Simon"];</pre></div></li><li class="listitem" style="list-style-type: disc">We can add multiple constraints to the same query, the resultant objects will match to all the constraints:<div class="informalexample"><pre class="programlisting">[query whereKey:@"studentName" notEqualTo:@"John Simon"];
[query whereKey:@"studentAge" greaterThan:[NSNumber numberWithInt:18]];</pre></div></li><li class="listitem" style="list-style-type: disc">You can limit the result of the query by setting the <code class="literal">limit</code> of the query object:<div class="informalexample"><pre class="programlisting">query.limit = 10;</pre></div></li><li class="listitem" style="list-style-type: disc">If you want to get only the first object of the result, you can use <code class="literal">getFirstObject</code> or <code class="literal">getFirstObjectInBackground</code>. Both methods will return the first object from the array of objects received in response:<div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"Student"];
[query whereKey:@"studentName" equalTo:@"John"];
[query getFirstObjectInBackgroundWithBlock:^(PFObject *object, NSError *error) {
  if (!object) {
    NSLog(@"The getFirstObject request failed.");
  } else {
    // The find succeeded.
    NSLog(@"Successfully retrieved the object.");
  }
}];</pre></div></li><li class="listitem" style="list-style-type: disc">You can skip the result by setting <code class="literal">skip</code>. This can be used for pagination as well:<div class="informalexample"><pre class="programlisting">query.skip = 10; // skip the first 10 results</pre></div></li><li class="listitem" style="list-style-type: disc">Parse <a id="id47" class="indexterm"/>provides you with an easy way of sorting numbers and strings. It allows you to control the order in which the results are returned:<div class="informalexample"><pre class="programlisting">// Sorts the results in ascending order by the name field
[query orderByAscending:@"studentName"];
 
// Sorts the results in descending order by the name field
[query orderByDescending:@"studentName"];</pre></div></li><li class="listitem" style="list-style-type: disc">You can filter the results by providing the comparisons in the queries:<div class="informalexample"><pre class="programlisting">// Fetch list of students who scored &lt; 50
[query whereKey:@"score" lessThan:[NSNumber numberWithInt:50]];
 
// Fetch list of students who scored &lt;= 50
[query whereKey:@"score" lessThanOrEqualTo:[NSNumber numberWithInt:50]];</pre></div></li><li class="listitem" style="list-style-type: disc">You can<a id="id48" class="indexterm"/> filter the results based on the different values as well. You can provide the array of the values that should appear in the results:<div class="informalexample"><pre class="programlisting">// Finds scores from any of Jonathan, Dario, or Shawn
NSArray *names = [NSArray arrayWithObjects:@"Jonathan Walsh",
  @"Dario Wunsch",@"Shawn Simon",nil];
[query whereKey:@"studentName" containedIn:names];
       Fetch objects excluding the data provided in the array.
// Finds scores from anyone who is neither Jonathan, Dario, nor Shawn
NSArray *names = [NSArray arrayWithObjects:@"Jonathan Walsh",@"Dario Wunsch",@"Shawn Simon",nil];
[query whereKey:@"studentName" notContainedIn:names];</pre></div></li></ul></div></div></div>
<div class="section" title="Relational and complex queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Relational and complex queries</h1></div></div></div><p>You can <a id="id49" class="indexterm"/>fire the <a id="id50" class="indexterm"/>queries on relational schema to perform operations on the Parse data. Following are the various ways to fetch data from Parse under a relational model.</p><div class="section" title="Array-based queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Array-based queries</h2></div></div></div><p>If you<a id="id51" class="indexterm"/> have<a id="id52" class="indexterm"/> keys with data in the array format, you can find objects where array contains value <code class="literal">x</code>:</p><div class="informalexample"><pre class="programlisting">// Find objects where the array in arrayKey contains 2.
[query whereKey:@"arrayKey" equalTo:[NSNumber numberWithInt:2]];</pre></div><p>If you want to fetch the data matching multiple values of array, you can use the following code:</p><div class="informalexample"><pre class="programlisting">// Find objects where the array in arrayKey contains each of the
// elements 2, 3, and 4.
[query whereKey:@"arrayKey" containsAllObjectsInArray:@[@2, @3, @4]];</pre></div></div><div class="section" title="String-based queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>String-based queries</h2></div></div></div><p>You <a id="id53" class="indexterm"/>can <a id="id54" class="indexterm"/>use <code class="literal">where:hasPrefix:</code> to add the constraint to the query result:</p><div class="informalexample"><pre class="programlisting">// Finds student name that start with "Stuart".
PFQuery *query = [PFQuery queryWithClassName:@"Student"];
[query whereKey:@"name" hasPrefix:@"Stuart"];</pre></div></div><div class="section" title="Relational queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Relational queries</h2></div></div></div><p>You <a id="id55" class="indexterm"/>can fetch the objects from Parse where the fields match<a id="id56" class="indexterm"/> the particular PFObject. Parse provides a method <code class="literal">whereKey:equalTo:</code> to fetch data from a query. Let's say you want to fetch a list of students who are enrolled for the MBA course:</p><div class="informalexample"><pre class="programlisting">// Assume PFObject *myPost was previously created.
PFQuery *query = [PFQuery queryWithClassName:@"Student"];
[query whereKey:@"course" equalTo:myCourse];
 
[query findObjectsInBackgroundWithBlock:^(NSArray *studentList, NSError *error) {
    // list of student enrolled for MBA course
}];</pre></div><p>In case you want to fetch multiple types of related objects in a single query, Parse provides you with the <code class="literal">includeKey:</code> method to fetch these kinds of relational results. For example, if  you want to <a id="id57" class="indexterm"/>fetch the names <a id="id58" class="indexterm"/>of the top-scorer students, and you want to fetch their courses at the same time, you can use the following code snippet to get the desired results:</p><div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"student"];
 
// Retrieve the top scorer
[query orderByAscending:@"score"];
 
// Only retrieve the top ten
query.limit = [NSNumber numberWithInt:10];
 
// Include the course data with each student score
[query includeKey:@"course"];
 
[query findObjectsInBackgroundWithBlock:^(NSArray *students, NSError *error) {
    // Top ten scorer Students from all courses
}];</pre></div></div><div class="section" title="Counting objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Counting objects</h2></div></div></div><p>There can be some cases in which you just need to know the count of the resultant array. For this you don't need to query the complete data using the <code class="literal">findObjects</code> method. Parse provides you with the <code class="literal">countObjects</code> method to fetch the count of the data available on Parse for the query:</p><div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"Student"];
[query whereKey:@"studentName" equalTo:@"Sean"];
[query countObjectsInBackgroundWithBlock:^(int count, NSError *error) {
  if (!error) {
    // The count request succeeded. Log the count
  } else {
    // The request failed
  }
}];</pre></div></div><div class="section" title="Compound queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Compound queries</h2></div></div></div><p>If you <a id="id59" class="indexterm"/>want to<a id="id60" class="indexterm"/> fetch the objects as the result of several queries, Parse provides the <code class="literal">orQueryWithSubqueries:</code> method to fetch these kinds of result.</p><p>Let's say you need to get the list of names of the top-scorer and the least-scorer students; the <a id="id61" class="indexterm"/>following code snippet gives the desired output:</p><div class="informalexample"><pre class="programlisting">// Query to fetch the list of students with highest score
PFQuery *highestScorer = [PFQuery queryWithClassName:@"Student"];
[lotsOfWins whereKey:@"score" greaterThan:[NSNumber numberWithInt:150]];

// Query to fetch the list of students with lowest score 
PFQuery *lowestScorer = [PFQuery queryWithClassName:@"Player"];
[fewWins whereKey:@"score" lessThan:[NSNumber numberWithInt:5]];

PFQuery *query = [PFQuery orQueryWithSubqueries:[NSArray arrayWithObjects:highestScorer,lowestScorer,nil]];
[query findObjectsInBackgroundWithBlock:^(NSArray *results, NSError *error) {
  // results contains students with highest and lowest score.
  }];</pre></div></div><div class="section" title="Caching queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Caching queries</h2></div></div></div><p>Caching <a id="id62" class="indexterm"/>the data is a process where we store the data received from the remote API calls temporally on a device. So, for the same request, you do not need to fetch the data again and again. Caching improves the efficiency, performance, and reduces load on the server with minimal API calls.</p><p>Once data is requested through a query from Parse, it is recommended to cache it, to reduce the number of hits to the Parse Cloud. You can cache the result on the disk. This feature will help you to show data in an offline mode or when the application is just launched and data is not fetched yet. Parse automatically handles flushing the cache when memory is low.</p><p>By default, <code class="literal">PFQuery</code> doesn't cache queries; however, you can enable caching of the <code class="literal">PFQuery</code> by setting the property <code class="literal">query.cachePolicy</code>. Let's take an example, if network reachability is not available, you can add an automatic fallback to cached data:</p><div class="informalexample"><pre class="programlisting">PFQuery *query = [PFQuery queryWithClassName:@"Student"];
query.cachePolicy = kPFCachePolicyNetworkElseCache;
[query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
  if (!error) {
    // Results were successfully found, looking first on the
    // network and then on disk.
  } else {
    // The network was inaccessible and we have no cached data for
    // this query.
  }
}];</pre></div><p>Parse provides you with the following caching policies:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">kPFCachePolicyIgnoreCache</code>
<a id="id63" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>It is the default cache policy. The query does not load from the cache nor does it save results to the cache.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">KPFCachePolicyCacheOnly</code>
<a id="id64" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The query only loads from the cache, ignoring the network. If there are no cached results, that causes a <code class="literal">PFError</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">KPFCachePolicyNetworkOnly</code>
<a id="id65" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>It does not load from the cache, but it saves results to the cache.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">KPFCachePolicyCacheElseNetwork</code>
<a id="id66" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>It tries to load from the cache, but if the query fails, it loads results from the network. If neither cache nor network succeeds, there is a <code class="literal">PFError</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">KPFCachePolicyNetworkElseCache</code>
<a id="id67" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This query first tries to load from the network, but if it fails, it loads results from the cache. If neither network nor cache succeeds, you will get a <code class="literal">PFError</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">KPFCachePolicyCacheThenNetwork</code>
<a id="id68" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This query first loads from the cache, then loads from the network. In this case, the callback will be called twice—first with the cached results, then with the network results. Since it returns two results at different times, this cache policy cannot be used synchronously with <code class="literal">findObjects</code>.</p>
</td></tr></tbody></table></div><p>Caching behavior <a id="id69" class="indexterm"/>can be controlled using the following operations on the cache:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It helps you to check the cached result for a query:<div class="informalexample"><pre class="programlisting">BOOL isInCache = [query hasCachedResult];</pre></div></li><li class="listitem" style="list-style-type: disc">It clears cached results for the query object:<div class="informalexample"><pre class="programlisting">[query clearCachedResult];</pre></div></li><li class="listitem" style="list-style-type: disc">It clears all the cache of the <code class="literal">PFQuery</code>:<div class="informalexample"><pre class="programlisting">[PFQuery clearAllCachedResults];</pre></div></li><li class="listitem" style="list-style-type: disc">You <a id="id70" class="indexterm"/>can control the time for which the cache result will exist:<div class="informalexample"><pre class="programlisting">query.maxCacheAge = 60 * 60 * 24;  // One day, in seconds.</pre></div></li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we explored Parse objects and the way to query the data available on Parse.</p><p>We started by exploring Parse objects and the ways to save these objects on the cloud.</p><p>Then, we learned about the queries which will help us to fetch the saved data on Parse.</p><p>Finally, we saw various ways to implement queries and the constraints by which we can reduce the complexity of the queries.</p><p>In the next chapter, we will learn the various ways to save our files on the Parse Cloud, along with the subclassing concepts on Parse objects.</p></div></body></html>