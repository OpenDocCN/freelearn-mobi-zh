- en: Chapter 2. Standard Library and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating HTML manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing your object description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quizzing the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for perfect numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting an array of products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the way out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing a dinner room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to know the usage of collections and standard library, mainly
    for those people who come from Objective-C because there are some differences
    here.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create some apps to use these features. After these
    recipes, you should have a good understanding about the Swift programming language.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, most of our recipes will be created on
    iOS, but you can develop them on Mac OS X if you want.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HTML manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML started as a simple format for displaying web pages and links. Nowadays,
    this format has become very common and it is used everywhere. There are even frameworks
    such as PhoneGap that create applications with this file type.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create HTML using only strings; the main idea is to
    know about string manipulation. In this case, we will create the HTML code for
    a visiting card.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Xcode and create a single view project called `Chapter2 HTML`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create HTML manually by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the storyboard and add the following layout:![How to do it…](img/00024.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, connect the text fields with the following properties on the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Link these properties with the corresponding text field on the view, and before
    creating an action button, we will create a `Card` class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are creating a class with the same information as our application.
    The main difference is that we have a constant called `TEMPLATE`, which has a
    model of our HTML.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this constant is private because it's something that we shouldn't
    see (for example, from the view controller). Also notice that we have a plus sign
    at the end of each line that needs to continue on the next line. The reason is
    that we can't concatenate strings without using an operator as we used in Objective-C.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Swift doesn't need a semicolon at the instruction end. However, if you have
    a huge line, you have to tell the compiler that the line is going to continue,
    with a plus sign, for example, or by indicating on the next line that it is continuing
    from the previous one, with a dot operator, for example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you''ve been programming with Objective-C or C++, you may be asking why
    we''ve created an empty initializer. The reason is: it is not necessary; theoretically,
    because we only have constants and optional values. However, some Swift versions,
    for whatever reason, don''t detect it and force you to create an empty initializer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What are the attributes' initial values? The answer is *nil*. Have a look to
    see whether all of them are optional; otherwise, we will have to set their values
    to something.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid using empty values such as empty strings to initialize an attribute; it
    is better to use optional attributes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this time, we have the basic structure. Now we need to create the button
    event, so link the touch up event with the following action on the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we will have a look at whether this action is very clear. We will start
    creating a `card` object, then we will receive the information we need from our
    view, and at the end, display it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid spaghetti code; do not create an enormous action and try to divide it
    into classes and methods. Have a look at the Model-View-Controller pattern on
    Wikipedia.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Everything is fine except for one detail: the `Card` class has no method called
    `toHtml`. No problem, let''s implement it. Go back to our `Card` class and add
    the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now it's time to test it; just press play on your Xcode IDE, fill in the fields
    and press the button, and you should see a message like the one shown here:![How
    to do it…](img/00025.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings have a lot of methods; some of them are used to modify the current string,
    while others only return values, and others create a new string based on the original
    one. In our case, we used `stringByReplacingOccurrencesOfString`, which generates
    a new string by replacing our marks `(#something#`) with the corresponding attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We can chain the result of each replacement to do the next one, preventing reassignment
    on each line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nowadays, iPhones and iPads have 1 gigabyte or more of RAM, which should be
    enough for most of the traditional HTML templates. However, if you have a very
    big template with lots of replacements, you might need to look for a more optimized
    method for it. Replacing strings on big string variables allocates a lot of memory
    and you might get a poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at this method documentation, you will see that there are two additional
    arguments, one called `options` and another one called `range`. They are used
    to specify a special comparator to search our string mark, and the other one uses
    only part of our string. As we didn't have to use them and they are optional,
    we've just omitted them; it wasn't necessary to fill them with nil values as we
    used to do in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your project has objects that need to create HTML, XML, or JSON code, you
    can create a base object with a method specific to the corresponding casting to
    standardize it.
  prefs: []
  type: TYPE_NORMAL
- en: Printing your object description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of this recipe is to see the Swift way of creating a string using variable
    values. In Objective-C, we have a class method called `stringWithFormat`, but
    this method isn't used in Swift with the same frequency as it is used in Objective-C
    because now we have interpolation. In this example, we will create an app, which
    will show the user three possible products. When the user chooses one of them,
    the app must show the information of this product and also its price, if it's
    available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new single view project called `Chapter2 Product Value`. Now, let's
    click on the storyboard and add three buttons, as shown here:![How to do it…](img/00026.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've done this, you can add a new swift file called `Product`. Now we
    will create a class with a product name, its price, and the manufacturer name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, the only information that can be omitted is the product price;
    the other attributes are not optional. This means that we will need an initializer
    with at least the product name and the manufacturer name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we would like to use our product with interpolation, we need to implement
    the `CustomStringConvertable` protocol, which forces us to implement a property
    called `description`. Once we have this information, we can implement our class
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can go to the view controller and create three products as attributes;
    following our examples, we will create `television`, `gabion`, and `locker`. So,
    let''s add the following attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create an auxiliary function, which is going to convert
    a double into a string with two digits of precision. I will create this function
    on the view controller file but outside its class. If in a project you are going
    to use this function in more than one file, I recommend you create another file
    for this function using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good idea to have one or more files dedicated to auxiliary functions
    and class extensions. This will make your code maintenance easier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last thing we need to do is to create the button action. As you know, we
    have three buttons, and all of them will perform the same function; the only difference
    is the product that will be displayed. For this reason, we will create only one
    function and differentiate the product according to its sender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid repeating code, even if they are next to each other or if they are small
    code. This is because when the project starts receiving changes, it will generate
    new bugs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another detail that I would like to mention is that, in this example, I will
    show the product price after adding VAT (20%). This is to make you aware of the
    power of Swift string interpolation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this sample, we used the buttons' titles to know the product chosen, but
    it's a bad practice. It was done this way only to create a small example focused
    on string interpolation. Imagine that you need to translate your program to other
    languages or if you have to add a small amount of information to this label; it
    will make you fix a lot of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now our app is complete; try to press play and then the app buttons. You should
    see an alert view like this one:![How to do it…](img/00027.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the greatest features of Swift is string interpolation; it allows you
    to have expressions like the one we did while calculating the price with VAT included.
    This also allows you to call functions like we called `doubleFormatter` to have
    our number shown with two digits. This also allows us to print an object.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to, we can even call object methods or property, for example. We
    can show the manufacturer name in uppercase, changing our description to `\(self.name)
    \(self.manufacturer.uppercaseString))`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if you want to print your own object, it must follow the `CustomStringConvertable`
    protocol and implement the property called `description`. Some languages such
    as Java have the equivalent method (`toString` in case of Java) on a base class
    and you only need to override it. However, Swift has no base if you don't specify
    it, and this is the reason you can't overwrite the `description` property without
    specifying the usage of the `CustomStringConvertable` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: To use string interpolation, just create a string and when you need an external
    value, just |wrap it between `\(` (backslash and open parenthesis) and `)` (closed
    parenthesis), for example, `\(variable)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the expression is getting too complex in a way that makes it difficult to
    use, just create a new variable with its value inside the string. This is also
    a good practice in terms of software maintenance. Objective-C doesn't have this
    feature; you have to create a new string using a class method named `stringWithFormat`.
    We used the Swift equivalent one, which is now an initializer.
  prefs: []
  type: TYPE_NORMAL
- en: I would also like to point out that we created a constant inside our `if` statement.
    In this case, we are not verifying whether the price is true or if it is greater
    than zero, we are just checking that it does not have a nil value. In case of
    a product that costs 0, for example, it would also evaluate to true.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, notice that our variable message is not optional but that
    it wasn't initialized where declared. The reason for this is that the compiler
    will check it before reading it and setting it, and there is no possibility of
    having it uninitialized.
  prefs: []
  type: TYPE_NORMAL
- en: The initial value for this variable depends on the product value, which can't
    be nil; this is the reason we were forced to add an `else` statement and `exit`
    from our function. Otherwise, the compiler would find a possible way to have the
    product set to nil and it would fail due to our interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another good solution for our `doubleFormatter` function is to create an extension.
    To do this, just change our formatter code to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that now we''ve added a new method to double types, and we can call
    it whenever we want. Of course, we also have to change the interpolation that
    uses our double value. Now, we can use the class extension replacing the corresponding
    line with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Quizzing the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to add some icons on our application, but depending on the
    icon you want, it's not necessary to add an image; you can use Unicode characters.
    Let's create a quiz app using strings alone.
  prefs: []
  type: TYPE_NORMAL
- en: The idea for this app is to create an app where the user needs to answer a question
    in 12 seconds. After the quiz, the app will show the user his score, such as the
    number of right and wrong questions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we know the concept of this program, let's create a new project and name
    it `Chapter 2 Unicode`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a quiz app, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new file called `Quiz` and add a class with a question
    to it, with three possible answers and the right answer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To add Unicode characters to your code, you can copy from a website or go to
    **Edit** | **Special characters**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we''ve got this happy class, we need to create another one to store
    our quizzes and manage the user''s answers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to add one label for the question, three buttons for the possible
    answers, and one label to show the timer. Don't forget to hide the navigation
    bar if you don't want to show it. Your screen should look similar to this:![How
    to do it...](img/00028.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it''s time to create the corresponding properties on our view controller
    and link them. Besides these components, we will also need a timer and another
    variable to know how much time has passed. Call these properties as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ok, now it''s time to initialize these components. This is the reason we will
    create an initializer. In Objective-C, we used to set up the `viewDidLoad` method,
    as this method is called after the controller''s view has been loaded in memory,
    but now on Swift, every object must have each non-optional property initialized.
    This is the reason we will overwrite the `init` method. Don''t worry about the
    meaning of each line; it will be explained soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first question you might have is: why did we use `required` instead of
    `override`? This is because the initializer was defined as required on the base
    class (`UIViewController`); in this case, we must re-implement this method.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is to set `elapsedTime`. We will not use it now, but as it is
    not optional, we must set it here. Note that both `elapsedTime` and `quizManager`
    are initialized before the super class. After initializing the super class, we
    can add the questions to the quiz manager; which is the reason we have a call
    to `setupQuizManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ok, now we can show the first question on screen. To do this, we need the famous
    `viewDidLoad` function. We can''t do it on the initializer because the labels
    and the buttons haven''t been instantiated. You can also see the `prepareNextQuestion`
    method, which verifies whether there are more questions. If so, this shows the
    next question; if not, then it shows your score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will notice that we are using the new `guard` keyword introduced in Swift
    2.0\. Using guard will allow you to define an exit strategy if a particular condition
    is not met. This really comes in handy when unwrapping optionals; all code after
    the guard condition will contain the unwrapped value(s) without indentation and
    scope issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is something that is still missing, it''s the timer callback. Remember
    that we would like to show the user how much time he has left to answer the question,
    and after this, we have to skip to the next question. As you can see in the preceding
    method, we call a method named `tick`; this means that with each second, we have
    to increase the value of `elapsedTime`, and when the timer is over, we will consider
    that the question was answered incorrect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you press play now, you can see the app working except for one small detail.
    The user can''t answer! Notice that there is no button action, so we need to add
    it, and remember that once the user has pressed the button, it will go to the
    next question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cool, now we have our app working!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned some ways of using Unicode happy characters. Now
    you can create you own WhatsApp-like program. We saw that we can have variable
    names with Unicode characters; if you want, you can name your variables in Japanese!
    You can also create strings with Unicode values using `String(Character(UnicodeScalar(UNICODE_VALUE)))`,
    or you can also use it with interpolations such as `Total \u{1F44D}`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take care while using Unicode characters; you may be complicating the other
    team members' lives. Remember that not everybody speaks Japanese or Chinese, and
    sometimes symbols are similar to others.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that it's possible to write an integer in hexadecimal; it's
    only necessary to add the prefix `0x`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to see more Unicode symbols, there are some pages that can help
    us. I recommend [http://unicode-table.com](http://unicode-table.com) and [http://www.alanwood.net/demos/wingdings.html](http://www.alanwood.net/demos/wingdings.html).
  prefs: []
  type: TYPE_NORMAL
- en: Searching for perfect numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Believe it or not, computers were born as giant calculators, and until now,
    their main function was to do powerful calculations. Let's add a little bit of
    math to our Swift project to create an app that will look for the first perfect
    number and show it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main question you probably have now is: what''s a perfect number? A perfect
    number is a positive integer that is equal to the sum of its divisors. For example,
    6 is a perfect number because if you sum its divisors (1 + 2 + 3), its result
    is 6.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the range operators.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating a new Swift project called `Chapter2 Perfect Number`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to search for perfect numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the storyboard and create a layout similar to the one shown here:![How
    to do it…](img/00029.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s link the text fields with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, before we create the button action, we will create a function called
    `isPerfect`, which will check whether the number passed as an argument is a perfect
    number or not. After this, we will create the button action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, we used a `for` loop twice. The first time we used the closed-range
    operator (`…`), which was used to include the last number (`rangeEnd`), because
    we want to check the last number the user entered.
  prefs: []
  type: TYPE_NORMAL
- en: The second time we used the half-open operator (`..<`) to exclude the last number
    because we don't want to include the last number into the sum.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first version of Swift, the half-open operator, was only two dots (`..`).
    After some beta versions, it was renamed to `..<`. For this reason, you can find
    some code on the Internet that does not work anymore.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use these operators on `switch` statements; they are very handy
    sometimes, mainly when you don't want to write the typical C `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an array of products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to manage an array in Swift. Here, we will
    create an array of products (very typical), add products to it, remove unavailable
    products, and sort the array by price.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Swift single view project called `Chapter 2 SortingProduct`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create and sort an array of products by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start with the view part, let''s create the model part of our application.
    In our case, we will create the `Product` class. So, create a new file called
    `Product.swift` and type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the idea of this class is to create objects with their name,
    price, and availability. We also inherited it from `CustomStringConvertable` to
    make use of its `description` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can click on the storyboard and add two labels, one for the full catalog,
    which means that it will show every product in its original order, no matter how
    much it costs or whether it's available or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The other label will show the same products but filtered for availability and
    sorted by price. So, now link your labels with the following properties and also
    create a product array as a property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can create additional labels if you want to know their meaning. I created
    one with the title `Catalog` and another one with the title `Available Products`.
    It is also important to set a new number of lines on `catalogLabel` and `availableLabel`;
    otherwise, it will display only the first product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to create the initialize; here, we only need to add some products
    to our array. As it''s just a sample, the products will be hardcoded, but in real
    apps, we should retrieve them from a database or from the Internet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we can display our catalog when the view has loaded so that we
    can start using our `catalog` label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Okay, now it is time to add a button and create its action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application is done; once you click on the button, you will see a result
    similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays in Swift are very similar to mutable arrays in Objective-C; they can
    add objects, remove them, and so on, but there are some differences. In the Swift
    programming language, you have to specify the object type that the array contains,
    like we did when we wrote the type between brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create an array of any kind of object, as we used to do in Objective-C,
    by declaring a variable as `[AnyObject]`. However, this should be avoided if it's
    not necessary. There is also the possibility of using NSArray instead of Array;
    in this case, we will have the same methods that we have for Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see something new on the `viewDidLoad` method; we called a closure
    named `map`, and this is because we want to create a big string with every product
    from our catalog delimited by a new line character (`\n`). To do this, we had
    to convert our `Product` array to a `String` array. The `map` function helps us
    with this because we can pass one function as an argument function that converts
    each element into the desired new type.
  prefs: []
  type: TYPE_NORMAL
- en: Another new function is the `filter` function; this function receives another
    function as an argument, which returns a Boolean value. If the returned value
    is true, it means that the current element is valid and shouldn't be filtered;
    if the returned value is false, of course the new array will not contain this
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we have the `sort` function. This function doesn't create
    a new array; it modifies the current one. Consider that, in this case, we have
    an array of our own class, something that the compiler doesn't know how to order.
    In this case, we have to tell this function when two objects are ordered and when
    they are not.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take care when using functions that modify an array; once it's done, you can't
    roll back.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways of declaring an array, one of them is the way we did using
    brackets, and the other form of declaring an array is using `Array<Product>`.
    There is no difference; they create the same kind of object. In both cases, you
    can't inherit from this type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays were declared such as `Type[]` on the first version of Swift, then it
    was replaced by `[Type]`.
  prefs: []
  type: TYPE_NORMAL
- en: There are more array functions that can help us to manipulate the array such
    as `reduce`, `reverse`, or `removeRange`. If you've worked with NoSQL databases,
    you might be habituated to this kind of function. You can also create an array
    extension to manipulate arrays in your own way.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the way out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about tuples. This new type didn't exist in Objective-C
    and it's very useful in Swift, mainly when it's necessary to return more than
    one value. For example, there are a lot of functions that need to return a value
    and an error code. In other languages, we usually return the value and the error
    value is returned as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to use a two-dimensional array, which in Objective-C
    was more complicated. In this case, we will use an array of an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: So, this time, we will create an application that will find the way out of a
    maze. Of course, we will not waste our time designing a maze; we will present
    the result into a text view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Swift single view project called `Chapter 2 Maze`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create the model part of this maze. The maze for us is an array
    with four different possibilities: walls that we can''t pass through, aisles where
    we can walk through, a way out that is our goal, and used, which means that we''ve
    already used this path so we shouldn''t use it again; this will prevent walking
    around in circles. So, the first thing we will do is to create a file called `Maze`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we start implementing our `maze` class, we know that we will need a
    type to store one coordinate of the maze and another one to know whether the path
    was found, and in the case it is found, we should have the path that is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, now it''s time to create our class; in this case, we will need a two-dimensional
    array that represents the maze, another array that will contain the path to the
    way out, and two properties to know the width and the height of the maze:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first method that we will create is the initializer; in this case, it will
    be necessary to create a maze specifying its size. When we create the two-dimensional
    array, we will fill it with `AISLE`; to create walls, we will use another method
    that we will create afterwards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need methods to create the walls and the way out. In a more completed
    case, we should check whether the position is valid or not, but in this case,
    we will not bother ourselves with every detail. So, here are the methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next operation is to create the main method that will try to figure out
    one way to exit from the maze. In this case, the programmer shouldn''t give the
    start point so that this method will have no argument, but we need to walk through
    the maze. However, the idea is to create a recursive function that will receive
    a new position and look for the next position, which is why this second function
    is private:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed by this code that Swift has lazy evaluation. This is a
    good thing because we didn't have to create a nested `if` function when we had
    to check whether the position was inside the array bound.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now it''s time to complete our sample. Go to the storyboard and add a text
    view and a button to it. Link the text view with your code, calling it `textView`.
    Then, create an action for your button, adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of code needs some explanation. Let's start from the beginning. We've
    created an enumeration with four possible values. It is better to use enumerations
    than an integer or a string because you prevent the usage of non-existing values.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we've declared two type aliases; the idea of this instruction is
    to rename a type like we did with `Position` and `Way`. This doesn't create a
    new type but helps us in terms of software maintenance; for example, if you use
    an array of integers that has a possibility of being changed to an array of doubles,
    it's a better idea to use a `typealias` than replace every declaration to `[Double]`.
    This feature is equivalent to `typedef` on the C programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about the attributes. The first attribute is not optional and
    this is inside double brackets, which means that it is a two-dimensional array.
    Usually, by human definition, we say that the first dimension of an array is the
    row and the second is the column.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about positions, for example, in a Cartesian plane, we refer to
    `x` as the columns and `y` as the rows, and this is the reason why you will see
    the `y` coordinate coming before the `x` one, such as `maze[position.y][position.x+1]
    == .AISLE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack is also a non-optional attribute because we don''t need the nil value,
    but this means that we must initialize it with something. As we initialize every
    time when `findWayOut` is called, and the first time it will be initialized twice:
    one on the initializer and another inside the function itself. To prevent this
    double initialization, we will add the `lazy` modifier, which means that it should
    be initialized with the same value in the declaration only the first time that
    this variable is going to be read if it wasn''t initialized before.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It used to be `@lazy` instead of just `lazy` on the first version of Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about the initializer; to create a maze, it's necessary to receive
    the width and the height as arguments. As the arguments have the same name as
    the attributes, it's necessary to differentiate between them. In this case, the
    attributes are called `self.width` and `self.height`, and the arguments are called
    `width` and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is the wildcard expression, which means that the current value
    of the `for` loop is not used. In this case, instead of assigning it to a variable,
    we just use an underscore. Notice that the underscore is used in both loops and
    the inner loop doesn't affect the outer loop, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to create an array in only one line; this should be even
    more efficient because it''s different when you create an array with a capacity
    rather than adding each element one by one. Try replacing both the `for` loops
    with this single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The next two methods are very similar, but one of them has the prefix `add`
    and the other one has the prefix `set`. It's only for software maintenance; we
    can have lots of walls, but only one way out. In this code, we are not checking
    it but it should be checked in the future. In cases like this, instead of a setter,
    we can use a property.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to add here is that when the attributes were assigned, it wasn't
    necessary to specify the enumeration type, such as `BlockType.WALL`, but only
    its value, for example, `.WALL`. The reason for this is that Swift knows the assigned
    type and that it can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the method that will be called to find the way out. It only initializes
    the stack to ensure that it is an empty array and then it calls the `next` function.
    Note that this looks like we have a function with double parentheses, but it's
    not true, we are passing a tuple as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are like arrays with a fixed size. To create it, use parenthesis instead
    of brackets. The interesting feature about tuples in Swift is that you can name
    the values as if it were a dictionary or an object. So, it's up to you to create
    a tuple as `(0,0)` or `(x:0, y:0)`. In cases like the `Way` type, where the elements
    have different meaning, I would suggest that you name the values; otherwise, it
    would be very difficult to remember what the element on the first position represents,
    if there is a path for way out or not, and that the second one represents the
    path itself.
  prefs: []
  type: TYPE_NORMAL
- en: Also, have a look at the view controller when the `findWayOut` method returns
    its values. This looks like that they are assigned to a tuple, but it's not true,
    they are assigned to two variables; this feature we didn't have on C or Objective-C.
    This means that if you want to swap the values of two variables, you can just
    use a sentence, for example, `(var1, var2) = (var2, var1)`, without creating any
    auxiliary variable as we used to do on Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used an array as a stack to store the path that we've already
    walked through, and using the `removeLast` method we could return back a step,
    as if we had some kind of breadcrumb and that is the secret to finding the way
    out. We just need to follow a path, and if we get lost, we only need to collect
    the breadcrumbs and try another one.
  prefs: []
  type: TYPE_NORMAL
- en: 'After finding the goal, the user will see the path as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples in Swift can be used in different ways; they are also very useful in
    some switch cases; however, don't try to substitute dictionaries or arrays with
    tuples, each type has its own function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift 1.2 introduced a native type called `Set` that does what this recipe does.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the included set type in Swift is not enough to solve our problems,
    so in this recipe, we will create our own set. The goal of this recipe is not
    only to show how you could create your own set, but also how to overload operators.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will create a simple shopping list program where the user
    can write the product that he needs to buy and its quantity. If he tries to add
    it twice, the product will not appear twice, rather it will sum the quantity to
    the existing product.
  prefs: []
  type: TYPE_NORMAL
- en: There will be a switch button that when disabled means the user won't be able
    to add the product to the shopping list if it already exists, and of course, there
    will be a button to display our list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, create a new project called `Chapter2 ShoppingList`, and then create
    a Swift file called `ShoppingList`. The idea here is to create our container and
    the type that it will store; in this case, the `Product` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Product is something that is related with our container; we can even say that
    this is like a part of it. So, in this case, we can create a nested class to work
    with it. In this class, we will need only two attributes: its name and its quantity.
    Follow these steps to create your own sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will create its description, and it will implement the `Comparable`
    protocol. We will use this protocol to know whether two objects represent the
    same product. Let''s start coding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create the shopping list attributes. We only need an array to
    store our products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the shopping list is a set, we should implement the basic methods. One method
    is used to add a product and another one is used to know whether the shopping
    list already has a product. And, of course, we will also add the `description`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we compared a product with another using the double equality operator
    (`==`). The main question is how does the compiler make the comparison? Actually,
    the compiler can't make this comparison without the programmer's help. First of
    all, as you can see, we used the `Comparable` protocol in this program. This is
    not really necessary, but it's good to implement this protocol in case we also
    need to use a product with other containers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Even if it''s a comparable, we have to implement a function that will tell
    the runtime whether two products are equals or not. This function must be called
    `==` (yes, double equals), and it must be declared on the global scope: outside
    classes and functions. So, here we have the corresponding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we were implementing only the `Equatable` protocol, we wouldn''t need to
    implement any other method; however, as we are implementing `Comparable`, we will
    also need to implement the operators `<`, `<=`, `>`, and `>=`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we are creating some operators, let''s continue with them. Let''s overload
    the `+=` operator twice, once to add more units to a product and another to add
    a product into the shopping list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that it wasn't necessary to implement any protocol to overload this operator,
    and it wasn't even necessary for the previous operators, but it's a good idea
    to implement the `Comparable` protocol to use with other functions or algorithms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Implement the `Comparable` or `Equatable` protocols when you can use it with
    other generic objects, for example, when you think the object could be ordered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A good feature of Swift is that you don''t need to overload only existing operators;
    you can also create new operators. In this case, we will create two new operators:
    `=>` that will tell us whether a product is in our shopping list and `!=>`, which
    is the opposite operator. I will explain this in detail later. Use these operators
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the model is done, let''s create the view. Enter two text fields:
    one for the product name and another one for the quantity; one switch to allow
    appending products or not; two buttons, one to add the product to the list and
    another one to display the list; and a text view. Let''s connect them, except
    the buttons with the following attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an attribute that represents the application shopping list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to add the button actions. Let''s start with the easiest thing:
    the display button that will show the description of the shopping list into the
    text view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have to create the add button action. In this case, it will be necessary
    to check whether the user introduced a number on the quantity text field and also
    whether it was possible to add the product to the shopping list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `clear` function is just an auxiliary method to empty the text fields every
    time we press the add button:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you can click on play and add some products, repeat some products, and display
    them. You should have a result like the one shown here:![How to do it…](img/00032.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Overloading operators is something very common in Swift; you can overload existing
    operators and you can create your own operator. If you want to create your own
    operator, the first thing you have to do is to report some properties of your
    operator. First, you have to choose if you type the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infix**: This means that the operator is used between two objects; for example,
    in our sample, we created the `!=>` operator to be used between a product and
    a set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prefix**: This means that the operator will operate only with the object
    that is on its right. For example, let''s imagine that we would like to create
    the `!!!` operator, which could mean that we would like to empty the shopping
    list; in this case, we should use it as `!!!shoppingList`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postfix**: This operator will operate only with the object that is on its
    left, such as `shoppingList!!!`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to write the word `operator` and the name you''ve chosen for
    it. After this, you have to add between parentheses the properties of this operator.
    Associativity values are left, right, and none. This is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Left-associative**: This means that when there''s more than one operator
    with the same precedence, the one that is furthest left is going to be evaluated
    first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right-associative**: This, as you can imagine, is the opposite of the left-associative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None-associative**: This means that it''s not permitted to have more than
    one operator with the same precedence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precedence is like a priority. Higher precedence is evaluated first.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift allows changing the function of existing operators, for example, you
    can declare the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make every integer sum operator return `10`. This is something curious,
    but I wouldn''t do that in sane conditions. Even worse than this is if you create
    recursive calls like this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Organizing a dinner room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use other features from the Swift programming
    language. We will copy the range of elements from an array, use dictionaries,
    subscripts, switches, and name a loop.
  prefs: []
  type: TYPE_NORMAL
- en: For this app, we will create a dinner for a company. In this case, it's not
    a wedding table where couples must be seated next to each other, rather we only
    need people of the same group sat together on the same table, probably because
    they are from the same team or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a class that represents a room. To add a new guest into this
    room, we will need to specify the name of someone who belongs to this group, which
    is already inside the room. If the person we want to add to this room is the first
    one, we will use the nil value as the name of the person who belongs to this group.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of adding someone to a table that is full, one person from this
    table must be reallocated to another table. Of course, we won't use the most optimized
    algorithm because that's not our main goal.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Swift single view project called `Chapter2 DinnerRoom`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we need to start with the model part of the Model-View-Controller.
    For this code, we will need a class for the room, another for a table that will
    store the seats with the person that is seated there, a group, which is the range
    of the table of people that belongs to the same team, and of course, we will also
    need a class to represent a person.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `person` class; in this case, we only need to store his
    name and the group he belongs to. As there is a period where the person can be
    without any group, this attribute should be optional. So, create a new Swift file
    called `person.swift` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this class inherits from the `Equatable` protocol, which means
    that we must implement the `==` operator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, now let''s create the `Group` class. Remember that a group doesn''t have
    a name; it''s just a range of people who are sitting together. In this case, we
    need to store where the range starts, where it finishes, and its table. As you
    may imagine, we need to create a file called `group.swift` and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `size` property has no setters, only a getter, and it's not related
    with a new attribute; that's what is called a `computed` property. Also, note
    that we had to add an `unowned` modifier to the `table` attribute; this is because
    if we had a UML class diagram, we can see that a room contains tables that contain
    people who belong to a group that knows its table. As you can see, we have a cycle,
    which by default would prevent the reference counter from reaching zero, and as
    a consequence, it would create a memory leak. Adding `unowned` will help us to
    avoid this problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next class is `Room`. This class needs to store its tables and also the
    guests that are already in the room. This second attribute is not mandatory, but
    it is faster for the computer looking into a dictionary than searching for it,
    and it is also faster for the programmer because he will write less code. Add
    `room.swift` to your project and start adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, look at the `guests` attribute, as we have two types between brackets
    and separated by a colon; this means that it''s not an array, it''s a dictionary.
    Alternatively, you can also write `Dictionary<String,Person>` instead of `[String:
    Person]`. One difference with dictionaries from Objective-C to Swift is that you
    must specify the key and the value types.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When possible, try to use dictionaries instead of searching for elements, as
    you will have a better performance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are a good observer, you can see that we repeated the `add` function.
    The difference is on the arguments type. This means that you can overload methods
    and functions in Swift.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to check whether someone is already in this room, we will use the brackets
    operator so we can type code such as `if room["Harry Potter"] == true {...`. To
    enable it in Swift, we have to write some kind of special function called subscript.
    In this case, we will write a read-only `subscript`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we only need to use the same idea to add someone in the room; remember
    that we have to specify someone''s name from the same group or nil when it''s
    the first person. Following this idea, we can add someone into the room with a
    code similar to `room["Harry Potter"] = Person("David Copperfield")`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we added an assertion into the getter method of the subscript;
    the reason is that subscripts can be read-only or read-write but they can't be
    write-only. In this case, there is no sense in asking for a return value, so the
    only thing we can do is to create an assertion to prevent problems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't use `assertionFailure` regularly; try to create code that can detect errors
    and continue to work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file called `table.swift`. Before we start coding the `Table`
    class, we need to know that a table will have an array of seats. We can have a
    free seat or an occupied one. If it''s occupied, it''s by someone, so we need
    to know who is occupying the seat. For cases such as this, Swift allows us to
    use enumerations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only problem with enumeration is that we need to use `switch` cases a lot
    of times, so in this case, where we want to know whether one seat is free or occupied
    by someone, it''s a good idea to overload the operators `==` and `!=`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can start typing the `Table` class. Basically, we need to store an array
    of seats, but we can have some auxiliary computed properties and methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before giving much explanation, we will test the previous code by adding `textView`
    to our view controller and some people into `room.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, we used some new features here. We were able to copy a range
    of seats using the `…` operator, which is an awesome feature that can save us
    from typing a lot of loops that do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this slice operator (`…`), when working with a part of an array, the
    compiler can create a good optimization for a better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good feature is the `switch` statement that can work with a combination
    of values. Look at the `==` operator and you''ll see that we don''t need to create
    inner switched cases for each case. Talking about the equalities operator, have
    a look at the `add` method that we used: `!==` instead of `!=`. The reason is
    that when we need to check whether two objects have the same instance, we have
    to use the operator `===` or `!==` to check whether they don''t share the same
    instance.'
  prefs: []
  type: TYPE_NORMAL
- en: We also used a label to name a loop (searching), the reason for that is, by
    default, the `break` statement will exit from the switch, not from our loop. We
    can control this situation with some Boolean variables, but we can avoid it breaking
    with `break searching`.
  prefs: []
  type: TYPE_NORMAL
- en: Another good trick was walking in the reverse way on our arrays. We did it using
    the method reverse. Of course, we did it knowing that we have a small array; I
    can't imagine a table for one million people. Using reverse with big arrays is
    not a good idea because a new array will be created internally.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can still use the old `NSDictionary` class, but I will follow the same rule
    that we saw with `NSArray`. Swift dictionaries are safer, and if you need a dictionary,
    store completely different object types. It would be better to review your code
    as it could be very painful to maintain this code.
  prefs: []
  type: TYPE_NORMAL
- en: You have only just started learning about assertions, but further on in this
    book, you will learn how to deal with assertions.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to work with functions without specifying the input or output
    type, Swift gives you the feature of generics. We will learn more about this in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
