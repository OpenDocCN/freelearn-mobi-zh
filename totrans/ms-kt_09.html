<html><head></head><body><div><div><div><h1 id="_idParaDest-100" class="chapter-number"><a id="_idTextAnchor112"/>9</h1>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor113"/>Runtime Permissions</h1>
			<p>As we build our Android apps, there are some functionalities that require permissions to be granted for them to function properly. Due to privacy and data security policies, we as developers can not automatically grant permissions to the apps that we develop. We need to inform the users of the permissions that the apps need and why they need them.</p>
			<p>In this chapter, we will understand runtime permissions and how to request them in our app.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Understanding runtime permissions</li>
				<li>Requesting permissions at runtime</li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor114"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine</a>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor115"/>Understanding runtime permissions</h1>
			<p><code>requestPermissions()</code> and <code>checkSelfPermission()</code>. The user only needs to grant permission once during the lifetime of the app.</p>
			<p>Some of the features that need permission to be granted to work are camera, location, microphone and storage. Before using them, ensure that a user has permission to use them. If the user has not granted permission, you must request it from them. If the user has denied the permission, you must show a dialog explaining why you need it and ask the user to grant it from the settings. If the user has granted permission, you can use the feature. Failing to do these checks often results in an app crashing or a feature not working. If your app targets <a id="_idIndexMarker463"/>Android 6.0 and above, you must request these permissions at runtime, and the user must grant the permission for the app to work.</p>
			<p>The flow for requesting<a id="_idIndexMarker464"/> permissions is shown in the following chart:</p>
			<div><div><img src="img/B19779_09_01.jpg" alt="Figure 9.1 – The runtime permissions flow" width="1121" height="791"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The runtime permissions flow</p>
			<p>As shown in the preceding diagram, this is the flow:</p>
			<ol>
				<li>The initial step is to <em class="italic">declare</em> the permission in the manifest file. This is done by adding the permission to the manifest file.</li>
				<li>After adding the permission to the manifest file, we must <em class="italic">design the UX</em> for the feature that needs <a id="_idIndexMarker465"/>the permission to be granted.</li>
				<li>The next step is <em class="italic">waiting for the user to use</em> the feature that needs permission to be granted. At this point, we check whether the user has granted permission. If the user has granted permission, we proceed to use the feature.</li>
				<li>If the user <em class="italic">has not granted permission</em>, we first check whether we need to <em class="italic">show a rationale</em> that explains why we need permission. If we need to show the rationale, we show it with explanations and then request permission from the user. If we do not need to show the rationale, we just request permission from the user.</li>
				<li>Once the permission is requested, we wait for the <em class="italic">user to grant or deny</em> permission. If the user grants permission, we proceed to use the feature. If the user denies permission, we allow the app to work, but the user cannot use the feature that needs permission to work.</li>
			</ol>
			<p>With this flow in mind, let us look at how to implement it in code. We are going to request permission to access a location.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor116"/>Requesting permissions at runtime</h1>
			<p>We will follow the<a id="_idIndexMarker466"/> steps covered in <em class="italic">Figure 9</em><em class="italic">.1</em> to request runtime permissions for our app:</p>
			<ol>
				<li>Let us start by adding the permission to the manifest file. We will request permission to access the user’s location. To do this, we add the following permission to the manifest file:<pre class="source-code">
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;</pre><p class="list-inset">This specifies that our app will be using the <code>ACCESS_COARSE_LOCATION</code> permission. Declaring permissions in the manifests is crucial for enhancing security, user awareness, and overall app compatibility. By explicitly specifying the actions or resources apps require access to permissions informs users during installations, allowing them to make informed decisions about granting or denying access. This declaration ensures compatibility across different Android versions and devices, facilitates inter-app communication, and supports intent filtering to control <a id="_idIndexMarker467"/>component access. Permissions also play a role in runtime permission requests for dangerous permissions and help maintain platform compatibility. Additionally, Play Store reviews declare permissions as part of the submission process, contributing to adherence to policies and guidelines. In essence, manifest-based permission declarations are fundamental for creating secure, transparent, and user-controlled environments in our apps.</p><p class="list-inset">The next thing is to create the UX for the feature that needs permission. We will create a dialog to request permissions from the user. It will also have the logic that shows the rationale to the user if permission was previously denied.</p></li>				<li>Let’s create a new file in the <code>view</code> package named <code>PermissionDialog.kt</code> and add the utility functions to the file:<pre class="source-code">
fun checkIfPermissionGranted(context: Context, permission: String): Boolean {
    return (ContextCompat.checkSelfPermission(context, permission)
            == PackageManager.PERMISSION_GRANTED)
}
fun shouldShowPermissionRationale(context: Context, permission: String): Boolean {
    val activity = context as Activity?
    if (activity == null)
        Log.d("Permissions", "Activity is null")
    return ActivityCompat.shouldShowRequestPermissionRationale(
        activity!!,
        permission
    )
}</pre><p class="list-inset">The first function checks whether the permission has been granted using the <code>ContextCompat.checkSelfPermission()</code> function. The second function checks whether <a id="_idIndexMarker468"/>we need to show the rationale to the user. This is done using the <code>ActivityCompat.shouldShowRequestPermissionRationale()</code> function. This function returns <code>true</code> if the app has requested this permission previously and the user denied the request. If the user turned down the permission request in the past and chose the <code>false</code>.</p><p class="list-inset">Next, let us create a sealed class that will be used to represent the state of the permission request.</p></li>				<li>Create a new file named <code>PermissionAction.kt</code> in the <code>data</code> package, and add the following code to the file:<pre class="source-code">
sealed class PermissionAction {
    data object PermissionGranted : PermissionAction()
    data object PermissionDenied : PermissionAction()
}</pre><p class="list-inset">The class has two states, <code>PermissionGranted</code> and <code>PermissionDenied</code>. A user can either grant or deny permission.</p></li>				<li>Next, let us create <a id="_idIndexMarker469"/>the dialog that will be used to request permission from the user. Head back to the <code>PermissionDialog.kt</code> file and add the following code to the file:<pre class="source-code">
@Composable
fun PermissionDialog(
    context: Context,
    permission: String,
    permissionAction: (PermissionAction) -&gt; Unit
) {
    val isPermissionGranted = checkIfPermissionGranted(context, permission)
    if (isPermissionGranted) {
        permissionAction(PermissionAction.PermissionGranted)
        return
    }
    val permissionsLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean -&gt;
        if (isGranted) {
            permissionAction(PermissionAction.PermissionGranted)
        } else {
            permissionAction(PermissionAction.PermissionDenied)
        }
    }
    val showPermissionRationale = shouldShowPermissionRationale(context, permission)
    var isDialogDismissed by remember { mutableStateOf(false) }
    var isPristine by remember { mutableStateOf(true) }
    if ((showPermissionRationale &amp;&amp; !isDialogDismissed) || (!isDialogDismissed &amp;&amp; !isPristine)) {
        isPristine = false
        AlertDialog(
            onDismissRequest = {
                isDialogDismissed = true
                permissionAction(PermissionAction.PermissionDenied)
            },
            title = { Text(text = "Permission Required") },
            text = { Text(text = "This app requires the location permission to be granted.") },
            confirmButton = {
                Button(
                    onClick = {
                        isDialogDismissed = true
                        permissionsLauncher.launch(permission)
                    }
                ) {
                    Text(text = "Grant Access")
                }
            },
            dismissButton = {
                Button(
                    onClick = {
                        isDialogDismissed = true
                        permissionAction(PermissionAction.PermissionDenied)
                    }
                ) {
                    Text(text = "Cancel")
                }
            }
        )
    } else {
        if (!isDialogDismissed) {
            SideEffect {
                permissionsLauncher.launch(permission)
            }
        }
    }
}</pre><p class="list-inset">Let’s break down the preceding code:</p><ul><li>We have created a composable, <code>PermissionDialog</code>, which takes three parameters, <code>context</code>, <code>permission</code> string, and a <code>permissionAction</code> callback, which passed the option the user selected to the call site.</li><li>Inside the <a id="_idIndexMarker470"/>composable, the first thing we do is check whether permission has been granted. If permission has been granted, we call the <code>permissionAction</code> callback with the <code>PermissionGranted</code> state and return.</li><li>Next, we also created <code>permissionsLauncher</code>, which is used to request permission from the user. We use the <code>rememberLauncherForActivityResult()</code> function to create a launcher for the contract. We then use the launcher to request permission from the user. If the user grants the permission, we call the <code>permissionAction</code> callback with the <code>PermissionGranted</code> state. If the user denies the permission, we call the <code>permissionAction</code> callback with the <code>PermissionDenied</code> state.</li><li>If the permission has not been granted, we check whether we need to show the rationale to the user. If we need to, we show the rationale with explanations and then request permission from the user. If we do not need to show the rationale, we must request permission from the user. In our case, the rationale is <code>AlertDialog</code>, with two action items and a message explaining why we need the permission. The first action item is used to request permission from the user. The second action item is used to cancel the permission request. If we tap the <code>permissionAction</code> callback is called with the <code>PermissionDenied</code> state, and the dialog is dismissed. We also have two mutable states, <code>isDialogDismissed</code> and <code>isPristine</code>. The first is used to check whether the dialog has been dismissed. The second one let’s know whether the dialog was shown before. We use these states combined to know whether to show the dialog or not.</li><li>Lastly, if we do not need to show the rationale, we just request permission from the user. We<a id="_idIndexMarker471"/> use <code>SideEffect</code> to request permission from the user because we want to request permission from the user as soon as the dialog is shown.</li></ul><p class="list-inset">Since we do not have an actual feature in our app currently that uses location, we are going to simulate permission flow with our <code>PetsScreen</code> composable.</p></li>				<li>Let’s head to the <code>PetsScreen.kt</code> file and modify it to the following:<pre class="source-code">
@Composable
fun PetsScreen(
    onPetClicked: (Cat) -&gt; Unit,
    contentType: ContentType,
) {
    val petsViewModel: PetsViewModel = koinViewModel()
    val petsUIState by petsViewModel.petsUIState.collectAsStateWithLifecycle()
    val context = LocalContext.current
    var showContent by rememberSaveable { mutableStateOf(false) }
    PermissionDialog(
        context = context,
        permission = Manifest.permission.ACCESS_COARSE_LOCATION
    ) { permissionAction -&gt;
        when (permissionAction) {
            is PermissionAction.PermissionDenied -&gt; {
                showContent = false
            }
            is PermissionAction.PermissionGranted -&gt; {
                showContent = true
                Toast.makeText(
                    context,
                    "Location permission granted!",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }
    if (showContent) {
        PetsScreenContent(
            modifier = Modifier
                .fillMaxSize(),
            onPetClicked = onPetClicked,
            contentType = contentType,
            petsUIState = petsUIState,
            onFavoriteClicked = {
                petsViewModel.updatePet(it)
            }
        )
    }
}</pre><p class="list-inset">We have only made a few changes to this file:</p><ul><li>First, we have added a <code>showContent</code> mutable state that is used to check whether we should show the content of the screen. We have also set the initial value of the state to <code>false</code>. We will use this state to show the content of the screen if<a id="_idIndexMarker472"/> the user grants permission. We also have the <code>context</code> variable used to get the screen’s context.</li><li>We have also added the <code>PermissionDialog</code> composable to the <code>PetsScreen</code> composable. We have passed the context and the permission – in this case, the <code>ACCESS_COARSE_LOCATION</code> permission – to the composable. We have also passed a callback to the composable that is used to get the state of the permission request. If the user grants the permission, we set the <code>showContent</code> state to <code>true</code> and show a toast with the <code>showContent</code> state to <code>false</code>.</li><li>Lastly, we have added a check to see whether the <code>showContent</code> state is <code>true</code>. If the state is <code>true</code>, we show the content of the screen. If the state is <code>false</code>, we do not show the content of the screen.</li></ul></li>				<li>Build and run the app. At first, we<a id="_idIndexMarker473"/> will see the permission dialog, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19779_09_02.jpg" alt="Figure 9.2 – The permission dialog" width="503" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The permission dial<a id="_idTextAnchor117"/>og</p>
			<ol>
				<li value="7">Tap the <strong class="bold">Don’t allow</strong> option, which will show an empty white screen, since we don’t show any content when the user has not granted the app permission.</li>
			</ol>
			<div><div><img src="img/B19779_09_03.jpg" alt="Figure 9.3 – The no permission screen" width="503" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The no permission screen</p>
			<p class="list-inset">The next time we run the<a id="_idIndexMarker474"/> app, we will see the rationale dialog showing why the app needs permission.</p>
			<div><div><img src="img/B19779_09_04.jpg" alt="Figure 9.4 – The permission rationale" width="499" height="1099"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The permission rationale</p>
			<p class="list-inset">On this rationale dialog, we can either cancel the request or grant access. Tapping the <strong class="bold">Grant Access</strong> option should bring up the permission dialog shown in <em class="italic">Figure 9</em><em class="italic">.2</em>, and by tapping the <strong class="bold">While using the app</strong> option, we grant the app the location <a id="_idIndexMarker475"/>permission, and now, we should be able to see the list of cute cats o<a id="_idTextAnchor118"/>nce again. Running the app again does not show the dialogs, since we have already granted the app the location permission.</p>
			<div><div><img src="img/B19779_09_05.jpg" alt="Figure 9.5 – Cute cats" width="499" height="1099"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Cute cats</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor119"/>Summary</h1>
			<p>In this chapter, we explored what runtime permissions are and why we should declare and request permissions in our apps. Step by step, we learned how to request runtime permissions in our app and how to show permission rationale dialogs, explaining to users why we need access to runtime permissions in cases where they have denied apps access to permissions.</p>
			<p>In the next chapter, we will learn debugging tips and tricks, how to detect leaks using LeakCanary, how to inspect HTTPS requests/responses fired by our app using Chucker, and how to inspect the Room database.</p>
		</div>
	</div></div>
<div><div><div><h1 id="_idParaDest-106" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor120"/>Part 3: Code Analysis and Tests</h1>
			<p>In this part, you will gain proficiency in debugging through a series of valuable tips and tricks. Unveiling the intricacies, you will discover techniques for detecting memory leaks within your app and adeptly inspecting HTTP requests triggered by your application. Our exploration extends to inspecting your local database, offering insights into its inner workings. Diving into Kotlin best practices, you will delve into code analysis for your application, addressing code smells for enhanced code quality. This part also includes a comprehensive exploration of testing methodologies, empowering you to seamlessly integrate tests across various layers of your MVVM architecture.</p>
			<p>This section contains the following chapters:</p>
			<ul>
				<li><a href="B19779_10.xhtml#_idTextAnchor121"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging Your App</em></li>
				<li><a href="B19779_11.xhtml#_idTextAnchor135"><em class="italic">Chapter 11</em></a>, <em class="italic">Enhancing Code Quality</em></li>
				<li><a href="B19779_12.xhtml#_idTextAnchor157"><em class="italic">Chapter 12</em></a>, <em class="italic">Testing Your App</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</div></div></body></html>