<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Let's Build a Platformer!"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Let's Build a Platformer!</h1></div></div></div><p>Now that we're familiar with handling input and assets, why don't we build a platformer prototype? This should be a nice challenge that will introduce us to some more concepts and ways to work with Moai SDK.</p><p>In order to build this game, we'll copy the full content of the previous chapter's code and clean everything from <code class="literal">game.lua</code> that is specific to the <span class="emphasis"><em>Concentration</em></span> game.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Remove all the constants on the top of the file, the definition for the tile (but keep <code class="literal">resource_definitions</code> since we're going to use it).</li><li class="listitem" style="list-style-type: disc">Remove <code class="literal">self.wasClicking = false</code> from the <code class="literal">Game:start ()</code> method.</li><li class="listitem" style="list-style-type: disc">Remove the calls to <code class="literal">initializeTiles</code> and <code class="literal">restartGamePlay</code> from <code class="literal">Game:initialize ()</code>.</li><li class="listitem" style="list-style-type: disc">Remove the methods <code class="literal">Game:initializeTiles()</code>, <code class="literal">Game:restartGamePlay ()</code>, <code class="literal">Game:choseCell ()</code>, <code class="literal">Game:alreadySelectedTile()</code>, <code class="literal">Game:swapTile ()</code>, <code class="literal">Game:resetTiles ()</code>, and <code class="literal">Game:removeTiles()</code>.</li></ul></div><p>That should be it; now you should be good to go.</p><div class="section" title="Background"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Background</h1></div></div></div><p>We're going to <a id="id177" class="indexterm"/>insert a <a id="id178" class="indexterm"/>background to our screen:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we're going to do is display a background. This should be pretty easy for you right now. A good idea will be searching <a class="ulink" href="http://www.opengameart.org">www.opengameart.org</a> for a suitable background. That's what has been done in the code for this chapter, and you'll find a background in there.</li><li class="listitem">Let's add the definition. If you're using an image other than the one provided in the book's code, just go ahead and change the dimensions and filename (this code should go inside <code class="literal">resources_definition</code>):<div class="informalexample"><pre class="programlisting">  background = {
    type = RESOURCE_TYPE_IMAGE, 
    fileName = 'background/wizardtower.png', 
    width = 1000, height = 700
  },</pre></div></li><li class="listitem">Now, let's add a line at the bottom of the <code class="literal">initialize ()</code> method<a id="id179" class="indexterm"/> to load the background:<div class="informalexample"><pre class="programlisting">self:loadBackground ()</pre></div></li><li class="listitem">And <a id="id180" class="indexterm"/>now let's <a id="id181" class="indexterm"/>define that method:<div class="informalexample"><pre class="programlisting">function Game:loadBackground()
  
  self.background = {}
  self.background.deck = ResourceManager:get('background')
  
  local prop = MOAIProp2D.new ()
  prop:setDeck (self.background.deck)
  prop:setLoc (0, 0)

  self.background.prop = prop
  
  self.layer:insertProp (prop)
  
end</pre></div></li></ol></div><p>This is nothing new, right? It's the same thing we did to load an image in <a class="link" href="ch05.html" title="Chapter 5. Showing Images on the Screen">Chapter 5</a>, <span class="emphasis"><em>Showing Images on the Screen</em></span>.</p><p>Now, let's play with the camera and scroll it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Take into account the platform you're targeting when loading backgrounds.</p><p>The maximum texture size differs according to the <a id="id182" class="indexterm"/>
<span class="strong"><strong>Shader Model</strong></span>. You will be safe if you're using textures that are 1024 x 1024 or smaller; if you find yourself having textures that don't show up on the screen, double-check this. Remember that you can always split the textures into smaller ones and load several of them in different Props. We ran into this problem with the second scene in <span class="emphasis"><em>The Insulines</em></span>; it wasn't working on some computers because it was huge, so we had to split it.</p></div></div></div></div>
<div class="section" title="Camera and scrolling"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Camera and scrolling</h1></div></div></div><p>If you're planning to create games in 2D, an important thing to master is how to use a camera, and that's what we'll do now.</p><p>Enter this code at the<a id="id183" class="indexterm"/> beginning of <code class="literal">Game:initialize ()</code> in <code class="literal">game.lua</code>:</p><div class="informalexample"><pre class="programlisting">  self.camera = MOAICamera2D.new ()</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">What we're doing here is creating a new camera using the built-in<a id="id184" class="indexterm"/> <code class="literal">MOAICamera2D</code> class.</li><li class="listitem">Next, we need to assign that camera to each layer. Below the viewport assignment <code class="literal">(self.layer:setViewport ( viewport ))</code>, add the following line of code:<div class="informalexample"><pre class="programlisting">  self.layer:setCamera ( self.camera )</pre></div><p>This binds the layer to that camera. And that's it; when you move the camera, you'll see that the viewport will follow, and if you scale the camera up and down, it will zoom in and zoom out accordingly. We'll write a few lines to demonstrate this.</p></li><li class="listitem">Inside <code class="literal">Game:processInput ()</code> write the following code:<div class="informalexample"><pre class="programlisting">  local x, y = InputManager:deltaPosition () </pre></div><p>We are using a method from <code class="literal">InputManager</code> that returns the difference between the current mouse position and the previous one.</p><div class="informalexample"><pre class="programlisting">  self.camera:moveLoc ( x, 0, 0.5, MOAIEaseType.LINEAR )</pre></div></li></ol></div><p>We move the camera using the <code class="literal">moveLoc ()</code> method <a id="id185" class="indexterm"/>and passing the delta in <code class="literal">x</code>, nothing in <code class="literal">y</code>. The third parameter tells <code class="literal">moveLoc ()</code> to take half-a-second to do the movement. The third parameter is used to define the curve of the animation, in this case, we're making it linear, so it will make a movement that is constant in speed. We'll go more into this later.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>
<code class="literal">MOAIEaseType</code> <a id="id186" class="indexterm"/>defines a bunch of useful curves for our animations; you can check them out at <a class="ulink" href="http://getmoai.com/docs/class_m_o_a_i_ease_type.html">http://getmoai.com/docs/class_m_o_a_i_ease_type.html</a>.</p></div></div><p>If you run the game now, you'll see that when you move the mouse, the background scrolls to the left and right. That's a consequence of the camera being moved.</p><p>So, instead of moving all of the objects on screen, you just move the camera when you want to scroll.</p><p>What we can do later is scroll the camera to follow our character's movements.</p><div class="section" title="Parallax"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec28"/>Parallax</h2></div></div></div><p>Parallax<a id="id187" class="indexterm"/> is an effect that's often used (and abused) in games because it creates a feeling of depth in 2D scenes. The main idea is to create layers of images, which are at different distances, which move at different speeds when scrolling. This mimics what happens in reality with objects that are at different distances from a viewer (the objects far away move slower than the near ones).</p><p>We can achieve this by splitting the<a id="id188" class="indexterm"/> background into <a id="id189" class="indexterm"/>different images (each one representing a different plane).</p><div class="mediaobject"><img src="graphics/5064_08_01.jpg" alt="Parallax"/></div><p>Here we see the old background split into three layers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A cloudy background</li><li class="listitem" style="list-style-type: disc">A tower that is far away</li><li class="listitem" style="list-style-type: disc">Some hills that are nearer</li></ul></div><p>Now, what we need to do is make them move at different speeds.</p></div><div class="section" title="Setting up the layers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec29"/>Setting up the layers</h2></div></div></div><p>In Moai SDK, you can implement this using a<a id="id190" class="indexterm"/> <code class="literal">MOAILayer2D</code> method <a id="id191" class="indexterm"/>called <code class="literal">setParallax ()</code>.</p><p>Let's take a look at it.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As we saw, we'll need a couple of layers to do this. We'll replace our current layer with a table of layers. On <code class="literal">Game:initialize ()</code>, replace the lines for the layer initialization with a call to <code class="literal">self:setupLayers ()</code>.</li><li class="listitem">Then we <a id="id192" class="indexterm"/>create the actual method:<div class="informalexample"><pre class="programlisting">function Game:setupLayers ()
  
  self.layers = {}
  self.layers.background = MOAILayer2D.new ()
  self.layers.farAway = MOAILayer2D.new ()
  self.layers.main = MOAILayer2D.new ()</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll create a layer per depth plane that we want. We'll use three planes in this example: a background, a far away plane, and a main plane. (Our character and all of the game objects should go inside the main plane)<div class="informalexample"><pre class="programlisting"> for key, layer in pairs ( self.layers ) do
    layer:setViewport ( viewport )
    layer:setCamera ( self.camera )
  end</pre></div></li><li class="listitem">Then we iterate through all of the layers and assign the viewport and the camera correctly.<div class="informalexample"><pre class="programlisting">  local renderTable = {
    self.layers.background,
    self.layers.farAway,
    self.layers.main
  }</pre></div></li><li class="listitem">Now, we create a render table with the layers in order.<div class="informalexample"><pre class="programlisting">  MOAIRenderMgr.setRenderTable(renderTable)
end</pre></div></li><li class="listitem">We'll then make it active.</li></ol></div></li></ol></div><p>Now we have our layers ready to play with parallax.</p></div><div class="section" title="Adding images to the different distances"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec30"/>Adding images to the different distances</h2></div></div></div><p>Now we'll show<a id="id193" class="indexterm"/> images <a id="id194" class="indexterm"/>on each layer for you to see how cool this is:</p><div class="informalexample"><pre class="programlisting">local resource_definitions = {
 
  background = {
    type = RESOURCE_TYPE_IMAGE, 
    fileName = 'background/background_parallax.png', 
    width = 1500, height = 197,
  },
  
  farAway = {
    type = RESOURCE_TYPE_IMAGE, 
    fileName = 'background/far_away_parallax.png', 
    width = 625, height = 205,
  },

  main = {
    type = RESOURCE_TYPE_IMAGE, 
    fileName = 'background/main_parallax.png', 
    width = 975, height = 171,
  },

}</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">These <a id="id195" class="indexterm"/>are the three resource definitions we'll need: <a id="id196" class="indexterm"/>one for each layer. The images can be found in the source code for this chapter.<p>There is some more information that we'll need, but instead of adding it into the <code class="literal">resource_definitions</code> table, we'll create another table. Even if the objects and definitions look the same, there is a slight conceptual difference between them, so it is better to keep them separated. </p></li><li class="listitem">Write the following code below the <code class="literal">resource_definitions</code> table:<div class="informalexample"><pre class="programlisting">local background_objects = {
  
  background = {
    position = { 0, 70 },
    parallax = { 0.05, 0.05 }
  },
  
  farAway = {
    position = { 0, 50 },
    parallax = { 0.1, 0.1 }
  },
  
  main = {
    position = { 0, -75 },
    parallax = { 1, 1 }
  },
  
}</pre></div><p>What we're doing here is defining the position and the parallax information for each object we're creating. Well, strictly, the parallax is for the layer that contains the object.</p></li><li class="listitem">Now, we'll rewrite <code class="literal">Game:loadBackground ()</code> to look like the following:<div class="informalexample"><pre class="programlisting">function Game:loadBackground ()
  
  self.background = {}
  
  for name, attributes in pairs(background_objects) do</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We iterate through all the things we defined in <code class="literal">background_objects</code>:<div class="informalexample"><pre class="programlisting">    local b = {}
    b.deck = ResourceManager:get ( name )</pre></div></li><li class="listitem">We <a id="id197" class="indexterm"/>load <a id="id198" class="indexterm"/>the deck using the keys from the <code class="literal">background_objects</code> table.<div class="informalexample"><pre class="programlisting">    b.prop = MOAIProp2D.new ()
    b.prop:setDeck ( b.deck )
    b.prop:setLoc ( unpack(attributes.position) )</pre></div></li><li class="listitem">Here we use the position attribute we defined in <code class="literal">background_objects</code>:<div class="informalexample"><pre class="programlisting">    self.layers[name]:insertProp ( b.prop )
self.layers[name]:setParallax ( unpack(attributes.parallax) )</pre></div></li><li class="listitem">And here we make use of <code class="literal">setParallax</code> and use the parallax attribute we defined in background objects:<div class="informalexample"><pre class="programlisting">    self.background[name] = b
  end
  
end</pre></div></li></ol></div></li></ol></div><p>And that's it, we're now good to go. Run the game and move the mouse. You should now see the three different layers moving at different speeds.</p><p>Now we are ready to add the main character, so let's jump straight to that!</p></div></div>
<div class="section" title="Main character"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Main character</h1></div></div></div><p>In order to create our character<a id="id199" class="indexterm"/>, we'll need a sprite sheet with animations for walking, running, and jumping.</p><p>It should look something like the following image:</p><div class="mediaobject"><img src="graphics/5064_08_02.jpg" alt="Main character"/></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we'll create a resource definition as follows (put this below the background resource definition):<div class="informalexample"><pre class="programlisting">  character = {
    type = RESOURCE_TYPE_TILED_IMAGE,
    fileName = 'character/character.png',
    tileMapSize = {20, 6},
    width = 64, height = 64,
  }</pre></div><p>This is pretty much the same as we used for our <span class="emphasis"><em>Concentration</em></span> game, but note that we added <code class="literal">width</code> and <code class="literal">height</code>. That's the size of the tile. In the <span class="emphasis"><em>Concentration</em></span> game, we defined the size of the tile in the grid, but now there is no grid, so we need to define it here.</p></li><li class="listitem">In order to handle that definition, we need to add some lines to <code class="literal">resource_manager.lua</code>, inside <code class="literal">loadTiledImage</code>, just below the call to <code class="literal">setSize()</code>:<div class="informalexample"><pre class="programlisting">  if definition.width and definition.height then
    local half_width = definition.width / 2
    local half_height = definition.height / 2
    tiledImage:setRect ( -half_width, -half_height, half_width, half_height )
  end</pre></div><p>The preceding code is similar to that in <code class="literal">loadImage</code>; the difference is that we divide <code class="literal">width</code> and <code class="literal">height</code> by two and use the resulting values as the rectangle's dimensions.</p></li><li class="listitem">Let's create a file called <code class="literal">character.lua</code> to start creating our character (don't forget to <code class="literal">require</code> that file in <code class="literal">game.lua</code>) and add the following code to it:<div class="informalexample"><pre class="programlisting">module ( "Character", package.seeall )

local character_object = {
  position = { 0, 0 },
}
This table will be used to setup some initialization parameters.
function Character:initialize (layer)
  self.deck = ResourceManager:get ( 'character' )
  self.prop = MOAIProp2D.new ()
  self.prop:setDeck ( self.deck )
  self.prop:setLoc ( unpack(character_object.position) )
  layer:insertProp ( self.prop )
end</pre></div></li></ol></div><p>This is basically the<a id="id200" class="indexterm"/> same as what we've been doing in order to load images on screen; the important part here is that initialize receives a layer as a parameter and adds the Prop to that layer. Can you guess why?</p><p>Here is the reason: put the following line at the bottom of <code class="literal">Game:initialize ()</code> in <code class="literal">game.lua</code> (just below the call to <code class="literal">loadBackground</code>):</p><div class="informalexample"><pre class="programlisting">  Character:initialize ( self.layers.main )</pre></div><p>And voilà, we have our character on screen. Loving it? I think it's pretty static. Let's add some animations.</p><div class="section" title="Animations"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec31"/>Animations</h2></div></div></div><p>Now we are going to work on <a id="id201" class="indexterm"/>the animations. We'll introduce three <a id="id202" class="indexterm"/>new classes in this section: <a id="id203" class="indexterm"/>
<code class="literal">MOAIDeckRemapper</code>,<a id="id204" class="indexterm"/> <code class="literal">MOAIAnimCurve</code>, and<a id="id205" class="indexterm"/> <code class="literal">MOAIAnim</code>. Let's see how these interact.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, on the <code class="literal">character_object</code> table on <code class="literal">character.lua</code>, let's add the following (below position):<div class="informalexample"><pre class="programlisting">animations = {
    idle = {
      startFrame = 1,
      frameCount = 9,
      time = 0.1,
      mode = MOAITimer.LOOP
    },
    
    run = {
      startFrame = 41,
      frameCount = 16,
      time = 0.03,
      mode = MOAITimer.LOOP
    },
     
    jump = {
      startFrame = 89,
      frameCount = 3,
      time = 0.1,
      mode = MOAITimer.NORMAL
    },
  }</pre></div><p>This is the definition for the three animations we're going to use. Take a look at it and see <a id="id206" class="indexterm"/>that we define a start frame (the tileset index where the animation starts), the frame count (the amount of frames for the animation; these frames need to be sequentially placed in the tileset, as per the preceding example), the time between each frame, and the animation mode.</p><p>Similar to <code class="literal">MOAIEaseType</code>, <code class="literal">MOAITimer</code> has a bunch of different animation modes. You can check them out at <a class="ulink" href="http://getmoai.com/docs/class_m_o_a_i_timer.html">http://getmoai.com/docs/class_m_o_a_i_timer.html</a>.</p></li><li class="listitem">Then, we need <a id="id207" class="indexterm"/>to add a <code class="literal">MOAIDeckRemapper</code>. <code class="literal">MOAIDeckRemapper</code> <a id="id208" class="indexterm"/>is used in combination with an animation curve in order to tell the Prop which tileset index should be displayed in each animation step. Enter the following code in <code class="literal">Character:initialize()</code>:<div class="informalexample"><pre class="programlisting">  self.remapper = MOAIDeckRemapper.new ()
  self.remapper:reserve ( 1 )</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll remap just one index (the character animation frame), so we reserve just one remapper index.<div class="informalexample"><pre class="programlisting">  self.prop:setRemapper ( self.remapper )</pre></div></li><li class="listitem">Then we assign the remapper to the Prop.</li></ol></div><div class="mediaobject"><img src="graphics/5064_08_03.jpg" alt="Animations"/></div><p>For the <a id="id209" class="indexterm"/>animation to work, we need to create a curve. It will be used to tell our <code class="literal">MOAIDeckRemapper</code> instance which tileset index should be used at a given animation step.</p><p>The remapper will be in charge of changing the current Prop's index to the correct one.</p><p>The interesting thing is that these curves are defined using keys that set the value for a given point in the animation. These values are then interpolated using a <code class="literal">MOAIEaseType</code> curve.</p><p>This is really nice, since we don't have to specify each point in our animation, just two of them and the rest are interpolated. Let's see how this works.</p></li><li class="listitem">Let's create a method that will add an animation and review it step by step.<div class="informalexample"><pre class="programlisting">function Character:addAnimation ( name, startFrame, frameCount, time, mode )
  local curve = MOAIAnimCurve.new ()</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we create an animation curve. These curves are used to generate a specific behavior on how to move through the frames. We create a series of points that will create a curve (interpolating values). The animation will query the curve at a specific point of time and use its value.<div class="informalexample"><pre class="programlisting">  curve:reserveKeys ( 2 )</pre></div></li><li class="listitem">A <a id="id210" class="indexterm"/><span class="strong"><strong>key</strong></span> is a value that we use to define the curve. We'll need two keys here (the start and the end of the curve), but you might want more than one (for example, if some part of the animation needs to run faster than the others or stuff like that).<div class="informalexample"><pre class="programlisting">  curve:setKey ( 1, 0, startFrame, MOAIEaseType.LINEAR )</pre></div></li><li class="listitem">Using <code class="literal">setKey ()</code> we define a key:<p>The first parameter is the key number (starting at one). The second is the time at which that key should happen; in this case, since it's the first key for our animation, the time is zero. Then, we pass the value of that key; in our case, it'll be our <code class="literal">startFrame</code>, and then <code class="literal">MOAIEaseType</code>. Ease types are a way to tell animations to use different curves. In this case, we're using a linear curve.</p><div class="informalexample"><pre class="programlisting">  curve:setKey ( 2, time * frameCount, 
    startFrame + frameCount, MOAIEaseType.LINEAR )</pre></div></li><li class="listitem">The second key will be the last one. For the second parameter (<code class="literal">time</code>), we multiply the time between frames by the frame count, should be the total time for the animation. After that, we tell it to stop at <code class="literal">frameCount</code> frames after <code class="literal">startFrame</code> and, again, we use linear interpolation.<p>When creating our animation, this will create a linear function from <code class="literal">startFrame</code> at time 0 to <code class="literal">startFrame + frameCount</code> at the end of the curve. Just what we want for our animation.</p><div class="informalexample"><pre class="programlisting">  
  local anim = MOAIAnim:new ()
  anim:reserveLinks (1)
  anim:setLink ( 1, curve, self.remapper, 1 )</pre></div></li><li class="listitem">Next, we create our animation, reserve one link that will be used to connect the curve to the remapper, and then we connect them.<p>What will happen here is that when we start the animation, it will iterate through the curve passing the result of the curve to the remapper. When that happens, the remapper will change the image displayed by the Prop. The one at the end of the call is the index of the remapper we'll be using; since we only reserved one, we pass one there.</p><div class="informalexample"><pre class="programlisting">  anim:setMode ( mode )</pre></div></li><li class="listitem">Here we set the animation mode we defined.<div class="informalexample"><pre class="programlisting">  self.animations[name] = anim
  
end</pre></div></li><li class="listitem">To finish this, we store the animation under the name we passed as a parameter.<p>The way this <a id="id212" class="indexterm"/>works is not trivial, so it may take a while for you to process it. You should play around with the definition and parameters to get an idea of how the <code class="literal">MOAIAnim</code> + <code class="literal">MOAIAnimCurve</code> + <code class="literal">MOAIDeckRemapper</code> workflow interacts.</p><p>We'll define some auxiliary methods to work with these animations:</p><div class="informalexample"><pre class="programlisting">function Character:getAnimation ( name )
  return self.animations[name]
end</pre></div></li></ol></div></li><li class="listitem"><code class="literal">getAnimation</code> returns the animation that is indexed by name.<div class="informalexample"><pre class="programlisting">function Character:stopCurrentAnimation ()
  
  if self.currentAnimation then
    self.currentAnimation:stop ()
  end
  
end</pre></div></li><li class="listitem">In this method, we stop the animation that is currently running if it exists.</li><li class="listitem">The following method is used to start an animation. Let's take a look at it.<div class="informalexample"><pre class="programlisting">function Character:startAnimation ( name )

  self:stopCurrentAnimation ()</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we stop the current animation.</li><li class="listitem">Stopping the animation is really important, because a running animation consumes some memory, and if we don't stop it, we'll end up having tons of animations running all the time and consuming a lot of memory. We figured this out while developing <span class="emphasis"><em>The Insulines</em></span> as well.<div class="informalexample"><pre class="programlisting">  self.currentAnimation = self:getAnimation ( name )</pre></div></li><li class="listitem">Then we get the animation indexed by name.<div class="informalexample"><pre class="programlisting">  self.currentAnimation:start ()</pre></div></li><li class="listitem">And then we start it.<div class="informalexample"><pre class="programlisting">  return self.currentAnimation
end</pre></div></li><li class="listitem">We then return it, in case we want to do something with it later (such as blocking the coroutine to chain multiple animations, remember?).</li></ol></div></li><li class="listitem">The last thing <a id="id213" class="indexterm"/>we need to do is parse all of the animations we defined inside <code class="literal">character_object</code> and create the necessary animations. To do this, go to <code class="literal">Character:initialize</code>, and at the bottom, include the following code:<div class="informalexample"><pre class="programlisting">  self.animations = {}

  for name, def in pairs ( character_object.animations ) do
    self:addAnimation ( name, def.startFrame, def.frameCount,
      def.time, def.mode )
  end</pre></div></li></ol></div><p>Here we are iterating through all of the defined animations and are using the attributes as parameters for our<a id="id214" class="indexterm"/> <code class="literal">addAnimation ()</code> method.</p><p>The result will be that all the animations will be inside <code class="literal">Character.animations</code> and we'll be able to access them through the methods created earlier (<code class="literal">startAnimation</code> and <code class="literal">stopAnimation</code>). To see if everything works fine, add the following line:</p><div class="informalexample"><pre class="programlisting">  self:startAnimation ( 'run' )</pre></div><p>This should start the running animation. You will want to experiment a little bit with this by changing the parameters in the definitions and calling different animations.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we started to implement the initial structure for our platformer prototype. We created a camera and learned how to move it. We also played with layers and parallax. Then we added our character and learned about how to create animations from a tiled image.</p><p>In the next chapter, we'll introduce some physics to the prototype using Box2D, which is already shipped with Moai SDK.</p></div></body></html>