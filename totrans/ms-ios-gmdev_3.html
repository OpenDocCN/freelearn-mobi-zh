<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Blast Off! Starting with Development</h1></div></div></div><p>Now the fun really begins! We are going to start the development of our game! Are you as excited as I am? If you aren't, you should be! Just look at what we're going to cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a SpriteKit project in Xcode</li><li class="listitem" style="list-style-type: disc">Level design and implementation</li><li class="listitem" style="list-style-type: disc">Gravity – player movement</li><li class="listitem" style="list-style-type: disc">Collision detection</li></ul></div><p>We will cover all these and a whole lot more!</p><p>Buckle up because we are going to shift into high gear, and we aren't going to look back! Well, maybe we will once or twice, but you get the point. Let's begin! Let's create our project!</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec15"/>Creating a SpriteKit project in Xcode</h1></div></div></div><p>Let's begin straight <a id="id56" class="indexterm"/>away by opening up Xcode and clicking<a id="id57" class="indexterm"/> on <strong>File</strong> | <strong>New</strong> |<strong>Project</strong>. You will then be greeted by the New Project wizard, which will look like this:</p><div><img src="img/B03553_03_01.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>For this project, we<a id="id58" class="indexterm"/> are—obviously—going to select <strong>iOS</strong> | <strong>Application</strong> | <strong>Single View Application</strong> and then click on <strong>Next</strong>.</p><p>Once you do that, you<a id="id59" class="indexterm"/> will be required to fill in some details on the project, such as product name, organization name, and so on. See the following screenshot:</p><div><img src="img/B03553_03_02.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>Fill in the <a id="id60" class="indexterm"/>required fields (if they aren't already populated) and<a id="id61" class="indexterm"/> then click <strong>Next</strong>. To begin, we are going to make some changes to the project. For instance, locate the <code class="literal">LaunchScreen.xib</code> file in the sidebar on the left and delete it by pressing <em>Delete</em> on your keyboard.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>The <code class="literal">.xib</code> and storyboard files are the interface files that you can use to create the interface of a view. In them you can create buttons, text labels, and other user interface elements.</p></div></div><p>You will see a popup asking if you want to remove the reference or move it to the trash. We won't need it as we are going to program everything the player will see, so you can safely send it to the trash.</p><p>Then click on the main project file in the sidebar on the left; in the middle of the screen, you will see all the project's settings. We are also going to make some changes to this section.</p><div><img src="img/B03553_03_03.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>First things<a id="id62" class="indexterm"/> first. Under the <strong>App Icons and Launch Images</strong> rollout, locate<a id="id63" class="indexterm"/> the <strong>Launch Screen File</strong> dropdown. Where it says <code class="literal">LaunchScreen.xib</code>, simply select the text and delete it as shown in the following screenshot. Again, because we are going to be programming everything, we won't need it in our case.</p><div><img src="img/B03553_03_04.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>Look down a little further and you will see the <strong>Linked Frameworks and Libraries</strong> roll out.</p><p>
<strong>Frameworks</strong> and <strong>Libraries</strong> are extensions you can add to further enhance the functionality of your app. Examples of what you can add are CoreGraphics and SpriteKit; even the Facebook API or Cocos2D can be downloaded and added for additional features.</p><p>This is where we add our various frameworks (if you didn't know that already). We are going to add five frameworks and one library. To do this, click on the <strong>+</strong> button at the bottom of the section. The files we are going to add are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">libz.dlib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">CoreGraphics.framework</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIKit.framework</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SpriteKit.framework</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GLKit.framework</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Foundation.framework</code></li></ul></div><p>Here is a screenshot of <strong>Linked Frameworks and Libraries</strong>:</p><div><img src="img/B03553_03_05.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>Our game is <a id="id64" class="indexterm"/>going to make good use of these frameworks, as we <a id="id65" class="indexterm"/>will see throughout this chapter. I like to keep things nice and organized whereas Xcode just throws files at the top of the sidebar on the left-hand side. I selected the new frameworks that were just added, right-clicked on them, selected <strong>New Group from Selection</strong>, and called that folder <code class="literal">Frameworks</code>. I personally like to keep things good and organized when developing; I even make sure all the paragraphs of code are indented properly.</p><p>After you've added the new frameworks, you must download the two folders in the resource section of this book. They include additional frameworks that are provided for free online and that will assist us further, especially with our level design.</p><p>The Frameworks are <code class="literal">SKTUtils</code>, which is essentially an extension of <code class="literal">SpriteKit</code>, and <code class="literal">JSTileMap</code>, which we will use for our maps.</p><p>The <code class="literal">SKUtils</code> framework is an extension of <code class="literal">SpriteKit</code> that adds more visual effects as well as further mathematical calculations for additional physics (such as the use of π (pi) in calculations for even more complex physics calculations).</p><p>The <code class="literal">JSTileMap</code> framework allows us to import a tile map file into Xcode. As you will find out later, Xcode doesn't natively support map files.</p><p>Once you have them downloaded, simply select the two folders and drag them into the bar on the left-hand side of our project, as shown in the following screenshot:</p><div><img src="img/B03553_03_06.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>Make sure you <a id="id66" class="indexterm"/>click on the <strong>Copy items if needed</strong> check box; this <a id="id67" class="indexterm"/>will copy these folders into your project folder so that any changes do not affect the originals.</p><p>Importing the <code class="literal">SKTUtils</code> framework, I found, threw 20 errors at me, most of which were completely incomprehensible. So after much deliberation and debugging, I realized (halfway through writing this chapter, mind you), that we need to add a <strong>prefix header</strong>. The prefix header file is created to precompile headers a lot faster. So instead of compiling each header one by one, they are compiled once and way ahead of time.</p><p>Click on <strong>File</strong> | <strong>New</strong> | <strong>File</strong>. Once the wizard appears, click <strong>Other</strong> under <strong>iOS</strong>, select <strong>PCH File (PreCompiledHeader File)</strong>, and name it something like <strong>*yourProjectName*-Prefix.pch</strong>.</p><p>Once that file is created, click on it to edit it; we are going to fill it with the following code:</p><div><pre class="programlisting">#import &lt;Availability.h&gt;

#ifndef __IPHONE_5_0
#warning "This project uses features only available in iOS SDK 5.0 and later."
#endif

#ifdef __OBJC__
    #import &lt;UIKit/UIKit.h&gt;
    #import &lt;Foundation/Foundation.h&gt;
#endif</pre></div><p>We need to define <a id="id68" class="indexterm"/>our PCH file we just created in Xcode or else<a id="id69" class="indexterm"/> it will be rendered useless because it won't be doing anything!</p><p>Once we are done filling out that file, we are going to click on our project in the bar on the left. You will now see tabs at the top of the navigation bar: <strong>General</strong>, <strong>Capabilities</strong>, <strong>Info</strong>, <strong>Build Settings</strong>, <strong>Build Phases</strong>, and <strong>Build Rules</strong>. Click on <strong>Build Settings</strong>. Scroll down to find <strong>Apple LLVM 6.1 – Language</strong> and change the <strong>Precompile Prefix Header</strong> selection to <strong>Yes</strong>. Below that, double-click on the empty field in the <strong>Prefix Header</strong> section and fill it out according to your project. I named my project Adesa, so I filled in <strong>Adesa/Adesa-Prefix.pch</strong>, as shown in the following screenshot:</p><div><img src="img/B03553_03_15.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>Moving on!</p><p>Now we have to add in some more main and header files; one set will be called <strong>Player</strong>, and the other will be <strong>GameLevelScene</strong>. Unsure how to add these? No problem! Simply click <strong>File</strong> | <strong>New</strong> | <strong>File</strong> or press <em>Command</em> + <em>N</em>. For these files, we will select the <code class="literal">Cocoa Class</code> file and click <strong>Next</strong>, as shown in the following screenshot:</p><div><img src="img/B03553_03_07.jpg" alt="Creating a SpriteKit project in Xcode"/></div><p>Again fill out the<a id="id70" class="indexterm"/> name of the <strong>Class</strong>, and again one will be <strong>Player</strong> and<a id="id71" class="indexterm"/> the other <strong>GameLevelScene</strong>. I know setting things up is a little boring, but we have to do it. Now, on to editing our code!</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Editing our code files</h2></div></div></div><p>We need to start making a <a id="id72" class="indexterm"/>few changes to our source code files. We will start with the <code class="literal">ViewController</code> interface set of files, the <code class="literal">.h</code> and <code class="literal">.m</code> files, that is—the files that control a defined view. We will start with the <code class="literal">.h</code> file; at the moment, it should read like this:</p><div><pre class="programlisting">#import &lt;UIKit/UIKit.h&gt;

@interface ViewController : UIViewController

@end</pre></div><p>We need to add <code class="literal">#import&lt;SpriteKit/SpriteKit.h&gt;</code> directly below the line <code class="literal">#import &lt;UIKit/UIkit.h&gt;</code>.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>WHAT?!</strong>
</p><p>This line we just inserted into our code imports the SpriteKit framework into that header file so that we can access the features of SpriteKit in the header we are working on.</p></div></div><p>That's all for the <code class="literal">.h</code> file <a id="id73" class="indexterm"/>for the moment; we are going to be bouncing back and forth between files as we set our project up.</p><p>On to the <code class="literal">ViewController.m</code> file, which should be edited to look like this:</p><div><pre class="programlisting">#import "ViewController.h"
#import "GameLevelScene.h"

@implementation ViewController

-(void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    
    //Configure the view.
    SKView * skView = (SKView *)self.view;
    skView.showsFPS = YES;
    skView.showsNodeCount = YES;
    
    //Create and Configure the scene.
    SKScene * scene = [GameLevelScene sceneWithSize: skView.bounds.size];
    scene.scaleMode = SKSceneScaleModeAspectFill;
    
    //Present (or show) le scene.
    [skView presentScene:scene];
}

- (BOOL)shouldAutorotate
{
    return YES;
}

- (NSUInteger)supportedInterfaceOrientations
{
    return UIInterfaceOrientationMaskLandscape;
}


- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

@end</pre></div><p>I know what you're<a id="id74" class="indexterm"/> thinking: <em>What does all this mean?</em> I'll start from the beginning to make it easy on those who don't have coding experience:</p><div><pre class="programlisting">#import "ViewController.h"
#import "GameLevelScene.h"</pre></div><p>Again we have the import line; we import the <code class="literal">ViewController</code> header file where everything will be declared. Next we have the <code class="literal">GameLevelScene</code> header file; this will host the game scenes, where we will spend probably the majority of time in this file, as shown in the following code:</p><div><pre class="programlisting">-(void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    
    //Configure the view.
    SKView * skView = (SKView *)self.view;
    skView.showsFPS = YES;
    skView.showsNodeCount = YES;

    //Create and Configure the scene.
    SKScene * scene = [GameLevelScene sceneWithSize: skView.bounds.size];
    scene.scaleMode = SKSceneScaleModeAspectFill;
    
    //Present le scene.
    [skView presentScene:scene];
}</pre></div><p>With this paragraph of code, we have set up the SpriteKit view. The first line, <code class="literal">SKView * skView = (SKView *)self.view;</code>, declares a new instance of a SpriteKit view, named <code class="literal">skView</code>, and places it in the <code class="literal">ViewController</code> header file's view, hence <code class="literal">self.view</code>.</p><p>The next two lines are completely optional as they are more for testing purposes, and you will delete them before you release your app. The first line shows the frames-per-second count, and the next shows the number of nodes or objects within the scene. Feel free to remove these lines now if you don't want to see them.</p><p>The next line actually creates and configures the scene. As <code class="literal">SKScene * scene = [GameLevelScene scenewithSize: skView.bound.size]</code> denotes, the data is being pulled from the <code class="literal">GameLevelScene</code> set of files we still have to set up. For now it will throw an error saying there is no known class method for selector <code class="literal">sceneWithSize</code>, but don't worry because we haven't done any declarations in the <code class="literal">GameLevelScene</code> set of files.</p><p>After that, we see<a id="id75" class="indexterm"/> the scaling for the scene which is set to <code class="literal">AspectFill</code>. You can select either aspect fit or stretch, but for this example we will use aspect fill. You can change it if you like.</p><p>Finally we present the scene!</p><p>Let's bounce on over to the <code class="literal">GameLevelScene</code> files. We will again start with the header file, which should read like this:</p><div><pre class="programlisting">#import &lt;SpriteKit/SpriteKit.h&gt;

@interface GameLevelScene : SKScene

@end</pre></div><p>Simply, we have changed the <code class="literal">GameLevelScene</code> class to a <code class="literal">SpriteKit</code> scene; so now, when we go to build our project, the previously mentioned error will disappear. On to the <code class="literal">.m</code> file, which will read like this:</p><div><pre class="programlisting">#import "GameLevelScene.h"

@implementation GameLevelScene

-(id)initWithSize:(CGSize)size {

  if (self = [super initWithSize:size]) {


  }
  return self;
}

@end</pre></div><p>Again, this is a simple initializing of the scene and setting the size. Now let's build our project! You don't have to have a device plugged in at the moment; we will run on the simulator. If you're running an older computer, I suggest selecting the iPhone 4S for the simulator, as shown in the following screenshot, mainly because it takes less time to load and the screen size is small enough to fit nicely on your screen.</p><div><img src="img/B03553_03_08.jpg" alt="Editing our code files"/></div><p>Simply click on the<a id="id76" class="indexterm"/> button shown in the previous screenshot (the one beside the play and stop button), and select whatever device you like for the simulator.</p><p>Now let's build the project. Click on the <strong>Play</strong> button at the top, or press <em>cmd</em> + <em>B</em> (or <em>cmd</em> + <em>R</em> to build and run the project).</p><p>If all goes well, it should build successfully and the iOS simulator should appear. Uh oh! Did you get an error that looks like this?</p><div><pre class="programlisting">0x22d9a &lt;+138&gt;: movl   %eax, -0x10(%ebp)
2015-04-30 11:33:20.916 Adesa[25543:4462832] -[UIView setShowsFPS:]: unrecognized selector sent to instance 0x7a660940
2015-04-30 11:33:20.918 Adesa[25543:4462832] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView setShowsFPS:]: unrecognized selector sent to instance 0x7a660940'
*** First throw call stack:
(
(LOTS OF WRITING HERE)
)
libc++abi.dylib: terminating with uncaught exception of type NSException
(lldb)</pre></div><p>We also need to make changes to the <code class="literal">UIViewController</code> header file in the Storyboard.</p><p>On the left-hand bar of our project, locate the <code class="literal">Main.storyboard</code> file (remember we discussed the storyboard and <code class="literal">.xib</code> files earlier?), and click on it. We can arrange the UI of the apps in this file, but we probably won't use it in this project. Now you will see a blank iOS layout, ripe for changing.</p><p>All we are going to do here is launch the <strong>ViewController Scene</strong> rollout on the sidebar, just next to the bar where all our project files are, then roll out the <strong>View Controller</strong> rollout, and click on <strong>View</strong>, as shown in the following screenshot:</p><div><img src="img/B03553_03_09.jpg" alt="Editing our code files"/></div><p>Now look over <a id="id77" class="indexterm"/>to the bar on the far right, and you will see the top bar has six different buttons. Click the third one, in which you see <strong>Show the Identity Inspector</strong>. Now you will see a section right below the buttons called <strong>Custom Class</strong>. In the <strong>Class</strong> text field in this section, we are going to type in <strong>SKView</strong>, as shown in the following screenshot:</p><div><img src="img/B03553_03_10.jpg" alt="Editing our code files"/></div><p>Let's try running our project yet again. Does it build successfully? Good! Does it open the iOS simulator? Awesome! Does it show a blank device with the frame rate and zero nodes printed on the bottom of the screen? Amazing! We are right on track!</p><p>For our final changes, we <a id="id78" class="indexterm"/>are going to quickly edit the <code class="literal">Player</code> set of files. At this moment, all we have to do is edit the header file. Change it so it reads as follows:</p><div><pre class="programlisting">#import &lt;SpriteKit/SpriteKit.h&gt;

@interface Player : SKSpriteNode

@end</pre></div><p>We are now going to work on "pause for effect."</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Level design and implementation</h1></div></div></div><p>This is where we can <a id="id79" class="indexterm"/>have a lot of fun! We are now going to start <a id="id80" class="indexterm"/>designing our levels. You can spend hours adding the little details to each level to make them look perfect. Remember, a well-designed level will impress players and will give your game a professional look.</p><p>Unfortunately, Xcode just doesn't have the drag-and-drop ease of level design, so we are going to create our maps using a third-party program called <em>Tiled Map Editor</em>, which can be downloaded for<a id="id81" class="indexterm"/> free at <a class="ulink" href="http://www.mapeditor.org">www.mapeditor.org</a>.</p><p>I have included a sprite sheet for our levels as well as a built level in the <em>Resources</em> section of this book. Do you remember the <code class="literal">JSTileMap</code> library that was included as well in this chapter? It's what is going to display these maps as SpriteKit doesn't support TMXTileMaps. So sad!</p><p>Anyway, moving on! Open up the level I have included, entitled <code class="literal">level1.tmx</code>, and get a feel for how the program works.</p><p>The side bar of Tiled<a id="id82" class="indexterm"/> shows you the different layers of the levels. In this <a id="id83" class="indexterm"/>case, we have <strong>hazards</strong>, which are things like spikes and other objects that could prove detrimental to our player's health. Then we have <strong>walls</strong>, fairly self-explanatory, and then <strong>background</strong>, for scene elements such as clouds and trees.</p><div><img src="img/B03553_03_23.jpg" alt="Level design and implementation"/></div><p>Try making some edits to the level, and make it your own little masterpiece. The following screenshot shows all the tools you need; the selected tool in the image is the stamp tool, which allows you to place the selected image in the scene on the selected layer. Then you have the Paint Bucket and Eraser tools. Give it a try! When you're done, we are going to program the level into our game.</p><div><img src="img/B03553_03_11.jpg" alt="Level design and implementation"/></div><p>Let's open up our <code class="literal">GameLevelScene.m</code> file and add <code class="literal">#import "JSTileMap.h"</code> at the top of the file, under <code class="literal">#import "GameLevelScene.h"</code>.</p><p>Directly under the import we just inserted, we are going to add in the following lines:</p><div><pre class="programlisting">@interface GameLevelScene()
@property (nonatomic, strong) JSTileMap *map
@end</pre></div><p>This is adding a private variable for the map we will be using into our <code class="literal">GameLevelScene</code> class.</p><p>Now we are going to actually load the map. In the <code class="literal">(id)initWithSize:(CGSize)size </code>block of code, inside the <code class="literal">if</code> statement, add in the following code to change the color of the sky, as well as load the map:</p><div><pre class="programlisting">self.backgroundColor = [SKColor colorWithRed:.25 green:.0 blue:.25 alpha:1.0];

self.map = [JSTileMap mapNamed:@"level1.tmx"];
[self addChild:self.map];</pre></div><p>Run the project to<a id="id84" class="indexterm"/> see your awesome level is now in place on the screen. I<a id="id85" class="indexterm"/> decided to use a dark purple color for these levels because it's the environment I'm going for. You can go in for whatever you like, but remember to just adjust the colors accordingly.</p><p>If for some reason it's not showing up correctly or you are getting an error, make sure your <code class="literal">GameLevelScene.m</code> file now looks like this:</p><div><pre class="programlisting">#import "GameLevelScene.h"
#import "JSTileMap.h"

@interface GameLevelScene()
@property (nonatomic, strong) JSTileMap *map;
@end

@implementation GameLevelScene


-(id)initWithSize:(CGSize)size {
    if (self = [super initWithSize:size]) {
        //CUS ITS SKY FALL!...This makes the background purple...
        self.backgroundColor = [SKColor colorWithRed:.25 green:.0 blue:.25 alpha:1.0];
        
        self.map = [JSTileMap mapNamed:@"level1.tmx"];
        [self addChild:self.map];
    }
    return self;
}

@end</pre></div><p>Looks pretty cool eh? Tiled <a id="id86" class="indexterm"/>is a great program, and you can add a whole lot <a id="id87" class="indexterm"/>more detail then I did here.</p><div><img src="img/B03553_03_12.jpg" alt="Level design and implementation"/></div><p>Something's missing, though, isn't it? Hmm... Oh yes! Our player!</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Gravity – player movement</h1></div></div></div><p>For now, import the <code class="literal">Player</code> images (in the <code class="literal">sprites.atlas</code> file) I have provided in the resources section <a id="id88" class="indexterm"/>of this book. Unless you have your own! Then by <a id="id89" class="indexterm"/>all means use yours.</p><p>Let's go back to our <code class="literal">GameLevelScene.m</code> file and import yet another file. This time, it will be <code class="literal">#import "Player.h"</code>. Then, after the <code class="literal">@interface</code> section that we added earlier, we are going to add another property similar to the map property we just added: <code class="literal">@property (nonatomic, strong) Player *player1</code>. I used player1 because we will be adding in some multiplayer features later!</p><p>Then again, inside the <code class="literal">initWithSize</code> function we will add the following code:</p><div><pre class="programlisting">self.player = [[Player alloc] initWithImageNamed:@"P1Idle"];
self.player.position = (CGPointMake(100, 50);
self.player.zPosition = 15;
[self.map addChild: self.player];</pre></div><p>When we build and run our project, we should get similar results as seen in the following image. I think it's starting<a id="id90" class="indexterm"/> to look pretty cool!</p><div><img src="img/B03553_03_13.jpg" alt="Gravity – player movement"/></div><p>Hold on cowboy! What<a id="id91" class="indexterm"/> did we just do? Well let me explain what happened. The code we just added loaded our little space man as a sprite object, positioned him on the map, and then added him to the map object.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Here's something to keep in mind, as you may be wondering why our little guy is added to the map, instead of adding him directly to the scene. Well, let me tell you! It's all about control. I like to be in full control (and my wife says I can tell people that), and we want to control exactly which layers from our map are in front of and behind our little guy. So for example we can set the background objects, such as the trees and hills, to be way in the back, but if we want to we can position our space dude to be behind them. So then he needs to be a subobject, or a child, of the map class.</p></div></div><p>Now we need to make this guy move! First off, let's add some gravity into the scene. Back in our <code class="literal">GameLevelScene.m</code> file, we are again going to add another property in the same location we've been adding them, in the <code class="literal">Interface</code> section of our code. It will be this:</p><div><pre class="programlisting">@property (nonatomic, assign) NSTimeInterval previousTime;</pre></div><p>Refer to the following screenshot to ensure your code is filled out correctly:</p><div><img src="img/B03553_03_14.jpg" alt="Gravity – player movement"/></div><p>After this we are <a id="id92" class="indexterm"/>going to code in an <code class="literal">update</code> method, which we will <a id="id93" class="indexterm"/>place just before the <code class="literal">-(id)initWithSize:(CGSize)size {</code> line of code. To create this method, we will add this code:</p><div><pre class="programlisting">- (void)update:(NSTimeInterval)currentTime
{
    
    NSTimeInterval delta = currentTime - self.previousTime;
    
    if (delta &gt; 0.02) {
        delta = 0.02;
    }
    
    self.previousTime = currentTime;
    
    [self.player1 update:delta];
}</pre></div><p>This will throw an error at the moment, saying there is no visible <code class="literal">@interface</code> for a player that declares the update selector. Confusing, right? Let's take it one step at a time and explain what we just did here.</p><p>Firstly, we added in this update method, which is automatically built into a SpriteKit scene, or <code class="literal">SKScene</code> object. All we have to do is code it in! Then every frame that we call before the scene will be rendered accordingly. The update method provides us with a timer value, or the <code class="literal">NSTimerInterval</code> value, that is the current time of our program.</p><p>Secondly, we get the <code class="literal">delta</code> value, which is the current time, subtracted by the previous time. What's the <code class="literal">delta</code> value? It's essentially the interval since the previous time the update was called. With this <code class="literal">delta</code> time value, we can create movement, gravity, and other forces with a neat and smooth motion, as well as smooth animations.</p><p>Then we have an <code class="literal">if</code> statement; if the <code class="literal">delta</code> value goes above 0.02, it is kept at 0.02. Sometimes our devices lag, stutter, or slow down, and especially when first booting the game up, the device has a lot to load; thus, this <code class="literal">delta</code> value could be quite large. We keep it at a consistent value to reduce the chances of the physics acting weird. Why would this happen?</p><p>Like I mentioned <a id="id94" class="indexterm"/>before, this <code class="literal">delta</code> value creates smooth <a id="id95" class="indexterm"/>movement and gravity by keeping a neat consistent value. If that value goes way over 0.02, the movement or any external forces we program won't work correctly and bad things could occur that we don't want happening. Call it preventative measures so we don't create any game-breaking bugs. After the <code class="literal">if</code> statement, we then set the current time (which for example could be 0.02), as the previous time so the device can determine the <code class="literal">delta</code> value. Let's clarify, in order to determine how quickly the time is advancing, we have the current time, and previous time, so before the time advances we set the current time as the previous time, and then the current time advances.</p><p>Broken down, the clock begins to count, the current time is 0.05, before the time advances we will set the previous time variable to 0.05, then the current time will increase to 0.06. The device will then calculate the delta value. Make sense? I know it's a lot to take in.</p><p>Then we come to the line of code that causes the error. It's calling the error because we haven't implemented the <code class="literal">update</code> method in our <code class="literal">Player</code> set of files (or class). Let's do that now!</p><p>Go in to our <code class="literal">Player.h</code> file, and change the code so it looks like this:</p><div><pre class="programlisting">#import &lt;SpriteKit/SpriteKit.h&gt;

@interface Player : SKSpriteNode //(These lines should be here already)

@property (nonatomic, assign) CGPoint velocity;
-(void) update:(NSTimeInterval)delta;
@end</pre></div><p>Whoa, whoa buddy, this doesn't make sense! When programming a game, there's a lot of physics and math that goes into the coding. In the <code class="literal">@property (nonatomic, assign) CGPoint velocity;</code> line, we are creating a property that will measure how fast the player is moving.</p><p>What's a <strong>CGPoint</strong>, <a id="id96" class="indexterm"/>you ask? <strong>CG</strong> stands for <strong>CoreGraphics</strong> <a id="id97" class="indexterm"/>which is the main graphic rendering framework used by iOS devices, and <strong>point</strong>
<a id="id98" class="indexterm"/> is a point on the screen, so <code class="literal">CGPoint</code> holds the positional value of an object; in this case the <code class="literal">velocity</code> will now have an <code class="literal">x</code> and <code class="literal">y</code> value, allowing us to calculate the exact speed the player is moving at and the exact direction they are moving in. Fun!</p><p>Let's hop on over to the <code class="literal">Player.m</code> class file and change the code to the following:</p><div><pre class="programlisting">#import "Player.h"

#import "SKTUtils.h"

@implementation Player


- (instancetype)initWithImageNamed:(NSString *)name {
    if (self == [super initWithImageNamed:name]) {
        self.velocity = CGPointMake(0.0, 0.0);
    }
    return self;
}

- (void)update:(NSTimeInterval)delta {
    
    CGPoint gravity = CGPointMake(0.0, -450.0);
    
    CGPoint gravityStep = CGPointMultiplyScalar(gravity, delta);
    
    self.velocity = CGPointAdd(self.velocity, gravityStep);
    CGPoint velocityStep = CGPointMultiplyScalar(self.velocity, delta);
    
    self.position = CGPointAdd(self.position, velocityStep);
}

@end</pre></div><p>Let's break down what we just did here. I know things can be confusing, but don't worry! I'm here to help you!</p><p>First, we <a id="id99" class="indexterm"/>imported the <code class="literal">SKUtils</code> framework into the <code class="literal">Player</code> class. After <a id="id100" class="indexterm"/>that, we created a new <code class="literal">initWithImageNamed</code> method and initialized the velocity variable to <code class="literal">0.0</code>. Then we declared the value of the gravity force. Each time the update method runs, we are increasing the velocity of the player 450 points downward. If the player starts out by standing still, after one second he'll be moving at 450 pixels per second, at two seconds that value will be doubled, and so forth.</p><p>Sounds easy.... right?</p><p>Next, we used <code class="literal">CGPointMulitplyScalar</code> to decrease the acceleration down to the size of the current time step. Remember, <code class="literal">CGPointMulitplyScalar</code> increases the <code class="literal">CGPoint</code> values by a float value, and returns the <code class="literal">CGPoint</code> result. This is great because, when the device lags or for some odd reason we see a drop in frame rate, we will still get a consistent acceleration value.</p><p>In the <code class="literal">self.velocity =... block</code>, we calculate the gravity for the current time and then add it to the player's current velocity. With the new velocity calculated, we get the velocity for a single time step.</p><p>Finally, with the<a id="id101" class="indexterm"/> velocity all calculated, we use the <code class="literal">CGPointAdd</code> function<a id="id102" class="indexterm"/> to change the position of the player. As you can see, <code class="literal">CGPointAdd</code> is equal to the player's current position, with the gravity added.</p><p>OK! Let's run our project!</p><div><img src="img/B03553_03_16.jpg" alt="Gravity – player movement"/></div><p>What? He's falling through the ground? Hmm, I guess that means we need to detect collisions now?</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Collision detection</h1></div></div></div><p>We all know that collision detection <a id="id103" class="indexterm"/>is imperative to any game. Regardless of whether it's a hockey game, or Call of Angry eight year olds, the game needs to detect collisions of hockey pucks, bullets, swords, feet on the ground—you name it and there are a ton of collisions that need to be detected. For our game, we are only going to detect simple boxes colliding with each other between the player and enemies, the platforms, and the bullets colliding with enemies.</p><p>We are going to make things super easy; first we are going to detect the player's bounding box.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>What's a <a id="id104" class="indexterm"/>bounding box? Simple! Think of when you're creating your sprites; there's a box surrounding your image? You could think of a collision bounding box like that, the small box that your sprite fits in or within a defined space. You can (and we will) adjust the size of the bounding box to fit the sprite; you can have it larger or smaller depending on your needs.</p></div></div><p>With that all explained, let's hop into our <code class="literal">Player.h</code> file and add the following line:</p><div><pre class="programlisting">-(CGRect)collisionBox;</pre></div><p>We just created a core-graphics rectangle named <code class="literal">collisionBox</code>. Easy, right?</p><p>Now add the following code into <code class="literal">Player.m</code>:</p><div><pre class="programlisting">-(CGRect)collisionBox {
  return CGRectInset(self.frame, 2, 0);
}</pre></div><p>The value of <code class="literal">CGRectInset</code> decreases the size of the rectangle, or our collision box, by the last two bracketed numbers, <code class="literal">2</code> and <code class="literal">0</code> respectively. We set the player's frame as the base size, and then shrink it by <code class="literal">two</code> pixels on each side of the player. If you want, you don't have to shrink the bounding box, you can leave the two values at <code class="literal">0</code>.</p><p>Now things will start to get a little more complicated. We need to detect the various images in our level and select which one we want our player to collide with and those that we don't. Let's shoot on over to our <code class="literal">GameLevelScene.m</code> class and add in the following code:</p><div><pre class="programlisting">-(CGRect)tileRectFromTileCoords:(CGPoint)tileCoords {
  float levelHeightInPixels = self.map.mapSize.height * self.map.tileSize.height;</pre></div><p>This first block locates the pixel origin coordinate; we do this so we know exactly where to place the map in the scene. We need to flip the height coordinate because SpriteKit's origin is in the bottom-left corner of the screen but the tile map's origin is at the top left. In order to detect the origin, we need to add in the following code:</p><div><pre class="programlisting">  CGPoint origin = CGPointMake(tileCoords.x * self.map.tileSize.width, levelHeightInPixels - ((tileCoords.y + 1) * self.map.tileSize.height));


  return CGRectMake(origin.x, origin.y, self.map.tileSize.width, self.map.tileSize.height);
}</pre></div><p>Next we add <code class="literal">1</code> to the tile<a id="id105" class="indexterm"/> coordinate. Why do we do this? Actually, the tile coordinate system starts at <code class="literal">0</code>, so if we have 50 tiles, the 50th tile's actual coordinate will be 49. So we need to add one to get the right value.</p><div><pre class="programlisting">- (NSInteger)tileGIDAtTileCoord:(CGPoint)coord forLayer:(TMXLayer *)layer {
  TMXLayerInfo *layerInfo = layer.layerInfo;
  return [layerInfo tileGidAtCoord:coord];
}</pre></div><p>This next method accesses our saved map's layer info that is saved in <em>Tiled Map Editor</em>. Remember we had three layers: Background, walls, and hazards? If you want to have more than three layers, absolutely feel free to do so. I am only doing three in this example because we are going to add in our enemies and some special effects programmatically. This block of code will access those layers.</p><p>For our collision system, we are going to detect the surrounding eight tiles of our player. In the following blocks of code, we are going to detect the surrounding tiles, which will inspect the <code class="literal">CGRect</code> (or Core-Graphics rectangles) for a collision with the player's collision bounding box.</p><p>Let's go back to our <code class="literal">GameLevelScene.m</code> file and add in the following code:</p><div><pre class="programlisting">- (void)checkForAndResolveCollisionsForPlayer:(Player *)player forLayer:(TMXLayer *)layer {
    
    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};
    for (NSUInteger i = 0; i &lt; 8; i++) {
        NSInteger tileIndex = indices[i];
        
        
        CGRect playerRect = [player collisionBox];
        
        CGPoint playerCoord = [layer coordForPoint:player.position];
        
        NSInteger tileColumn = tileIndex % 3;
        NSInteger tileRow = tileIndex / 3;
        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));
        
        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:layer];
        
        if (gid) {
            
            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];
            
            NSLog(@"GID %ld, Tile Coord %@, Tile Rect %@, player rect %@", (long)gid, NSStringFromCGPoint(tileCoord), NSStringFromCGRect(tileRect), NSStringFromCGRect(playerRect));
            //after this is where we write our collision resolving
        }
        
    }
}</pre></div><p>Wow! So much code! Let's<a id="id106" class="indexterm"/> break it down. The first block creates an array that shows the position of the tiles surrounding our cool little player dude. As you can see, we find the eight surrounding tiles and then we store those values in the <code class="literal">tileIndex</code> variable.</p><p>Now, remember what I said about the tile coordinates being flipped? Notice the order of tiles? <code class="literal">7</code>, <code class="literal">1</code>, <code class="literal">3</code>, <code class="literal">5</code>, <code class="literal">0</code>, <code class="literal">2</code>, <code class="literal">6</code>, <code class="literal">8</code>. Tile 7 is the tile that is directly below our player, so it needs to be figured out right away. We need to know if he's on the ground or not; if he is, he can jump, but if not, no jumping! If we don't resolve this tile immediately, the player could potentially jump without the character touching the ground—if they pressed the jump button quickly enough.</p><p>Then we retrieved the player's collision box that we coded earlier and found the exact tile location of the player. We did this so we could then locate the surrounding tiles of our player. After we located the position of the player, we then divided the <code class="literal">tileIndex</code> variable we created earlier to find the row and column values around the player.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Let's break this down into an example.</p><p>Say the value of <code class="literal">tileIndex</code> is <code class="literal">3</code>; the value of <code class="literal">tileColumn</code> would be <code class="literal">0</code> (3 % 3 = 0) and the value of <code class="literal">tileRow</code> would be <code class="literal">1</code> (3 / 3 = 1).</p><p>If our space guy's position was found to be at tile coordinate (<code class="literal">50</code>, <code class="literal">10)</code>, the surrounding tile at <code class="literal">tileIndex 3</code> would be 50 + (0 – 1) and 10 + (1 – 1) or <code class="literal">49</code> and <code class="literal">10</code>, respectively. This equals the tile directly to the left of our space man's tile position.</p></div></div><p>I know that this can be a little confusing, but don't worry; you'll start to get it soon!</p><p>In the next step, we look up the GID value for the tile at the coordinate found in the previous instance of <code class="literal">tileIndex</code>.</p><p>Woah, halt! What in the wide, wide world of sports is a GID?</p><p>A <strong>GID</strong> is<a id="id107" class="indexterm"/> the number that<a id="id108" class="indexterm"/> represents the index of an image from a tile set. Each <code class="literal">TMXLayer</code> class has a tile set that has images arranged in a grid. Simply put, the GID is the position of a particular image.</p><p>Next we figure if the GID has a value of <code class="literal">0</code>. There is no tile. It's just blank space, so we don't resolve or test a collision. However, if there is a value in the GID, we get the <code class="literal">CGRect</code> position for that tile. Then we simply log the results. This is not a required block of code, but it is very helpful when things aren't working properly—you can look at the debugger to see what's going on. The following figure shows you how tiles are handled:</p><div><img src="img/B03553_03_17.jpg" alt="Collision detection"/></div><p>The big bold numbers represent the order in which tile collisions are handled, bottom first, top second, left-hand side third, and right-hand side fourth, then the corners. The smaller numbers represent the order in which those tiles are stored in the <code class="literal">tileIndex</code> variable.</p><p>Next we are going to go back into our <code class="literal">GameLevelScene.m</code> file, and add in the following lines:</p><div><pre class="programlisting">// Add to the @interface section with all our other properties
@property (nonatomic, strong) TMXLayer *walls;

// Add to the init method, after the map is added to the layer
self.walls = [self.map layerNamed:@"walls"];

// Add to the bottom of the update method
[self checkForAndResolveCollisionsForPlayer:self.player1 forLayer:self.walls];</pre></div><p>If you were to run the project<a id="id109" class="indexterm"/> now, it would just crash into the oblivion of<a id="id110" class="indexterm"/> <strong>SIGABRT</strong> (<strong>signal abort</strong>). SIGABRT signifies that, though an error wasn't shown within your code, your app failed when it attempted to run a section of code. You will be able to see what's going on and why it happened in the console log. We are going to further discuss debugging later in this book. We need to do a little more work.</p><p>When our <code class="literal">Player</code> class updates its position and the <code class="literal">GameLevelScene</code> class detects a collision, we will want the player to stop. So we need to create a new variable.</p><p>This variable will allow the <code class="literal">Player</code> class to do all its positioning calculations, and the <code class="literal">GameLevelScene</code> class will update the position after the collisions have been detected.</p><p>Let's go on over to our <code class="literal">Player.h</code> file and add this new property:</p><div><pre class="programlisting">@property (nonatomic, assign) CGPoint desiredPosition;</pre></div><p>We also need to make changes to our <code class="literal">collisionBox</code> method in the <code class="literal">Player.m</code> file, which should now read as follows:</p><div><pre class="programlisting">-(CGRect)collisionBox {
    CGRect boundingBox = CGRectOffset(self.frame, 2, 0);
    CGPoint difference = CGPointSubtract(self.desiredPosition, self.position);
    return CGRectOffset(boundingBox, difference.x, difference.y);
}</pre></div><p>This creates a collision bounding box based on the desired position. The layer will now use this for collision detection.</p><p>Now let's scroll down to our <code class="literal">update</code> method and locate this line:</p><div><pre class="programlisting">self.position = CGPointAdd(self.position, velocityStep);</pre></div><p>Replace it with the following:</p><div><pre class="programlisting">self.desiredPosition = CGPointAdd(self.position, velocityStep);</pre></div><p>Now this will update our <code class="literal">desiredPosition</code> property instead of the actual position property.</p><p>Back in our <code class="literal">GameLevelScene.m</code> file, look for our <code class="literal">-(void)checkForAndResolveCollisionsForPlayer:(Player *)player forLayer:(TMXLayer *)layer</code> method. We wrote <code class="literal">CGPoint playerCoord = [layer coordForPoint:player.position]</code>; we have to change this from <code class="literal">player.position</code> to <code class="literal">player.desiredPosition</code>.</p><p>Back into our <code class="literal">checkForAndResolveCollisionsForPlayer</code> method, after the commented out text <code class="literal">//after this is where we write our collision resolving</code>, we need to add in our collision resolution code. So that there's no confusion, the <code class="literal">checkForAndResolveCollisionsForPlayer</code> method should look like this<a id="id111" class="indexterm"/>:</p><div><pre class="programlisting">- (void)checkForAndResolveCollisionsForPlayer:(Player *)player forLayer:(TMXLayer *)layer
{
    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};
    player.onGround = NO;  ////Here
    for (NSUInteger i = 0; i &lt; 8; i++) {
        NSInteger tileIndex = indices[i];
        
        CGRect playerRect = [player collisionBox];
        CGPoint playerCoord = [layer coordForPoint:player.desiredPosition];
        
        NSInteger tileColumn = tileIndex % 3;
        NSInteger tileRow = tileIndex / 3;
        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));
        
        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:layer];
        if (gid != 0) {
            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];
            //NSLog(@"GID %ld, Tile Coord %@, Tile Rect %@, player rect %@", (long)gid, NSStringFromCGPoint(tileCoord), NSStringFromCGRect(tileRect), NSStringFromCGRect(playerRect));
            
            if (CGRectIntersectsRect(playerRect, tileRect)) {
                CGRect intersection = CGRectIntersection(playerRect, tileRect);
                
                if (tileIndex == 7) {
                    //tile is directly below Player
                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height);
                    player.velocity = CGPointMake(player.velocity.x, 0.0);
                    player.onGround = YES;
                } else if (tileIndex == 1) {
                    //tile is directly above Player
                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y - intersection.size.height);
                } else if (tileIndex == 3) {
                    //tile is left of Player
                    player.desiredPosition = CGPointMake(player.desiredPosition.x + intersection.size.width, player.desiredPosition.y);
                } else if (tileIndex == 5) {
                    //tile is right of Player
                    player.desiredPosition = CGPointMake(player.desiredPosition.x - intersection.size.width, player.desiredPosition.y);
                    //3
                } else {
                    if (intersection.size.width &gt; intersection.size.height) {
                        //tile is diagonal, but resolving collision vertically
                        
                        player.velocity = CGPointMake(player.velocity.x, 0.0);
                        float intersectionHeight;
                        if (tileIndex &gt; 4) {
                            intersectionHeight = intersection.size.height;
                            player.onGround = YES;
                        } else {
                            intersectionHeight = -intersection.size.height;
                        }
                        player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height );
                    } else {
                        //tile is diagonal, but resolving horizontally
                        float intersectionWidth;
                        if (tileIndex == 6 || tileIndex == 0) {
                            intersectionWidth = intersection.size.width;
                        } else {
                            intersectionWidth = -intersection.size.width;
                        }
                        
                        player.desiredPosition = CGPointMake(player.desiredPosition.x  + intersectionWidth, player.desiredPosition.y);
                    }
                }
            }
        }
    }

    player.position = player.desiredPosition;
}</pre></div><p>What did we just do?</p><p>We used the <code class="literal">CGRectIntersectsRect</code> method to see if the player and the tile rectangles collide. We then used our <code class="literal">tileIndex</code> to determine the exact position of that tile and checked to see if it's a vertical or a horizontal collision. We also created a variable to determine the distance required to move our player so he no longer collides with the tile. Then, we checked to see if our player needs to be moved up or down. When that is determined, we either add or subtract the collision height from our player.</p><p>We also set up Booleans (true or false statements) that will detect whether the player is colliding with the ground; if he is, make him stop, and set the <code class="literal">onGround</code> Boolean to <code class="literal">true</code>.</p><p>Lastly, we set the position of our player to finally resolve the collision.</p><p>Now, in our <code class="literal">Player.h</code> file, we need to add the <code class="literal">onGround</code> Boolean property. With all our other properties, add in the following line of code:</p><div><pre class="programlisting">@property (nonatomic, assign) BOOL onGround;</pre></div><p>Now that we have our little<a id="id112" class="indexterm"/> man working properly, we are going to get to programming his movement! Let's get him dancing! (I won't actually be programming him to dance; however, if that is something you want to do, absolutely be my guest. I won't judge.)</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Making our player dance!</h2></div></div></div><p>For this game, we are going to<a id="id113" class="indexterm"/> make the controls super easy. Touch the right side of the screen, and the player will move forward; touch the left side, and he will jump. You can use the same methods to have him moving forwards and backwards, but this is how we will do it for this example.</p><p>In our <code class="literal">Player.h</code> file, add the following properties:</p><div><pre class="programlisting">@property (nonatomic, assign) BOOL walking;
@property (nonatomic, assign) BOOL jumping;</pre></div><p>Popping over to our <code class="literal">GameLevelScene.m</code> file, we are going to add the following methods:</p><div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    for (UITouch *touch in touches) {
        CGPoint touchLocation = [touch locationInNode:self];
        if (touchLocation.x &gt; self.size.width / 2.0) {
            self.player1.jumping = YES;
        } else {
            self.player1.walking = YES;
        }
    }
}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    for (UITouch *touch in touches) {
        
        float halfWidth = self.size.width / 2.0;
        CGPoint touchLocation = [touch locationInNode:self];         
        //get previous touch and convert it to node space
        CGPoint previousTouchLocation = [touch previousLocationInNode:self];
        
        if (touchLocation.x &gt; halfWidth &amp;&amp; previousTouchLocation.x &lt;= halfWidth) {
            self.player1.walking = NO;
            self.player1.jumping = YES;
        } else if (previousTouchLocation.x &gt; halfWidth &amp;&amp; touchLocation.x &lt;= halfWidth) {
            self.player1.walking = YES;
            self.player1.jumping = NO;
        }
    }
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    
    for (UITouch *touch in touches) {
        CGPoint touchLocation = [touch locationInNode:self];
        if (touchLocation.x &lt; self.size.width / 2.0) {
            self.player1.walking = NO;
        } else {
            self.player1.jumping = NO;
        }
    }
}</pre></div><p>This is a pretty simple set of<a id="id114" class="indexterm"/> methods. We set up the two touch areas on the device's screen, each half of the width of the screen. Once one is touched, it fires the respective Boolean for either walking or jumping, which we will then detect if the Booleans have been fired in our <code class="literal">Player</code> class. Easy? Yup!</p><p>We need to add a small line of code up in our <code class="literal">(id)initWithSize</code> block of code so that we can enable touch controls in our app. Add this line anywhere in that method:</p><div><pre class="programlisting">self.userInteractionEnabled = YES;</pre></div><p>This line just gives us the ability to detect user interaction. If we were to run our app right now and touch the sides of the screen, our player would do absolutely nothing. Because he's a rebel? Not really. We have only set up the touches; we haven't told him what to do when he receives those touches.</p><p>Let's jump on over to <a id="id115" class="indexterm"/>our <code class="literal">Player.m</code> class and edit the <code class="literal">update</code> method so we can get him moving. The update method should look like this, with the highlighted code being the new lines we add:</p><div><pre class="programlisting">- (void)update:(NSTimeInterval)delta {
    
    CGPoint gravity = CGPointMake(0.0, -450.0);
    
    CGPoint gravityStep = CGPointMultiplyScalar(gravity, delta);
    
<strong>   CGPoint movingForward = CGPointMake(750.0, 0.0);</strong>
<strong>   CGPoint movingForwardStep = CGPointMultiplyScalar(walking, delta);</strong>

    self.velocity = CGPointAdd(self.velocity, gravityStep);

<strong>   self.velocity = CGPointMake(self.velocity.x *0.9, self.velocity.y);</strong>

<strong>  //here he shall fly!</strong>
<strong>  </strong>

<strong>  if (self.walking) {</strong>

<strong>  self.velocity = CGPointAdd(self.velocity, movingForwardStep);</strong>
<strong>}</strong>

<strong>  CGPoint minimumMovement = CGPointMake(0.0, -450);</strong>
<strong>  CGPoint maximumMovement = CGPointMake(120.0, 250.0);</strong>
<strong>  self.velocity = CGPointMake(Clamp(self.velocity.x, minimumMovement.x, maximumMovement.x), Clamp(self.velocity.y, minimumMovement.y, maximumMovement.y));</strong>


    CGPoint velocityStep = CGPointMultiplyScalar(self.velocity, delta);
    
    self.desiredPosition = CGPointAdd(self.position, velocityStep);
}</pre></div><p>Seem easy enough? No? Ok, let's explain things a little more. First we added a moving forward "force" that will<a id="id116" class="indexterm"/> be added when the user touches the screen, which is being added at 750 points per second in relation to the delta frame step for smooth motion. Mmmm, smoooooth!</p><p>Next we controlled the moving forward force to imitate the friction of the ground so that, when the player stops moving, he glides briefly instead of coming to an immediate halt.</p><p>Next we checked if the screen is being touched, and if so we add velocity!</p><p>Then came the clamping. Clamping? Think of when you clamp a piece of wood to a work bench, that thing isn't moving. It's the same with the clamp methods; we are "clamping" or limiting the player's maximum and minimum horizontal and vertical speeds. The player will not move outside those limits.</p><p>We shall now add in the jumping method. Back in our <code class="literal">update</code> block of code, just above the <code class="literal">if (self.walking)</code> statement, we are going to add the following code to make our player jump:</p><div><pre class="programlisting">CGPoint jumpForce = CGPointMake(0.0, 310.0);
float jumpTime = 150.0;

if (self.jumping &amp;&amp; self.onGround) {
  self.velocity = CGPointAdd(self.velocity, jumpForce);
} else if (!self.jumping &amp;&amp; self.velocity.y &gt; jumpTime) {
  self.velocity = CGPointMake(self.velocity.x, jumpTime);
}</pre></div><p>This jumping system is similar to that of <em>Super Mario</em> where, if you press and hold the jump button, he will accelerate to a certain point, at which juncture the <code class="literal">jumpTime</code> function then stops him from further accelerating. However, if the player stops pressing the jump button before the jump reaches the <code class="literal">jumpTime</code> function cut off, the jump will be reduced.</p><div><img src="img/B03553_03_18.jpg" alt="Making our player dance!"/></div><p>See that? You're on<a id="id117" class="indexterm"/> your way to creating the next <em>Super Mario</em>! If you run your project and click on the sides of the screen, he will move around and jump! But you know what, I don't like the fact that our player can only move forward. What if he gets stuck? (Like in my level, he can get stuck almost immediately. Oops!) So let's go back to our <code class="literal">Player.h</code> class and add another property:</p><div><pre class="programlisting">@property (nonatomic, assign) BOOL goingBackwards;</pre></div><p>Then on over to our <code class="literal">GameLevelScene.m</code> file, where we make a slight change to our <code class="literal">touchesBegan</code> function and the <code class="literal">TouchesMoved</code> block of code that we added earlier:</p><div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    for (UITouch *touch in touches) {
        CGPoint touchLocation = [touch locationInNode:self];
        if (touchLocation.x &gt; self.size.width / 2.0) {
            self.player1.jumping = YES;
        }        
        else {
            if (touchLocation.x &lt; self.size.width / 2.0) {
                if (touchLocation.y &gt; self.size.height / 2){
                    self.player1.goingBackwards = YES;
        self.player1.xScale = -1.0;
                }
                if (touchLocation.y &lt; self.size.height / 2){
                    self.player1.walking = YES;
            self.player1.xScale = 1.0;
                }
            }
            
        }
    }
}
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    for (UITouch *touch in touches) {
        
        float halfWidth = self.size.width / 2.0;
        CGPoint touchLocation = [touch locationInNode:self];
        
        //get previous touch and convert it to node space
        CGPoint previousTouchLocation = [touch previousLocationInNode:self];
        
        if (touchLocation.x &gt; halfWidth &amp;&amp; previousTouchLocation.x &lt;= halfWidth) {
            self.player1.walking = NO;
            self.player1.goingBackwards = NO;
            self.player1.jumping = YES;
        } else if (previousTouchLocation.x &gt; halfWidth &amp;&amp; touchLocation.x &lt;= halfWidth) {
            //self.player1.walking = YES;
            self.player1.goingBackwards = NO;
            self.player1.jumping = NO;
        }
        else if (previousTouchLocation.x &gt; halfWidth &amp;&amp; touchLocation.x &lt;= halfWidth) {
            if (touchLocation.y &gt; self.size.height / 2){
            self.player1.walking = NO;
            //self.player1.goingBackwards = YES;
            self.player1.jumping = NO;
            }
        }
    }
}
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    
    for (UITouch *touch in touches) {
        CGPoint touchLocation = [touch locationInNode:self];
        if (touchLocation.x &lt; self.size.width / 2.0) {
            //self.player1.walking = NO;
            if (touchLocation.x &lt; self.size.width / 2.0) {
                if (touchLocation.y &gt; self.size.height / 2){
                    self.player1.goingBackwards = NO;
                }
                if (touchLocation.y &lt; self.size.height / 2){
                    self.player1.walking = NO;
                }
            }
            
        } else {
            self.player1.jumping = NO;
        }
    }
}</pre></div><p>So now, instead of having the screen halved with one walking button and one jumping button, we have the screen split into<a id="id118" class="indexterm"/> three, with the walking button as one half of the screen, and that half has been split height-wise, as shown in the following screenshot:</p><div><img src="img/B03553_03_19.jpg" alt="Making our player dance!"/></div><p>Let's pop over to <a id="id119" class="indexterm"/>our <code class="literal">Player.m</code> file and make some very small adjustments to our <code class="literal">update</code> method. We are going to add in the following lines:</p><div><pre class="programlisting">    CGPoint movingBackward = CGPointMake(-750.0, 0.0);
    CGPoint movingBackwardStep = CGPointMultiplyScalar(movingBackward, delta);</pre></div><p>These lines are a reverse of the walking forward method we created, hence the -750 value. Now under our <code class="literal">if (self.walking)</code> method, we are going to add the following <code class="literal">if</code> statement:</p><div><pre class="programlisting">    if (self.goingBackwards) {
        self.velocity = CGPointAdd(self.velocity, movingBackwardStep);
    }
  //The below value has to be changed to allow a negative x value to walk backwards.
    CGPoint minimumMovement = CGPointMake(-750.0, -450);</pre></div><p>This again is just a reverse of the walking forward movement. Test it out to see if it's working; if so, he should be backtracking on his steps like a scared cat!</p><p>Now we are going to get the screen scrolling as our player moves towards the edge of the screen. On to our <code class="literal">GameLevelScene.m</code> class, to which we add the following code:</p><div><pre class="programlisting">//Add this in the import section
#import "SKTUtils.h"

//Then add this wherever you like, after any of the methods
- (void)setViewpointCenter:(CGPoint)position {
  NSInteger x = MAX(position.x, self.size.width / 2);
  NSInteger y = MAX(position.y, self.size.height / 2);
  x = MIN(x, (self.map.mapSize.width * self.map.tileSize.width) - self.size.width / 2);
  y = MIN(y, (self.map.mapSize.height * self.map.tileSize.height) - self.size.height / 2);
  CGPoint actualPosition = CGPointMake(x, y);
  CGPoint centerOfView = CGPointMake(self.size.width/2, self.size.height/2);
  CGPoint viewPoint = CGPointSubtract(centerOfView, actualPosition);
  self.map.position = viewPoint;
}

//Then add this in the Update method
[self setViewpointCenter<strong>:self.player1.position</strong>];</pre></div><p>This block<a id="id120" class="indexterm"/> constrains the position of the screen to the player when he reaches the center of the view.</p><p>Test it to see if it works!</p><div><img src="img/B03553_03_20.jpg" alt="Making our player dance!"/></div><p>This is starting to <a id="id121" class="indexterm"/>look so good! But if you've noticed, he can't die. Sadly, we do want him to die when he hits spikes or falls down those scary pits, don't we?</p><p>Let's integrate the hazards layer in our TMX map. To do this, we have to go to our <code class="literal">GameLevelScene.m</code> file and add in the following detection method:</p><div><pre class="programlisting">//Add this at the top of the code
@property (nonatomic, strong) TMXLayer *hazards;

//Add this in the initWithSize method after we set up the Walls
self.hazards = [self.map layerNamed:@"hazards"];

//add this in the checkForAndResolveCollisionsForPlayer
[self handleHazardCollisions:self.player1];

//Add this anywhere!

- (void)handleHazardCollisions:(Player *)player
{
    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};
    
    for (NSUInteger i = 0; i &lt; 8; i++) {
        NSInteger tileIndex = indices[i];
        
        CGRect playerRect = [player collisionBox];
        CGPoint playerCoord = [self.hazards coordForPoint:player.desiredPosition];
        
        NSInteger tileColumn = tileIndex % 3;
        NSInteger tileRow = tileIndex / 3;
        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));
        
        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:self.hazards];
        if (gid != 0) {
            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];
            if (CGRectIntersectsRect(playerRect, tileRect)) {
                [self gameOver:0];
            }
        }
    }
}</pre></div><p>This is essentially the <a id="id122" class="indexterm"/>same code that we used for our <code class="literal">checkForAndResolveCollisionsForPlayer</code> function. We only added a <code class="literal">gameOver</code> method whereby, when it equals <code class="literal">0</code>, the player dies, and when it's <code class="literal">1</code>, the player beats the level.</p><p>You will have errors showing at the moment. We haven't incorporated our game over feature yet, so let's do that now. Again in our <code class="literal">GameLevelScene.m</code> file, let's add the following code:</p><div><pre class="programlisting">//add this at the top with all the other properties
@property (nonatomic, assign) BOOL gameOver;

//Put this in the update method
if (self.gameOver) return;

//Then add this method anywhere in the GameLevelScene
-(void)gameOver:(BOOL)won {
    
    self.gameOver = YES;
    
    NSString *gameText;
    if (won) {
        gameText = @"Level Complete!";
    } else {
        gameText = @"You have failed!";
    }
    
    
    SKLabelNode *endGameLabel = [SKLabelNode labelNodeWithFontNamed:@"AvenirNext-Heavy"];
    endGameLabel.text = gameText;
    endGameLabel.fontSize = 40;
    endGameLabel.position = CGPointMake(self.size.width / 2.0, self.size.height / 1.7);
    [self addChild:endGameLabel];
    
    
    UIButton *replay = [UIButton buttonWithType:UIButtonTypeCustom];
    replay.tag = 321;
    UIImage *replayImage = [UIImage imageNamed:@"replay"];
    [replay setImage:replayImage forState:UIControlStateNormal];
    [replay addTarget:self action:@selector(replay:) forControlEvents:UIControlEventTouchUpInside];
    replay.frame = CGRectMake(self.size.width / 2.0 - replayImage.size.width / 2.0, self.size.height / 2.0 - replayImage.size.height / 2.0, replayImage.size.width, replayImage.size.height);
    [self.view addSubview:replay];
}

//Add this into the checkForAndResolveCollisionsForPlayer, after CGPoint playerCoord = [layer coordForPoint:player1.desiredPosition]; 
if (playerCoord.y &gt;= self.map.mapSize.height - 1) {
  [self gameOver:0];
  return;
}</pre></div><p>Let's break it down as we <a id="id123" class="indexterm"/>usually do. Firstly, we set up the new game over the Boolean, which we use whenever the player collides with a hazard, or later an enemy.</p><p>After that, we set a level win and a level failed string (or text) to pop up whenever the player either beats the level or loses. I used <em>Avenir Next Heavy</em> as a font. There are a ton of fonts that you can use for your game. For an awesome site showing all the fonts you can use, check out <a class="ulink" href="http://iosfonts.com">iosfonts.com</a>.</p><p>We then created a <code class="literal">UIButton</code> the user will be able to tap to restart the level. (Don't forget to add in the <code class="literal">replay.png</code> and <code class="literal">replay@2x.png</code> image files that I supplied in the resources section of this chapter.)</p><p>Finally we added in the method that checks the player's position; if he is below the map—in other words, if he's fallen down a hole or crack in the map—we call game over.</p><p>But our poor little guy isn't going to experience just death! He needs to win every once and a while, right? Well we need to add those methods as well! Don't worry, it's super easy!</p><p>In our <code class="literal">GameLevelScene.m</code> file, we need to add a new method:</p><div><pre class="programlisting">-(void)didHeWin {
  if (self.player1.position.x &gt; 3200.0) {
    [self gameOver:1];
  }
}</pre></div><p>This is a positionally based win, so once our player reaches the <code class="literal">x</code> value of <code class="literal">3200</code> on the map we will call a win. We can have a win layer on the TMX map and incorporate that layer, but this just seems easier! Finally, in the <code class="literal">handleHazardCollisions</code> section, we need to check if our little guy has won:</p><div><pre class="programlisting">[self didHeWin];</pre></div><p>We now test this to see if it <a id="id124" class="indexterm"/>works and you will see the following screen:</p><div><img src="img/B03553_03_21.jpg" alt="Making our player dance!"/></div><p>When we fail a level, we land on spikes, ouch! But we reach the end of the level, as shown in the following <a id="id125" class="indexterm"/>screenshot:</p><div><img src="img/B03553_03_22.jpg" alt="Making our player dance!"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Summary</h1></div></div></div><p>Oh my goodness! It's starting to look great, isn't it? We've done a lot of work in this chapter! What with our level design, figuring a way around implementing our maps into our project, creating our little player, and making him move, collide, and jump around, we certainly have done a lot.</p><p>For now, let's go take a break! In the next chapter, we are going to do some more creation, such as adding awesome music and sound effects, to polish the game up a bit, and maybe add some menus, particle effects, and even some enemies!</p><p>Go get yourself a nice strong &lt;insert beverage of choice here&gt;, and I'll see you in the next chapter!</p></div></body></html>