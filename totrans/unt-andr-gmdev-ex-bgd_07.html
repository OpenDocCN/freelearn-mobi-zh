<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Throwing Your Weight Around – Physics and a 2D Camera</h1></div></div></div><p>
<em>In the previous chapter, we learned about the special features of a mobile device and how to create touch and tilt controls. We also created a Space Fighter game to use these new controls. The steering of the ship was done by tilting the device and shooting by touching the screen. Using some special movement tricks, we gave the player an infinite amount of space to fly and enemies to fight.</em>
</p><p>
<em>In this chapter, we take a short break from the Space Fighter game to explore Unity's physics engine. We will also take a look at options for creating a 2D game experience. To do all of this, we will be recreating one of the most popular mobile games on the market, Angry Birds. We will use physics to throw birds and destroy structures. We will also take a look at the creation of a level-selection screen.</em>
</p><p>In this chapter, we will be covering the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unity Physics</li><li class="listitem" style="list-style-type: disc">Parallax scrolling</li><li class="listitem" style="list-style-type: disc">Isometric camera</li><li class="listitem" style="list-style-type: disc">Level selection</li></ul></div><p>We will be creating a new project for this chapter, so start up Unity and let's begin!</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec96"/>2D games in a 3D world</h1></div></div></div><p>Perhaps the most underrealized thing when developing games is the fact that it's possible to create 2D-style games in a 3D game<a id="id455" class="indexterm"/> engine such as Unity. As with everything else, it comes with its own set of advantages and disadvantages, but the choice can be well worth it for generating a pleasing game experience. The foremost of the advantages is that one can use 3D assets for the game. This allows dynamic lighting and shadows to be easily included. However, if using a 2D engine, any shadow would need to be painted directly into the assets and you would be hard-pressed to make it dynamic. On the disadvantage side is the use of 2D assets in the 3D world. It is completely possible to use them, but large file sizes become necessary to achieve the desired detail and keep it from appearing pixelated. Most 2D engines, however, make use of vector art that will keep the image's lines smooth as it is scaled up and down. Also, one is able to use normal animations for the 3D assets, but frame-by-frame animation is generally required for any 2D asset. Altogether, the advantages have outweighed the<a id="id456" class="indexterm"/> disadvantages for many developers, creating a large selection of great looking 2D games that you may never realize were actually made in a 3D game engine. Now, we shall design another game by recreating the highly popular Angry Birds.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec97"/>Time for action – preparing the world</h1></div></div></div><p>Let's get started with preparing the world for the Angry Birds game:</p><div><ol class="orderedlist arabic"><li class="listitem">To start it all off, we need to create a new project in Unity. Naming it <code class="literal">Ch7_AngryBirds</code> will work well. Be sure to change the target platform to <strong>Android</strong> and set the <strong>Bundle Identifier</strong> to an appropriate value.</li><li class="listitem">Next, import the starting assets for this chapter and create some folders to keep everything organized.</li><li class="listitem">In Unity, it is very easy to turn a game from 3D to 2D. Simply select the <strong>Main Camera</strong> object that is by default present in every new scene, find the <strong>Projection</strong> value, and select <strong>Orthographic</strong> from the drop-down list.<div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>Every camera has two options for how to render the game. <strong>Perspective</strong> renders everything utilizing the distance from the camera, imitating the real world; objects that are farther away from the camera are drawn smaller than objects that are closer. <strong>Orthographic</strong> renders everything without this consideration; objects are not scaled based on their distance from the camera.</p></div></div></li><li class="listitem">Initially, the amount of the scene that the camera views is far too large. To change this, set the <strong>Size</strong> value to <code class="literal">5</code>. This reduces the amount of space the camera will render. This value will keep us focused on the action as the game is played.</li><li class="listitem">To make the camera properly usable, set its <strong>Position</strong> to <code class="literal">10</code> for the <strong>X</strong> axis, <code class="literal">3</code> for the <strong>Y</strong> axis, and <code class="literal">0</code> for the <strong>Z</strong> axis. Also, set its <strong>Rotation</strong> for the <strong>Y</strong> axis to <code class="literal">-90</code>. Everything is going to be positioned along the z axis, so our camera needs to be set to watch the axis and be far away enough so that it is not in the action.</li><li class="listitem">Next, we are going to need a ground. So, go to the menu bar of Unity and click on <strong>GameObject</strong>, followed by <strong>Create Other</strong>, and finally, click on <strong>Cube</strong>. This will suit well enough as a simple ground.</li><li class="listitem">To make it look a little like a ground, create a green material and apply it to the <strong>Cube</strong>.</li><li class="listitem">The ground cube needs to be large enough to cover the whole of our field of play. To do this, set its <strong>Scale</strong> to <code class="literal">5</code> for the <strong>X</strong> axis, <code class="literal">10</code> for the <strong>Y</strong> axis, and <code class="literal">100</code> for the <strong>Z</strong> axis. Also, set its <strong>Position</strong> to <code class="literal">0</code> for the <strong>X</strong> and <strong>Y</strong> axes, and <code class="literal">30</code> for the <strong>Z</strong> axis. Since nothing will be moving along the x axis, the ground only needs to be large enough for the other objects that will be in our scene to land on. It does, however, need to be wide and tall enough to keep the camera from seeing the edges.</li><li class="listitem">Right now, the <a id="id457" class="indexterm"/>ground looks rather dark due to the lack of light. From the menu bar of Unity, click on <strong>GameObject</strong>, followed by <strong>Create Other</strong>, and lastly click on <strong>Directional Light</strong> to add some brightness to the scene. It should be positioned to shine on the side of the cube that faces the camera.</li><li class="listitem">Next, we need to keep all of the objects that will be flying around the scene from straying too far and causing problems. To do this, we need to create some trigger volumes. The simplest way to do this is to create three more cubes. Position one at each end of the ground object and the last cube at about 50 units above. Then, scale them to form a box with the ground. Each should be no thicker than a single unit, and they need to be five units deep, the same as the ground. Next, remove their <strong>Mesh Renderer</strong> and <strong>Mesh Filter</strong> components. This removes the visible box, while leaving the collider volume. To change them to trigger volumes, check the <strong>Is Trigger</strong> checkbox on each <strong>Box Collider</strong> component.</li><li class="listitem">To make the volumes actually keep objects from straying too far, we need to create a new script. Create it and name it <code class="literal">GoneTooFar</code>.</li><li class="listitem">This script has a single, short function, <code class="literal">OnTriggerEnter</code>.<a id="id458" class="indexterm"/> We use it to destroy any object that might enter the volume. This function is used by Unity's physics system to detect when an object has entered a trigger volume. We will go into more detail later but, for now, know that one of the two objects, either the volume or the object entering it, needs a <strong>Rigidbody</strong> component. In our case, everything we might want to remove when they enter the trigger will have a <strong>Rigidbody</strong> component.<div><pre class="programlisting">public void OnTriggerEnter(Collider other) {
  Destroy(other.gameObject);
}</pre></div></li><li class="listitem">Finally, return to Unity and add the script to the three trigger-volume objects.<div><img src="img/2014OT_07_01.jpg" alt="Time for action – preparing the world"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>
<em>What just happened?</em>
</h2></div></div></div><p>We did the initial setup for <a id="id459" class="indexterm"/>our 2D game. By changing our camera view to <strong>Orthographic</strong>, the view switches from a 3D game to a 2D one. We also created a ground and some trigger volumes for our scene. Together, these will keep our birds and anything else from straying too far.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec98"/>Physics</h1></div></div></div><p>In Unity, physics simulation primarily focuses on the use of the <strong>Rigidbody</strong> component. When the <strong>Rigidbody</strong> component <a id="id460" class="indexterm"/>is attached to any object, it will be taken over by the physics engine. The object will fall with gravity and bump into any object that has a collider. In our scripts, making use of the <code class="literal">OnCollision</code> function and the <code class="literal">OnTrigger</code> function requires a <strong>Rigidbody</strong> component to be attached to at least one of the two interacting objects. However, a <strong>Rigidbody</strong> component can interfere with any specific movement we might cause the object to take. Every <strong>Rigidbody</strong>, though, can be marked as kinematic, meaning the physics engine will not move it. The <strong>CharacterController</strong> component that we used for our tank is a special, modified <strong>Rigidbody</strong>. In this chapter, we will be making heavy use of the <strong>Rigidbody</strong> component to tie all of our birds, blocks, and pigs into the physics engine.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Building blocks</h2></div></div></div><p>For our first physics objects, we will create the blocks that the pig castles are built out of. We will be creating three types of blocks: wood, glass, and rubber. With these few simple blocks, we will be able to easily create a large variety of levels and structures to smash with birds.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec99"/>Time for action – creating planks</h1></div></div></div><p>Each of the blocks we will be<a id="id461" class="indexterm"/> creating will be largely similar:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we will create the plank of wood. To do this, we need another cube. Rename it <code class="literal">Plank_Wood</code>.</li><li class="listitem">Set the plank's <strong>Scale</strong> to <code class="literal">2</code> for the <strong>X</strong> and <strong>Y</strong> axes, and <code class="literal">0.25</code> for the <strong>Z</strong> axis. Its scale on the y and z axis define its size as seen by the player. The scale on the x axis makes sure that it will be hit by other physics objects in the scene.</li><li class="listitem">Next, create a new material using the <code class="literal">plank_wood</code> texture and apply it to the cube.</li><li class="listitem">To convert this new wood plank into a physics object, add a <strong>Rigidbody</strong> component. Make sure your plank is selected, go to the menu bar of Unity and click on <strong>Component</strong>, followed by <strong>Physics</strong>; finally, click on <strong>Rigidbody</strong>.</li><li class="listitem">We need to keep the plank from moving along the x axis and out of alignment with our other physics objects as well as keeping it from rotating to show its other sides to the player. To do this, we make use of the <strong>Constraints</strong> group of checkboxes on the <strong>Rigidbody</strong> component. Check the checkbox for the <strong>X</strong> axis next to <strong>Freeze Position</strong> and the <strong>Y</strong> and <strong>Z</strong> checkboxes next to <strong>Freeze Rotation</strong>. These will keep the object from moving in ways we don't want it to.</li><li class="listitem">To make the plank function properly within our game, we need to create a new script and name it <code class="literal">Plank</code>.</li><li class="listitem">This script begins with a<a id="id462" class="indexterm"/> bunch of variables. The first two are for tracking the health of the plank. We need to separate the total amount of health from the current health, so we will be able to detect when the object has been reduced to half health. At that point, we will make use of our next three variables to change the object's material to one that shows damage. The last variable is used when the object runs out of health and is destroyed. We will use it to increase the player's score.<div><pre class="programlisting">public float totalHealth = 100f;
private float health = 100f;

public Material damageMaterial;
public Renderer plankRenderer;
private bool didSwap = false;

public int scoreValue = 100;</pre></div></li><li class="listitem">For the script's first function, we use <code class="literal">Awake</code> for initialization. We make sure the object's current health is the same as its total health, and we make sure the <code class="literal">didSwap</code> flag is set to <code class="literal">false</code>.<div><pre class="programlisting">public void Awake() {
  health = totalHealth;
  didSwap = false;}</pre></div></li><li class="listitem">Next, we make use of the <code class="literal">OnCollisionEnter</code> function<a id="id463" class="indexterm"/>. This is a special function, triggered by the <strong>Rigidbody</strong> component, that gives us information about what the object collided with and how. We use this information to find <code class="literal">collision.relativeVelocity.magnitude</code>. This is the speed at which the objects collided, and we use it as damage to reduce the current health. Next, the function checks to see if the health has been reduced to half and calls the <code class="literal">SwapToDamaged</code> function if it has. By using the <code class="literal">didSwap</code> flag, we make sure the function will only be called once. Finally, for the function, it checks to see if the health has dropped below zero. If it has, the object is destroyed and we call the <code class="literal">LevelTracker</code> script, which we will soon be making, to add to the player's score.<div><pre class="programlisting">public void OnCollisionEnter(Collision collision) {
  health -= collision.relativeVelocity.magnitude;

  if(!didSwap &amp;&amp; health &lt; totalHealth / 2f) {
    SwapToDamaged();
  }

  if(health &lt;= 0) {
    Destroy(gameObject);
    LevelTracker.AddScore(scoreValue);
  }
}</pre></div></li><li class="listitem">Finally for the script, we have the <code class="literal">SwapToDamaged</code> function<a id="id464" class="indexterm"/>. It starts by setting the <code class="literal">didSwap</code> flag to <code class="literal">true</code>. Next, it checks to make sure the <code class="literal">plankRenderer</code> and <a id="id465" class="indexterm"/><code class="literal">damageMaterial</code> variables have references to other objects. Ultimately, it uses the <code class="literal">plankRenderer.sharedMaterial</code> value to change to the damaged looking material.<div><pre class="programlisting">public void SwapToDamaged() {
  didSwap = true;
  if(plankRenderer == null) return;
  if(damageMaterial == null) return;

  plankRenderer.sharedMaterial = damageMaterial;
}</pre></div></li><li class="listitem">Before we can add our <code class="literal">Plank</code> script to our objects, we need to create the <code class="literal">LevelTracker</code> script that was mentioned earlier. Create it now.</li><li class="listitem">This script is fairly short and starts with a single variable. The variable will track the player's score for the level and is <code class="literal">static</code> so that it can be easily changed as objects are destroyed for points.<div><pre class="programlisting">private static int score = 0;</pre></div></li><li class="listitem">Next, we use the <code class="literal">Awake</code> function to make sure the player starts at zero when beginning a level.<div><pre class="programlisting">public void Awake() {
  score = 0;
}</pre></div></li><li class="listitem">Finally for the script, we add the <code class="literal">AddScore</code> function<a id="id466" class="indexterm"/>. This function simply takes the amount of points passed to it and increases the player's score. It is also <code class="literal">static</code>, so that it can be called by any object in the scene without needing a reference to the script.<div><pre class="programlisting">public static void AddScore(int amount) {
  score += amount;
}</pre></div></li><li class="listitem">Back in Unity, we need to create a new material using the <code class="literal">plank_wood_damaged</code> texture. This will be the material that the script will swap to.</li><li class="listitem">Add the <code class="literal">Plank</code> script to our <code class="literal">Plank_Wood</code> object. Connect the <strong>Damaged Material</strong> reference to the new material and the <strong>Plank Renderer</strong> reference to the object's <strong>Mesh Renderer</strong> component.</li><li class="listitem">As we create different types of planks, we can adjust the <strong>Total Health</strong> value to give them different strengths. A value of <code class="literal">25</code> works pretty well for the wood planks.</li><li class="listitem">Next, create an empty <strong>GameObject</strong> and rename it <code class="literal">LevelTracker</code>.</li><li class="listitem">Add the <code class="literal">LevelTracker</code> script to the object and it will begin to track the player's score.</li><li class="listitem">If you want to see the wood plank in action, position it above the ground and hit the play button. As soon as the game starts, Unity's physics will take over and drop the plank with gravity. If it started out high enough, you will be able to see it switch textures as it loses health.</li><li class="listitem">To make the other two <a id="id467" class="indexterm"/>planks that we need, select the <code class="literal">Plank_Wood</code> object and press <em>Ctrl</em> + <em>D</em> twice to duplicate it. Rename one to <code class="literal">Plank_Glass</code> and the other to <code class="literal">Plank_Rubber</code>.</li><li class="listitem">Next, create three new materials. One should be purple for the rubber plank, one should use the <code class="literal">plank_glass</code> texture for the glass plank, and the last material should use the <code class="literal">plank_glass_damaged</code> texture for when the glass plank is damaged. Apply the new materials to the proper locations for the new planks.</li><li class="listitem">As for the health of the new planks, a value of <code class="literal">15</code> for the glass and <code class="literal">100</code> for the rubber will work well.</li><li class="listitem">Finally, turn your three planks into prefabs and use them to build a structure for us to knock down. Feel free to scale them to make different-sized blocks, but leave the x axis alone. Also, all of the blocks should be positioned at zero on the x axis and your structure should be centered around about <code class="literal">30</code> on the z axis.<div><img src="img/2014OT_07_02.jpg" alt="Time for action – creating planks"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the building blocks<a id="id468" class="indexterm"/> we needed for the structures that are going to be knocked down in our game. We used a <strong>Rigidbody</strong> component to tie them into the physics engine. Also, we created a script that keeps track of their health and swaps materials when it drops below half.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Have a go hero – creating a stone block</h2></div></div></div><p>Wood and glass work well as basic blocks. But, if we are going to make harder levels, we need something a little stronger. Try your hand at making a stone block. Create two textures and materials for it to show its pristine and damaged states.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Physics materials</h2></div></div></div><p>Physics materials are special types <a id="id469" class="indexterm"/>of materials that specifically tell the physics engine how two objects should interact. This does not affect the appearance of an object. It defines the friction and bounciness of a collider. We will use them to give our rubber plank some bounce and the glass plank some slide.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec100"/>Time for action – sliding and bouncing</h1></div></div></div><p>Physics materials are quick enough to implement and will allow us to complete this section in four short steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Physics materials are created <a id="id470" class="indexterm"/>like everything else, in the <strong>Project</strong> panel. Right-click inside the <strong>Project</strong> panel and click on <strong>Create</strong> | <strong>Physic Material</strong>. Create two physic materials and name one <code class="literal">Glass</code> and the other <code class="literal">Rubber</code>.</li><li class="listitem">Select one of them and take a look at it in the <strong>Inspector</strong> window. Right now, we are only concerned with the first three values. The others are used for more complex situations.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Dynamic Friction</strong>: This property is the amount of friction used when the object is moving. A value of zero is no friction, such as ice, and a value of one is a lot of friction, such as rubber.</li><li class="listitem" style="list-style-type: disc"><strong>Static Friction</strong>: This property functions the same as <strong>Dynamic Friction</strong>, the difference being that it is used when the object is not moving.</li><li class="listitem" style="list-style-type: disc"><strong>Bounciness</strong>: This property is how much of an object's energy is reflected when it hits something or is hit by something. Zero means none of the energy is reflected, while a value of one will reflect all of it.</li></ul></div></li><li class="listitem">For the <code class="literal">Glass</code> material, set the two friction values to <code class="literal">0.1</code> and <strong>Bounciness</strong> to <code class="literal">0</code>. For the <code class="literal">Rubber</code> material, set the two friction values to <code class="literal">1</code> and <strong>Bounciness</strong> to <code class="literal">0.8</code>.</li><li class="listitem">Next, select your <code class="literal">Plank_Glass</code> prefab and take a look at its <strong>Box Collider</strong> component. To apply your new physics materials, simply drag-and-drop one from the <strong>Project</strong> to the <strong>Material</strong> slot. Do the same for your <code class="literal">Plank_Rubber</code> prefab and, any time an object hits one of them, the materials will be used to control their interaction.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec100"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a pair of physics materials. They control how two colliders interact when they run into each other. Using them, we are given control over the amount of friction and bounciness that is possessed by any collider.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec101"/>Characters</h1></div></div></div><p>Having a bunch of generic blocks is just the beginning of this game. Next, we are going to create a few characters to add some life to the game. We are going to need some evil pigs to destroy and some good birds to throw at them.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec101"/>The enemy</h2></div></div></div><p>Our first character will be the enemy pig. On their own, they don't actually do anything. So, they are really just the wooden blocks we made earlier that happen to look like pigs. To make their destruction the goal of the game, however, we are going to expand our <code class="literal">LevelTracker</code> script to watch them and trigger a Game Over event if they are all destroyed. We will also expand it to draw the score on the screen and make it save the score for later use. To demonstrate the use of 2D assets in the 3D environment, the pigs are also created as flat textures.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec102"/>Time for action – creating the pigs</h1></div></div></div><p>Let's get started with creating the pigs for the Angry Birds game:</p><div><ol class="orderedlist arabic"><li class="listitem">The pigs are created in a manner similar to that of the the wood planks. Start by creating an empty <strong>GameObject</strong> and naming it <code class="literal">Pig</code>.</li><li class="listitem">Next, create a plane, <a id="id471" class="indexterm"/>make it a child of the <code class="literal">Pig</code> object, and remove its <strong>Mesh Collider</strong> component. We do this because of the rotation the plane will need to face the camera. Being a child of the empty <strong>GameObject</strong> allows us to ignore that rotation when working with the pig.</li><li class="listitem">Set the plane's local <strong>Position</strong> to <code class="literal">0</code> on each axis and set its <strong>Rotation</strong> to <code class="literal">90</code> on the <strong>X</strong> axis, <code class="literal">270</code> on the <strong>Y</strong> axis, and <code class="literal">0</code> on the <strong>Z</strong> axis. This will make the plane face the camera.</li><li class="listitem">Now, create two materials. Name one <code class="literal">Pig_Fresh</code> and the other <code class="literal">Pig_Damage</code>. From their <strong>Shader</strong> drop-down list, select <strong>Transparent</strong>, followed by <strong>Cutout</strong>, and finally <strong>Soft Edge Unlit</strong>. This allows us to make use of the the texture's alpha channel and provide some transparency.</li><li class="listitem">Finish off the materials by adding the <code class="literal">pig_damage</code> and <code class="literal">pig_fresh</code> textures to them.</li><li class="listitem">To the <code class="literal">Pig</code> object, add a <strong>Sphere Collider</strong> component, a <strong>Rigidbody</strong> component, and the <code class="literal">Plank</code> script. We make use of the <strong>Sphere Collider</strong> component, rather than the <strong>Mesh Collider</strong> component the plane came with, because the plane has zero thickness and will, therefore, have many issues colliding with other objects.</li><li class="listitem">To complete the pig's creation, apply your material to the plane and connect the references in the <code class="literal">Plank</code> script. Finally, set the <strong>Constraints</strong> parameters on the <strong>Rigidbody</strong> component just as we did for the other planks.</li><li class="listitem">Now, turn the pig<a id="id472" class="indexterm"/> into a prefab and add it to your structure. Remember, leave them at zero on the x axis, but feel free to adjust their size, health, and score values to give them some variety.</li><li class="listitem">Next, we need to expand the <code class="literal">LevelTracker</code> script. Open it up and we can add some more code.</li><li class="listitem">First, we add some more variables at the beginning of the script. The first one, as its name suggests, will hold a list of all the pigs in our scene. Next is a flag for signaling that the game has ended. And finally, a string for telling the player why the game has ended.<div><pre class="programlisting">public Transform[] pigs = new Transform[0];

private static gameOver = false;
private static string message = "";</pre></div></li><li class="listitem">Next, we need to add a line to the <code class="literal">Awake</code> function. This simply makes sure that the <code class="literal">gameOver</code> flag is <code class="literal">false</code> when the level starts.<div><pre class="programlisting">gameOver = false;</pre></div></li><li class="listitem">We use the <code class="literal">OnGUI</code> function<a id="id473" class="indexterm"/> to draw a Game Over screen when the game has ended, or for drawing the current score if it is still continuing.<div><pre class="programlisting">public void OnGUI() {
  if(gameOver)
    DrawGameOver();
  else
    DrawScore();}</pre></div></li><li class="listitem">The <code class="literal">DrawScore</code> function<a id="id474" class="indexterm"/> takes the current score and uses <code class="literal">GUI.Label</code> to draw it in the top-right corner of the screen.<div><pre class="programlisting">private void DrawScore() {
  Rect scoreRect = new Rect(Screen.width – 100, 0, 100, 30);
  GUI.Label(scoreRect, "Score: " + score);
}</pre></div></li><li class="listitem">The <code class="literal">DrawGameOver</code> function<a id="id475" class="indexterm"/> first uses the <code class="literal">GUI.Box</code> function to draw a dark box over the whole of the screen, simultaneously drawing the Game Over message on the screen. Next, it draws the player's final score in the middle of the screen. Below that, it draws a button. This button will save the player's current score and load the level-selection screen we will create later. The <code class="literal">Application.LoadLevel</code> function is used to load any other scene in your game. All of the scenes you intend to load have to be added to the <strong>Build Settings</strong> window found in the <strong>File</strong> menu and can be loaded by using either their name or their index, as used here:<div><pre class="programlisting">private void DrawGameOver() {
  Rect boxRect =  new Rect(0, 0, Screen.width, Screen.height);
  GUI.Box(boxRect, "Game Over\n" + message);

  Rect scoreRect = new Rect(0, Screen.height / 2, Screen.width, 30);
  GUI.Label(scoreRect, "Score: " + score);

  Rect exitRect = new Rect(0, Screen.height / 2 + 50, Screen.width, 50);
  if(GUI.Button(exitRect, "Return to Level Select")) {
    Application.LoadLevel(0);
    SaveScore();
  }
}</pre></div></li><li class="listitem">In the <code class="literal">LateUpdate</code> function, we call another function to check whether all the pigs have been destroyed if the game is not yet over.<div><pre class="programlisting">public void LateUpdate() {
  if(!gameOver)
    CheckPigs();
}</pre></div></li><li class="listitem">Next, we add the <code class="literal">CheckPigs</code> function<a id="id476" class="indexterm"/>. This function loops through the list of pigs to see if they<a id="id477" class="indexterm"/> are all destroyed. Should it find one that is still around, it exits the function. Otherwise, the game is flagged as being over and the message is set to tell the player that they succeeded in destroying all of the pigs.<div><pre class="programlisting">private void CheckPigs() {
  for(int i=0;i&lt;pigs.Length;i++) {
    if(pigs[i] != null) return;
  }

  gameOver = true;
  message = "You destroyed the pigs!";
}</pre></div></li><li class="listitem">The <code class="literal">OutOfBirds</code> function<a id="id478" class="indexterm"/> will be called by the slingshot we are going to create later, when the player runs out of birds to launch at the pigs. If the game has not yet ended, the function ends the game and sets an appropriate message for the player.<div><pre class="programlisting">public static void OutOfBirds() {
  if(gameOver) return;

  gameOver = true;
  message = "You ran out of birds!";
}</pre></div></li><li class="listitem">Finally, we have the <code class="literal">SaveScore</code> function<a id="id479" class="indexterm"/>. Here, we use the <code class="literal">PlayerPrefs</code> class. It lets us easily store and retrieve small amounts of data, perfect for our current needs. We just need to provide it with a unique key to save the data under. For that, we use a short string combined with the level's index as provided by <code class="literal">Application.loadedLevel</code>. Next, we use <code class="literal">PlayerPrefs.GetInt</code> to retrieve the last score that was saved. If there isn't one, the zero that we passed to the<a id="id480" class="indexterm"/> function is returned as a default value. Finally, we compare the new score with the old score and use <code class="literal">PlayerPrefs.SetInt</code> to save the new score if it is higher.<div><pre class="programlisting">private void SaveScore() {
  string key = "LevelScore" + Application.loadedLevel;
  int previousScore = PlayerPrefs.GetInt(key, 0);
  if(previousScore &lt; score) 
    PlayerPrefs.SetInt(key, score);
}</pre></div></li><li class="listitem">Back in Unity, the pigs need to be added to the <code class="literal">LevelTracker</code> script's list. With the <code class="literal">LevelTracker</code> script selected, drag-and-drop each pig to the <code class="literal">Pigs</code> value in the <strong>Inspector</strong> window to add them.<div><img src="img/2014OT_07_03.jpg" alt="Time for action – creating the pigs"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec102"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the pigs and updated our <code class="literal">LevelTracker</code> script to track them. The pigs are really just like the<a id="id481" class="indexterm"/> planks of wood, but are spheres instead of boxes. The updated <code class="literal">LevelTracker</code> script watches for the instance when all of the pigs are destroyed and triggers a Game Over screen when they are. It also handles the drawing of the score while the game is being played and the saving of that score when the level is over.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec103"/>The ally</h2></div></div></div><p>Next, we need something to throw at the pigs and their fortification. Here, we will create the simplest of the birds. The red bird is essentially just a rock. He has no special powers and nothing particularly special about his code, besides health. You will also notice that the bird is a 3D model, giving it the shadows that the pigs are missing.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec103"/>Time for action – creating the red bird</h1></div></div></div><p>Let's get started with <a id="id482" class="indexterm"/>creating the red bird:</p><div><ol class="orderedlist arabic"><li class="listitem">Although the red bird model is 3D, it is set up in a manner similar to that of the pig. Create an empty <strong>GameObject</strong>, naming it <code class="literal">Bird_Red</code>, and add the appropriate model from the <code class="literal">birds</code> model as a child, zeroing out its position. The model should be rotated to align it along the z axis. If turned a little more toward the camera, the player is able to see the bird's face while still giving the impression of looking down the field.</li><li class="listitem">Next, give it a <strong>Sphere Collider</strong> component and a <strong>Rigidbody</strong> component, and set the <strong>Constraints</strong> parameters.</li><li class="listitem">Now, we need to create a new script named <code class="literal">Bird</code>. This script will be a base for all of our birds, tracking their health and triggering their special powers when appropriate.</li><li class="listitem">It starts with two variables. The first will keep track of the bird's current health. The second is<a id="id483" class="indexterm"/> a flag so that the bird will only use its special power once. It is marked as <code class="literal">protected</code> so the class that extends this script can use it while keeping it from interference from outside the class.<div><pre class="programlisting">public float health = 50;
protected bool didSpecial = false;</pre></div></li><li class="listitem">The <code class="literal">Update</code> function does three checks before activating the bird's special power. First, it checks whether it has already been done, then whether the screen has been touched, and finally whether the bird has a <strong>Rigidbody</strong> component and that it is not being controlled by another script.<div><pre class="programlisting">public void Update() {
  if(didSpecial)
    return;
  if(!Input.GetMouseButtonDown(0))
    return;
  if(rigidbody == null || rigidbody.isKinematic)
    return;
  
  DoSpecial();
}</pre></div></li><li class="listitem">In the case of the red bird, the <code class="literal">DoSpecial</code> function only sets its flag to <code class="literal">true</code>. It is marked as <code class="literal">virtual</code> so that we can override the function for the other birds and make them do some fancier things.<div><pre class="programlisting">protected virtual void DoSpecial() {
  didSpecial = true;
}</pre></div></li><li class="listitem">The <code class="literal">OnCollisionEnter</code> function works just like the one for the planks, subtracting health based on the strength of the collision and destroying the bird if it runs out of health.<div><pre class="programlisting">public void OnCollisionEnter(Collision collision) {
  health -= collision.relativeVelocity.magnitude;
  if(health &lt; 0)
    Destroy(gameObject);
}</pre></div></li><li class="listitem">Return to Unity and add the script to the <code class="literal">Bird_Red</code> object.</li><li class="listitem">Complete the bird's creation by turning it into a prefab and deleting it from the scene. The slingshot we <a id="id484" class="indexterm"/>will be creating soon will handle the creation of the birds when the game starts.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec104"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the red bird. It is set up just like our other physics objects. We also created a script to handle the bird's health that is expanded later, when we create the other birds for our game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec104"/>Controls</h1></div></div></div><p>Next, we are going to give the player the ability to interact with the game. First, we will create a slingshot to throw the birds. Following that will be the creation of the camera controls. We will even create a nice background effect to round out the look of our game.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Attacking</h2></div></div></div><p>To attack the pig fortress, we have our basic bird ammo. We need to create a slingshot to hurl that ammo at the pigs. It will also handle the spawning of the birds at the beginning of the level and automatically reload as birds are used. When the slingshot runs out of birds it will notify the <code class="literal">LevelTracker</code> script and the game will end. Finally, we will create a script that will keep the physics simulation from going on for too long. We don't want the player forced to sit and watch a pig slowly roll across the screen. So, the script will, after a little while, start damping the movement of the <strong>Rigidbody</strong> components to make them stop rather than keep rolling.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec105"/>Time for action – creating the slingshot</h1></div></div></div><p>Most of the slingshot's appearance<a id="id485" class="indexterm"/> will actually be an optical illusion:</p><div><ol class="orderedlist arabic"><li class="listitem">To start off the creation of the slingshot, add the <code class="literal">slingshot</code> model to the scene and position it at the origin. Apply a light brown material to the <code class="literal">Fork</code> model and a dark <a id="id486" class="indexterm"/>brown one to the <code class="literal">Pouch</code> model.</li><li class="listitem">Next, we need four empty <strong>GameObject</strong>. Make them all the children of the <code class="literal">Slingshot</code> object.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Name the first <code class="literal">FocalPoint</code> and center it between the fork prongs of the slingshot. This will be the point through which we fire all of the birds.</li><li class="listitem" style="list-style-type: disc">The second is <code class="literal">Pouch</code>. Make the <code class="literal">pouch</code> model a child of this object, setting its position to <code class="literal">0.5</code> on the <strong>X</strong> axis and <code class="literal">0</code> on the <strong>Y</strong> and <strong>Z</strong> axes. This will make the pouch appear in front of the current bird without having to make a complete pouch model.</li><li class="listitem" style="list-style-type: disc">Third is <code class="literal">BirdPoint</code>; this will position the bird that is being fired. Make it a child of the <code class="literal">Pouch</code> point and set its position to <code class="literal">0</code> on the <strong>X</strong> and <strong>Y</strong> axes and <code class="literal">0.3</code> on the <strong>Z</strong> axis.</li><li class="listitem" style="list-style-type: disc">Last is <code class="literal">WaitPoint</code>; the birds waiting to be fired will be positioned behind this point. Set its position to <code class="literal">0</code> for the <strong>X</strong> axis, <code class="literal">0.5</code> for the <strong>Y</strong> axis, and <code class="literal">-4</code> for the <strong>Z</strong> axis.</li></ul></div></li><li class="listitem">Next, rotate the <code class="literal">Fork</code> model so that we can see both prongs of the fork. The values of <code class="literal">270</code> for the <strong>X</strong> axis, <code class="literal">25</code> for the <strong>Y</strong> axis, and <code class="literal">0</code> for the <strong>Z</strong> axis will work well.</li><li class="listitem">The <code class="literal">Slingshot</code> script will provide most of the interaction for the player. Create it now.</li><li class="listitem">We start it with a group of variables. The first will keep a reference to the damper that was mentioned earlier. The second group keeps track of the birds that will be used in the level. Next is a group of variables that will track the current bird that is ready to be fired. Fourth, we have some variables to hold references to the points we created a moment ago. The <code class="literal">maxRange</code> variable is the distance from the focal point to which the player can drag the pouch. The last two variables define how powerfully the bird will be launched.<div><pre class="programlisting">public RigidbodyDamper rigidbodyDamper;

public GameObject[] levelBirds = new GameObject[0];
private GameObject[] currentBirds;
private int nextIndex = 0;
public Transform waitPoint;
public Transform toFireBird;
public bool didFire = false;
public bool isAiming = false;

public Transform pouch;
public Transform focalPoint;
public Transform pouchBirdPoint;

public float maxRange = 3;

public float maxFireStrength = 25;
public float minFireStrength = 5;</pre></div></li><li class="listitem">As with our other scripts, we use the <code class="literal">Awake</code> function for initialization. The <code class="literal">levelBirds</code> variable will hold references to all of the <code class="literal">bird</code> prefabs that will be used in the level.<a id="id487" class="indexterm"/> We start by creating an instance of each one and storing it in the <code class="literal">currentBirds</code> variable. The <code class="literal">isKinematic</code> variable is set to <code class="literal">true</code> on each bird's <strong>Rigidbody</strong> so that it does not move when it is not in use. Next, it readies the first bird to be fired and, finally, it positions the remaining birds behind the <code class="literal">waitPoint</code>.<div><pre class="programlisting">public void Awake() {
  currentBirds = new GameObject[levelBirds.Length];
  for(int i=0;i&lt;levelBirds.Length;i++) {
    GameObject nextBird = Instantiate(levelBirds[i]) as GameObject;
    nextBird.rigidbody.isKinematic = true;
    currentBirds[i] = nextBird;
  }

  ReadyNextBird();
  SetWaitPositions();
}</pre></div></li><li class="listitem">The <code class="literal">ReadyNextBird</code> function<a id="id488" class="indexterm"/> first checks to see if we have run out of birds. If so, it calls the <code class="literal">LevelTracker</code> script to trigger the Game Over event. The <code class="literal">nextIndex</code> variable tracks the current location of the birds in the list to fire at the player. Next, the function checks to make sure the next slot actually has a bird, incrementing the index and trying for a new bird if it does not have one. If there is a bird available, it is stored in the <code class="literal">toFireBird</code> variable and made a child of the <code class="literal">BirdPoint</code> object we created; its position and rotation are zeroed out. Finally, the firing and aiming flags are reset.<div><pre class="programlisting">public void ReadyNextBird() {
  if(currentBirds.Length &lt;= nextIndex) {
    LevelTracker.OutOfBirds();
    return;
  }

  if(currentBirds[nextIndex] == null) {
    nextIndex++;
    ReadyNextBird();
    return;
  }

  toFireBird = currentBirds[nextIndex].transform;
  nextIndex++;

  toFireBird.parent = pouchBirdPoint;
  toFireBird.localPosition = Vector3.zero;
  toFireBird.localRotation = Quaternion.identity;

  didFire = false;
  isAiming = false;
}</pre></div></li><li class="listitem">The <code class="literal">SetWaitingPositions</code> function<a id="id489" class="indexterm"/> uses the position of the <code class="literal">waitPoint</code> to position all of the <a id="id490" class="indexterm"/>remaining birds behind the slingshot.<div><pre class="programlisting">public void SetWaitingPositions() {
  for(int i=nextIndex;i&lt;currentBirds.Length;i++) {
    if(currentBirds[i] == null) continue;
    Vector3 offset = Vector3.forward * (i – nextIndex) * 2;
    currentBirds[i].transform.position = waitPoint.position – offset;
  }
}</pre></div></li><li class="listitem">The <code class="literal">Update</code> function<a id="id491" class="indexterm"/> starts by checking to see if the player has fired a bird and watches the <code class="literal">rigidbodyDamper.allSleeping</code> variable to see if all of the physics objects have stopped moving. Once they do, the next bird is readied to fire. If we have not fired, the aiming flag is checked and the <code class="literal">DoAiming</code> function is called to handle the aiming. If the player is neither aiming nor has just fired a bird, we check for touch input and, if the player touches close enough to the focal point, we flag that the player has started aiming.<div><pre class="programlisting">public void Update() {
  if(didFire) {
    if(rigidbodyDamper.allSleeping) {
      ReadyNextBird();
      SetWaitingPositions();
    }
    return;
  }
  else if(isAiming) {
    DoAiming();}
  else {
    if(Input.touchCount &lt;= 0) return;
    Vector3 touchPoint = GetTouchPoint();
    isAiming = Vector3.Distance(touchPoint, focalPoint.position) &lt; maxRange / 2;
  }
}</pre></div></li><li class="listitem">The <code class="literal">DoAiming</code> function<a id="id492" class="indexterm"/> checks to see if the player has stopped touching the screen and fires the current bird when they have. If they have not, we position the pouch at the current touch point. Finally, the pouch's position is limited to keep it within the maximum range.<div><pre class="programlisting">private void DoAiming() {
  if(Input.touchCount &lt;= 0) {
    FireBird();
    return;
  }

  Vector3 touchPoint = GetTouchPoint();

  pouch.position = touchPoint;
  pouch.LookAt(focalPoint);

  float distance = Vector3.Distance(focalPoint.position, pouch.position);
  if(distance &gt; maxRange) {
    pouch.position = focalPoint.position – (pouch.forward * maxRange);
  }
}</pre></div></li><li class="listitem">The <code class="literal">GetTouchPoint</code> function<a id="id493" class="indexterm"/> uses <code class="literal">ScreenPointToRay</code> to find out where the player is touching in 3D space. This is just as when we were shooting asteroids but, because this game is 2D, we can just look at the ray's origin and return it with a <a id="id494" class="indexterm"/>zero for its x axis value.<div><pre class="programlisting">private Vector3 GetTouchPoint() {
  Ray touchRay = Camera.main.ScreenPointToRay(Input.GetTouch(0).position);
  Vector3 touchPoint = touchRay.origin;
  touchPoint.x = 0;
  return touchPoint;
}</pre></div></li><li class="listitem">Finally, for this script, we have the <code class="literal">FireBird</code> function<a id="id495" class="indexterm"/>. This function starts by setting our <code class="literal">didFire</code> flag to <code class="literal">true</code>. Next, it finds out the direction to fire by finding the direction from the pouch's position to the <code class="literal">focalPoint</code>. It also uses the distance between them to determine the power to fire the bird with, clamping it between our min and max strengths. Then, it releases the bird by clearing its parent and setting its <code class="literal">isKinematic</code> flag to <code class="literal">false</code>. To launch it, we use the <code class="literal">rigidbody.AddForce</code> function<a id="id496" class="indexterm"/> and pass the direction multiplied by the power to it. <code class="literal">ForceMode.Impulse</code> is also passed to make the force applied once and immediately. Next, the pouch is positioned at the <code class="literal">focalPoint</code>, as if it were actually<a id="id497" class="indexterm"/> under tension. And finally, we call <code class="literal">rigidbodyDamper.ReadyDamp</code> to start the damping of the <code class="literal">Rigidbody</code> movement.<div><pre class="programlisting">private void FireBird() {
  didFire = true;

  Vector3 direction = (focalPoint.position – pouch.position).normalized;
  float distance = Vector3.Distance(focalPoint.position, pouch.position);
float power = distance &lt;= 0 ? 0 : distance / maxRange;
  power *= maxFireStrength;
  power = Mathf.Clamp(power, minFireStrength, maxFireStrength);

  toFireBird.parent = null;
  toFireBird.rigidbody.isKinematic = false;
  toFireBird.rigidbody.AddForce(direction * power, ForceMode.Impulse);

  pouch.position = focalPoint.position;

  rigidbodyDamper.ReadyDamp();
}</pre></div></li><li class="listitem">Before we can make use of the <code class="literal">Slingshot</code> script, we need to create the <code class="literal">RigidbodyDamper</code> script.</li><li class="listitem">This script starts with six variables. The first two define how long to wait before the damping movement and how much to damp it by. The next two track whether it can apply the damping and when it will start. Next, is a variable that will be filled with a list of all the rigidbodies that are currently in the scene. Finally, it has the <code class="literal">allSleeping</code> flag that will be set to <code class="literal">true</code> when the movement has stopped.<div><pre class="programlisting">public float dampWaitLength = 10f;
public float dampAmount = 0.9f;
private float dampTime = -1;
private bool canDamp = false;
private Rigidbody[] rigidbodies = new Rigidbody[0];

public bool allSleeping = false;</pre></div></li><li class="listitem">The <code class="literal">ReadyDamp</code> function<a id="id498" class="indexterm"/> starts by using <code class="literal">FindObjectsOfType</code> to fill the list with all of the rigidbodies. It sets when to start damping as the sum of the current time and the wait length. It marks that the script can do its damping and resets the <code class="literal">allSleeping</code> flag. <a id="id499" class="indexterm"/>Finally, it uses <code class="literal">StartCoroutine</code> to call the <code class="literal">CheckSleepingRigidbodies</code> function. This is a special way of calling functions to make them run in the background without blocking the rest of the game from running.<div><pre class="programlisting">public void ReadyDamp() {
  rigidbodies = FindObjectsOfType(typeof(Rigidbody)) as Rigidbody[];
  dampTime = Time.time + dampWaitLength;
  canDamp = true;
  allSleeping = false;

  StartCoroutine(CheckSleepingRigidbodies());
}</pre></div></li><li class="listitem">In the <code class="literal">FixedUpdate</code> function<a id="id500" class="indexterm"/>, we first check to see if we can damp the movement and whether it is time to do it. If it is, we loop through all of the rigidbodies, applying our damp to each one's rotational and linear velocity. Those that are kinematic, controlled by scripts, and already sleeping, meaning they stopped moving, are skipped.<div><pre class="programlisting">public void FixedUpdate() {
  if(!canDamp || dampTime &gt; Time.time) return;

  foreach(Rigidbody next in rigidbodies) {
    if(next != null &amp;&amp; !next.isKinematic &amp;&amp; !next.IsSleeping()) {
      next.angularVelocity *= dampAmount;
      next.velocity *= dampAmount;
    }
  }
}</pre></div></li><li class="listitem">The <code class="literal">CheckSleepingRigidbodies</code> function<a id="id501" class="indexterm"/> is special and will run in the background. This is made possible by the <code class="literal">IEnumerator</code> flag at the beginning of the function and the <code class="literal">yield return null</code> line in the middle. Together, these allow the function to pause regularly and keep from freezing the rest of the game while it waits for the function to complete. The function starts by creating a check flag and using it to check if all of the rigidbodies have stopped moving. If one is found still moving, the flag is set to <code class="literal">false</code> and the function pauses until the next frame, when it will try again. When it reaches the end, because all of the rigidbodies are sleeping, it sets the <code class="literal">allSleeping</code> flag to <code class="literal">true</code>, so that the slingshot can ready the next bird. It also stops itself from damping while the player is getting ready to fire the next bird.<div><pre class="programlisting">private IEnumerator CheckSleepingRigidbodies() {
  bool sleepCheck = false;

  while(!sleepCheck) {
    sleepCheck = true;

    foreach(Rigidbody next in rigidbodies) {
      if(next != null &amp;&amp; !next.isKinematic &amp;&amp; !next.IsSleeping()) {
        sleepCheck = false;
        yield return null;
        break;
      }
    }
  }

  allSleeping = true;
  canDamp = false;
}</pre></div></li><li class="listitem">Finally, we have the <a id="id502" class="indexterm"/><code class="literal">AddBodiesToCheck</code> function. This function will be used by anything that spawns new physics objects after the player has fired the bird. It starts by creating a temporary list and expanding the current one. Next, it adds all of the values from the temporary list to the expanded one. Finally, the list of rigidbodies <a id="id503" class="indexterm"/>is added after those of the temporary list.<div><pre class="programlisting">public void AddBodiesToCheck(Rigidbody[] toAdd) {
  Rigidbody[] temp = rigidbodies;
  rigidbodies = new Rigidbody[temp.Length + toAdd.Length];

  for(int i=0;i&lt;temp.Length;i++) {
    rigidbodies[i] = temp[i];
  }
  for(int i=0;i&lt;toAdd.Length;i++) {
    rigidbodies[i + temp.Length] = toAdd[i];
  }
}</pre></div></li><li class="listitem">Return to Unity and add the two scripts to the <code class="literal">Slingshot</code> object. On the <code class="literal">Slingshot</code> script component, connect the references to the <strong>Rigidbody Damper</strong> component and each of the points. Also, add to the <strong>Level Birds</strong> list as many references to the red bird as you want for the level.</li><li class="listitem">To keep objects from rolling back and through the slingshot, create a <strong>Box Collider</strong> component and position it at the stock of the <code class="literal">Fork</code> model.</li><li class="listitem">To finish off the look of the slingshot, we need to create the elastic bands that tie the pouch to the fork. We will do this by first creating the <code class="literal">SlingshotBand</code> script.</li><li class="listitem">The script starts with two variables. One for the point that the band will end at and one to reference the <code class="literal">LineRenderer</code> that will draw it.<div><pre class="programlisting">public Transform endPoint;
public LineRenderer lineRenderer;</pre></div></li><li class="listitem">The <code class="literal">Awake</code> function makes<a id="id504" class="indexterm"/> sure the <code class="literal">lineRenderer</code> variable has only two points and sets their initial positions.<div><pre class="programlisting">public void Awake() {
  if(lineRenderer == null) return;
  if(endPoint == null) return;

  lineRenderer.SetVertexCount(2);
  lineRenderer.SetPosition(0, transform.position);
  lineRenderer.SetPosition(1, endPoint.position);
}</pre></div></li><li class="listitem">In the <code class="literal">LateUpdate</code> function<a id="id505" class="indexterm"/>, we set the <code class="literal">lineRenderer</code> variable's end position to the <code class="literal">endPoint</code> value. This point will move around with the pouch, so we need to constantly update the renderer.<div><pre class="programlisting">public void LateUpdate() {
  if(endPoint == null) return;
  if(lineRenderer == null) return;

  lineRenderer.SetPosition(1, endPoint.position);
}</pre></div></li><li class="listitem">Return to Unity and create an empty <strong>GameObject</strong>. Name it <code class="literal">Band_Near</code> and make it a child of the <code class="literal">Slingshot</code> object.</li><li class="listitem">As children of this new point, create a cylinder and a second empty <strong>GameObject</strong>, named <code class="literal">Band</code>.</li><li class="listitem">Give the cylinder a brown material and position it near the prong of the slingshot fork.</li><li class="listitem">To the <code class="literal">Band</code> object, add a <strong>Line Renderer</strong> component found under <strong>Effects</strong> in the <strong>Component</strong> menu. After positioning it in the center of the cylinder, add the <code class="literal">SlingshotBand</code> script to the object.</li><li class="listitem">To the <strong>Line Renderer</strong> under <strong>Materials</strong>, you can put your brown material in the slot to color the band. under <strong>Parameters</strong>. Set the <strong>Start Width</strong> to <code class="literal">0.5</code> and the <strong>End width</strong> to <code class="literal">0.2</code> to set the size of the line.</li><li class="listitem">Next, create one more empty <strong>GameObject</strong> and name it <code class="literal">BandEnd_Near</code>. Make it a child of the <code class="literal">Pouch</code> object and position it inside the pouch.</li><li class="listitem">Now, connect the script's references to its line renderer and end point.</li><li class="listitem">To make the second band, <a id="id506" class="indexterm"/>duplicate the four objects we just created and position them far from the prong of the fork. The end point for this band can just be moved back along the x axis to keep it out of the way of the birds.</li><li class="listitem">Finally, turn the whole thing into a prefab so it can be easily reused in other levels.<div><img src="img/2014OT_07_04.jpg" alt="Time for action – creating the slingshot"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec106"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the slingshot that will be used to fire birds. We used techniques we learned in the previous chapter to handle touch input and track the player's finger while they aim and shoot. If you save your scene and position the camera to look at the slingshot, you will notice that it is complete if not entirely playable. Birds can be fired at the pig fortress, although we can only see the destruction from within Unity's <strong>Scene</strong> view.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Watching</h2></div></div></div><p>The game is technically playable at this point, but it is kind of hard to see what is going on. Next, we will create a system to control the camera. It will allow the player to drag the camera left and right, follow the bird when it is launched and return to the slingshot when everything stops moving. There will also be a set of limits to keep the camera from going too far and viewing things we do not want the player to see.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec106"/>Time for action – controlling the camera</h1></div></div></div><p>We will only need one, fairly short script to control and manage our camera:</p><div><ol class="orderedlist arabic"><li class="listitem">To start and to keep everything organized, create a new empty <strong>GameObject</strong> and name it <code class="literal">CameraRig</code>. Also, to keep it simple, set its position to zero on each axis.</li><li class="listitem">Next, create three more <a id="id507" class="indexterm"/>empty <strong>GameObject</strong> and name them <code class="literal">LeftPoint</code>, <code class="literal">RightPoint</code>, and <code class="literal">TopPoint</code>. Set their <strong>X</strong> axis positions to <code class="literal">5</code>. Position the <code class="literal">LeftPoint</code> to be in front of the slingshot and at <code class="literal">3</code> on the <strong>Y</strong> axis. The <code class="literal">RightPoint</code> needs to be positioned in front of the <code class="literal">pig</code> structure you created. The <code class="literal">TopPoint</code> can be over the slingshot, but needs to set to <code class="literal">8</code> on the <strong>Y</strong> axis. These three points will define the limits of where our camera can move when being dragged and following birds.</li><li class="listitem">Make all three points, and the <code class="literal">Main Camera</code> object, children of the <code class="literal">CameraRig</code> object.</li><li class="listitem">Now, we create the <code class="literal">CameraControl</code> script. This script will control all of the movement and interaction with the camera.</li><li class="listitem">Our variables for this script start with a reference to the slingshot; we need this so we can follow the current bird when it is fired. Next are the references to the points we just created. The next group of variables control how long the camera will sit without input before returning to look at the slingshot and how fast it will return. The <code class="literal">dragScale</code> variable controls how fast the camera actually moves when the player drags their finger across the screen, allowing us to keep the scene moving with the finger. The last group is to control whether the camera can follow the current bird and how fast it can do so.<div><pre class="programlisting">public Slingshot slingshot;

public Transform rightPoint;
public Transform leftPoint;
public Transform topPoint;

public float waitTime = 3f;
private float headBackTime = -1;
private Vector3 waitPosition;
public float headBackDuration = 3f;

public float dragScale = 0.075f;

private bool followBird = false;
private Vector3 followVelocity = Vector3.zero;
public float followSmoothTime = 0.1f;</pre></div></li><li class="listitem">In the <code class="literal">Awake</code> function<a id="id508" class="indexterm"/>, we first make certain the camera is not following a bird and make it wait before heading to look at the slingshot. This allows us to initially point the camera to the pig fortress when the level starts and move to the slingshot after giving the<a id="id509" class="indexterm"/> player a chance to see what they are up against.<div><pre class="programlisting">public void Awake() {
  followBird = false;
  StartWait();
}</pre></div></li><li class="listitem">The <code class="literal">StartWait</code> function<a id="id510" class="indexterm"/> sets the time when it will start to head back to the slingshot and records the position that it is heading back from. This allows us to create a smooth transition.<div><pre class="programlisting">public void StartWait() {
  headBackTime = Time.time + waitTime;
  waitPosition = transform.position;
}</pre></div></li><li class="listitem">Next, we have the <a id="id511" class="indexterm"/><code class="literal">Update</code> function. This one starts by checking whether the slingshot has fired. If it hasn't, it checks to see whether the player has started aiming, signaling that the bird should be followed and zeroing out the velocity if they have. If they have not, the <code class="literal">followBird</code> flag is cleared. Next, the function checks whether it should follow and does so if it should, also calling the <code class="literal">StartWait</code> function in case this is the frame in which the bird is destroyed. If it should not follow the bird, it checks for touch input and drags the camera if it finds any. The wait is again started in case the player removes their finger in this frame. Finally, it checks to see if the slingshot is done firing the current bird and if it is time to head back. Should both be true, the camera moves back to pointing at the slingshot.<div><pre class="programlisting">public void Update() {
  if(!slingshot.didFire) {
    if(slingshot.isAiming) {
      followBird = true;
      followVelocity = Vector3.zero;
    }
    else {
      followBird = false;
    }
  }
  
  if(followBird) {
    FollowBird();
    StartWait();
  }
  else if(Input.touchCount &gt; 0) {
    DragCamera();
    StartWait();
  }

  if(!slingshot.didFire &amp;&amp; headBackTime &lt; Time.time) {
    BackToLeft();
  }
}</pre></div></li><li class="listitem">The <code class="literal">FollowBird</code> function <a id="id512" class="indexterm"/>starts by making sure there is a bird to follow by checking the <code class="literal">toFireBird</code> variable on the <code class="literal">Slingshot</code> script and stops following if a bird is not found. Should there be a bird, the function then determines a new point to move to that will look directly at the bird. It then uses the <code class="literal">Vector3.SmoothDamp</code> function to smoothly follow the bird. This function works similar to a spring—the farther away it is from its target position, the faster it moves the object. The <code class="literal">followVelocity</code> variable is used to keep it moving smoothly. Finally, it calls another function to limit the camera's position within those bounding points we set up earlier.<div><pre class="programlisting">private void FollowBird() {
  if(slingshot.toFireBird == null) {
    followBird = false;
    return;
  }

  Vector3 targetPoint = slingshot.toFireBird.position;
  targetPoint.x = transform.position.x;

  transform.position = Vector3.SmoothDamp(transform.position, targetPoint, ref followVelocity, followSmoothTime);
  ClampPosition();
}</pre></div></li><li class="listitem">In the <code class="literal">DragCamera</code> function<a id="id513" class="indexterm"/>, we use the <code class="literal">deltaPosition</code> value of the current touch to determine how far it has moved since the last frame. By scaling this value and subtracting the vector from the camera's position, the function moves the camera as the player drags across the screen. This function also calls upon the function to clamp the camera's position.<div><pre class="programlisting">private void DragCamera() {
  transform.position -= new Vector3(0, 0, Input.GetTouch(0).deltaPosition.x * dragScale);
  ClampPosition();
}</pre></div></li><li class="listitem">The <code class="literal">ClampPosition</code> function<a id="id514" class="indexterm"/> starts by taking the camera's current position. It then clamps the z position to be between those of the <code class="literal">leftPoint</code> and <code class="literal">rightPoint</code> variables' <code class="literal">z</code> positions. Next, the <code class="literal">y</code> position is clamped between the <code class="literal">leftPoint</code> and <code class="literal">topPoint</code> variables' positions. Finally, the new position is reapplied to the camera's transform.<div><pre class="programlisting">private void ClampPosition() {
  Vector3 clamped = transform.position;
  clamped.z = Mathf.Clamp(clamped.z, leftPoint.position.z, rightPoint.position.z);
  clamped.y = Mathf.Clamp(clamped.y, leftPoint.position.y, topPoint.position.y);
  transform.position = clamped;
}</pre></div></li><li class="listitem">Finally, we have the <code class="literal">BackToLeft</code> function<a id="id515" class="indexterm"/>. It starts by using the time and our duration variable to determine how much progress in returning to the slingshot the camera will have made. It records the camera's current position and uses <code class="literal">Mathf.SmoothStep</code> on both the z and y axes to find a new position that is the appropriate distance between the <code class="literal">waitPosition</code> variable and the <code class="literal">leftPoint</code> variable. Finally, the new position is applied.<div><pre class="programlisting">private void BackToLeft() {
  float progress = (Time.time – headBackTime) / headBackDuration;
  Vector3 newPosition = transform.position;
  newPosition.z = Mathf.SmoothStep(waitPosition.z, leftPoint.position.z, progress);
  newPosition.y = Mathf.SmoothStep(waitPosition.y, leftPoint.position.y, progress);
  transform.position = newPosition;
}</pre></div></li><li class="listitem">Next, return to Unity and add the new script to the <code class="literal">Main Camera</code> object. Connect the references to the slingshot and each of the points to finish it off.</li><li class="listitem">Position the camera to point at your pig fortress and turn the whole rig into a prefab.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec108"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the camera rig that will let the player watch all of the action as they play the game. The camera will now follow the birds as they are fired from the slingshot and can now be dragged by the player. By keying off the positions of a few objects, this movement is limited to keep the player from seeing things we don't want them to. If the camera is left idle long enough, it will also return to look at the slingshot.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec109"/>Have a go hero – more levels</h2></div></div></div><p>Now that we have all of the pieces needed to make a complete level, we need some more levels. We need at least two more levels. You can use the blocks and pigs to create any level you might want. It is a good idea to keep the pig structures centered at about <code class="literal">30</code> on the <strong>Z</strong> axis. Also, think about the difficulty of the level while making it, so that you can end up with an easy, medium, and hard level.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec107"/>A better background</h1></div></div></div><p>A great feature of many 2D games is a parallax scrolling background. This simply means that the background is created in layers that scroll by at different speeds. Think of it as if looking out the window of your car. The objects that are far away appear to hardly move, while the ones that are near move by quickly. In a 2D game, it gives the illusion of depth and adds a nice touch to the look of the game. For this background, we will be layering several materials on a single plane.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec108"/>Time for action – creating the parallax background</h1></div></div></div><p>There is an alternative method of creating and utilizing a second camera, but ours will make use of a single script that<a id="id516" class="indexterm"/> additionally allows us to control the speed of each layer:</p><div><ol class="orderedlist arabic"><li class="listitem">We will start this section with the creation of the <code class="literal">ParallaxScroll</code> script.</li><li class="listitem">This script starts with three variables. The first two keep track of each material and how fast they should scroll. The third keeps track of the camera's last position, so we can track how far it moves in each frame.<div><pre class="programlisting">public Material[] materials = new Material[0];
public float[] speeds = new float[0];

private Vector3 lastPosition = Vector3.zero;</pre></div></li><li class="listitem">In the <code class="literal">Start</code> function, we record the camera's beginning position. We use <code class="literal">Start</code> instead of <code class="literal">Awake</code> here, in case the camera needs to do any special movement at the beginning of the game.<div><pre class="programlisting">public void Start() {
  lastPosition = Camera.main.transform.position;
}</pre></div></li><li class="listitem">Next, we use the <code class="literal">LateUpdate</code> function to make changes after the camera has moved about. It starts by finding the camera's new position and comparing the z axis values to determine how far it moved. Next, it loops through the list of materials. The loop first gathers the current offset of its texture using <code class="literal">mainTextureOffset</code>. Next, the camera's movement multiplied by the material's speed is subtracted from the offset's x axis to find a new horizontal position. Then, the new offset is applied to the material. Finally, the function records the camera's last position for the next frame.<div><pre class="programlisting">public void LateUpdate() {
  Vector3 newPosition = Camera.main.transform.position;
  float move = newPosition.z – lastPosition.z;

  for(int i=0;i&lt;materials.Length;i++) {
    Vector2 offset = materials[i].mainTextureOffset;
    offset.x -= move * speeds[i];
    materials[i].mainTextureOffset = offset;
  }

  lastPosition = newPosition;
}</pre></div></li><li class="listitem">Return to Unity and create six new materials. One for each of the background textures: <code class="literal">sky</code>, <code class="literal">hills_tall</code>, <code class="literal">hills_short</code>, <code class="literal">grass_light</code>, <code class="literal">grass_dark</code>, and <code class="literal">fronds</code>. All of the materials, except for the sky, need to use the <strong>Diffuse</strong> shader under <strong>Transparent</strong> in the <strong>Shader</strong> drop-down list. If they do not, we will not be able to see all of the textures when they are layered.</li><li class="listitem">We also need to adjust the <strong>Tiling</strong> of each of these new materials. For all of them, leave the <strong>Y</strong> axis<a id="id517" class="indexterm"/> as <code class="literal">1</code>. For the <strong>X</strong> axis, set <code class="literal">5</code> for the <code class="literal">sky</code>, <code class="literal">6</code> for <code class="literal">hills_tall</code>, <code class="literal">7</code> for <code class="literal">hills_short</code>, <code class="literal">8</code> for <code class="literal">grass_dark</code>, <code class="literal">9</code> for <code class="literal">fronds</code>, and <code class="literal">10</code> for <code class="literal">grass_light</code>. This will offset all of the features of the textures so a long pan does not see features regularly lining up.</li><li class="listitem">Next, create a new plane. Name it <code class="literal">Background</code> and remove its <strong>Mesh Collider</strong> component.</li><li class="listitem">Position it at <code class="literal">-5</code> on the <strong>X</strong> axis, <code class="literal">7</code> on the <strong>Y</strong> axis, and <code class="literal">30</code> on the <strong>Z</strong> axis. Set its rotation to <code class="literal">90</code> for both the <strong>X</strong> and <strong>Y</strong> axes and <code class="literal">0</code> for <strong>Z</strong>. Also, set the scale to <code class="literal">10</code> for the <strong>X</strong> axis, <code class="literal">1</code> for the <strong>Y</strong> axis, and <code class="literal">1.5</code> for the <strong>Z</strong> axis. Altogether, these position the plane as facing the camera and filling the background.</li><li class="listitem">In the plane's <strong>Mesh Renderer</strong> component, expand the <strong>Materials</strong> list and set the <strong>Size</strong> to <code class="literal">6</code>. Add each of our new materials to the list slots in the order of <code class="literal">sky</code>, <code class="literal">hills_tall</code>, <code class="literal">hills_short</code>, <code class="literal">grass_dark</code>, <code class="literal">fronds</code>, <code class="literal">grass_light</code>. Do the same for the <strong>Materials</strong> list in the <strong>Parallax Scroll</strong> script component.</li><li class="listitem">Finally, in the <strong>Parallax Scroll</strong> script component, set the <strong>Size</strong> of the <strong>Speeds</strong> list to <code class="literal">6</code> and input the following values in the order of <code class="literal">0.03</code>, <code class="literal">0.024</code>, <code class="literal">0.018</code>, <code class="literal">0.012</code>, <code class="literal">0.006</code>, <code class="literal">0</code>. These values will move the materials gently and evenly.</li><li class="listitem">Turning the background into a prefab, at this point, will make it easy to reuse later.<div><img src="img/2014OT_07_05.jpg" alt="Time for action – creating the parallax background"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec110"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a parallax <a id="id518" class="indexterm"/>scroll effect. This effect will pan a series of background textures, giving the illusion of depth in our 2D game. To easily see it in action, hit play and grab the camera in the <strong>Scene</strong> view, moving it along the z axis to see the background change.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec111"/>Have a go hero – dark of the night</h2></div></div></div><p>We have two other levels to add backgrounds to. Your challenge here is to create your own background. Use the techniques you learned in this section to create a night-style background. It could include a stationary moon while everything else scrolls in the shot. For an added trick, create a cloud layer that slowly pans across the screen as well as with the camera and the rest of the background.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec109"/>The flock variety</h1></div></div></div><p>There is one last set of assets we need to create for our levels, the other birds. We will create three more birds that each have a unique special ability: a yellow bird that accelerates, a blue bird that splits into multiple birds, and a black bird that explodes. With these our flock will be complete.</p><p>To make the creation of these birds easier, we will be making use of a concept called <strong>inheritance</strong><a id="id519" class="indexterm"/>. Inheritance allows a script to expand upon the functions it is inheriting without the need to rewrite them. If used correctly, this can be very powerful and, in our case, will aid in the quick creation of multiple characters that are largely similar.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec112"/>The yellow bird</h2></div></div></div><p>First, we will create the yellow bird. Largely, this bird functions exactly as the red bird. However, when the player touches the screen, the bird's speed increases. By extending the <code class="literal">Bird</code> script that we created earlier,<a id="id520" class="indexterm"/> this bird's creation becomes quite simple.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec110"/>Time for action – creating the yellow bird</h1></div></div></div><p>Because of the power of inheritance,<a id="id521" class="indexterm"/> the script we are creating here consists of only a handful of lines of code:</p><div><ol class="orderedlist arabic"><li class="listitem">Start by creating the yellow bird in the same way as the red bird, using the <code class="literal">YellowBird</code> model instead.</li><li class="listitem">Instead of using the <code class="literal">Bird</code> script, we will create the <code class="literal">YellowBird</code> script.</li><li class="listitem">This script needs to extend the <code class="literal">Bird</code> script, so replace <code class="literal">MonoBehaviour</code> with <code class="literal">Bird</code> on line four. It should look similar to the following code snippet:<div><pre class="programlisting">public class YellowBird : Bird {</pre></div></li><li class="listitem">This script adds a single variable that will be used to multiply the bird's current velocity.<div><pre class="programlisting">public float multiplier = 2f;</pre></div></li><li class="listitem">Next, we override the <code class="literal">DoSpecial</code> function and multiply the bird's <code class="literal">rigidbody.velocity</code> when it is called:<div><pre class="programlisting">protected override void DoSpecial() {
  didSpecial = true;
  rigidbody.velocity *= multiplier;
}</pre></div></li><li class="listitem">Return to Unity, add the script to your new bird, and turn it into a prefab. Add some to the list on your slingshot to use the bird in your level.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec113"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the yellow bird. This bird is simple. It directly modifies its velocity to suddenly gain a boost of speed when the player touches the screen. As you will soon see, we use this same style <a id="id522" class="indexterm"/>of script creation to create all of our birds.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec114"/>The blue bird</h2></div></div></div><p>Next, we create the blue bird. This bird splits into three birds when the player touches the screen. It will also extend the <code class="literal">Bird</code> script.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec111"/>Time for action – creating the blue bird</h1></div></div></div><p>The blue bird will again make use of inheritance,<a id="id523" class="indexterm"/> reducing the amount of code that needs to be written to create the bird:</p><div><ol class="orderedlist arabic"><li class="listitem">Again, start building <a id="id524" class="indexterm"/>your blue bird the same way as the previous two, substituting the appropriate model. You should also adjust the <strong>Radius</strong> of the <strong>Sphere Collider</strong> component to align appropriately with the smaller size of this bird.</li><li class="listitem">Next, we create the <code class="literal">BlueBird</code> script.</li><li class="listitem">Again, adjust line four so the script extends <code class="literal">Bird</code> instead of <code class="literal">MonoBehaviour</code>.<div><pre class="programlisting">public class BlueBird : Bird {</pre></div></li><li class="listitem">This script has three variables. The first is a list of prefabs to spawn when the bird splits. Next is the angle difference between each new bird that will be launched. Finally is a value to spawn the birds a little ahead of their current position to keep them from getting stuck inside each other.<div><pre class="programlisting">public GameObject[] splitBirds = new GameObject[0];
public float launchAngle = 15f;
public float spawnLead = 0.5f;</pre></div></li><li class="listitem">Next, we override the <code class="literal">DoSpecial</code> function and start, as with the others, by marking that we made our special move. Next, it calculates half of the number of birds to spawn and creates an empty list for storing the rigidbodies of the newly spawned birds.<div><pre class="programlisting">protected override void DoSpecial() {
  didSpecial = true;
  
  int halfLength = splitBirds.Length / 2;
  Rigidbody[] newBodies = new Rigidbody[splitBirds.Length];</pre></div></li><li class="listitem">The function continues by looping through the list of birds, skipping the slots that are empty. It spawns the new birds at its position, continuing to the next if there is a missing <strong>Rigidbody</strong> component. The new <strong>Rigidbody</strong> component is then stored in the list.<div><pre class="programlisting">  for(int i=0;i&lt;splitBirds.Length;i++) {
    if(splitBirds[i] == null) continue;

    GameObject next = Instantiate(splitBirds[i], transform.position, transform.rotation) as GameObject;
    if(next.rigidbody == null) continue;

    newBodies[i] = next.rigidbody;</pre></div></li><li class="listitem">Using <code class="literal">Quaternion.Euler</code>, a new rotation is created that will angle the new bird along a path split off from the main path. The new bird's velocity is set to the rotated velocity of the current bird. It is then moved forward along its new path to get out of the way of the other birds being spawned.<div><pre class="programlisting">    Quaternion rotate = Quaternion.Euler(launchAngle * (i – halfLength), 0, 0);
    next.rigidbody.velocity = rotate * rigidbody.velocity;
    next.transform.position += next.rigidbody.velocity.normalized * spawnLead;
  }</pre></div></li><li class="listitem">After the loop, the function uses <code class="literal">FindObjectOfType</code><a id="id525" class="indexterm"/> to find the slingshot that is currently in the scene. If found, it is changed to track the first new bird spawned as the one that was fired. The new list of rigidbodies is also set to the <code class="literal">rigidbodyDamper</code> variable to be added to its list of rigidbodies. Finally, the script destroys the bird it is attached to, completing the illusion that the bird has split apart.<div><pre class="programlisting">  Slingshot slingshot = FindObjectOfType(typeof(Slingshot)) as Slingshot;
  if(slingshot != null) {
    slingshot.toFireBird = newBodies[0].transform;
  slingshot.rigidbodyDamper.AddBodiesToCheck(newBodies);
  }

  Destroy(gameObject);
}</pre></div></li><li class="listitem">Before you add the script to your new bird, we actually need two blue birds: one that splits and one that does not. Duplicate your bird and name one <code class="literal">Bird_Blue_Split</code> and the other <code class="literal">Bird_Blue_Normal</code>. To the split bird add the new script and to the normal bird add the <code class="literal">Bird</code> script.</li><li class="listitem">Turn both birds into prefabs and add the normal bird to the other's list of birds to be split into.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec115"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created the blue bird. This bird splits into multiple birds when the user taps the screen. The effect actually requires two birds that look identical. One that does the splitting and another that is split into but does nothing special.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec116"/>Have a go hero – creating a rainbow bird</h2></div></div></div><p>It is actually possible to add <a id="id526" class="indexterm"/>anything we want to spawn to the blue bird's list of things to split into. Your challenge here is to create a rainbow bird. This bird could split into different types of birds, not just blue ones. Or, perhaps it is a stone bird that splits into stone blocks. For an extended challenge, create a mystery bird that picks a bird from its list randomly when it splits.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec117"/>The black bird</h2></div></div></div><p>Finally, we have the black bird. This bird explodes when the player touches the screen. As with all the birds discussed previously, it will extend the <code class="literal">Bird</code> script.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec112"/>Time for action – creating the black bird</h1></div></div></div><p>As with the two birds discussed earlier,<a id="id527" class="indexterm"/> inheriting from the red bird makes the black bird's creation much easier:</p><div><ol class="orderedlist arabic"><li class="listitem">As with the others, this bird is initially created in the same way as the red bird, readjusting the <strong>Radius</strong> for its increased size.</li><li class="listitem">Again, we create a<a id="id528" class="indexterm"/> new script to extend the <code class="literal">Bird</code> script. This time it is called <code class="literal">BlackBird</code>.</li><li class="listitem">Do not forget to adjust line four to extend the <code class="literal">Bird</code> script and not <code class="literal">MonoBehaviour</code>.<div><pre class="programlisting">public class BlackBird : Bird {</pre></div></li><li class="listitem">This script has two variables. The first is the size of the explosion and the second is its strength.<div><pre class="programlisting">public float radius = 2.5f;
public float power = 25f;</pre></div></li><li class="listitem">Once more we override the <code class="literal">DoSpecial</code> function<a id="id529" class="indexterm"/>, first marking that we did it. Next, we use <code class="literal">Physics.OverlapSphere</code> to acquire a list of all of the objects that are within the range of the bird's explosion. The function then loops through the list, skipping any empty slots and those without rigidbodies. If the object does exist and has a <strong>Rigidbody</strong> component attached, we call <code class="literal">AddExplosionForce</code> to simulate the way an explosion's strength against you is reduced the further you are from it. We give the function the explosion's strength, followed by the bird's position and radius. The value <code class="literal">3</code> is a vertical modifier. It does not interfere with the distance an object is from the explosion but, instead, adjusts the angle the explosion hits it at. This <code class="literal">3</code> moves the force to below the object, because explosions that throw debris up are cooler than ones that push out. <code class="literal">ForceMode.Impulse</code> is again used to apply the force immediately. Finally, the function destroys the exploded bird.<div><pre class="programlisting">protected override void DoSpecial() {
  didSpecial = true;

  Collider[] colliders = Physics.OverlapSphere(transform.position, radius);

  foreach(Collider hit in colliders) {
    if(hit == null) continue;
    if(hit.rigidbody != null)
      hit.rigidbody.AddExplosionForce(power, transform.position, radius, 3, ForceMode.Impulse);
  }

  Destroy(gameObject);
}</pre></div></li><li class="listitem">As with the last two, apply your new script to your new bird and turn it into a prefab. You now have four birds<a id="id530" class="indexterm"/> to choose from when selecting the slingshot arsenal for each level.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec118"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created our fourth and last bird, the black bird. This bird explodes when the user touches the screen, throwing anything that might be near into the sky. This can be a fun bird to play around with and effective for destroying your pig forts.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec119"/>Have a go hero – explosive blocks</h2></div></div></div><p>Now that you know how to cause explosions, we have another challenge. Create an explosive crate. Extend the <code class="literal">Plank</code> script to make it. When enough damage is done to the crate, trigger the explosion. For an added challenge, instead of making the crate explode, configure it to throw out a few bombs that explode when they hit something.</p><div><img src="img/2014OT_07_06.jpg" alt="Have a go hero – explosive blocks"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec113"/>Level selection</h1></div></div></div><p>Finally, we need to create our level selection. From this scene, we will be able to access and start playing all of the levels we created earlier. We will also display the current high scores for each level.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec114"/>Time for action – creating the level selection</h1></div></div></div><p>A new scene and a single script will serve us well in managing our level selection:</p><div><ol class="orderedlist arabic"><li class="listitem">This last section<a id="id531" class="indexterm"/> begins by saving your current scene and hitting <em>Ctrl</em> + <em>N</em> to create a new one, named <code class="literal">LevelSelect</code>.</li><li class="listitem">For this scene, we need to create a single, short script also named <code class="literal">LevelSelect</code>.</li><li class="listitem">The first and only variable defines the size of the buttons that will appear on screen.<div><pre class="programlisting">public int buttonSize = 100;</pre></div></li><li class="listitem">The only function is the <code class="literal">OnGUI</code> function.<a id="id532" class="indexterm"/> This function starts with a loop. It will loop through three times for the three levels we should have created earlier. A <code class="literal">Rect</code> variable is created and initialized to the <code class="literal">buttonSize</code>. The x and y values are then set to position the buttons in a row, centered on the screen. Next, the current high score for the level is retrieved, using <code class="literal">PlayerPrefs.GetInt</code> and the same key creation that we used in our <code class="literal">LevelTracker</code> script. Then, the function creates a string to hold the message that will appear on the button. Finally,<a id="id533" class="indexterm"/> the button is drawn and, when clicked, <code class="literal">Application.LoadLevel</code> is used to load the scene and start the user playing that level.<div><pre class="programlisting">public void OnGUI() {
  for(int i=0;i&lt;3;i++) {
    Rect next = new Rect(0,0, buttonSize, buttonSize);
    next.x = (Screen.width / 2) – (buttonSize * 1.5f) + (buttonSize * i);
    next.y = (Screen.height / 2) – (buttonSize / 2f);

    int levelScore = PlayerPrefs.GetInt("LevelScore" + (i + 1), 0);
    string text = "Level " + (i + 1) + "\nScore: " + levelScore;

    if(GUI.Button(next, text)) {
      Application.LoadLevel(i + 1);
    }
  }
}</pre></div></li><li class="listitem">Return to Unity and add the script to the <code class="literal">Main Camera</code> object.</li><li class="listitem">Finally, open the <strong>Build Settings</strong> and add your scenes to the <strong>Scenes in Build</strong> list. Clicking and dragging on the scenes in the list will let you reorder them. Make sure your <strong>LevelSelect</strong> scene is first and has the index of zero to the right of it. The rest of your scenes can appear in whatever order you desire. But be aware that they will be associated with the buttons in the same order.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec120"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a level-selection screen. It uses a loop to create a list of buttons associated with the levels in our game. When a button is pressed, <code class="literal">Application.LoadLevel</code> starts that level. We also made use of <code class="literal">PlayerPrefs.GetInt</code> to retrieve the high scores for each of the levels.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec121"/>Have a go hero – adding some style</h2></div></div></div><p>Here, the challenge is to use GUI styles to make the screen look great. A logo and a background would help a lot. Additionally, take a look at <code class="literal">GUI.BeginScrollView</code> if you have more than three levels. This function will let the user scroll through a list of levels that is far greater in size than can be easily seen on screen.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec115"/>Summary</h1></div></div></div><p>In this chapter, we learned about physics in Unity and recreated the incredibly popular mobile game, Angry Birds. By using Unity's physics system, we are able to make all of the levels that we could ever want to play. With this game, we also explored options for creating a 2D game in a 3D environment. Our birds and slingshot are 3D assets, giving us the ability to light and shade them. The pigs and the background, however, are 2D images, reducing our lighting options, but can allow for some greater detail in the assets. The 2D images were also crucial in the creation of the parallax scrolling effect of the background. Finally, the building's blocks appear to be 2D, but are actually 3D blocks. We also created a level-selection screen. From there, the player can see their high scores and pick any of the levels that we created to play.</p><p>In the next chapter, we return to the Space Fighter game we started in the previous chapter. We are going to create and add all of the special effects that finish off a game. We will add the shooting and explosion sound effects that every space game needs. We will also add various particle effects. When ships are shot at, they will actually explode, rather than just disappearing.</p></div></body></html>