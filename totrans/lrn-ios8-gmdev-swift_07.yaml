- en: Chapter 7. Advanced SpriteKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover some advanced features that are present in SpriteKit,
    such as lighting and physics, that will make the process of game development easier
    and will make our game looking prettier. With lighting, we can create a light
    source and make certain objects in the scene cast shadows and get affected by
    the light. Using a physics engine, we can make the game objects automatically
    get affected by gravity and forces applied externally.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at how to import classes, which are written in Objective-C,
    so that if you have already written some classes for the SpriteKit Objective-C,
    we can easily bring them into Swift without the need to rewrite the code again.
  prefs: []
  type: TYPE_NORMAL
- en: Using this new knowledge of importing Objective-C classes, we will look at tools
    such as Glyph Designer and Spine. With Glyph Designer, we can have custom fonts
    that take up less space and processing power than regular labels, and with Spine,
    we can create skeletal-based animation, which is a better optimized way of creating
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lighting and shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite Illuminator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective-C in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glyph Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skeletal animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting and shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create light sources in SpriteKit using a **LightNode**. The LightNode
    can be placed in the scene like a sprite node by adding it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a light source, open the `MainMenuScene` class and add the following
    after we added the background to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Similar to how we create an SKSpriteNode, we create an SKLightNode to create
    lights in Swift. We position it by centering it along the width and placing it
    at three quarters the height of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If you build and run the game now, you will see that there is no change to the
    scene. This is because we have to tell the scene specifically which objects should
    be affected by the light source. This is done by assigning a category bitmask
    to the light source so that we can later go to the object and tell it to be affected
    by the light of a certain bitmask. Here, we assign the bitmask as `1`. Since the
    bitmask takes a UINT32, there can be 32 light sources in total in a scene at a
    time, as there are 32 bits or 4 bytes in an integer.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the bitmask category of the LightNode to `1`, we are saying the first
    bit is switched ON for this light source. So, while assigning categories, you
    won't use general integer numbers to define a category. So, the category of a
    light should be 1, 2, 4, 8, 16, and so on. Here, `1` means that the first bit
    is ON, `2` means that the second bit is ON, and `4` means that the third bit is
    ON, and so on. Do not use general numbers such as 1, 2, 3, 4, and 5 and so on
    for defining categories, as it would lead to unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: While creating light sources, we also need to provide other information regarding
    the light source, such as falloff. Like all light sources, it has maximum intensity
    at the source, and the more you move away from the source, the weaker and weaker
    the intensity becomes. Falloff determines how quickly the light source loses its
    intensity. A value of `1` means that it will never lose its value of intensity
    and `0` means that it will lose it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Along with bitmask and falloff, we also need to provide the color of the light
    source, the ambient light, and the color of the shadows. For the light and shadow
    color, we give white and black. Note that in the shadow color, we reduced the
    value of the opacity as otherwise the shadows will be completely black. For the
    ambient color, we reduced the blue variable to zero, as there is enough blue from
    the sky in the background. Then, we add the light to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: To actually make an object get affected by the light source, we have to assign
    the `lightBitMask` property of that object to the category bitmask of the light
    source we assigned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to make the BG get affected by the light source, add the following in the
    code after where we added the BG to the scene and run the game to see the result,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Lighting and shadows](img/B04014_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Wow! Isn''t that pretty? Here I changed the color of the font to blue so that
    the light source is easily visible. This can be done by adding the following highlighted
    line in `myLabel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now to cast shadows, all we have to do is call `shadowCastBitMask` on the object
    that you want to cast shadows. Assign the category bitmask of the light source
    to it so that shadows can be cast.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will ask the play button sprite image to cast a shadow, so after adding
    the play button to the scene, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, the play button will cast a shadow depending upon where the light source
    is.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things to keep in mind while creating light sources and shadows
    in a scene. Only sprites can cast shadows in a SpriteKit scene. I tried applying
    it to the label and it wasn't able to create shadows from the text.
  prefs: []
  type: TYPE_NORMAL
- en: If you are making an object get affected by the light, make sure that it is
    never deleted and then added back into the scene. If the object is removed, the
    light source has to recalculate the lighting in the scene, and this process is
    done again once the object is added back into the scene. This will cause a flicker
    while recalculating the light and shadows in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's is better to add shadows to objects that you know won't get deleted in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in `GameViewController`, change `ignoreSiblingOrder` to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With that said, let us run the scene to see the shadow in action, as shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting and shadows](img/B04014_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is awesome. But wouldn't it be great if we could add some moving clouds
    that cast shadows in the scene? Also, since the cloud is moving, we can use the
    parallax sprite class to make the BG scroll like we did in the previous chapter.
    We can also add a sprite for the sun and make it spin.
  prefs: []
  type: TYPE_NORMAL
- en: To do this for this chapter, we will create a separate sprite for the sky and
    change the BG sprite to not include clouds, as we will be adding a new cloud sprite
    and moving it using the moving sprite class and making it loop around the scene.
    So, go to the resources folder of this chapter, go into the lighting directory,
    and get the sky, sun, cloud, and the new BG images. Create image assets called
    sky, sun, and cloud. Replace the old BG sprite with the new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainMenuScene` class, add the sky sprite first as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the sun sprite to the scene as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After adding the sun to the scene, make it get affected by the light. Then,
    we create a new `repeatActionForever` variable on it so that it will rotate the
    sun sprite by one degree every second forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, at the top of the `MainMenuScene` class, add the following global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we want to call the update methods on the `scrollingBg`, `cloudNode`, and
    cloud objects in the `update` function, we want them to be global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now, initiate the classes and variables in the `didMoveToView` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First create `cloudNode` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initiate the `shadowcaste` property on `cloudNode` and add it to the
    cloud moving sprite variable so that we can update its position later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We make the cloud move slowly when compared to the background since the background
    is moving at speed of `–5.0`. If we make both of them move at the same speed,
    then it will look as if the background and cloud are one image and moving together.
  prefs: []
  type: TYPE_NORMAL
- en: Below this, add the light source.
  prefs: []
  type: TYPE_NORMAL
- en: After this, initiate the `scrollingBg` class by creating two sprite images called
    `BG1` and `BG2`. Add them to the scene and initiate `lightingBitMask` on both
    the background sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, initiate the `scrollingBg` class by passing in the background sprites,
    the `viewsize`, and the speed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to update the position of `scrollingBg`, the cloud, and the cloud
    node objects. So, add an update function and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we call the `update` and `moveSprite` functions of `scrollingBg` and cloud
    objects. We also update the position of the `cloudNode` sprite by settings its
    `X` position to the right of the screen once the image has gone beyond the left,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting and shadows](img/B04014_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have to be careful with the order in which the objects were added to the
    scene to make sure the shadows are cast properly. The order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sky`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud (`cloudNode`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lightNode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scrollingBg` (`BG1` and `BG2`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is important since the shadow is cast in the same depth as the light source
    and not at the depth of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding image, though we ask the light to cast on the play button,
    we don't see a shadow as we saw in the earlier screenshot since the background
    layer is above that. If you bring `lightNode` to the top-most layer, you will
    see the play button cast a shadow, but then even though the clouds are behind
    the background layer, their shadows will be seen over the trees in the background
    layer, which is odd. So, it is important at which layer you add the light source.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing you have to be careful about is the size of the image that you
    want the light to get affected by. You will see that that I didn't enable the
    `lightBitMask` property on the sky image, as it brought down the FPS of the game
    to 45 and everything was running slowly on my iPadMini Retina. So I disabled lighting
    on the sky layer and just kept it on the run and background sprites. But this
    was still causing stutter and slowdown on iPad3, so I had to completely disable
    lighting on all the images to have a consistent 60 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Adding lighting and shadows is very hardware and processor intensive, so make
    sure you do enough testing on all the devices while implementing them in your
    game so that, irrespective of which device the game is running on, it runs at
    a smooth FPS.
  prefs: []
  type: TYPE_NORMAL
- en: This is all for lighting; we will move to the `GameplayScene` class to look
    at physics and see how to implement it. We will return to `MainMenuScene` when
    we look at Glyph Designer and Spine later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to add physics by replacing the small physics
    engine we created earlier, which was used to create gravity to pull the player
    down or bump the player up.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Illuminator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although SpriteKit adds a normal map on its own, you can also specify your own
    normal maps for better results. To download Sprite Illuminator, go to [https://www.codeandweb.com/spriteilluminator](https://www.codeandweb.com/spriteilluminator)
    and download the DMG file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Sprite Illuminator has been downloaded, double-click on the DMG file and
    copy the application to the **Applications** folder. Go to the Launchpad and start
    the application. Once the application launches, you should see the window as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sprite Illuminator](img/B04014_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us look at the interface in detail.
  prefs: []
  type: TYPE_NORMAL
- en: On the left, we have the **Sprites** panel. The middle panel is the **Preview**
    panel, in which you can see a preview of all the changes as you make them. The
    panel on the right is called the **Tools** panel. We will drill down further into
    each of these panels.
  prefs: []
  type: TYPE_NORMAL
- en: The Sprites panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the **Sprites** panel, you can modify the sprite, global light, and display
    mode as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sprite**: Here we can add or remove the sprites for which we want the normal
    map to be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global light**: We can change the property of the global light source by
    affecting its `Z` position, brightness, light color, and ambient color. This is
    just for visualization purposes, in the game, we will have to add a light source
    and change its properties in SpriteKit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display mode**: By default, the **Lit texture** mode is ON. This gives a
    preview of how the image will look with lighting and normal map enabled. Texture
    mode will just show the texture without lighting and normal map. Lit surface will
    show the image with the light source but without the normal map. The **Normal
    map** mode will show only the normal map that you have created for an image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Preview panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Preview** panel will show the preview of the image depending upon the
    mode you select in the **Display mode** section.
  prefs: []
  type: TYPE_NORMAL
- en: The Tools panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be spending most of the time in the tools panel. This is where we will
    be creating the height map for any image. The **Tools** panel includes **Effects**
    and **Brushes and Tools**:'
  prefs: []
  type: TYPE_NORMAL
- en: Under **Effects**, using the **Bevel** and **Emboss** tool we can add height
    or depth to the map. This works exactly how the same tools work in Photoshop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under **Brushes,** five brushes are included. The brushes included are **Height**,
    **Angle**, **Structure**, **Smoothen**, and **Erase**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Height**: This can be added to an area that you wish to make appear to be
    protruding from the image. You can specify the values for **Brush Size**, **Height**,
    **Hardness**, **Contour**, and **Direction** for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angle**: This can be added to an area which might be at a particular angle
    to the direction of the light. This is most useful while developing isometric
    tile maps. Apart from specifying the values for **Brush Size**, **Opacity**, and
    **Hardness**, we can specify the direction of the surface by selecting the area
    around the sphere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structure**: This brush is used to add some rough texture to an area. You
    can modify the brush size, density, height, and direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoothness**: This brush is used to smoothen an area. The brush size and
    smoothness can be controlled by the slider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Erase**: If we wish to erase an effect or brush we can do so by using the
    erase brush'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a couple of **selection tools** that are provided that can make the
    selection process a little simpler. So, if you want to apply a brush or an effect
    in a particular area, you can isolate that area using the selection tool and apply
    the effect in just that area:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wand/Color**: This tool is like the wand tool in Photoshop. You can also
    adjust the tolerance level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polygon**: You can create a closed polygon loop around the area of an image
    with this tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move**: You can move the image with this tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you are happy with your creation, you can click on the **Publish** button
    and a normal map will be created for your image. The normal map will be a PNG
    file with the same file name as your original file suffixed with `_n`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Sprite Illuminator, I have created a normal map for the hero sprite (shown
    in the following screenshot). The file and resources are included in the `Resources`
    folder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Tools panel](img/B04014_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `Sprite Illuminator` folder in the `Resources` directory, I have created
    the two versions of the regular image and normal map for both the sizes. I have
    also renamed the files to avoid any name conflicts. Drag these four files into
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: To use these assets in the `GamePlayScene.swift` file, comment out the old code
    for adding and animating the hero sprite, and add the following highlighted code
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Here, instead of loading the hero file in the image set, we are assigning the
    `heroSI` and `heroSI_n` texture to the hero variable.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we set the `lightBitmask` property of the hero to `1` so that the light
    source affects it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In other frameworks, you will most probably have to import a physics engine
    library of your choice, such as Box2d, or chipmunk would configure it to make
    it work properly. You would also have to write custom code for making collision
    detection work. In SpriteKit, every scene has physics running in the background
    as soon as the scene is created. You are not required to do anything else to make
    it work. So, in the gameplay scene, we will disable the physics engine we created
    and replace it with SpriteKit's inbuilt physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `gameplayScene.swift` file and comment out the `updateHero` function
    in the `update` function. As you might remember, the `updateHero` function took
    care of making the hero get affected by gravity, making sure the hero was inside
    the screen at all times and also making sure thrust is applied when the player
    taps the left half of the screen. Using the inbuilt physics engine, we will see
    how we can make it do all the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: As I said earlier, the physics is already active, meaning that there is already
    some gravity that is acting on the scene. So, let us make the hero get affected
    by gravity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `init` function, right after we added the hero sprite to the scene,
    add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is all we have to do to tell the hero to get affected by physics. The `physicsBody`
    property of any sprite will assign a body to the sprite, making it behave like
    a solid object, meaning that now this sprite will have physics properties like
    any object in real life. It will have a density, respond to friction, be bouncy,
    and get affected by other bodies. Now we can apply force to it or make it move
    with a certain velocity. If some moving body hits this body, as Newton said, it
    would react to that hit and move.
  prefs: []
  type: TYPE_NORMAL
- en: When we assign a body, we have the option of giving shape to the body. Here
    we are giving a rectangle with the same dimensions as the sprite. If we wish,
    we could have given the body the shape of a circle or we could also use a custom
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: If we build and run the game now, we will see that the hero will just fall through
    the bottom of the screen. This is because nothing is preventing the hero from
    going through. To counter this downward motion, we have to create a body around
    the scene to prevent the hero from falling down.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `init` function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we attached a physics body to the hero, and now we are initiating
    the physics body property of the scene itself. The difference here is that it
    is an `edgeLoop` body type. An edge loop is different from a regular body type
    in that the former doesn't have volume. So, it doesn't have mass, density, friction,
    and so on, and you can't apply force or make it move with a velocity. But other
    bodies will get affected by it, meaning that if a regular body is moving and gets
    obstructed by an `edgeLoop`, then the regular body will stop moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics](img/B04014_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While creating an edge loop, we have to pass in the shape of the loop, so here
    we are giving the shape of a rectangle starting from the origin that is the bottom
    left of the screen, which is (0, 0), and the size of the view by passing in the
    width and height of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you build and run, you will see that the hero stops. In fact, the hero
    not only stops but also bounces a bit once she hits the bottom of the screen.
    You can set the mass, density, friction, and restitution values depending upon
    how heavy or bouncy you need your character to be by changing the values, as shown
    in the following. The values range from `0` to `1` in all cases: `0` being less
    bouncy, dense, affected by friction, and so on, and `1` being the opposite end
    of the spectrum.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can also change the value of the gravity in the scene so if you wanted to
    make a level set on the moon, you can change the default gravity to 1/6th of its
    original value to give that effect.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note about the physics engine is that it is not in pixels
    but in real-world values. For example, the default value of gravity is actually
    9.8 meters/(second * second). All the values, which are actually pixels, are converted
    to meters, and SpriteKit does the conversion from pixels to meters internally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics](img/B04014_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To have moon like gravity, access the gravity property of the physics world
    property of the scene and change gravity to 1/6th of 9.8 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*self.physicsWorld.gravity = CGVector(dx: 0, dy: -1.64)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `gravity` property expects a `CGVector` value since we want the gravity
    to exert a downward force, the value of `x` is zero and `y` is kept at `–1.64`
    from the default value of `–9.8` as this is what gravity would be on the moon.
    You can change it back to `–9.8` for a more Earthy feeling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a force on the hero such that we can thrust her up in the air.
    So, in the `touchesBegan` function, we can remove the code that we previously
    added to push the hero up in the air and apply a physics force in the upward direction.
    But before we add the force, we have to set the velocity of the hero zero since
    the hero would have to overcome the downward velocity to move upward. If the velocity
    in the negative *y* direction is too big, then, irrespective of how much force
    you apply upward, it will all be nullified by the downward gravitational force
    acting on the hero. First make the downward velocity of the hero zero and then
    apply the force upward. Take the following thrust code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we set the hero's velocity to `0`. Since there is no velocity acting in
    the *x* direction, it doesn't matter if we set just the `Y` value to `0` or both
    the `X` and `Y` values to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we apply an **impulse** in the *y* direction with an `X` value of `0`
    and `Y` value equal to `300`. But wait!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is this impulse thing?**'
  prefs: []
  type: TYPE_NORMAL
- en: All this time we were talking about applying force and now we are actually applying
    an impulse. In the physics engine, there is a separate property called force and
    how it works is that once you apply a force to a body, the force will be constantly
    applied to the body. We just want the force to be applied once after we tap the
    left half of the screen. So, we apply an impulse and not force. If we wanted the
    player to keep moving up once we tap the screen, we should use the force property
    instead of impulse. So, be sure how you want your object to behave and apply either
    a force or an impulse on your physics object accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: And that is all. Now you have the player behaving exactly as we did with our
    own homegrown physics engine previously. Run the game and test it.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now look at how to import Objective-C classes into Swift and use them.
    We will then use this to use tools such as Glyph Designer and Spine, which have
    implementations in Objective-C but don't have specific classes in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: For making Objective-C classes work with Swift, you will need to create a bridging
    header file. The file is usually named with the convention `<ProjectName>-Bridging-Header.h`,
    and then you will need to add the file location into **Objective-C Bridging Header**
    under **Swift Compiler – Code Generation** in the project `Build Settings`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using the code provided along with this book, you might need to modify
    the path to avoid compilation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, if you create a new header file in a swift project, you will be greeted
    with the following window asking to treat the current file created as the bridging
    header file, and Xcode will automatically add the location of the file in **Build
    Settings**. In case it doesn't pop up, we will have to walk through the steps
    to make sure Xcode knows where to look for the bridging header file manually.
  prefs: []
  type: TYPE_NORMAL
- en: '![Objective-C in Swift](img/B04014_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For creating the bridging header file for the current project, go to **File**
    | **New** | **File** and then select **Source** under **iOS** and select the header
    file with an "H" on it. Name the file **skGame-Bridging-Header** and click on
    **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go to **Build Settings** and in the search type `bridging`, as shown in
    the following screenshot. Double-click to the right of **Objective–C Bridging
    Header** and drag-and-drop the bridging header file that we just created from
    the project onto the box. Hit *Enter*. Now, the project knows the location of
    the bridging header file. We can use this file to call the header files of Objective-C
    classes so that they can be shared with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '![Objective-C in Swift](img/B04014_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Glyph Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Glyph Designer is an application that can be used to make fonts that can be
    used in the game. But don't we already have an SKLabel for that? That is true.
    But SKLabel takes the font from the system, and converts the font files into an
    image at run time and then displays it onto the screen. So, whenever the score
    needs to be incremented, the system will need to convert the font into an image
    and then display that on the screen. This is very similar to the problem we faced
    with sprites earlier and used Texture Packer to get around it.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can use system fonts for bigger games, it is better to use a Bitmap
    font, a font in which the letters and numbers are already converted to images
    rather than converting them every time. So, with Glyph Designer, we can create
    a Bitmap font and use it to better optimize the game.
  prefs: []
  type: TYPE_NORMAL
- en: Bitmap fonts are similar to a spritesheet and will have an image with all the
    letters, numbers, and symbols in it, and this image file will be accompanied with
    a data file that has the locations and size of the symbols and letters. Whenever
    a letter needs to be displayed on the screen, the data file will be checked for
    the location of the letter, which will be retrieved and then displayed on screen.
  prefs: []
  type: TYPE_NORMAL
- en: The trial version of the application can be downloaded from [https://71squared.com/glyphdesigner](https://71squared.com/glyphdesigner).
  prefs: []
  type: TYPE_NORMAL
- en: '![Glyph Designer](img/B04014_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After downloading the application, you can open it and it will create a new
    untitled project. On the left panel, you will see a list of all the fonts that
    are present in the system. The center view shows the spritesheet of the file that
    will be created. This is a preview window and will dynamically change according
    to the changes you make.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right panel is where you will be making most of the changes after selecting
    the font that you want to modify on the left. On the right panel, you will find
    the following headings (as shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Glyph Info**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture Atlas**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glyph Fill**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glyph Stroke**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glyph Shadow**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Included Glyphs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Glyph Designer](img/B04014_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should be mostly concerned with **Glyph Fill**, **Stroke**, and **Shadow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Glyph Fill**: We can select the type of fill, that is **Solid**, **Gradient**,
    or **Image**. So, basically we can select the color of the font here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glyph Stroke**: This will create a new stroke effect around the letter. You
    can select the color and the size of the stroke here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glyph Shadow**: Here we can select the color and direction of the shadows.
    There are two types of shadows: inner and outer. This effect will give the letters
    a bit of depth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you are satisfied with the changes, click on the **Export** button and
    select the format. You can select the `skf @2` version or the normal `skf` version
    for generating the files for **2x** and **1x** resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Glyph Designer](img/B04014_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a Bitmap font
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you select `.skf` in the export type. This will create a folder with
    `.atlas` at the end with all the characters and symbols in it and a `.skf` file
    that is the data file associated with the font.
  prefs: []
  type: TYPE_NORMAL
- en: Drag both the `.atlas` folder and the `.skf` file into the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to implement the Bitmap font in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: For making Glyph Designer work with SpriteKit, we will need the universal static
    library created by 71Squared. Go to [https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit](https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit)
    and download the `libSSBitmapFont.zip` file from the bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the file is downloaded, extract it and drag the `SSBitmapFont.h` and `SSBitmapFontLableNode.h`
    files into the project. Don't drag the folder containing the files, but just the
    individuals files themselves. Also, drag the `libSSBitmapFont.a` file into the
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the bridged header file we created earlier and import the two header
    `SSBitmapFont.h` and `SSBitmapFontLabelNode.h` files in the bridged header file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can access the files anywhere in our Swift project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make sure everything works correctly, just build the project to make sure
    that there aren't any errors popping up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MainMenuScene` class, we will use the Bitmap font to display the name
    of the game instead of `SKLabelNode`. Open the `MainMenuScene` class. At the top
    of the class, add the following code. This is similar to what we did to get the
    `bgMusic.mp3` file in the `GameViewController` class. But here we will get the
    SKF file from the main bundle location of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we create a new variable called `bmFontFile`, and using the `SSBitmapFont`
    class we imported from Objective-C, we get the name of the `skGame_font` font
    file from the project location. Along with the name, we also need to provide the
    extension of the `skf` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we have the `bmFont` file saved, we can use this file to create new text
    or a label by passing in the text and assigning the position, and adding it to
    the scene. So, we replace the code of `SKLabelNode` that we had added previously
    with the following code to see the Bitmap font in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create a new constant called `bmFontText` and use the `nodeFromString` property
    of `bmFontFile` to assign the `Ms.TinyBazooka` text to it. We set the position
    as usual and add the `bmFontText` to the scene:![Implementing a Bitmap font](img/B04014_07_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can immediately see that the Bitmap font is a lot sharper than the text
    created with `SKLableNode`. So, it is no surprise that these days, games made
    by both professional companies both independent developers use Bitmap fonts instead.
  prefs: []
  type: TYPE_NORMAL
- en: Skeletal animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an earlier chapter, we saw how to make animations in the game using frame-based
    animation, in which we imported a series of images and created an animation by
    cycling through the frames. Although frame-based animations are good, they can
    be tedious to make. The artist has to draw each frame and you can't have too many
    frames if you want to keep the bundle size low. As a result, the animations don't
    look very fluid. Moreover, if you want to make some changes to the character,
    then it is back to the drawing board for the artist, as he has to go through all
    the frames of the animations and redo them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the skeletal animation technique instead of making the individual frames
    for animation, we import individual parts of the character and make a spritesheet,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using an application, we position the parts of the character and then create
    an animation. This way we can create different animations such as walking, running,
    jumping, attacking, and so on, from the body parts. All the animations are exported
    as a data file.
  prefs: []
  type: TYPE_NORMAL
- en: When the data file and character parts are brought into the game, the data file
    will be referred to place parts of the character to form the posture of the character.
    Later, when we call an animation to play on the character, the data file will
    be referred to again to create the movement dynamically. Lets us see how to create
    skeletal animations.
  prefs: []
  type: TYPE_NORMAL
- en: For creating the animations, we will be using an application called **Spine**
    by Esoteric Software. You can download the trial version from their website at
    [http://esotericsoftware.com/](http://esotericsoftware.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The trial version won't allow you to save the project but I have included the
    project file with the resources for this chapter so that you can open it in the
    trial version and play around with it.
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the DMG file from the site, double-click on it to install
    it. Once the installation is complete, click on the spine logo on the top left
    side of the screen to create a new project, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have to bring in the parts of the character so that we can pose the
    character properly for animation. This phase is called the character setup.
  prefs: []
  type: TYPE_NORMAL
- en: In the resources for this chapter in the spine folder, you will find a folder
    called `heroParts`, copy this folder onto the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: When you open Spine, the default project will be loaded. For creating a new
    project, click on the Spine icon on the top left and then select **New Project**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the **Tree** panel on the right-hand side, in the **Hierarchy** panel, select
    the **Images** folder, as in the preceding screenshot. At the bottom you will
    now be able to select the path to the `heroParts` folder. Click on **Browse**
    and point it to the other `heroParts` folder on the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: All the parts will appear under the **Images** tab. Next, drag all the parts
    onto the checked view panel. You can click on the individual parts and use the
    rotate and translate button in the **Transform** panel on the bottom to place
    the parts of the hero. If some parts need to be in front of others, then click
    on the triangle next to **Draw Order** in the **Hierarchy** panel and drag an
    image to make it appear above or below any other object.
  prefs: []
  type: TYPE_NORMAL
- en: The small plus at the center of the view panel is the root node. Move this node
    to the middle of the character by locking the images by clicking on the **Images**
    button in the **Compensate** panel on the bottom of the screen. You can rename
    the root node by clicking on it. Rename it to `hip` for the sake of convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the character is set up properly, it should look like the following image.
    Refer to the following screenshot for checking the **Draw Order**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next we will draw the bones. Bones work very similarly to human bones. You can
    attach one or more parts of the character to a bone, and then when you move or
    rotate the bone, the character part will move or rotate accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create bones for the legs. To create bones, click on the **Create**
    button with the bones icon on it on the **Tools** panel on the bottom of the screen.
    Now we will create a bone from the hip to the left foot. Left click on **hip**
    to start creating a bone. While still holding the left mouse button, move the
    mouse toward the left-foot image. Press the *Shift* key on the keyboard while
    over the left foot. Once the left foot is highlighted, release the mouse button
    and *Shift* key.
  prefs: []
  type: TYPE_NORMAL
- en: Now do the process again for the other foot. Start from the hip and press the
    *Shift* key, and when the other foot is highlighted, release the mouse and *Shift*
    key. It is OK if the bone is not perfectly aligned with the foot.
  prefs: []
  type: TYPE_NORMAL
- en: Again, from the hip, create a bone to the body so that it is closer to the start
    of the hand, but make sure the body is highlighted and not the hand. Name this
    bone `body` in the **Hierarchy** panel. Now, from the end of this newly created
    bone, create one bone for the hand and another for the head of the character.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the bazooka is still attached to the hip or the root bone.
    In the **Hierarchy** panel, move the bazooka node under the hand bone. This way,
    the bazooka will move along with the hand bone. The following screenshot shows
    the bone hierarchy after completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can click on the individual bones, rotate them, and when you rotate
    the bone, the body part also rotates along with it. Here is the character in different
    poses.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure the rotate button is clicked on in the **Transpose** panel and the
    images are not locked.
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the character is setup and ready to be animated. Click on the **Setup**
    button on the **View** panel. You are now in **Animation** mode. A new panel will
    open up below called **DopeSheet**. Click on the **Animations** heading under
    the **Hierarchy** panel and click on **NewAnimations** at the bottom of the screen.
    A new window will open, asking for a name, enter `walk` here and Click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the new **Dopesheet** panel, you will see that the **Transformation**
    panel has also changed a bit. If you click on any bone, a green key symbol appears
    next to the **Rotate**, **Translate**, and **Scale** buttons, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These keys record the changes made in the **Rotation**, **Translation**, and
    **Scale** buttons of that bone. Green signifies that no changes have been recorded.
    Click on the three green buttons in the **Transform** panel at the 0th frame.
    Now, the values have been recorded as the keys have changed from green to red.
    Now, move the time line slider in blue from the 0th frame in the dopesheet to
    the 5th frame. Again the keys are green. Rotate the leg back a little bit and
    once again click on all three keys to make them red.
  prefs: []
  type: TYPE_NORMAL
- en: If you move the timeline slider between the 0th and 5th frames, you will see
    the leg rotating back and forth. Click on the play button to see the animation
    in action. Click on the loop button to the right end of the play button to loop
    the animation. This is how an animation is created.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a simple walk cycle animation that we will later import in the
    game and play the animation. Undo all the actions to go back to the original pose.
  prefs: []
  type: TYPE_NORMAL
- en: For creating the walk cycle, we record the position, rotation, and scale of
    all the bones in the 0th, 6th, 12th, 18th, and 24th frames. The pose on the 0th
    and 24th frames is the same. The pose in the 12th frame is the opposite of that
    in the 0th frame, as the position of the feet will be interchanged, meaning the
    foot that was previously at the back in the 0th frame will be at the front and
    vice versa. At the 6th and 18th frames, the feet will be brought back together
    and the character will be raised by moving the hip/root.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the poses at different frames. Starting from
    the left, the first pose is for the 0th and 24th frames. So, rotate the leg bones
    apart, and select all the bones and create a key by clicking on all three green
    key buttons. Keeping the same pose, move the time slider to the 24th frame and
    click on the key buttons again.
  prefs: []
  type: TYPE_NORMAL
- en: The middle image shows the pose for the 12th frame where the legs are switched.
    So, once again, rotate the legs and move the time slider to the 12th frame and
    click on the key buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The image on the right shows the pose for the 6th and 18th frames. Here, move
    the legs closer and raise the character by moving the hip bone up. Move the time
    slider to the 6th frame and create a key frame. To create the key frame for the
    18th frame, no changes are made to the pose. Just move the time slider to the
    18th frame and create a new key frame. That's it; your walk cycle is ready. Click
    on the play button and enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all the bones were selected when clicking on the green button to record
    the frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you have the essential or pro version of Spine, you can export the data
    file by clicking on the Spine icon on the top left and then clicking on **Export**.
  prefs: []
  type: TYPE_NORMAL
- en: The exported data type will be of type `.json`. Select the location where you
    want the data file to be exported and leave the other values as default. Click
    on the **Export** button to export the JSON data file.
  prefs: []
  type: TYPE_NORMAL
- en: When you export the file, you will notice that the data file is named skeleton.
    Rename the file to `player` manually, as every time the file is named skeleton
    by default and we don't want this file to be overwritten while creating JSON files
    for other characters.
  prefs: []
  type: TYPE_NORMAL
- en: To create the atlas for the images for the spine animation, create a folder
    called `player.atlas` and copy all the character parts from the `heroParts` folder
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: Now drag the `player.atlas` and `player.json` files into the project.
  prefs: []
  type: TYPE_NORMAL
- en: For animating the character, we require the Spine runtime. Similar to Glyph
    Designer, it is written in Objective-C, but as we did earlier, we will import
    the header file in the bridging header file and make the Objective-C classes accessible
    in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To get the header files, go to [https://github.com/mredig/SGG_SKSpineImport](https://github.com/mredig/SGG_SKSpineImport),
    and download the ZIP file and extract it. From the extracted folder, go to the
    `SpineImporter` folder and drag all the files in the folder to the Swift project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Bridging Header` file, add the `SpineImport.h` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainMenuScene` class, we will add the player animation. At the top
    of the class, create a global variable hero and assign the `SGG_Spine` class to
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code right after where we added `BG1` and `BG2` to the
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We provide the name of the JSON data file and the name of the atlas in the `skeletonFromFile`
    property of the hero. Since we didn't use any skins in the game, the third parameter
    is kept `nill`.
  prefs: []
  type: TYPE_NORMAL
- en: We, then, position the hero variable and increase the scale a bit.
  prefs: []
  type: TYPE_NORMAL
- en: To tell which animation to start playing, we use the `runAnimation` property
    of the hero and assign the walk animation we created in spine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the hero to the scene. Build and run the game to see the final
    result, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Skeletal animation](img/B04014_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to add lighting and shadows to our game without
    much effort. Since Apple included it with SpriteKit, you can be sure the code
    to create the effect is well optimized. In other frameworks, this effect has to
    be written by a developer, and the developer needs to have good experience to
    make an optimized lighting and shadow effect.
  prefs: []
  type: TYPE_NORMAL
- en: We also had a brief introduction to SpriteKit's physics engine and replaced
    our homemade physics engine with it. Here we have barely even scratched the surface
    of the possibilities with the physics engine. With good knowledge and experience,
    we can make our own Angry Birds clone.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from SpriteKit's Lighting and Physics engines, we also saw how to bring
    Objective-C code into Swift and make use of it to implement tools such as Glyph
    Designer and Spine. Both Glyph Designer and Spine are professional tools that
    are an absolute must for game developers and designers. They really help in optimizing
    and simplifying the game development process by a lot.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to say goodbye to Ms. TinyBazooka, for, in the next two chapters,
    we will be entering the world of 3D game development. But we will return to SpriteKit
    in [Chapter 10](ch10.html "Chapter 10. Publishing and Distribution"), *Publishing
    and Distribution*, where we will see how to publish this game to the App Store.
  prefs: []
  type: TYPE_NORMAL
