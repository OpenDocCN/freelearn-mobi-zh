<html><head></head><body>
        

            
                <h1 class="header-title">Booting Up x86vbox Using PXE/NFS</h1>
            

            
                
<p>In the last chapter, we created the x86vbox device and we were able to build it in our environment. In this chapter, we will start to debug the boot up process for x86vbox. The first thing that we meet in the boot up process is the bootloader issue. We could use the same GRUB bootloader as Android-x86. With GRUB, we still have issues about how to configure and install it on the storage media. If we go this way, we need to spend some time talking about the topics related to bootloader.</p>
<p>Using VirtualBox as a virtual hardware platform, we have a much simpler solution. We can use the built-in PXE boot mechanism to avoid bootloader issues. From a debugging point of view, PXE boot can make the entire boot up process more transparent to us. With PXE boot, we can move the installation of bootloader out of the picture so we can concentrate on debugging the Android system itself. In this chapter, we will cover the following topics:</p>
<ul>
<li>Setting up a PXE boot environment</li>
<li>Configuring VirtualBox to boot from PXE</li>
<li>Setting up the root filesystem using NFS</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Setting up a PXE boot environment</h1>
            

            
                
<p>What is PXE? <strong>PXE</strong> means <strong>Preboot Execution Environment</strong>. To build a Linux environment, what we need is to find a way to load the kernel and ramdisk to the system memory. This is one of the major tasks performed by most Linux bootloaders. The bootloader usually fetches the kernel and ramdisk from some kind of storage device, such as flash storage, hard disk, USB, and so on. It can also be retrieved from a network connection. PXE is a method that can boot a device with LAN connection and a PXE-capable <strong>network interface controller</strong> (<strong>NIC</strong>).</p>
<p>As shown in the following diagram, PXE uses the DHCP and TFTP protocols to complete the boot process. In the simplest environment, a PXE server is set up as both a DHCP and TFTP server. The NIC client obtains the IP address from the DHCP server and uses the TFTP protocol to get the kernel and ramdisk images to start the boot process:</p>
<div><img height="385" width="408" class=" image-border" src="img/image_09_001.png"/></div>
<p>PXE boot environment</p>
<p>In this section, we will learn how to prepare a PXE-capable ROM for a VirtualBox virtio network adapter so that we can use this ROM and boot the system via PXE. We will also learn how to set up a PXE server, which is the key element in the PXE setup. In VirtualBox, it includes a built-in PXE server. We will use this built-in PXE server to boot the Android system.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Preparing PXE Boot ROM</h1>
            

            
                
<p>Even though PXE boot is supported by VirtualBox, the setup is not consistent on a different NIC. You may get error messages such as <kbd>PXE-E3C - TFTP Error - Access Violation</kbd> during the boot. This is because PXE boot depends on LAN Boot ROM. When you choose different network adapters, you may get different test results. To get a consistent test result, you can use the LAN Boot ROM from the Etherboot/gPXE project. gPXE is an open source (GPL) network bootloader. It provides a direct replacement for proprietary PXE ROMs, with many extra features such as DNS, HTTP, iSCSI, and so on. There is a page at the gPXE project website about how to set up LAN Boot ROM for VirtualBox:</p>
<p><a href="http://www.etherboot.org/wiki/romburning/vbox">http://www.etherboot.org/wiki/romburning/vbox</a></p>
<p>The following table lists network adapters supported by VirtualBox:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>VirtualBox adapters</strong></p>
</td>
<td>
<p><strong>PCI vendor ID</strong></p>
</td>
<td>
<p><strong>PCI device ID</strong></p>
</td>
<td>
<p><strong>Mfr name</strong></p>
</td>
<td>
<p><strong>Device name</strong></p>
</td>
</tr>
<tr>
<td>
<p>Am79C970A</p>
</td>
<td>
<p>1022h</p>
</td>
<td>
<p>2000h</p>
</td>
<td>
<p>AMD</p>
</td>
<td>
<p>PCnet-PCI II (AM79C970A)</p>
</td>
</tr>
<tr>
<td>
<p>Am79C973</p>
</td>
<td>
<p>1022h</p>
</td>
<td>
<p>2000h</p>
</td>
<td>
<p>AMD</p>
</td>
<td>
<p>PCnet-PCI III (AM79C973)</p>
</td>
</tr>
<tr>
<td>
<p>82540EM</p>
</td>
<td>
<p>8086h</p>
</td>
<td>
<p>100Eh</p>
</td>
<td>
<p>Intel</p>
</td>
<td>
<p>Intel PRO/1000 MT Desktop (82540EM)</p>
</td>
</tr>
<tr>
<td>
<p>82543GC</p>
</td>
<td>
<p>8086h</p>
</td>
<td>
<p>1004h</p>
</td>
<td>
<p>Intel</p>
</td>
<td>
<p>Intel PRO/1000 T Server (82543GC)</p>
</td>
</tr>
<tr>
<td>
<p>82545EM</p>
</td>
<td>
<p>8086h</p>
</td>
<td>
<p>100Fh</p>
</td>
<td>
<p>Intel</p>
</td>
<td>
<p>Intel PRO/1000 MT Server (82545EM)</p>
</td>
</tr>
<tr>
<td>
<p>virtio</p>
</td>
<td>
<p>1AF4h</p>
</td>
<td>
<p>1000h</p>
</td>
<td/>
<td>
<p>Paravirtualized Network (virtio-net)</p>
</td>
</tr>
</tbody>
</table>
<p>Since paravirtualized networks have better performance in most situations, we will explore how to support PXE boot using the virtio-net network adapter.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Downloading and building the LAN Boot ROM</h1>
            

            
                
<p>There may be LAN Boot ROM binary images available on the Internet, but they are not provided at the gPXE project. We have to build from source code according to the instructions from the gPXE project website.</p>
<p>Let's download and build the source code using the following commands:</p>
<pre>
<strong>$ git clone git://git.etherboot.org/scm/gpxe.git</strong><br/><strong>$ cd gpxe/src</strong><br/><strong>$ make bin/1af41000.rom  # for virtio 1af4:1000</strong>  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Fixing up the ROM image</h1>
            

            
                
<p>Before the ROM image can be used, the ROM image has to be updated due to VirtualBox having the following requirements on ROM image size:</p>
<ul>
<li>Size must be 4K aligned (that is, a multiple of 4,096)</li>
<li>Size must not be greater than 64K</li>
</ul>
<p>Let's check the image size first and make sure that it is not larger than 65,536 bytes (64K):</p>
<pre>
<strong>$ ls -l bin/1af41000.rom | awk '{print $5}'</strong><br/><strong>62464</strong>  
</pre>
<p>We can see that it is less than 64K. Now we have to pad the image file to a 4K boundary. We can do this using the following commands:</p>
<pre>
<strong>$ python</strong><br/><strong>&gt;&gt;&gt; 65536 - 62464             # Calculate padding size</strong><br/><strong>3072</strong><br/><strong>&gt;&gt;&gt; f = open('bin/1af41000.rom', 'a')</strong><br/><strong>&gt;&gt;&gt; f.write('\0' * 3072)      # Pad with zeroes</strong><br/><strong>&gt;&gt;&gt; f.close()</strong>  
</pre>
<p>We check the image file size again:</p>
<pre>
<strong>$ ls -l bin/1af41000.rom | awk '{print $5}'</strong><br/><strong>65536</strong>  
</pre>
<p>As we can see, the file size is 64K now. To be convenient, I will upload this file at the following link and you can download it:</p>
<p><a href="https://sourceforge.net/projects/android-system-programming/files/android-7/ch14/1af41000.rom/download">https://sourceforge.net/projects/android-system-programming/files/android-7/ch14/1af41000.rom/download</a></p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Configuring the virtual machine to use the LAN Boot ROM</h1>
            

            
                
<p>The user-based VirtualBox configuration can be stored in the <kbd>$HOME/.VirtualBox</kbd> folder and we need to use this folder for the built-in PXE server.</p>
<p>This folder is not created by default, so we need to create it first:</p>
<pre>
<strong>$ mkdir .VirtualBox</strong>  
</pre>
<p>After we create this folder, we can launch VirtualBox and quit. Then, let's look at the content of the <kbd>$HOME/.VirtualBox</kbd> folder again, as shown in the following screenshot:</p>
<div><img height="186" width="543" class=" image-border" src="img/image_09_002.png"/></div>
<p>From the preceding screenshot, we can see that the content of this folder is empty before we run VirtualBox. After we execute VirtualBox and quit, there are a list of files that are created by VirtualBox in this folder.</p>
<p>Now, we can change the configuration to use the LAN Boot ROM we just created. To use this LAN Boot ROM, we can use the <kbd>VBoxManage</kbd> command to update VirtualBox settings. We use the following command to set the <kbd>LanBootRom</kbd> path:</p>
<pre>
<strong>$ VBoxManage setextradata global VBoxInternal/Devices/pcbios/0/Config/LanBootRom $HOME/.VirtualBox/1af41000.rom</strong>  
</pre>
<p>We copied the LAN Boot ROM to <kbd>$HOME/.VirtualBox/1af41000.rom</kbd>. We use <kbd>global</kbd> here, then all VMs will use the gPXE LAN Boot ROM. We can change <kbd>global</kbd> to a specific virtual machine name. In that case, the gPXE LAN Boot ROM will only be used by that virtual machine.</p>
<p>Having set up the configuration, let's look at the <kbd>$HOME/.VirtualBox/VirtualBox.xml</kbd> configuration file:</p>
<pre>
&lt;?xml version="1.0"?&gt; <br/>&lt;!-- <br/>** DO NOT EDIT THIS FILE. <br/>** If you make changes to this file while any VirtualBox related application <br/>** is running, your changes will be overwritten later, without taking effect. <br/>** Use VBoxManage or the VirtualBox Manager GUI to make changes. <br/>--&gt; <br/>&lt;VirtualBox  version="1.12-linux"&gt; <br/>  &lt;Global&gt; <br/>    &lt;ExtraData&gt; <br/>      &lt;ExtraDataItem name="GUI/DetailsPageBoxes" <br/>      value="general,system,preview,display,storage,audio,<br/>      network,usb,sharedFolders,description"/&gt; <br/>      &lt;ExtraDataItem name="GUI/LastWindowPosition" <br/>      value="475,240,770,550"/&gt; <br/>      &lt;ExtraDataItem name="GUI/SplitterSizes" value="255,511"/&gt; <br/>      &lt;ExtraDataItem name="GUI/UpdateCheckCount" value="2"/&gt; <br/>      &lt;ExtraDataItem name="GUI/UpdateDate" value="1 d, 2017-05-15, <br/>      stable, 5.1.2"/&gt; <br/><strong>&lt;ExtraDataItem </strong><br/><strong>      name="VBoxInternal/Deices/pcbios/o/Config/LanBootRom"</strong><br/><strong>      value="/home/roger/.VirtualBox/1af41000.rom"/&gt;</strong> <br/>    &lt;/ExtraData&gt; <br/>... 
</pre>
<p>As we can see, the <kbd>VBoxInternal/Deices/pcbios/o/Config/LanBootRom</kbd> configuration is set in this configuration file.</p>
<p>To remove the preceding configuration, we just have to reset the path value as follows. The <kbd>$VM_NAME</kbd> argument can be <kbd>global</kbd> or a virtual machine name:</p>
<pre>
<strong>$ VBoxManage setextradata $VM_NAME VBoxInternal/Devices/pcbios/0/Config/LanBootRom</strong>
</pre>
<p>You can also check the current configuration using the following command:</p>
<pre>
<strong>$ VBoxManage getextradata $VM_NAME VBoxInternal/Devices/pcbios/0/Config/LanBootRom</strong><br/><strong>Value: /home/roger/.VirtualBox/1af41000.rom</strong>  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Setting up the PXE boot environment</h1>
            

            
                
<p>With a proper PXE ROM installed, we can set up the PXE server now. Before we set up a PXE server, we need to think about the network connections. There are three ways a virtual machine in VirtualBox can connect to the network:</p>
<ul>
<li><strong>Bridged network</strong>: This connects to the same physical network as the host. It looks like the virtual machine connects to the same LAN connection as the host.</li>
<li><strong>Host-only network</strong>: This connects to a virtual network that is only visible by the virtual machine and the host. In this configuration, the virtual machine cannot connect to an outside network, such as the Internet.</li>
<li><strong>NAT network</strong>: This one connects to the host network through NAT. This is the most common choice. In this configuration, the virtual machine can access the external network, but the external network cannot connect to the virtual machine directly. For example, if you set up a FTP service on the virtual machine, the computers on the LAN of the host cannot access this FTP service. If you want to publish this service, you have to use port forwarding settings to do this.</li>
</ul>
<p>With these concepts in mind, if you want to use a dedicated machine as the PXE server, you can use a bridged network in your environment. However, you must be very careful using this setup. This is usually done by the IT group in your organization, since you cannot set up a DHCP server on the LAN without affecting others. We won't use this option here.</p>
<p>The host-only network is actually a good choice for this case, because this kind of network is an isolated network configuration. The network connection only exists between the host and the virtual machine. It is possible to use the host-only network to set up the PXE server, but we won't use this option in our setup.</p>
<p>In VirtualBox, PXE booting in the NAT network is supported. With this option, we don't need to set up a separate PXE server by ourselves. We will use this built-in PXE server in this book. The test environment from this chapter to <a href="15628e05-2216-4855-8347-588f61c8f61a.xhtml">Chapter 14</a>, <em>Customizing and Debugging Recovery</em> will use this setup.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Configuring and testing the PXE boot</h1>
            

            
                
<p>We can create a virtual machine instance to test the environment. We will demonstrate this in the Ubuntu 14.04 environment. The same setup can be duplicated to the Windows or OS X environment as well.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Setting up the virtual machine</h1>
            

            
                
<p>Let's create a virtual machine called pxeAndroid in VirtualBox first. After starting the VirtualBox, we can click the New button to create a new virtual machine, as shown in the following screenshot:</p>
<div><img height="323" width="433" class=" image-border" src="img/image_09_003.png"/></div>
<p>We call it pxeAndroid and choose Linux as the type of virtual machine. We can just follow the wizard to create this virtual machine with a suitable configuration. After the virtual machine is created, we need to make a few changes to the settings.</p>
<p>The first thing that needs to be changed is the network configuration. We need to set the network adapter as a NAT network. We can click the name of the virtual machine, pxeAndroid, first and then click on the Settings button to change the settings. Select the Network option on the left-hand side, as we can see in the following screenshot:</p>
<div><img height="297" width="457" class=" image-border" src="img/image_09_004.png"/></div>
<p>We select Adapter 1, the default for the NAT network. We need to change the Adapter Type to Paravirtualized Network (virtio-net) since we will use the PXE ROM that we just built. The NAT network can connect to the outside network. It supports port forwarding so that we can access certain services in the virtual machine. The one that we need to set up here is the ADB service. We need to use ADB to debug the x86vbox device later. We can set up the port forwarding for ADB as follows:</p>
<div><img height="239" width="450" class=" image-border" src="img/image_09_005.png"/></div>
<p>Next, we can click on the System option to specify that the default boot order is to boot from the network interface, as shown in the following screenshot:</p>
<div><img height="340" width="522" class=" image-border" src="img/image_09_006.png"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Using VirtualBox internal PXE booting with NAT</h1>
            

            
                
<p>Once we set up the virtual machine, we can use the built-in PXE server of VirtualBox for PXE boot using the NAT network. To use the built-in PXE server, we need to set it up using the following steps:</p>
<ol>
<li>Create a <kbd>$HOME/.VirtualBox/TFTP</kbd> folder. The built-in <kbd>TFTP</kbd> root is at <kbd>$HOME/.VirtualBox/TFTP</kbd> on Linux or <kbd>%USERPROFILE%\.VirtualBox\TFTP</kbd> on Windows.</li>
<li>Usually, the default boot image name is <kbd>pxelinux.0</kbd> for PXE boot, but it is <kbd>vmname.pxe</kbd> for the VirtualBox built-in PXE. For example, if we use <kbd>pxeAndroid</kbd> as the virtual machine name, we have to make a copy of <kbd>pxelinux.0</kbd> and name it <kbd>pxeAndroid.pxe</kbd> under the <kbd>TFTP</kbd> root folder.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Configuring pxelinux.cfg</h1>
            

            
                
<p>Before we can test the virtual machine that we just set up, we need to specify it in the configuration file to let the PXE boot know where to find the kernel and ramdisk images.</p>
<p>The PXE boot process is something like this:</p>
<ol>
<li>When the pxeAndroid virtual machine powers on, the client will get the IP address through DHCP.</li>
<li>After the DHCP configuration is found, the configuration includes the standard information such as IP address, subnet mask, gateway and DNS, and so on. In addition, it also provides the location of the TFTP server and the filename of a boot image. The name of the boot image is usually <kbd>pxelinux.0</kbd>. The name of the boot image is <kbd>vmname.pxe</kbd> for the built-in PXE boot environment where the <kbd>vmname</kbd> should be the name of virtual machine. For example, it is <kbd>pxeAndroid.pxe</kbd> for our virtual machine.</li>
<li>The client contacts the TFTP server to obtain the boot image. The boot image should be put under <kbd>TFTP</kbd> root, which is <kbd>$HOME/.VirtualBox/TFTP</kbd> in our case.</li>
<li>The TFTP server sends the boot image (<kbd>pxelinux.0</kbd> or <kbd>vmname.pxe</kbd>), and the client executes it.</li>
<li>By default, the boot image searches the <kbd>pxelinux.cfg</kbd> directory on the TFTP server for boot configuration files.</li>
<li>The client downloads all the files it needs (kernel, ramdisk, root filesystem, and so on) and then loads them.</li>
<li>The <kbd>pxeAndroid</kbd> target machine reboots.</li>
</ol>
<p>In step 5, the boot image searches the boot configuration files in the following steps:</p>
<ol>
<li>First, it searches for the boot configuration file that is named according to the MAC address represented in lower case hexadecimal digits with dash separators. For example, for the MAC address 08:00:27:90:99:7B, it searches for the file <kbd>08-00-27-90-99-7b</kbd>.</li>
<li>Then, it searches for the configuration file using the IP address (of the machine that is being booted) in upper-case hexadecimal digits. For example, for the IP address 192.168.56.100, it searches for the <kbd>C0A83864</kbd> file.</li>
<li>If that file is not found, it removes one hexadecimal digit from the end and tries again. However, if the search is still not successful, it finally looks for a file named <kbd>default</kbd> (in lower case).</li>
</ol>
<p>For example, if the boot filename is <kbd>$HOME/.VirtualBox/TFTP/pxeAndroid.pxe</kbd>, the Ethernet MAC address is 08:00:27:90:99:7B, and the IP address is 192.168.56.100, the boot image looks for filenames in the following order:</p>
<pre>
<strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/08-00-27-90-99-7b</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C0A83864</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C0A8386</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C0A838</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C0A83</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C0A8</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C0A</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C0</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/C</strong><br/><strong>$HOME/.VirtualBox/TFTP/pxelinux.cfg/default</strong>  
</pre>
<p>The <kbd>pxelinux.0</kbd> boot image is part of an open source project the Syslinux. We can get the boot image and the menu user interface from the Syslinux project using the following command:</p>
<pre>
<strong>$ sudo apt-get install syslinux</strong>  
</pre>
<p>After Syslinux is installed, <kbd>pxelinux.0</kbd> can be copied to the <kbd>TFTP</kbd> root folder as follows:</p>
<pre>
<strong>$ cp /usr/lib/syslinux/pxelinux.0 $HOME/.VirtualBox/TFTP/pxelinux.0</strong>  
</pre>
<p>To have a better user interface, we can copy <kbd>menu.c32</kbd> to the <kbd>TFTP</kbd> folder as well:</p>
<pre>
<strong>$ cp /usr/lib/syslinux/menu.c32 $HOME/.VirtualBox/TFTP/menu.c32</strong>  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">pxelinux.cfg/default</h1>
            

            
                
<p>Now, we will look at how to configure the boot configuration file <kbd>$HOME/.VirtualBox/TFTP/pxelinux.cfg/default</kbd>. In our setup, it looks like the following code snippet:</p>
<pre>
prompt 1 <br/>default menu.c32 <br/>timeout 100 <br/><br/>label 1. NFS Installation (serial port) - x86vbox <br/>menu x86vbox_install_serial <br/>kernel x86vbox/kernel <br/>append ip=dhcp console=ttyS3,115200 initrd=x86vbox/initrd.img root=/dev/nfs rw androidboot.hardware=x86vbox INSTALL=1 DEBUG=2 SRC=/x86vbox ROOT=10.0.2.2:/home/sgye/vol1/android-x86vbox/out/target/product qemu=1 qemu.gles=0 <br/><br/>label 2. x86vbox (ROOT=/dev/sda1, serial port) <br/>menu x86vbox_sda1 <br/>kernel x86vbox/kernel <br/>append ip=dhcp console=ttyS3,115200 initrd=x86vbox/initrd.img androidboot.hardware=x86vbox DEBUG=2 SRC=/android-x86vbox ROOT=/dev/sda1 <br/>... 
</pre>
<p>The preceding file can be download from <a href="https://github.com/shugaoye/asp-sample/blob/master/ch09/pxelinux.cfg/default">https://github.com/shugaoye/asp-sample/blob/master/ch09/pxelinux.cfg/default</a>.</p>
<p>You can copy it from the above mentioned GitHub URL and you need to change the NFS shared folder to your own <kbd>ROOT=10.0.2.2:/{your NFS shared folder}</kbd>.</p>
<p>The syntax in the boot configuration file can be found at the following URL from the Syslinux project:</p>
<p><a href="http://www.syslinux.org/wiki/index.php?title=SYSLINUX">http://www.syslinux.org/wiki/index.php?title=SYSLINUX</a></p>
<p>In the preceding configuration file that we use in this chapter, we can see the following commands and options:</p>
<ul>
<li><kbd>prompt</kbd>: It will let the bootloader know if it will show a LILO-style <em>boot:</em> prompt. With this command-line prompt, you can input the option directly. All the boot options are defined by the command <kbd>label</kbd>.</li>
<li><kbd>default</kbd>: It defines the default boot option.</li>
<li><kbd>timeout</kbd>: If more than one <kbd>label</kbd> entry is available, this directive indicates how long to pause at the boot: prompt until booting automatically, in units of 1/10 s. The timeout is cancelled when any key is pressed, the assumption being that the user will complete the command line. A timeout of zero will disable the timeout completely. The default is 0.</li>
<li><kbd>label</kbd>: A human-readable string that describes a kernel and options. The default label is <kbd>linux</kbd>, but you can change this with the <kbd>DEFAULT</kbd> keyword.</li>
<li><kbd>kernel</kbd>: The kernel file that the boot image will boot.</li>
<li><kbd>append</kbd>: The kernel command line that can be passed to the kernel during the boot.</li>
</ul>
<p>In the preceding configuration file, we show two boot options. In the first option, we can boot to a minimum Linux environment using the NFS root filesystem. We can install the x86vbox images from that environment to the hard disk. In the second option, we can boot x86vbox from the <kbd>/dev/sda1</kbd> disk partition. We will explore these options in detail later.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Setting up a serial port for debugging</h1>
            

            
                
<p>The reason why we want to boot Android using PXE and NFS is because we want to use a very simple bootloader and find an easier way to debug the system. In order to see the debug log, we want to redirect the debug output from the video console to a serial port so that we can separate the graphic user interface from the debug output. We need to do two things in order to meet our goals.</p>
<p>The Linux kernel debug message can be redirected to a specific channel using kernel command-line arguments. We specify this in PXE boot configuration with the <kbd>console=ttyS3,115200</kbd> option. This is defined in <kbd>pxelinux.cfg/default</kbd> as follows:</p>
<pre>
label 1. NFS Installation (serial port) - x86vbox <br/>menu x86vbox_install_serial <br/>kernel x86vbox/kernel <br/>append ip=dhcp console=ttyS3,115200 initrd=x86vbox/initrd.img root=/dev/nfs rw androidboot.hardware=x86vbox INSTALL=1 DEBUG=2 SRC=/x86vbox ROOT=10.0.2.2:/home/sgye/vol1/android-x86vbox/out/target/product qemu=1 qemu.gles=0 
</pre>
<p>We will explain the details about kernel parameters in the <kbd>append</kbd> option later in this chapter. The next thing is that we need to create a virtual serial port that we can connect to. We configure this in the virtual machine settings page, as shown in the following screenshot:</p>
<div><img height="287" width="441" class=" image-border" src="img/image_09_007.png"/></div>
<p>We use a host pipe to simulate the virtual serial port. We can set the path as something like <kbd>/tmp/pxeAndroid_p</kbd>.</p>
<p>The mapping between <kbd>COMx</kbd> to <kbd>/dev/ttySx</kbd> is as follows:</p>
<pre>
/dev/ttyS0 - COM1 <br/>/dev/ttyS1 - COM2 <br/>/dev/ttyS2 - COM3 <br/>/dev/ttyS3 - COM4 
</pre>
<p>To connect to the host pipe, we can use a tool such as <kbd>minicom</kbd>. If you don't have <kbd>minicom</kbd> installed, you can install and configure <kbd>minicom</kbd> as follows:</p>
<pre>
<strong>$ sudo apt-get install minicom</strong>  
</pre>
<p>To set up <kbd>minicom</kbd>, we can use the following command:</p>
<pre>
<strong>$ sudo minicom -s</strong>  
</pre>
<p>After <kbd>minicom</kbd> starts, select Serial port setup, and set Serial Device as unix#/tmp/pxeAndroid_p. Once this is done, select Save setup as dfl and Exit from Minicom as shown in the following screenshot. Now we can connect to the virtual serial port using <kbd>minicom</kbd>.</p>
<div><img height="309" width="468" class=" image-border" src="img/image_09_008.png"/></div>
<p>After we have made all the changes for the x86vbox configuration, we can power on the virtual machine and test it. We should be able to see the following boot up screen:</p>
<div><img height="394" width="603" class=" image-border" src="img/image_09_009.png"/></div>
<p>We can see from the preceding screenshot that the virtual machine loads the <kbd>pxelinux.cfg/default</kbd> file and waits on the boot prompt. We are ready to boot from PXE ROM now.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">NFS filesystem</h1>
            

            
                
<p>We created the x86vbox device in <a href="acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml">Chapter 8</a>, <em>Creating Your Own Device on VirtualBox</em>, and we were able to build it. However, we did not discuss how to boot images. The issue here is the output from the build is the standard AOSP images. They are not able to be used by VirtualBox directly. For example, <kbd>system.img</kbd> can be used by the emulator, but not VirtualBox. VirtualBox can use standard virtual disk images in VDI, VHD, or VMDK formats, but not a raw disk image such as <kbd>system.img</kbd>.</p>
<p>In the Android-x86 build, the output is an installation image, such as ISO or USB disk image formats. With an installation image, it can be burnt to a CDROM and USB drive. Then, we can boot VirtualBox from CDROM or USB to install the system just as we install Windows on our PC. It is quite tedious and not efficient to use this method when we are debugging a system. As a developer, we want a simple and quick way so that we can start the debugging immediately after we build the system.</p>
<p>The method that we will use here is to boot the system using the NFS filesystem. The key point is that we will treat the output folder of the AOSP build as the root filesystem directly so that we can boot the system using it without any additional work.</p>
<p>If you are an embedded system developer, you may have used this method in your work already. When we work on the initial debugging phase of an embedded Linux system, we often use the NFS filesystem as the root filesystem. With this method, we can avoid flashing the images to the flash storage every time after the build.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Preparing the kernel</h1>
            

            
                
<p>To support NFS boot, we need a Linux kernel with NFS filesystem support. The default Linux kernel for Android doesn't have NFS boot support. In order to boot Android and mount the NFS directory as the root filesystem, we have to recompile the Linux kernel with the following options enabled:</p>
<pre>
CONFIG_IP_PNP=y <br/>CONFIG_IP_PNP_DHCP=y <br/>CONFIG_IP_PNP_BOOTP=y <br/>CONFIG_IP_PNP_RARP=y <br/>CONFIG_USB_USBNET=y <br/>CONFIG_USB_NET_SMSC95XX=y <br/>CONFIG_USB=y <br/>CONFIG_USB_SUPPORT=y <br/>CONFIG_USB_ARCH_HAS_EHCI=y <br/>CONFIG_NETWORK_FILESYSTEMS=y <br/>CONFIG_NFS_FS=y <br/>CONFIG_NFS_V3=y <br/>CONFIG_NFS_V3_ACL=y <br/>CONFIG_ROOT_NFS=y 
</pre>
<p>We can use <kbd>menuconfig</kbd> to change the kernel configuration or copy a configuration file with NFS support.</p>
<p>To configure the kernel build using <kbd>menuconfig</kbd>, we can use the following commands:</p>
<pre>
<strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86vbox-eng</strong><br/><strong>$ make -C kernel O=$OUT/obj/kernel ARCH=x86 menuconfig</strong>
</pre>
<p>We can also use the configuration file with NFS enabled in my GitHub. We can observe the difference between this configuration file and the default kernel configuration file from Android-x86 as follows:</p>
<pre>
<strong>$ diff kernel/arch/x86/configs/android-x86_defconfig ~/src/android-x86_nfs_defconfig</strong><br/><strong>216a217</strong><br/><strong>&gt; # CONFIG_SYSTEM_TRUSTED_KEYRING is not set</strong><br/><strong>1083a1085</strong><br/><strong>&gt; CONFIG_DNS_RESOLVER=y</strong><br/><strong>1836c1838</strong><br/><strong>&lt; CONFIG_VIRTIO_NET=m</strong><br/><strong>---</strong><br/><strong>&gt; CONFIG_VIRTIO_NET=y</strong><br/><strong>1959c1961</strong><br/><strong>&lt; CONFIG_E1000=m</strong><br/><strong>---</strong><br/><strong>&gt; CONFIG_E1000=y</strong><br/><strong>5816a5819</strong><br/><strong>&gt; # CONFIG_ECRYPT_FS is not set</strong><br/><strong>5854,5856c5857,5859</strong><br/><strong>&lt; CONFIG_NFS_FS=m</strong><br/><strong>&lt; CONFIG_NFS_V2=m</strong><br/><strong>&lt; CONFIG_NFS_V3=m</strong><br/><strong>---</strong><br/><strong>&gt; CONFIG_NFS_FS=y</strong><br/><strong>&gt; CONFIG_NFS_V2=y</strong><br/><strong>&gt; CONFIG_NFS_V3=y</strong><br/><strong>5858c5861</strong><br/><strong>&lt; # CONFIG_NFS_V4 is not set</strong><br/><strong>---</strong><br/><strong>&gt; CONFIG_NFS_V4=y</strong><br/><strong>5859a5863,5872</strong><br/><strong>&gt; CONFIG_NFS_V4_1=y</strong><br/><strong>&gt; CONFIG_NFS_V4_2=y</strong><br/><strong>&gt; CONFIG_PNFS_FILE_LAYOUT=y</strong><br/><strong>&gt; CONFIG_PNFS_BLOCK=y</strong><br/><strong>&gt; CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"</strong><br/><strong>&gt; # CONFIG_NFS_V4_1_MIGRATION is not set</strong><br/><strong>&gt; CONFIG_NFS_V4_SECURITY_LABEL=y</strong><br/><strong>&gt; CONFIG_ROOT_NFS=y</strong><br/><strong>&gt; # CONFIG_NFS_USE_LEGACY_DNS is not set</strong><br/><strong>&gt; CONFIG_NFS_USE_KERNEL_DNS=y</strong><br/><strong>5861,5862c5874,5875</strong><br/><strong>&lt; CONFIG_GRACE_PERIOD=m</strong><br/><strong>&lt; CONFIG_LOCKD=m</strong><br/><strong>---</strong><br/><strong>&gt; CONFIG_GRACE_PERIOD=y</strong><br/><strong>&gt; CONFIG_LOCKD=y</strong><br/><strong>5865c5878,5880</strong><br/><strong>&lt; CONFIG_SUNRPC=m</strong><br/><strong>---</strong><br/><strong>&gt; CONFIG_SUNRPC=y</strong><br/><strong>&gt; CONFIG_SUNRPC_GSS=y</strong><br/><strong>&gt; CONFIG_SUNRPC_BACKCHANNEL=y</strong><br/><strong>5870a5886</strong><br/><strong>&gt; # CONFIG_CIFS_UPCALL is not set</strong><br/><strong>5873a5890</strong><br/><strong>&gt; # CONFIG_CIFS_DFS_UPCALL is not set</strong><br/><strong>6132c6149,6153</strong><br/><strong>&lt; # CONFIG_KEYS is not set</strong><br/><strong>---</strong><br/><strong>&gt; CONFIG_KEYS=y</strong><br/><strong>&gt; # CONFIG_PERSISTENT_KEYRINGS is not set</strong><br/><strong>&gt; # CONFIG_BIG_KEYS is not set</strong><br/><strong>&gt; # CONFIG_ENCRYPTED_KEYS is not set</strong><br/><strong>&gt; # CONFIG_KEYS_DEBUG_PROC_KEYS is not set</strong><br/><strong>6142a6164</strong><br/><strong>&gt; # CONFIG_INTEGRITY_SIGNATURE is not set</strong><br/><strong>6270a6293</strong><br/><strong>&gt; # CONFIG_ASYMMETRIC_KEY_TYPE is not set</strong><br/><strong>6339a6363</strong><br/><strong>&gt; CONFIG_ASSOCIATIVE_ARRAY=y</strong><br/><strong>6352a6377</strong><br/><strong>&gt; CONFIG_OID_REGISTRY=y</strong>  
</pre>
<p>We can copy this configuration file and use it to build the Linux kernel. The following commands just show how to build the kernel separately. You don't have to do this if you build x86vbox by checking out the source code of this chapter. This is included in the x86vbox device Makefiles:</p>
<pre>
<strong>$ repo init https://github.com/shugaoye/manifests -b android-7.1.1_r4_x86vbox_ch08_r1</strong><br/><strong>$ repo sync</strong><br/><strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86vbox-eng</strong><br/><strong>$ make -C kernel O=$OUT/obj/kernel ARCH=x86</strong>  
</pre>
<p>After the build, we can copy the kernel and ramdisk files to the <kbd>TFTP</kbd> root at <kbd>$HOME/.VirtualBox/TFTP/x86vbox</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Setting up the NFS server</h1>
            

            
                
<p>When we have a NFS-capable kernel, we need to set up the NFS server on our development host so that we can mount to the NFS folders exported by our NFS server. We can check whether the NFS server is already installed or not using the following command:</p>
<pre>
<strong>$ dpkg -l | grep nfs</strong>  
</pre>
<p>If the NFS server is not installed, we can install it using the following command:</p>
<pre>
<strong>$ sudo apt-get install nfs-kernel-server</strong>  
</pre>
<p>Once we have a NFS server ready, we need to export our root filesystem through NFS. We will use the AOSP build output folder as we mentioned previously. We can add the following line to the <kbd>/etc/exports</kbd> configuration file:</p>
<pre>
$AOSP/out/target/product/ *(rw,sync,insecure,no_subtree_check,async) 
</pre>
<p>After that, we execute the following command to export the <kbd>$AOSP/out/target/product</kbd> folder. You need to replace <kbd>$AOSP</kbd> with the absolute path in your setup:</p>
<pre>
<strong>$ sudo exportfs -a</strong>  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Configuring the PXE boot menu</h1>
            

            
                
<p>When we have a real bootloader such as PXE Boot ROM, we have a way to support the boot path like a real Android device. As we know, Android devices can boot to three different modes--bootloader mode, recovery mode, and the normal start-up.</p>
<p>With PXE Boot ROM, we can easily support the same and more. By configuring the <kbd>pxelinux.cfg/default</kbd> file, we can allow x86vbox to boot in different paths. We will configure multiple boot paths here.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Booting to NFS installation</h1>
            

            
                
<p>Since we cannot use AOSP image files to boot x86vbox directly, we need to install AOSP images to the VirtualBox hard disk. This is very similar to Android-x86. In Android-x86, we need to use a CDROM or USB stick to install the system so that we can boot Android after the installation. Instead of using a CDROM or USB image for the installation, we can install the system from the NFS path directly. If we set the NFS path to the <kbd>$AOSP/out/target/product</kbd> path, we can install the system right after the completion of the build.</p>
<p>We can boot the system to an installation mode so that we can use the Android-x86 installation script that we discussed to install x86vbox images to the virtual hard disk:</p>
<pre>
label 1. NFS Installation (serial port) - x86vbox <br/>menu x86vbox_install_serial <br/>kernel x86vbox/kernel <br/>append ip=dhcp console=ttyS3,115200 initrd=x86vbox/initrd.img root=/dev/nfs rw androidboot.hardware=x86vbox INSTALL=1 DEBUG=2 SRC=/x86vbox ROOT=10.0.2.2:$AOSP/out/target/product 
</pre>
<p>In the preceding configuration, we use the NFS-capable kernel from the <kbd>TFTP</kbd> folder such as <kbd>$HOME/.VirtualBox/TFTP/x86vbox/kernel</kbd>. The <kbd>initrd.img</kbd> ramdisk image is also stored in the same folder. Both files under the <kbd>TFTP</kbd> folder can actually be symbolic links to the AOSP output. In this case, we don't have to copy them after the build, as we can see from the following screenshot:</p>
<div><img height="260" width="588" class=" image-border" src="img/image_09_010.png"/></div>
<p>We use the following three options to configure the NFS boot:</p>
<ul>
<li><kbd>ip=dhcp</kbd>: Use DHCP to get the IP address from the DHCP server. The DHCP server can be the built-in DHCP server of VirtualBox or an external DHCP server.</li>
<li><kbd>root=/dev/nfs</kbd>: Use the NFS boot.</li>
<li><kbd>ROOT=10.0.2.2:$AOSP/out/target/product</kbd>: The root is the AOSP output folder in the development host. If we use the built-in PXE, the IP address <kbd>10.0.2.2</kbd> is the default host IP address in the NAT network. It could be changed using the VirtualBox configuration. In your configuration, you need to replace <kbd>$AOSP</kbd> with an absolute path.</li>
</ul>
<p>We want to monitor the debug output so we set the console to the virtual serial port that we configured previously as <kbd>console=ttyS3,115200</kbd>. We can use a host pipe to connect to it using <kbd>minicom</kbd>.</p>
<p>We set three kernel parameters by using the Android-x86 init script and installation script:</p>
<ul>
<li><kbd>INSTALL=1</kbd>: Tells the init script that we want to install the system</li>
<li><kbd>DEBUG=2</kbd>: This will bring us to the debug console during the boot process</li>
<li><kbd>SRC=/x86vbox</kbd> : This is the directory for the root filesystem</li>
</ul>
<p>Finally, the <kbd>androidboot.hardware=x86vbox</kbd> option is passed to the Android init process to tell it which init script to run. In this case, the device init script <kbd>init.x86vbox.rc</kbd> will be executed as we discussed in the previous chapter.</p>
<p>In our PXE boot menu, we can add another configuration for the installation without the <kbd>console=ttyS3,115200</kbd> option. In this case, all debug output will print on the screen, which is the default standard output.</p>
<p>To find out what is installed on the harddisk, you can refer to <a href="b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml">Chapter 6</a>, <em>Debugging the Boot Up Process Using a Customized ramdisk</em>. The filesystem layout on the hard disk is similar to the directory layout for <kbd>x86emu_x86.img</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Booting from a hard disk</h1>
            

            
                
<p>We can have another option, as follows,to boot the system from the hard disk after we install the system using the previous configuration:</p>
<pre>
label 2. x86vbox (ROOT=/dev/sda1, serial port) <br/>menu x86vbox_sda1_S3 <br/>kernel x86vbox/kernel <br/>append ip=dhcp console=ttyS3,115200 initrd=x86vbox/initrd.img androidboot.hardware=x86vbox DEBUG=2 SRC=/android-x86vbox ROOT=/dev/sda1 
</pre>
<p>In the preceding configuration, we use the <kbd>/dev/sda1</kbd> device as the root and we don't have the <kbd>INSTALL=1</kbd> option. With this configuration, the virtual machine will boot to the Android system from the hard disk <kbd>/dev/sda1</kbd> and the debug output will print to the virtual serial port.</p>
<p>We can use another similar configuration that prints the debug output to the screen.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Booting to recovery</h1>
            

            
                
<p>With the PXE boot menu, we can configure the system to boot to recovery as well. We can use the following configuration:</p>
<pre>
label 5. x86vbox recovery (ROOT=/dev/sda2) <br/>menu x86vbox_recovery <br/>kernel x86vbox/kernel <br/>append ip=dhcp console=ttyS3,115200 initrd=x86vbox/ramdisk-recovery.img androidboot.hardware=x86vbox DEBUG=2 SRC=/android-x86vbox ROOT=/dev/sda2 
</pre>
<p>We will use a configuration similar to this in <a href="5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml">Chapter 12</a>, <em>Introducing Recovery</em> to <a href="15628e05-2216-4855-8347-588f61c8f61a.xhtml">Chapter 14</a>, <em>Customizing and Debugging Recovery</em>, when we explore recovery programming. The difference here is that we use a recovery ramdisk instead of <kbd>initrd.img</kbd>. Since recovery is a self-contained environment, we can set the <kbd>ROOT</kbd> variable to other partitions as well.</p>
<p>Be aware that the <kbd>x86vbox recovery</kbd> configuration cannot be tested in this chapter. We will test this in <a href="5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml">Chapter 12</a>, <em>Introducing Recovery</em> to <a href="15628e05-2216-4855-8347-588f61c8f61a.xhtml">Chapter 14</a>, <em>Customizing and Debugging Recovery</em>.</p>
<p>With all the preceding setup, we can boot to the PXE boot menu, as shown in the following screenshot:</p>
<div><img height="387" width="591" class=" image-border" src="img/image_09_011.png"/></div>
<p>We can select the first option from the preceding PXE boot menu to boot to a debug console as follows:</p>
<div><img height="369" width="555" class=" image-border" src="img/image_09_012.png"/></div>
<p>From the preceding debug output, we can see that the virtual machine obtains the IP address <kbd>10.0.2.15</kbd> from DHCP server <kbd>10.0.2.2</kbd>. The NFS root is found at IP address <kbd>10.0.2.2</kbd>, which is the development host. In the default VirtualBox NAT network setup, the IP address of the DHCP server or the host is <kbd>10.0.2.2</kbd>. The IP address of the built-in TFTP server is <kbd>10.0.2.4</kbd>. The DNS server IP address is <kbd>10.0.2.3</kbd>.</p>
<p>It is possible to boot the Android system from the <kbd>$OUT/system</kbd> directory using the NFS filesystem. However, we need to make changes to <kbd>netd</kbd> to disable flushing the routing rules. The changes can be done in the following file in the <kbd>flushRules</kbd> function:<br/>
<kbd>$AOSP/system/netd/server/RouteController.cpp</kbd><br/>
Without this change, the network connection will be reset after the routing rules are flushed. However, we can still use NFS boot to perform the first stage-boot or install the system to hard disk.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we learnt a debugging method using a combination of PXE boot and the NFS root filesystem. This is a common practice in the embedded Linux development world. We try to use a similar setup for Android system development. As we can see, this setup can make the development and debugging process more efficient. We can use this setup to remove the bootloader dependency. We can also reduce the time to flash or provision build images to the device.</p>
<p>I wrote an article to discuss a more advanced case about the PXE/NFS setup using an external DHCP/TFTP server running in the host-only network environment. If you are interested in this topic, you can read it at the following URL:<br/>
<a href="https://www.packtpub.com/books/content/booting-android-system-using-pxenfs">https://www.packtpub.com/books/content/booting-android-system-using-pxenfs</a></p>
<p>In the next chapter, we will continue our journey on the boot up process of x86vbox. We will explore and learn how to enable the graphic system on VirtualBox so that we can bring up the Android system eventually for the x86vbox device.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>