<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Alternative Testing Tactics</h1></div></div></div><p>Up to this point we have analyzed the most common and accessible tactics to implement testing in our projects. However, there are a few missing pieces in our puzzle and with the current versions of the Android SDK (<em>Android 2.3 Gingerbread</em> as of this writing) these features are not yet implemented. Nevertheless, not everything is lost. One of the biggest and strongest benefits of Android is its Open Source nature and the features we are going to exploit here precisely depend on it because we will be using the complete source code to introduce some changes required by what we plan to provide.</p><p>Building Android from source code is not for the faint hearted. It is extremely time consuming mainly at the beginning while you are familiarizing yourself with the whole Android environment, and it also requires a lot of disk space and horsepower. To illustrate this assertion, one simple build for one target takes almost 10GB of disk space and almost an hour to build on a 4 core machine. I'm not trying to scare you but warn you and at the same time ask for a little endurance.</p><p>They say that great sacrifices come with great rewards and this seems to be another case that follows this rule.</p><p>In this chapter we will be covering:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building Android from source</li><li class="listitem" style="list-style-type: disc">Code coverage using EMMA</li><li class="listitem" style="list-style-type: disc">Adding code coverage to our Temperature Converter project</li><li class="listitem" style="list-style-type: disc">Introducing Robotium</li><li class="listitem" style="list-style-type: disc">Testing on host's JVM</li><li class="listitem" style="list-style-type: disc">Introducing Robolectric</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec01"/>Building Android from source</h1></div></div></div><p>Perhaps Android's<em> Achilles' heel</em> would be the lack of documentation and the number of places you have to visit to get the complete version of what you are trying to find, or what's even worse in many cases the official documentation is incorrect or has not been updated to match the current release. One example of this is the documentation (available at<a class="ulink" href="http://source.android.com/source/download.html"> http://source.android.com/source/download.html</a> at the time of this writing) of the requirements to build Android from source that still states that Java 6 is not supported and Ubuntu 8.10 (intrepid) 32bit can be used, which is totally wrong. Funnily enough, Java 6 and at least Ubuntu 10.04 (lucid) 64bit are required. Starting with Android 2.3 (Gingerbread), building on 32bit machines is no longer supported. But that's enough for a rant, I will leave them for my personal blog, otherwise if the documentation were complete, books like this one would not be needed and I could be writing one about Windows Phone 7...<a class="indexterm" id="id476"/>
</p><p>Just kidding, I don't think this could happen in the near future.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec01"/>Code coverage</h2></div></div></div><p>One of our objectives in building Android from source is enabling code coverage via EMMA (<a class="ulink" href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>).<a class="indexterm" id="id477"/>
</p><p>Code coverage is a measure used in software testing that describes the amount of source code that was actually tested by the tests suite and to what degree following some criteria. As code coverage inspects the code directly it is therefore a form of white box testing.<a class="indexterm" id="id478"/>
</p><p>From the several tools available providing code coverage analysis for Java we are using EMMA, an open-source toolkit for measuring and reporting Java code coverage that is supported by the Android project, and the infrastructure to start using it for your own projects is already there, therefore minimizing the effort needed to implement it. EMMA came to fill an existing gap in the vast Open Source ecosystem where no coverage tools existed with compatible licenses. EMMA is based on IBM's Common Public License v1.0 and is thus free for both Open Source and commercial development.</p><p>EMMA distinguishes itself from other tools by going after a unique feature combination: support for large-scale enterprise software development while keeping individual developer's work fast and iterative. This is fundamental in a project the size of Android and EMMA shines at its best providing code coverage for it.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec01"/>EMMA features</h3></div></div></div><p>Android 2.3 includes EMMA v2.0, build 5312. The most distinctive set of features, paraphrasing its documentation, which can be found at its website are the following:<a class="indexterm" id="id479"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">EMMA can instrument classes for coverage either offline (before they are loaded) or on the fly (using an instrumenting application classloader).</li><li class="listitem" style="list-style-type: disc">Supported coverage types: Class, method, line, basic block. EMMA can detect when a single source code line is covered only partially.</li><li class="listitem" style="list-style-type: disc">Coverage stats are aggregated at method, class, package, and "all classes" levels.</li><li class="listitem" style="list-style-type: disc">Output report types: Plain text, HTML, XML. All report types support drill-down, to a user-controlled detail depth. The HTML report supports source code linking.</li><li class="listitem" style="list-style-type: disc">Output reports can highlight items with coverage levels below user-provided thresholds.</li><li class="listitem" style="list-style-type: disc">Coverage data obtained in different instrumentation or test runs can be merged together.</li><li class="listitem" style="list-style-type: disc">EMMA does not require access to the source code and degrades gracefully with decreasing amounts of debug information available in the input classes.</li><li class="listitem" style="list-style-type: disc">EMMA can instrument individual<code class="literal"> .class</code> files or entire<code class="literal"> .jar files</code> (in place, if desired). Efficient coverage subset filtering is possible, too.</li><li class="listitem" style="list-style-type: disc">Makefile and ANT build integration are supported on an equal footing.</li><li class="listitem" style="list-style-type: disc">EMMA is quite fast: The runtime overhead of added instrumentation is small (5 to 20%) and the bytecode instrumentor itself is very fast (mostly limited by file I/O speed). Memory overhead is a few hundred bytes per Java class.</li><li class="listitem" style="list-style-type: disc">EMMA is 100% pure Java, has no external library dependencies, and works in any Java 2 JVM (even 1.2.x).</li></ul></div><p>Some minor changes were introduced by Android to the EMMA project to fully adapt it and support code coverage:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Change<code class="literal"> coverage.out.file</code> location in<code class="literal"> core/res/emma_default.properties</code> to<code class="literal"> /data/coverage.ec</code></li><li class="listitem" style="list-style-type: disc">Remove reference to<code class="literal"> sun.misc.*</code> in<code class="literal"> core/java14/com/vladium/util/IJREVersion.java</code></li><li class="listitem" style="list-style-type: disc">Remove reference to<code class="literal"> sun.misc.*</code> and<code class="literal"> SunJREExitHookManager</code> class from<code class="literal"> core/java13/com/vladium/util/exit/ExitHookManager.java</code></li><li class="listitem" style="list-style-type: disc">Add<code class="literal"> java.security.cert.Certificate</code> cast to<code class="literal"> core/java12/com/vladium/emma/rt/InstrClassLoader.java</code> to fix compiler error</li><li class="listitem" style="list-style-type: disc">Move<code class="literal"> out/core/res/com/vladium/emma/rt/RTExitHook.closure</code> (from Emma Ant build) into<code class="literal"> pregenerated/</code> so it does not have to be generated in Android's make-based build, but also doesn't break Emma's build</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec02"/>System requirements</h2></div></div></div><p>The Android build for gingerbread requires a 64-bit build environment as well as some other tools:<a class="indexterm" id="id480"/>
</p><p>Required packages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Git, JDK, flex, and the other development packages</li><li class="listitem" style="list-style-type: disc">Java 6</li><li class="listitem" style="list-style-type: disc">Pieces from the 32-bit cross-building environment</li><li class="listitem" style="list-style-type: disc">X11 development</li></ul></div><p>The instructions if you are running the recommended Ubuntu 10.04 LTS 64bit are as follows:</p><div><pre class="programlisting"><strong>$ sudo apt-get install git-core gnupg flex bison gperf libsdl-dev \
libesd0-dev libwxgtk2.6-dev build-essential zip curl libncurses5-dev \
zlib1g-dev $ sudo apt-get install gcc-multilib g++-multilib libc6-dev-i386 \
lib32ncurses5-dev ia32-libs x11proto-core-dev libx11-dev \
lib32readline5-dev lib32z-dev</strong>
</pre></div><p>Set the system to use the right version of java by default:</p><div><pre class="programlisting"><strong>$ sudo update-java-alternatives -s java-6-sun</strong>
</pre></div><p>In any case, check the AOSP website (<a class="ulink" href="http://source.android.com/source/download.html">http://source.android.com/source/download.html</a>) for updated instructions.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec03"/>Downloading the Android source code</h2></div></div></div><p>The Android project is a large collection of relatively independent projects put under the Android umbrella. All of them use Git as the version control system. You can see what I mean by visiting the<strong> Gitweb</strong> interface for the Android project at<a class="ulink" href="http://android.git.kernel.org/"> http://android.git.kernel.org/</a>.<a class="indexterm" id="id481"/>
</p><p>As you can see, dozens of projects are listed and you need all to build the entire platform. To simplify the process of dealing with this great number of Git projects at the same time Google created<strong> repo</strong>, a tool that was built on top of Git to help manage the many Git repositories, uploads to the revision control system, and automate parts of the Android development work-flow.<a class="indexterm" id="id482"/>
</p><p>
<code class="literal">Repo</code> is a complementary tool that does not replace Git, but just makes it easier to work with Git in the context of Android. The<code class="literal"> repo</code> command is an Python executable wrapped into a shell script and can be put anywhere in your path.</p><p>Detailed information about Git and Repo in the scope of Android project can be obtained from their information page at<a class="ulink" href="http://source.android.com/source/git-repo.html"> http://source.android.com/source/git-repo.html</a>.<a class="indexterm" id="id483"/>
</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec02"/>Installing repo</h3></div></div></div><p>As we mentioned before,<code class="literal"> repo</code> is our key to the Android source code world, therefore the first measure is installing it.<a class="indexterm" id="id484"/>
</p><p>Follow these commands:</p><div><pre class="programlisting"><strong>$ curl http://android.git.kernel.org/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo</strong>
</pre></div><p>This creates the initial repo script, which will initialize the complete repository and will include the<code class="literal"> repo.git</code> project as well, so<code class="literal"> repo</code> is auto-maintained. Every time you synchronize with the repository, changes to<code class="literal"> repo</code> itself are propagated if necessary. That's a very clever use of the tool.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec03"/>Creating the working copy</h3></div></div></div><p>Our working copy of the repository can be created anywhere in our computer. Just remember that there should be at least 10GB of free space and sometimes much more is needed if you build for different targets.<a class="indexterm" id="id485"/>
</p><p>Let's say that we decide to create the working copy in<code class="literal"> ~/android/android-2.3</code>, then use the following commands:</p><div><pre class="programlisting"><strong>$ mkdir ~/android/android-2.3
$ cd ~/android/android-2.3
$ repo init -u git://android.git.kernel.org/platform/manifest.git</strong>
</pre></div><p>These three simple steps have created our working copy ready to be synchronized. Remember that is a very big download and depending on your network connection speed and the load on the servers it could take some time. So it is very smart to wait some days after a major release is pushed to the servers.</p><p>When you are ready to synchronize just invoke this command in your working copy:<a class="indexterm" id="id486"/>
</p><div><pre class="programlisting"><strong>$ repo sync</strong>
</pre></div><p>When you run<code class="literal"> repo sync</code>, this is what happens:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the project has never been synchronized, then<code class="literal"> repo sync</code> is equivalent to<code class="literal"> git clone</code>. All branches in the remote repository are copied to the local project directory.</li><li class="listitem" style="list-style-type: disc">If the project has already been synchronized once, then<code class="literal"> repo sync</code> is equivalent to:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">git remote update</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">git rebase origin/branch</code></li><li class="listitem" style="list-style-type: disc">Where branch is the currently checked-out branch in the local project directory. If the local branch is not tracking a branch in the remote repository, then no synchronization will occur for the project.</li></ul></div></li><li class="listitem" style="list-style-type: disc">If the<code class="literal"> git rebase</code> operation results in merge conflicts, you will need to use the normal Git commands (for example,<code class="literal"> git rebase --continue)</code> to resolve the conflicts.</li></ul></div><p>Once finished, the complete Android source code has been downloaded to your working copy. We haven't specified any specific branch so we just downloaded the latest Android Open Source Project (AOSP) main branch.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec04"/>The Building Steps</h3></div></div></div><p>We are ready to start our build supporting code coverage analysis.<a class="indexterm" id="id487"/>
</p><p>To achieve this we need to follow the steps to set the environment and chose your combo:</p><div><pre class="programlisting"><strong>~/android/android-2.3$ source build/envsetup.sh</strong>
</pre></div><p>
<strong>including device/htc/passion/vendorsetup.sh</strong>
</p><p>
<strong>including device/samsung/crespo/vendorsetup.sh</strong>
</p><div><pre class="programlisting">~/android/android-2.3$ lunch
</pre></div><p>
<strong>You're building on Linux</strong>
</p><p>
<strong>Lunch menu... pick a combo:</strong>
</p><p>
<strong>1. full-eng</strong>
</p><p>
<strong>2. full_x86-eng</strong>
</p><p>
<strong>3. simulator</strong>
</p><p>
<strong>4. full_passion-userdebug</strong>
</p><p>
<strong>5. full_crespo-userdebug</strong>
</p><p>
<strong>Which would you like? [full-eng]</strong>
</p><p>Select<strong> full-eng</strong> in this case.<a class="indexterm" id="id488"/>
</p><p>
<strong>============================================</strong>
</p><p>
<strong>PLATFORM_VERSION_CODENAME=AOSP</strong>
</p><p>
<strong>PLATFORM_VERSION=AOSP</strong>
</p><p>
<strong>TARGET_PRODUCT=full</strong>
</p><p>
<strong>TARGET_BUILD_VARIANT=eng</strong>
</p><p>
<strong>TARGET_SIMULATOR=false</strong>
</p><p>
<strong>TARGET_BUILD_TYPE=release</strong>
</p><p>
<strong>TARGET_BUILD_APPS=</strong>
</p><p>
<strong>TARGET_ARCH=arm</strong>
</p><p>
<strong>TARGET_ARCH_VARIANT=armv5te</strong>
</p><p>
<strong>HOST_ARCH=x86</strong>
</p><p>
<strong>HOST_OS=linux</strong>
</p><p>
<strong>HOST_BUILD_TYPE=release</strong>
</p><p>
<strong>BUILD_ID=OPENMASTER</strong>
</p><p>
<strong>============================================</strong>
</p><p>One more step is needed in this case. As we want to enable EMMA code coverage we need to set this in the environment:</p><div><pre class="programlisting"><strong>~/android/android-2.3$ export EMMA_INSTRUMENT=true</strong>
</pre></div><p>Get set, ready, go:</p><div><pre class="programlisting"><strong>~/android/android-2.3$ make -j4</strong>
</pre></div><div><h3 class="title"><a id="note26"/>Note</h3><p>The<code class="literal"> -j</code> or<code class="literal"> -jobs</code> option to make lets you specify the number of jobs (commands) to run simultaneously. This is very useful to speed up lengthy build processes in multiprocessor or multicore machines. If no argument is given to the<code class="literal"> -j</code> option, then<code class="literal"> make</code> will not limit the number of jobs that can run simultaneously.</p></div><p>After a while and tons of messages, your build will be available. If everything went well you will be seeing a message similar to this one at the end:<a class="indexterm" id="id489"/>
</p><p>
<strong>Target system fs image: out/target/product/generic/obj/PACKAGING/systemimage_intermediates/system.img</strong>
</p><p>
<strong>Install system fs image: out/target/product/generic/system.img</strong>
</p><p>
<strong>Installed file list: out/target/product/generic/installed-files.txt</strong>
</p><p>This is because the last steps are to create the system image and the list of installed files.</p><p>If the build fails then try some of the suggestions mentioned below in order to fix it or find out more at the AOSP site (<a class="ulink" href="http://source.android.com/source/building.html">http://source.android.com/source/building.html</a>). If there are some problems and things are not so smooth, here is a list of tips you can follow to revert the situation.</p><div><h3 class="title"><a id="tip08"/>Tip</h3><p><strong>Tips to revert from a broken build</strong></p><p>Clean, using<code class="literal"> make clean</code>, and make again.</p><p>Reducing the number of jobs (make<code class="literal"> -j</code> or<code class="literal"> make jobs)</code> usually helps too.</p><p>Sometimes, just invoking make again after a failed build, can make the build succeed. Yes, I know it sounds like nonsense, but it helps when you have tried everything else.</p></div><p>We now have an instrumented build that will let us obtain code coverage analysis for tests in our projects. So this is our next step.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec02"/>TemperatureConverter code coverage</h1></div></div></div><p>We built Android from source to be able to obtain code coverage analysis reports for our projects mainly for two reasons:<a class="indexterm" id="id490"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need an EMMA instrumented build, which is what we did in previous sections</li><li class="listitem" style="list-style-type: disc">To be able to instrument an application, this application should be built as part of the main build tree, and this is what we will be doing now;</li></ul></div><p>A possible location for our application and tests inside the main Android tree could be<code class="literal"> development/samples</code>, so we are going to use it. Should you decide on a different location, minor adaption might be needed in the files and commands presented here.</p><p>We already have our TemperatureConverter project and its tests<code class="literal"> TemperatureConverterTests</code> somewhere in our filesystem, and if you followed the examples presented before they are probably checked into the version control system of your choice, so the options here are checking out the project again at this location or creating a symbolic link. Let's choose the latter for the sake of simplicity for this example:</p><div><pre class="programlisting"><strong>~/android/android-2.3/development/samples$ ln -s ~/workspace/TemperatureConverter .
~/android/android-2.3/development/samples$ ln -s ~/workspace/TemperatureConverterTest .</strong>
</pre></div><p>Following, we need to add the makefiles. We built our projects from Eclipse and later on we added<code class="literal"> ant</code> support. Now we are adding support for a third build system:<code class="literal"> make</code>.</p><p>Android built is<code class="literal"> make</code> based and we should follow its conventions and style to be able to build our application and its tests as part of the main build.</p><p>Create the following<code class="literal"> Android.mk</code> inside the<code class="literal"> TemperatureConverter</code> project:</p><div><pre class="programlisting">LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := samples
# Only compile source java files in this apk.
LOCAL_SRC_FILES := $(call all-java-files-under, src)
LOCAL_PACKAGE_NAME := TemperatureConverter
LOCAL_SDK_VERSION := current
include $(BUILD_PACKAGE)
</pre></div><p>This makefile will be included as part of the main build if executed.</p><p>To build it separately we can use a helper function that was defined in our environment when we set it up at the beginning using<code class="literal"> envsetup.sh</code>. This function is<code class="literal"> mm</code> and is defined as:</p><div><pre class="programlisting">mm ()
{
if [ -f build/core/envsetup.mk -a -f Makefile ]; then
make $@;
else
T=$(gettop);
local M=$(findmakefile);
local M=`echo $M|sed 's:'$T'/::'`;
if [ ! "$T" ]; then
echo "Couldn't locate the top of the tree. Try setting TOP.";
else
if [ ! "$M" ]; then
echo "Couldn't locate a makefile from the current directory.";
else
ONE_SHOT_MAKEFILE=$M make -C $T all_modules $@;
fi;
fi;
fi
}
</pre></div><p>The boilerplate code to locate and include needed components is provided by this function.<a class="indexterm" id="id491"/>
</p><p>Using it to build the application is simply done by invoking it when our current working directory is the project we want to compile.</p><div><pre class="programlisting"><strong>~/android/android-2.3/development/samples/TemperatureConverter$ EMMA_INSTRUMENT=true mm</strong>
</pre></div><p>Because we enabled EMMA by setting<code class="literal"> EMMA_INSTRUMENT=true</code> in our environment among the messages produced by this command, we should see the following:</p><p>
<strong>EMMA: processing instrumentation path ..</strong>.</p><p>
<strong>EMMA: instrumentation path processed in 149 ms</strong>
</p><p>
<strong>EMMA: [14 class(es) instrumented, 4 resource(s) copied]</strong>
</p><p>
<strong>EMMA: metadata merged into [/home/diego/android/android-2.3/out/target/common/obj/APPS/TemperatureConverter_intermediates/coverage.em] {in 16 ms}</strong>
</p><p>This indicates that our build is being instrumented.</p><p>We should proceed in a similar manner to build and instrument our tests.</p><p>In the<code class="literal"> TemperatureConverterTest</code> project create its corresponding makefile:<code class="literal"> Android.mk</code>, this time containing this information, which is slightly different from the main project:<a class="indexterm" id="id492"/>
</p><div><pre class="programlisting">LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
# We only want this apk build for tests.
LOCAL_MODULE_TAGS := tests
LOCAL_JAVA_LIBRARIES := android.test.runner
LOCAL_STATIC_JAVA_LIBRARIES := easymock hamcrest-core \
hamcrest-integration hamcrest-library
# Include all test java files.
LOCAL_SRC_FILES := $(call all-java-files-under, src)
LOCAL_PACKAGE_NAME := TemperatureConverterTest
LOCAL_INSTRUMENTATION_FOR := TemperatureConverter
LOCAL_SDK_VERSION := current
include $(BUILD_PACKAGE)
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := \
easymock:libs/easymock-2.5.2.jar \
hamcrest-core:libs/hamcrest-core-1.2-android.jar \
hamcrest-integration:libs/hamcrest-integration-1.2-android.jar \
hamcrest-library:libs/hamcrest-library-1.2-android.jar
include $(BUILD_MULTI_PREBUILT)
</pre></div><p>This is a little more involved because the tests are using external libraries we need to define to be used during the build process.<a class="indexterm" id="id493"/>
</p><p>Again, we should build it using the<code class="literal"> mm</code> function:</p><div><pre class="programlisting">~/android/android-2.3/development/samples/TemperatureConverterTest \ $ EMMA_INSTRUMENT=true mm
</pre></div><p>We have successfully built the<code class="literal"> TemperatureConverter</code> application and its tests, now as part of the main Android build. At this point we are ready to obtain the code coverage analysis reports, just by following a few more steps.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec04"/>Generating code coverage analysis report</h2></div></div></div><p>Having reached this point, we have<code class="literal"> TemperatureConverter</code> and its tests instrumented and compiled residing in our output directory which is<code class="literal"> out/target/common/obj/APPS/</code>.<a class="indexterm" id="id494"/>
</p><p>We need an instance of the emulator that belongs to our instrumented built. This emulator is in the<code class="literal"> out</code> directory too.</p><p>In this case we extend the default system partition size up to 256MB and include a sdcard image that should have been created previously. These elements are needed because some data will be collected during the instrumented test run and we need some room to save it.</p><div><pre class="programlisting"><strong>~/android/android-2.3$ ./out/host/linux-x86/bin/emulator -sdcard ~/tmp/sdcard.img -partition-size 256</strong>
</pre></div><p>Our intention is now to synchronize the image running on the emulator with our changes.</p><p>These steps avoid creating a new image when some changes or updates are available just by copying the modified files.<a class="indexterm" id="id495"/>
</p><p>To be able to do it we first need to enable writing to the system image:</p><div><pre class="programlisting"><strong>~/android/android-2.3$ adb remount</strong>
</pre></div><p>This command when finished successfully should give this output:</p><p>
<strong>remount succeeded</strong>
</p><p>Followed by the synchronization of changes:</p><div><pre class="programlisting"><strong>~/android/android-2.3/development/samples/TemperatureConverterTest$ adb sync</strong>
</pre></div><p>The list of files being copied to the emulator image are displayed. Once everything is updated we can now run the tests using<code class="literal"> am instrument</code> as we previously did. As we mentioned in<a class="link" href="ch02.html" title="Chapter 2. Testing on Android"> Chapter 2</a>,<em> Testing on Android</em> when we reviewed the available options for this command,<code class="literal"> -e</code> can be used to set various suboptions. In this case we use it to enable code coverage collection:</p><div><pre class="programlisting"><strong>~/android/android-2.3$ adb shell am instrument -e coverage 'true' \ -w com.example.aatg.tc.test/android.test.InstrumentationTestRunner</strong>
</pre></div><p>This following message verifies that our tests are collecting coverage data:</p><p>
<strong>EMMA: collecting runtime coverage data ..</strong>.</p><p>The last message indeed informs us where this data was collected:</p><p>
<strong>Generated code coverage data to /data/data/com.example.aatg.tc/files/coverage.ec</strong>
</p><p>We can create a directory in the development computer to keep our coverage reports for this project. In this directory we should also copy the off-line coverage metadata and then generate the reports:</p><div><pre class="programlisting"><strong>~/android/android-2.3$ mkdir -p out/emma/tc
~/android/android-2.3$ cd out/emma/tc</strong>
</pre></div><p>Then we copy the coverage report from the device:</p><div><pre class="programlisting"><strong>~/android/android-2.3/out/emma/tc$ adb pull /data/data/com.example.aatg.tc/files/coverage.ec coverage.ec</strong>
</pre></div><p>When data is transferred we receive these statistics:</p><p>
<strong>200 KB/s (22840 bytes in 0.110s)</strong>
</p><p>And the off-line coverage metadata:</p><div><pre class="programlisting"><strong>~/android/android-2.3/out/emma/tc$ cp ~/android/android-2.3/out/target/common/obj/APPS/TemperatureConverter_intermediates/coverage.em .# not the dot (.) at the end</strong>
</pre></div><p>With all these components present in our working directory, it will be easier to specify the command line options. If you prefer you can use a different organization and leave the files somewhere else and even create symbolic links here.<a class="indexterm" id="id496"/>
</p><p>Having read everything, we can invoke<code class="literal"> emma</code> to generate the report. The default report shows the overall coverage summary followed by a breakdown by package. In this example we are using HTML output and we are linking to the source.</p><div><h3 class="title"><a id="note27"/>Note</h3><p>If your source folder for the<code class="literal"> TemperatureConverter</code> main project is other than<code class="literal"> ~/workspace/TemperatureConverter/src</code> don't forget to adapt the following command, otherwise the command will fail:<code class="literal"> ~/android/android-2.3/out/emma/tc$ java -cp ~/android/android-2.3/external/emma/lib/emma.jar emma report -r html -in coverage.ec -sp ~/workspace/TemperatureConverter/src -in coverage.em</code>.</p></div><p>And we will be able to see the messages indicating the creation of the report:</p><p>
<strong>EMMA: processing input files ..</strong>.</p><p>
<strong>EMMA: 2 file(s) read and merged in 20 ms</strong>
</p><p>
<strong>EMMA: writing [html] report to [/home/diego/android/android-2.3/out/emma/tc/coverage/index.html] ..</strong>.</p><p>
<strong>EMMA: writing [html] report to [/home/diego/android/android-2.3/out/emma/tc/coverage/index.html] ..</strong>.</p><p>This has created the report files inside the coverage directory, so we can open the index by invoking:</p><div><pre class="programlisting"><strong>~/android/android-2.3/out/emma/tc$ firefox coverage/index.html</strong>
</pre></div><p>Then, the coverage analysis report is displayed:</p><div><img alt="Generating code coverage analysis report" src="img/3500_10_01.jpg"/></div><p>This report has three main sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Overall coverage summary:</strong> The summary for all classes is presented here.</li><li class="listitem" style="list-style-type: disc"><strong>Overall stats summary:</strong> The statistics of the coverage are presented here, for example how many packages, classes, or lines were present.</li><li class="listitem" style="list-style-type: disc"><strong>Coverage breakdown by package:</strong> In the case of bigger applications this will display the coverage for particular packages. In this example, it's the same as the total because there is a single package.</li></ul></div><p>The information presented in the report includes coverage metrics in a way that allows for drilling down into data in a top-down fashion, starting with all classes and going all the way to the level of individual methods and source lines (in the HTML report).<a class="indexterm" id="id497"/>
</p><p>The fundamental unit of code coverage in EMMA is the basic blocks; all other types of coverage are derived from the basic block coverage in some way. Line coverage is mostly used to link to the source code.</p><p>This table describes the important pieces of information in the EMMA coverage report:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Label</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>name</p>
</td><td style="text-align: left" valign="top">
<p>The name of the class or package</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Class, %</p>
</td><td style="text-align: left" valign="top">
<p>The percentage of classes covered over the total and the detailed number.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Method, %</p>
</td><td style="text-align: left" valign="top">
<p>The percentage of methods covered over the total and the detailed number. This is a basic java method which is composed by a given number of basic blocks.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Block, %</p>
</td><td style="text-align: left" valign="top">
<p>The percentage of blocks covered over the total and the detailed number. A basic block is defined as a sequence of bytecode instructions without any jumps or jump targets.</p>
<p>The number of basic blocks in a method is a good measure of its complexity.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Line, %</p>
</td><td style="text-align: left" valign="top">
<p>The percentage of lines covered over the total and the detailed number. This is basically used to link to the source code.</p>
</td></tr></tbody></table></div><p>When the values presented are under a threshold coverage metric value, these metrics are presented in red in the report. By default, these values are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For methods: 70%</li><li class="listitem" style="list-style-type: disc">For blocks: 80%</li><li class="listitem" style="list-style-type: disc">For lines: 80%</li><li class="listitem" style="list-style-type: disc">For classes: 100%</li></ul></div><p>All of these values can be changed, specifying parameters on the command line or in a configuration file. Please refer to the documentation for details (<a class="ulink" href="http://emma.sourceforge.net/docs.html">http://emma.sourceforge.net/docs.html</a>).</p><p>We can drill-down from the package to specific methods and the lines covered are presented in green while uncovered ones appear in red and partially covered in yellow.<a class="indexterm" id="id498"/>
</p><p>This is an example of this report for the<code class="literal"> TemperatureConverter</code> class:</p><div><img alt="Generating code coverage analysis report" src="img/3500_10_02.jpg"/></div><p>In this report we can see that the class<code class="literal"> TemperatureConverter</code> is not 100% covered but all the basic blocks inside it are.</p><p>Do you know why ?</p><p>Think for a moment...</p><p>Yes, because the implicit default constructor has not been tested. But wait a second; this is a utility class which is not supposed to be instantiated at all. We can see here not only how this analysis is helping us to test our code and find potential bugs but also to improve the design.<a class="indexterm" id="id499"/>
</p><p>What we need to do to prevent<code class="literal"> TemperatureConverter</code> from being instantiated is to create a private default constructor:</p><div><pre class="programlisting">public TemperatureConverter {
…
private TemperatureConverter() {
}
...
}
</pre></div><p>Once we add this private constructor and run the tests and coverage again we can see now that even though the class is not yet 100% covered and thus not green we can assure that this constructor won't be invoked from any other class.<a class="indexterm" id="id500"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec05"/>Covering the restoring the instance state</h2></div></div></div><p>There is another case that we will analyze. In the report for<code class="literal"> TemperatureConverterActivity</code> we can see that some blocks are still not covered and they are red. One of such blocks is the partial support for restoring a saved instance we added before, though this block is not yet functional and its only logging a message we should cover it with a test.<a class="indexterm" id="id501"/>
</p><p>The code mentioned in<code class="literal"> TemperatureConverterActivity.java</code> is:</p><div><pre class="programlisting">/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
if ( savedInstanceState != null ) {<strong>
Log.d(TAG, "Should restore state from " + savedInstanceState);</strong>
}
…
</pre></div><p>To test this block we must control the invocation of the<code class="literal"> onCreate()</code> method and inject a mock<code class="literal"> Bundle</code> to simulate the actual Android lifecycle.</p><p>We may think of using one of our previously created test classes to add the needed test, but if you remember from our previous chapters we stated that when we need a higher degree of control over the creation of the<code class="literal"> Activity</code> under test, instead of<code class="literal"> ActivityInstrumentationTestCase2&lt;T&gt;</code> we should use<code class="literal"> ActivityUnitTestCase&lt;T&gt;</code>, which is also derived from<code class="literal"> InstrumentationTestCase</code> (see the UML class diagram for<code class="literal"> ActivityInstrumentationTestCase2&lt;T&gt;</code> in<a class="link" href="ch03.html" title="Chapter 3. Building Blocks on the Android SDK"> Chapter 3</a>, <em>Building Blocks on the Android SDK</em>)</p><p>The test case based on<code class="literal"> ActivityUnitTestCase&lt;T&gt;</code> allows us to inject the desired values to<code class="literal"> onCreate()</code> while starting the Activity by using<code class="literal"> startActivity(Intent intent, Bundle savedInstanceState, Object lastNonConfigurationInstance)</code>.</p><p>The following code snippet shows the test case we are adding to our already existing<code class="literal"> TemperatureConverterActivityUnitTests</code> class:<a class="indexterm" id="id502"/>
</p><div><pre class="programlisting">package com.example.aatg.tc.test;
import com.example.aatg.tc.TemperatureConverterActivity;
import com.example.aatg.tc.TemperatureConverterApplication;
import android.app.Instrumentation;
import android.content.Intent;
import android.os.Bundle;
import android.test.ActivityUnitTestCase;
public class TemperatureConverterActivityUnitTests extends
ActivityUnitTestCase&lt;TemperatureConverterActivity&gt; {
public TemperatureConverterActivityUnitTests(String name) {
super(TemperatureConverterActivity.class);
setName(name);
}
protected void setUp() throws Exception {
super.setUp();<strong>
mStartIntent = new Intent(Intent.ACTION_MAIN);
mInstrumentation = getInstrumentation();
setApplication(new TemperatureConverterApplication());</strong>
}
protected void tearDown() throws Exception {
super.tearDown();
}
// other tests not displayed here …<strong>
public final void testOnCreateBundle() {
Bundle savedInstanceState = new Bundle();
savedInstanceState.putString("dummy", "dummy");
setApplication(new TemperatureConverterApplication());
Intent intent = new Intent(mInstrumentation.getTargetContext(), TemperatureConverterActivity.class);
startActivity(intent, savedInstanceState, null);
TemperatureConverterActivity activity = getActivity();
assertNotNull(activity);
}</strong>
}
</pre></div><p>We are creating a<code class="literal"> Bundle</code> containing only dummy values as nothing special is expected in the Activity. Additionally we are injecting a real<code class="literal"> TemperatureConverterApplication</code> object instead of an Application mock because it is used, and casted, inside the Activity's<code class="literal"> onCreate()</code> method and it would fail.<a class="indexterm" id="id503"/>
</p><p>No additional tests were added to this class as nothing special is done when the saved state is restored. For your particular application probably you would like to check that some values were restored correctly.</p><p>Should we run the test coverage report again we would see that now the mentioned block is now covered.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec06"/>Covering the exceptions</h2></div></div></div><p>Continuing with our examination of the coverage report will lead us to discover another block that is not exercised by our current tests. The block in question is the last catch in the following try-catch block in<code class="literal"> TemeratureConverterActivity:</code>
<a class="indexterm" id="id504"/>
</p><div><pre class="programlisting">try {
final double temp = Double.parseDouble(str);
final double result = (mOp == OP.C2F) ?
TemperatureConverter.celsiusToFahrenheit(temp) :
TemperatureConverter.fahrenheitToCelsius(temp);
final String resultString = String.format("%.2f", result);
mDest.setNumber(result);
mDest.setSelection(resultString.length());
} catch (NumberFormatException e) {
// WARNING
// this is generated while a number is entered,
// for example just a '-'
// so we don't want to show the error<strong>
} catch (InvalidTemperatureException e) {
mSource.setError("ERROR: " + e.getLocalizedMessage());
}</strong>
</pre></div><p>We should provide a test, or better a pair of tests, one for each temperature unit, that furnishing an invalid temperature verifies that the error is displayed. This is the test in<code class="literal"> TemperatureConverterActivityTests</code> for the Celsius case and you can easily convert it to provide the other case:</p><div><pre class="programlisting">public void testInvalidTemperatureInCelsius() throws Throwable {
runTestOnUiThread(new Runnable() {
@Override
public void run() {
mCelsius.clear();
mCelsius.requestFocus();
}
});
// temp less than ABSOLUTE_ZERO_C
assertNull(mCelsius.getError());
sendKeys("MINUS 3 8 0");
assertNotNull(mCelsius.getError());
}
</pre></div><p>We clear and request the focus for the field under test. As we did before, we should achieve this by using a Runnable on the UI thread otherwise we will receive an exception.<a class="indexterm" id="id505"/>
</p><p>Then we check there's no previous error, set the invalid temperature, and retrieve the error message to verify that is not null. Running the end-to-end process again we can attest that the block is now covered giving us total coverage as intended.</p><p>This is the iterative process you should follow to change as much as possible of the code to green. Ideally this should be 100% but sometimes this is not achievable mainly for some blocks that are not reachable during the tests.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec07"/>Bypassing access restrictions</h2></div></div></div><p>One of the blocks we added to satisfy our needs, the private constructor for<code class="literal"> TemperatureConverter</code>, is now unreachable by our tests and is marked red. In cases like this we can leave it as it is or we can use a more convoluted solution using reflection to bypass the access restrictions and create a test. Though this is not really advisable because strictly speaking you should limit to test the public interface, we are including this as an illustration of this technique.<a class="indexterm" id="id506"/>
</p><p>This is the test we are adding to the<code class="literal"> TemperatureConverterTests</code> class:</p><div><pre class="programlisting">public final void testPrivateConstructor() throws
SecurityException, NoSuchMethodException,
IllegalArgumentException, InstantiationException,
IllegalAccessException, InvocationTargetException {
Constructor&lt;TemperatureConverter&gt; ctor =
TemperatureConverter.class.getDeclaredConstructor();
ctor.setAccessible(true);
TemperatureConverter tc = ctor.newInstance((Object[])null);
assertNotNull(tc);
}
</pre></div><p>This example uses reflection to bypass the access restriction and create a new<code class="literal"> TemperatureConstructor</code> instance and then verify that it was successfully created.<a class="indexterm" id="id507"/>
</p><p>If you are not familiar with this technique or Java reflection in general you can read the excellent tutorial at The Java Tutorials by Oracle (<a class="ulink" href="http://download.oracle.com/javase/tutorial/reflect/">http://download.oracle.com/javase/tutorial/reflect/</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec08"/>Covering the options menu</h2></div></div></div><p>Taking another look at the coverage report, we can yet identify a method that's not covered by our tests. It is the<code class="literal"> TemperatureConverterActivity.onCreateOptionsMenu()</code> which creates the menu holding the Preferences option in our particular situation. What it does is very simple and straightforward. It creates a<code class="literal"> MenuItem</code> that when clicked invokes the<code class="literal"> TemperatureConverterPreferences</code> Activity through the corresponding intent. This is right what we are going to test. From our experience we know that if we are interested in knowing if an Activity was launched from our Activity under tests, then what we need is an<code class="literal"> ActivityMonitor</code>, so we are establishing the test based on this component.<a class="indexterm" id="id508"/>
</p><p>This is the new test we will add to the<code class="literal"> TemperatureConverterActivityTests</code> class:</p><div><pre class="programlisting">public final void testOnCreateOptionsMenu() {
final Instrumentation instrumentation = getInstrumentation();
final ActivityMonitor preferencesMon = instrumentation.addMonitor( "com.example.aatg.tc.TemperatureConverterPreferences", null, false);
assertTrue(instrumentation.invokeMenuActionSync( mActivity, TemperatureConverterActivity. MENU_ID_PREFERENCES, 0));
final Activity preferences = preferencesMon.waitForActivityWithTimeout(3000);
assertNotNull(preferences);
preferences.finish();
}
</pre></div><p>Firstly we get the Instrumentation as in other cases. We then add a monitor using<code class="literal"> addMonitor(),</code> a convenience wrapper that also creates the<code class="literal"> ActivityMonitor</code> for us and returns it, defining the name of the Activity class to monitor, null as a result as we are not interested in it, and false not to block the start of the Activity. This monitor will be hit if an Activity that matches the class is launched.</p><p>Next, we invoke the menu option with ID<code class="literal"> 0</code>, as it was defined in<code class="literal"> onCreateOptionsMenu()</code>, and passing no flags (0 again). We assert that the invocation was successful as<code class="literal"> invokeMenuActionSync()</code> returns true in such cases.<a class="indexterm" id="id509"/>
</p><p>We wait for the Activity to start, verify that it was actually started as<code class="literal"> waitForActivityWithTimeout()</code> returns null if the timeout expires before the Activity was started, and finally<code class="literal"> finishing()</code> the Activity.</p><p>This is a good example of<code class="literal"> ActivityMonitor</code> utilization. However, the way we used to invoke the particular menu item and the limitations we would face if we intended to continue testing the new Activity for a real functional test led us to believe that there should be another way, and actually there is!</p><p>We will explore such ways in the following section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec03"/>The undocumented Ant coverage target</h1></div></div></div><p>If building with make doesn’t appeal to you very much there is still another alternative. Latest versions of Android tools include an undocumented option that adds to the documented targets we mentioned before: help, clean, compile, debug, release, install, and uninstall.</p><p>This target is<code class="literal"> coverage</code> and can be used like in the following example in the<code class="literal"> TemperatureConverterTest</code> project.</p><div><h3 class="title"><a id="note28"/>Note</h3><p>To be able to successfully complete all its subtasks a suitable emulator or device should be running.</p></div><div><pre class="programlisting"><strong>$ ant coverage</strong>
</pre></div><p>This will generate the following output (parts of the output were trimmed in order to include it here):</p><div><pre class="programlisting">Buildfile: &lt;path/to&gt;/TemperatureConverterTest/build.xml
[setup] Android SDK Tools Revision 11
[setup] Project Target: Android 2.3.1
...
-set-coverage-classpath:
-install-instrumented:
...
-package-with-emma:
...
-install-with-emma:
...
coverage:
[echo] Running tests ...
[exec]
[exec] com.example.aatg.tc.test.EditNumberTests:.......
[exec] com.example.aatg.tc.test. TemperatureConverterActivityTests:...............
[exec] com.example.aatg.tc.test. TemperatureConverterActivityUnitTest:...
[exec] com.example.aatg.tc.test. TemperatureConverterApplicationTests:....
[exec] com.example.aatg.tc.test.TemperatureConverterTests:.......
[exec] com.example.aatg.tc.test.robotium. TemperatureConverterActivityTests:..
[exec] Test results for InstrumentationTestRunner=..........................
[exec] Time: 61.931
[exec]
[exec] OK (38 tests)
[exec]
[exec]
[exec] Generated code coverage data to /data/data/com.example.aatg.tc/files/coverage.ec
[echo] Downloading coverage file into project directory...
[exec] 14 KB/s (751 bytes in 0.050s)
[echo] Extracting coverage report...
...<strong>
[echo] Saving the report file in &lt;path/to&gt;/ TemperatureConverterTest/coverage/coverage.html</strong>
BUILD SUCCESSFUL
Total time: 1 minute 31 seconds
</pre></div><p>This automates several of the steps we described before. However it is not documented yet so it can be removed or changed in the future. On the other hand, when the projects are complex or there are a lot of dependencies this build target may fail when the makefile succeeds, so use it with caution.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec04"/>Introducing Robotium</h1></div></div></div><p>One component of the vast emerging robotic fauna is Robotium (<a class="ulink" href="http://code.google.com/p/robotium/">http://code.google.com/p/robotium/</a>), a test framework created to simplify the writing of tests requiring minimal knowledge of the application under test. Robotium is mainly oriented to write powerful and robust automatic black-box test cases for Android applications. It can cover function, system, and acceptance test scenarios, even spanning multiple Android activities of the same application automatically.<a class="indexterm" id="id510"/>
</p><p>Robotium can also be used to test applications that we don't have the source code for, or even pre-installed applications.</p><p>Robotium has full support for Activities, Dialogs, Toasts, Menus, and Context Menus.</p><p>Let's put Robotium to work creating some new tests for<code class="literal"> TemperatureConverter</code>. To keep our tests organized we create a new package named<code class="literal"> com.example.aatg.tc.tests.robotium</code> in the<code class="literal"> TemperatureConverterTest</code> project. In this package we are creating the class for our test cases, because we will be initially testing<code class="literal"> TemperatureConverterActivity</code>. It is reasonable to call it<code class="literal"> TemperatureConverterActivityTests</code> even though we have a class with the same name in another package also extending<code class="literal"> ActivityInstrumentationTestCase2</code>. After all, this class will be containing tests for this same<code class="literal"> Activity</code> too.<a class="indexterm" id="id511"/>
</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec09"/>Downloading Robotium</h2></div></div></div><p>We need to download the<code class="literal"> robotium-solo</code> JAR file and its Javadoc so we can add them to our project. Go to the Robotium download site (<a class="ulink" href="http://code.google.com/p/robotium/downloads/list">http://code.google.com/p/robotium/downloads/list</a>) and pick the latest version available, which at the time of this writing is<code class="literal"> robotium-solo-2.1.jar</code>.<a class="indexterm" id="id512"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec10"/>Configuring the project</h2></div></div></div><p>In the properties of our<code class="literal"> TemperatureConverterTest</code> project we need to add this JAR to<strong> Java Build Path | Libraries</strong>. Once added, you can expand this node and add the Javadoc location to point to the companion JAR file using the<strong> Javadoc in archive</strong> option.<a class="indexterm" id="id513"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec11"/>Creating the test cases</h2></div></div></div><p>From previous chapter we know that if we are creating test cases for an Activity that should run connected to the system infrastructure, we should base it on<code class="literal"> ActivityInstrumentationTestCase2</code>, and that is what we are going to do.<a class="indexterm" id="id514"/>
</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec05"/>The testFahrenheitToCelsiusConversion() test</h3></div></div></div><p>More or less the test cases have the same structure as other Instrumentation based tests. The main difference is that we need to instantiate Robotium's Solo in the test<code class="literal"> setUp()</code> and<code class="literal"> finalize()</code> it in the<code class="literal"> tearDown():</code>
<a class="indexterm" id="id515"/>
</p><div><pre class="programlisting">package com.example.aatg.tc.test.robotium;
import android.test.ActivityInstrumentationTestCase2;
import com.example.aatg.tc.TemperatureConverterActivity;<strong>
import com.jayway.android.robotium.solo.Solo;</strong>
/**
* @author diego
*
*/
public class TemperatureConverterActivityTests extends
ActivityInstrumentationTestCase2&lt;TemperatureConverterActivity&gt; {<strong>
private Solo mSolo;</strong>
private TemperatureConverterActivity mActivity;
/**
* @param name
*/
public TemperatureConverterActivityTests(String name) {
super(TemperatureConverterActivity.class);
setName(name);
}
/* (non-Javadoc)
* @see android.test.ActivityInstrumentationTestCase2#setUp()
*/
protected void setUp() throws Exception {
super.setUp();
mActivity = getActivity();<strong>
mSolo = new Solo(getInstrumentation(), mActivity);</strong>
}
testFahrenheitToCelsiusConversion() testabout/* (non-Javadoc)
* @see android.test.ActivityInstrumentationTestCase2#tearDown()
*/
protected void tearDown() throws Exception {
try {<strong>
mSolo.finalize();</strong>
}
catch (Throwable ex) {
ex.printStackTrace();
}
mActivity.finish();
super.tearDown();
}
}
</pre></div><p>To instantiate<code class="literal"> Solo</code> we have to pass a reference to the<code class="literal"> Instrumentation</code> and to the<code class="literal"> Activity</code> under test.</p><p>On the other hand, to finalize<code class="literal"> Solo</code> we should precisely call the<code class="literal"> finalize()</code> method, then finish the<code class="literal"> Activity</code>, and invoke<code class="literal"> super.tearDown()</code>.</p><p>Solo provides a variety of methods to drive UI tests and some assertions. Let's start by re-implementing the<code class="literal"> testFahrenheitToCelsiusConversion()</code> that we previously implemented using the conventional approach, but in this case using<code class="literal"> Solo</code> facilities:<a class="indexterm" id="id517"/>
</p><div><pre class="programlisting">public final void testFahrenheitToCelsiusConversion() {
mSolo.clearEditText(CELSIUS);
mSolo.clearEditText(FAHRENHEIT);
final double f = 32.5d;
mSolo.clickOnEditText(FAHRENHEIT);
mSolo.enterText(FAHRENHEIT, Double.toString(f));
mSolo.clickOnEditText(CELSIUS);
final double expectedC = TemperatureConverter.fahrenheitToCelsius(f);
final double actualC = Double.parseDouble(mSolo.getEditText(CELSIUS). getText().toString());
final double delta = Math.abs(expectedC - actualC);
final String msg = "" + f + "F -&gt; " + expectedC + "C but was " + actualC + "C (delta " + delta + ")";
assertTrue(msg, delta &lt; 0.005);
}
</pre></div><p>This is pretty similar, however the first difference you may have noticed is that in this case we are not getting references to the UI elements as we previously did in the<code class="literal"> setUp()</code> method using<code class="literal"> findViewById()</code> to locate the View. However, we are using one of the biggest advantages of Solo that is locating the Views for us using some criteria. In this case the criteria are used in the order in which they appear on the screen and since they are counted an index is assigned. The method<code class="literal"> mSolo.clearEditText(int index)</code> expects an integer index of the position on the screen starting from<code class="literal"> 0</code>. Consequently we should add these constants to the test case, as in our UI the Celsius field is on top and Fahrenheit beneath:</p><div><pre class="programlisting">private static final int CELSIUS = 0;
private static final int FAHRENHEIT = 1;
</pre></div><p>The other methods follow the same convention and we are supplying these constants when necessary. This test is very similar to the one in<code class="literal"> com.example.aatg.tc.test.TemperatureConverterActivityTest</code> but you may have noticed that there is a subtle difference. Here we are located at a much higher level and we don't have to worry about internals or implementation details; for example when in our previous test we invoked<code class="literal"> mCelsius.requestFocus()</code> to trigger the conversion mechanism, but here we just simulate what the user does and issue a<code class="literal"> mSolo.clickOnEditText(CELSIUS)</code>.</p><p>Because of this, we don't want to cast and use<code class="literal"> EditNumber.getNumber()</code> either. We just obtain the textual data that is on the screen, convert it to a<code class="literal"> Double</code>, and then compare it against the expected value.<a class="indexterm" id="id518"/>
</p><p>We simplified the test sensibly but the biggest advantage of using<code class="literal"> Solo</code> is yet to come.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec06"/>The testOnCreateOptionsMenu() revisited</h3></div></div></div><p>You may have been waiting for this since the announcement in our preceding<code class="literal"> testOnCreateOptionsMenu()</code> implementation. This time we are situated at a much higher level and we don't deal with implementation details. It is not our problem if a new Activity is launched when we click on the menu item; we only treat this case from the UI perspective.<a class="indexterm" id="id519"/>
</p><p>This is a screenshot showing the preferences dialog for<strong> Decimal places:</strong>
</p><div><img alt="The testOnCreateOptionsMenu() revisited" src="img/3500_10_03.jpg"/></div><p>Our purpose is also to change the value of<strong> Decimal places</strong> preferences to 5, and verify that the change actually took place.</p><p>The following code snippet illustrates the details of the test:<a class="indexterm" id="id520"/>
</p><div><pre class="programlisting">public final void testOnCreateOptionsMenu() {
final int decimalPlaces = 5;
final String numberRE = "^[0-9]+$";
mSolo.sendKey(Solo.MENU);
mSolo.clickOnText("Preferences");
mSolo.clickOnText("Decimal places");
assertTrue(mSolo.searchText(numberRE));
mSolo.clearEditText(DECIMAL_PLACES);
assertFalse(mSolo.searchText(numberRE));
mSolo.enterText(DECIMAL_PLACES, Integer.toString(decimalPlaces));
mSolo.clickOnButton("OK");
mSolo.goBack();
mSolo.sendKey(Solo.MENU);
mSolo.clickOnText("Preferences");
mSolo.clickOnText("Decimal places");
assertTrue(mSolo.searchText(numberRE));
assertEquals(decimalPlaces, Integer.parseInt( mSolo.getEditText(DECIMAL_PLACES). getText().toString()));
}
</pre></div><p>Can you already appreciate the difference? There are no gory details about how all this is implemented. We only test its functionality.</p><p>We start by pressing the<code class="literal"> MENU</code> key, clicking on<strong> Preferences</strong>.</p><p>Wow, we just specify the menu item title and that's it!</p><p>The new Activity is started but we don't have to worry about it. We continue and click on<strong> Decimal places</strong>.</p><p>We verify that some field containing a number, the prior value of this preference, appeared. Do you remember what I said about regular expressions: they always come in handy in one way or another; here to match any decimal integer number (any digit followed by zero or more digits). Then we clear the field and verify that it was in fact cleared.</p><p>We enter the string representing the number we want to use as a preference, 5 in this case. Click on the<strong> OK</strong> button, and the preference is saved.</p><p>It remains to verify that it actually happened. The same procedure is used to get the menu and the field and finally we verify that the actual number is already there.</p><p>You may wonder where<code class="literal"> DECIMAL_PLACES</code> comes from. We previously defined<code class="literal"> CELSIUS</code> and<code class="literal"> FAHRENHEIT</code> index constants for the fields on the screen and this is the same case, because this will be the third<code class="literal"> EditText</code> we should define in our class:<a class="indexterm" id="id521"/>
</p><div><pre class="programlisting">private static final int DECIMAL_PLACES = 2;
</pre></div><p>Tests can be run from Eclipse or the command line according to your preferences.</p><p>I hope you have enjoyed this simplicity as much as I did and that your brain is now bubbling with ideas to implement your own tests.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec05"/>Testing on host's JVM</h1></div></div></div><p>We left this subject for the end of this chapter as it seems this is the<em> Holy Grail</em> of the Android platform.</p><p>You know that Android is based on a virtual machine named Dalvik, after a village in Iceland, optimized for mobile resources with limited capabilities such as constrained amount of memory and processor speed. Certainly a very different environment than our development host computer, which may have plenty of memory and processor speed to enjoy.</p><p>Ordinarily, we run our applications and tests on an emulator or device. These targets have a much slower real or emulated CPU and thus running our tests is a time consuming activity mainly when our project starts to grow, and applying Test Driven Development techniques compels us to run hundreds of tests to verify every change we introduced.</p><div><h3 class="title"><a id="note29"/>Note</h3><p>It's worth noticing that this technique can be used only as a workaround during the development process to speed things up and it should never replace final testing on the real platform as incompatibilities between the Dalvik and JavaSE runtime may affect the accuracy of the tests.</p></div><p>Later, we should find out a method that allows us to intercept the standard<em> compilation-dexing-running</em> on an emulator or a device sequence and be able to run on our host computer directly.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec12"/>Creating the TemperatureConverterJVMTest project</h2></div></div></div><p>Let's put the ideas presented here into practice. This time we are creating a Java project in Eclipse, as opposed to our previously created Android projects.<a class="indexterm" id="id522"/>
</p><p>These are the steps needed to do it:</p><div><ol class="orderedlist arabic"><li class="listitem"> First we create the project and select<strong> JavaSE-1.6</strong> as the execution environment:<div><img alt="Creating the TemperatureConverterJVMTest project" src="img/3500_10_04.jpg"/></div></li><li class="listitem"> Pressing<strong> Next &gt;</strong> we can select the<strong> Java Settings</strong> for the project and as our intention is to create the tests for the<code class="literal"> TemperatureConverter</code> project we should add it as a<strong> Required project on the build path:</strong><a class="indexterm" id="id523"/><div><img alt="Creating the TemperatureConverterJVMTest project" src="img/3500_10_05.jpg"/></div></li><li class="listitem"> Then we create a new package in this project to keep our tests, named<code class="literal"> com.example.aatg.tc.test</code>. In this package we create a new<strong> JUnit Test Case</strong>, named<code class="literal"> TemperatureConverterTests</code>, using JUnit version 4, as opposed to the supported JUnit version 3 used in standard Android test cases. Select<strong> TemperatureConverter</strong> as the<strong> Class under test:</strong><a class="indexterm" id="id524"/><div><img alt="Creating the TemperatureConverterJVMTest project" src="img/3500_10_06.jpg"/></div></li><li class="listitem"> Pressing<strong> Next &gt;</strong> this time we can select the methods to test and the method stubs will be generated automatically:<a class="indexterm" id="id525"/></li></ol></div><div><img alt="Creating the TemperatureConverterJVMTest project" src="img/3500_10_07.jpg"/></div><p>Now we have the test case template and the method stubs completed. We now need to enter the test code we created in previous chapters for<code class="literal"> TemperatureConverter</code> in these stubs:<a class="indexterm" id="id526"/>
</p><div><pre class="programlisting">package com.example.aatg.tc.test;
import static org.junit.Assert.*;
import java.util.HashMap;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import com.example.aatg.tc.TemperatureConverter;
public class TemperatureConverterTests {
private static final HashMap&lt;Double, Double&gt; conversionTableDouble =
new HashMap&lt;Double, Double&gt;();
static {
// initialize (c, f) pairs
conversionTableDouble.put(0.0, 32.0);
conversionTableDouble.put(100.0, 212.0);
conversionTableDouble.put(-1.0, 30.20);
conversionTableDouble.put(-100.0, -148.0);
conversionTableDouble.put(32.0, 89.60);
conversionTableDouble.put(-40.0, -40.0);
conversionTableDouble.put(-273.0, -459.40);
}
</pre></div><p>The previous code snippet shows the imports and the definition of the<code class="literal"> TemperatureConverterTests</code>. This is almost exactly the same as before but with the sole addition of JUnit 4 annotations:<a class="indexterm" id="id527"/>
</p><div><pre class="programlisting">@Before
public void setUp() throws Exception {
}
@After
public void tearDown() throws Exception {
}
/**
* Test method for {@link com.example.aatg.tc. TemperatureConverter#fahrenheitToCelsius(double)}.
*/<strong>
@Test</strong>
public void testFahrenheitToCelsius() {
for (double c: conversionTableDouble.keySet()) {
final double f = conversionTableDouble.get(c);
final double ca = TemperatureConverter.fahrenheitToCelsius(f);
final double delta = Math.abs(ca - c);
final String msg = "" + f + "F -&gt; " + c + "C but is " + ca + " (delta " + delta + ")";
assertTrue(msg, delta &lt; 0.0001);
}
}
/**
* Test method for {@link com.example.aatg.tc. TemperatureConverter#celsiusToFahrenheit(double)}.
*/<strong>
@Test</strong>
public void testCelsiusToFahrenheit() {
for (double c: conversionTableDouble.keySet()) {
final double f = conversionTableDouble.get(c);
final double fa = TemperatureConverter.celsiusToFahrenheit(c);
final double delta = Math.abs(fa - f);
final String msg = "" + c + "C -&gt; " + f + "F but is " + fa + " (delta " + delta + ")";
assertTrue(msg, delta &lt; 0.0001);
}
}
</pre></div><p>Again, this code snippet shows no changes against our previous version of the test case but with the sole addition of JUnit 4 annotations:<a class="indexterm" id="id528"/>
</p><div><pre class="programlisting"><strong>
@Test</strong>
public final void testExceptionForLessThanAbsoluteZeroF() {
try {
final double c = TemperatureConverter.fahrenheitToCelsius( TemperatureConverter.ABSOLUTE_ZERO_F-1);
fail("Less than absolute zero F not detected");
}
catch (InvalidTemperatureException ex) {
// do nothing
}
}<strong>
@Test</strong>
public final void testExceptionForLessThanAbsoluteZeroC() {
try {
final double f = TemperatureConverter.celsiusToFahrenheit( TemperatureConverter.ABSOLUTE_ZERO_C-1);
fail("Less than absolute zero C not detected");
}
catch (RuntimeException ex) {
// do nothing
}
}
}
</pre></div><p>The code is exactly the same with just a few minor differences. One such difference is that we are now annotating the tests with<code class="literal"> @Test</code>, as JUnit 4 finds the test methods by this annotation and not by their name. So in this example we are using the same names for tests methods as we used before, but strictly speaking we could have used something different, for example<code class="literal"> shouldRaiseExceptionForLessThanAbsoluteZeroC</code> instead of<code class="literal"> testExceptionForLessThanAbsoluteZeroC</code>.<a class="indexterm" id="id529"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec13"/>Comparing the performance gain</h2></div></div></div><p>Once the tests are finished we can run them from Eclipse by selecting the appropriate test launcher,<strong> Eclipse JUnit Launcher:</strong>
<a class="indexterm" id="id530"/>
</p><div><img alt="Comparing the performance gain" src="img/3500_10_08.jpg"/></div><p>The distinction is evident. There is no emulator start up, any device communication and therefore the speed gain is important. Analyzing the evidence we can find out these differences.<a class="indexterm" id="id531"/>
</p><p>Running all tests in my development computer takes 0.005 seconds, with some tests taking so little time that they are not even accounted for, and are displayed as 0.000 seconds:</p><div><img alt="Comparing the performance gain" src="img/3500_10_09.jpg"/></div><p>Comparing this with the time it took to run the same tests on the emulator makes this huge difference evident:<a class="indexterm" id="id532"/>
</p><div><img alt="Comparing the performance gain" src="img/3500_10_10.jpg"/></div><p>These same tests took 0.443 seconds to run, almost 100 times more and that's a huge difference if you consider hundreds of tests running tens of times a day.</p><p>It is also good to notice that other advantages exists beside the speed gain and they are the availability of several mock frameworks and code coverage tools.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec14"/>Adding Android to the picture</h2></div></div></div><p>We intentionally left Android outside our picture. Let's analyze what happens if we include a simple Android test. Remember that for these tests to compile<code class="literal"> android.jar</code> from the SDK should also be added to the project libraries.<a class="indexterm" id="id533"/>
</p><p>Add this test to a new JUnit test case named<code class="literal"> TemperatureConverterActivityUnitTests:</code>
</p><div><pre class="programlisting">package com.example.aatg.tc.test;
import static org.junit.Assert.assertNotNull;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import android.app.Application;
import android.content.Intent;
import com.example.aatg.tc.TemperatureConverterActivity;
import com.example.aatg.tc.TemperatureConverterApplication;
public class TemperatureConverterActivityUnitTests {<strong>
@Before</strong>
public void setUp() throws Exception {
}<strong>
@After</strong>
public void tearDown() throws Exception {
}<strong>
@Test
public final void testApplication() {
Application application = new TemperatureConverterApplication();
assertNotNull(application);
}</strong>
}
</pre></div><p>And here is what we obtain:</p><p>
<strong>java.lang.RuntimeException: Stub!</strong>
</p><p>
<strong>at android.content.Context.&lt;init&gt;(Context.java:4)</strong>
</p><p>
<strong>at android.content.ContextWrapper.&lt;init&gt;(ContextWrapper.java:5)</strong>
</p><p>
<strong>at android.app.Application.&lt;init&gt;(Application.java:6)</strong>
</p><p>
<strong>at com.example.aatg.tc.TemperatureConverterApplication.&lt;init&gt;(TemperatureConverterApplication.java:27)</strong>
</p><p>
<strong>…</strong>
</p><p>The reason is that<code class="literal"> android.jar</code> provides only the API, not the implementation. All methods throw<code class="literal"> java.lang.RuntimeException: Stub!</code> when used.<a class="indexterm" id="id534"/>
</p><p>If we want to circumvent this limitation to test some classes outside of the Android operating system, we should create an<code class="literal"> android.jar</code> that mocks every class. However, we will also find problems for subclasses of Android classes like<code class="literal"> TemperatureConverterApplication</code>. This would be a daunting task and a significant amount of work, so we should look for another solution.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec06"/>Introducing Robolectric</h1></div></div></div><p>
<strong>Robolectric</strong> (<a class="ulink" href="http://pivotal.github.com/robolectric/">http://pivotal.github.com/robolectric/</a>) is a unit test framework that intercepts the loading of Android classes and rewrites the method bodies. Robolectric re-defines Android methods so they return default values, like<code class="literal"> null, 0</code>, or<code class="literal"> false</code>, and if provided it forwards method calls to shadow objects giving Android behavior.<a class="indexterm" id="id535"/>
</p><p>A large number of shadow objects are provided, but this is far from complete coverage, however it is improving constantly. This should also lead you to treat it as an evolving Open Source project, for which you should be ready to contribute to make it better, but also to depend on it with caution because you may discover that what you need for your tests has not been implemented yet. This is not in any way to diminish its promising future.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec15"/>Installing Robolectric</h2></div></div></div><p>Robolectric can be installed by downloading the<code class="literal"> robolectric-&lt;version&gt;-jar-with-dependencies.jar</code> from the Maven central repository (<a class="ulink" href="http://repo1.maven.org/maven2/com/pivotallabs/robolectric/">http://repo1.maven.org/maven2/com/pivotallabs/robolectric/</a>). By the time of this writing the latest JAR available is<code class="literal"> robolectric-0.9.8-jar-with-dependencies.jar</code> and this is what we are going to use in our samples.<a class="indexterm" id="id536"/>
</p><p>Conveniently you can also download the corresponding Javadoc and attach it to the library in you project properties so you can access the documentation from Eclipse.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec16"/>Creating a new Java project</h2></div></div></div><p>To keep our tests organized we are creating a new Java project as we did in our previous section. This time we are adding the following libraries:<a class="indexterm" id="id537"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">robolectric-&lt;version&gt;-jar-with-dependencies.jar</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android.jar</code> from your Android SDK.</li><li class="listitem" style="list-style-type: disc"><code class="literal">maps.jar</code> also from your Android SDK. Note that this is an optional package when you install the SDK.</li><li class="listitem" style="list-style-type: disc">JUnit 4.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec17"/>Writing some tests</h2></div></div></div><p>We will get acquainted with Robolectric by reproducing some of the tests we wrote before.<a class="indexterm" id="id538"/>
</p><p>One good example can be re-writing the<code class="literal"> EditNumber</code> tests. Let's create a new<code class="literal"> EditNumberTests</code> class, this time in the newly created project, and copy the tests from the<code class="literal"> EditNumberTests</code> in<code class="literal"> TemperatureConverterTest</code> project:</p><div><pre class="programlisting">package com.example.aatg.tc.test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import com.example.aatg.tc.EditNumber;
import com.xtremelabs.robolectric.RobolectricTestRunner;<strong>
@RunWith(RobolectricTestRunner.class)</strong>
public class EditNumberTests {
private static final double DELTA = 0.00001d;
private EditNumber mEditNumber;
</pre></div><p>In the previous snippet we defined the package. In this case using<code class="literal"> com.example.aatg.tc.test</code> as usual. Also we declare the test runner with the<code class="literal"> @RunWith</code> annotation. Later we defined the<code class="literal"> mEditNumber</code> field to hold the reference to the<code class="literal"> EditNumber:</code>
</p><div><pre class="programlisting">@Before
public void setUp() throws Exception {<strong>
mEditNumber = new EditNumber(null);</strong>
mEditNumber.setFocusable(true);
}
@After
public void tearDown() throws Exception {
}
@Test
public final void testPreconditions() {
assertNotNull(mEditNumber);
}
/**
* Test method for {@link com.example.aatg.tc.EditNumber# EditNumber(android.content.Context, AttributeSet attrs, int defStyle)}.
*/
@Test
public final void testEditNumberContextAttributeSetInt() {
final EditNumber e = new EditNumber(null, null, -1);
assertNotNull(e);
}
</pre></div><p>This snippet comprises the usual<code class="literal"> setup()</code> and<code class="literal"> tearDown()</code> methods followed by the<code class="literal"> testPreconditions()</code> test. In the<code class="literal"> setUp()</code> method we created an<code class="literal"> EditNumber</code> with a null context and then we set it as focusable:<a class="indexterm" id="id539"/>
</p><div><pre class="programlisting">/**
* Test method for {@link com.example.aatg.tc.EditNumber#clear()}.
*/
@Test
public final void testClear() {
final String value = "123.45";
mEditNumber.setText(value);
mEditNumber.clear();
String expectedString = "";
String actualString = mEditNumber.getText().toString();
assertEquals(expectedString, actualString);
}
/**
* Test method for {@link com.example.aatg.tc.EditNumber# setNumber(double)}.
*/
@Test
public final void testSetNumber() {
mEditNumber.setNumber(123.45);
final String expected = "123.45";
final String actual = mEditNumber.getText().toString();
assertEquals(expected, actual);
}
/**
* Test method for {@link com.example.aatg.tc.EditNumber# getNumber()}.
*/
@Test
public final void testGetNumber() {
mEditNumber.setNumber(123.45);
final double expected = 123.45;
final double actual = mEditNumber.getNumber();<strong>
assertEquals(expected, actual, DELTA);</strong>
}
}
</pre></div><p>In this last snippet we have the basic tests which are the same as the<code class="literal"> EditNumber</code> tests of our previous examples.</p><p>We are highlighting the most important changes. The first one is to specify the test runner JUnit will delegate the processing of the tests to, by using the annotation<code class="literal"> @RunWith</code>. In this case we need to use<code class="literal"> RobolectricTestRunner.class</code> as the runner. Then we create an<code class="literal"> EditText</code> using a null<code class="literal"> Context</code> as this is a class that cannot be instantiated. Finally, a<code class="literal"> DELTA</code> value is specified in<code class="literal"> testGetNumber</code> as<code class="literal"> assertEquals</code> since the floating point number requires it in JUnit 4. Additionally we added the<code class="literal"> @Test</code> annotation to mark the method as tests.</p><p>The other test methods that existed in the original<code class="literal"> EditNumberTests</code> cannot be implemented or simply fail for a variety of reasons. For example, as we mentioned before, Robolectric classes return default values, like<code class="literal"> null, 0, false</code>, and so on, and this is the case for<code class="literal"> Editable.Factory.getInstance()</code> which returns null and causes the test to fail; because there is no other way of creating an<code class="literal"> Editable</code> object we are at a dead end.</p><p>Similarly, the<code class="literal"> InputFilter</code> that<code class="literal"> EditNumber</code> sets is non functional. It is futile to create a test that expects some behavior.</p><p>The alternative to these shortcomings would be to create<code class="literal"> Shadow</code> classes but this requires alteration of the Robolectric source and the creation of<code class="literal"> Robolectric.shadowOf()</code> methods. This procedure is described in the documentation that you may follow if you are interested in applying this approach to your tests.<a class="indexterm" id="id540"/>
</p><p>Before being able to run your tests you need to create symbolic links for<code class="literal"> TemperatureConverter</code> project's<code class="literal"> AndroidManifest.xml</code> and resources which are used by Robolectric.</p><div><pre class="programlisting"><strong>$ cd ~/workspace/TemperatureConverterJVMTests
$ ln -s ../TemperatureConverter/AndroidManifest.xml
$ ln -s ../TemperatureConverter/res . # note the dot at the end</strong>
</pre></div><p>Having identified these issues we can proceed to run the tests from inside Eclipse and they will run in the host's JVM with no need to start or communicate with an emulator or device.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec07"/>Summary</h1></div></div></div><p>This chapter has been a little more involved than previous ones, with the sole intention of facing realistic situations and state-of-the-art Android testing.</p><p>We started analyzing the requirements and steps to build Android from source. This measure is needed to be able to activate code coverage through EMMA, which we did and later on we ran our tests obtaining a detailed code coverage analysis report.</p><p>We then used this report to improve our tests and we created some to cover areas we were not aware that have not been tested. This led us to better tests and in some cases improved the design of the project under test.</p><p>We introduced Robotium, a very useful tool to ease the creation of test cases for our Android applications and we improved some tests with it.</p><p>Then we analyzed one of the hottest topics on Android testing as it is testing on the development host JVM optimizing and reducing considerably the time needed to run the tests, something that is highly desirable when we are applying Test Driven Development to our process. Within this scope, we analyzed JUnit 4 and Robolectric and created some tests as demonstrations and to get you started on these techniques.</p><p>We have reached the end of this journey through the available methods and tools to Android testing. You should now be much better prepared to start applying this to your own projects. The results will be visible as soon as you begin to use them.</p><p>Finally, I hope that you have enjoyed reading this book as much as I did writing it.</p><p>Happy testing!</p></div></body></html>