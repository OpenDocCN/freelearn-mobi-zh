["```kt\n$ ls system-images/android-25/default/x86\nbuild.prop   kernel-ranchu  ramdisk.img        system.img\nkernel-qemu  NOTICE.txt     source.properties  userdata.img  \n\n```", "```kt\nroot@x86emu:/ # mount\nrootfs / rootfs ro,seclabel,relatime 0 0\ntmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0\ndevpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0\nproc /proc proc rw,relatime 0 0\nsysfs /sys sysfs rw,seclabel,relatime 0 0\nselinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0\ndebugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0\nnone /acct cgroup rw,relatime,cpuacct 0 0\nnone /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0\ntmpfs /mnt tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0\nnone /dev/cpuctl cgroup rw,relatime,cpu 0 0\n/dev/block/vda /system ext4 ro,seclabel,relatime,data=ordered 0 0\n/dev/block/vdb /cache ext4 rw,seclabel,nosuid,nodev,noatime,errors=panic,data=ordered 0 0\n/dev/block/vdc /data ext4 rw,seclabel,nosuid,nodev,noatime,errors=panic,data=ordered 0 0\n...  \n\n```", "```kt\n/dev/block/by-name/misc    /misc    emmc    defaults    defaults  \n\n```", "```kt\nstruct bootloader_message { \n    char command[32]; \n    char status[32]; \n    char recovery[768]; \n    char stage[32]; \n    char reserved[224]; \n}; \n\n```", "```kt\nint \nmain(int argc, char **argv) { \n    time_t start = time(NULL); \n\n    redirect_stdio(TEMPORARY_LOG_FILE); \n\n    ... \n    if (argc == 2 && strcmp(argv[1], \"--adbd\") == 0) { \n        adb_main(0, DEFAULT_ADB_PORT); \n        return 0; \n    } \n\n    printf(\"Starting recovery (pid %d) on %s\", getpid(), \n    ctime(&start)); \n\n    load_volume_table(); \n    get_args(&argc, &argv); \n\n    ... \n    ui->Print(\"Supported API: %d\\n\", RECOVERY_API_VERSION); \n\n    int status = INSTALL_SUCCESS; \n\n    if (update_package != NULL) { \n        status = install_package(update_package, &should_wipe_cache, \n        TEMPORARY_INSTALL_FILE, true); \n        if (status == INSTALL_SUCCESS && should_wipe_cache) { \n            wipe_cache(false, device); \n        } \n    ... \n    } else if (should_wipe_data) { \n        if (!wipe_data(false, device)) { \n            status = INSTALL_ERROR; \n        } \n    } else if (should_wipe_cache) { \n        if (!wipe_cache(false, device)) { \n            status = INSTALL_ERROR; \n        } \n    } else if (sideload) { \n    ... \n    Device::BuiltinAction after = shutdown_after ? Device::SHUTDOWN : \n    Device::REBOOT; \n    if ((status != INSTALL_SUCCESS && !sideload_auto_reboot) || ui-\n    >IsTextVisible()) { \n        Device::BuiltinAction temp = prompt_and_wait(device, status); \n        if (temp != Device::NO_ACTION) { \n            after = temp; \n        } \n    } \n\n    // Save logs and clean up before rebooting or shutting down. \n    finish_recovery(send_intent); \n\n    switch (after) { \n        case Device::SHUTDOWN: \n            ui->Print(\"Shutting down...\\n\"); \n            property_set(ANDROID_RB_PROPERTY, \"shutdown,\"); \n            break; \n\n        case Device::REBOOT_BOOTLOADER: \n            ui->Print(\"Rebooting to bootloader...\\n\"); \n            property_set(ANDROID_RB_PROPERTY, \"reboot,bootloader\"); \n            break; \n\n        default: \n            ui->Print(\"Rebooting...\\n\"); \n            property_set(ANDROID_RB_PROPERTY, \"reboot,\"); \n            break; \n    } \n    sleep(5); // should reboot before this finishes \n    return EXIT_SUCCESS; \n} \n\n```", "```kt\nstatic void \nget_args(int *argc, char ***argv) { \n    struct bootloader_message boot; \n    memset(&boot, 0, sizeof(boot)); \n    get_bootloader_message(&boot);  // this may fail, leaving a zeroed \n                                    //structure \n    stage = strndup(boot.stage, sizeof(boot.stage)); \n    ... \n\n```", "```kt\nif (*argc <= 1) { \n    boot.recovery[sizeof(boot.recovery) - 1] = '\\0'; \n    const char *arg = strtok(boot.recovery, \"\\n\"); \n    if (arg != NULL && !strcmp(arg, \"recovery\")) { \n        *argv = (char **) malloc(sizeof(char *) * MAX_ARGS); \n        (*argv)[0] = strdup(arg); \n        for (*argc = 1; *argc < MAX_ARGS; ++*argc) { \n            if ((arg = strtok(NULL, \"\\n\")) == NULL) break; \n            (*argv)[*argc] = strdup(arg); \n        } \n        LOGI(\"Got arguments from boot message\\n\"); \n    } else if (boot.recovery[0] != 0 && boot.recovery[0] != 255) { \n        LOGE(\"Bad boot message\\n\\\"%.20s\\\"\\n\", boot.recovery); \n    } \n} \n\n```", "```kt\nif (*argc <= 1) { \n    FILE *fp = fopen_path(COMMAND_FILE, \"r\"); \n    if (fp != NULL) { \n        char *token; \n        char *argv0 = (*argv)[0]; \n        *argv = (char **) malloc(sizeof(char *) * MAX_ARGS); \n        (*argv)[0] = argv0;  // use the same program name \n\n        char buf[MAX_ARG_LENGTH]; \n        for (*argc = 1; *argc < MAX_ARGS; ++*argc) { \n            if (!fgets(buf, sizeof(buf), fp)) break; \n            token = strtok(buf, \"\\r\\n\"); \n            if (token != NULL) { \n                (*argv)[*argc] = strdup(token); \n            } else { \n                --*argc; \n            } \n        } \n\n        check_and_fclose(fp, COMMAND_FILE); \n        LOGI(\"Got arguments from %s\\n\", COMMAND_FILE); \n    } \n} \n\n```", "```kt\nstrlcpy(boot.command, \"boot-recovery\", sizeof(boot.command)); \nstrlcpy(boot.recovery, \"recovery\\n\", sizeof(boot.recovery)); \nint i; \nfor (i = 1; i < *argc; ++i) { \n    strlcat(boot.recovery, (*argv)[i], sizeof(boot.recovery)); \n    strlcat(boot.recovery, \"\\n\", sizeof(boot.recovery)); \n} \nset_bootloader_message(&boot); \n\n```", "```kt\nint get_bootloader_message(struct bootloader_message *out) { \n    Volume* v = volume_for_path(\"/misc\"); \n    if (v == NULL) { \n      LOGE(\"Cannot load volume /misc!\\n\"); \n      return -1; \n    } \n    if (strcmp(v->fs_type, \"mtd\") == 0) { \n        return get_bootloader_message_mtd(out, v); \n    } else if (strcmp(v->fs_type, \"emmc\") == 0) { \n        return get_bootloader_message_block(out, v); \n    } \n    LOGE(\"unknown misc partition fs_type \\\"%s\\\"\\n\", v->fs_type); \n    return -1; \n} \n\n```", "```kt\nstatic int get_bootloader_message_block(struct bootloader_message *out, \nconst Volume* v) { \n    wait_for_device(v->blk_device); \n    FILE* f = fopen(v->blk_device, \"rb\"); \n    if (f == NULL) { \n        LOGE(\"Can't open %s\\n(%s)\\n\", v->blk_device, strerror(errno)); \n        return -1; \n    } \n    struct bootloader_message temp; \n    int count = fread(&temp, sizeof(temp), 1, f); \n    if (count != 1) { \n        LOGE(\"Failed reading %s\\n(%s)\\n\", v->blk_device, \n        strerror(errno)); \n        return -1; \n    } \n    if (fclose(f) != 0) { \n        LOGE(\"Failed closing %s\\n(%s)\\n\", v->blk_device, \n        strerror(errno)); \n        return -1; \n    } \n    memcpy(out, &temp, sizeof(temp)); \n    return 0; \n} \n\n```", "```kt\nstatic void \nfinish_recovery(const char *send_intent) { \n    // By this point, we're ready to return to the main system... \n    if (send_intent != NULL) { \n        FILE *fp = fopen_path(INTENT_FILE, \"w\"); \n        if (fp == NULL) { \n            LOGE(\"Can't open %s\\n\", INTENT_FILE); \n        } else { \n            fputs(send_intent, fp); \n            check_and_fclose(fp, INTENT_FILE); \n        } \n    } \n\n    if (locale != NULL) { \n        LOGI(\"Saving locale \\\"%s\\\"\\n\", locale); \n        FILE* fp = fopen_path(LOCALE_FILE, \"w\"); \n        fwrite(locale, 1, strlen(locale), fp); \n        fflush(fp); \n        fsync(fileno(fp)); \n        check_and_fclose(fp, LOCALE_FILE); \n    } \n\n    copy_logs(); \n\n    struct bootloader_message boot; \n    memset(&boot, 0, sizeof(boot)); \n    set_bootloader_message(&boot); \n\n    if (ensure_path_mounted(COMMAND_FILE) != 0 || \n        (unlink(COMMAND_FILE) && errno != ENOENT)) { \n        LOGW(\"Can't unlink %s\\n\", COMMAND_FILE); \n    } \n\n    ensure_path_unmounted(CACHE_ROOT); \n    sync();  // For good measure. \n} \n\n```", "```kt\nint \ninstall_package(const char* path, bool* wipe_cache, const char* install_file, bool needs_mount) \n{ \n    modified_flash = true; \n\n    FILE* install_log = fopen_path(install_file, \"w\"); \n    if (install_log) { \n        fputs(path, install_log); \n        fputc('\\n', install_log); \n    } else { \n        LOGE(\"failed to open last_install: %s\\n\", strerror(errno)); \n    } \n    int result; \n    if (setup_install_mounts() != 0) { \n        LOGE(\"failed to set up expected mounts for install; \n        aborting\\n\"); \n        result = INSTALL_ERROR; \n    } else { \n        result = really_install_package(path, wipe_cache, needs_mount); \n    } \n    if (install_log) { \n        fputc(result == INSTALL_SUCCESS ? '1' : '0', install_log); \n        fputc('\\n', install_log); \n        fclose(install_log); \n    } \n    return result; \n} \n\n```", "```kt\nstatic int \nreally_install_package(const char *path, bool* wipe_cache, bool needs_mount) \n{ \n    ui->SetBackground(RecoveryUI::INSTALLING_UPDATE); \n    ... \n\n    MemMapping map; \n    if (sysMapFile(path, &map) != 0) { \n        LOGE(\"failed to map file\\n\"); \n        return INSTALL_CORRUPT; \n    } \n\n    int numKeys; \n    Certificate* loadedKeys = load_keys(PUBLIC_KEYS_FILE, &numKeys); \n    if (loadedKeys == NULL) { \n        LOGE(\"Failed to load keys\\n\"); \n        return INSTALL_CORRUPT; \n    } \n    LOGI(\"%d key(s) loaded from %s\\n\", numKeys, PUBLIC_KEYS_FILE); \n\n    ui->Print(\"Verifying update package...\\n\"); \n\n    int err; \n    err = verify_file(map.addr, map.length, loadedKeys, numKeys); \n    free(loadedKeys); \n    LOGI(\"verify_file returned %d\\n\", err); \n    if (err != VERIFY_SUCCESS) { \n        LOGE(\"signature verification failed\\n\"); \n        sysReleaseMap(&map); \n        return INSTALL_CORRUPT; \n    } \n\n    /* Try to open the package. \n     */ \n    ZipArchive zip; \n    err = mzOpenZipArchive(map.addr, map.length, &zip); \n    if (err != 0) { \n        LOGE(\"Can't open %s\\n(%s)\\n\", path, err != -1 ? strerror(err) : \n        \"bad\"); \n        sysReleaseMap(&map); \n        return INSTALL_CORRUPT; \n    } \n\n    /* Verify and install the contents of the package. \n     */ \n    ui->Print(\"Installing update...\\n\"); \n    ui->SetEnableReboot(false); \n    int result = try_update_binary(path, &zip, wipe_cache); \n    ui->SetEnableReboot(true); \n    ui->Print(\"\\n\"); \n\n    sysReleaseMap(&map); \n\n    return result; \n} \n\n```", "```kt\nstatic int \ntry_update_binary(const char* path, ZipArchive* zip, bool* wipe_cache) { \n    const ZipEntry* binary_entry = \n            mzFindZipEntry(zip, ASSUMED_UPDATE_BINARY_NAME); \n    if (binary_entry == NULL) { \n        mzCloseZipArchive(zip); \n        return INSTALL_CORRUPT; \n    } \n\n    const char* binary = \"/tmp/update_binary\"; \n    unlink(binary); \n    int fd = creat(binary, 0755); \n    if (fd < 0) { \n        mzCloseZipArchive(zip); \n        LOGE(\"Can't make %s\\n\", binary); \n        return INSTALL_ERROR; \n    } \n    bool ok = mzExtractZipEntryToFile(zip, binary_entry, fd); \n    close(fd); \n    mzCloseZipArchive(zip); \n\n    if (!ok) { \n        LOGE(\"Can't copy %s\\n\", ASSUMED_UPDATE_BINARY_NAME); \n        return INSTALL_ERROR; \n    } \n\n```", "```kt\nint pipefd[2]; \npipe(pipefd); \nconst char** args = (const char**)malloc(sizeof(char*) * 5); \nargs[0] = binary; \nargs[1] = EXPAND(RECOVERY_API_VERSION);   // defined in Android.mk \nchar* temp = (char*)malloc(10); \nsprintf(temp, \"%d\", pipefd[1]); \nargs[2] = temp; \nargs[3] = (char*)path; \nargs[4] = NULL; \n\npid_t pid = fork(); \nif (pid == 0) { \n    umask(022); \n    close(pipefd[0]); \n    execv(binary, (char* const*)args); \n    fprintf(stdout, \"E:Can't run %s (%s)\\n\", binary, strerror(errno)); \n    _exit(-1); \n} \n\n```", "```kt\n    close(pipefd[1]); \n\n    *wipe_cache = false; \n\n    char buffer[1024]; \n    FILE* from_child = fdopen(pipefd[0], \"r\"); \n    while (fgets(buffer, sizeof(buffer), from_child) != NULL) { \n        char* command = strtok(buffer, \" \\n\"); \n        if (command == NULL) { \n            continue; \n        } else if (strcmp(command, \"progress\") == 0) { \n            char* fraction_s = strtok(NULL, \" \\n\"); \n            char* seconds_s = strtok(NULL, \" \\n\"); \n\n            float fraction = strtof(fraction_s, NULL); \n            int seconds = strtol(seconds_s, NULL, 10); \n\n            ui->ShowProgress(fraction * (1-VERIFICATION_PROGRESS_FRACTION), \n            seconds); \n        } else if (strcmp(command, \"set_progress\") == 0) { \n            char* fraction_s = strtok(NULL, \" \\n\"); \n            float fraction = strtof(fraction_s, NULL); \n            ui->SetProgress(fraction); \n        } else if (strcmp(command, \"ui_print\") == 0) { \n            char* str = strtok(NULL, \"\\n\"); \n            if (str) { \n                ui->Print(\"%s\", str); \n            } else { \n                ui->Print(\"\\n\"); \n            } \n            fflush(stdout); \n        } else if (strcmp(command, \"wipe_cache\") == 0) { \n            *wipe_cache = true; \n        } else if (strcmp(command, \"clear_display\") == 0) { \n            ui->SetBackground(RecoveryUI::NONE); \n        } else if (strcmp(command, \"enable_reboot\") == 0) { \n            ui->SetEnableReboot(true); \n        } else { \n            LOGE(\"unknown command [%s]\\n\", command); \n       } \n    } \n    fclose(from_child); \n\n    int status; \n    waitpid(pid, &status, 0); \n    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) { \n       LOGE(\"Error in %s\\n(Status %d)\\n\", path, WEXITSTATUS(status)); \n       return INSTALL_ERROR; \n    } \n\n```", "```kt\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<manifest> \n\n  <remote  name=\"github\" \n           revision=\"refs/tags/android-7.1.1_r4_x86vbox_ch12_r1\" \n           fetch=\".\" /> \n\n  <remote  name=\"aosp\" \n           fetch=\"https://android.googlesource.com/\" /> \n  <default revision=\"refs/tags/android-7.1.1_r4\" \n           remote=\"aosp\" \n           sync-c=\"true\" \n           sync-j=\"1\" /> \n\n  ... \n  <project path=\"bootable/newinstaller\" \n  name=\"platform_bootable_newinstaller\" remote=\"github\" /> \n  <project path=\"device/generic/common\" name=\"device_generic_common\" \n  groups=\"pdk\" remote=\"github\" /> \n  <project path=\"device/generic/x86vbox\" name=\"x86vbox\" remote=\"github\" \n  /> \n  <project path=\"bootable/recovery\" name=\"android_bootable_recovery\" \n  remote=\"github\" groups=\"pdk\" /> \n  ... \n\n```", "```kt\n$ repo init -u https://github.com/shugaoye/manifests -b android-7.1.1_r4_ch12_aosp\n$ repo sync \n\n```", "```kt\n$ source build/envsetup.sh\n$ lunch x86vbox-eng\n$ make -j4\n\n```", "```kt\n$ make initrd USE_SQUASHFS=0 \n\n```", "```kt\n$ ls *.mk\nAndroidProducts.mk  BoardConfig.mk  x86vbox.mk  \n\n```", "```kt\nPRODUCT_COPY_FILES += \\ \n... \ndevice/generic/x86vbox/recovery.fstab:recovery/root/etc/recovery.fstab \\    device/generic/x86vbox/recovery/root/init.recovery.x86vbox.rc:root/init.recovery.x86vbox.rc \\    device/generic/x86vbox/recovery/root/sbin/network_start.sh:recovery/root/sbin/network_start.sh \\    device/generic/x86vbox/recovery/root/sbin/create_partitions.sh:recovery/root/sbin/create_partitions.sh \\ \n... \n\n```", "```kt\non init \n    exec -- /system/bin/logwrapper /system/bin/sh /system/etc/init.sh \n\nservice network_start /sbin/network_start.sh \n    user root \n    seclabel u:r:recovery:s0 \n    oneshot \n\nservice console /system/bin/sh \n    class core \n    console \n    disabled \n    user shell \n    group shell log \n    seclabel u:r:shell:s0 \n\non property:ro.debuggable=1 \n    start console \n\n```", "```kt\n/dev/block/sda1 /system  ext4  ro          wait \n/dev/block/sda2 /data    ext4  noatime,... wait \n/dev/block/sda3 /sdcard  vfat  defaults    voldmanaged=sdcard:auto \n/dev/block/sda5 /cache   ext4  noatime,... wait \n/dev/block/sda6 /misc    emmc  defaults    defaults \n/dev/block/sda7 /recovery emmc defaults    defaults \n\n```", "```kt\n/dev/block/sda3  /sdcard  vfat  defaults  voldmanaged=sdcard:auto \n/dev/block/sda5  /cache   ext4  noatime,... wait \n\n```", "```kt\nTARGET_NO_KERNEL := false \nTARGET_NO_RECOVERY := false \n\n```", "```kt\n# Double buffer cannot work well on virtualbox \nRECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER := true \n\n```", "```kt\nifeq ($(RECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER), true) \nLOCAL_CFLAGS += -DRECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER \nendif \n\n```", "```kt\n... \n    /* check if we can use double buffering */ \n#ifndef RECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER \n    if (vi.yres * fi.line_length * 2 <= fi.smem_len) { \n        double_buffered = true; \n\n        memcpy(gr_framebuffer+1, gr_framebuffer, sizeof(GRSurface)); \n        gr_framebuffer[1].data = gr_framebuffer[0].data + \n            gr_framebuffer[0].height * gr_framebuffer[0].row_bytes; \n\n        gr_draw = gr_framebuffer+1; \n\n    } else { \n#else \n    { \n        printf(\"RECOVERY_GRAPHICS_FORCE_SINGLE_BUFFER := true\\n\"); \n#endif \n        double_buffered = false; \n\n        gr_draw = (GRSurface*) malloc(sizeof(GRSurface)); \n        memcpy(gr_draw, gr_framebuffer, sizeof(GRSurface)); \n        gr_draw->data = (unsigned char*) malloc(gr_draw->height * \n        gr_draw->row_bytes); \n        if (!gr_draw->data) { \n            perror(\"failed to allocate in-memory surface\"); \n            return NULL; \n        } \n    }  \n... \n\n```", "```kt\nfind_ramdisk() \n{ \n   busybox mount /dev/sda5 /hd \n   if [ ! -e /hd/recovery/command ]; then \n         busybox umount /hd \n         if [ \"$RECOVERY\" = \"1\" ]; then \n               RAMDISK=/mnt/$SRC/ramdisk-recovery.img \n         else \n               RAMDISK=/mnt/$SRC/ramdisk.img \n         fi \n   else \n         busybox umount /hd \n         RAMDISK=/mnt/$SRC/ramdisk-recovery.img \n         return \n   fi \n   echo boot using $RAMDISK ... \n} \n\n```", "```kt\n... \n   zcat $RAMDISK | cpio -id > /dev/null  \n... \n\n```"]