- en: Chapter 2. Building Blocks – Variables, Collections, and Flow Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 构建块 – 变量、集合和流程控制
- en: One of the coolest things about programming is the way that concepts build on
    each other. If you've never programmed anything before, even the most basic app
    can seem very complex. The reality is that, if you analyze everything going on
    in an app down to the ones and zeros flowing through the processor, it is incredibly
    complex. However, every aspect of using a computer is an abstraction. When you
    use an app, the complexity of the programming is being abstracted away for you.
    Learning to program is just going one level deeper in making a computer work for
    you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中最酷的事情之一是概念是如何相互构建的。如果你以前从未编写过任何程序，即使是功能最基本的应用程序也可能看起来非常复杂。现实是，如果你将应用程序中发生的一切分析到处理器中流动的零和一，它是非常复杂的。然而，使用计算机的每个方面都是一个抽象。当你使用应用程序时，编程的复杂性正在为你抽象化。学习编程就是深入一层，让计算机为你工作。
- en: As you learn the basic concepts behind programming, they will become second
    nature and this will free your mind to grasp even more complex concepts. When
    you first learn to read, sounding out each word is challenging. However, eventually,
    you reach a level where you glance at a word and you know the meaning instantaneously.
    This frees you up to start looking for deeper meaning from the text.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你学习编程背后的基本概念，它们将变得像第二本能一样自然，这将使你的思想能够把握更复杂的概念。当你第一次学习阅读时，逐个发音每个单词是具有挑战性的。然而，最终你会达到一个水平，你只需瞥一眼一个单词，就能立刻知道它的意思。这让你能够开始从文本中寻找更深层次的意义。
- en: In this chapter, we will build up your knowledge of the building blocks of programming
    in Swift. Each of these building blocks is exciting on its own and they will become
    even more exciting as we start to see the possibilities they open up. No matter
    how complex programming might seem to you now, I guarantee that one day you will
    look back and marvel at how all of these concepts have become second nature.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建你在Swift中编程构建块的知识。每个构建块本身都很有趣，随着我们开始看到它们开启的可能性，它们将变得更加有趣。无论编程现在对你来说可能多么复杂，我保证有一天你会回过头来，惊叹于所有这些概念是如何变得像第二本能一样的。
- en: 'In this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Core Swift types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心Swift类型
- en: Swift's type system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift的类型系统
- en: Printing to the console
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印到控制台
- en: Controlling the flow of your program
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制程序流程
- en: A comprehensive example of all concepts covered
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有涵盖概念的综合示例
- en: Core Swift types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心Swift类型
- en: Every programming language needs to name a piece of information so that it can
    be referenced later. This is the fundamental way in which code remains readable
    after it is written. Swift provides a number of core types that help you represent
    your information in a very comprehensible way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都需要命名信息的一部分，以便以后可以引用它。这是代码在编写后保持可读性的基本方法。Swift提供了一系列核心类型，帮助你以非常易于理解的方式表示你的信息。
- en: Constants and variables
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常数和变量
- en: 'Swift provides two types of information: a **constant** and a **variable:**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了两种类型的信息：**常数**和**变量**：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All constants are defined using the `let` keyword followed by a name, and all
    variables are defined using the `var` keyword. Both constants and variables in
    Swift must contain a value before they are used. This means that, when you define
    a new one, you will most likely give it an initial value. You do so by using the
    assignment operator (`=`) followed by a value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有常数都是使用 `let` 关键字后跟一个名称来定义的，所有变量都是使用 `var` 关键字来定义的。Swift中的常数和变量在使用之前必须包含一个值。这意味着，当你定义一个新的时，你很可能会给它一个初始值。你是通过使用赋值运算符（`=`）后跟一个值来做到这一点的。
- en: The only difference between the two is that a constant can never be changed,
    whereas a variable can be. In the preceding example, the code defines a constant
    called `pi` that stores the information `3.14` and a variable called `name` that
    stores the information `"Sarah"`. It makes sense to make `pi` a constant because
    `pi` will always be `3.14`. However, we need to change the value of `name` in
    the future so we defined it as a variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两个之间的唯一区别是常数永远不能改变，而变量可以改变。在先前的例子中，代码定义了一个名为 `pi` 的常数，它存储了信息 `3.14`，以及一个名为 `name`
    的变量，它存储了信息 `"Sarah"`。将 `pi` 定义为常数是有意义的，因为 `pi` 将始终是 `3.14`。然而，我们需要在未来更改 `name`
    的值，所以我们将其定义为变量。
- en: One of the hardest parts of managing a program is the state of all the variables.
    As a programmer, it is often impossible to calculate all the different possible
    values a variable might have, even in relatively small programs. Since variables
    can often be changed by distant, seemingly unrelated code, more states will cause
    more bugs that are harder to track down. It is always best to default to using
    constants until you run into a practical scenario in which you need to modify
    the value of the information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 管理程序中最困难的部分之一是所有变量的状态。作为程序员，即使在相对较小的程序中，通常也不可能计算出变量可能具有的所有不同值。由于变量通常可以被遥远的、看似无关的代码更改，更多的状态会导致更多难以追踪的bug。始终最好默认使用常量，直到您遇到需要修改信息值的实际场景。
- en: Containers
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: It is often helpful to give a name to more complex information. We often have
    to deal with a collection of related information or a series of similar information
    like lists. Swift provides three main collection types called **tuples**, **arrays**,
    and **dictionaries**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 给更复杂的信息命名通常很有帮助。我们经常必须处理一系列相关的信息或一系列类似的信息，如列表。Swift提供了三种主要的集合类型，称为**元组**、**数组**和**字典**。
- en: Tuples
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'A tuple is a fixed sized collection of two or more pieces of information. For
    example, a card in a deck of playing cards has three properties: `color`, `suit`,
    and `value`. We could use three separate variables to fully describe a card, but
    it would be better to express it in one:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是由两个或更多信息片段组成的固定大小集合。例如，一副扑克牌中的一张牌有三个属性：`颜色`、`花色`和`数值`。我们可以使用三个单独的变量来完全描述一张牌，但最好在一个表达式中表达它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each piece of information consists of a name and a value separated by a colon
    (`:`) and each is separated by a comma (`,`). Finally, the whole thing is surrounded
    by parentheses (`()`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每条信息由一个名称和一个值组成，名称和值之间用冒号(`:`)分隔，每个值之间用逗号(`,`)分隔。最后，整个结构被括号(`()`)包围。
- en: 'Each part of a tuple can be accessed separately by name using a period (`.`),
    otherwise referred to as a dot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用点(`.`)通过名称单独访问元组的每个部分，这通常被称为点：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You are also able to create a tuple with no names for each part of it. You
    can then access them based on where they are in the list, starting with zero as
    the first element:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为每个部分创建一个没有名称的元组。然后，您可以根据它们在列表中的位置访问它们，从零开始作为第一个元素：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another way to access specific values in a tuple is to capture each of them
    in a separate variable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 访问元组中的特定值的另一种方法是分别捕获每个值：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to change a value in a tuple, you can assign every value at once
    or you can update a single value, using the same reference as in the preceding
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在元组中更改一个值，您可以一次分配所有值，或者可以使用与前面代码相同的引用更新单个值：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Arrays
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is essentially a list of information of variable length. For example,
    we could create a list of people we want to invite to a party, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数组本质上是一个可变长度的信息列表。例如，我们可以创建一个列表，列出我们想要邀请参加派对的人，如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An array always starts and ends with a square bracket and each element is separated
    by a comma. You can even declare an empty array with open and closing brackets:
    `[]`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数组始终以方括号开始和结束，每个元素之间用逗号分隔。您甚至可以使用开闭括号声明一个空数组：`[]`。
- en: 'You can then add values to an array by adding another array to it, like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向数组中添加另一个数组来向数组中添加值，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that `+=` is the shorthand for the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`+=`是以下内容的缩写：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can access values in an array based on their position, usually referred
    to as their index, as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据数组中元素的索引位置访问数组中的值，通常称为索引，如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The index is specified using square brackets (`[]`) immediately after the name
    of the array. Indexes start at `0` and go up from there like tuples. So, in the
    preceding example, index `2` returned the third element in the array, `Marcos`.
    There is additional information you can retrieve about an array, like the number
    of elements that you can see as we move forward.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是通过在数组名称后立即使用方括号(`[]`)来指定的。索引从`0`开始，像元组一样向上递增。因此，在前面的例子中，索引`2`返回了数组中的第三个元素，`Marcos`。您还可以检索有关数组的其他信息，例如随着我们向前移动可以看到的元素数量。
- en: Dictionaries
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'A dictionary is a collection of **keys** and **values**. Keys are used to store
    and look up specific values in the container. This container type is named after
    a word dictionary in which you can look up the definition of a word. In that real
    life example, the word would be the key and the definition would be the value.
    As an example, we can define a dictionary of television shows organized by their
    genre:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一组**键**和**值**的集合。键用于在容器中存储和查找特定的值。这种容器类型以单词“dictionary”命名，你可以在其中查找单词的定义。在那个现实生活中的例子中，单词将是键，定义将是值。作为一个例子，我们可以定义一个按类型组织的电视节目字典：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A dictionary looks similar to an array but each key and value is separated by
    a colon (`:`). Note that Swift is pretty forgiving with how whitespace is used.
    The array could be defined with each element on its own line and the dictionary
    could be defined with every element on a single line. It is up to you to use whitespace
    to make your code as readable as possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 字典看起来与数组相似，但每个键和值都由冒号（`:`）分隔。请注意，Swift对空白的使用相当宽容。数组可以定义为每个元素单独一行，字典可以定义为每行包含一个元素。使用空白来使你的代码尽可能可读是你的责任。
- en: 'With the dictionary defined as shown above, you would get the value `Modern
    Family` if you looked up the key `Comedy`. You access a value in code similar
    to how you would in an array but, instead of providing an index in the square
    brackets, you provide the key:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示定义的字典，如果你查找键`Comedy`，你会得到值`Modern Family`。在代码中访问值的方式类似于在数组中，但你不是在方括号中提供索引，而是提供键：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can define an empty dictionary in a similar way to an empty array but with
    a dictionary you must also include a colon between the brackets: `[:]`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像定义空数组一样定义一个空字典，但使用字典时，你必须在括号之间包含一个冒号：`[:]`。
- en: 'Adding a value to a dictionary is similar to retrieving a value but you use
    the assignment operator (`=`):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加值的方式类似于检索值，但你使用赋值运算符（`=`）：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a bonus, this can also be used to change the value for an existing key.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，这也可以用来更改现有键的值。
- en: You might have noticed that all of my variable and constant names begin with
    a lower case letter and each subsequent word starts with a capital letter. This
    is called camel case and it is the widely accepted way of writing variable and
    constant names. Following this convention makes it easier for other programmers
    to understand your code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我所有的变量和常量名称都以小写字母开头，并且每个后续单词都以大写字母开头。这被称为驼峰式命名法，并且是编写变量和常量名称的广泛接受的方式。遵循此约定使得其他程序员更容易理解你的代码。
- en: Now that we know about Swift's basic containers, let's explore what they are
    in a little more detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Swift的基本容器，让我们更详细地探讨它们是什么。
- en: Swift's type system
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift的类型系统
- en: Swift is a strongly typed language, which means that every constant and variable
    is defined with a specific **type**. Only values of matching types can be assigned
    to them. So far, we have taken advantage of a feature of Swift called **Type Inference.**
    This means that the code does not have to explicitly declare a type if it can
    be inferred from the value being assigned to it during the declaration.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是一种强类型语言，这意味着每个常量和变量都使用特定的**类型**进行定义。只有匹配类型的值可以分配给它们。到目前为止，我们已经利用了Swift的一个名为**类型推断**的功能。这意味着如果可以在声明时从分配给它的值中推断出类型，则代码不需要显式声明类型。
- en: 'Without Type Inference, the `name` variable declaration from before would be
    written as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类型推断的情况下，之前的`name`变量声明将写成如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code is explicitly declaring `name` as the type `String` with the value
    `Sarah`. A constant or variable's type can be specified by adding a colon (`:`)
    and a type after its name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码明确地将`name`声明为类型`String`，其值为`Sarah`。可以通过在名称后添加一个冒号（`:`）和类型来指定常量或变量的类型。
- en: A string is defined by a series of characters. This is perfect for storing text,
    as in our name example. The reason that we don't need to specify the type is that
    `Sarah` is a **string literal**. Text surrounded by quotation marks is a string
    literal and can be inferred to be of the type `String`. That means that `name`
    must be of the type `String` if you make its initial value `Sarah`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串由一系列字符组成。这对于存储文本来说非常完美，就像我们名称的例子一样。我们不需要指定类型的原因是`Sarah`是一个**字符串字面量**。被引号包围的文本是字符串字面量，可以推断其类型为`String`。这意味着如果你将其初始值设置为`Sarah`，则`name`必须为`String`类型。
- en: 'Similarly, if we had not used type inference for our other variable declarations,
    they would look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们没有为其他变量声明使用类型推断，它们看起来会是这样：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Double` is a numeric type that can store decimal numbers. An array''s type
    is declared by putting the type of element it stores in square brackets. Finally,
    a dictionary''s type is defined in the form `[KeyType:ValueType]`. All of these
    types can be inferred because each of them is assigned to a value that has an
    inferable type.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Double`是一种可以存储小数的数值类型。数组的类型通过将存储的元素类型放在方括号中来声明。最后，字典的类型以`[KeyType:ValueType]`的形式定义。所有这些类型都可以推断，因为每个类型都被分配了一个具有可推断类型的值。'
- en: 'The code is much cleaner and easier to understand if we leave the types out
    as the original examples showed. Just keep in mind that these types are always
    implied to be there, even if they are not written explicitly. If we tried to assign
    a number to the `name` variable, we would get an error, as shown:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像原始示例那样省略类型，代码会更干净、更容易理解。只需记住，这些类型始终隐含存在，即使它们没有明确写出。如果我们尝试将一个数字赋值给`name`变量，我们会得到一个错误，如下所示：
- en: '![Swift''s type system](img/B05103_02_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Swift的类型系统](img/B05103_02_01.jpg)'
- en: Here, we are trying to assign a number, specifically an `Int`, to a variable
    that was inferred to be a `String`. Swift does not allow that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们试图将一个数字，特别是`Int`，赋值给被推断为`String`类型的变量。Swift不允许这样做。
- en: 'When dealing with inferred types, it is extremely useful to ask Xcode what
    type a variable is inferred to be. You can do this by holding down the *Option*
    key on your keyboard and clicking on the variable name. This will display a pop-up
    that looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理推断类型时，询问Xcode一个变量被推断为何种类型非常有用。你可以通过按住键盘上的*Option*键并点击变量名称来实现。这将显示一个如下所示的弹出窗口：
- en: '![Swift''s type system](img/B05103_02_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Swift的类型系统](img/B05103_02_02.jpg)'
- en: As was expected, the variable was indeed inferred to be of the type `String`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，变量确实被推断为`String`类型。
- en: Types are an integral part of Swift. They are one of the major reasons that
    Swift is so safe as a programming language. They help the compiler learn more
    about your code and, because of that, the compiler can warn you about bugs automatically
    without even running your code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是Swift的一个基本组成部分。它们是Swift作为编程语言如此安全的主要原因之一。它们帮助编译器更多地了解你的代码，因此，编译器可以在不运行你的代码的情况下自动警告你关于错误。
- en: Printing to the console
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印到控制台
- en: It is very useful to write output to a log so that you can trace the behavior
    of code. As a codebase grows in complexity, it gets hard to follow the order in
    which things happen and exactly what the data looks like as it flows through the
    code. Playgrounds help a lot with this but it is not always enough.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入日志非常有用，这样你可以追踪代码的行为。随着代码库的复杂性增加，很难追踪事情发生的顺序以及数据在代码中流动时的确切样子。游乐场在这方面有很大帮助，但并不总是足够。
- en: 'In Swift, this process is called printing to the console. To do this, you use
    something called `print`. It is used by writing `print` followed by text surrounded
    by parentheses. For example, to print `Hello World!` to the console, the code
    would look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，这个过程被称为打印到控制台。要这样做，你使用一个叫做`print`的东西。它是通过写入`print`后跟括号内的文本来使用的。例如，要将`Hello
    World!`打印到控制台，代码看起来会是这样：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you put that code in a playground, you would see `Hello World!` written
    in the results pane. However, this is not truly the console. To view the console,
    you can go to **View** | **Debug Area** | **Show Debug Area**. A new view will
    appear at the bottom of the window and it will contain all text the code has printed
    to the console:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段代码放入游乐场，你会在结果面板中看到`Hello World!`被写入。然而，这并不是真正的控制台。要查看控制台，你可以转到**视图** |
    **调试区域** | **显示调试区域**。窗口底部将出现一个新的视图，其中包含代码打印到控制台的所有文本：
- en: '![Printing to the console](img/B05103_02_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![打印到控制台](img/B05103_02_03.jpg)'
- en: 'Not only can you print static text to the console, you can also print out any
    variable. For example, if you wanted to print out the `name` variable, you would
    write:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以打印静态文本到控制台，还可以打印出任何变量。例如，如果你想打印出`name`变量，你会这样写：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can even use a feature of Swift called **string interpolation** to insert
    variables into a string, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用Swift的一个功能，称为**字符串插值**，将变量插入到字符串中，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At any point in a string literal, even when not printing, you can insert the
    results of the code by surrounding the code with `\(` and `)`. Normally this would
    be the name of a variable but it could be any code that returns a value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串字面量的任何位置，即使不是在打印时，你都可以通过将代码用 `\(` 和 `)` 包围起来来插入代码的结果。通常这将是变量的名称，但它可以是任何返回值的代码。
- en: Printing to the console is even more useful when we start using more complex
    code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用更复杂的代码时，向控制台打印信息就更加有用。
- en: Control flow
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程
- en: A program wouldn't be very useful if it were a single fixed list of commands
    that always did the same thing. With a single code path, a calculator app would
    only be able to perform one operation. There are a number of things we can do
    to make an app more powerful and collect the data to make decisions as to what
    to do next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序只是一系列固定的命令列表，总是做同样的事情，那么它就不会很有用。使用单一的代码路径，计算器应用只能执行一个操作。我们可以做很多事情来使应用更强大，并收集数据以决定下一步做什么。
- en: Conditionals
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'The most basic way to control the flow of a program is to specify code that
    should only be executed if a certain condition is met. In Swift, we do that with
    an `if` statement. Let''s look at an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 控制程序流程的最基本方法是指定只有在满足特定条件时才应该执行的代码。在 Swift 中，我们使用 `if` 语句来实现这一点。让我们看看一个例子：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Semantically, the preceding code reads; if the number of invitees is greater
    then 20, print 'Too many people invited". This example only executes one line
    of code if the condition is true, but you can put as much code as you like inside
    the curly brackets (`{}`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上看，前面的代码是：如果受邀人数大于 20，则打印 'Too many people invited'。这个例子如果条件为真，则只执行一行代码，但你可以在花括号
    `{}` 内放置尽可能多的代码。
- en: 'Anything that can be evaluated as either true or false can be used in an `if`
    statement. You can then chain multiple conditions together using an `else if`
    and/or an `else`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以评估为真或假的任何内容都可以用在 `if` 语句中。然后你可以使用 `else if` 和/或 `else` 将多个条件链接在一起：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each condition is checked from top to bottom until a condition is satisfied.
    At that point, the code block is executed and the remaining conditions are skipped,
    including the final `else` block.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条件都会从上到下进行检查，直到满足某个条件。在这一点上，代码块将被执行，剩余的条件将被跳过，包括最后的 `else` 块。
- en: As an exercise, I recommend adding an additional scenario to the preceding code
    in which, if there were exactly zero invitees, it would print "One is the loneliest
    number". You can test out your code by adjusting how many invitees you add to
    the `invitees` declaration. Remember that the order of the conditions is very
    important.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，我建议在前面代码的基础上添加一个额外的场景，如果恰好没有受邀者，则打印 "One is the loneliest number"。你可以通过调整添加到
    `invitees` 声明中的受邀者数量来测试你的代码。记住，条件的顺序非常重要。
- en: As useful as conditionals are, they can become very verbose if you have a lot
    of them chained together. To solve this type of problem, there is another control
    structure called a **switch.**
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管条件语句很有用，但如果有很多条件链接在一起，它们可能会变得非常冗长。为了解决这类问题，还有一种名为 **switch** 的控制结构。
- en: Switches
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch`'
- en: 'A switch is a more expressive way of writing a series of `if` statements. A
    direct translation of the example from the conditionals section would look like
    this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 是编写一系列 `if` 语句的更表达性的方式。条件语句部分的示例的直接翻译如下：'
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A switch consists of a value and a list of conditions for that value with the
    code to execute if the condition is true. The value to be tested is written immediately
    after the `switch` command and all of the conditions are contained in curly brackets
    (`{}`). Each condition is called a **case**. Using that terminology, the semantics
    of the preceding code is "Considering the number of invitees, in the case that
    it is greater than 20, print `"Too many people invited"`, otherwise, in the case
    that it is less than or equal to three, print `"Too many people invited"`, otherwise,
    by default print `"Just right"`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 由一个值和该值的条件列表组成，如果条件为真，则执行相应的代码。要测试的值紧跟在 `switch` 命令之后，所有条件都包含在花括号
    `{}` 中。每个条件称为一个 **case**。使用这个术语，前面代码的语义是：“考虑到受邀人数，如果它大于 20，则打印 `"Too many people
    invited"`，否则，如果它小于或等于三个，则打印 `"Too many people invited"`，否则，默认打印 `"Just right"`。'
- en: This works by creating a temporary constant `x` that is given the value that
    the switch is testing. It then performs a test on `x`. If the condition passes,
    it executes the code for that case and then exits the switch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过创建一个临时常量`x`来实现的，该常量被赋予开关测试的值。然后它对`x`进行测试。如果条件通过，它将执行该情况的代码，然后退出开关。
- en: Just like in conditionals, each case is only considered if all of the previous
    cases are not satisfied. Unlike conditionals, all the cases need to be exhaustive.
    That means that you need to have a case for every possible value that the variable
    being passed in could be. For example, `invitees.count` is an integer, so it could
    theoretically be any value from negative infinity to positive infinity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在条件语句中一样，只有当所有前面的情况都不满足时，才会考虑每个情况。与条件语句不同，所有的情况都需要穷尽。这意味着你需要为变量可能传递的每个可能的值设置一个情况。例如，`invitees.count`是一个整数，所以理论上可以是负无穷大到正无穷大之间的任何值。
- en: 'The most common way to handle that is by using a default case as designated
    by the `default` keyword. Sometimes, you don''t actually want to do anything in
    the default case, or possibly even in a specific case. For that, you can use the
    `break` keyword, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种情况最常见的方式是使用由`default`关键字指定的默认情况。有时，你实际上不想在默认情况下做任何事情，甚至可能在特定情况下也不做。为此，你可以使用`break`关键字，如下所示：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the default case must always be the last one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况必须始终是最后一个。
- en: 'We have seen so far that switches are nice because they enforce the condition
    of being exhaustive. This is great for letting the compiler catch bugs for you.
    However, switches can also be much more concise. We can rewrite the preceding
    code like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到开关很棒，因为它们强制执行穷尽条件的规则。这对于让编译器为你捕获错误非常有用。然而，开关也可以更加简洁。我们可以像这样重写前面的代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have described each case as a range of possible values. The first case
    includes all of the values between and including `0` and `3`. This is way more
    expressive than using a `where` clause. This example also shows a rethinking of
    the logic. Instead of having a case specific for values over `20`, we have cases
    for the closed ranges that we know and then capture everything for the case above
    `20` in the default case. Note that this version of the code does not properly
    handle the situation in which the count might be negative, whereas the original
    version did. In this version, if the count were `-1`, it would fall all the way
    through to the default case and print out `"Too many people invited"`. For this
    use case, it is fine because the count of an array can never be negative.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将每种情况描述为可能值的范围。第一种情况包括介于`0`和`3`之间（包括这两个数）的所有值。这比使用`where`子句表达得更加丰富。这个例子也展示了逻辑的重新思考。我们不是为超过`20`的值设置特定的情况，而是为已知的闭区间设置情况，然后在默认情况下捕获超过`20`的所有情况。请注意，这个版本的代码没有正确处理计数可能为负的情况，而原始版本可以处理。在这个版本中，如果计数是`-1`，它将一直通过到默认情况并打印出`"Too
    many people invited"`。对于这个用例来说，这是可以接受的，因为数组的计数永远不会是负数。
- en: 'Switches don''t only work with numbers. They are great for performing any type
    of test:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开关不仅与数字一起工作。它们非常适合执行任何类型的测试：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code shows some other interesting features of switches. The first case
    is actually made up of two separate conditions. Each case can have any number
    of conditions separated by commas (`,`). This is useful when you have multiple
    cases that you want to use the same code for.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了开关的一些其他有趣特性。第一种情况实际上由两个单独的条件组成。每个情况可以有任意数量的条件，条件之间用逗号（`,`）分隔。当你有多个情况想要使用相同的代码时，这很有用。
- en: The second case uses a custom test on the name to see if it starts with the
    letter A. This is great for demonstrating the way in which switches are executed.
    Even though the string `Amy` would satisfy the second condition, this code would
    only print, `Amy is an honored guest` because the other cases are not evaluated
    once the first case is satisfied. For now, don't worry if you don't understand
    completely how `hasPrefix` works.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况使用自定义测试对名称进行检查，以查看它是否以字母A开头。这对于展示开关的执行方式非常出色。尽管字符串`Amy`会满足第二个条件，但这段代码只会打印出`"Amy
    is an honored guest"`，因为一旦第一个条件得到满足，就不会再评估其他情况。现在，如果你不完全理解`hasPrefix`是如何工作的，请不要担心。
- en: Lastly, the second case uses the `fallthrough` keyword. This tells the program
    to execute the code in the following case. Importantly, this bypasses the next
    case's condition; it does not matter if the value passes the condition, the code
    is still executed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第二种情况使用了 `fallthrough` 关键字。这告诉程序执行下一个情况的代码。重要的是，这绕过了下一个情况的条件；无论值是否通过条件，代码仍然会被执行。
- en: 'To make sure that you understand how a switch is executed, put the following
    code into a playground and try to predict what will be printed out with various
    names:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你理解 `switch` 的执行方式，将以下代码放入游乐场中，并尝试预测使用各种名称时将打印出什么内容：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Some good names to try are `Andrew`, `Amy`, and `Jamison`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得尝试的好名字有 `Andrew`、`Amy` 和 `Jamison`。
- en: Now we have full control over which code we want executed in which circumstances.
    However, a program often requires that we execute the same code more than once.
    For example, if we want to perform an operation on every element in an array,
    it would not be viable to copy and paste a bunch of code. Instead, we can use
    control structures called **loops**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完全控制了在什么情况下执行哪种代码。然而，一个程序通常需要我们多次执行相同的代码。例如，如果我们想要对数组中的每个元素执行一个操作，复制和粘贴一大堆代码是不可行的。相反，我们可以使用称为
    **循环** 的控制结构。
- en: Loops
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'There are many different types of loops but all of them execute the same code
    repeatedly until a condition is no longer true. The most basic type of loop is
    called a `while` loop:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的循环，但它们都会在条件不再为真时重复执行相同的代码。最基本类型的循环称为 `while` 循环：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A `while` loop consists of a condition to test and code to be run until that
    condition fails. In the preceding example, we have looped through every element
    in the `invitees` array. We used the variable `index` to track which invitee we
    were currently on. To move to the next index, we used a new operator `+=` which
    added one to the existing value. This is the same as writing `index = index +
    1`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环由一个用于测试的条件和直到该条件失败为止要运行的代码组成。在上面的例子中，我们遍历了 `invitees` 数组中的每个元素。我们使用变量
    `index` 来跟踪我们当前在哪个邀请者。为了移动到下一个索引，我们使用了一个新的运算符 `+=`，它将一个加到现有值上。这和写 `index = index
    + 1` 是一样的。'
- en: 'There are two important things to note about this loop. Firstly, our index
    starts at `0`, not `1`, and it goes on until it is less than the number of invitees,
    not less than or equal to them. This is because, if you remember, array indexes
    start at `0`. If we started at `1` we would miss the first element and, if we
    included `invitees.count,` the code would crash because it would try to access
    an element beyond the end of the array. Always remember: *the last element of
    an array is at the index one less than the count*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个循环有两个重要的事情需要注意。首先，我们的索引从 `0` 开始，而不是 `1`，并且它一直持续到小于邀请者的数量，而不是小于或等于它们。这是因为，如果你记得，数组索引从
    `0` 开始。如果我们从 `1` 开始，我们会错过第一个元素，如果我们包含了 `invitees.count`，代码会崩溃，因为它会尝试访问数组末尾之外的元素。始终记住：*数组的最后一个元素在索引上比计数少一个*。
- en: The other thing to note is that, if we were to forget to include `index+=1`
    in the loop, we would have an infinite loop. The loop would continue to run forever
    because `index` would never go beyond `invitees.count`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，如果我们忘记在循环中包含 `index+=1`，我们就会有一个无限循环。循环将永远继续运行，因为 `index` 从不会超过 `invitees.count`。
- en: 'This pattern of wanting to loop through a list is so common that there is a
    more concise and safe loop called a **for-in** loop:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种想要遍历列表的模式如此常见，以至于有一个更简洁、更安全的循环称为 **for-in** 循环：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now this is getting pretty cool. We no longer have to worry about indexes. There
    is no risk of accidentally starting at `1` or going past the end. Also, we get
    to give our own name to the specific element as we go through the array. One thing
    to note is that we did not declare the `invitee` variable with `let` or `var`.
    This is particular to a `for-in` loop because the constant used there is newly
    declared each time through the loop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得相当酷了。我们不再需要担心索引。没有意外从 `1` 开始或越过末尾的风险。此外，我们可以在遍历数组时给特定的元素起自己的名字。需要注意的是，我们没有用
    `let` 或 `var` 声明 `invitee` 变量。这特别适用于 `for-in` 循环，因为那里使用的常量每次通过循环都会被新声明。
- en: '`for-in` loops are great for looping through different types of containers.
    They can also be used to loop through a dictionary, as shown:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in` 循环非常适合遍历不同类型的容器。它们也可以用来遍历字典，如下所示：'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, we get access to both the key and the value of the dictionary.
    This should look familiar because `(genre, show)` is actually a tuple used for
    each iteration through the loop. It may be confusing to determine whether or not
    you have a single value from a `for-in` loop like arrays or a tuple like dictionaries.
    At this point, it would be best for you to remember just these two common cases.
    The underlying reasons will become clear when we start talking about **sequences**
    in [Chapter 6](ch06.html "Chapter 6. Make Swift Work For You – Protocols and Generics"),
    *Make Swift Work For You – Protocols and Generics*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以访问字典的键和值。这应该看起来很熟悉，因为`(genre, show)`实际上是一个元组，用于循环的每次迭代。在确定是否从类似数组或元组的`for-in`循环中有一个单一值时可能会感到困惑。在这个时候，最好记住这两个常见的案例。背后的原因将在我们开始讨论[第6章](ch06.html
    "第6章。让Swift为你工作 – 协议和泛型")中的**序列**时变得清晰，*让Swift为你工作 – 协议和泛型*。
- en: 'Another feature of `for-in` loops is the ability to only loop through elements
    that pass a given test. You could achieve this with an `if` statement but Swift
    provides a more concise way of writing it using the `where` keyword:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环的另一个特性是能够只遍历通过给定测试的元素。你可以使用`if`语句实现这一点，但Swift提供了一个更简洁的方式来写它，使用`where`关键字：'
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, the loop will only be run for each of the invitees that start with the
    letter `A`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，循环将只为以字母`A`开头的每个邀请人运行。
- en: 'These loops are great but sometimes we need access to the index we are currently
    on and, at other times, we may want to loop through a set of numbers without an
    array. To do this, we can use a range similar to a `Switch`, as shown:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些循环很棒，但有时我们需要访问当前所在的索引，而在其他时候，我们可能想要遍历一组数字而不使用数组。为此，我们可以使用类似于`Switch`的`range`，如下所示：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code runs the loop using the variable `index` from the value `0` up to
    but not including `invitees.count`. There are actually two types of ranges. This
    one is called a **half open range** because it does not include the last value.
    The other type of range, which we saw with switches, is called a **closed range**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用变量`index`从值`0`运行到但不包括`invitees.count`。实际上有两种类型的范围。这种类型被称为**半开范围**，因为它不包括最后一个值。另一种类型，我们在开关中看到的那种类型，被称为**闭包范围**：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The closed range includes the last value so that the loop will print out every
    number starting with `1` and ending with `10`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包范围包括最后一个值，因此循环将打印出从`1`开始到`10`结束的每个数字。
- en: 'All loops have two special keywords that let you modify their behavior, which
    are called `continue` and `break`. `continue` is used to skip the rest of the
    loop and move back to the condition to see whether or not the loop should be run
    again. For example, if we didn''t want to print out invitees whose name began
    with `A`, we would use the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有循环都有两个特殊关键字，可以修改它们的行为，这些关键字被称为`continue`和`break`。`continue`用于跳过循环的其余部分，并返回到条件以查看是否应该再次运行循环。例如，如果我们不想打印以`A`开头的邀请人，我们会使用以下代码：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the condition `invitee.hasPrefix("A")` were satisfied, the continue command
    would be run and it would skip the rest of the loop, moving onto the next invitee.
    Because of this, only invitees not starting with `A` would be printed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件`invitee.hasPrefix("A")`得到满足，`continue`命令将被执行，并且它会跳过循环的其余部分，转到下一个邀请人。正因为如此，只有不以`A`开头的邀请人会被打印出来。
- en: 'The `break` keyword is used to immediately exit a loop:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`关键字用于立即退出循环：'
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As soon as a break is encountered, the execution jumps to after the loop. In
    this case, it jumps to the final line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦遇到`break`，执行就会跳转到循环之后。在这种情况下，它跳转到最后一行。
- en: Loops are great for dealing with variable amounts of data, like our list of
    invitees. When writing your code, you probably won't know how many people will
    be in that list. Using a loop gives you the flexibility to handle a list of any
    length.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 循环非常适合处理可变数量的数据，比如我们的邀请人列表。在编写代码时，你可能不知道列表中会有多少人。使用循环可以让你灵活地处理任何长度的列表。
- en: As an exercise, I recommend you try writing a loop to find the sum of all the
    multiples of 3 under 10,000\. You should get 16,668,333.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我建议你尝试编写一个循环来找出10,000以下所有3的倍数的总和。你应该得到16,668,333。
- en: Loops are also a great way of reusing code without duplicating it but they are
    just the first step towards quality code reuse. Next, we will talk about functions,
    which opens up a whole new world of writing understandable and reusable code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 循环也是重用代码而不重复代码的绝佳方式，但它们只是高质量代码重用的第一步。接下来，我们将讨论函数，这将开启一个全新的可理解和可重用代码的世界。
- en: Functions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'All of the code we have explored so far is very linear down the file. Each
    line is processed one at a time and then the program moves onto the next. This
    is one of the great things about programming: everything the program does can
    be predicted by stepping through the program yourself mentally, one line at a
    time.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探索的所有代码都非常线性地沿着文件排列。每一行一次被处理，然后程序继续执行下一行。这是编程的伟大之处之一：程序所做的每一件事都可以通过你自己逐行地
    mentally stepping through 程序来预测。
- en: However, as your program gets larger, you will notice that there are places
    that reuse very similar or identical code that you cannot reuse by using loops.
    Moreover, the more code you write, the harder it becomes to know exactly what
    it is doing. Code comments can help with that but there is an even better solution
    to both of these problems and they're called **functions**. A function is essentially
    a named collection of code that can be executed and reused by using that name.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着你的程序变得越来越大，你会注意到有些地方重复使用非常相似或相同的代码，而这些代码不能通过使用循环来重用。此外，你写的代码越多，就越难确切知道它在做什么。代码注释可以帮助解决这个问题，但有一个更好的解决方案可以解决这两个问题，它们被称为**函数**。函数本质上是一组可以被执行和通过该名称重用的代码集合。
- en: There are various different types of functions but each builds on the previous
    type.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种不同类型的函数，但每种类型都是建立在之前类型的基础上的。
- en: Basic functions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本函数
- en: 'The most basic type of function simply has a name with some static code to
    be executed later. Let''s look at a simple example. The following code defines
    a function named `sayHello`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的函数类型仅仅有一个名称和一些稍后要执行的静态代码。让我们看看一个简单的例子。以下代码定义了一个名为 `sayHello` 的函数：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Functions are defined using the keyword `func` followed by a name and parentheses
    (`()`). The code to be run in the function is surrounded by curly brackets (`{}`).
    Just like in loops, a function can consist of any number of lines of code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是通过使用关键字 `func` 后跟一个名称和括号（`()`）来定义的。要在函数中运行的代码被大括号（`{}`）包围。就像在循环中一样，一个函数可以由任意数量的代码行组成。
- en: 'From our knowledge of printing, we know that this function will print out the
    text `Hello World!`. However, when will it do that? The terminology used for telling
    a function to execute is "calling a function." You call a function by using its
    name followed by parentheses (`()`):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们对打印的了解中，我们知道这个函数将打印出文本 `Hello World!`。然而，它将在什么时候做这件事呢？用于告诉函数执行的操作的术语是“调用函数”。你通过使用函数的名称后跟括号（`()`）来调用函数：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a very simple function that is not that useful but we can already see
    some pretty great benefits of functions. In reality, what happens when you call
    this function is that the execution moves into the function and, when it has finished
    executing every line of the function, it exits out and continues on from where
    the function was called. However, as programmers, we are often not concerned with
    what is happening inside a function unless something has gone wrong. If functions
    are named well, they tell you what they will do and that is all you need to know
    to follow the rest of the code. In fact, well-named functions can almost always
    take the place of comments in your code. This really reduces clutter without harming
    the legibility of your code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的函数，虽然它并不那么有用，但我们已经可以看到函数的一些非常显著的好处。实际上，当你调用这个函数时，执行会进入函数内部，当它执行完函数中的每一行代码后，它会退出并从函数被调用的地方继续执行。然而，作为程序员，我们通常并不关心函数内部发生的事情，除非出了什么问题。如果函数命名得当，它们会告诉你它们将做什么，这就是你需要知道的所有信息，以便理解代码的其余部分。实际上，命名良好的函数几乎可以替代代码中的注释，这真的减少了代码的杂乱，同时又不损害代码的可读性。
- en: The other advantage this function has over using `print` directly is that the
    code becomes more maintainable. If you use `print` in multiple places in your
    code and then change your mind about how you want to say `Hello`, you have to
    change a lot of code. However, if you use a function like the one above, you can
    easily change how it says `Hello` by changing the function and it will then be
    changed in each place you use that function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相较于直接使用 `print` 的另一个优点是代码的可维护性更高。如果你在代码的多个地方使用 `print`，然后改变你想要表达“Hello”的方式，你不得不更改很多代码。然而，如果你使用上述这样的函数，你可以通过更改函数来轻松地改变它表达“Hello”的方式，并且它将在你使用该函数的每个地方都相应地改变。
- en: 'You may have noticed some similarity in how we have named our `sayHello` function
    and how we used `print`. This is because `print` is a function that is built into
    Swift itself. There is complex code in the `print` function that makes printing
    to the console possible and accessible to all programmers. But hey, `print` is
    able to take in a value and do something with it, how do we write a function like
    that? The answer is: parameters.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在命名`sayHello`函数和使用`print`的方式上有一些相似之处。这是因为`print`是Swift本身内置的一个函数。`print`函数中包含复杂的代码，使得向控制台打印变得可能并且对所有程序员都是可访问的。但是，`print`能够接受一个值并对其进行操作，我们如何编写这样的函数呢？答案是：参数。
- en: Parameterized functions
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化函数
- en: 'A function can take zero or more parameters, which are input values. Let''s
    modify our `sayHello` function to be able to say `Hello` to an arbitrary name
    using string interpolation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以接受零个或多个参数，这些是输入值。让我们修改我们的`sayHello`函数，使其能够使用字符串插值对任意名称说`Hello`：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now our function takes in an arbitrary parameter called `name` of the type
    `String` and prints `hello` to it. The name of this function is now `sayHelloToName:`.
    We didn''t include the parameter name because, when you call the method, you don''t
    use the first parameter''s name by default:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们这个函数接受一个任意参数，称为`name`，类型为`String`，并向其打印`hello`。这个函数的名字现在是`sayHelloToName:`。我们没有包含参数名，因为当你调用方法时，默认情况下不会使用第一个参数的名称：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We included a colon (`:`) at the end of the name to indicate that it takes a
    parameter there. This makes it different from a function named `sayHelloToName`
    that does not take a parameter. The naming may seem unimportant and arbitrary
    but it is very important that we are all able to communicate about our code using
    common and precise terminology, so that we can more effectively learn from and
    collaborate with each other.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名称的末尾包含了一个冒号（`:`），以表示它在那里接受一个参数。这使得它与不接收参数的`sayHelloToName`函数不同。命名可能看起来不重要且随意，但确保我们都能使用共同和精确的术语来交流我们的代码非常重要，这样我们才能更有效地相互学习和合作。
- en: As mentioned before, a function can take more than one parameter. A parameter
    list looks a lot like a tuple. Each parameter is given a name and a type separated
    by a colon (`:`), and these are then separated by commas (`,`). On top of that,
    functions can not only take in values but can also return values to the calling
    code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个函数可以接受多个参数。参数列表看起来很像一个元组。每个参数都有一个名称和一个类型，由冒号（`:`）分隔，然后由逗号（`,`）分隔。除此之外，函数不仅可以接受值，还可以向调用代码返回值。
- en: Functions that return values
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值的函数
- en: 'The type of value to be returned from a function is defined after the end of
    all of the parameters separated by an arrow `->`. Let''s write a function that
    takes a list of invitees and one other person to add to the list. If there are
    spots available, the function adds the person to the list and returns the new
    version. If there are no spots available, it just returns the original list, as
    shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回值的类型定义在所有参数之后，由箭头`->`分隔。让我们编写一个函数，它接受一个邀请者列表和另一个要添加到列表中的人。如果有空位，该函数会将这个人添加到列表中，并返回新版本。如果没有空位，它就只返回原始列表，如下所示：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this function, we tested the number of names on the invitee list and, if
    it was greater than 20, we returned the same list as was passed in to the `invitees`
    parameter. Note that `return` is used in a function in a similar way to `break`
    in a loop. As soon as the program executes a line that returns, it exits the function
    and provides that value to the calling code. So, the final `return` line is only
    run if the `if` statement does not pass. It then adds the `newinvitee` parameter
    to the list and returns that to the calling code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们测试了邀请者列表上的名称数量，如果它大于20，我们就返回传递给`invitees`参数的相同列表。请注意，`return`在函数中的使用方式与在循环中`break`的使用方式相似。一旦程序执行了返回的行，它就会退出函数，并将该值提供给调用代码。因此，最后的`return`行只有在`if`语句未通过时才会执行。然后它将`newinvitee`参数添加到列表中，并将其返回给调用代码。
- en: 'You would call this function like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样调用这个函数：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is important to note that we must assign `list` to the value returned from
    our function because it is possible that the new value will be changed by the
    function. If we did not do this, nothing would happen to the list.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们必须将函数返回的值赋给`list`，因为新值可能会被函数修改。如果我们不这样做，列表将不会有任何变化。
- en: 'If you try typing this code into a playground, you will notice something very
    cool. As you begin typing the name of the function, you will see a small pop-up
    that suggests the name of the function you might want to type, as shown:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在游乐场中输入这段代码，你会注意到一个非常酷的现象。当你开始输入函数名时，你会看到一个小的弹出窗口，建议你可能想要输入的函数名，如下所示：
- en: '![Functions that return values](img/B05103_02_04.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![返回值的函数](img/B05103_02_04.jpg)'
- en: You can use the arrow keys to move up and down the list to select the function
    you want to type and then press the *Tab* key to make Xcode finish typing the
    function for you. Not only that, but it highlights the first parameter so that
    you can immediately start typing what you want to pass in. When you are done defining
    the first parameter, you can press *Tab* again to move on to the next parameter.
    This greatly increases the speed with which you can write your code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用箭头键在列表中上下移动以选择你想要输入的函数，然后按 *Tab* 键让 Xcode 帮你完成函数的输入。不仅如此，它还会突出显示第一个参数，这样你就可以立即开始输入你想要传递的内容。当你完成第一个参数的定义后，你可以再次按
    *Tab* 键来移动到下一个参数。这大大提高了你编写代码的速度。
- en: 'This is a pretty well-named function because it is clear what it does. However,
    we can give it a more natural and expressive name by making it read more like
    a sentence:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当好命名的函数，因为它清楚地说明了它的功能。然而，我们可以通过使其更像一个句子来给它一个更自然、更富有表现力的名称：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is a great feature of Swift that allows you to have a function called with
    **named parameters**. We can do this by giving the second parameter two names,
    separated by a space. The first name is the one to be used when calling the function,
    otherwise referred to as the **external name**. The second name is the one to
    be used when referring to the constant being passed in from within the function,
    otherwise referred to as the **internal name**. As an exercise, try to change
    the function so that it uses the same external and internal names and see what
    Xcode suggests. For more of a challenge, write a function that takes a list of
    invitees and an index for a specific invitee to write a message to ask them to
    just bring themselves. For example, it would print `Sarah, just bring yourself`
    for the index `0` in the preceding list.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Swift 的一项伟大特性，允许你使用带**命名参数**的函数。我们可以通过给第二个参数两个名称，用空格分隔来实现这一点。第一个名称是在调用函数时要使用的名称，也称为**外部名称**。第二个名称是在函数内部引用传入的常量时要使用的名称，也称为**内部名称**。作为一个练习，尝试更改函数，使其使用相同的内外部名称，并查看
    Xcode 的建议。更具挑战性的是，编写一个函数，它接受一个邀请人列表和一个特定邀请人的索引，以便写一条消息请他们只带自己。例如，对于前面列表中的索引 `0`，它会打印
    `Sarah, just bring yourself`。
- en: Functions with default arguments
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: 'Sometimes we write functions where there is a parameter that commonly has the
    same value. It would be great if we could provide a value for a parameter to be
    used if the caller did not override that value. Swift has a feature for this called
    **default arguments**. To define a default value for an argument, you simply add
    an equal sign after the argument, followed by the value. We can add a default
    argument to the `sayHelloToName:` function, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们编写的函数中有一个参数通常具有相同的值。如果能提供一个参数值，以便调用者没有覆盖该值时使用，那就太好了。Swift 有一个名为**默认参数**的特性。要为参数定义一个默认值，你只需在参数后添加一个等号，然后跟上一个值。我们可以在
    `sayHelloToName:` 函数中添加一个默认参数，如下所示：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This means that we can now call this function with or without specifying a
    name:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以带或不带指定名称调用这个函数：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When using default arguments, the order of the arguments becomes unimportant.
    We can add default arguments to our `addInvitee:ifPossibleToList:` function and
    then call it with any combination or order of arguments:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用默认参数时，参数的顺序变得不再重要。我们可以在我们的 `addInvitee:ifPossibleToList:` 函数中添加默认参数，然后以任何组合或顺序调用它：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Clearly, the call still reads much better when it is written in the same order
    but not all functions are designed in that way. The most important part of this
    feature is that you can specify only the arguments that you want to be different
    from the defaults.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当以相同的顺序编写时，调用仍然读起来更好，但并非所有函数都是这样设计的。这个特性的最重要部分是，你可以指定你想要与默认值不同的参数。
- en: Guard statement
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护语句
- en: 'The last feature of functions that we are going to discuss is another type
    of conditional called a **guard statement**. We have not discussed it until now
    because it doesn''t make much sense unless it is used in a function or loop. A
    guard statement acts in a similar way to an `if` statement but the compiler forces
    you to provide an `else` condition that must exit from the function, loop, or
    switch case. Let''s rework our `addInvitee:ifPossibleToList:` function to see
    what it looks like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的函数的最后一个特性是另一种称为`guard`语句的条件类型。我们之前没有讨论它，因为它除非在函数或循环中使用，否则没有太多意义。`guard`语句的行为与`if`语句类似，但编译器强制你提供一个`else`条件，该条件必须从函数、循环或`switch`案例中退出。让我们重新设计我们的`addInvitee:ifPossibleToList:`函数，看看它是什么样子：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Semantically, the guard statement instructs us to ensure that the number of
    invitees is less than 20 or else return the original list. This is a reversal
    of the logic we used before, when we returned the original list if there were
    20 or more invitees. This logic actually makes more sense because we are stipulating
    a prerequisite and providing a failure path. The other nice thing about using
    the guard statement is that we can't forget to return out of the `else` condition.
    If we do, the compiler will give us an error.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，`guard`语句指示我们确保受邀人数少于20人，否则返回原始列表。这与我们之前使用的逻辑相反，当时如果有20人或更多受邀者，我们会返回原始列表。这种逻辑实际上更有意义，因为我们规定了先决条件并提供了失败路径。使用`guard`语句的另一个优点是我们不会忘记从`else`条件中返回。如果我们这样做，编译器会给我们一个错误。
- en: It is important to note that guard statements do not have a block of code that
    is executed if it passes. Only an `else` condition can be specified with the assumption
    that any code you want to run for the passing condition will simply come after
    the statement. This is safe only because the compiler forces the `else` condition
    to exit the function and, in turn, ensures that the code after the statement will
    not run.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，要注意`guard`语句没有在通过时执行的代码块。只能指定一个`else`条件，假设你想要为通过条件运行的任何代码将简单地跟在语句之后。这之所以安全，仅仅是因为编译器强制`else`条件退出函数，从而确保语句之后的代码不会运行。
- en: Overall, guard statements are a great way of defining preconditions to a function
    or loop without having to indent your code for the passing case. This is not a
    big deal for us yet but, if you have lots of preconditions, it often becomes cumbersome
    to indent the code far enough to handle them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`guard`语句是一种很好的定义函数或循环先决条件的方法，而无需为通过情况缩进代码。对我们来说，这还不是什么大问题，但如果你有很多先决条件，通常会使缩进代码变得繁琐。
- en: Bringing it all together
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容结合起来
- en: At this point, we have learned a lot about the basic workings of Swift. Let's
    take a moment to bring many of these concepts together in a single program. We
    will also see some new variations on what we have learned.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Swift的基本工作原理。让我们花点时间将这些概念在单个程序中结合起来。我们还将看到一些我们所学内容的新变体。
- en: The goal of the program is to take a list of invitees and a list of television
    shows and ask random people to bring a show from each genre. It should also ask
    the rest to just bring themselves.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的目标是接受一个受邀者列表和一个电视节目列表，并随机要求人们从每个类型中带一个节目。它还应要求其他人只带自己。
- en: 'Before we look at the code, I will mention the three small new features that
    I will use:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，我将提到我将要使用的三个小新特性：
- en: Generating a random number
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Using a variable to store only true or false
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量仅存储真或假
- en: Repeat-while loops
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复-直到循环
- en: The most important feature is the ability to generate a random number. To do
    this, we have to import the `Foundation` framework. This is the most basic framework
    made available by Apple. As the name suggests, it forms the basis of the framework
    for both OS X and iOS.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的特性是生成随机数的能力。为了做到这一点，我们必须导入`Foundation`框架。这是苹果提供的基本框架中最基础的框架。正如其名所示，它构成了OS
    X和iOS框架的基础。
- en: '`Foundation` includes a function called `rand` that returns a random number.
    Computers are actually not capable of generating truly random numbers and, by
    default, `rand` always returns the same values in the same order. To make it return
    different values each time the program is run, we use a function called `srand`
    that stands for seed random. Seeding random means that we provide a value for
    `rand` on which to base its first value. A common way of seeding the random number
    is using the current time. We will use a method called `clock` that is also from
    `Foundation`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foundation` 包含一个名为 `rand` 的函数，它返回一个随机数。实际上，计算机无法生成真正的随机数，并且默认情况下，`rand` 总是在相同的顺序返回相同的值。为了使它在每次程序运行时返回不同的值，我们使用一个名为
    `srand` 的函数，代表种子随机。播种随机意味着我们提供一个值给 `rand`，作为其第一个值的基础。一种常见的播种随机数的方法是使用当前时间。我们将使用来自
    `Foundation` 的 `clock` 方法。'
- en: Lastly, `rand` returns a number anywhere from `0` to a very large number but,
    as you will see, we want to restrict the random number to between `0` and the
    number of invitees. To do this, we use the remainder operator (`%`). This operator
    gives you the remainder after dividing the first number by the second number.
    For example, `14 % 4` returns `2` because `4` goes into `14`, `3` times with `2`
    left over. The great feature of this operator is that it forces a number of any
    size to always be between `0` and `1` less than the number you are dividing by.
    This is perfect for changing all of the possible random values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`rand` 函数返回一个从 `0` 到一个非常大的数字，但正如您将看到的，我们希望将随机数限制在 `0` 和受邀人数之间。为此，我们使用取余运算符
    (`%`)。这个运算符给出第一个数除以第二个数后的余数。例如，`14 % 4` 返回 `2`，因为 `4` 可以进入 `14`，`3` 次后还剩下 `2`。这个运算符的伟大之处在于它强制任何大小的数字始终在
    `0` 和除数减 `1` 之间。这对于改变所有可能的随机值是完美的。
- en: 'The full code for generating a random number looks like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的完整代码如下：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You may notice one other thing about this code. We are using new syntax `UInt32()`
    and `Int()`. This is a way of changing one type into another. For example, the
    `clock` function returns a value of the type `clock_t` but `srand` takes a parameter
    of the type `UInt32`. Remember, just like with variables, you can hold the option
    key and click on a function to see what types it takes and returns.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会注意到代码中的另一个特点。我们正在使用新的语法 `UInt32()` 和 `Int()`。这是一种将一种类型转换为另一种类型的方法。例如，`clock`
    函数返回 `clock_t` 类型的值，但 `srand` 函数需要一个 `UInt32` 类型的参数。记住，就像变量一样，您可以按住选项键并单击一个函数来查看它接受和返回的类型。
- en: 'The second feature we will use a variable that can store only true or false.
    This is called a `Bool`, which is short for Boolean. We have used this type many
    times before as it is used in all conditionals and loops but this is the first
    time that we will store a `Bool` directly in a variable. At its most basic level,
    a Boolean variable is defined and used like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第二个特性是一个只能存储真或假的变量。这被称为 `Bool`，是布尔（Boolean）的简称。我们之前已经多次使用过这种类型，因为它用于所有条件和循环中，但这是我们第一次将
    `Bool` 直接存储在变量中。在最基本的情况下，布尔变量是这样定义和使用的：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we can use the Boolean directly in a conditional. This is because
    a Boolean is the exact type a conditional is expecting. All of our other tests
    like `<=` actually result in a `Bool`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在条件语句中直接使用布尔值。这是因为布尔值正是条件语句所期望的类型。我们所有的其他测试，如 `<=`，实际上都导致一个 `Bool`。
- en: 'Lastly, the third feature we will use is a variation of the `while` loop called
    a **repeat-while** loop. The only difference with a `repeat-while` loop is that
    the condition is checked at the end of the loop instead of at the beginning. This
    is significant because, unlike with a `while` loop, a `repeat-while` loop will
    always be executed at least once, as shown:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用的第三个特性是 `while` 循环的一种变体，称为 **重复-直到** 循环。与 `repeat-while` 循环的唯一区别是条件是在循环的末尾而不是开始时检查。这很重要，因为与
    `while` 循环不同，`repeat-while` 循环至少会执行一次，如下所示：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this loop, we will continue to generate a random number between `0` and
    `4` until we get a number that does not equal `3`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个循环，我们将继续生成 `0` 到 `4` 之间的随机数，直到我们得到一个不等于 `3` 的数字。
- en: 'Everything else in the code builds off the concepts we already know. I recommend
    that you read through the code and try to understand it. Try to not only understand
    it from the perspective of how it works but why I wrote it in that way. I included
    comments to help explain both what the code is doing and why it is written in
    that way:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的其他一切都是基于我们已知的概念构建的。我建议你阅读代码并尝试理解它。尝试不仅从它如何工作的角度理解它，还要理解为什么我以这种方式编写它。我包含了注释来帮助解释代码正在做什么以及为什么以这种方式编写：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This first section of code gives us a localized place in which to put all of
    our data. We can easily come back to the program and change the data if we want
    and we don''t have to go searching through the rest of the program to update it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一个部分为我们提供了一个局部位置，我们可以在这里放置所有数据。如果我们想修改数据，可以轻松回到程序中，而不必在程序的其余部分中搜索以更新它：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, I have provided a number of functions that simplify more complex code
    later on in the program. Each one is given a meaningful name so that, when they
    are used, we do not have to go and look at their code to understand what they
    are doing:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我提供了一些函数，它们简化了程序后面更复杂的代码。每个函数都有一个有意义的名称，这样，当它们被使用时，我们就不必去查看它们的代码来理解它们正在做什么：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This last section contains the real logic of the program, which is commonly
    referred to as the **business logic**. The functions from the previous section
    are just details and the final section is the logic that really defines what the
    program does.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段包含程序的真正逻辑，通常被称为**业务逻辑**。上一段中的函数只是细节，最后一段是真正定义程序做什么的逻辑。
- en: This is far from the only way to organize a program. This will become even clearer
    as we learn more advanced organization techniques. However, this breakdown shows
    you the general philosophy behind how you should organize your code. You should
    strive to write every piece of code as if it were going to be published in a book.
    Many of the comments in this example will become excessive as you get better with
    Swift but, when in doubt, explain what you are doing using either a comment or
    a well-named function. Not only will it help others understand your code, it will
    also help you understand it when you come back to it in six months and you are
    a stranger to the code again. Not only that, if you force yourself to formalize
    your thoughts as you write the code, you will find yourself creating a lot less
    bugs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是组织程序的唯一方法。随着我们学习更多高级组织技术，这一点将变得更加清晰。然而，这种分解展示了你应该组织代码的一般哲学。你应该努力编写每一行代码，就像它将要被发表在书中一样。随着你对Swift的熟练程度提高，这个例子中的许多注释将变得过多，但当你不确定时，使用注释或命名良好的函数来解释你正在做什么。这不仅有助于他人理解你的代码，当你六个月后再次回到代码时，它也会帮助你理解代码。不仅如此，如果你强迫自己在编写代码时使思想形式化，你会发现你创建的bug会少得多。
- en: Let's also look at an interesting limitation of this implementation. This program
    is going to run into a major problem if the number of invitees is less than the
    number of shows. The `repeat-while` loop will continue forever, never finding
    an invitee that was not invited. Your program doesn't have to handle every possible
    input but you should at least be aware of its limitations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看这个实现的一个有趣限制。如果邀请人数少于演出数量，这个程序将遇到一个主要问题。`repeat-while`循环将永远继续，永远不会找到一个未被邀请的邀请人。你的程序不需要处理所有可能的输入，但你至少应该意识到它的局限性。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have developed a great basis for Swift knowledge. We have
    learned about the various built-in mechanisms Swift has for representing complex
    information in expressive and accessible ways. We know that, by default, we should
    declare information as a constant until we find a practical need to change it,
    and then we should make it a variable. We have explored how every piece of information
    in Swift has a type associated with it by the compiler, whether it is through
    type inference or declared explicitly. We are familiar with many of the built-in
    types, including simple types like `String`, `Int`, and `Bool` as well as containers
    like tuples, arrays, and dictionaries. We can use the console output to better
    investigate our programs, especially by using string interpolation for dynamic
    output. We recognize the power of controlling the flow of our programs with `if`
    statements, conditionals, switches, and loops. We have functions in our skill
    set to write more legible, maintainable, and reusable code. Finally, we have seen
    an example of how all of these concepts can be combined to write a full program.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为Swift知识打下了坚实的基础。我们学习了Swift如何以表达性和易于访问的方式表示复杂信息的各种内置机制。我们知道，默认情况下，我们应该将信息声明为常量，直到我们发现实际需要改变它的时候，然后我们应该将其变为变量。我们探讨了在Swift中，每一条信息都通过编译器与一个类型相关联，无论是通过类型推断还是显式声明。我们对许多内置类型都很熟悉，包括简单的类型如`String`、`Int`和`Bool`，以及容器类型如元组、数组和字典。我们可以使用控制台输出更好地调查我们的程序，特别是通过使用字符串插值来实现动态输出。我们认识到使用`if`语句、条件语句、`switch`语句和循环来控制程序流程的强大功能。我们的技能集中包含编写更易读、可维护和可重用代码的函数。最后，我们看到了如何将这些概念结合起来编写一个完整程序的例子。
- en: As a challenge to you, I suggest you fix the final program so that it stops
    trying to assign shows if there are not enough invitees. When you can do that,
    you are more than ready to move on to the next topic, which is **types**, **scopes**,
    and **projects**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对你的一次挑战，我建议你修复最终的程序，使其在邀请人不足时停止尝试分配节目。当你能够做到这一点时，你就已经准备好继续下一个主题了，这个主题是**类型**、**作用域**和**项目**。
- en: These are all tools that we can use to write even more organized code and they
    will become more critical as we write larger and larger projects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们可以用来编写更加有序代码的工具，随着我们编写越来越大的项目，它们将变得更加关键。
