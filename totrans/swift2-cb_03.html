<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Using Structs and Generics" id="10DJ41-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Using Structs and Generics</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating an exam app</li><li class="listitem">Checking for the right answer</li><li class="listitem">Avoiding the copying of structs</li><li class="listitem">Creating a generic array initializer</li><li class="listitem">Creating a priority list</li><li class="listitem">Creating a protocol for the priority queue</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Using Structs and Generics" id="10DJ41-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec28" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">We could say that structures are something similar to classes. They store values with attributes, and they have initializers and methods. But their usage is a bit different. The idea of structs in Swift came from Objective-C, which by itself was using the C struct.</p><p class="calibre7">We will also use generics, so we can create generic containers. The idea of generics is not new; other languages such as C++ and Java already had it. However, this feature didn't exist in Objective-C, so the programmer was responsible for casting the retrieved data and as a consequence of this, the code was unsafe.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating an exam app"><div class="book" id="11C3M2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Creating an exam app</h1></div></div></div><p class="calibre7">In this recipe, we <a id="id111" class="calibre1"/>will create an exam app. For this exam, we will choose some random questions and the user will answer them. At the end, the app will show the user score and start again with a new exam.</p></div>

<div class="book" title="Creating an exam app">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec77" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">First, open Xcode and create a project called <code class="email">Chapter 3 Examination</code>, then create a file called <code class="email">question.swift</code>. This is where we will define a question for an exam.</p></div></div>

<div class="book" title="Creating an exam app">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec78" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">To create an exam <a id="id112" class="calibre1"/>app, follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the storyboard and add a label and three buttons to the view controller. You will have something similar to the following screenshot:<div class="mediaobject"><img src="../images/00033.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Copy the following code into the <code class="email">question.swift</code> file:<div class="informalexample"><pre class="programlisting">struct Question {
    var question:String
    var answer1:String
    var answer2:String
    var answer3:String
    var rightAnswer:Int
    var userAnswer:Int?
    
    init(question:String, answer1:String, answer2:String, answer3:String, rightAnswer:Int){
       self.question = question
        self.answer1 = answer1
        self.answer2 = answer2
        self.answer3 = answer3
        self.rightAnswer = rightAnswer
    }
}</pre></div></li><li class="listitem" value="3">Ok, now we can create our array of questions. This will be like a template because it is not the exam yet; it will be a container of every question. So, go to the only view <a id="id113" class="calibre1"/>controller we have and add the following attribute:<div class="informalexample"><pre class="programlisting">private var examTemplate = [Question]()</pre></div></li><li class="listitem" value="4">The next step is to fill this array with questions; as you may imagine, we will not add a lot of questions in this recipe, but a real application can have many of them. In this case, we need to divide it into different methods by category, as follows:<div class="informalexample"><pre class="programlisting">private func addGeneralKnowledgeQuestions(){
  examTemplate += [
    Question(question: "In which year was Packt Pub founded?",
      answer1: "2001", answer2: "2004", answer3: "1978", rightAnswer: 2),
    Question(question: "What is the capital of Luxembourg?",
      answer1: "Luxembourg City", answer2: "Diekirch", answer3: "Viena", rightAnswer: 1)
        ]
}

private func addComputersQuestions(){
    examTemplate += [
        Question(question: "In which year did Bob Bemer, the creator of the 'escape key', die?",
          answer1: "2004", answer2: "1980", answer3: "He is still alive", rightAnswer: 1),
        Question(question: "How much RAM did Macintosh 128Kb have?",
          answer1: "1 Gb", answer2: "1 byte", answer3: "128K", rightAnswer: 3)
        ]
}
    
private func addAstronomyQuestions(){
    examTemplate += [
        Question(question: "What is the name of the solar system star?",
          answer1: "Antonio Banderas", answer2: "Europe", answer3: "Sun", rightAnswer: 3),
        Question(question: "How long is the astronomical unit?",
          answer1: "150 millions of kilometers", answer2: "1 light year", answer3: "8 thousand inches", rightAnswer: 1)
        ]
}</pre></div></li><li class="listitem" value="5">Good! Now, we can initialize our exam, so let's create a method to do it. We will also need an <a id="id114" class="calibre1"/>attribute that will contain the current exam and another one that knows the current question:<div class="informalexample"><pre class="programlisting">    private lazy var exam:[Question] = []
    private lazy var currentQuestion = 0
    private func createExam(){
        func containsQuestion(question:String) -&gt; Bool{
            for i in exam{
                if question == i.question{
                    return true
                }
            }
            return false
        }
        exam = []
        currentQuestion = 0
        while exam.count &lt; 3 {
            var question = examTemplate[ Int(arc4random_uniform(UInt32(examTemplate.count)))]
            if !containsQuestion(question.question) {
                exam.append(question)
            }
        }
    }</pre></div></li><li class="listitem" value="6">Okay, it's time to start! We only need to show the question with its possible answers, like the method shown here:<div class="informalexample"><pre class="programlisting">@IBOutlet var labelQuestion: UILabel!
    @IBOutlet weak var buttonAnswer1: UIButton!
    @IBOutlet weak var buttonAnswer2: UIButton!
    @IBOutlet weak var buttonAnswer3: UIButton!
    @IBOutlet weak var buttonAnswerIdontKnow: UIButton!
    
    private func showCurrentQuestion(){
        if currentQuestion &lt; exam.count {
            labelQuestion.text = exam[currentQuestion].question
            buttonAnswer1.setTitle(exam [currentQuestion].answer1, forState: .Normal)
            buttonAnswer2.setTitle(exam[currentQuestion].answer2, forState: .Normal)
            buttonAnswer3.setTitle(exam[currentQuestion].answer3, forState: .Normal)
            buttonAnswerIdontKnow.setTitle("I don't know", forState: .Normal)
        }else {
          var total = 0
          for i in exam {
            total += i.rightAnswer == i.userAnswer? ? 1 : 0
          }

          let alert = UIAlertController(title: "Score", message: "Your score is \(total)", preferredStyle:.Alert)
          let startAgainAction = UIAlertAction(title:"Start Again", style.Default) { (action) -&gt; void in 
            createExam()
            showCurrentQuestion()
  }
  alert.addAction(startAgainAction)
    self.presentViewController(alert, animated: true, completion: nil)
        }
    }</pre></div></li><li class="listitem" value="7">Now, we only <a id="id115" class="calibre1"/>need to add this action for the buttons:<div class="informalexample"><pre class="programlisting">    @IBAction func answer(sender: UIButton) {
        switch sender {
        case buttonAnswer1:
            exam[currentQuestion].userAnswer = 1
        case buttonAnswer2:
            exam[currentQuestion].userAnswer = 2
        case buttonAnswer3:
            exam[currentQuestion].userAnswer = 3
        default:
            print("I don't know")
            
        }
        currentQuestion++
        showCurrentQuestion()
    }</pre></div></li><li class="listitem" value="8">If you click on play <a id="id116" class="calibre1"/>now, you will realize that the app still doesn't work; we have to initialize it, so let's finish this application by filling the <code class="email">viewDidLoad</code> method, as follows:<div class="informalexample"><pre class="programlisting">     override func viewDidLoad() {
        super.viewDidLoad()
        addGeneralKnowledgeQuestions()
        addComputersQuestions()
        addAstronomyQuestions()
        createExam()
        showCurrentQuestion()
    }</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating an exam app">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec79" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">The main difference between a class and a structure is that structures are copied every time they are assigned. What does this mean? This means that in this case if we've created this program with classes, the exam attribute and the exam template will point to the same objects (questions).</p><p class="calibre7">With this problem in mind, you can see that if we used classes when we start again, the new exam would come with the previous user's answers. Also, there is more; if you would like to store the exams with their answers, you would have to clone the objects; otherwise, everybody would have the same answers. Using structs, you don't have to worry about it; every time you create a new exam, you have new objects.</p><p class="calibre7">Another interesting part that I'd like to comment on is the <code class="email">createExam</code> function. As you can see, we have another function inside of it. Swift allows you to have auxiliary functions. This is very useful, mainly when we want to divide our code into small tasks.</p><p class="calibre7">On the same function (<code class="email">createExam</code>), you can see that we had a large call for creating a random number. The reason for this weird call is that Swift doesn't have a function for random numbers yet. Actually, Objective-C doesn't have a random function either; we have to use the C function <code class="email">arc4random_uniform</code>.</p><p class="calibre7">Such a function receives as an argument a 32-bit unsigned integer, but Swift can't convert its integer to this type. So, we used <code class="email">UInt32</code> to convert this number. As this function also returns an unsigned integer, it is necessary to cast its result to the Swift integer.</p></div></div>

<div class="book" title="Creating an exam app">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec80" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">There are more functions <a id="id117" class="calibre1"/>to retrieve random numbers, such as <code class="email">rand</code>, <code class="email">random</code>, and <code class="email">arc4random</code>. Have a look at the manual page of the command line and check their differences.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Checking for the right answer" id="12AK81-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec30" class="calibre1"/>Checking for the right answer</h1></div></div></div><p class="calibre7">This recipe will <a id="id118" class="calibre1"/>complete the previous one by checking the user's answer and <a id="id119" class="calibre1"/>validating that it is correct. If for any reason the answer receives a value out of range, this will be set to <code class="email">nil</code>. Of course, in this application, it's not possible to answer with a wrong value, but remember that a good developer is always thinking about the possible software evolution.</p></div>

<div class="book" title="Checking for the right answer" id="12AK81-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec81" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Copy the previous recipe; if you like, you can rename the product <code class="email">Chapter 3 Examination 2</code> by simply renaming the target name, as shown here:</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Checking for the right answer" id="12AK81-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec82" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Follow these steps in order to check the answers:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Go to the <code class="email">question.swift</code> file. Now, replace the current class with the following one:<div class="informalexample"><pre class="programlisting">struct Question {
    var question:String
    var answer1:String
    var answer2:String
    var answer3:String
    var rightAnswer:Int
    var userAnswer:Int? {
        willSet(newAnswer){
            if newAnswer &lt; 2 || newAnswer &gt; 3 {
                userAnswer = nil
                 print("Wrong value, fixing it")
            }
        }
        didSet(oldValue){
            <span class="strong"><strong class="calibre8">valid = userAnswer != nil &amp;&amp; userAnswer != rightAnswer</strong></span>
        }
    }
    var valid = false
    
    init(question:String, answer1:String, answer2:String, answer3:String, rightAnswer:Int){
       self.question = question
       self.answer1 = answer1
       self.answer2 = answer2
       self.answer3 = answer3
       self.rightAnswer = rightAnswer
    }
}</pre></div></li><li class="listitem" value="2">Now, return <a id="id120" class="calibre1"/>to the view controller and replace the <a id="id121" class="calibre1"/><code class="email">showCurrentQuestion</code> method with the following code:<div class="informalexample"><pre class="programlisting">    private func showCurrentQuestion(){
        if currentQuestion &lt; exam.count {
            labelQuestion.text = exam[currentQuestion].question
            buttonAnswer1.setTitle(exam[currentQuestion].answer1, forState: .Normal)
            buttonAnswer2.setTitle(exam[currentQuestion].answer2, forState: .Normal)
            buttonAnswer3.setTitle(exam[currentQuestion].answer3, forState: .Normal)
            buttonAnswerIdontKnow.setTitle("I don't know", forState: .Normal)
        }else {
            var total = 0
            for i in exam {
                total += i.valid ? 1 : 0
            }
  let alert = UIAlertController(title: "Score", message: "Your score is \(total)", preferredStyle:.Alert) self.presentViewController(alert, animated: true, completion: nil)
        }
    }</pre></div></li><li class="listitem" value="3">This recipe can stop here. However, as we want to check this, an out-of-range <a id="id122" class="calibre1"/>value will be corrected to <code class="email">nil</code>; we can replace <a id="id123" class="calibre1"/>the <code class="email">answer</code> method with this one here:<div class="informalexample"><pre class="programlisting">    @IBAction func answer(sender: UIButton) {
        switch sender {
        case buttonAnswer1:
            exam[currentQuestion].userAnswer = 1
        case buttonAnswer2:
            exam[currentQuestion].userAnswer = 2
        case buttonAnswer3:
            exam[currentQuestion].userAnswer = 3
        default:
            exam[currentQuestion].userAnswer = 0
        }
        currentQuestion++
        showCurrentQuestion()
    }</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Checking for the right answer" id="12AK81-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec83" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Swift has a good feature for properties called <code class="email">property observer</code>. This feature is equivalent to triggers on relational databases. With <code class="email">willSet</code>, you can correct the input and with <code class="email">didSet</code>, you can trigger actions that are needed after the value has been changed.</p><p class="calibre7">We also changed the way we check a valid answer; this is done because the logic of a question should be inside its class or structure.</p></div></div>

<div class="book" title="Checking for the right answer" id="12AK81-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec84" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">As you can see, this recipe is related to the <span class="strong"><em class="calibre9">Quizzing the user</em></span> recipe in <a class="calibre1" title="Chapter 2. Standard Library and Collections" href="part0025_split_000.html#NQU21-bba3081a9dc049b7aa5e4f7cc42ef8bb">Chapter 2</a>, <span class="strong"><em class="calibre9">Standard Library and Collections</em></span>. If you want to create a more complete example, you can merge both apps into one.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Avoiding the copying of structs" id="1394Q1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec31" class="calibre1"/>Avoiding the copying of structs</h1></div></div></div><p class="calibre7">There are <a id="id124" class="calibre1"/>times when we are working with structs and we don't want to copy them. In this recipe, we will see this example and the solution for it by creating a small app where the user can see the coordinates of two supposed characters, and we can press a button to change their coordinates to a center point between them.</p></div>

<div class="book" title="Avoiding the copying of structs" id="1394Q1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec85" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new single view project called <code class="email">Chapter3 Vector2D</code>. For this recipe, we will need only one new file, which we will call <code class="email">Position.swift</code>.</p></div></div>

<div class="book" title="Avoiding the copying of structs" id="1394Q1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec86" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's create the app that prevents the copying of structs:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Let's start with the model part, as usual. Click on the <code class="email">Position.swift</code> file. Let's create a struct with the same name, as follows:<div class="informalexample"><pre class="programlisting">struct Position:CustomStringConvertable {
    private var x:Int,y:Int
    init(){
        (x,y) = (0,0)
    }
    mutating func moveUp(){
        self.y--
    }
    mutating func moveDown(){
        self.y++
    }
    mutating func moveRight(){
        self.x++
    }
    mutating func moveLeft(){
        self.x--
    }
    mutating func meet(inout position:Position){
        let newx = (self.x + position.x) / 2
        var newy = (self.y + position.y) / 2
        self.x = newx
        self.y = newy
        position.x = newx
        position.y = newy
    }
    var description:String {
        return "\(self.x)x\(self.y)"
    }
}</pre></div></li><li class="listitem" value="2">Now, go to the storyboard and add nine buttons and two labels to it, something <a id="id125" class="calibre1"/>similar to the following screenshot:<div class="mediaobject"><img src="../images/00035.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Now, let's link our labels with the following attributes:<div class="informalexample"><pre class="programlisting">    @IBOutlet var labelC1: UILabel!
    @IBOutlet var labelC2: UILabel!</pre></div></li><li class="listitem" value="4">After this, we will create two attributes that represent the coordinates of the characters. Of course, in a real game, these attributes will belong to objects of another type, probably of something like a character:<div class="informalexample"><pre class="programlisting">    var character1 = Position()
    var character2 = Position()</pre></div></li><li class="listitem" value="5">As you can see, these objects will start at the 0 x 0 position, but the labels won't know it if we don't initialize it with the <code class="email">viewDidLoad</code> method. So, let's add the following code to the view controller:<div class="informalexample"><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        displayPositionC1()
        displayPositionC2()
    }

    private func displayPositionC1(){
        labelC1.text = character1.description
    }

    private func displayPositionC2(){
        labelC2.text = character2.description
    }</pre></div></li><li class="listitem" value="6">Now, we can add the events that move the characters. As you can imagine, they are <a id="id126" class="calibre1"/>very straightforward because, each action will proxy to the equivalent method on the struct. Here is the code for this:<div class="informalexample"><pre class="programlisting">    @IBAction func upC1(sender: UIButton) {
        character1.moveUp()
        displayPositionC1()
    }
    
    @IBAction func downC1(sender: UIButton) {
        character1.moveDown()
        displayPositionC1()
    }
    @IBAction func leftC1(sender: UIButton) {
        character1.moveLeft()
        displayPositionC1()
    }
    
    @IBAction func rightC1(sender: UIButton) {
        character1.moveRight()
        displayPositionC1()
    }

    @IBAction func meet(sender: UIButton) {
        character1.meet(&amp;character2)
        displayPositionC1()
        displayPositionC2()
    }</pre></div></li><li class="listitem" value="7">Now, the application is done. Click on play and move the characters with the buttons. The most important part is that no struct was copied or cloned.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Avoiding the copying of structs" id="1394Q1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec87" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">As you can see, we had to add a modifier on the methods of our structs. This is because struct methods, by default, are constants. If you need to change an attribute, you have to use the <code class="email">mutating</code> modifier.</p><p class="calibre7">When receiving an <a id="id127" class="calibre1"/>argument that you don't want to copy, such as a struct, you have to use the <code class="email">inout</code> parameter. This parameter will allow you to modify the corresponding argument. However, when using this feature, you have to call the function adding an ampersand (<code class="email">&amp;</code>) before the variable and you can't pass expressions as arguments.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a generic array initializer" id="147LC1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec32" class="calibre1"/>Creating a generic array initializer</h1></div></div></div><p class="calibre7">In this recipe, we will <a id="id128" class="calibre1"/>learn how to use generics. This feature is used a lot in languages such as C++, Java, and C# because this way, we don't need to overload a function for each possible type that could be used in our function.</p><p class="calibre7">In this case, we will create a function that receives the input items and returns an array with these elements but completely shuffled.</p></div>

<div class="book" title="Creating a generic array initializer" id="147LC1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec88" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new Swift single view project called <code class="email">Chapter3 Array initializer</code>.</p></div></div>

<div class="book" title="Creating a generic array initializer" id="147LC1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec89" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">To create a generic array initializer, follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add a new file called <code class="email">ArrayInit</code> and add this code into it:<div class="informalexample"><pre class="programlisting">func arrayInit&lt;T&gt;(values:T...)-&gt;[T]{
    var newArray = values
    for var i=0;i &lt; newArray.count * 2 ; ++i {
                let pos1 = Int(arc4random_uniform(UInt32(newArray.count)))
        let pos2 = Int(arc4random_uniform(UInt32(newArray.count)))
        (newArray[pos1], newArray[pos2]) = (newArray[pos2], newArray[pos1])
    }
    return newArray
}</pre></div></li><li class="listitem" value="2">Now, we need to add two buttons and a text view to our storyboard to see this function working. So, let's link the text view with the following property:<div class="informalexample"><pre class="programlisting">@IBOutlet weak var textView: UITextView!</pre></div></li><li class="listitem" value="3">The next <a id="id129" class="calibre1"/>step is to create the events of each button, so add these actions into your view controller:<div class="informalexample"><pre class="programlisting">    @IBAction func arrayInt(sender: AnyObject) {
        let arr = arrayInit(5, 10, 15, 20, 25, 30)
          textView.text = arr.map({ (element) -&gt; String in
             return String(element)
        }).joinWithSeparator("\n")
}
    
    @IBAction func arrayString(sender: AnyObject) {
        let arr = arrayInit("Hello", "I'm", "Edu","Merry", "Christmas")
        textView.text = arr.joinWithSeparator("\n")
    }</pre></div></li><li class="listitem" value="4">Now, it's time to test our code. Run your application and press each button, and you should have results like these screenshots:<div class="mediaobject"><img src="../images/00036.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating a generic array initializer" id="147LC1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec90" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">One advantage of object-oriented programming is avoiding the duplication of code. Some languages will force you to create a function for the array of strings, another one for the array of integers, and another new one for each new type that we need to use with this function.</p><p class="calibre7">Fortunately, Swift <a id="id130" class="calibre1"/>allows us to create a generic function. This means that we only need to implement the function once and the same code will be applied each time.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre7">Inside the function, the arguments are treated as a constant array, but calling the function with an array as an argument has another meaning; the compiler will think that you have only one argument that is an array.</p></div><p class="calibre7">This function has something different: the ellipsis that is used after the input argument. This means that the function is not restricted to a number of arguments; this has a variable number of arguments. In our case, we can call it with six integers and with five strings. This feature is very useful, for example, when creating functions to calculate the average of some numbers.</p></div></div>

<div class="book" title="Creating a generic array initializer" id="147LC1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec91" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Overloading generic functions is allowed; it's used when there is a type that, for any reason, needs a different code. For example, now you can use this code to shuffle cards.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a priority list"><div class="book" id="1565U2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec33" class="calibre1"/>Creating a priority list</h1></div></div></div><p class="calibre7">Let's imagine that <a id="id131" class="calibre1"/>we need to manage a queue of passengers on a flight. We know that business class should embark first, then passengers in first class, and finally, economy class.</p><p class="calibre7">This is a typical case of a priority queue, but the nagging question is, can we create a priority queue only once? Or should we create a new priority queue in every new app? An Objective-C programmer who recently arrived at Swift will probably create this container storing objects of the type <code class="email">AnyObject</code>. This solution can be acceptable; however, Swift has a better solution that is even safer, and as you know, that is generics.</p><p class="calibre7">A priority queue needs to organize its elements using criteria. In this case, we can create our queue of any element but ensure that it is created for elements of a class that implements the <code class="email">Comparable</code> protocol; that's what we call a type constraint.</p></div>

<div class="book" title="Creating a priority list">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec92" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new Swift single view project called <code class="email">Chapter3 Flight</code>.</p></div></div>

<div class="book" title="Creating a priority list">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec93" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Follow these <a id="id132" class="calibre1"/>steps to create a priority list:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add a new Swift file called <code class="email">PriorityQueue.swift</code>.</li><li class="listitem" value="2">In this file, let's create a class with the same name. Here, we will need an array as an attribute to store our elements and a few methods to work with this queue: <code class="email">enqueue</code> for adding a new element; <code class="email">dequeue</code> for removing the first element of the queue; <code class="email">size</code>, which returns the number of elements on our queue; and <code class="email">toArray</code>, which will return the elements of our queue to an array. So, add the following code into your file:<div class="informalexample"><pre class="programlisting">class PriorityQueue&lt;T:Comparable&gt; {
    
    private var elements = [T]()
    func enqueue(element:T) {
        elements.append(element)
        var index=elements.count-2
        while index&gt;=0 &amp;&amp; elements[index] &lt; elements[index+1] {
            (elements[index],elements[index+1]) = (elements[index+1],elements[index])
            index--
        }
    }
    
    func dequeue() -&gt; T {
        return elements.removeAtIndex(0)
    }
    
    var size: Int {
        return elements.count
    }
    
    func toArray() -&gt;[T]{
        return elements
    }
    
}</pre></div></li><li class="listitem" value="3">Now, create a new file called <code class="email">Passenger.swift</code>. Here, we will define a passenger with his data. Remember that we need to compare the priority of a passenger. For this reason, this class must implement the <code class="email">Comparable</code> protocol:<div class="informalexample"><pre class="programlisting">class Passenger:Comparable, CustomStringConvertable {
    enum Class:Int {
        case ECONOMY=0, FIRST=1, BUSINESS=2
        
        var value:Int{
            return self.rawValue
        }
    }
    var classtype:Class
    var name:String
    var id:String
    
    init (name:String, id:String, classtype:Class = .ECONOMY){
        self.name = name
        self.id = id
        self.classtype = classtype
    }
    
    var description:String{
        var seattype:String
            switch self.classtype{
            case .ECONOMY:
                seattype = "economy"
            case .FIRST:
                seattype = "first"
            case .BUSINESS:
                seattype = "business"
            default:
                seattype = "unkown"
            }
        
        
        return "\(self.name), with id \(self.id) on \(seattype) class"
    }
}

// Operators
func &lt;(lhs: Passenger, rhs: Passenger) -&gt; Bool{
    return lhs.classtype.value &lt; rhs.classtype.value
}

func ==(lhs: Passenger, rhs: Passenger) -&gt; Bool{
    return lhs.classtype == rhs.classtype
}

func !=(lhs: Passenger, rhs: Passenger) -&gt; Bool{
    return lhs.classtype != rhs.classtype
}

func &lt;=(lhs: Passenger, rhs: Passenger) -&gt; Bool{
    return lhs &lt; rhs || lhs == rhs
}

func &gt;=(lhs: Passenger, rhs: Passenger) -&gt; Bool{
    return !(lhs &lt; rhs)
}

func &gt;(lhs: Passenger, rhs: Passenger) -&gt; Bool{
    return lhs != rhs &amp;&amp; !(lhs &lt; rhs )
}</pre></div></li><li class="listitem" value="4">Now, open your storyboard and add two text fields (one for passenger name and another <a id="id133" class="calibre1"/>one for his identification number and ID document), one table view to choose the seat type, two buttons to queue and dequeue, and a text field to display the current queue status. You should have a layout similar to the following one:<div class="mediaobject"><img src="../images/00037.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">The next step is to open the view controller and add the protocol <code class="email">UITableViewDataSource</code>:<div class="informalexample"><pre class="programlisting">class ViewController: UIViewController, UITableViewDataSource {</pre></div></li><li class="listitem" value="6">Ok, now link <a id="id134" class="calibre1"/>the corresponding components with the attribute, and beside this, create a passenger queue as an attribute:<div class="informalexample"><pre class="programlisting">    @IBOutlet weak var passengerName: UITextField!
    @IBOutlet weak var idDocument: UITextField!
    @IBOutlet weak var seatType: UITableView!
    @IBOutlet weak var textView: UITextView!
    
    private var passengersQueue = PriorityQueue&lt;Passenger&gt;()</pre></div></li><li class="listitem" value="7">At this moment, we can start implementing the <code class="email">tableview</code> code. As you know, we must implement at least two mandatory methods of <code class="email">UITableViewDataSource</code>. Let's start with the easiest one that returns the number of rows. Right now, there is no way to detect the number of elements of an enumeration, so we will hardcode this value:<div class="informalexample"><pre class="programlisting">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int{
    return 3
}</pre></div></li><li class="listitem" value="8">The next step <a id="id135" class="calibre1"/>is to create the method that returns the seat type cells:<div class="informalexample"><pre class="programlisting">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell{
        var cell:UITableViewCell
        if let auxCell = tableView.dequeueReusableCellWithIdentifier("cell") {
            cell = auxCell
        }else{
            cell = UITableViewCell()
        }
        switch indexPath.row {
        case 0:
            cell.textLabel!.text = "Economy class"
        case 1:
            cell.textLabel!.text = "First class"
        case 2:
            cell.textLabel!.text = "Business class"
        default:
            break;
        }
        
        return cell
    }</pre></div></li><li class="listitem" value="9">If you click on play at this moment, you should at least see the table view with its values. Now, we need to create a method to display the current queue passengers:<div class="informalexample"><pre class="programlisting">    private func displayQueue () {
            textView.text = (self.passengersQueue.toArray().map{
            (var p)-&gt; String in
            return p.description
            }).joinWithSeperator("\n")
    }</pre></div></li><li class="listitem" value="10">Now, we only need to create the actions for our buttons:<div class="informalexample"><pre class="programlisting">    @IBAction func enqueue(sender: AnyObject) {
      if let indexPath = seatType.indexPathForSelectedRow {
         var passenger = Passenger(name: passengerName.text, id: idDocument.text, classtype: Passenger.Class(rawValue: indexPath.row)!)
            passengersQueue.enqueue(passenger)
            self.displayQueue()
        }else {
          let alert = UIAlertController(title: "Error", message: "You must select the seat type", preferredStyle:.Alert)
            self.presentViewController(alert, animated: true, completion: nil)
  
        }
    }

    @IBAction func dequeue(sender: AnyObject) {
        passengersQueue.dequeue()
        displayQueue()
    }</pre></div></li></ol><div class="calibre13"/></div><p class="calibre7">The app is done. Now, try to add different passengers and check how your queue grows.</p></div></div>

<div class="book" title="Creating a priority list">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec94" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Generics save us from rewriting a lot of code, but as it needs to be safe, you can't use operators or methods that might not exist on the type that you are working with. To solve this problem, you can specify a constraint that will tell the compiler which methods are allowed to be used with this type. In our case, we specified that T is Comparable; so we can use the operators of Comparators on our code.</p><p class="calibre7">Some new knowledge that we can retrieve from this code is the nested enumeration. Swift has no <a id="id136" class="calibre1"/>namespace or package, but you can create nested enumerations, classes, and structs. This way we can avoid clashing names.</p><p class="calibre7">Another new feature is the typed enumeration; as you can see, we specified that each enumeration value is associated with an integer number. You can retrieve this value using <code class="email">rawValue</code> or use <code class="email">init(rawValue:)</code> to do the inverted process.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre7">The first version of Swift used to have a method called <code class="email">toRaw()</code> instead of the property <code class="email">rawValue</code>, and <code class="email">fromRaw()</code> instead of using the initializer <code class="email">init(rawValue:)</code>.</p></div><p class="calibre7">You can also implement your own function or computed property as we did in this enumeration; sometimes, it's better than using the raw value.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre7">Creating your function or computed property to convert enumerations is a good practice for software maintenance.</p></div></div></div>

<div class="book" title="Creating a priority list">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec95" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">There is more than one way to solve this problem; if you need performance, you might use a double linked list instead.</p><p class="calibre7">You can specify <a id="id137" class="calibre1"/>more than one constraint if you want to by using the <code class="email">where</code> clause. For example, if you would like to store elements that are also <code class="email">CustomStringConvertable</code>, you can change the class header to <code class="email">class PriorityQueue&lt;T:Comparable where T: CustomStringConvertable &gt; {</code>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a protocol for the priority queue" id="164MG1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec34" class="calibre1"/>Creating a protocol for the priority queue</h1></div></div></div><p class="calibre7">In the <a id="id138" class="calibre1"/>previous recipe, we created a generic code which <a id="id139" class="calibre1"/>can be used in our future programs, but we have to remember that priority queues are only one kind of queue. It is good practice to define an interface for this abstract data type, and after this, have different implementations.</p><p class="calibre7">As you know, in Swift, we have protocols for cases such as this; however, we have a problem: protocols don't <a id="id140" class="calibre1"/>have generics. What is the solution? The answer is <span class="strong"><strong class="calibre8">associated types</strong></span>.</p></div>

<div class="book" title="Creating a protocol for the priority queue" id="164MG1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec96" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Copy the project of the previous recipe and name it <code class="email">Chapter 3 Flight Protocol</code>, and create a new file called <code class="email">Queue.swift</code>.</p></div></div>

<div class="book" title="Creating a protocol for the priority queue" id="164MG1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec97" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">To create a protocol for the priority queue, follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add the following code onto the <code class="email">Queue.swift</code> file:<div class="informalexample"><pre class="programlisting">protocol Queue {
    typealias ElementType
    func enqueue(element:ElementType)
    func dequeue() -&gt; ElementType
    var size: Int{
        get
    }
}</pre></div></li><li class="listitem" value="2">Now, return to the priority queue and change its header to this one:<div class="informalexample"><pre class="programlisting">class PriorityQueue&lt;T:Comparable&gt;:Queue</pre></div></li><li class="listitem" value="3">Click on play, and of course, the result is visually the same, but your code is now more recyclable. Try to remove one method such as <code class="email">enqueue</code>, and you will see that the compiler will complain about the missing method of the protocol.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating a protocol for the priority queue" id="164MG1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec98" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Unfortunately, we can't create protocols with generics, but we can solve this problem with associated <a id="id141" class="calibre1"/>types. You only need to create <code class="email">typealias</code> inside the protocol without specifying its real type, and then, we can declare the protocol's <a id="id142" class="calibre1"/>methods with this type. When you inherit from this protocol, your type can be anything, even a generic type <code class="email">T</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip27" class="calibre1"/>Tip</h3><p class="calibre7">Try to use protocols when you have a concept such as a queue, a list, or a stack. Then, you can have different implementations and use the best one for the occasion.</p></div></div></div>

<div class="book" title="Creating a protocol for the priority queue" id="164MG1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec99" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Now that you have learned how to make reusable code with generics, you will improve even more in the next chapter where we will use design patterns with Swift.</p></div></div></body></html>