- en: Chapter 5. Creating User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we created our first project and have become familiar with the code
    editor and its functionalities, we will begin our application by creating our
    user interface. Is there more than one way to create a user interface using Android
    Studio? How can you add components to your user interface? Have you ever wondered
    how to make your applications support different screen sizes and resolutions?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on the creation of the user interfaces using layouts. Layouts
    can be created using a graphical view or a text-based view. You will learn how
    to use both of them to create your layout. We will also code a `Hello World` application
    using simple components. Since there are over 18,000 Android device types, you
    will learn about fragmentation on different screen types and we will discuss how
    to prepare our application for this issue. We will end this chapter with basic
    notions of handling events in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics we''ll be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing layout editors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting different screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the UI theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graphical editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the main layout located at `/src/main/res/layout/activity_main.xml` in
    our project. The graphical editor will be opened by default. The center panel
    of the graphical editor is the **Preview**, where you can examine what your layout
    looks like. From the **Preview** you can see that initially this main layout contains
    just a text view with a **Hello World!** message. To switch between the graphical
    and text editors, click on the **Design** and **Text** tabs at the bottom of the
    screen, as shown in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical editor](img/B05459_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Toolbar** options contains some options that can be used to change the
    layout style and preview. The **Toolbar** options, which are shown in the following
    screenshot, are explained throughout the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical editor](img/B05459_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Component Tree** panel displays the components placed in the layout as
    a hierarchy. There are two components in our layout: a **RelativeLayout** as the
    root element, and a **TextView** which is the one displaying the **Hello World!**
    message. When you select one element on the **Component Tree** panel, the element
    is highlighted in **Preview**, and its properties are listed in the **Properties**
    inspector panel. It shows the properties of the selected component from the layout
    and allows us to change them. **Palette** lists the existing **user interface**
    (**UI**) components to place in our layout. It organizes the components in different
    categories. Let''s look at the options available in **Components Palette**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts**: A layout is a container object used to distribute the components
    on the screen. The root element of UI is a layout object, but layouts can also
    contain more layouts, creating a hierarchy of components structured in layouts.
    The recommendation is to keep this layout hierarchy as simple as possible. Our
    main layout has **RelativeLayout** as a root element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widgets**: This category contains options for text views, buttons, checkboxes,
    switches, image views, progress bars, seek bars, rating bars, spinners, and web
    views. They are the most commonly used components, and they are used in most layouts.
    Our main layout contains **TextView** inside the root relative layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text Fields**: These are editable fields that contain different categories
    of input under which users can type text. The difference between the various options
    is the type of text users can type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: This category groups components that share a common behavior.
    Radio groups, list views, grid views, scroll views, and tab hosts are some of
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date & Time**: This category holds components related to date and time in
    the form of calendars or clocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expert**: The components in this category are not as common as the components
    in the **Widgets** category, but it is worth taking a look at them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom**: This category holds components that allow us to include our custom
    components, which are usually other layouts from our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text-based editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Change the graphical editor to the text editor by clicking on the **Text**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The text-based editor](img/B05459_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Toolbar** panel is the same as that on the graphical editor. The **Preview**
    window displays the layout, but it cannot be changed. To do that, you should use
    the **Design** tab instead. The components are added to the layout using their
    XML declarations. The properties are also configured using XML declarations. Like
    the graphical editor, the text editor contains two XML elements: a relative layout
    as the root element and the text view element inside the root layout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The XML tag names define the type of component that we are declaring. For the
    relative layout, we use the `RelativeLayout` tag, and for the text view, we use
    the `TextView` tag. We can add properties to the elements by including attributes
    in the XML tags. For example, the text view in our main layout has three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:layout_width`, with the `wrap_content` value: This property sets the
    element width inside its parent element. The `wrap_content` value means that the
    element''s width will be determined by the width of its content. The other default
    value that you can set for this property is `match_parent`, which means that the
    element will have the same width as its parent element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_height`, the `wrap_content` value: This property sets the element
    height inside its parent element. The values behave the same way as the width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:text`, with the `Hello World!` value: This property sets the text
    to be displayed in the text view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created our main activity, the associated layout was also created. This
    is a way of creating a layout when creating an activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an independent layout without creating a new activity, right-click on
    the `layout` folder (`res/layout/`) and navigate to **New** | **Layout resource
    file**. You can also create a layout file using the same right-click menu by navigating
    to the **New** | **XML** | **Layout XML file**. You can also navigate to these
    two options using the top **File** menu. The following dialog from the next screenshot
    will be displayed to configure the new layout component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new layout](img/B05459_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Type the **Layout File Name** and the **Root Tag**. The root element of our
    main layout was a relative layout, but you can select a different root tag. There
    are five types of layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FrameLayout**: This layout displays usually only one child in an arranged
    area of the screen. If more than one child is added, then the views are displayed
    in a stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LinearLayout**: This layout displays its children by aligning them, one after
    other, in one direction. There are two types of linear layouts: vertical and horizontal,
    which are identified by the `android:orientation` property of the layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TableLayout**: This layout displays its children by distributing them in
    rows and columns. Along with the table layout, you need to use the **TableRow**
    element to create the distribution in rows and columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GridLayout**: This layout displays its children in a rectangular grid. Children
    can fill more than one cell using properties such as `rowSpec` and `columnSpec`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RelativeLayout**: This layout displays its children by the relative positions
    between them. You have to use the position properties in the children''s views
    to determine their position. At least one child view needs to have a position
    property relative to the parent view, so that child view, and the ones relative
    to it, can be positioned inside the parent layout. Some of these properties are
    `android:layout_below`, `android:layout_toLeftOf`, or `android:layout_alignBottom`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the layout is created, the associated activity can be changed to a different
    activity using the editor. If the layout has no activity, any existing one can
    be linked to it from the editor. To accomplish this, search for the **Associate
    with Activity** option in the toolbar of the layout editor, click on it, and select
    the **Associate with other Activity** option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new layout](img/B05459_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A dialog box that lists all the activities of your project will open, and you
    can select one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our main layout is a relative layout and contains a text view saying **Hello
    World!**. Now let's add a new component. The easiest way to do this is using the
    graphical editor, so open the **Design** tab. Select a component and drag it into
    the layout preview; for example, navigate to the **Person Name** component in
    **Text Fields** and place it below the text view.
  prefs: []
  type: TYPE_NORMAL
- en: Since our root layout is a relative layout, as you drag the element in the layout,
    some line guides are displayed. The properties related to the position are also
    shown in the top part of the **Preview** as you try to drag and drop the element
    in the layout. These lines and suggested properties, which are shown in the following
    screenshot, can help you properly align the element in your screen. They also
    help you to set the element position relative to the rest of the elements that
    are already in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding components](img/B05459_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The properties suggested in the **Preview** panel from the previous screenshot
    align the text field to the left of the parent element (**alignParentLeft**),
    set the text field position below the **Hello World!** text view (**below=textView**),
    and add a margin to the text view of 38 dp (**margin=38 dp**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Component Tree** view, there is now a new `editText` object. Keep
    the text field selected to examine its properties loaded in the **Properties**
    inspector. Let''s change some of them and observe the differences in the layout
    preview and in **Component Tree**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**layout:width**: This option will adapt the width of the field to its content.
    Its current value is `wrap_content`. Change it to `match_parent` to adapt it to
    the parent layout width (the root relative layout).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hint**: Type `Enter your name` as the hint of the field. The hint is a text
    shown when the field is empty to indicate the information that should be typed.
    As the field has a default value, `Name`, the hint is not visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**id**: This has `@+id/editText` as the current ID. The ID will be used from
    the code to get access to this object and is the ID displayed in the component
    tree. This ID can also be used by other elements in the layout to determine their
    relative position to it. Change it to `@+id/editText_name` to distinguish it easily
    from other text fields. Check whether the component ID has also changed in the
    **Component Tree** window, as shown in the following screenshot:![Adding components](img/B05459_05_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**text**: This deletes the value of this field. The hint should now be visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we switch to the text editor, we can see the XML definition of the text
    field with the properties we edited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a recommended order for the properties of the XML definitions. Having
    a specific order helps to understand the code when reading it and makes it easier
    to modify the elements. Select the `EditText` code definition and execute the
    **Reformat Code** action in the **Code** menu. The properties order has now changed,
    placing the `android:id` at the first position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can check the position properties (`android:layout_marginTop`, `android:layout_below`,
    and `android:layout_alignParentLeft`) that match the properties displayed in the
    graphical editor while you were dragging the edit text in the layout. Note that
    the `android:layout_below` property uses the ID of the text view to identify it.
  prefs: []
  type: TYPE_NORMAL
- en: From the text editor, the existing components and their properties can also
    be changed. Modify the text view ID (the `android:id` property) from `@+id/textView`
    to `@+id/textView_greeting`. Having a descriptive ID is important since it will
    be used by our code. Descriptive variable names allow the code to be self-documenting.
    You will need to change all the references to the text view ID to the new ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another component using the text editor this time. Press the **Open
    Tag** key and start typing `Button`. A list of suggestions will appear to help
    you with the code completion. Let the list of suggestions appear and select a
    `Button` object. Inside the `Button` tag, add the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:id`, with the `@+id/button_accept` value: This creates the ID property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_width`, with the `wrap_content` value: This lets the width
    adapt to the button content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_height`, with the `wrap_content` value: This lets the height
    adapt to the button content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_below`, with the `@id/editText_name` value: This places the
    button below the name text field. We reference the name text field by its ID (`@id/editText_name`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_centerHorizontal`, with the value `true`: This centers the
    button horizontally in the parent layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:text`, with the `Accept` value: This sets the text of the button.
    The recommended way to add a text to a component is by adding it to the `strings.xml`
    file. The component should be configured with the string identifier, instead of
    the string directly. For simplicity, we are adding the string directly to the
    button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final XML definition for the button is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The button is displayed in **Preview**. The next screenshot shows that if we
    switch to the graphical editor, the button is displayed in it and also in **Component
    Tree**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding components](img/B05459_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Component's properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The properties that we added or modified in our main layout can also be modified
    by code, and not only using the layout editor. For example, if you have a `Button`
    object in your code, you can change its text using the `setText` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the properties available for a `View` object are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:alpha`: This XML property sets the alpha value of the view, between
    `0` and `1`, which represents the opacity of the view. You can also use the `setAlpha`
    method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:background`: This XML property sets the background of the view. You
    can also use the `setBackground` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:clickable`: This XML property sets whether the view is clickable or
    not, receiving the click events or not. You can also use the `setClicklable` method
    from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:elevation`: This XML property sets the elevation value of the view,
    its z depth value. You can also use the `setElevation` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:fadeScrollbars`: This XML property sets whether the scroll bars fade
    out when they are not in use. You can also use the `setScrollbarFadingEnabled`
    method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:focusable`: This XML property sets whether the view can take the focus
    or not. You can also use the setFocusable method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:foreground`: This XML property sets the foreground of the view. You
    can also use the `setForeground` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:foregroundTint`: This XML property sets the tint color for the foreground
    of the view. You can also use the `setForegroundTintList` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:id`: This XML property sets the identifier of the view. You can also
    use the `setId` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:minHeight`: This XML property sets the minimum height that the view
    should have. You can also use the `setMinimumHeight` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:minWidth`: This XML property sets the minimum width that the view
    should have. You can also use the `setWidth` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:padding`: This XML property sets the padding for the four edges of
    the view. You can also use the `setPadding` method from code. Similar to this
    property are: `android:paddingBottom`, `android:paddingEnd`, `android:paddingLeft`,
    `android:paddingRight`, `android:paddingStart`, and `android:paddingTop`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:scrollIndicators`: This XML property sets whether the scroll indicators
    are shown for the view. You can also use the `setScrollIndicators` method from
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:textAlignment`: This XML property sets the alignment of the text in
    the view. You can also use the `setTextAlignment` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:visibility`: This XML property sets whether the view is visible or
    not. You can also use the `setVisibility` method from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the properties of a `View` object, `View` subclasses can provide
    some more specific properties. For example, the `TextView` objects also have these
    properties: `android:editable`, `android:fontFamily`, `android:hint`, `android:text`,
    or `android:textColor`.'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating Android applications, we have to take into account the existence
    of multiple screen sizes and screen resolutions. It is important to check how
    our layouts are displayed in different screen configurations. To accomplish this,
    Android Studio provides a functionality to change the virtual device that renders
    the layout preview when we are in the **Design** mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find this functionality in the toolbar and click on it to open the list
    of available device definitions, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting multiple screens](img/B05459_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try some of them. The difference between a tablet device and a device like those
    from the Nexus line is very notable. We should adapt the views to all the screen
    configurations our application supports to ensure that they are displayed optimally.
    Note that there are device definitions for Android Wear (**square**, **round**,
    and **round chin** designs) and for Android TV.
  prefs: []
  type: TYPE_NORMAL
- en: 'The device definitions indicate the screen size, resolution, and screen density.
    Android screen densities include ldpi, mdpi, tvdpi, hdpi, xhdpi, and even xxhdpi.
    Let''s see what their values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ldpi** : This is **low-density dots per inch**, and its value is about 120
    dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mdpi**: This is **medium-density dots per inch**, and its values is about
    160 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tvdpi**: This is **medium-density dots per inch**, and its value is about
    213 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hdpi**: This is **high-density dots per inch**, and its value is about 240
    dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xhdpi**: This is **extra-high-density dots per inch**, and its value is about
    320 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xxhdpi**: This is **extra-extra-high-density dots per inch**, and its value
    is about 480 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xxxhdpi**: This is **extra-extra-extra-high-density dots per inch**, and
    its value is about 640 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last dashboards published by Google show that most devices have high-density
    screens (42.3 percent), followed by xhdpi (24.8 percent) and xxhdpi (15.0 percent).
    Therefore, we can cover 82.1 percent of all the devices by testing our application
    using these three screen densities. If you want to cover a bigger percentage of
    devices, test your application using mdpi screens (12.9 percent) as well so the
    coverage will be 95.0 percent of all devices. The official Android dashboards
    are available at [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards).
  prefs: []
  type: TYPE_NORMAL
- en: Another issue to keep in mind is the **device orientation**. Do we want to support
    the landscape mode in our application? If the answer is yes, then we have to test
    our layouts in landscape orientation. On the toolbar, click on the **layout state**
    option to change the mode either from portrait to landscape or from landscape
    to portrait.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our application supports landscape mode and the layout does not get displayed
    as expected in this orientation, we might want to create a variation of the layout.
    Click on the first icon of the toolbar, that is, the **Configuration to render
    this layout with inside the IDE** option, and select the **Create Landscape Variation**
    option, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting multiple screens](img/B05459_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A new layout will be opened in the editor. This layout has been created in the
    `resources` folder, under the `layout-land` directory, and it uses the same name
    as the portrait layout - `/src/main/res/layout-land/activity_main.xml`. The Android
    system will decide which version of the layout needs to be used depending on the
    current device orientation. Now, we can edit the new layout variation so that
    it perfectly conforms to landscape mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can create a variation of the layout for extra-large screens.
    Select the **Create layout-xlarge Variation** option. The new layout will be created
    in the `layout-xlarge` folder using the same name as the original layout at `/src/main/res/layout-xlarge/activity_main.xml`.
    Android divides into actual screen sizes of small, normal, large, and extra large:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Small**: Screens classified in this category are at least 426 dp x 320 dp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal**: Screens classified in this category are at least 470 dp x 320 dp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large**: Screens classified in this category are at least 640 dp x 480 dp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extra large**: Screens classified in this category are at least 960 dp x
    720 dp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **density-independent pixel** (**dp**) is equivalent to one physical pixel
    on a 160 dpi screen. The latest dashboards published by Google show that most
    devices have a normal screen size (85.1 percent), followed by large screen size
    (8.2 percent). The official Android dashboards are available at [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards).
  prefs: []
  type: TYPE_NORMAL
- en: 'To display multiple device configurations at the same time, click on the **Configuration
    to render this layout with inside the IDE** option in the toolbar and select the
    **Preview All Screen Sizes** option, or click on the **Preview Representative
    Sample** option to open only the most important screen sizes, as shown in the
    following screenshot. We can also delete any of the samples by right-clicking
    on them and selecting the **Delete** option from the menu. Another useful action
    of this menu is the **Save screenshot** option. It allows us to take a screenshot
    of the layout preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting multiple screens](img/B05459_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we create different layout variations, we can preview all of them by selecting
    the **Preview Layout Versions** option. If we want to preview what the layout
    looks like for different Android versions, we can use the **Preview Android Versions**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to add different components and optimize our layout
    for different screens, let's start working with themes.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the UI theme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layouts and widgets are created using the default UI theme of our project. We
    can change the appearance of the elements of the UI by creating styles. Styles
    can be grouped to create a theme, and a theme can be applied to an activity or
    to the whole application. Some themes are provided by default, such as the **Material
    Design** or **Holo** style. Styles and themes are created as resources under the
    `/src/res/values` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To continue our example, we are going to change the default colors of the theme
    that we are using in our app. Using the graphical editor, you can see that the
    selected theme for our layout is shown as **AppTheme** in the toolbar. This theme
    was created for our project and can be found in the `styles` file at `/src/res/values/styles.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `styles` file. Android Studio suggests we use the **Theme Editor**.
    You can click on the message link or you can navigate to **Tools** | **Android**
    | **Theme Editor** to open it. You can see the **Theme Editor** in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the UI theme](img/B05459_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The left panel shows what different UI components look like. For example, you
    can view the appearance of the app bar, different types of buttons, text views,
    or the appearance of the status bar. The right panel of the **Theme Editor** contains
    the settings of the theme. You can change the values from the right panel and
    see how the components change in the left panel of **Theme Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: In the right-hand configuration panel, you can change the **Theme** to modify,
    you can change the **Theme parent** of the selected theme, and you can change
    the theme colors. You will note that **AppTheme** is by default an extension of
    another theme, `Theme.AppCompat.Light.DarkActionBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to change the main color of our app. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for the **colorPrimary** property on the right panel of the **Theme Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the color square of the **colorPrimary** property. The color selector
    of the following screenshot will be opened:![Changing the UI theme](img/B05459_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a different color and click on the **OK** button. Note that the theme
    has changed and now the app bar has the new color in **Theme Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your main layout file. The preview of the layout has also changed its color.
    This theme primary color will be applied to all our layouts due to the fact that
    we configured it in the theme and not just in the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The specification of the colors is saved in the `colors` file at `/src/res/values/colors.xml`.
    This is the current content of the `colors` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also change the colors from this file. Modify the `colorPrimaryDark`,
    save the file, and note that in the **Theme Editor**, the status bar color has
    changed to the new color. Switch to your main layout file and observe that the
    preview of your layout has also changed to show the new color in the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the layout theme completely, click on the theme option from the toolbar
    in the graphical editor. The theme selector dialog is now opened, displaying a
    list of the available themes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the UI theme](img/B05459_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The themes created in our own project are listed in the **Project Themes** section.
    The **Manifest Themes** section shows the theme configured in the application
    manifest file (`/src/main/AndroidManifest.xml`). The **All** section lists all
    the available themes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user interface would be useless if the rest of the application could not
    interact with it. Events in Android are generated when the user interacts with
    our application. All the UI widgets are children of the `View` class, and they
    share some events handled by the following listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnClickListener`: This captures the event when the user clicks on the view
    element. To configure this listener in a view, use the `setOnClickListener` method.
    The `OnClickListener` interface declares the following method to receive the click
    event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnCreateContextMenu`: This captures the event when the user performs a long
    click on the view element and we want to open a context menu. To configure this
    listener in a view, use the `setOnCreateContextMenu` method. The `OnCreateContextMenu`
    interface declares the following method to receive the long-click event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnDragListener`: This captures the event when the user drags and drops the
    event element. To configure this listener in a view, use the `setOnDragListener`
    method. The `OnDragListener` interface declares the following method to receive
    the drag event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnFocusChangedListener`: This captures the event when the user navigates from
    an element to another in the same view. To configure this listener in a view,
    use the `setOnFocusChangedListener` method. The `OnFocusChangedListener` interface
    declares the following method to receive the change of focus event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnHoverListener`: This captures the event when the user is moving over an
    element. To configure this listener in a view, use the `setOnHoverListener` method.
    The `OnHoverListener` interface declares the following method to receive the hover
    event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnKeyListener`: This captures the event when the user presses any key while
    the view element has the focus. To configure this listener in a view, use the
    `setOnKeyListener` method. The `OnKeyListener` interface declares the following
    method to receive the key event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnLayoutChangeListener`: This captures the event when the layout of a view
    changes its bounds due to layout processing. To configure this listener in a view,
    use the `setOnLayoutChangeListener` method. The `OnLayoutChangeListener` interface
    declares the following method to receive the layout change event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnLongClickListener`: This captures the event when the user touches the view
    element and holds it. To configure this listener in a view, use the `setOnLongClickListener`
    method. The `OnLongClickListener` interface declares the following method to receive
    the long click event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnScrollChangeListener`: This captures the event when the scroll position
    of a view changes. To configure this listener in a view, use the `setOnScrollChangeListener`
    method. The `OnScrollChangeListener` interface declares the following method to
    receive the scroll change event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OnTouchListener`: This captures the event when the user touches the view element.
    To configure this listener in a view, use the `setOnTouchListener` method. The
    `OnTouchListener` interface declares the following method to receive the touch
    event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition to these standard events and listeners, some UI widgets have some
    more specific events and listeners. Checkboxes can register a listener to capture
    when its state changes (`OnCheckedChangeListener`), and spinners can register
    a listener to capture when an item is clicked (`OnItemClickListener`).
  prefs: []
  type: TYPE_NORMAL
- en: The most common event to capture is when the user clicks on the view elements.
    There is an easy way to handle it—using the view properties. Select the **Accept**
    button in our layout and look for the `onClick` property. This property indicates
    the name of the method that will be executed when the user presses the button.
    This method has to be created in the activity associated with the current layout,
    our main activity (`MainActivity.java`) in this case. Type `onAcceptClick` as
    the value of this property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the main activity to create the method definition. When a view is clicked,
    the event callback method when has to be public with a `void` return type. It
    receives the view that has been clicked on as parameter. This method will be executed
    every time the user clicks on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From the main activity, we can interact with all the components of the interface,
    so when the user presses the **Accept** button, our code can read the text from
    the name field and change the greeting to include the name in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the reference to a `view` object, use the `findViewById` method inherited
    from the `Activity` class. This method receives the ID of the component and returns
    the `View` object corresponding to that ID. The returned view object has to be
    cast to its specific class in order to use its methods, such as the `getText`
    method of the `EditText` class, to get the name typed by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first two lines of the method, the references to the elements of the
    layout are retrieved: the text view that contains the greeting and the text field
    where the user can type a name. The components are found by their IDs, the same
    ID that we indicated in the properties of the element in the layout file. All
    the IDs of resources are included in the `R` class. The `R` class is autogenerated
    in the build phase and therefore we must not edit it. If this class is not autogenerated,
    then probably some file of our resources contain an error.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line is a conditional statement used to check whether the user typed
    a name. If they typed a name, the text will be replaced by a new greeting that
    contains that name. In the coming chapters, you will learn how to execute our
    application in an emulator, and we will be able to test this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the event we want to handle is not the user''s click, then we have to create
    and add the listener by code to the `onCreate` method of the activity. There are
    two ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the listener interface in the activity and then adding the unimplemented
    methods. The methods required by the interface are the methods used to receive
    the events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a private anonymous implementation of the listener in the activity
    file. The methods that receive the events are implemented in this object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the listener implementation has to be assigned to the view element
    using the setter methods, such as `setOnClickListener`, `setOnCreateContextMenu`,
    `setOnDragListener`, `setOnFocusChange`, `setOnKeyListener`, and so forth. The
    listener assignment is usually included in the `onCreate` method of the activity.
    If the listener is implemented in the same activity, then the parameter indicated
    to the setter method is the own activity using the `this` keyword, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The activity should then implement the listener and the `onClick` method required
    by the listener interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we implement it using a private anonymous class, the code would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to create and edit the user interface layouts using
    both the graphical and the text-based editors. We finished our first small application,
    and we upgraded it with some basic components. You should now be able to create
    a simple layout and test it with different styles, screen sizes, and screen resolutions.
    You also learned about the different available UI themes. Finally, you learned
    about events and learned how to handle them using listeners.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about some useful tools available in the
    Android Studio. We will use the SDK Manager frequently to install different packages.
    You will also learn about the AVD Manager for different virtual devices to test
    your applications on. We will generate Javadoc documentation for our project using
    the Javadoc utility, and you will learn about the version control systems available
    in Android Studio.
  prefs: []
  type: TYPE_NORMAL
