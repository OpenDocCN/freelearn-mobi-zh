<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Expanding your UI – Fragments, Resources, and Gathering User Input</h1></div></div></div><p>In the previous chapter, we concentrated on creating a strong foundation for your app's user interface. In this chapter, we'll build on these foundations using additional resources, such as arrays, dimensions, and 9-patch images.</p><p>Once we've perfected the <em>appearance</em> of your UI, we'll explore how to make the UI react to user input, before taking a look at one UI component that can help us make the most out of devices with larger screens: <em>fragments</em>. And since fragments aren't the <em>only</em> way to take advantage of the extra screen space, we'll also take a look at the multi-window and picture-in-picture modes coming up in Android N.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>More resource types</h1></div></div></div><p>If your app features any text, then as a general rule, the text belongs in your project's <code class="literal">res/strings.xml</code> file as a string resource and <em>not</em> in your application code. Although we've touched on string resources in the previous chapter, they're such an integral part of the vast majority of Android applications that it makes sense to look at them in more detail, particularly in regards to some of the more complex tasks you can perform with string resources, such as creating string arrays.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Creating and styling string resources</h2></div></div></div><p>A string is a simple resource that you define once in your project's <code class="literal">res/values/strings.xml</code> file, and then use it multiple times throughout your project.</p><p>You define string resources using the following syntax:</p><pre class="programlisting">&lt;resources&gt; &#13;
 &#13;
&lt;string name="string_name"&gt;This is the text that'll appear whenever you reference this string resource.&lt;/string&gt; &#13;
 &#13;
&lt;/resources&gt; &#13;
</pre><p>You also have the option to add style attributes to your string resources, so every time you use the string resource in your application, it has exactly the same styling. Android supports the following HTML markup:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;b&gt;</code> for bold text</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;i&gt;</code> for italic text</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;u&gt;</code> for underlined text</li></ul></div><p>Wrap your chosen HTML markup around the text you want to style:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
 &#13;
&lt;string name="Hello World"&gt;Hello world, &lt;b&gt;welcome&lt;/b&gt; to my app!&lt;/string&gt; &#13;
 &#13;
&lt;string name="click"&gt;Please click the &lt;i&gt;button&lt;/i&gt; to continue&lt;/string&gt; &#13;
 &#13;
&lt;/resources&gt; &#13;
</pre><p>Although you'll typically reference string resources from your application's layout resource files, you can also reference a string via your Java code:</p><pre class="programlisting">String string = getString(R.string.string_name);</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Creating string arrays</h2></div></div></div><p>A string array is exactly what it sounds like: an array of string resources.</p><p>String arrays are useful when you have multiple related strings that always appear together, such as a list of options in a recurring menu.</p><p>While you <em>could</em> define every item as a separate string resource and then reference each string individually, this is pretty time consuming, plus you'll need to remember a long list of different string IDs! It usually makes more sense to add all your string resources to a single array, so you can display all these strings just by referencing a single string array.</p><p>You typically create string arrays in a dedicated <code class="literal">res/values/arrays.xml</code> file. For example, the following XML defines a string array called <strong>ingredients</strong> that consists of five string resources:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
 &#13;
   &lt;string-array  &#13;
 &#13;
//Create your string array// &#13;
 &#13;
name="ingredients"&gt; &#13;
 &#13;
//Give your array a descriptive name// &#13;
 &#13;
      &lt;item&gt;Self-raising flour&lt;/item&gt; &#13;
 &#13;
//Add each string to your array// &#13;
 &#13;
      &lt;item&gt;Butter&lt;/item&gt; &#13;
      &lt;item&gt;Caster sugar&lt;/item&gt; &#13;
      &lt;item&gt;Eggs&lt;/item&gt; &#13;
      &lt;item&gt;Baking powder&lt;/item&gt; &#13;
   &lt;/string-array&gt; &#13;
 &#13;
&lt;/resources&gt; &#13;
</pre><p>To load this string array, use the <code class="literal">getStringArray()</code> method of the <code class="literal">Resources</code> class:</p><pre class="programlisting">Resources res = getResources(); &#13;
String[] ingredients = res.getStringArray (R.array.ingredients); &#13;
</pre><p>String arrays are also useful for rapidly populating spinner controls. Assuming the spinner control's options are static and predetermined, you can define all these options in a string array and then load the array inside the spinner control.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>A <strong>spinner</strong> is a UI element where the user selects one value from a list of options. When the user touches the spinner control, a drop down appears displaying all the available options. The user can then select an option from the list, and the spinner control then displays this selected option in its default, unopened state.</p></div></div><p>To populate a spinner using a string array, add the spinner control to your activity's layout resource file, and then reference the array using <code class="literal">android:entries:</code>
</p><pre class="programlisting">&lt;Spinner &#13;
    android:layout_height="wrap_content" &#13;
    android:layout_width="match_parent" &#13;
    android:id="@+id/spinnerOfIngredients" &#13;
    android:entries="@array/ingredients"&gt; &#13;
&lt;/Spinner&gt; &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Defining dimensions in dimens.xml</h2></div></div></div><p>Android supports several different units of measurement that you can hardcode into your project using XML or Java, such as <code class="literal">android:textSize="20sp"</code>. However, you can also define the dimensions you want to use in advance in your project's <code class="literal">res/values/dimens.xml</code> file:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
  &lt;dimen name="textview_width"&gt;26dp&lt;/dimen&gt; &#13;
  &lt;dimen name="textview_height"&gt;35dp&lt;/dimen&gt; &#13;
  &lt;dimen name="headline_size"&gt;41sp&lt;/dimen&gt; &#13;
  &lt;dimen name="bodytext_size"&gt;20sp&lt;/dimen&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>Then, you can set the size of your UI components by referencing the corresponding value within your <code class="literal">dimens.xml</code> file:</p><pre class="programlisting">&lt;TextView &#13;
   android:layout_height="@dimen/textview_height" &#13;
   android:layout_width="@dimen/textview_width" &#13;
   android:textSize="@dimen/headline_size"/&gt; </pre><p>You can also apply values from your <code class="literal">dimens.xml</code> file using Java:</p><pre class="programlisting">textElement.setWidth(getResources().getDimensionPixelSize(R.dimen.headline_size)); &#13;
</pre><p>But why go to the extra effort of using the <code class="literal">dimens.xml</code> file, when you can just add dimension information to your layout directly?</p><p>Though this may seem like the quickest option, it isn't good practice to mix your dimensions with your layout and application code. Similar to string resources, the <code class="literal">dimens.xml</code> file provides a single, dedicated place where you can change your project's dimensions <em>without</em> having to touch the rest of your code. It also helps you create a consistent user interface, as it encourages you to define a set of values once and then use these same values throughout your app.</p><p>Secondly, you can use multiple <code class="literal">dimens.xml</code> files to create a more flexible user interface. Using the <code class="literal">dimens.xml</code> files in this way does require a bit of prep work, as you'll need to create multiple <code class="literal">res/values</code> folders that target Android's different generalized densities. In the same way you, create multiple <code class="literal">drawable</code> folders to manage your project's images.</p><p>Open your project's <code class="literal">res</code> folder and create the following folders:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">values-ldpi</code>: Targets 120dpi devices</li><li class="listitem" style="list-style-type: disc"><code class="literal">values-mdpi</code>: Targets 60dpi devices</li><li class="listitem" style="list-style-type: disc"><code class="literal">values-hdpi</code>: Targets 240dpi devices</li><li class="listitem" style="list-style-type: disc"><code class="literal">values-xhdpi</code>: Targets 320dpi devices</li><li class="listitem" style="list-style-type: disc"><code class="literal">values-xxhdpi</code>: Targets 480dpi devices</li></ul></div><p>Then, create a <code class="literal">dimens.xml</code> file inside each folder:</p><p>
</p><div><img src="img/B05061_3_1.jpg" alt="Defining dimensions in dimens.xml"/></div><p>
</p><p>This may seem like a lot of work, but once you have this structure in place, you can use your <code class="literal">dimens</code>. files to define the sets of values that are optimized for each screen density category. Then, when the Android system loads your layout, it'll select the most appropriate <code class="literal">dimens.xml</code> file for the current screen configuration and apply the file's dimensions to your layout.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p><strong>Downloading the example code</strong></p><p>You can download the example code files for this book from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.
You can download the code files by following these steps:
</p><div><ol class="orderedlist arabic"><li class="listitem">Log in or register to our website using your e-mail address and password.</li><li class="listitem">Hover the mouse pointer on the <strong>SUPPORT</strong> tab at the top.</li><li class="listitem">Click on <strong>Code Downloads &amp; Errata</strong>.</li><li class="listitem">Enter the name of the book in the <strong>Search</strong> box.</li><li class="listitem">Select the book for which you're looking to download the code files.</li><li class="listitem">Choose from the drop-down menu where you purchased this book from.</li><li class="listitem">Click on <strong>Code Download</strong>.</li></ol></div><p>
</p><p>You can also download the code files by clicking on the <strong>Code Files</strong> button on the book's webpage at the Packt Publishing website. This page can be accessed by entering the book's name in the <strong>Search</strong> box. Please note that you need to be logged in to your Packt account.</p><p>
</p><p>Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">WinRAR / 7-Zip for Windows</li><li class="listitem" style="list-style-type: disc">Zipeg / iZip / UnRarX for Mac</li><li class="listitem" style="list-style-type: disc">7-Zip / PeaZip for Linux</li></ul></div><p>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Color state lists</h2></div></div></div><p>Each time the user interacts with a UI element, your app will signal that it's registered this interaction. Sometimes, this signal will be built-in: a new screen loads up, a pop up opens, or a <em>tick</em> appears in a checkbox. However, if it isn't immediately obvious that a UI element has registered the user's input, you should give them a visual clue. One possible method is to use the <strong>color state list</strong>.</p><p>A color state list defines a series of states and assigns a color to each of these states. When you apply a color state list to a view, the view displays different colors from the list based on its current state.</p><p>Color state lists are most commonly applied to buttons. For example, a grey button may briefly turn a darker shade of grey when it's in a depressed state, leaving the user in no doubt about whether the button has registered their interaction.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Color state lists are similar to the state list resources that we looked at in the previous chapter—we're just signaling changes of state using colors rather than images.</p></div></div><p>To create a color state list, open your project's <code class="literal">res/drawable</code> folder and create a new XML file; give the file a name that indicates its purpose, such as <code class="literal">res/drawable/button_background.xml</code>. Then, fill this file with all the different states that you want to trigger a color change and the colors you'd like to use.</p><p>The potential states include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:state_pressed="true/false."</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:state_focused="true/false."</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:state_selected="true/false."</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:state_checkable="true/false."</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:state_checked="true/false."</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:state_enabled="true/false."</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android:state_window_focused= "true/false."</code></li></ul></div><p>In this example, we're going to add two states to a color state list:</p><pre class="programlisting">&lt;selector  &gt; &#13;
 &#13;
//A color state list must be inside a single selector element// &#13;
 &#13;
&lt;item &#13;
 &#13;
//Add each state and color as a separate &lt;item&gt;// &#13;
 &#13;
android:state_pressed="true" &#13;
 &#13;
//If the current state is pressed...// &#13;
 &#13;
android:color="@color/green" /&gt; &#13;
 &#13;
//....Apply the color green to this view// &#13;
 &#13;
&lt;item &#13;
 &#13;
android:color="@color/blue/&gt; &#13;
 &#13;
//If the View is in its default state, apply the color blue instead. We're using blue as the default that'll be applied to the view when none of the above states are relevant// &#13;
</pre><div><div><h3 class="title"><a id="note17"/>Note</h3><p>The order you place your <code class="literal">&lt;item&gt;</code> element within the selector element is crucial, as the system works its way through the color state list in order and selects the first item that applies to the view's current state. As you saw in the preceding example, you can create a default color that'll be applied to the view when none of the other states are applicable. If you create a default state, then you must<em> always</em> place it at the very end of the color state list as a final resort.</p></div></div><p>The only thing left to do is apply the color state list resource to your view:</p><pre class="programlisting">&lt;Button &#13;
   android:layout_width="match_parent" &#13;
   android:layout_height="wrap_content" &#13;
   android:text="@string/button_text" &#13;
   android:background:="@drawable/button_background" /&gt; &#13;
</pre><p>You can also refer to your color state list resource in Java using <code class="literal">R.drawable.button_text</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Working with 9-patch images</h1></div></div></div><p>A 9-patch graphic is a stretchable bitmap that allows you to define which areas the system can and can't stretch when it needs to resize your image to fit the current screen.</p><p>When you convert a regular image into a 9-patch image, you add an extra 1-pixel-wide border around your image's top and left areas. This 1-pixel border pinpoints exactly which pixels the system should replicate if it needs to create a stretched effect rather than simply resizing the entire image:</p><p>
</p><div><img src="img/B05061_3_2.jpg" alt="Working with 9-patch images"/></div><p>
</p><p>Your border doesn't have to be a continuous line; if there's any area you don't want the system to stretch, just leave the area as a gap in your border. In the previous example, the system can stretch the drawable horizontally and vertically by replicating the pixels marked with the black line. However, the corners aren't marked, so these will remain the same size, creating a sharper, more defined corner.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Converting an image into 9-patch format adds an extra pixel to your image's perimeter. Keep this in mind when you're creating images with the intention of converting them into 9-patches!</p></div></div><p>Although your image can include multiple stretchable sections, your lines must be exactly 1 pixel wide for the Android system to correctly recognize these lines; stretch your image accordingly (if appropriate), and then remove the lines from the finished image. If you add any lines that are thicker than one pixel, the system will treat these lines as just another part of your image.</p><p>If you do use 9-patches, you still need to provide alternate versions of these images for each of Android's generalized screen densities (<code class="literal">ldpi</code>, <code class="literal">mdpi</code>, <code class="literal">hdpi</code>, <code class="literal">xhdpi</code>, and <code class="literal">xxhdpi</code>). When the system loads your app, it'll select the 9-patch image that's the best fit for the current screen density, and then it will stretch the image's <em>stretchable</em> sections if required.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>9-patch images can stretch, but they can't shrink. For the best results when creating 9-patch images that target the different density folders, you should target the lowest common resolution for each density category.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>How do I create 9-patch images?</h2></div></div></div><p>There are lots of different PNG editors out there, but I'll be using Draw 9-patch as this editor is included in the Android SDK, so chances are you already have it installed on your computer.</p><p>You'll find the <code class="literal">Draw9patch.bat</code> program in your computer's <code class="literal">sdk/tools</code> folder. Launch the editor and import your image by dragging it into the Draw 9-patch window.</p><p>The 9-patch workspace consists of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Left pane</strong>: This is the drawing area where you define your image's stretchable sections.</li><li class="listitem" style="list-style-type: disc"><strong>Right pane</strong>: This is the preview area, which displays a preview of how your graphic will appear when stretched. As you're editing your image in the left pane, make sure you keep an eye on this preview.</li></ul></div><p>
</p><div><img src="img/B05061_3_3.jpg" alt="How do I create 9-patch images?"/></div><p>
</p><p>To define the area that can be stretched horizontally, draw a line along the top of your image by clicking. Every time you click, a new pixel will be added to your line.</p><p>
</p><div><img src="img/B05061_3_4.jpg" alt="How do I create 9-patch images?"/></div><p>
</p><p>If you make a mistake, you can remove pixels by holding the <em>
<strong>Shift</strong>
</em> key while clicking each pixel you want to remove.</p><p>To define the area that can be stretched vertically, click to draw a line along your image's left edge.</p><p>Once you're happy with the results, save your 9-patch image by selecting <strong>File</strong> | <strong>Save 9-patch</strong>. This saves your image with the <code class="literal">.9.png</code> extension. You can then add this graphical resource to your project as normal.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>If you're not a fan of Draw 9-patch, or you just want to try an alternative, there are several free online tools that you can use to create 9-patch images, including <a class="ulink" href="http://draw9patch.com/">http://draw9patch.com/</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Registering the user input</h1></div></div></div><p>Input controls are your UI's interactive components, such as buttons, <code class="literal">EditText</code> fields, and checkboxes.</p><p>We've already seen how you can drop input controls into your UI, but input controls don't register user input out of the box.</p><p>To turn UI components, such as buttons and <code class="literal">EditText</code> fields, into fully-functioning interactive components, you'll need to write some extra code.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Handling click events</h2></div></div></div><p>Click events are one of the most common input events your UI will have to handle. A click event is simply where the user touches an onscreen element, such as tapping a button or a checkbox.</p><p>A button cannot process clicks on its own; you'll need to create a listener and then assign it to the button. When the user taps the button, the listener registers the tap and executes the code from your <code class="literal">onClick</code> method.</p><p>Let's imagine that your layout contains a single button, and you want that button to register click events. As with many things in Android, you can create the same effect via XML or via your application code.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec15"/>Handling onClick Via Java</h3></div></div></div><p>Here's how you can handle these events using <code class="literal">Java</code>.</p><pre class="programlisting">Button button = (Button) findViewById(R.id.button1&#13;
&#13;
//Get a reference to the view you want to assign the listener to// &#13;
button.setOnClickListener(new View.OnClickListener() { &#13;
 &#13;
//Assign the setOnClickListener listener to this view// &#13;
 &#13;
                @Override &#13;
                public void onClick(View view) { &#13;
 &#13;
//Override the onClick method//  &#13;
 &#13;
.... &#13;
.... &#13;
 &#13;
// This is where you'd implement the code that tells your app what action it needs to perform whenever it registers a click event, for example you might want your app to launch a new activity, open a menu, or start playing a video// &#13;
 &#13;
} &#13;
  }); &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec16"/>Handling onClick Via XML</h3></div></div></div><p>You can create the same functionality via your layout resource file by adding the <code class="literal">android:onClick</code> attribute to your view, and then adding the <code class="literal">onClick</code> method to the corresponding Java file:</p><pre class="programlisting">&lt;Button &#13;
      android:id="@+id/button1"&#13;
      android:layout_width="wrap_content"&#13;
      android:layout_height="wrap_content"&#13;
      android:onClick="buttonClicked"&#13;
      android:text="Click me" /&gt; &#13;
</pre><p>Whenever the user clicks this button, the <code class="literal">buttonClicked</code> method will be executed, so the next step is to add this method to your Java file:</p><pre class="programlisting">public void buttonClicked(View v) { &#13;
Toast.makeText(this, "The button has been clicked!", Toast.LENGTH_LONG).show(); &#13;
 &#13;
//So you can test whether the buttonClicked method is working correctly, we'll tell the app to display a "The button has been clicked" message whenever buttonClicked is executed//  &#13;
 &#13;
  } &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Registering the EditText input</h2></div></div></div><p>When you drop <code class="literal">EditText</code> into your UI, the user can type text into the field, but by default, <code class="literal">EditText</code> cannot read or use this information.</p><p>For <code class="literal">EditText </code>to acquire user input, you need to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Get a reference to the <code class="literal">EditText</code> field using <code class="literal">findViewById</code>.</li><li class="listitem">Get the text from the <code class="literal">EditText</code> field using <code class="literal">getText()</code>.</li></ol></div><p>You may then want to display this text elsewhere in your UI using <code class="literal">setText()</code>.</p><p>Now that you know how to register click events and retrieve the user input from <code class="literal">EditText</code>, let's look at an example app that combines all this functionality.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec17"/>The example app</h3></div></div></div><p>We'll create a simple app that asks users to enter their name into <code class="literal">EditText</code> and then tap a <strong>Submit</strong> button. The app will then retrieve the user's name from the <code class="literal">EditText</code> field and display it in <code class="literal">TextView</code> as the part of a welcome message.</p><p>Create a simple layout that contains these three onscreen elements:</p><pre class="programlisting">&lt;LinearLayout &#13;
   &#13;
   &#13;
  android:orientation="vertical" &#13;
  android:layout_width="match_parent" &#13;
  android:layout_height="match_parent" &gt; &#13;
 &#13;
      &lt;TextView &#13;
          android:id="@+id/textView1" &#13;
          android:layout_width="wrap_content" &#13;
          android:layout_height="wrap_content" &#13;
          android:text="@string/form" &#13;
          android:textColor="@color/blue" /&gt; &#13;
 &#13;
//Add the TextView. Initially this view will display instructions, but once the user has submitted their name it'll update to display our welcome message instead// &#13;
 &#13;
 &#13;
       &lt;EditText &#13;
          android:id="@+id/editText1" &#13;
          android:layout_width="wrap_content" &#13;
          android:layout_height="wrap_content" &#13;
 &#13;
//Add the EditText// &#13;
 &#13;
          android:background="@color/grey" &#13;
 &#13;
//Depending on your app's color scheme, an empty EditText may blend into the background, so you may want to give the EditText its own background color//  &#13;
 &#13;
 &#13;
          android:hint="@string/yourName" &#13;
          android:ems="10" &gt; &#13;
 &#13;
//Make it clear what information the user needs to enter, using android:hint// &#13;
 &#13;
          &lt;requestFocus /&gt; &#13;
      &lt;/EditText&gt; &#13;
 &#13;
      &lt;Button &#13;
          android:id="@+id/button1" &#13;
          android:layout_width="wrap_content" &#13;
          android:layout_height="wrap_content" &#13;
          android:background="@color/blue" &#13;
          android:text="@string/submit" &#13;
          android:textColor="@color/white" /&gt; &#13;
 &#13;
//Add the Submit button// &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>Next, open <code class="literal">res/values/strings.xml</code> and create your string resources:</p><pre class="programlisting">&lt;resources&gt; &#13;
&lt;string name="app_name"&gt;Form&lt;/string&gt; &#13;
  &lt;string name="form"&gt;Please complete the form below&lt;/string&gt; &#13;
  &lt;string name="yourName"&gt;Enter your name&lt;/string&gt; &#13;
  &lt;string name="submit"&gt;Submit&lt;/string&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>
</p><div><img src="img/B05061_3_5.jpg" alt="The example app"/></div><p>
</p><p>Now that you have your UI, it's time to give these on-screen elements the ability to register and process the user input.</p><p>In this example, we create an event listener and assign it to our <code class="literal">submitButton</code>. When the user taps the <strong>Submit</strong> button, the app registers this interaction and retrieves whatever text is currently in the <code class="literal">EditText</code> field. It then sets this value to <code class="literal">TextView</code>, replacing the default <strong>Please complete the form below</strong> text with the <code class="literal">EditText</code> value, plus two other bits of text, to create our complete welcome message:</p><pre class="programlisting">package com.example.jessica.myapplication; &#13;
 &#13;
import android.os.Bundle; &#13;
import android.app.Activity; &#13;
import android.view.View; &#13;
import android.widget.Button; &#13;
import android.widget.EditText; &#13;
import android.widget.TextView; &#13;
 &#13;
public class MainActivity extends Activity { &#13;
 &#13;
  Button submitButton; &#13;
  EditText nameEdit; &#13;
  TextView welcomeText; &#13;
 &#13;
  @Override &#13;
  public void onCreate(Bundle savedInstanceState) { &#13;
      super.onCreate(savedInstanceState); &#13;
      setContentView(R.layout.activity_main); &#13;
      submitButton = (Button)findViewById(R.id.button1); &#13;
 &#13;
  submitButton.setOnClickListener(new View.OnClickListener() { &#13;
          public void onClick(View view) { &#13;
 &#13;
//Assign the setOnClickListener to your submitButton// &#13;
 &#13;
              nameEdit = (EditText) findViewById(R.id.editText1); &#13;
 &#13;
//Get a reference to the EditText// &#13;
 &#13;
              welcomeText = (TextView)                findViewById(R.id.textView1); &#13;
 &#13;
//Get the text from nameText and set it to the welcomeText TextView. At this point, I'm adding a bit of extra text (Welcome, and !) to create a nicer greeting//  &#13;
 &#13;
              welcomeText.setText("Welcome " +                nameEdit.getText().toString() + "!"); &#13;
          } &#13;
      }); &#13;
  } &#13;
 &#13;
} &#13;
</pre><p>This is it—boot up your app and try interacting with the different UI elements.</p><p>
</p><div><img src="img/B05061_3_6.jpg" alt="The example app"/></div><p>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Working with fragments</h1></div></div></div><p>When you're developing your UI for pre-Android N devices, one of the major restrictions you'll encounter is that you can only ever display a single activity on the screen at any one time. Fragments give you a way to overcome this restriction; although <em>technically</em> you can still only display one activity at a time; each activity can consist of multiple fragments.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Android N introduced multi-window mode, which gives users the ability to display more than one app at a time, allowing them to see multiple activities at once, albeit from different applications! We'll take a closer look at multi-window mode later in this chapter.</p></div></div><p>A fragment is a self-contained, modular section of your app's user interface that you embed inside an activity. You <em>cannot</em> instantiate a fragment as a standalone application element. Think of a fragment as a kind of <em>sub activity</em> that has its own life cycle, behavior, and (usually) its own user interface.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Why do we need fragments?</h2></div></div></div><p>The Android team introduced fragments in Android version 3.0, also known as <strong>Honeycomb</strong>, mainly to help developers make better use of all the extra screen space available on larger devices, such as tablets. Using fragments, you can divide each activity into distinct components and then control each part separately.</p><p>You can also create multiple layouts that combine your project's fragments in different ways depending on the current screen configuration. For example, you could create a multi pane layout that combines multiple fragments in a single activity; and you could create a single pane layout that displays each fragment separately, which is better suited to smaller screens. Your app can then select the most appropriate layout (multi pane or single pane) depending on the current device.</p><p>In this way, fragments are useful for making the most out of devices with larger screens, while also providing a good user experience for users viewing your app on smaller screens.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>You may also want to use fragments to create layouts that are optimized for devices held in landscape and portrait orientation. For example, you can create a layout for landscape devices that displays multiple fragments in a side-by-side configuration, and you can create a single-pane layout that displays one fragment at a time when the device is in portrait mode.</p></div></div><p>The final major benefit of using fragments is that when a fragment's host activity is running, you can add, remove, and replace each fragment independently to create a truly dynamic user interface.</p><p>Let's take a look at an example of how an app that provides single-pane and multi-pane layouts may work.</p><p>Imagine an activity (<strong>Activity 1</strong>) that contains two fragments: <strong>Fragment A</strong> and <strong>Fragment B</strong>. <strong>Fragment A</strong> displays a list of items. When the user selects an item in <strong>Fragment A</strong>, <strong>Fragment B</strong> updates to display information related to the selected item.</p><p>This app includes two different layouts, and it selects which layout to display based on the size of the device's screen. If the screen is large enough to accommodate both <strong>Fragment A</strong> and <strong>Fragment B</strong>, the app displays these fragments side-by-side in <strong>Activity 1</strong>, in a multi-pane layout.</p><p>
</p><div><img src="img/B05061_3_7.jpg" alt="Why do we need fragments?"/></div><p>
</p><p>If there isn't enough room to accommodate both fragments, the app will display each fragment separately, as different screens in a single-pane layout.</p><p>In this scenario, <strong>Activity 1</strong> displays <strong>Fragment A </strong>
<em>only</em>. When the user selects an item from <strong>Fragment A</strong>, the screen updates to display <strong>Fragment B</strong>. This means your app creates an entirely new activity (<strong>Activity 2</strong>) that exists simply to host <strong>Fragment B</strong>:</p><p>
</p><div><img src="img/B05061_3_8.jpg" alt="Why do we need fragments?"/></div><p>
</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>While fragments are important tools that can help you create more flexible layouts, fragments aren't a magical cure. Even if you do include fragments in your user interface, you'll still need to follow all the usual guidelines and best practices <em>in addition to using fragments</em>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/>The fragment life cycle</h2></div></div></div><p>Although a fragment has its own life cycle, the life cycle is directly affected by the life cycle of the host activity. Each life cycle callback for the host activity results in a similar callback for all its fragments; for example, when the host activity's <code class="literal">onStop()</code> method is called, all the fragments within the activity also receive a call to <code class="literal">onStop()</code>, and when the activity is destroyed, so are all its fragments.</p><p>You can only manipulate a fragment's life cycle independently while the host activity is in its resumed state. At this point, you can add, remove, and replace fragments. However, once the host activity leaves its resumed state, all its fragments lose their independence and are once again dependent on the host activity's life cycle.</p><p>Like an activity, a fragment can exist in three states:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Resumed</strong>: The fragment is visible in the running activity.</li><li class="listitem" style="list-style-type: disc"><strong>Paused</strong>: Another activity is in the foreground and has focus, but the fragment's host activity is still visible.</li><li class="listitem" style="list-style-type: disc"><strong>Stopped</strong>: Either the host activity has been stopped, or the fragment has been removed from the activity and added to the back stack. A stopped fragment is still alive, but it's no longer visible to the user.</li></ul></div><p>One major difference between the life cycle of an activity and the life cycle of a fragment is how you restore each one and get its state back:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Activity</strong>: When an activity is stopped, it's placed into a back stack of activities that's managed by the system.</li><li class="listitem" style="list-style-type: disc"><strong>Fragment</strong>: When a fragment is stopped, it's only placed into a back stack that's managed by the host activity <em>if</em> you explicitly request that the instance should be saved. To make this request, call <code class="literal">addToBackStack()</code> during the transaction that removes the fragment.</li></ul></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>
<strong>What is the back stack? And why is it so important?</strong></p><p>The back stack keeps track of all the actions the user can reverse by tapping the device's <strong>Back</strong> button, whether that's a physical back key or one of Android's illuminated soft keys. If you add a fragment to the back stack, then the user can backtrack to that fragment. If you don't add a fragment to the back stack, the user cannot recover that fragment.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Creating a fragment</h2></div></div></div><p>In this section, I'll show you how to create a simple fragment. The first step is defining the fragment's UI component:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your project's <code class="literal">res</code> folder.</li><li class="listitem">Right-click the <code class="literal">layout</code> folder and select <strong>New</strong>, followed by <strong>Layout resource file</strong>.</li><li class="listitem">Give your layout resource file a descriptive name, such as <code class="literal">list_fragment</code>.</li><li class="listitem">Select the<strong> Root Element</strong> option you want to use.</li><li class="listitem">Double-check the <strong>Directory name</strong> option is set to <strong>layout</strong>.</li><li class="listitem">Click <strong>OK</strong>.</li></ol></div><p>Open your new layout resource file and define your fragment's UI:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;LinearLayout     &#13;
android:orientation="vertical"  &#13;
android:layout_width="match_parent" &#13;
android:layout_height="match_parent"&gt; &#13;
  &#13;
 &lt;TextView &#13;
      android:layout_width="wrap_content" &#13;
      android:layout_height="wrap_content" &#13;
      android:text="This is a fragment" &#13;
      android:id="@+id/textView" /&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>Before we create the actual fragment, let's take a moment to look at the issue of backwards compatibility; specifically, how you can reap the benefits of fragments even on devices that run pre-Honeycomb versions of Android.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec18"/>Fragments and backwards compatibility</h3></div></div></div><p>When you're developing an app, you should aim to support as many versions of Android as possible, as this will give you the widest potential audience. Since fragments didn't find their way into Android until version 3.0, if you want your app to be compatible with devices running anything earlier than Android Honeycomb, you'll need to add <code class="literal">v4</code> of <strong>Android Support Library</strong> to your project.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>Android Support Library is a handy set of code libraries that enable you to use features and APIs that wouldn't otherwise be available to the earlier versions of the Android platform.</p><p>Once you add the v4 library to your project, you can use fragments while remaining backwards compatible with devices running versions as low as Android 1.6.</p></div></div><p>To add this library to your project, launch Android SDK Manager, open the <code class="literal">Extras</code> folder and download the <strong>Android Support Library</strong> (if you're using Eclipse) or <strong>Android Support Repository</strong> (if you're using Android Studio).</p><p>If you're using Android Studio, add the library to your project by opening its module-level <code class="literal">build.gradle</code> file and adding the support library to the dependencies section:</p><pre class="programlisting">dependencies { &#13;
.... &#13;
.... &#13;
.... &#13;
  compile 'com.android.support:support-v4:23.1.0' &#13;
} &#13;
</pre><p>If you're developing in Eclipse, perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">libs</code> directory in the root of your project.</li><li class="listitem">Locate the support library called the JAR file in your Android SDK directory (for example, <code class="literal">&lt;sdk&gt;/extras/android/support/v4/android-support-v4.jar</code>). Copy this JAR into the <code class="literal">libs</code> directory you created in the previous step.</li><li class="listitem">Right-click the JAR file and select <strong>Build Path</strong>, followed by <strong>Add to Build Path</strong>.</li></ol></div><p>You'll also need to import the fragment class from the v4 support library (<code class="literal">import android.support.v4.app.Fragment</code>) and extend <code class="literal">FragmentActivity</code> instead of the usual <code class="literal">Activity</code> class (<code class="literal">public class ListFragment extends FragmentActivity</code>).</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>There are no hard and fast rules about which versions of the Android system you should support, though you'll generally want to support as many versions as you feasibly can without compromising on your app's functionality. If you do decide against supporting the earlier versions of the Android platform, then you don't need to use the support library. If you're unsure, it may help you to look at Google's stats about the percentage of Android devices currently running each version of the Android platform, available at <a class="ulink" href="http://developer.android.com/about/dashboards/index.html">http://developer.android.com/about/dashboards/index.html</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec19"/>Creating your fragment class</h3></div></div></div><p>In addition to creating a layout, you need to have a class associated with your fragment. This class must extend <code class="literal">Fragment</code> or <code class="literal">FragmentActivity</code>.</p><p>To add a new class to your project, perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your <code class="literal">Java</code> folder and right-click on your project's package name.</li><li class="listitem">Select <strong>New</strong> followed by <strong>Java Class</strong>.</li><li class="listitem">Give your class a descriptive name, for example, <code class="literal">ListFragment</code>.</li></ol></div><p>Open your new <code class="literal">ListFragment</code> class; it will look similar to this:</p><pre class="programlisting">package com.example.jessica.myapplication; &#13;
 &#13;
public class ListFragment { &#13;
} &#13;
</pre><p>You'll want to make the following changes:</p><pre class="programlisting">package com.example.jessica.myapplication; &#13;
 &#13;
 &#13;
import android.os.Bundle; &#13;
import android.support.v4.app.Fragment; &#13;
import android.view.LayoutInflater; &#13;
import android.view.View; &#13;
import android.view.ViewGroup; &#13;
 &#13;
public class ListFragment extends Fragment { &#13;
 &#13;
//Remember, if you want your app to work on devices running anything earlier than Honeycomb, you need to extend FragmentActivity rather than extending the Fragment class// &#13;
 &#13;
    @Override &#13;
 &#13;
//To inflate your fragment's layout inside the current activity, you need to override the onCreateView() method//  &#13;
 &#13;
 &#13;
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  &#13;
 &#13;
//Your implementation of onCreateView() must return a View, which is the root of your fragment's layout// &#13;
 &#13;
Bundle savedInstanceState) { &#13;
 &#13;
///savedInstanceState is a Bundle that passes data about the previous instance of the fragment, just in case this fragment is being resumed//  &#13;
 &#13;
 &#13;
      View view = inflater.inflate(R.layout.list_fragment, &#13;
              container, false); &#13;
      return view; &#13;
 &#13;
//Inflate a new view hierarchy from the specified layout resource file. In this example, that's list_fragment.xml//   &#13;
 &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">inflate()</code> method (in the preceding code) takes the following arguments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The layout file that's being inflated (<code class="literal">R.layout.list_fragment</code>).</li><li class="listitem" style="list-style-type: disc">The parent <code class="literal">ViewGroup</code> where the inflated fragment layout should be inserted (<code class="literal">container</code>).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">false</code> Boolean that indicates the inflated layout should be attached to the <code class="literal">ViewGroup</code> during inflation.</li></ul></div><p>The next step is to add the fragment to your activity. You have two options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Embed the fragment in your activity's corresponding XML layout file</li><li class="listitem" style="list-style-type: disc">Add the fragment at runtime via your application code</li></ul></div><p>The most straightforward option is embedding your fragmentinside a layout file; however, this does have one big drawback—when you add a fragment declaratively, the fragment is static and will remain on the host activity until it's destroyed. You <em>won't</em> be able to add or remove this fragment during the host activity's life cycle.</p><p>Adding a fragment to an activity via your application code gives you more freedom and flexibility, but it is more difficult to implement a fragment programmatically.</p><p>Since it's the most straightforward approach, let's start by looking at how to add a fragment via your layout resource file.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec20"/>Adding a fragment to your activity declaratively</h3></div></div></div><p>You can add a fragment to an activity using <code class="literal">&lt;fragment&gt;</code> in the same way you declare a view:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;LinearLayout  &#13;
android:orientation="vertical"  &#13;
android:layout_width="match_parent" &#13;
android:layout_height="match_parent"&gt; &#13;
 &#13;
   &lt;fragment &#13;
      android:id="@+id/listFragment" &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="match_parent" &#13;
 &#13;
//Add the fragment// &#13;
 &#13;
     class="com.example.jessica.myapplication.ListFragment" /&gt; &#13;
 &#13;
//Identify the fragment you want to instantiate, using the class attribute// &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>Alternatively, you can identify the fragment using <code class="literal">android:name</code>:</p><pre class="programlisting">&lt;fragment android:name="com.example.jessica.myapplication.ListFragment" &#13;
android:id="@+id/listFragment" &#13;
android:layout_width="match_parent" &#13;
android:layout_height="match_parent" /&gt; &#13;
</pre><p>When it's time to create this activity's layout, the system will instantiate the specified fragment, retrieve its layout, and then display it in place of the original <code class="literal">&lt;fragment&gt;</code> tags.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Adding a fragment to an activity at runtime</h2></div></div></div><p>If you want to add, remove, or replace your fragments during the life cycle of the host activity, things get a bit more complicated, as you'll need to place these fragments in your activity at runtime, which means delving into your application code.</p><p>In this example, we'll be using the same <code class="literal">list_fragment.xml</code> file and the <code class="literal">ListFragment.java</code> class we created earlier. However, instead of the <code class="literal">&lt;fragment&gt;</code> placeholder, we'll be using <code class="literal">FrameLayout</code>, a special container view that indicates where the fragment will eventually be displayed in the layout file:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;LinearLayout  &#13;
android:orientation="vertical"  &#13;
android:layout_width="match_parent" &#13;
android:layout_height="match_parent"&gt; &#13;
 &#13;
  &lt;FrameLayout  &#13;
       &#13;
      android:id="@+id/fragment_container" &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="match_parent" /&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>You then need to tell your activity to replace the <code class="literal">FrameLayout</code> container with your fragment at runtime:</p><pre class="programlisting">package com.example.jessica.myapplication; &#13;
 &#13;
import android.support.v7.app.AppCompatActivity; &#13;
import android.os.Bundle; &#13;
import android.support.v4.app.FragmentActivity; &#13;
 &#13;
public class MainActivity extends FragmentActivity { &#13;
 &#13;
  @Override &#13;
  public void onCreate(Bundle savedInstanceState) { &#13;
      super.onCreate(savedInstanceState); &#13;
      setContentView(R.layout.activity_main); &#13;
 &#13;
       if (findViewById(R.id.list_fragment) != null) { &#13;
 &#13;
       &#13;
          if (savedInstanceState != null) { &#13;
              return; &#13;
          } &#13;
 &#13;
           // Create a new Fragment// &#13;
          ListFragment firstFragment = new ListFragment(); &#13;
           &#13;
          firstFragment.setArguments(getIntent().getExtras()); &#13;
 &#13;
// If this activity was started with special instructions from an Intent, pass the Intent's extras to the fragment as arguments// &#13;
           &#13;
           getSupportFragmentManager().beginTransaction() &#13;
 &#13;
// Call the beginTransaction() method on the fragment manager instance// &#13;
 &#13;
                  .add(R.id.list_fragment, &#13;
 &#13;
//Call the add() method of the fragment transaction instance, and pass it the resource ID of the view that'll contain the fragment (R.id.list_fragment) and the fragment class instance(firstFragment)// &#13;
 &#13;
firstFragment).commit(); &#13;
 &#13;
//The final piece of the above code calls the commit() method of the fragment transaction// &#13;
 &#13;
        } &#13;
    } &#13;
} &#13;
</pre><p>When you add a fragment at runtime, you're free to add, remove, and replace this fragment as and when required. These changes are known as <strong>fragment transactions</strong>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec21"/>Fragment transactions and the back stack</h3></div></div></div><p>Fragment transactions are changes you commit to an activity in response to user interaction.</p><p>Whenever you perform a fragment transaction, you have the option to save this transaction to the back stack. If you do add a transaction to the back stack, the user can navigate back to this fragment state by pressing the device's physical <em>back</em> button or the softkey.</p><p>If you perform a transaction that removes or replaces a fragment and <em>doesn't</em> add the transaction to the back stack, when you commit that transaction, the fragment is destroyed and the user can't navigate back to it.</p><p>If you want the option to add a fragment transaction to the back stack, make sure you add the fragment to the host activity during that activity's <code class="literal">onCreate()</code> method. You can then add the fragment to the back stack by calling <code class="literal">transaction.addToBackStack</code> before you commit a transaction that'll remove the fragment.</p><p>In the next section, you'll learn how to add, remove, and replace fragments. Regardless of the kind of fragmenttransaction you're performing, you'll need to get an instance of <code class="literal">FragmentTransaction</code> from the <code class="literal">FragmentManager</code> class:</p><pre class="programlisting">import android.support.v4.app.FragmentTransaction; &#13;
import android.support.v4.app.FragmentManager; &#13;
 &#13;
//Add the FragmentTransaction and FragmentManager import statements// &#13;
 &#13;
FragmentManager fragmentManager = getSupportFragmentManager(); &#13;
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); &#13;
 &#13;
//Get the FragmentTransaction instance//  &#13;
</pre><p>You can then perform the following fragment transactions.</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec1"/>Adding a fragment</h4></div></div></div><p>You can add a fragment to an activity using the <code class="literal">add()</code> method.</p><p>Pass the <code class="literal">add()</code> method to <code class="literal">ViewGroup</code> where you want to place the fragment, identify the fragment you want to add, and then commit the transaction. For example, take a look here:</p><pre class="programlisting">fragmentTransaction.add(R.id.fragment_container, firstFragment).commit(); &#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec2"/>Removing a fragment</h4></div></div></div><p>To remove a fragment from an activity, you need to use the <code class="literal">remove()</code> method. This method takes a reference to the fragment instance you want to remove, plus the aforementioned <code class="literal">commit()</code> method.</p><p>In this example, we're removing a fragment called <code class="literal">previousFragment</code>:</p><pre class="programlisting">fragmentTransaction.remove(previousFragment).commit(); &#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec3"/>Replacing a fragment</h4></div></div></div><p>To replace one fragment with another fragment at runtime, you need to call the <code class="literal">replace()</code> method of the fragmenttransaction instance.</p><p>The following example shows you how to replace one fragment with another fragment (<code class="literal">newFragment</code>) so that the user has the option to navigate back to the previous fragment. We'll also add the replaced fragment to the back stack:</p><pre class="programlisting">Fragment newFragment = new Fragment(); &#13;
 &#13;
// Create a new fragment// &#13;
 &#13;
FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); &#13;
 &#13;
//Create a new transaction// &#13;
 &#13;
transaction.replace(R.id.list_fragment, newFragment); &#13;
 &#13;
//The replace() method takes two arguments: the id of the view containing the fragment that's being replaced, and an instance of the new fragment// &#13;
 &#13;
transaction.addToBackStack(null); &#13;
 &#13;
//Give the user a way of reversing the transaction by adding the replaced fragment to the back stack. Note that addToBackStack() takes an optional String parameter that identifies this fragment state on the back stack. If you don't need this parameter, you can just pass null, similar to what we're doing in this example// &#13;
 &#13;
transaction.commit(); &#13;
 &#13;
// Commit the transaction// &#13;
</pre><div><div><h3 class="title"><a id="note27"/>Note</h3><p>If you add multiple changes to the transaction and then call <code class="literal">addToBackStack()</code>, all changes applied <em>before</em> you called <code class="literal">commit()</code> are added to the back stack as a single transaction.</p></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>The multi-window support in Android N</h1></div></div></div><p>Beginning with Android N, the Android operating system supports multi-window natively on both tablets and smartphones.</p><p>This new multi-window mode gives users the option to display more than one app at a time in a split-screen environment, either side-by-side or arranged one above the other. The user can resize these split-screen apps by dragging the dividing line that separates them, making one app larger and the other one smaller.</p><p>Giving users the ability to view multiple apps simultaneously is good news for productivity, paving the way for multi-app multitasking, such as bringing up a restaurant's address in Google Chrome and then typing the address directly into Google Maps, or replying to an incoming SMS without having to abandon the video you were watching on YouTube.</p><p>Another major benefit of the multi-window support is that users can drag data from one activity and drop it into another activity directly, whenever these activities are sharing the same screen. Since this direct drag and drop can come in handy for all sorts of everyday tasks, if your app doesn't already support drag and drop, then you should enable it for Android N.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec53"/>How does the multi-window mode work?</h2></div></div></div><p>Android smartphone and tablet users can switch to multi-window mode in the following ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This can happen by opening the Overview screen (also known as the <strong>recent apps screen</strong> or <strong>task list</strong>) and long pressing an activity title. The user can then drag the activity to a highlighted portion of the screen to open that activity in the multi-window mode.</li><li class="listitem" style="list-style-type: disc">This can happen by opening the activity they want to view in the multi-window mode and then pressing the <strong>Overview</strong> button. The device will then put the current activity in multi-window mode and open the Overview screen ready for the user to select another activity to share the screen.</li></ul></div><p>In the multi-window mode, only one activity is active at any given time; that's the activity the user has most recently interacted with, also known as the topmost activity. All other activities are placed in a paused state even though they're still visible to the user. This means that certain activities may need to continue running even when they're paused; for example, video-playing activities should continue playing video content even when they're not the topmost activity.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>If you're developing a video-playing app, the solution is to pause the video in <code class="literal">onStop</code> and resume playback in <code class="literal">onStart</code>, rather than in your app's <code class="literal">onPause</code> handlers.</p></div></div><p>When the user interacts with a paused activity, the activity is resumed and it's the <em>other </em>app's turn to be placed in a paused state.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Getting your app ready for multi-window mode</h2></div></div></div><p>If your app targets Android N or higher and you <em>don't </em>specify whether your app supports multi-window mode, the Android system assumes that your app does include multi-window support.</p><p>However, it's good practice to explicitly state whether your app or activity supports multi-window mode by adding the new <code class="literal">android:resizeableActivity</code> attribute to the <code class="literal">&lt;activity&gt;</code> or <code class="literal">&lt;application&gt;</code> sections of your project's <code class="literal">Manifest</code> file:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:resizeableActivity="true."</code>: This app or activity can be launched in multi-window mode on phones and tablets.</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:resizeableActivity="false."</code>: This app or activity cannot be launched in multi-window mode. If the user attempts to launch this activity in multi-window mode, the app will take over the entire screen instead. If you want to ensure that the system only ever displays your app in full-screen mode, you'll need to use <code class="literal">android:resizeableActivity="false"</code> to <em>explicitly </em>disable multi-window support.</li></ul></div><p>You can also set minimum allowable dimensions so that users cannot shrink your UI further than a specified size; you can do so using the <code class="literal">android:minimalSize</code> attribute. If the user tries to resize the activity so it's smaller than <code class="literal">android:minimalSize</code>, the system crops the activity to the size the user requests instead of shrinking your content.</p><p>Since your app may need to behave differently when it's in multi-window mode, Android N extends the <code class="literal">Activity</code> class so you can query an activity to find out whether it's in multi-window mode:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Activity.inMultiWindow</code>: This is called to find out whether the current activity is in multi-window mode. The <code class="literal">Fragment</code> version of this method is <code class="literal">Fragment.inMultiWindow</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Activity.onMultiWindowChanged</code>: This is called whenever the activity switches into or out of multi-window mode. The fragment version of this method is <code class="literal">Fragment.onMultiWindowChanged</code>.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec22"/>Testing your app's multi-window support</h3></div></div></div><p>If your app targets Android N or higher and you <em>haven't</em> explicitly disabled multi-window support, then you'll need to test your app in multi-window mode to ensure you're providing the best possible user experience.</p><p>In particular, you should check the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Your app switches between full-screen and multi-window mode smoothly</em>. Launch your app in a full-screen mode, and then switch to multi-window mode. Check that this action happens quickly, smoothly, and doesn't cause your app to lag.</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Your app resizes properly in multi-window mode</em>. Launch your app in multi-window mode, open another app, and then drag the divider line to test your app across a range of sizes. In particular, check that all UI elements remain visible and reachable, check that touch targets never shrink to the point where they become difficult to interact with, and check that your app's text remains readable. Test how your app handles resizing when it's sharing space with another app in both side-by-side and one-above-the-other configurations. You should also check that performing multiple resizing operations in quick succession doesn't result in lag or cause your app to crash.</li><li class="listitem" style="list-style-type: disc"><em>The system respects your app's minimum dimensions</em>. If you have specified a minimum dimension, check that the system will prevent users from shrinking your app beyond this <code class="literal">android:minimalSize</code> value, by dragging the divider line.</li><li class="listitem" style="list-style-type: disc"><em>Your app behaves as expected when it's visible but not active</em>. For example, if you've developed a video-playing app, you should verify that your app continues to play video as expected when it's not the topmost activity.</li></ul></div><p>If you explicitly disable multi-window support (by including <code class="literal">android:resizableActivity="false"</code> in <code class="literal">Manifest</code>), then you should also install your app on an Android N device and verify that it's not possible to view your app in multi-window mode.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Picture-by-picture mode</h2></div></div></div><p>Android N doesn't restrict the multitasking fun to smartphones and tablets! Android 7.0 also introduces a multitasking feature especially for Android TV users.</p><p>This new <strong>picture-in-picture</strong> (<strong>PIP</strong>) mode gives Android TV users the ability to watch a pinned window in a corner of the screen, while another activity runs in the background. The user can then toggle between the PIP window and the full-screen mode. If the user tries to play another video on the main screen, the PIP window will automatically close.</p><p>To use this feature in your Android TV apps, you need to register your app's video activity by adding <code class="literal">android:resizeableActivity="true"</code> and <code class="literal">android:supportsPictureInPictur="true"</code> to <code class="literal">Manifest</code>. You can then decide what events trigger the PIP mode in your app by calling <code class="literal">getActivity().enterPictureInPicture</code>.</p><p>When your activity switches to PIP, the system considers the activity to be in a paused state and calls your activity's <code class="literal">onPause</code> method. However, the whole point of PIP is that your app continues to play video in the corner of the screen. Therefore, it's crucial that your app checks whether an activity is paused because it's in the PIP mode. If it is, your app will continue to play its video content:</p><pre class="programlisting">@Override &#13;
public void onPause() { &#13;
 &#13;
   // If onPause is called due to PIP, do not pause playback//  &#13;
    &#13;
if (inPictureInPicture()) { &#13;
       // Continue playback// &#13;
 &#13;
       ... &#13;
   } &#13;
 &#13;
   // If the activity isn't paused due to PIP mode, then pause playback if necessary//   &#13;
 &#13;
   ... &#13;
} &#13;
</pre><p>Bear in mind that in PIP mode, your video content is displayed in a small overlay window. This means users won't be able to clearly see small details or interact with any UI elements. So, if your video activity features either of these, you should remove them when your activity enters PIP. You can then restore these UI elements when your activity switches back to the full-screen mode.</p><p>For example, look at this:</p><pre class="programlisting">@Override &#13;
public void onPictureInPictureChanged(boolean inPictureInPicture) { &#13;
   if (inPictureInPicture) { &#13;
 &#13;
       //This is where you'd hide the controls in PIP mode//  &#13;
 &#13;
       ... &#13;
   } else { &#13;
 &#13;
       //This is where you'd restore any controls that are hidden when the activity enters PIP mode// &#13;
 &#13;
       ... &#13;
   } &#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we saw how to take a basic UI to the next level using arrays, dimensions, 9-patch images, and color state lists. We also looked at how to create a more flexible user interface by incorporating fragments and multi-window mode into your design.</p><p>Now that we've spent a few chapters looking at the mechanics of how to build an effective UI, it's time to switch things up a bit and look at the <em>theory</em> behind creating a great Android user interface.</p><p>There's no shortage of best practices and guidelines that have come and gone with the different versions of the Android platform, but in version 5.0, the Android team announced a completely new direction for the Android UI.</p><p>It's called Material Design, and it's the subject of our next chapter.</p></div></body></html>