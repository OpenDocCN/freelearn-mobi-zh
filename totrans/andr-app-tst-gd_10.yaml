- en: Chapter 10. Alternative Testing Tactics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。替代测试策略
- en: Up to this point we have analyzed the most common and accessible tactics to
    implement testing in our projects. However, there are a few missing pieces in
    our puzzle and with the current versions of the Android SDK (*Android 2.3 Gingerbread*
    as of this writing) these features are not yet implemented. Nevertheless, not
    everything is lost. One of the biggest and strongest benefits of Android is its
    Open Source nature and the features we are going to exploit here precisely depend
    on it because we will be using the complete source code to introduce some changes
    required by what we plan to provide.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分析了在项目中实现测试的最常见和最易访问的策略。然而，在我们的拼图中还有一些缺失的部分，并且随着当前版本的 Android SDK（截至本文撰写时为
    *Android 2.3 姜饼*），这些功能尚未实现。尽管如此，并非一切皆无。Android 最大的和最强大的优势之一是其开源性质，而我们将要利用的功能正是依赖于它，因为我们将会使用完整的源代码来引入一些我们计划提供的更改所需的变化。
- en: Building Android from source code is not for the faint hearted. It is extremely
    time consuming mainly at the beginning while you are familiarizing yourself with
    the whole Android environment, and it also requires a lot of disk space and horsepower.
    To illustrate this assertion, one simple build for one target takes almost 10GB
    of disk space and almost an hour to build on a 4 core machine. I'm not trying
    to scare you but warn you and at the same time ask for a little endurance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建 Android 并非易事。这需要极多的时间，尤其是在你熟悉整个 Android 环境的初期，同时还需要大量的磁盘空间和计算能力。为了说明这一点，对单个目标的简单构建就需要近
    10GB 的磁盘空间，并在 4 核机器上花费近一个小时来构建。我并不是想吓唬你，而是警告你，同时请求你有一点耐心。
- en: They say that great sacrifices come with great rewards and this seems to be
    another case that follows this rule.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说，巨大的牺牲伴随着巨大的回报，这似乎又是一个遵循这一规则的案例。
- en: 'In this chapter we will be covering:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Building Android from source
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码构建 Android
- en: Code coverage using EMMA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EMMA 进行代码覆盖率
- en: Adding code coverage to our Temperature Converter project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码覆盖率添加到我们的温度转换器项目中
- en: Introducing Robotium
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Robotium
- en: Testing on host's JVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在宿主机的 JVM 上进行测试
- en: Introducing Robolectric
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Robolectric
- en: Building Android from source
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码构建 Android
- en: Perhaps Android's *Achilles' heel* would be the lack of documentation and the
    number of places you have to visit to get the complete version of what you are
    trying to find, or what's even worse in many cases the official documentation
    is incorrect or has not been updated to match the current release. One example
    of this is the documentation (available at [http://source.android.com/source/download.html](http://source.android.com/source/download.html)
    at the time of this writing) of the requirements to build Android from source
    that still states that Java 6 is not supported and Ubuntu 8.10 (intrepid) 32bit
    can be used, which is totally wrong. Funnily enough, Java 6 and at least Ubuntu
    10.04 (lucid) 64bit are required. Starting with Android 2.3 (Gingerbread), building
    on 32bit machines is no longer supported. But that's enough for a rant, I will
    leave them for my personal blog, otherwise if the documentation were complete,
    books like this one would not be needed and I could be writing one about Windows
    Phone 7...
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 也许 Android 的**致命弱点**就是缺乏文档，以及你需要访问的多个地方才能找到你试图寻找的完整版本，或者更糟糕的是，在许多情况下，官方文档是错误的，或者没有更新以匹配当前版本。一个例子是，在撰写本文时，关于从源代码构建
    Android 的要求文档（可在[http://source.android.com/source/download.html](http://source.android.com/source/download.html)找到）仍然声称
    Java 6 不受支持，可以使用 Ubuntu 8.10（intrepid）32位，这是完全错误的。有趣的是，Java 6 和至少 Ubuntu 10.04（lucid）64位是必需的。从
    Android 2.3（姜饼）开始，在 32 位机器上构建不再受支持。但这就足够了，我要把这些牢骚留到我的个人博客上，否则如果文档是完整的，像这样的书就不需要了，我可能正在写一本关于
    Windows Phone 7 的书...
- en: Just kidding, I don't think this could happen in the near future.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，我不认为这会在近期发生。
- en: Code coverage
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: One of our objectives in building Android from source is enabling code coverage
    via EMMA ([http://emma.sourceforge.net/](http://emma.sourceforge.net/)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从源代码构建 Android 的一个目标是在 EMMA 的帮助下实现代码覆盖率（[http://emma.sourceforge.net/](http://emma.sourceforge.net/)）。
- en: Code coverage is a measure used in software testing that describes the amount
    of source code that was actually tested by the tests suite and to what degree
    following some criteria. As code coverage inspects the code directly it is therefore
    a form of white box testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是软件测试中用来描述测试套件实际测试的源代码量以及达到某些标准的程度的度量。由于代码覆盖率直接检查代码，因此它是一种白盒测试。
- en: From the several tools available providing code coverage analysis for Java we
    are using EMMA, an open-source toolkit for measuring and reporting Java code coverage
    that is supported by the Android project, and the infrastructure to start using
    it for your own projects is already there, therefore minimizing the effort needed
    to implement it. EMMA came to fill an existing gap in the vast Open Source ecosystem
    where no coverage tools existed with compatible licenses. EMMA is based on IBM's
    Common Public License v1.0 and is thus free for both Open Source and commercial
    development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 Java 提供代码覆盖率分析的几个工具中，我们使用 EMMA，这是一个由 Android 项目支持的、用于测量和报告 Java 代码覆盖率的开源工具包，并且已经存在用于启动您自己的项目的基础设施，因此最小化了实现它的努力。EMMA
    出现填补了庞大的开源生态系统中的一个空白，在该空白中不存在具有兼容许可证的覆盖率工具。EMMA 基于 IBM 的 Common Public License
    v1.0，因此对开源和商业开发都是免费的。
- en: 'EMMA distinguishes itself from other tools by going after a unique feature
    combination: support for large-scale enterprise software development while keeping
    individual developer''s work fast and iterative. This is fundamental in a project
    the size of Android and EMMA shines at its best providing code coverage for it.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: EMMA 通过追求独特的功能组合来区别于其他工具：支持大规模企业级软件开发，同时保持单个开发者的工作快速和迭代。这对于 Android 这样规模的项目至关重要，而
    EMMA 在提供代码覆盖率方面表现出色。
- en: EMMA features
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EMMA 功能
- en: 'Android 2.3 includes EMMA v2.0, build 5312\. The most distinctive set of features,
    paraphrasing its documentation, which can be found at its website are the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android 2.3 包含 EMMA v2.0，版本 5312。其最独特的功能集合，根据其文档的描述，可以在其网站上找到，如下：
- en: EMMA can instrument classes for coverage either offline (before they are loaded)
    or on the fly (using an instrumenting application classloader).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMMA 可以在离线（在它们被加载之前）或实时（使用一个分析应用程序类加载器）对类进行代码覆盖率分析。
- en: 'Supported coverage types: Class, method, line, basic block. EMMA can detect
    when a single source code line is covered only partially.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的覆盖率类型：类、方法、行、基本块。EMMA 可以检测到单行源代码只部分被覆盖的情况。
- en: Coverage stats are aggregated at method, class, package, and "all classes" levels.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖率统计数据在方法、类、包和“所有类”级别进行汇总。
- en: 'Output report types: Plain text, HTML, XML. All report types support drill-down,
    to a user-controlled detail depth. The HTML report supports source code linking.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出报告类型：纯文本、HTML、XML。所有报告类型都支持钻取，达到用户控制的详细程度。HTML 报告支持源代码链接。
- en: Output reports can highlight items with coverage levels below user-provided
    thresholds.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出报告可以突出显示低于用户提供的阈值覆盖率的项。
- en: Coverage data obtained in different instrumentation or test runs can be merged
    together.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的代码覆盖率分析或测试运行中获得的数据可以合并在一起。
- en: EMMA does not require access to the source code and degrades gracefully with
    decreasing amounts of debug information available in the input classes.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMMA 不需要访问源代码，并且当输入类中可用的调试信息减少时，它能够优雅地降级。
- en: EMMA can instrument individual `.class` files or entire `.jar files` (in place,
    if desired). Efficient coverage subset filtering is possible, too.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMMA 可以对单个 `.class` 文件或整个 `.jar` 文件（如果需要，就地）进行代码覆盖率分析。也支持高效的覆盖率子集过滤。
- en: Makefile and ANT build integration are supported on an equal footing.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Makefile 和 ANT 构建集成得到同等支持。
- en: 'EMMA is quite fast: The runtime overhead of added instrumentation is small
    (5 to 20%) and the bytecode instrumentor itself is very fast (mostly limited by
    file I/O speed). Memory overhead is a few hundred bytes per Java class.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMMA 非常快：添加的代码覆盖率分析器的运行时开销很小（5 到 20%），而字节码分析器本身也非常快（主要受限于文件 I/O 速度）。内存开销是每个
    Java 类几百字节。
- en: EMMA is 100% pure Java, has no external library dependencies, and works in any
    Java 2 JVM (even 1.2.x).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EMMA 是 100% 纯 Java，没有外部库依赖，并且可以在任何 Java 2 JVM（甚至 1.2.x）上运行。
- en: 'Some minor changes were introduced by Android to the EMMA project to fully
    adapt it and support code coverage:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Android 对 EMMA 项目进行了一些小的修改，以使其完全适应并支持代码覆盖率：
- en: Change `coverage.out.file` location in `core/res/emma_default.properties` to
    `/data/coverage.ec`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `core/res/emma_default.properties` 中的 `coverage.out.file` 位置更改为 `/data/coverage.ec`
- en: Remove reference to `sun.misc.*` in `core/java14/com/vladium/util/IJREVersion.java`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `core/java14/com/vladium/util/IJREVersion.java` 中移除对 `sun.misc.*` 的引用
- en: Remove reference to `sun.misc.*` and `SunJREExitHookManager` class from `core/java13/com/vladium/util/exit/ExitHookManager.java`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `core/java13/com/vladium/util/exit/ExitHookManager.java` 中移除对 `sun.misc.*`
    和 `SunJREExitHookManager` 类的引用
- en: Add `java.security.cert.Certificate` cast to `core/java12/com/vladium/emma/rt/InstrClassLoader.java`
    to fix compiler error
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `java.security.cert.Certificate` 强制转换为 `core/java12/com/vladium/emma/rt/InstrClassLoader.java`
    中的 `cast` 以修复编译器错误
- en: Move `out/core/res/com/vladium/emma/rt/RTExitHook.closure` (from Emma Ant build)
    into `pregenerated/` so it does not have to be generated in Android's make-based
    build, but also doesn't break Emma's build
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `out/core/res/com/vladium/emma/rt/RTExitHook.closure`（来自 Emma Ant 构建）移动到 `pregenerated/`
    目录中，这样它就不需要在 Android 的基于 make 的构建中生成，但也不会破坏 Emma 的构建
- en: System requirements
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统要求
- en: 'The Android build for gingerbread requires a 64-bit build environment as well
    as some other tools:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Gingerbread 版本的 Android 构建需要一个 64 位构建环境以及一些其他工具：
- en: 'Required packages:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的软件包：
- en: Git, JDK, flex, and the other development packages
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git、JDK、flex 以及其他开发包
- en: Java 6
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 6
- en: Pieces from the 32-bit cross-building environment
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32 位交叉构建环境中的片段
- en: X11 development
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X11 开发
- en: 'The instructions if you are running the recommended Ubuntu 10.04 LTS 64bit
    are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行推荐的 Ubuntu 10.04 LTS 64 位系统，以下是指令：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Set the system to use the right version of java by default:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设置系统默认使用正确的 java 版本：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In any case, check the AOSP website ([http://source.android.com/source/download.html](http://source.android.com/source/download.html))
    for updated instructions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，请访问 AOSP 网站 ([http://source.android.com/source/download.html](http://source.android.com/source/download.html))
    以获取更新的说明。
- en: Downloading the Android source code
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载 Android 源代码
- en: The Android project is a large collection of relatively independent projects
    put under the Android umbrella. All of them use Git as the version control system.
    You can see what I mean by visiting the **Gitweb** interface for the Android project
    at [http://android.git.kernel.org/](http://android.git.kernel.org/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Android 项目是一组相对独立的项目的集合，它们被置于 Android 的伞下。所有这些项目都使用 Git 作为版本控制系统。您可以通过访问 Android
    项目的 **Gitweb** 界面来了解这一点，网址为 [http://android.git.kernel.org/](http://android.git.kernel.org/)。
- en: As you can see, dozens of projects are listed and you need all to build the
    entire platform. To simplify the process of dealing with this great number of
    Git projects at the same time Google created **repo**, a tool that was built on
    top of Git to help manage the many Git repositories, uploads to the revision control
    system, and automate parts of the Android development work-flow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，列出了数十个项目，您需要所有这些来构建整个平台。为了简化同时处理大量 Git 项目的流程，Google 创建了 **repo**，这是一个基于
    Git 构建的工具，旨在帮助管理多个 Git 仓库，上传到版本控制系统，并自动化 Android 开发工作流程的一部分。
- en: '`Repo` is a complementary tool that does not replace Git, but just makes it
    easier to work with Git in the context of Android. The `repo` command is an Python
    executable wrapped into a shell script and can be put anywhere in your path.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repo` 是一个补充工具，它并不取代 Git，但使得在 Android 的背景下使用 Git 更加容易。`repo` 命令是一个 Python 可执行文件，被封装在一个
    shell 脚本中，并且可以被放置在您的路径中的任何位置。'
- en: Detailed information about Git and Repo in the scope of Android project can
    be obtained from their information page at [http://source.android.com/source/git-repo.html](http://source.android.com/source/git-repo.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 项目的范围内，有关 Git 和 Repo 的详细信息可以从它们的信息页面 [http://source.android.com/source/git-repo.html](http://source.android.com/source/git-repo.html)
    获取。
- en: Installing repo
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 repo
- en: As we mentioned before, `repo` is our key to the Android source code world,
    therefore the first measure is installing it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`repo` 是我们进入 Android 源代码世界的钥匙，因此第一步是安装它。
- en: 'Follow these commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下命令操作：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates the initial repo script, which will initialize the complete repository
    and will include the `repo.git` project as well, so `repo` is auto-maintained.
    Every time you synchronize with the repository, changes to `repo` itself are propagated
    if necessary. That's a very clever use of the tool.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建初始的 repo 脚本，它将初始化完整的仓库，并将包括 `repo.git` 项目，因此 `repo` 将自动维护。每次您与仓库同步时，如果需要，`repo`
    自身的更改将被传播。这是一个非常聪明的工具使用方式。
- en: Creating the working copy
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建工作副本
- en: Our working copy of the repository can be created anywhere in our computer.
    Just remember that there should be at least 10GB of free space and sometimes much
    more is needed if you build for different targets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在计算机的任何位置创建仓库的工作副本。只需记住，至少需要 10GB 的可用空间，如果您为不同的目标构建，有时可能需要更多空间。
- en: 'Let''s say that we decide to create the working copy in `~/android/android-2.3`,
    then use the following commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定在 `~/android/android-2.3` 中创建工作副本，然后使用以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These three simple steps have created our working copy ready to be synchronized.
    Remember that is a very big download and depending on your network connection
    speed and the load on the servers it could take some time. So it is very smart
    to wait some days after a major release is pushed to the servers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个简单的步骤已经创建了我们准备同步的工作副本。请记住，这是一个非常大的下载，根据您的网络连接速度和服务器负载，可能需要一些时间。因此，在主要版本推送到服务器后等待几天是非常明智的。
- en: 'When you are ready to synchronize just invoke this command in your working
    copy:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好同步时，只需在您的工作副本中调用此命令：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run `repo sync`, this is what happens:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `repo sync` 时，会发生以下情况：
- en: If the project has never been synchronized, then `repo sync` is equivalent to
    `git clone`. All branches in the remote repository are copied to the local project
    directory.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果项目从未同步过，则 `repo sync` 等同于 `git clone`。远程仓库中的所有分支都将复制到本地项目目录。
- en: 'If the project has already been synchronized once, then `repo sync` is equivalent
    to:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果项目已经同步过一次，则 `repo sync` 等同于：
- en: '`git remote update`'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git remote update`'
- en: '`git rebase origin/branch`'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git rebase origin/branch`'
- en: Where branch is the currently checked-out branch in the local project directory.
    If the local branch is not tracking a branch in the remote repository, then no
    synchronization will occur for the project.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中分支是本地项目目录中当前签出的分支。如果本地分支没有跟踪远程仓库中的分支，则项目不会发生同步。
- en: If the `git rebase` operation results in merge conflicts, you will need to use
    the normal Git commands (for example, `git rebase --continue)` to resolve the
    conflicts.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `git rebase` 操作导致合并冲突，您需要使用正常的 Git 命令（例如，`git rebase --continue`）来解决冲突。
- en: Once finished, the complete Android source code has been downloaded to your
    working copy. We haven't specified any specific branch so we just downloaded the
    latest Android Open Source Project (AOSP) main branch.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，完整的 Android 源代码已下载到您的工作副本。我们没有指定任何特定的分支，所以我们只下载了最新的 Android 开源项目 (AOSP)
    主分支。
- en: The Building Steps
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建步骤
- en: We are ready to start our build supporting code coverage analysis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始支持代码覆盖率分析的建设。
- en: 'To achieve this we need to follow the steps to set the environment and chose
    your combo:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要遵循设置环境和选择您的组合的步骤：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**including device/htc/passion/vendorsetup.sh**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**包括 device/htc/passion/vendorsetup.sh**'
- en: '**including device/samsung/crespo/vendorsetup.sh**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**包括 device/samsung/crespo/vendorsetup.sh**'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**You''re building on Linux**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**您正在 Linux 上构建**'
- en: '**Lunch menu... pick a combo:**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**午餐菜单...选择一个组合：**'
- en: '**1\. full-eng**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. full-eng**'
- en: '**2\. full_x86-eng**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. full_x86-eng**'
- en: '**3\. simulator**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**3. 模拟器**'
- en: '**4\. full_passion-userdebug**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**4. full_passion-userdebug**'
- en: '**5\. full_crespo-userdebug**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**5. full_crespo-userdebug**'
- en: '**Which would you like? [full-eng]**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**您想选择哪个？ [full-eng]**'
- en: Select **full-eng** in this case.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下选择 **full-eng**。
- en: '**============================================**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**============================================**'
- en: '**PLATFORM_VERSION_CODENAME=AOSP**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**PLATFORM_VERSION_CODENAME=AOSP**'
- en: '**PLATFORM_VERSION=AOSP**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**PLATFORM_VERSION=AOSP**'
- en: '**TARGET_PRODUCT=full**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**TARGET_PRODUCT=full**'
- en: '**TARGET_BUILD_VARIANT=eng**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**TARGET_BUILD_VARIANT=eng**'
- en: '**TARGET_SIMULATOR=false**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**TARGET_SIMULATOR=false**'
- en: '**TARGET_BUILD_TYPE=release**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**TARGET_BUILD_TYPE=release**'
- en: '**TARGET_BUILD_APPS=**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**TARGET_BUILD_APPS=**'
- en: '**TARGET_ARCH=arm**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**TARGET_ARCH=arm**'
- en: '**TARGET_ARCH_VARIANT=armv5te**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**TARGET_ARCH_VARIANT=armv5te**'
- en: '**HOST_ARCH=x86**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**HOST_ARCH=x86**'
- en: '**HOST_OS=linux**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**HOST_OS=linux**'
- en: '**HOST_BUILD_TYPE=release**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**HOST_BUILD_TYPE=release**'
- en: '**BUILD_ID=OPENMASTER**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**BUILD_ID=OPENMASTER**'
- en: '**============================================**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**============================================**'
- en: 'One more step is needed in this case. As we want to enable EMMA code coverage
    we need to set this in the environment:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下还需要进行一个步骤。因为我们想启用 EMMA 代码覆盖率，所以需要在环境中设置此选项：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Get set, ready, go:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好，出发：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `-j` or `-jobs` option to make lets you specify the number of jobs (commands)
    to run simultaneously. This is very useful to speed up lengthy build processes
    in multiprocessor or multicore machines. If no argument is given to the `-j` option,
    then `make` will not limit the number of jobs that can run simultaneously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 的 `-j` 或 `-jobs` 选项允许您指定同时运行的作业（命令）数量。这在多处理器或多核机器中加快长时间构建过程非常有用。如果没有给
    `-j` 选项提供参数，则 `make` 不会限制可以同时运行的作业数量。'
- en: 'After a while and tons of messages, your build will be available. If everything
    went well you will be seeing a message similar to this one at the end:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间和大量消息后，你的构建将可用。如果一切顺利，你将在结束时看到类似以下的消息：
- en: '**Target system fs image: out/target/product/generic/obj/PACKAGING/systemimage_intermediates/system.img**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标系统文件系统镜像：out/target/product/generic/obj/PACKAGING/systemimage_intermediates/system.img**'
- en: '**Install system fs image: out/target/product/generic/system.img**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装系统文件系统镜像：out/target/product/generic/system.img**'
- en: '**Installed file list: out/target/product/generic/installed-files.txt**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**已安装文件列表：out/target/product/generic/installed-files.txt**'
- en: This is because the last steps are to create the system image and the list of
    installed files.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为最后一步是创建系统镜像和已安装文件列表。
- en: If the build fails then try some of the suggestions mentioned below in order
    to fix it or find out more at the AOSP site ([http://source.android.com/source/building.html](http://source.android.com/source/building.html)).
    If there are some problems and things are not so smooth, here is a list of tips
    you can follow to revert the situation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建失败，请尝试以下建议中的某些方法来修复它，或者更多地在AOSP网站上了解信息([http://source.android.com/source/building.html](http://source.android.com/source/building.html))。如果有一些问题，事情并不那么顺利，这里有一份你可以遵循的提示列表来恢复情况。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Tips to revert from a broken build**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**从损坏的构建中恢复的提示**'
- en: Clean, using `make clean`, and make again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 清理，使用`make clean`，然后再次构建。
- en: Reducing the number of jobs (make `-j` or `make jobs)` usually helps too.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 减少作业数量（使用`make -j`或`make jobs`）通常也很有帮助。
- en: Sometimes, just invoking make again after a failed build, can make the build
    succeed. Yes, I know it sounds like nonsense, but it helps when you have tried
    everything else.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，仅仅在构建失败后再次调用make，就可以使构建成功。是的，我知道这听起来很荒谬，但当你尝试了所有其他方法时，它是有帮助的。
- en: We now have an instrumented build that will let us obtain code coverage analysis
    for tests in our projects. So this is our next step.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个经过测试的构建，这将使我们能够为我们项目的测试获得代码覆盖率分析。所以这是我们的下一步。
- en: TemperatureConverter code coverage
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 温度转换器代码覆盖率
- en: 'We built Android from source to be able to obtain code coverage analysis reports
    for our projects mainly for two reasons:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从源代码构建Android，主要是为了能够为我们项目的代码覆盖率分析报告。主要有两个原因：
- en: We need an EMMA instrumented build, which is what we did in previous sections
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个EMMA测试的构建，这正是我们在前面的章节中做的。
- en: To be able to instrument an application, this application should be built as
    part of the main build tree, and this is what we will be doing now;
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要能够对应用程序进行测试，这个应用程序应该作为主构建树的一部分进行构建，这正是我们现在要做的；
- en: A possible location for our application and tests inside the main Android tree
    could be `development/samples`, so we are going to use it. Should you decide on
    a different location, minor adaption might be needed in the files and commands
    presented here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序和测试在主Android树中的可能位置是`development/samples`，因此我们将使用它。如果你决定使用不同的位置，这里提供的文件和命令可能需要进行一些小的调整。
- en: 'We already have our TemperatureConverter project and its tests `TemperatureConverterTests`
    somewhere in our filesystem, and if you followed the examples presented before
    they are probably checked into the version control system of your choice, so the
    options here are checking out the project again at this location or creating a
    symbolic link. Let''s choose the latter for the sake of simplicity for this example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的文件系统中某个地方有了我们的`TemperatureConverter`项目和它的测试`TemperatureConverterTests`，如果你之前遵循了示例，它们可能已经被检查到你所选择的版本控制系统，所以这里的选项是在这个位置再次检出项目或者创建一个符号链接。让我们选择后者，为了简化这个示例：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Following, we need to add the makefiles. We built our projects from Eclipse
    and later on we added `ant` support. Now we are adding support for a third build
    system: `make`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加makefiles。我们最初从Eclipse构建我们的项目，后来添加了`ant`支持。现在我们正在添加对第三个构建系统`make`的支持。
- en: Android built is `make` based and we should follow its conventions and style
    to be able to build our application and its tests as part of the main build.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的Android是基于`make`的，我们应该遵循其约定和风格，以便能够将我们的应用程序及其测试作为主构建的一部分进行构建。
- en: 'Create the following `Android.mk` inside the `TemperatureConverter` project:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TemperatureConverter`项目内部创建以下`Android.mk`：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This makefile will be included as part of the main build if executed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行，此makefile将作为主构建的一部分包含。
- en: 'To build it separately we can use a helper function that was defined in our
    environment when we set it up at the beginning using `envsetup.sh`. This function
    is `mm` and is defined as:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独构建它，我们可以使用在设置环境时定义的辅助函数。这个函数是`mm`，定义为：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The boilerplate code to locate and include needed components is provided by
    this function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定位和包含所需组件的样板代码由这个函数提供。
- en: Using it to build the application is simply done by invoking it when our current
    working directory is the project we want to compile.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建应用程序，只需在当前工作目录是我们想要编译的项目时调用它即可。
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because we enabled EMMA by setting `EMMA_INSTRUMENT=true` in our environment
    among the messages produced by this command, we should see the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在环境中通过设置`EMMA_INSTRUMENT=true`启用了EMMA，因此我们应该看到以下信息：
- en: '**EMMA: processing instrumentation path ..**.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：处理仪器化路径 ..**.'
- en: '**EMMA: instrumentation path processed in 149 ms**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：处理仪器化路径耗时149毫秒**'
- en: '**EMMA: [14 class(es) instrumented, 4 resource(s) copied]**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：[仪器化14个类，复制4个资源]**'
- en: '**EMMA: metadata merged into [/home/diego/android/android-2.3/out/target/common/obj/APPS/TemperatureConverter_intermediates/coverage.em]
    {in 16 ms}**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：元数据已合并到[/home/diego/android/android-2.3/out/target/common/obj/APPS/TemperatureConverter_intermediates/coverage.em]
    {耗时16毫秒}**'
- en: This indicates that our build is being instrumented.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的构建正在被仪器化。
- en: We should proceed in a similar manner to build and instrument our tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该以类似的方式继续构建和仪器化我们的测试。
- en: 'In the `TemperatureConverterTest` project create its corresponding makefile:
    `Android.mk`, this time containing this information, which is slightly different
    from the main project:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TemperatureConverterTest`项目中创建相应的makefile：`Android.mk`，这次包含以下信息，与主项目略有不同：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a little more involved because the tests are using external libraries
    we need to define to be used during the build process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这稍微复杂一些，因为测试正在使用我们需要在构建过程中定义的外部库。
- en: 'Again, we should build it using the `mm` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们应该使用`mm`函数来构建它：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have successfully built the `TemperatureConverter` application and its tests,
    now as part of the main Android build. At this point we are ready to obtain the
    code coverage analysis reports, just by following a few more steps.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功构建了`TemperatureConverter`应用程序及其测试，现在它已成为Android主构建的一部分。此时，我们准备通过执行几个更多步骤来获取代码覆盖率分析报告。
- en: Generating code coverage analysis report
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成代码覆盖率分析报告
- en: Having reached this point, we have `TemperatureConverter` and its tests instrumented
    and compiled residing in our output directory which is `out/target/common/obj/APPS/`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这一点后，我们已经在输出目录`out/target/common/obj/APPS/`中构建并仪器化了`TemperatureConverter`及其测试。
- en: We need an instance of the emulator that belongs to our instrumented built.
    This emulator is in the `out` directory too.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个属于我们的仪器构建的模拟器实例。这个模拟器也在`out`目录中。
- en: In this case we extend the default system partition size up to 256MB and include
    a sdcard image that should have been created previously. These elements are needed
    because some data will be collected during the instrumented test run and we need
    some room to save it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将默认系统分区大小扩展到256MB，并包括一个之前应该创建的sdcard镜像。这些元素是必需的，因为在仪器化测试运行期间将收集一些数据，我们需要一些空间来保存它。
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our intention is now to synchronize the image running on the emulator with our
    changes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的目的是将模拟器上运行的镜像与我们的更改同步。
- en: These steps avoid creating a new image when some changes or updates are available
    just by copying the modified files.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤通过复制修改后的文件来避免在有更改或更新可用时创建新的镜像。
- en: 'To be able to do it we first need to enable writing to the system image:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够做到这一点，我们首先需要启用向系统镜像写入：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This command when finished successfully should give this output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当此命令成功完成后，应该给出以下输出：
- en: '**remount succeeded**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载成功**'
- en: 'Followed by the synchronization of changes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是同步更改：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The list of files being copied to the emulator image are displayed. Once everything
    is updated we can now run the tests using `am instrument` as we previously did.
    As we mentioned in [Chapter 2](ch02.html "Chapter 2. Testing on Android"), *Testing
    on Android* when we reviewed the available options for this command, `-e` can
    be used to set various suboptions. In this case we use it to enable code coverage
    collection:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 显示正在复制到模拟器映像的文件列表。一旦所有内容都更新完毕，我们现在可以使用`am instrument`命令运行测试，就像我们之前做的那样。正如我们在[第2章](ch02.html
    "第2章。在Android上进行测试")中提到的，在回顾此命令的可用选项时，`-e`可以用来设置各种子选项。在这种情况下，我们使用它来启用代码覆盖率收集：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This following message verifies that our tests are collecting coverage data:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息验证了我们的测试正在收集覆盖率数据：
- en: '**EMMA: collecting runtime coverage data ..**.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：收集运行时覆盖率数据 ..**。'
- en: 'The last message indeed informs us where this data was collected:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条信息确实告诉我们数据是从哪里收集的：
- en: '**Generated code coverage data to /data/data/com.example.aatg.tc/files/coverage.ec**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成的代码覆盖率数据写入/data/data/com.example.aatg.tc/files/coverage.ec**'
- en: 'We can create a directory in the development computer to keep our coverage
    reports for this project. In this directory we should also copy the off-line coverage
    metadata and then generate the reports:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在开发计算机上创建一个目录来保存本项目的覆盖率报告。在这个目录中，我们还应该复制离线覆盖率元数据，然后生成报告：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we copy the coverage report from the device:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从设备复制覆盖率报告：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When data is transferred we receive these statistics:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输时，我们会收到以下统计信息：
- en: '**200 KB/s (22840 bytes in 0.110s)**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**200 KB/s（0.110秒内22840字节）**'
- en: 'And the off-line coverage metadata:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以及离线覆盖率元数据：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With all these components present in our working directory, it will be easier
    to specify the command line options. If you prefer you can use a different organization
    and leave the files somewhere else and even create symbolic links here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作目录中存在所有这些组件后，指定命令行选项将更容易。如果您愿意，可以使用不同的组织结构，并将文件放在其他地方，甚至在此处创建符号链接。
- en: Having read everything, we can invoke `emma` to generate the report. The default
    report shows the overall coverage summary followed by a breakdown by package.
    In this example we are using HTML output and we are linking to the source.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完所有内容后，我们可以调用`emma`来生成报告。默认报告显示整体覆盖率摘要，然后按包分拆。在这个例子中，我们使用HTML输出，并链接到源代码。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If your source folder for the `TemperatureConverter` main project is other
    than `~/workspace/TemperatureConverter/src` don''t forget to adapt the following
    command, otherwise the command will fail: `~/android/android-2.3/out/emma/tc$
    java -cp ~/android/android-2.3/external/emma/lib/emma.jar emma report -r html
    -in coverage.ec -sp ~/workspace/TemperatureConverter/src -in coverage.em`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`TemperatureConverter`主项目的源文件夹不是`~/workspace/TemperatureConverter/src`，请记住调整以下命令，否则命令将失败：`~/android/android-2.3/out/emma/tc$
    java -cp ~/android/android-2.3/external/emma/lib/emma.jar emma report -r html
    -in coverage.ec -sp ~/workspace/TemperatureConverter/src -in coverage.em`。
- en: 'And we will be able to see the messages indicating the creation of the report:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将能够看到指示报告创建的消息：
- en: '**EMMA: processing input files ..**.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：处理输入文件 ..**。'
- en: '**EMMA: 2 file(s) read and merged in 20 ms**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：2个文件在20毫秒内读取并合并**'
- en: '**EMMA: writing [html] report to [/home/diego/android/android-2.3/out/emma/tc/coverage/index.html]
    ..**.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：将[html]报告写入[/home/diego/android/android-2.3/out/emma/tc/coverage/index.html]
    ..**。'
- en: '**EMMA: writing [html] report to [/home/diego/android/android-2.3/out/emma/tc/coverage/index.html]
    ..**.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMMA：将[html]报告写入[/home/diego/android/android-2.3/out/emma/tc/coverage/index.html]
    ..**。'
- en: 'This has created the report files inside the coverage directory, so we can
    open the index by invoking:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这在覆盖率目录内创建了报告文件，因此我们可以通过调用以下命令来打开索引：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, the coverage analysis report is displayed:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，显示覆盖率分析报告：
- en: '![Generating code coverage analysis report](img/3500_10_01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![生成代码覆盖率分析报告](img/3500_10_01.jpg)'
- en: 'This report has three main sections:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该报告有三个主要部分：
- en: '**Overall coverage summary:** The summary for all classes is presented here.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总体覆盖率摘要：** 这里展示了所有类的摘要。'
- en: '**Overall stats summary:** The statistics of the coverage are presented here,
    for example how many packages, classes, or lines were present.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总体统计摘要：** 这里展示了覆盖率统计信息，例如有多少个包、类或行。'
- en: '**Coverage breakdown by package:** In the case of bigger applications this
    will display the coverage for particular packages. In this example, it''s the
    same as the total because there is a single package.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按包分拆的覆盖率：** 对于较大的应用程序，这将显示特定包的覆盖率。在这个例子中，它与总数相同，因为只有一个包。'
- en: The information presented in the report includes coverage metrics in a way that
    allows for drilling down into data in a top-down fashion, starting with all classes
    and going all the way to the level of individual methods and source lines (in
    the HTML report).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 报告中展示的信息以允许自上而下钻取数据的方式呈现覆盖率指标，从所有类开始，一直钻取到单个方法和源代码行（在HTML报告中）。
- en: The fundamental unit of code coverage in EMMA is the basic blocks; all other
    types of coverage are derived from the basic block coverage in some way. Line
    coverage is mostly used to link to the source code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: EMMA中代码覆盖率的基本单位是基本块；所有其他类型的覆盖率都是以某种方式从基本块覆盖率派生出来的。行覆盖率主要用于链接到源代码。
- en: 'This table describes the important pieces of information in the EMMA coverage
    report:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此表描述了EMMA覆盖率报告中重要信息的关键部分：
- en: '| Label | Description |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| name | The name of the class or package |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 类或包的名称 |'
- en: '| Class, % | The percentage of classes covered over the total and the detailed
    number. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 类，% | 总类覆盖的百分比和详细数字。 |'
- en: '| Method, % | The percentage of methods covered over the total and the detailed
    number. This is a basic java method which is composed by a given number of basic
    blocks. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 方法，% | 总方法覆盖的百分比和详细数字。这是一个基本的Java方法，由给定数量的基本块组成。 |'
- en: '| Block, % | The percentage of blocks covered over the total and the detailed
    number. A basic block is defined as a sequence of bytecode instructions without
    any jumps or jump targets.The number of basic blocks in a method is a good measure
    of its complexity. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 块，% | 总块覆盖的百分比和详细数字。基本块被定义为没有跳转或跳转目标的字节码指令序列。一个方法中的基本块数量是该方法复杂度的一个良好度量。 |'
- en: '| Line, % | The percentage of lines covered over the total and the detailed
    number. This is basically used to link to the source code. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 行，% | 总行覆盖的百分比和详细数字。这基本上用于链接到源代码。 |'
- en: 'When the values presented are under a threshold coverage metric value, these
    metrics are presented in red in the report. By default, these values are:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示的值低于阈值覆盖率指标值时，这些指标在报告中以红色显示。默认情况下，这些值是：
- en: 'For methods: 70%'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于方法：70%
- en: 'For blocks: 80%'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于块：80%
- en: 'For lines: 80%'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于行：80%
- en: 'For classes: 100%'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于类：100%
- en: All of these values can be changed, specifying parameters on the command line
    or in a configuration file. Please refer to the documentation for details ([http://emma.sourceforge.net/docs.html](http://emma.sourceforge.net/docs.html)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些值都可以更改，可以通过命令行或配置文件指定参数。请参阅文档以获取详细信息（[http://emma.sourceforge.net/docs.html](http://emma.sourceforge.net/docs.html)）。
- en: We can drill-down from the package to specific methods and the lines covered
    are presented in green while uncovered ones appear in red and partially covered
    in yellow.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从包中钻取到具体的方法，被覆盖的行以绿色显示，未覆盖的行以红色显示，部分覆盖的行以黄色显示。
- en: 'This is an example of this report for the `TemperatureConverter` class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`TemperatureConverter`类的报告示例：
- en: '![Generating code coverage analysis report](img/3500_10_02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![生成代码覆盖率分析报告](img/3500_10_02.jpg)'
- en: In this report we can see that the class `TemperatureConverter` is not 100%
    covered but all the basic blocks inside it are.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在此报告中，我们可以看到`TemperatureConverter`类没有100%覆盖，但其中的所有基本块都被覆盖了。
- en: Do you know why ?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道为什么吗？
- en: Think for a moment...
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看...
- en: Yes, because the implicit default constructor has not been tested. But wait
    a second; this is a utility class which is not supposed to be instantiated at
    all. We can see here not only how this analysis is helping us to test our code
    and find potential bugs but also to improve the design.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，因为隐式的默认构造函数尚未经过测试。但是等等；这是一个不应该被实例化的工具类。我们可以看到，这种分析不仅帮助我们测试代码和发现潜在的错误，还可以改进设计。
- en: 'What we need to do to prevent `TemperatureConverter` from being instantiated
    is to create a private default constructor:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止`TemperatureConverter`被实例化，我们需要创建一个私有的默认构造函数：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once we add this private constructor and run the tests and coverage again we
    can see now that even though the class is not yet 100% covered and thus not green
    we can assure that this constructor won't be invoked from any other class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了这个私有构造函数并再次运行测试和覆盖率，现在我们可以看到，尽管类还没有100%覆盖，因此不是绿色的，但我们可以确保这个构造函数不会被其他任何类调用。
- en: Covering the restoring the instance state
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖恢复实例状态
- en: There is another case that we will analyze. In the report for `TemperatureConverterActivity`
    we can see that some blocks are still not covered and they are red. One of such
    blocks is the partial support for restoring a saved instance we added before,
    though this block is not yet functional and its only logging a message we should
    cover it with a test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个情况我们将进行分析。在 `TemperatureConverterActivity` 的报告中，我们可以看到一些代码块仍然没有被覆盖，并且它们是红色的。其中之一是我们之前添加的恢复保存实例的部分支持，尽管这个代码块尚未启用，它只是记录了一条消息，我们应该用测试来覆盖它。
- en: 'The code mentioned in `TemperatureConverterActivity.java` is:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TemperatureConverterActivity.java` 中提到的代码是：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To test this block we must control the invocation of the `onCreate()` method
    and inject a mock `Bundle` to simulate the actual Android lifecycle.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此代码块，我们必须控制 `onCreate()` 方法的调用，并注入一个模拟的 `Bundle` 来模拟实际的 Android 生命周期。
- en: We may think of using one of our previously created test classes to add the
    needed test, but if you remember from our previous chapters we stated that when
    we need a higher degree of control over the creation of the `Activity` under test,
    instead of `ActivityInstrumentationTestCase2<T>` we should use `ActivityUnitTestCase<T>`,
    which is also derived from `InstrumentationTestCase` (see the UML class diagram
    for `ActivityInstrumentationTestCase2<T>` in [Chapter 3](ch03.html "Chapter 3. Building
    Blocks on the Android SDK"), *Building Blocks on the Android SDK*)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会考虑使用之前创建的测试类来添加所需的测试，但如果你记得我们之前的章节，我们提到当我们需要对测试的 `Activity` 创建有更高程度的控制时，我们应该使用
    `ActivityUnitTestCase<T>` 而不是 `ActivityInstrumentationTestCase2<T>`，后者也是从 `InstrumentationTestCase`
    派生的（参见 [第 3 章](ch03.html "第 3 章。Android SDK 的构建块") 中 `ActivityInstrumentationTestCase2<T>`
    的 UML 类图，*Android SDK 的构建块*）
- en: The test case based on `ActivityUnitTestCase<T>` allows us to inject the desired
    values to `onCreate()` while starting the Activity by using `startActivity(Intent
    intent, Bundle savedInstanceState, Object lastNonConfigurationInstance)`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `ActivityUnitTestCase<T>` 的测试用例允许我们在通过 `startActivity(Intent intent, Bundle
    savedInstanceState, Object lastNonConfigurationInstance)` 启动 Activity 的同时，向 `onCreate()`
    注入所需的值。
- en: 'The following code snippet shows the test case we are adding to our already
    existing `TemperatureConverterActivityUnitTests` class:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们要添加到现有 `TemperatureConverterActivityUnitTests` 类中的测试用例：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are creating a `Bundle` containing only dummy values as nothing special is
    expected in the Activity. Additionally we are injecting a real `TemperatureConverterApplication`
    object instead of an Application mock because it is used, and casted, inside the
    Activity's `onCreate()` method and it would fail.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个只包含模拟值的 `Bundle`，因为在 Activity 中没有期望到任何特殊的东西。此外，我们注入了一个真实的 `TemperatureConverterApplication`
    对象而不是 Application 模拟对象，因为它在 Activity 的 `onCreate()` 方法中被使用和转换，否则会失败。
- en: No additional tests were added to this class as nothing special is done when
    the saved state is restored. For your particular application probably you would
    like to check that some values were restored correctly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复保存状态时没有进行任何特殊操作，因此没有向此类添加额外的测试。对于您的特定应用程序，您可能希望检查某些值是否已正确恢复。
- en: Should we run the test coverage report again we would see that now the mentioned
    block is now covered.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试覆盖率报告，我们会看到现在提到的代码块已被覆盖。
- en: Covering the exceptions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖异常
- en: Continuing with our examination of the coverage report will lead us to discover
    another block that is not exercised by our current tests. The block in question
    is the last catch in the following try-catch block in `TemeratureConverterActivity:`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 继续检查覆盖率报告将引导我们发现另一个当前测试未涉及的代码块。所讨论的代码块是以下 try-catch 块中的最后一个 catch 在 `TemeratureConverterActivity:`
    中：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We should provide a test, or better a pair of tests, one for each temperature
    unit, that furnishing an invalid temperature verifies that the error is displayed.
    This is the test in `TemperatureConverterActivityTests` for the Celsius case and
    you can easily convert it to provide the other case:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该提供一个测试，或者更好的是一个测试对，每个温度单位一个，以验证无效的温度会显示错误。这是 `TemperatureConverterActivityTests`
    中的 Celsius 情况的测试，你可以轻松地将其转换为提供其他情况：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We clear and request the focus for the field under test. As we did before, we
    should achieve this by using a Runnable on the UI thread otherwise we will receive
    an exception.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清除并请求测试字段的关注。正如我们之前所做的那样，我们应该通过在 UI 线程上使用 Runnable 来实现这一点，否则我们将收到一个异常。
- en: Then we check there's no previous error, set the invalid temperature, and retrieve
    the error message to verify that is not null. Running the end-to-end process again
    we can attest that the block is now covered giving us total coverage as intended.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查没有之前的错误，设置无效的温度，并检索错误消息以验证它不为null。再次运行端到端过程，我们可以证明现在块已被覆盖，从而实现了预期的全面覆盖。
- en: This is the iterative process you should follow to change as much as possible
    of the code to green. Ideally this should be 100% but sometimes this is not achievable
    mainly for some blocks that are not reachable during the tests.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你应该遵循的迭代过程，尽可能多地更改代码以使其变为绿色。理想情况下，这应该是100%，但有时这是不可实现的，主要是因为一些在测试期间无法到达的块。
- en: Bypassing access restrictions
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过访问限制
- en: One of the blocks we added to satisfy our needs, the private constructor for
    `TemperatureConverter`, is now unreachable by our tests and is marked red. In
    cases like this we can leave it as it is or we can use a more convoluted solution
    using reflection to bypass the access restrictions and create a test. Though this
    is not really advisable because strictly speaking you should limit to test the
    public interface, we are including this as an illustration of this technique.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的一个块，为了满足我们的需求，`TemperatureConverter`的私有构造函数现在无法被我们的测试访问，并标记为红色。在这种情况下，我们可以让它保持原样，或者我们可以使用更复杂的解决方案，通过反射绕过访问限制并创建一个测试。尽管这并不是真的建议，因为严格来说，你应该限制测试公共接口，但我们将其包括在内，以说明这种技术。
- en: 'This is the test we are adding to the `TemperatureConverterTests` class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要添加到`TemperatureConverterTests`类中的测试：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example uses reflection to bypass the access restriction and create a new
    `TemperatureConstructor` instance and then verify that it was successfully created.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用反射来绕过访问限制并创建一个新的`TemperatureConstructor`实例，然后验证它是否已成功创建。
- en: If you are not familiar with this technique or Java reflection in general you
    can read the excellent tutorial at The Java Tutorials by Oracle ([http://download.oracle.com/javase/tutorial/reflect/](http://download.oracle.com/javase/tutorial/reflect/)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个技术或Java反射不太熟悉，你可以阅读Oracle的Java教程中的优秀教程（[http://download.oracle.com/javase/tutorial/reflect/](http://download.oracle.com/javase/tutorial/reflect/))。
- en: Covering the options menu
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖选项菜单
- en: Taking another look at the coverage report, we can yet identify a method that's
    not covered by our tests. It is the `TemperatureConverterActivity.onCreateOptionsMenu()`
    which creates the menu holding the Preferences option in our particular situation.
    What it does is very simple and straightforward. It creates a `MenuItem` that
    when clicked invokes the `TemperatureConverterPreferences` Activity through the
    corresponding intent. This is right what we are going to test. From our experience
    we know that if we are interested in knowing if an Activity was launched from
    our Activity under tests, then what we need is an `ActivityMonitor`, so we are
    establishing the test based on this component.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看覆盖率报告，我们还可以识别出一个我们的测试没有覆盖的方法。它是`TemperatureConverterActivity.onCreateOptionsMenu()`，它在我们特定情况下创建了包含“偏好设置”选项的菜单。它的操作非常简单直接。它创建了一个`MenuItem`，当点击时，通过相应的intent调用`TemperatureConverterPreferences`活动。这正是我们要测试的。根据我们的经验，如果我们想知道是否从我们的测试活动启动了活动，那么我们需要的是一个`ActivityMonitor`，因此我们基于这个组件建立测试。
- en: 'This is the new test we will add to the `TemperatureConverterActivityTests`
    class:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要添加到`TemperatureConverterActivityTests`类中的新测试：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Firstly we get the Instrumentation as in other cases. We then add a monitor
    using `addMonitor(),` a convenience wrapper that also creates the `ActivityMonitor`
    for us and returns it, defining the name of the Activity class to monitor, null
    as a result as we are not interested in it, and false not to block the start of
    the Activity. This monitor will be hit if an Activity that matches the class is
    launched.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像其他情况一样获取Instrumentation。然后，我们使用`addMonitor()`添加一个监控器，这是一个便利包装器，它也会为我们创建`ActivityMonitor`并返回它，定义要监控的活动类名称，结果为null，因为我们对此不感兴趣，并且不阻塞活动的启动。如果启动了一个匹配的Activity，这个监控器将被触发。
- en: Next, we invoke the menu option with ID `0`, as it was defined in `onCreateOptionsMenu()`,
    and passing no flags (0 again). We assert that the invocation was successful as
    `invokeMenuActionSync()` returns true in such cases.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用ID为`0`的菜单选项，正如它在`onCreateOptionsMenu()`中定义的那样，并传递没有标志（再次为0）。我们断言调用是成功的，因为在这种情况下`invokeMenuActionSync()`返回true。
- en: We wait for the Activity to start, verify that it was actually started as `waitForActivityWithTimeout()`
    returns null if the timeout expires before the Activity was started, and finally
    `finishing()` the Activity.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待`Activity`启动，验证它实际上已经启动，因为如果`waitForActivityWithTimeout()`在`Activity`启动之前超时，则返回null，最后`finishing()``Activity`。
- en: This is a good example of `ActivityMonitor` utilization. However, the way we
    used to invoke the particular menu item and the limitations we would face if we
    intended to continue testing the new Activity for a real functional test led us
    to believe that there should be another way, and actually there is!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`ActivityMonitor`使用的良好示例。然而，我们过去调用特定菜单项的方式以及如果我们打算继续测试新的`Activity`进行实际功能测试时可能面临的限制，使我们相信应该有另一种方式，实际上确实存在！
- en: We will explore such ways in the following section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨这些方法。
- en: The undocumented Ant coverage target
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未记录的Ant覆盖率目标
- en: 'If building with make doesn’t appeal to you very much there is still another
    alternative. Latest versions of Android tools include an undocumented option that
    adds to the documented targets we mentioned before: help, clean, compile, debug,
    release, install, and uninstall.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用make构建不太吸引你，还有另一种选择。Android工具的最新版本包括一个未记录的选项，它增加了我们之前提到的文档化目标：帮助、清理、编译、调试、发布、安装和卸载。
- en: This target is `coverage` and can be used like in the following example in the
    `TemperatureConverterTest` project.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此目标是`coverage`，可以在以下示例中像在`TemperatureConverterTest`项目中一样使用。
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be able to successfully complete all its subtasks a suitable emulator or
    device should be running.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够成功完成所有子任务，应运行一个合适的模拟器或设备。
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will generate the following output (parts of the output were trimmed in
    order to include it here):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出（为了包含在这里，输出的一部分已被裁剪）：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This automates several of the steps we described before. However it is not documented
    yet so it can be removed or changed in the future. On the other hand, when the
    projects are complex or there are a lot of dependencies this build target may
    fail when the makefile succeeds, so use it with caution.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这自动化了我们之前描述的几个步骤。然而，它尚未被记录，因此将来可能会被删除或更改。另一方面，当项目复杂或有很多依赖项时，如果makefile成功，则此构建目标可能会失败，因此请谨慎使用。
- en: Introducing Robotium
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Robotium
- en: One component of the vast emerging robotic fauna is Robotium ([http://code.google.com/p/robotium/](http://code.google.com/p/robotium/)),
    a test framework created to simplify the writing of tests requiring minimal knowledge
    of the application under test. Robotium is mainly oriented to write powerful and
    robust automatic black-box test cases for Android applications. It can cover function,
    system, and acceptance test scenarios, even spanning multiple Android activities
    of the same application automatically.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛兴起的机器人群体中的一个组成部分是Robotium ([http://code.google.com/p/robotium/](http://code.google.com/p/robotium/))，这是一个测试框架，旨在简化需要最少了解被测试应用程序的测试的编写。Robotium主要面向编写强大且健壮的自动黑盒测试用例，用于Android应用程序。它可以覆盖功能、系统和验收测试场景，甚至可以自动跨越同一应用程序的多个Android活动。
- en: Robotium can also be used to test applications that we don't have the source
    code for, or even pre-installed applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Robotium还可以用于测试我们没有源代码的应用程序，甚至可以用于测试预安装的应用程序。
- en: Robotium has full support for Activities, Dialogs, Toasts, Menus, and Context
    Menus.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Robotium完全支持`Activities`、`Dialogs`、`Toasts`、`Menus`和`Context Menus`。
- en: Let's put Robotium to work creating some new tests for `TemperatureConverter`.
    To keep our tests organized we create a new package named `com.example.aatg.tc.tests.robotium`
    in the `TemperatureConverterTest` project. In this package we are creating the
    class for our test cases, because we will be initially testing `TemperatureConverterActivity`.
    It is reasonable to call it `TemperatureConverterActivityTests` even though we
    have a class with the same name in another package also extending `ActivityInstrumentationTestCase2`.
    After all, this class will be containing tests for this same `Activity` too.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Robotium为`TemperatureConverter`创建一些新的测试。为了使我们的测试井然有序，我们在`TemperatureConverterTest`项目中创建了一个名为`com.example.aatg.tc.tests.robotium`的新包。在这个包中，我们创建测试用例的类，因为我们最初将测试`TemperatureConverterActivity`。即使我们还有一个在另一个包中具有相同名称的类，它也扩展了`ActivityInstrumentationTestCase2`，将其命名为`TemperatureConverterActivityTests`也是合理的。毕竟，这个类也将包含对这个相同`Activity`的测试。
- en: Downloading Robotium
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载Robotium
- en: We need to download the `robotium-solo` JAR file and its Javadoc so we can add
    them to our project. Go to the Robotium download site ([http://code.google.com/p/robotium/downloads/list](http://code.google.com/p/robotium/downloads/list))
    and pick the latest version available, which at the time of this writing is `robotium-solo-2.1.jar`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载 `robotium-solo` JAR 文件及其 Javadoc，以便将它们添加到我们的项目中。请访问 Robotium 下载网站 ([http://code.google.com/p/robotium/downloads/list](http://code.google.com/p/robotium/downloads/list))
    并选择可用的最新版本，在撰写本文时是 `robotium-solo-2.1.jar`。
- en: Configuring the project
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置项目
- en: In the properties of our `TemperatureConverterTest` project we need to add this
    JAR to **Java Build Path | Libraries**. Once added, you can expand this node and
    add the Javadoc location to point to the companion JAR file using the **Javadoc
    in archive** option.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `TemperatureConverterTest` 项目的属性中，我们需要将此 JAR 添加到 **Java Build Path | Libraries**。一旦添加，您可以展开此节点，并使用
    **Javadoc in archive** 选项将 Javadoc 位置指向伴随的 JAR 文件。
- en: Creating the test cases
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试用例
- en: From previous chapter we know that if we are creating test cases for an Activity
    that should run connected to the system infrastructure, we should base it on `ActivityInstrumentationTestCase2`,
    and that is what we are going to do.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一章我们知道，如果我们为应该连接到系统基础设施的 Activity 创建测试用例，我们应该基于 `ActivityInstrumentationTestCase2`，这正是我们要做的。
- en: The testFahrenheitToCelsiusConversion() test
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试FahrenheitToCelsiusConversion() 测试
- en: More or less the test cases have the same structure as other Instrumentation
    based tests. The main difference is that we need to instantiate Robotium's Solo
    in the test `setUp()` and `finalize()` it in the `tearDown():`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 大体上，测试用例的结构与其他基于 Instrumentation 的测试相同。主要区别在于我们需要在测试的 `setUp()` 中实例化 Robotium
    的 `Solo`，并在 `tearDown()` 中最终化它：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To instantiate `Solo` we have to pass a reference to the `Instrumentation` and
    to the `Activity` under test.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化 `Solo`，我们必须传递对 `Instrumentation` 和待测试的 `Activity` 的引用。
- en: On the other hand, to finalize `Solo` we should precisely call the `finalize()`
    method, then finish the `Activity`, and invoke `super.tearDown()`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了最终化 `Solo`，我们应该精确地调用 `finalize()` 方法，然后完成 `Activity`，并调用 `super.tearDown()`。
- en: 'Solo provides a variety of methods to drive UI tests and some assertions. Let''s
    start by re-implementing the `testFahrenheitToCelsiusConversion()` that we previously
    implemented using the conventional approach, but in this case using `Solo` facilities:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Solo 提供了各种方法来驱动 UI 测试和一些断言。让我们从重新实现 `testFahrenheitToCelsiusConversion()` 开始，这是我们之前使用传统方法实现的，但这次使用
    `Solo` 功能：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is pretty similar, however the first difference you may have noticed is
    that in this case we are not getting references to the UI elements as we previously
    did in the `setUp()` method using `findViewById()` to locate the View. However,
    we are using one of the biggest advantages of Solo that is locating the Views
    for us using some criteria. In this case the criteria are used in the order in
    which they appear on the screen and since they are counted an index is assigned.
    The method `mSolo.clearEditText(int index)` expects an integer index of the position
    on the screen starting from `0`. Consequently we should add these constants to
    the test case, as in our UI the Celsius field is on top and Fahrenheit beneath:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常相似，然而你可能注意到的第一个区别是，在这种情况下，我们并没有像在 `setUp()` 方法中使用 `findViewById()` 定位 View
    那样获取 UI 元素的引用。然而，我们正在使用 Solo 的一个最大的优点，即使用某些标准为我们定位 View。在这种情况下，标准按照它们在屏幕上出现的顺序使用，并且由于它们被计数，因此分配了一个索引。方法
    `mSolo.clearEditText(int index)` 期望一个整数索引，该索引从屏幕上的 `0` 开始。因此，我们应该将这些常量添加到测试用例中，因为在我们
    UI 中，摄氏度字段在顶部，华氏度在下面：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The other methods follow the same convention and we are supplying these constants
    when necessary. This test is very similar to the one in `com.example.aatg.tc.test.TemperatureConverterActivityTest`
    but you may have noticed that there is a subtle difference. Here we are located
    at a much higher level and we don't have to worry about internals or implementation
    details; for example when in our previous test we invoked `mCelsius.requestFocus()`
    to trigger the conversion mechanism, but here we just simulate what the user does
    and issue a `mSolo.clickOnEditText(CELSIUS)`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法遵循相同的约定，并在必要时提供这些常量。这个测试与 `com.example.aatg.tc.test.TemperatureConverterActivityTest`
    中的测试非常相似，但你可能已经注意到有一个细微的差别。在这里，我们处于一个更高的层次，不必担心内部或实现细节；例如，在我们之前的测试中，我们调用 `mCelsius.requestFocus()`
    来触发转换机制，但在这里我们只是模拟用户的行为并发出 `mSolo.clickOnEditText(CELSIUS)`。
- en: Because of this, we don't want to cast and use `EditNumber.getNumber()` either.
    We just obtain the textual data that is on the screen, convert it to a `Double`,
    and then compare it against the expected value.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们也不想使用`EditNumber.getNumber()`进行类型转换和使用。我们只是获取屏幕上的文本数据，将其转换为`Double`，然后将其与预期值进行比较。
- en: We simplified the test sensibly but the biggest advantage of using `Solo` is
    yet to come.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们合理地简化了测试，但使用`Solo`的最大优势还在后面。
- en: The testOnCreateOptionsMenu() revisited
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再次审视testOnCreateOptionsMenu()
- en: You may have been waiting for this since the announcement in our preceding `testOnCreateOptionsMenu()`
    implementation. This time we are situated at a much higher level and we don't
    deal with implementation details. It is not our problem if a new Activity is launched
    when we click on the menu item; we only treat this case from the UI perspective.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从我们之前的`testOnCreateOptionsMenu()`实现中宣布这个功能以来一直在等待这个时刻。这次我们处于一个更高的层次，我们不需要处理实现细节。当我们点击菜单项时，如果启动了一个新的活动，这不是我们的问题；我们只从UI的角度处理这种情况。
- en: This is a screenshot showing the preferences dialog for **Decimal places:**
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张显示**小数位数**偏好设置的截图：
- en: '![The testOnCreateOptionsMenu() revisited](img/3500_10_03.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![再次审视testOnCreateOptionsMenu()](img/3500_10_03.jpg)'
- en: Our purpose is also to change the value of **Decimal places** preferences to
    5, and verify that the change actually took place.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是也将**小数位数**偏好值更改为5，并验证更改是否确实发生了。
- en: 'The following code snippet illustrates the details of the test:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了测试的细节：
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Can you already appreciate the difference? There are no gory details about how
    all this is implemented. We only test its functionality.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经能感受到这种差异了吗？这里没有关于如何实现这些功能的血腥细节。我们只测试其功能。
- en: We start by pressing the `MENU` key, clicking on **Preferences**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先按下`菜单`键，点击**偏好设置**。
- en: Wow, we just specify the menu item title and that's it!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们只需指定菜单项标题就足够了！
- en: The new Activity is started but we don't have to worry about it. We continue
    and click on **Decimal places**.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 新的活动已经开始，但我们不必担心它。我们继续并点击**小数位数**。
- en: 'We verify that some field containing a number, the prior value of this preference,
    appeared. Do you remember what I said about regular expressions: they always come
    in handy in one way or another; here to match any decimal integer number (any
    digit followed by zero or more digits). Then we clear the field and verify that
    it was in fact cleared.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证了一个包含数字的字段出现了，这个数字是此偏好的先前值。你还记得我关于正则表达式说过的话吗：它们总是以某种方式派上用场；这里用来匹配任何十进制整数（任何数字后跟零个或多个数字）。然后我们清除字段并验证它确实被清除了。
- en: We enter the string representing the number we want to use as a preference,
    5 in this case. Click on the **OK** button, and the preference is saved.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入代表我们想要用作偏好的数字的字符串，在这个例子中是5。点击**确定**按钮，偏好设置就被保存了。
- en: It remains to verify that it actually happened. The same procedure is used to
    get the menu and the field and finally we verify that the actual number is already
    there.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是验证它确实发生了。使用相同的程序来获取菜单和字段，最后我们验证实际数字已经存在。
- en: 'You may wonder where `DECIMAL_PLACES` comes from. We previously defined `CELSIUS`
    and `FAHRENHEIT` index constants for the fields on the screen and this is the
    same case, because this will be the third `EditText` we should define in our class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道`DECIMAL_PLACES`是从哪里来的。我们之前为屏幕上的字段定义了`CELSIUS`和`FAHRENHEIT`索引常量，这是同样的情况，因为这将是我们类中应该定义的第三个`EditText`：
- en: '[PRE36]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tests can be run from Eclipse or the command line according to your preferences.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的偏好，可以从Eclipse或命令行运行测试。
- en: I hope you have enjoyed this simplicity as much as I did and that your brain
    is now bubbling with ideas to implement your own tests.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你和我的感受一样，喜欢这种简单性，并且你的大脑现在充满了实现你自己的测试的想法。
- en: Testing on host's JVM
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主机JVM上测试
- en: We left this subject for the end of this chapter as it seems this is the *Holy
    Grail* of the Android platform.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把这个主题留到了本章的末尾，因为它似乎是这个Android平台的**圣杯**。
- en: You know that Android is based on a virtual machine named Dalvik, after a village
    in Iceland, optimized for mobile resources with limited capabilities such as constrained
    amount of memory and processor speed. Certainly a very different environment than
    our development host computer, which may have plenty of memory and processor speed
    to enjoy.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道Android是基于名为Dalvik的虚拟机，这个名字来源于冰岛的一个村庄，它针对具有有限能力如内存和处理器速度受限的移动资源进行了优化。这当然与我们的开发主机计算机非常不同的环境，后者可能拥有大量的内存和处理器速度来享受。
- en: Ordinarily, we run our applications and tests on an emulator or device. These
    targets have a much slower real or emulated CPU and thus running our tests is
    a time consuming activity mainly when our project starts to grow, and applying
    Test Driven Development techniques compels us to run hundreds of tests to verify
    every change we introduced.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在模拟器或设备上运行我们的应用程序和测试。这些目标具有较慢的真实或模拟CPU，因此运行我们的测试是一个耗时活动，尤其是在我们的项目开始增长时，并且应用测试驱动开发技术迫使我们运行数百个测试来验证我们引入的每个更改。
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth noticing that this technique can be used only as a workaround during
    the development process to speed things up and it should never replace final testing
    on the real platform as incompatibilities between the Dalvik and JavaSE runtime
    may affect the accuracy of the tests.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种技术只能在开发过程中作为权宜之计来加快速度，它永远不应该取代在真实平台上的最终测试，因为Dalvik和JavaSE运行时之间的不兼容性可能会影响测试的准确性。
- en: Later, we should find out a method that allows us to intercept the standard
    *compilation-dexing-running* on an emulator or a device sequence and be able to
    run on our host computer directly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们应该找到一个方法，允许我们在模拟器或设备上拦截标准的 *编译-dexing-运行* 序列，并能够直接在我们的主机计算机上运行。
- en: Creating the TemperatureConverterJVMTest project
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 TemperatureConverterJVMTest 项目
- en: Let's put the ideas presented here into practice. This time we are creating
    a Java project in Eclipse, as opposed to our previously created Android projects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这里提出的想法付诸实践。这次我们在Eclipse中创建一个Java项目，而不是我们之前创建的Android项目。
- en: 'These are the steps needed to do it:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成此操作的步骤：
- en: First we create the project and select **JavaSE-1.6** as the execution environment:![Creating
    the TemperatureConverterJVMTest project](img/3500_10_04.jpg)
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建项目并选择 **JavaSE-1.6** 作为执行环境：![创建 TemperatureConverterJVMTest 项目](img/3500_10_04.jpg)
- en: Pressing **Next >** we can select the **Java Settings** for the project and
    as our intention is to create the tests for the `TemperatureConverter` project
    we should add it as a **Required project on the build path:**![Creating the TemperatureConverterJVMTest
    project](img/3500_10_05.jpg)
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **Next >** 我们可以为此项目选择 **Java 设置**，由于我们的意图是为 `TemperatureConverter` 项目创建测试，因此我们应该将其添加为
    **构建路径上的必需项目**：![创建 TemperatureConverterJVMTest 项目](img/3500_10_05.jpg)
- en: Then we create a new package in this project to keep our tests, named `com.example.aatg.tc.test`.
    In this package we create a new **JUnit Test Case**, named `TemperatureConverterTests`,
    using JUnit version 4, as opposed to the supported JUnit version 3 used in standard
    Android test cases. Select **TemperatureConverter** as the **Class under test:**![Creating
    the TemperatureConverterJVMTest project](img/3500_10_06.jpg)
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在项目中创建一个新的包来保存我们的测试，命名为 `com.example.aatg.tc.test`。在这个包中，我们创建一个新的 **JUnit
    测试用例**，命名为 `TemperatureConverterTests`，使用JUnit版本4，而不是标准Android测试用例中使用的支持的JUnit版本3。选择
    **TemperatureConverter** 作为 **测试的类**：![创建 TemperatureConverterJVMTest 项目](img/3500_10_06.jpg)
- en: 'Pressing **Next >** this time we can select the methods to test and the method
    stubs will be generated automatically:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **Next >** 这次我们可以选择要测试的方法，方法占位符将自动生成：
- en: '![Creating the TemperatureConverterJVMTest project](img/3500_10_07.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![创建 TemperatureConverterJVMTest 项目](img/3500_10_07.jpg)'
- en: 'Now we have the test case template and the method stubs completed. We now need
    to enter the test code we created in previous chapters for `TemperatureConverter`
    in these stubs:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了测试用例模板和方法占位符。我们现在需要将这些之前章节中为 `TemperatureConverter` 创建的测试代码输入到这些占位符中：
- en: '[PRE37]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The previous code snippet shows the imports and the definition of the `TemperatureConverterTests`.
    This is almost exactly the same as before but with the sole addition of JUnit
    4 annotations:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段显示了导入和 `TemperatureConverterTests` 的定义。这几乎与之前完全相同，只是增加了一个JUnit 4注解：
- en: '[PRE38]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Again, this code snippet shows no changes against our previous version of the
    test case but with the sole addition of JUnit 4 annotations:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个代码片段与我们的测试用例的先前版本没有变化，只是增加了一个JUnit 4注解：
- en: '[PRE39]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code is exactly the same with just a few minor differences. One such difference
    is that we are now annotating the tests with `@Test`, as JUnit 4 finds the test
    methods by this annotation and not by their name. So in this example we are using
    the same names for tests methods as we used before, but strictly speaking we could
    have used something different, for example `shouldRaiseExceptionForLessThanAbsoluteZeroC`
    instead of `testExceptionForLessThanAbsoluteZeroC`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完全相同，只有一些细微的差异。其中一个差异是我们现在使用 `@Test` 注解测试，因为 JUnit 4 通过这个注解找到测试方法，而不是通过它们的名称。所以在这个例子中，我们使用与之前相同的测试方法名称，但严格来说，我们也可以使用不同的名称，例如
    `shouldRaiseExceptionForLessThanAbsoluteZeroC` 而不是 `testExceptionForLessThanAbsoluteZeroC`。
- en: Comparing the performance gain
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较性能提升
- en: Once the tests are finished we can run them from Eclipse by selecting the appropriate
    test launcher, **Eclipse JUnit Launcher:**
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试完成，我们就可以通过选择适当的测试启动器在 Eclipse 中运行它们，**Eclipse JUnit 启动器：**
- en: '![Comparing the performance gain](img/3500_10_08.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![比较性能提升](img/3500_10_08.jpg)'
- en: The distinction is evident. There is no emulator start up, any device communication
    and therefore the speed gain is important. Analyzing the evidence we can find
    out these differences.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 区别很明显。没有模拟器启动，没有设备通信，因此速度提升很重要。分析证据，我们可以找出这些差异。
- en: 'Running all tests in my development computer takes 0.005 seconds, with some
    tests taking so little time that they are not even accounted for, and are displayed
    as 0.000 seconds:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的开发计算机上运行所有测试需要 0.005 秒，有些测试所需时间如此之短，以至于甚至不计入，显示为 0.000 秒：
- en: '![Comparing the performance gain](img/3500_10_09.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![比较性能提升](img/3500_10_09.jpg)'
- en: 'Comparing this with the time it took to run the same tests on the emulator
    makes this huge difference evident:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与在模拟器上运行相同测试所需的时间进行比较，这种巨大的差异就显而易见了：
- en: '![Comparing the performance gain](img/3500_10_10.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![比较性能提升](img/3500_10_10.jpg)'
- en: These same tests took 0.443 seconds to run, almost 100 times more and that's
    a huge difference if you consider hundreds of tests running tens of times a day.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相同的测试运行了 0.443 秒，几乎是前者的 100 倍，如果你考虑到每天运行成百上千次测试，这将是巨大的差异。
- en: It is also good to notice that other advantages exists beside the speed gain
    and they are the availability of several mock frameworks and code coverage tools.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，除了速度提升之外，还存在其他优势，那就是有多个模拟框架和代码覆盖率工具可用。
- en: Adding Android to the picture
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Android 加入画面
- en: We intentionally left Android outside our picture. Let's analyze what happens
    if we include a simple Android test. Remember that for these tests to compile
    `android.jar` from the SDK should also be added to the project libraries.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将 Android 留在我们的画面之外。让我们分析如果我们包含一个简单的 Android 测试会发生什么。记住，为了使这些测试编译，`android.jar`
    也应该添加到项目的库中。
- en: Add this test to a new JUnit test case named `TemperatureConverterActivityUnitTests:`
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将此测试添加到名为 `TemperatureConverterActivityUnitTests:` 的新 JUnit 测试用例中
- en: '[PRE40]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And here is what we obtain:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们得到的结果：
- en: '**java.lang.RuntimeException: Stub!**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.lang.RuntimeException: Stub!**'
- en: '**at android.content.Context.<init>(Context.java:4)**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**在android.content.Context.<init>(Context.java:4)**'
- en: '**at android.content.ContextWrapper.<init>(ContextWrapper.java:5)**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**在android.content.ContextWrapper.<init>(ContextWrapper.java:5)**'
- en: '**at android.app.Application.<init>(Application.java:6)**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**在android.app.Application.<init>(Application.java:6)**'
- en: '**at com.example.aatg.tc.TemperatureConverterApplication.<init>(TemperatureConverterApplication.java:27)**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**在com.example.aatg.tc.TemperatureConverterApplication.<init>(TemperatureConverterApplication.java:27)**'
- en: '**…**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**…**'
- en: 'The reason is that `android.jar` provides only the API, not the implementation.
    All methods throw `java.lang.RuntimeException: Stub!` when used.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '原因是 `android.jar` 只提供了 API，没有实现。所有方法在使用时都会抛出 `java.lang.RuntimeException: Stub!`。'
- en: If we want to circumvent this limitation to test some classes outside of the
    Android operating system, we should create an `android.jar` that mocks every class.
    However, we will also find problems for subclasses of Android classes like `TemperatureConverterApplication`.
    This would be a daunting task and a significant amount of work, so we should look
    for another solution.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想绕过这种限制来测试 Android 操作系统之外的某些类，我们应该创建一个模拟每个类的 `android.jar`。然而，我们也会发现 Android
    类的子类（如 `TemperatureConverterApplication`）存在问题。这将是一项艰巨的任务，需要大量的工作，因此我们应该寻找另一种解决方案。
- en: Introducing Robolectric
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Robolectric
- en: '**Robolectric** ([http://pivotal.github.com/robolectric/](http://pivotal.github.com/robolectric/))
    is a unit test framework that intercepts the loading of Android classes and rewrites
    the method bodies. Robolectric re-defines Android methods so they return default
    values, like `null, 0`, or `false`, and if provided it forwards method calls to
    shadow objects giving Android behavior.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**Robolectric** ([http://pivotal.github.com/robolectric/](http://pivotal.github.com/robolectric/))
    是一个单元测试框架，它拦截Android类的加载并重写方法体。Robolectric重新定义了Android方法，使它们返回默认值，如 `null, 0`
    或 `false`，如果提供了，它将方法调用转发到阴影对象，以提供Android的行为。'
- en: A large number of shadow objects are provided, but this is far from complete
    coverage, however it is improving constantly. This should also lead you to treat
    it as an evolving Open Source project, for which you should be ready to contribute
    to make it better, but also to depend on it with caution because you may discover
    that what you need for your tests has not been implemented yet. This is not in
    any way to diminish its promising future.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了大量阴影对象，但这远非全面覆盖，然而它正在不断改进。这也应该引导你将其视为一个不断发展的开源项目，你应该准备好为其做出贡献以使其变得更好，但也应谨慎依赖它，因为你可能会发现你为测试所需的功能尚未实现。这绝不是要贬低其有希望的未来。
- en: Installing Robolectric
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Robolectric
- en: Robolectric can be installed by downloading the `robolectric-<version>-jar-with-dependencies.jar`
    from the Maven central repository ([http://repo1.maven.org/maven2/com/pivotallabs/robolectric/](http://repo1.maven.org/maven2/com/pivotallabs/robolectric/)).
    By the time of this writing the latest JAR available is `robolectric-0.9.8-jar-with-dependencies.jar`
    and this is what we are going to use in our samples.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Robolectric可以通过从Maven中央仓库下载 `robolectric-<version>-jar-with-dependencies.jar`
    来安装 ([http://repo1.maven.org/maven2/com/pivotallabs/robolectric/](http://repo1.maven.org/maven2/com/pivotallabs/robolectric/))。在撰写本文时，可用的最新JAR文件是
    `robolectric-0.9.8-jar-with-dependencies.jar`，这是我们将在示例中使用的内容。
- en: Conveniently you can also download the corresponding Javadoc and attach it to
    the library in you project properties so you can access the documentation from
    Eclipse.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，您还可以下载相应的Javadoc并将其附加到项目属性中的库，以便您可以从Eclipse访问文档。
- en: Creating a new Java project
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的Java项目
- en: 'To keep our tests organized we are creating a new Java project as we did in
    our previous section. This time we are adding the following libraries:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的测试保持组织，我们正在创建一个新的Java项目，就像我们在前面的部分中所做的那样。这次我们添加了以下库：
- en: '`robolectric-<version>-jar-with-dependencies.jar`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robolectric-<version>-jar-with-dependencies.jar`。'
- en: '`android.jar` from your Android SDK.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您Android SDK中的 `android.jar`。
- en: '`maps.jar` also from your Android SDK. Note that this is an optional package
    when you install the SDK.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maps.jar` 也来自您的Android SDK。请注意，当您安装SDK时，这是一个可选包。'
- en: JUnit 4.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 4.
- en: Writing some tests
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一些测试
- en: We will get acquainted with Robolectric by reproducing some of the tests we
    wrote before.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过重现我们之前编写的一些测试来熟悉Robolectric。
- en: 'One good example can be re-writing the `EditNumber` tests. Let''s create a
    new `EditNumberTests` class, this time in the newly created project, and copy
    the tests from the `EditNumberTests` in `TemperatureConverterTest` project:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子可以重写 `EditNumber` 测试。让我们创建一个新的 `EditNumberTests` 类，这次是在新创建的项目中，并将测试从
    `TemperatureConverterTest` 项目的 `EditNumberTests` 中复制过来：
- en: '[PRE41]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the previous snippet we defined the package. In this case using `com.example.aatg.tc.test`
    as usual. Also we declare the test runner with the `@RunWith` annotation. Later
    we defined the `mEditNumber` field to hold the reference to the `EditNumber:`
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了包。在这种情况下，使用 `com.example.aatg.tc.test` 如常。我们还使用 `@RunWith` 注解声明了测试运行器。稍后，我们定义了
    `mEditNumber` 字段来保存对 `EditNumber:` 的引用：
- en: '[PRE42]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This snippet comprises the usual `setup()` and `tearDown()` methods followed
    by the `testPreconditions()` test. In the `setUp()` method we created an `EditNumber`
    with a null context and then we set it as focusable:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段包括通常的 `setup()` 和 `tearDown()` 方法，然后是 `testPreconditions()` 测试。在 `setUp()`
    方法中，我们创建了一个具有null上下文的 `EditNumber`，然后将其设置为可聚焦：
- en: '[PRE43]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this last snippet we have the basic tests which are the same as the `EditNumber`
    tests of our previous examples.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的代码片段中，我们有基本的测试，与之前示例中的 `EditNumber` 测试相同。
- en: We are highlighting the most important changes. The first one is to specify
    the test runner JUnit will delegate the processing of the tests to, by using the
    annotation `@RunWith`. In this case we need to use `RobolectricTestRunner.class`
    as the runner. Then we create an `EditText` using a null `Context` as this is
    a class that cannot be instantiated. Finally, a `DELTA` value is specified in
    `testGetNumber` as `assertEquals` since the floating point number requires it
    in JUnit 4\. Additionally we added the `@Test` annotation to mark the method as
    tests.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调最重要的变化。第一个变化是使用注解`@RunWith`指定JUnit将委托处理测试的测试运行器。在这种情况下，我们需要使用`RobolectricTestRunner.class`作为运行器。然后我们使用一个null的`Context`创建一个`EditText`，因为这个类不能被实例化。最后，在`testGetNumber`中指定了一个`DELTA`值，因为JUnit
    4中浮点数需要它。此外，我们还添加了`@Test`注解来标记方法为测试。
- en: The other test methods that existed in the original `EditNumberTests` cannot
    be implemented or simply fail for a variety of reasons. For example, as we mentioned
    before, Robolectric classes return default values, like `null, 0, false`, and
    so on, and this is the case for `Editable.Factory.getInstance()` which returns
    null and causes the test to fail; because there is no other way of creating an
    `Editable` object we are at a dead end.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 原始`EditNumberTests`中存在的其他测试方法由于各种原因无法实现或简单地失败。例如，正如我们之前提到的，Robolectric类返回默认值，如`null,
    0, false`等，这种情况也适用于`Editable.Factory.getInstance()`，它返回null并导致测试失败；因为没有其他方法创建`Editable`对象，所以我们陷入了僵局。
- en: Similarly, the `InputFilter` that `EditNumber` sets is non functional. It is
    futile to create a test that expects some behavior.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`EditNumber`设置的`InputFilter`是非功能的。创建一个期望某些行为的测试是徒劳的。
- en: The alternative to these shortcomings would be to create `Shadow` classes but
    this requires alteration of the Robolectric source and the creation of `Robolectric.shadowOf()`
    methods. This procedure is described in the documentation that you may follow
    if you are interested in applying this approach to your tests.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不足的替代方案是创建`Shadow`类，但这需要修改Robolectric源代码并创建`Robolectric.shadowOf()`方法。如果您有兴趣将这种方法应用于测试，可以在文档中找到此过程的描述。
- en: Before being able to run your tests you need to create symbolic links for `TemperatureConverter`
    project's `AndroidManifest.xml` and resources which are used by Robolectric.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够运行测试之前，您需要为`TemperatureConverter`项目的`AndroidManifest.xml`和Robolectric使用的资源创建符号链接。
- en: '[PRE44]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Having identified these issues we can proceed to run the tests from inside Eclipse
    and they will run in the host's JVM with no need to start or communicate with
    an emulator or device.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了这些问题之后，我们可以从Eclipse内部运行测试，它们将在主机的JVM上运行，无需启动或与模拟器或设备通信。
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been a little more involved than previous ones, with the sole
    intention of facing realistic situations and state-of-the-art Android testing.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章比之前的章节要复杂一些，唯一的目的是面对现实情况以及最先进的Android测试。
- en: We started analyzing the requirements and steps to build Android from source.
    This measure is needed to be able to activate code coverage through EMMA, which
    we did and later on we ran our tests obtaining a detailed code coverage analysis
    report.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始分析从源代码构建Android的要求和步骤。这项措施是为了能够通过EMMA激活代码覆盖率，我们确实这样做了，并且后来运行了我们的测试，获得了详细的代码覆盖率分析报告。
- en: We then used this report to improve our tests and we created some to cover areas
    we were not aware that have not been tested. This led us to better tests and in
    some cases improved the design of the project under test.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这份报告来改进我们的测试，并创建了一些覆盖我们之前未意识到尚未测试的区域。这使我们有了更好的测试，并在某些情况下改进了被测试项目的架构。
- en: We introduced Robotium, a very useful tool to ease the creation of test cases
    for our Android applications and we improved some tests with it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了Robotium，这是一个非常有用的工具，可以帮助我们轻松创建Android应用的测试用例，并且我们用它改进了一些测试。
- en: Then we analyzed one of the hottest topics on Android testing as it is testing
    on the development host JVM optimizing and reducing considerably the time needed
    to run the tests, something that is highly desirable when we are applying Test
    Driven Development to our process. Within this scope, we analyzed JUnit 4 and
    Robolectric and created some tests as demonstrations and to get you started on
    these techniques.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分析了Android测试中最热门的话题之一，即开发主机JVM上的测试优化，这可以显著减少运行测试所需的时间，这在我们将测试驱动开发应用于我们的流程时是非常期望的。在这个范围内，我们分析了JUnit
    4和Robolectric，并创建了一些测试作为演示，以便您开始使用这些技术。
- en: We have reached the end of this journey through the available methods and tools
    to Android testing. You should now be much better prepared to start applying this
    to your own projects. The results will be visible as soon as you begin to use
    them.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了通过可用方法和工具探索Android测试的旅程的终点。现在，你应该已经为开始将所学应用到自己的项目中做好了充分的准备。一旦开始使用，效果就会立即显现。
- en: Finally, I hope that you have enjoyed reading this book as much as I did writing
    it.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我希望你阅读这本书的乐趣和我写作这本书的乐趣一样多。
- en: Happy testing!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 祝测试愉快！
