- en: Chapter 10. Alternative Testing Tactics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point we have analyzed the most common and accessible tactics to
    implement testing in our projects. However, there are a few missing pieces in
    our puzzle and with the current versions of the Android SDK (*Android 2.3 Gingerbread*
    as of this writing) these features are not yet implemented. Nevertheless, not
    everything is lost. One of the biggest and strongest benefits of Android is its
    Open Source nature and the features we are going to exploit here precisely depend
    on it because we will be using the complete source code to introduce some changes
    required by what we plan to provide.
  prefs: []
  type: TYPE_NORMAL
- en: Building Android from source code is not for the faint hearted. It is extremely
    time consuming mainly at the beginning while you are familiarizing yourself with
    the whole Android environment, and it also requires a lot of disk space and horsepower.
    To illustrate this assertion, one simple build for one target takes almost 10GB
    of disk space and almost an hour to build on a 4 core machine. I'm not trying
    to scare you but warn you and at the same time ask for a little endurance.
  prefs: []
  type: TYPE_NORMAL
- en: They say that great sacrifices come with great rewards and this seems to be
    another case that follows this rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: Building Android from source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coverage using EMMA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding code coverage to our Temperature Converter project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Robotium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing on host's JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Robolectric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Android from source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps Android's *Achilles' heel* would be the lack of documentation and the
    number of places you have to visit to get the complete version of what you are
    trying to find, or what's even worse in many cases the official documentation
    is incorrect or has not been updated to match the current release. One example
    of this is the documentation (available at [http://source.android.com/source/download.html](http://source.android.com/source/download.html)
    at the time of this writing) of the requirements to build Android from source
    that still states that Java 6 is not supported and Ubuntu 8.10 (intrepid) 32bit
    can be used, which is totally wrong. Funnily enough, Java 6 and at least Ubuntu
    10.04 (lucid) 64bit are required. Starting with Android 2.3 (Gingerbread), building
    on 32bit machines is no longer supported. But that's enough for a rant, I will
    leave them for my personal blog, otherwise if the documentation were complete,
    books like this one would not be needed and I could be writing one about Windows
    Phone 7...
  prefs: []
  type: TYPE_NORMAL
- en: Just kidding, I don't think this could happen in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of our objectives in building Android from source is enabling code coverage
    via EMMA ([http://emma.sourceforge.net/](http://emma.sourceforge.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a measure used in software testing that describes the amount
    of source code that was actually tested by the tests suite and to what degree
    following some criteria. As code coverage inspects the code directly it is therefore
    a form of white box testing.
  prefs: []
  type: TYPE_NORMAL
- en: From the several tools available providing code coverage analysis for Java we
    are using EMMA, an open-source toolkit for measuring and reporting Java code coverage
    that is supported by the Android project, and the infrastructure to start using
    it for your own projects is already there, therefore minimizing the effort needed
    to implement it. EMMA came to fill an existing gap in the vast Open Source ecosystem
    where no coverage tools existed with compatible licenses. EMMA is based on IBM's
    Common Public License v1.0 and is thus free for both Open Source and commercial
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'EMMA distinguishes itself from other tools by going after a unique feature
    combination: support for large-scale enterprise software development while keeping
    individual developer''s work fast and iterative. This is fundamental in a project
    the size of Android and EMMA shines at its best providing code coverage for it.'
  prefs: []
  type: TYPE_NORMAL
- en: EMMA features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android 2.3 includes EMMA v2.0, build 5312\. The most distinctive set of features,
    paraphrasing its documentation, which can be found at its website are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: EMMA can instrument classes for coverage either offline (before they are loaded)
    or on the fly (using an instrumenting application classloader).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supported coverage types: Class, method, line, basic block. EMMA can detect
    when a single source code line is covered only partially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage stats are aggregated at method, class, package, and "all classes" levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output report types: Plain text, HTML, XML. All report types support drill-down,
    to a user-controlled detail depth. The HTML report supports source code linking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output reports can highlight items with coverage levels below user-provided
    thresholds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage data obtained in different instrumentation or test runs can be merged
    together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMMA does not require access to the source code and degrades gracefully with
    decreasing amounts of debug information available in the input classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMMA can instrument individual `.class` files or entire `.jar files` (in place,
    if desired). Efficient coverage subset filtering is possible, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makefile and ANT build integration are supported on an equal footing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EMMA is quite fast: The runtime overhead of added instrumentation is small
    (5 to 20%) and the bytecode instrumentor itself is very fast (mostly limited by
    file I/O speed). Memory overhead is a few hundred bytes per Java class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EMMA is 100% pure Java, has no external library dependencies, and works in any
    Java 2 JVM (even 1.2.x).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some minor changes were introduced by Android to the EMMA project to fully
    adapt it and support code coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: Change `coverage.out.file` location in `core/res/emma_default.properties` to
    `/data/coverage.ec`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove reference to `sun.misc.*` in `core/java14/com/vladium/util/IJREVersion.java`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove reference to `sun.misc.*` and `SunJREExitHookManager` class from `core/java13/com/vladium/util/exit/ExitHookManager.java`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `java.security.cert.Certificate` cast to `core/java12/com/vladium/emma/rt/InstrClassLoader.java`
    to fix compiler error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move `out/core/res/com/vladium/emma/rt/RTExitHook.closure` (from Emma Ant build)
    into `pregenerated/` so it does not have to be generated in Android's make-based
    build, but also doesn't break Emma's build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android build for gingerbread requires a 64-bit build environment as well
    as some other tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Required packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Git, JDK, flex, and the other development packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pieces from the 32-bit cross-building environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X11 development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The instructions if you are running the recommended Ubuntu 10.04 LTS 64bit
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the system to use the right version of java by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In any case, check the AOSP website ([http://source.android.com/source/download.html](http://source.android.com/source/download.html))
    for updated instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the Android source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android project is a large collection of relatively independent projects
    put under the Android umbrella. All of them use Git as the version control system.
    You can see what I mean by visiting the **Gitweb** interface for the Android project
    at [http://android.git.kernel.org/](http://android.git.kernel.org/).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, dozens of projects are listed and you need all to build the
    entire platform. To simplify the process of dealing with this great number of
    Git projects at the same time Google created **repo**, a tool that was built on
    top of Git to help manage the many Git repositories, uploads to the revision control
    system, and automate parts of the Android development work-flow.
  prefs: []
  type: TYPE_NORMAL
- en: '`Repo` is a complementary tool that does not replace Git, but just makes it
    easier to work with Git in the context of Android. The `repo` command is an Python
    executable wrapped into a shell script and can be put anywhere in your path.'
  prefs: []
  type: TYPE_NORMAL
- en: Detailed information about Git and Repo in the scope of Android project can
    be obtained from their information page at [http://source.android.com/source/git-repo.html](http://source.android.com/source/git-repo.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installing repo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned before, `repo` is our key to the Android source code world,
    therefore the first measure is installing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates the initial repo script, which will initialize the complete repository
    and will include the `repo.git` project as well, so `repo` is auto-maintained.
    Every time you synchronize with the repository, changes to `repo` itself are propagated
    if necessary. That's a very clever use of the tool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the working copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our working copy of the repository can be created anywhere in our computer.
    Just remember that there should be at least 10GB of free space and sometimes much
    more is needed if you build for different targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we decide to create the working copy in `~/android/android-2.3`,
    then use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These three simple steps have created our working copy ready to be synchronized.
    Remember that is a very big download and depending on your network connection
    speed and the load on the servers it could take some time. So it is very smart
    to wait some days after a major release is pushed to the servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are ready to synchronize just invoke this command in your working
    copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run `repo sync`, this is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: If the project has never been synchronized, then `repo sync` is equivalent to
    `git clone`. All branches in the remote repository are copied to the local project
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the project has already been synchronized once, then `repo sync` is equivalent
    to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git remote update`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git rebase origin/branch`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where branch is the currently checked-out branch in the local project directory.
    If the local branch is not tracking a branch in the remote repository, then no
    synchronization will occur for the project.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `git rebase` operation results in merge conflicts, you will need to use
    the normal Git commands (for example, `git rebase --continue)` to resolve the
    conflicts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once finished, the complete Android source code has been downloaded to your
    working copy. We haven't specified any specific branch so we just downloaded the
    latest Android Open Source Project (AOSP) main branch.
  prefs: []
  type: TYPE_NORMAL
- en: The Building Steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are ready to start our build supporting code coverage analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this we need to follow the steps to set the environment and chose
    your combo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**including device/htc/passion/vendorsetup.sh**'
  prefs: []
  type: TYPE_NORMAL
- en: '**including device/samsung/crespo/vendorsetup.sh**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**You''re building on Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lunch menu... pick a combo:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. full-eng**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. full_x86-eng**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. simulator**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. full_passion-userdebug**'
  prefs: []
  type: TYPE_NORMAL
- en: '**5\. full_crespo-userdebug**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Which would you like? [full-eng]**'
  prefs: []
  type: TYPE_NORMAL
- en: Select **full-eng** in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '**============================================**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLATFORM_VERSION_CODENAME=AOSP**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLATFORM_VERSION=AOSP**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TARGET_PRODUCT=full**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TARGET_BUILD_VARIANT=eng**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TARGET_SIMULATOR=false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TARGET_BUILD_TYPE=release**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TARGET_BUILD_APPS=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TARGET_ARCH=arm**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TARGET_ARCH_VARIANT=armv5te**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOST_ARCH=x86**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOST_OS=linux**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOST_BUILD_TYPE=release**'
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILD_ID=OPENMASTER**'
  prefs: []
  type: TYPE_NORMAL
- en: '**============================================**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more step is needed in this case. As we want to enable EMMA code coverage
    we need to set this in the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Get set, ready, go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-j` or `-jobs` option to make lets you specify the number of jobs (commands)
    to run simultaneously. This is very useful to speed up lengthy build processes
    in multiprocessor or multicore machines. If no argument is given to the `-j` option,
    then `make` will not limit the number of jobs that can run simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a while and tons of messages, your build will be available. If everything
    went well you will be seeing a message similar to this one at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target system fs image: out/target/product/generic/obj/PACKAGING/systemimage_intermediates/system.img**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Install system fs image: out/target/product/generic/system.img**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installed file list: out/target/product/generic/installed-files.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the last steps are to create the system image and the list of
    installed files.
  prefs: []
  type: TYPE_NORMAL
- en: If the build fails then try some of the suggestions mentioned below in order
    to fix it or find out more at the AOSP site ([http://source.android.com/source/building.html](http://source.android.com/source/building.html)).
    If there are some problems and things are not so smooth, here is a list of tips
    you can follow to revert the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tips to revert from a broken build**'
  prefs: []
  type: TYPE_NORMAL
- en: Clean, using `make clean`, and make again.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of jobs (make `-j` or `make jobs)` usually helps too.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, just invoking make again after a failed build, can make the build
    succeed. Yes, I know it sounds like nonsense, but it helps when you have tried
    everything else.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an instrumented build that will let us obtain code coverage analysis
    for tests in our projects. So this is our next step.
  prefs: []
  type: TYPE_NORMAL
- en: TemperatureConverter code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built Android from source to be able to obtain code coverage analysis reports
    for our projects mainly for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We need an EMMA instrumented build, which is what we did in previous sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to instrument an application, this application should be built as
    part of the main build tree, and this is what we will be doing now;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A possible location for our application and tests inside the main Android tree
    could be `development/samples`, so we are going to use it. Should you decide on
    a different location, minor adaption might be needed in the files and commands
    presented here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have our TemperatureConverter project and its tests `TemperatureConverterTests`
    somewhere in our filesystem, and if you followed the examples presented before
    they are probably checked into the version control system of your choice, so the
    options here are checking out the project again at this location or creating a
    symbolic link. Let''s choose the latter for the sake of simplicity for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Following, we need to add the makefiles. We built our projects from Eclipse
    and later on we added `ant` support. Now we are adding support for a third build
    system: `make`.'
  prefs: []
  type: TYPE_NORMAL
- en: Android built is `make` based and we should follow its conventions and style
    to be able to build our application and its tests as part of the main build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `Android.mk` inside the `TemperatureConverter` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This makefile will be included as part of the main build if executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build it separately we can use a helper function that was defined in our
    environment when we set it up at the beginning using `envsetup.sh`. This function
    is `mm` and is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The boilerplate code to locate and include needed components is provided by
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: Using it to build the application is simply done by invoking it when our current
    working directory is the project we want to compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we enabled EMMA by setting `EMMA_INSTRUMENT=true` in our environment
    among the messages produced by this command, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: processing instrumentation path ..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: instrumentation path processed in 149 ms**'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: [14 class(es) instrumented, 4 resource(s) copied]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: metadata merged into [/home/diego/android/android-2.3/out/target/common/obj/APPS/TemperatureConverter_intermediates/coverage.em]
    {in 16 ms}**'
  prefs: []
  type: TYPE_NORMAL
- en: This indicates that our build is being instrumented.
  prefs: []
  type: TYPE_NORMAL
- en: We should proceed in a similar manner to build and instrument our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TemperatureConverterTest` project create its corresponding makefile:
    `Android.mk`, this time containing this information, which is slightly different
    from the main project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a little more involved because the tests are using external libraries
    we need to define to be used during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we should build it using the `mm` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully built the `TemperatureConverter` application and its tests,
    now as part of the main Android build. At this point we are ready to obtain the
    code coverage analysis reports, just by following a few more steps.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code coverage analysis report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having reached this point, we have `TemperatureConverter` and its tests instrumented
    and compiled residing in our output directory which is `out/target/common/obj/APPS/`.
  prefs: []
  type: TYPE_NORMAL
- en: We need an instance of the emulator that belongs to our instrumented built.
    This emulator is in the `out` directory too.
  prefs: []
  type: TYPE_NORMAL
- en: In this case we extend the default system partition size up to 256MB and include
    a sdcard image that should have been created previously. These elements are needed
    because some data will be collected during the instrumented test run and we need
    some room to save it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our intention is now to synchronize the image running on the emulator with our
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: These steps avoid creating a new image when some changes or updates are available
    just by copying the modified files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to do it we first need to enable writing to the system image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This command when finished successfully should give this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**remount succeeded**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Followed by the synchronization of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of files being copied to the emulator image are displayed. Once everything
    is updated we can now run the tests using `am instrument` as we previously did.
    As we mentioned in [Chapter 2](ch02.html "Chapter 2. Testing on Android"), *Testing
    on Android* when we reviewed the available options for this command, `-e` can
    be used to set various suboptions. In this case we use it to enable code coverage
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This following message verifies that our tests are collecting coverage data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: collecting runtime coverage data ..**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last message indeed informs us where this data was collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generated code coverage data to /data/data/com.example.aatg.tc/files/coverage.ec**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a directory in the development computer to keep our coverage
    reports for this project. In this directory we should also copy the off-line coverage
    metadata and then generate the reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we copy the coverage report from the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When data is transferred we receive these statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 KB/s (22840 bytes in 0.110s)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the off-line coverage metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With all these components present in our working directory, it will be easier
    to specify the command line options. If you prefer you can use a different organization
    and leave the files somewhere else and even create symbolic links here.
  prefs: []
  type: TYPE_NORMAL
- en: Having read everything, we can invoke `emma` to generate the report. The default
    report shows the overall coverage summary followed by a breakdown by package.
    In this example we are using HTML output and we are linking to the source.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your source folder for the `TemperatureConverter` main project is other
    than `~/workspace/TemperatureConverter/src` don''t forget to adapt the following
    command, otherwise the command will fail: `~/android/android-2.3/out/emma/tc$
    java -cp ~/android/android-2.3/external/emma/lib/emma.jar emma report -r html
    -in coverage.ec -sp ~/workspace/TemperatureConverter/src -in coverage.em`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And we will be able to see the messages indicating the creation of the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: processing input files ..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: 2 file(s) read and merged in 20 ms**'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: writing [html] report to [/home/diego/android/android-2.3/out/emma/tc/coverage/index.html]
    ..**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EMMA: writing [html] report to [/home/diego/android/android-2.3/out/emma/tc/coverage/index.html]
    ..**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This has created the report files inside the coverage directory, so we can
    open the index by invoking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the coverage analysis report is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating code coverage analysis report](img/3500_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This report has three main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overall coverage summary:** The summary for all classes is presented here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overall stats summary:** The statistics of the coverage are presented here,
    for example how many packages, classes, or lines were present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coverage breakdown by package:** In the case of bigger applications this
    will display the coverage for particular packages. In this example, it''s the
    same as the total because there is a single package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information presented in the report includes coverage metrics in a way that
    allows for drilling down into data in a top-down fashion, starting with all classes
    and going all the way to the level of individual methods and source lines (in
    the HTML report).
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental unit of code coverage in EMMA is the basic blocks; all other
    types of coverage are derived from the basic block coverage in some way. Line
    coverage is mostly used to link to the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This table describes the important pieces of information in the EMMA coverage
    report:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Label | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| name | The name of the class or package |'
  prefs: []
  type: TYPE_TB
- en: '| Class, % | The percentage of classes covered over the total and the detailed
    number. |'
  prefs: []
  type: TYPE_TB
- en: '| Method, % | The percentage of methods covered over the total and the detailed
    number. This is a basic java method which is composed by a given number of basic
    blocks. |'
  prefs: []
  type: TYPE_TB
- en: '| Block, % | The percentage of blocks covered over the total and the detailed
    number. A basic block is defined as a sequence of bytecode instructions without
    any jumps or jump targets.The number of basic blocks in a method is a good measure
    of its complexity. |'
  prefs: []
  type: TYPE_TB
- en: '| Line, % | The percentage of lines covered over the total and the detailed
    number. This is basically used to link to the source code. |'
  prefs: []
  type: TYPE_TB
- en: 'When the values presented are under a threshold coverage metric value, these
    metrics are presented in red in the report. By default, these values are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For methods: 70%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For blocks: 80%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For lines: 80%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For classes: 100%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these values can be changed, specifying parameters on the command line
    or in a configuration file. Please refer to the documentation for details ([http://emma.sourceforge.net/docs.html](http://emma.sourceforge.net/docs.html)).
  prefs: []
  type: TYPE_NORMAL
- en: We can drill-down from the package to specific methods and the lines covered
    are presented in green while uncovered ones appear in red and partially covered
    in yellow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of this report for the `TemperatureConverter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating code coverage analysis report](img/3500_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this report we can see that the class `TemperatureConverter` is not 100%
    covered but all the basic blocks inside it are.
  prefs: []
  type: TYPE_NORMAL
- en: Do you know why ?
  prefs: []
  type: TYPE_NORMAL
- en: Think for a moment...
  prefs: []
  type: TYPE_NORMAL
- en: Yes, because the implicit default constructor has not been tested. But wait
    a second; this is a utility class which is not supposed to be instantiated at
    all. We can see here not only how this analysis is helping us to test our code
    and find potential bugs but also to improve the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do to prevent `TemperatureConverter` from being instantiated
    is to create a private default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once we add this private constructor and run the tests and coverage again we
    can see now that even though the class is not yet 100% covered and thus not green
    we can assure that this constructor won't be invoked from any other class.
  prefs: []
  type: TYPE_NORMAL
- en: Covering the restoring the instance state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another case that we will analyze. In the report for `TemperatureConverterActivity`
    we can see that some blocks are still not covered and they are red. One of such
    blocks is the partial support for restoring a saved instance we added before,
    though this block is not yet functional and its only logging a message we should
    cover it with a test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code mentioned in `TemperatureConverterActivity.java` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To test this block we must control the invocation of the `onCreate()` method
    and inject a mock `Bundle` to simulate the actual Android lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: We may think of using one of our previously created test classes to add the
    needed test, but if you remember from our previous chapters we stated that when
    we need a higher degree of control over the creation of the `Activity` under test,
    instead of `ActivityInstrumentationTestCase2<T>` we should use `ActivityUnitTestCase<T>`,
    which is also derived from `InstrumentationTestCase` (see the UML class diagram
    for `ActivityInstrumentationTestCase2<T>` in [Chapter 3](ch03.html "Chapter 3. Building
    Blocks on the Android SDK"), *Building Blocks on the Android SDK*)
  prefs: []
  type: TYPE_NORMAL
- en: The test case based on `ActivityUnitTestCase<T>` allows us to inject the desired
    values to `onCreate()` while starting the Activity by using `startActivity(Intent
    intent, Bundle savedInstanceState, Object lastNonConfigurationInstance)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the test case we are adding to our already
    existing `TemperatureConverterActivityUnitTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a `Bundle` containing only dummy values as nothing special is
    expected in the Activity. Additionally we are injecting a real `TemperatureConverterApplication`
    object instead of an Application mock because it is used, and casted, inside the
    Activity's `onCreate()` method and it would fail.
  prefs: []
  type: TYPE_NORMAL
- en: No additional tests were added to this class as nothing special is done when
    the saved state is restored. For your particular application probably you would
    like to check that some values were restored correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Should we run the test coverage report again we would see that now the mentioned
    block is now covered.
  prefs: []
  type: TYPE_NORMAL
- en: Covering the exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing with our examination of the coverage report will lead us to discover
    another block that is not exercised by our current tests. The block in question
    is the last catch in the following try-catch block in `TemeratureConverterActivity:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We should provide a test, or better a pair of tests, one for each temperature
    unit, that furnishing an invalid temperature verifies that the error is displayed.
    This is the test in `TemperatureConverterActivityTests` for the Celsius case and
    you can easily convert it to provide the other case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We clear and request the focus for the field under test. As we did before, we
    should achieve this by using a Runnable on the UI thread otherwise we will receive
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check there's no previous error, set the invalid temperature, and retrieve
    the error message to verify that is not null. Running the end-to-end process again
    we can attest that the block is now covered giving us total coverage as intended.
  prefs: []
  type: TYPE_NORMAL
- en: This is the iterative process you should follow to change as much as possible
    of the code to green. Ideally this should be 100% but sometimes this is not achievable
    mainly for some blocks that are not reachable during the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing access restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the blocks we added to satisfy our needs, the private constructor for
    `TemperatureConverter`, is now unreachable by our tests and is marked red. In
    cases like this we can leave it as it is or we can use a more convoluted solution
    using reflection to bypass the access restrictions and create a test. Though this
    is not really advisable because strictly speaking you should limit to test the
    public interface, we are including this as an illustration of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the test we are adding to the `TemperatureConverterTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This example uses reflection to bypass the access restriction and create a new
    `TemperatureConstructor` instance and then verify that it was successfully created.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with this technique or Java reflection in general you
    can read the excellent tutorial at The Java Tutorials by Oracle ([http://download.oracle.com/javase/tutorial/reflect/](http://download.oracle.com/javase/tutorial/reflect/)).
  prefs: []
  type: TYPE_NORMAL
- en: Covering the options menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking another look at the coverage report, we can yet identify a method that's
    not covered by our tests. It is the `TemperatureConverterActivity.onCreateOptionsMenu()`
    which creates the menu holding the Preferences option in our particular situation.
    What it does is very simple and straightforward. It creates a `MenuItem` that
    when clicked invokes the `TemperatureConverterPreferences` Activity through the
    corresponding intent. This is right what we are going to test. From our experience
    we know that if we are interested in knowing if an Activity was launched from
    our Activity under tests, then what we need is an `ActivityMonitor`, so we are
    establishing the test based on this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the new test we will add to the `TemperatureConverterActivityTests`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Firstly we get the Instrumentation as in other cases. We then add a monitor
    using `addMonitor(),` a convenience wrapper that also creates the `ActivityMonitor`
    for us and returns it, defining the name of the Activity class to monitor, null
    as a result as we are not interested in it, and false not to block the start of
    the Activity. This monitor will be hit if an Activity that matches the class is
    launched.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we invoke the menu option with ID `0`, as it was defined in `onCreateOptionsMenu()`,
    and passing no flags (0 again). We assert that the invocation was successful as
    `invokeMenuActionSync()` returns true in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: We wait for the Activity to start, verify that it was actually started as `waitForActivityWithTimeout()`
    returns null if the timeout expires before the Activity was started, and finally
    `finishing()` the Activity.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good example of `ActivityMonitor` utilization. However, the way we
    used to invoke the particular menu item and the limitations we would face if we
    intended to continue testing the new Activity for a real functional test led us
    to believe that there should be another way, and actually there is!
  prefs: []
  type: TYPE_NORMAL
- en: We will explore such ways in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The undocumented Ant coverage target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If building with make doesn’t appeal to you very much there is still another
    alternative. Latest versions of Android tools include an undocumented option that
    adds to the documented targets we mentioned before: help, clean, compile, debug,
    release, install, and uninstall.'
  prefs: []
  type: TYPE_NORMAL
- en: This target is `coverage` and can be used like in the following example in the
    `TemperatureConverterTest` project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be able to successfully complete all its subtasks a suitable emulator or
    device should be running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following output (parts of the output were trimmed in
    order to include it here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This automates several of the steps we described before. However it is not documented
    yet so it can be removed or changed in the future. On the other hand, when the
    projects are complex or there are a lot of dependencies this build target may
    fail when the makefile succeeds, so use it with caution.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Robotium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One component of the vast emerging robotic fauna is Robotium ([http://code.google.com/p/robotium/](http://code.google.com/p/robotium/)),
    a test framework created to simplify the writing of tests requiring minimal knowledge
    of the application under test. Robotium is mainly oriented to write powerful and
    robust automatic black-box test cases for Android applications. It can cover function,
    system, and acceptance test scenarios, even spanning multiple Android activities
    of the same application automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Robotium can also be used to test applications that we don't have the source
    code for, or even pre-installed applications.
  prefs: []
  type: TYPE_NORMAL
- en: Robotium has full support for Activities, Dialogs, Toasts, Menus, and Context
    Menus.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put Robotium to work creating some new tests for `TemperatureConverter`.
    To keep our tests organized we create a new package named `com.example.aatg.tc.tests.robotium`
    in the `TemperatureConverterTest` project. In this package we are creating the
    class for our test cases, because we will be initially testing `TemperatureConverterActivity`.
    It is reasonable to call it `TemperatureConverterActivityTests` even though we
    have a class with the same name in another package also extending `ActivityInstrumentationTestCase2`.
    After all, this class will be containing tests for this same `Activity` too.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Robotium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download the `robotium-solo` JAR file and its Javadoc so we can add
    them to our project. Go to the Robotium download site ([http://code.google.com/p/robotium/downloads/list](http://code.google.com/p/robotium/downloads/list))
    and pick the latest version available, which at the time of this writing is `robotium-solo-2.1.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the properties of our `TemperatureConverterTest` project we need to add this
    JAR to **Java Build Path | Libraries**. Once added, you can expand this node and
    add the Javadoc location to point to the companion JAR file using the **Javadoc
    in archive** option.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From previous chapter we know that if we are creating test cases for an Activity
    that should run connected to the system infrastructure, we should base it on `ActivityInstrumentationTestCase2`,
    and that is what we are going to do.
  prefs: []
  type: TYPE_NORMAL
- en: The testFahrenheitToCelsiusConversion() test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More or less the test cases have the same structure as other Instrumentation
    based tests. The main difference is that we need to instantiate Robotium's Solo
    in the test `setUp()` and `finalize()` it in the `tearDown():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To instantiate `Solo` we have to pass a reference to the `Instrumentation` and
    to the `Activity` under test.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, to finalize `Solo` we should precisely call the `finalize()`
    method, then finish the `Activity`, and invoke `super.tearDown()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solo provides a variety of methods to drive UI tests and some assertions. Let''s
    start by re-implementing the `testFahrenheitToCelsiusConversion()` that we previously
    implemented using the conventional approach, but in this case using `Solo` facilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty similar, however the first difference you may have noticed is
    that in this case we are not getting references to the UI elements as we previously
    did in the `setUp()` method using `findViewById()` to locate the View. However,
    we are using one of the biggest advantages of Solo that is locating the Views
    for us using some criteria. In this case the criteria are used in the order in
    which they appear on the screen and since they are counted an index is assigned.
    The method `mSolo.clearEditText(int index)` expects an integer index of the position
    on the screen starting from `0`. Consequently we should add these constants to
    the test case, as in our UI the Celsius field is on top and Fahrenheit beneath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The other methods follow the same convention and we are supplying these constants
    when necessary. This test is very similar to the one in `com.example.aatg.tc.test.TemperatureConverterActivityTest`
    but you may have noticed that there is a subtle difference. Here we are located
    at a much higher level and we don't have to worry about internals or implementation
    details; for example when in our previous test we invoked `mCelsius.requestFocus()`
    to trigger the conversion mechanism, but here we just simulate what the user does
    and issue a `mSolo.clickOnEditText(CELSIUS)`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we don't want to cast and use `EditNumber.getNumber()` either.
    We just obtain the textual data that is on the screen, convert it to a `Double`,
    and then compare it against the expected value.
  prefs: []
  type: TYPE_NORMAL
- en: We simplified the test sensibly but the biggest advantage of using `Solo` is
    yet to come.
  prefs: []
  type: TYPE_NORMAL
- en: The testOnCreateOptionsMenu() revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have been waiting for this since the announcement in our preceding `testOnCreateOptionsMenu()`
    implementation. This time we are situated at a much higher level and we don't
    deal with implementation details. It is not our problem if a new Activity is launched
    when we click on the menu item; we only treat this case from the UI perspective.
  prefs: []
  type: TYPE_NORMAL
- en: This is a screenshot showing the preferences dialog for **Decimal places:**
  prefs: []
  type: TYPE_NORMAL
- en: '![The testOnCreateOptionsMenu() revisited](img/3500_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our purpose is also to change the value of **Decimal places** preferences to
    5, and verify that the change actually took place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates the details of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Can you already appreciate the difference? There are no gory details about how
    all this is implemented. We only test its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We start by pressing the `MENU` key, clicking on **Preferences**.
  prefs: []
  type: TYPE_NORMAL
- en: Wow, we just specify the menu item title and that's it!
  prefs: []
  type: TYPE_NORMAL
- en: The new Activity is started but we don't have to worry about it. We continue
    and click on **Decimal places**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We verify that some field containing a number, the prior value of this preference,
    appeared. Do you remember what I said about regular expressions: they always come
    in handy in one way or another; here to match any decimal integer number (any
    digit followed by zero or more digits). Then we clear the field and verify that
    it was in fact cleared.'
  prefs: []
  type: TYPE_NORMAL
- en: We enter the string representing the number we want to use as a preference,
    5 in this case. Click on the **OK** button, and the preference is saved.
  prefs: []
  type: TYPE_NORMAL
- en: It remains to verify that it actually happened. The same procedure is used to
    get the menu and the field and finally we verify that the actual number is already
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder where `DECIMAL_PLACES` comes from. We previously defined `CELSIUS`
    and `FAHRENHEIT` index constants for the fields on the screen and this is the
    same case, because this will be the third `EditText` we should define in our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tests can be run from Eclipse or the command line according to your preferences.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have enjoyed this simplicity as much as I did and that your brain
    is now bubbling with ideas to implement your own tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing on host's JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We left this subject for the end of this chapter as it seems this is the *Holy
    Grail* of the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: You know that Android is based on a virtual machine named Dalvik, after a village
    in Iceland, optimized for mobile resources with limited capabilities such as constrained
    amount of memory and processor speed. Certainly a very different environment than
    our development host computer, which may have plenty of memory and processor speed
    to enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinarily, we run our applications and tests on an emulator or device. These
    targets have a much slower real or emulated CPU and thus running our tests is
    a time consuming activity mainly when our project starts to grow, and applying
    Test Driven Development techniques compels us to run hundreds of tests to verify
    every change we introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth noticing that this technique can be used only as a workaround during
    the development process to speed things up and it should never replace final testing
    on the real platform as incompatibilities between the Dalvik and JavaSE runtime
    may affect the accuracy of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we should find out a method that allows us to intercept the standard
    *compilation-dexing-running* on an emulator or a device sequence and be able to
    run on our host computer directly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TemperatureConverterJVMTest project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's put the ideas presented here into practice. This time we are creating
    a Java project in Eclipse, as opposed to our previously created Android projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps needed to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: First we create the project and select **JavaSE-1.6** as the execution environment:![Creating
    the TemperatureConverterJVMTest project](img/3500_10_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pressing **Next >** we can select the **Java Settings** for the project and
    as our intention is to create the tests for the `TemperatureConverter` project
    we should add it as a **Required project on the build path:**![Creating the TemperatureConverterJVMTest
    project](img/3500_10_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we create a new package in this project to keep our tests, named `com.example.aatg.tc.test`.
    In this package we create a new **JUnit Test Case**, named `TemperatureConverterTests`,
    using JUnit version 4, as opposed to the supported JUnit version 3 used in standard
    Android test cases. Select **TemperatureConverter** as the **Class under test:**![Creating
    the TemperatureConverterJVMTest project](img/3500_10_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pressing **Next >** this time we can select the methods to test and the method
    stubs will be generated automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Creating the TemperatureConverterJVMTest project](img/3500_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have the test case template and the method stubs completed. We now need
    to enter the test code we created in previous chapters for `TemperatureConverter`
    in these stubs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippet shows the imports and the definition of the `TemperatureConverterTests`.
    This is almost exactly the same as before but with the sole addition of JUnit
    4 annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this code snippet shows no changes against our previous version of the
    test case but with the sole addition of JUnit 4 annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The code is exactly the same with just a few minor differences. One such difference
    is that we are now annotating the tests with `@Test`, as JUnit 4 finds the test
    methods by this annotation and not by their name. So in this example we are using
    the same names for tests methods as we used before, but strictly speaking we could
    have used something different, for example `shouldRaiseExceptionForLessThanAbsoluteZeroC`
    instead of `testExceptionForLessThanAbsoluteZeroC`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the performance gain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the tests are finished we can run them from Eclipse by selecting the appropriate
    test launcher, **Eclipse JUnit Launcher:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing the performance gain](img/3500_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The distinction is evident. There is no emulator start up, any device communication
    and therefore the speed gain is important. Analyzing the evidence we can find
    out these differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running all tests in my development computer takes 0.005 seconds, with some
    tests taking so little time that they are not even accounted for, and are displayed
    as 0.000 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing the performance gain](img/3500_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Comparing this with the time it took to run the same tests on the emulator
    makes this huge difference evident:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing the performance gain](img/3500_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These same tests took 0.443 seconds to run, almost 100 times more and that's
    a huge difference if you consider hundreds of tests running tens of times a day.
  prefs: []
  type: TYPE_NORMAL
- en: It is also good to notice that other advantages exists beside the speed gain
    and they are the availability of several mock frameworks and code coverage tools.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Android to the picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We intentionally left Android outside our picture. Let's analyze what happens
    if we include a simple Android test. Remember that for these tests to compile
    `android.jar` from the SDK should also be added to the project libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Add this test to a new JUnit test case named `TemperatureConverterActivityUnitTests:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is what we obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.lang.RuntimeException: Stub!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.content.Context.<init>(Context.java:4)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.content.ContextWrapper.<init>(ContextWrapper.java:5)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.app.Application.<init>(Application.java:6)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at com.example.aatg.tc.TemperatureConverterApplication.<init>(TemperatureConverterApplication.java:27)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**…**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that `android.jar` provides only the API, not the implementation.
    All methods throw `java.lang.RuntimeException: Stub!` when used.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to circumvent this limitation to test some classes outside of the
    Android operating system, we should create an `android.jar` that mocks every class.
    However, we will also find problems for subclasses of Android classes like `TemperatureConverterApplication`.
    This would be a daunting task and a significant amount of work, so we should look
    for another solution.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Robolectric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Robolectric** ([http://pivotal.github.com/robolectric/](http://pivotal.github.com/robolectric/))
    is a unit test framework that intercepts the loading of Android classes and rewrites
    the method bodies. Robolectric re-defines Android methods so they return default
    values, like `null, 0`, or `false`, and if provided it forwards method calls to
    shadow objects giving Android behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: A large number of shadow objects are provided, but this is far from complete
    coverage, however it is improving constantly. This should also lead you to treat
    it as an evolving Open Source project, for which you should be ready to contribute
    to make it better, but also to depend on it with caution because you may discover
    that what you need for your tests has not been implemented yet. This is not in
    any way to diminish its promising future.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Robolectric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Robolectric can be installed by downloading the `robolectric-<version>-jar-with-dependencies.jar`
    from the Maven central repository ([http://repo1.maven.org/maven2/com/pivotallabs/robolectric/](http://repo1.maven.org/maven2/com/pivotallabs/robolectric/)).
    By the time of this writing the latest JAR available is `robolectric-0.9.8-jar-with-dependencies.jar`
    and this is what we are going to use in our samples.
  prefs: []
  type: TYPE_NORMAL
- en: Conveniently you can also download the corresponding Javadoc and attach it to
    the library in you project properties so you can access the documentation from
    Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Java project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep our tests organized we are creating a new Java project as we did in
    our previous section. This time we are adding the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`robolectric-<version>-jar-with-dependencies.jar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.jar` from your Android SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maps.jar` also from your Android SDK. Note that this is an optional package
    when you install the SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing some tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will get acquainted with Robolectric by reproducing some of the tests we
    wrote before.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good example can be re-writing the `EditNumber` tests. Let''s create a
    new `EditNumberTests` class, this time in the newly created project, and copy
    the tests from the `EditNumberTests` in `TemperatureConverterTest` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet we defined the package. In this case using `com.example.aatg.tc.test`
    as usual. Also we declare the test runner with the `@RunWith` annotation. Later
    we defined the `mEditNumber` field to hold the reference to the `EditNumber:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet comprises the usual `setup()` and `tearDown()` methods followed
    by the `testPreconditions()` test. In the `setUp()` method we created an `EditNumber`
    with a null context and then we set it as focusable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this last snippet we have the basic tests which are the same as the `EditNumber`
    tests of our previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: We are highlighting the most important changes. The first one is to specify
    the test runner JUnit will delegate the processing of the tests to, by using the
    annotation `@RunWith`. In this case we need to use `RobolectricTestRunner.class`
    as the runner. Then we create an `EditText` using a null `Context` as this is
    a class that cannot be instantiated. Finally, a `DELTA` value is specified in
    `testGetNumber` as `assertEquals` since the floating point number requires it
    in JUnit 4\. Additionally we added the `@Test` annotation to mark the method as
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: The other test methods that existed in the original `EditNumberTests` cannot
    be implemented or simply fail for a variety of reasons. For example, as we mentioned
    before, Robolectric classes return default values, like `null, 0, false`, and
    so on, and this is the case for `Editable.Factory.getInstance()` which returns
    null and causes the test to fail; because there is no other way of creating an
    `Editable` object we are at a dead end.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `InputFilter` that `EditNumber` sets is non functional. It is
    futile to create a test that expects some behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to these shortcomings would be to create `Shadow` classes but
    this requires alteration of the Robolectric source and the creation of `Robolectric.shadowOf()`
    methods. This procedure is described in the documentation that you may follow
    if you are interested in applying this approach to your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Before being able to run your tests you need to create symbolic links for `TemperatureConverter`
    project's `AndroidManifest.xml` and resources which are used by Robolectric.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Having identified these issues we can proceed to run the tests from inside Eclipse
    and they will run in the host's JVM with no need to start or communicate with
    an emulator or device.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been a little more involved than previous ones, with the sole
    intention of facing realistic situations and state-of-the-art Android testing.
  prefs: []
  type: TYPE_NORMAL
- en: We started analyzing the requirements and steps to build Android from source.
    This measure is needed to be able to activate code coverage through EMMA, which
    we did and later on we ran our tests obtaining a detailed code coverage analysis
    report.
  prefs: []
  type: TYPE_NORMAL
- en: We then used this report to improve our tests and we created some to cover areas
    we were not aware that have not been tested. This led us to better tests and in
    some cases improved the design of the project under test.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced Robotium, a very useful tool to ease the creation of test cases
    for our Android applications and we improved some tests with it.
  prefs: []
  type: TYPE_NORMAL
- en: Then we analyzed one of the hottest topics on Android testing as it is testing
    on the development host JVM optimizing and reducing considerably the time needed
    to run the tests, something that is highly desirable when we are applying Test
    Driven Development to our process. Within this scope, we analyzed JUnit 4 and
    Robolectric and created some tests as demonstrations and to get you started on
    these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of this journey through the available methods and tools
    to Android testing. You should now be much better prepared to start applying this
    to your own projects. The results will be visible as soon as you begin to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I hope that you have enjoyed reading this book as much as I did writing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Happy testing!
  prefs: []
  type: TYPE_NORMAL
