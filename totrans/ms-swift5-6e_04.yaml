- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optional Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started using Swift, the concept that I had the most trouble understanding
    was optional types. Coming from an Objective-C, C, Java, and Python background,
    I was able to relate most of Swift's features to how things worked in one of the
    other languages that I knew, but optionals were different. When Swift was first
    announced, there was really nothing like optionals in the other languages that
    I used, so it took a lot of reading to fully understand them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are optional types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need optional types in Swift?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to unwrap an optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is optional binding?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is optional chaining?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we declare variables in Swift, they are by default non-optional, which
    means that they must contain a valid, non-nil value. If we try to set a non-optional
    variable to `nil`, it will result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will throw an error when we attempt to set
    the `message` variable to `nil` because it is a non-optional type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to understand that `nil` in Swift is very different from
    `nil` in Objective-C or other C-based languages. In these languages, `nil` is
    a pointer to a non-existent object; however, in Swift, a `nil` value is the absence
    of a value. Grasping this concept is very important in order to fully understand
    optionals in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: A variable defined as an optional can contain a valid value, or it can indicate
    the absence of a value. We indicate the absence of a value by assigning it a special
    `nil` value. Optionals of any type can be set to `nil`, whereas in Objective-C,
    only objects can be set to `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To really understand the concept behind optionals, let''s look at a line of
    code that defines an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The question mark at the end indicates that the `myString` variable is an optional.
    We read this line of code as saying that the `myString` variable is an optional
    type, which may contain a value of the `string` type or may contain no value.
    How this line is written is very important in understanding how optionals work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionals are a special type in Swift. When we defined the `myString` variable,
    we actually defined it as an optional type. To understand this, let''s look at
    some more code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These two declarations are equivalent. Both lines declare an optional type that
    may contain a`Sstring` type or may lack a value. In Swift, we can think of the
    absence of a value as being set to nil, but always remember that this is different
    than setting something to nil in Objective-C. In this book, when we refer to nil,
    we are referring to how Swift uses nil and not how Objective-C uses nil.
  prefs: []
  type: TYPE_NORMAL
- en: The optional type is an enumeration with two possible values, `None` and `Some(T)`,
    where `T` is the generic associated value of the appropriate type. We will discuss
    generics in *Chapter 11*, *Generics*. If we set the optional to `nil`, it will
    have a value of `None`, and if we set a value, the optional will have a value
    of `Some` with an associated value of the appropriate type. In *Chapter 3*, *Learning
    about Variables, Constants, Strings, and Operators*, we explained that an enumeration
    in Swift might have associated values. Associated values allow us to store additional
    information along with the enumeration's member values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, an optional is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `T` is the type to associate with the optional. The `T` symbol is used
    to define a generic and can be used to represent any type.
  prefs: []
  type: TYPE_NORMAL
- en: The need for optional types in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the burning question: why does Swift need optionals? To understand this
    question, we should examine what problems optionals are designed to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In most languages, it is possible to create a variable without giving it an
    initialized value. For example, in Objective-C, both of these lines of code are
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that the `MyObject` class, written in Objective-C, has the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes the value passed in from the `i` parameter, multiplies it
    by two, and returns the results. Let''s try to call this method using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first thought might be that this code would display `Value: 10`, since
    we are pass athe value of `5` to a method that doubles the value passed in; however,
    this would be incorrect. In reality, this code would display `Value: 0` because
    we did not initialize the `m` object prior to using it.'
  prefs: []
  type: TYPE_NORMAL
- en: When we forget to initialize an object or set a value for a variable, we can
    get unexpected results at runtime, as we just demonstrated. The unexpected results
    can be, at times, very difficult to track down.
  prefs: []
  type: TYPE_NORMAL
- en: 'With optionals, Swift is able to detect problems such as this at compile time
    and alert us before it becomes a runtime issue. If we expect a variable or object
    to always contain a value prior to using it, we will declare the variable as a
    non-optional (this is the default declaration). Then we will receive an error
    if we try to use it prior to initializing it. Let''s look at an example of this.
    The following code would display an error because we are attempting to use a non-optional
    variable prior to initializing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If a variable is declared as an optional, it is good programming practice to
    verify that it contains a valid value before attempting to use it. We should only
    declare a variable as an optional if there is a valid reason for the variable
    to contain no value. This is the reason Swift declares variables as non-optional
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of what optionals are and what types
    of problems they are designed to solve, let's look at how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing to keep in mind is that the type we define in the variable''s declaration
    is actually the associated value in the optional enumeration. The following code
    shows us how we would typically declare an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code declares an optional variable that might contain a string or might
    contain no value. When a variable such as this is declared, by default it is set
    to nil. Now that we have seen how to define an optional, let's look at how we
    can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to using optionals is to always verify that they contain a valid value
    prior to accessing them. The reason for this is if we attempt to use an optional
    value without verifying that it contains a valid value, we may encounter a runtime
    error, causing our application to crash. We use the term unwrapping to refer to
    the process of retrieving a value from an optional. We are going to introduce
    two methods for retrieving the values of an optional; please keep in mind that
    using optional binding is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Forced unwrapping of an optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To unwrap or retrieve the value of an optional, we place an exclamation mark
    (`!`) after the variable name. This is called forced unwrapping. Forced unwrapping,
    in this manner, is very dangerous and should be used only if we are certain that
    the variable contains a non-nil value. Otherwise, if it does contain a nil value,
    we will get a runtime error and the application will crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the exclamation point to unwrap an optional, we are telling the
    compiler that we know the optional contains a value, so go ahead and give it to
    us. Let''s look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will work as we expect it to, where the `test` variable will contain
    the `"test"` string; however, if the line that set the `myString1` optional to
    `test` was removed, we would receive a runtime error when the application is run.
    Note that the compiler will not alert us to an issue because we are using the
    exclamation point to unwrap the optional; therefore, the compiler assumes that
    we know what we are doing and will happily compile the code for us. We should
    verify that the `myString1` optional contains a valid value before unwrapping
    it. The following example is one way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the line that sets the `myString1` optional to `test` were removed,
    we would not receive a runtime error because we only unwrap the `myString1` optional
    if it contains a valid (non-nil) value.
  prefs: []
  type: TYPE_NORMAL
- en: Unwrapping optionals, as we just described, is not optimal, and it is not recommended
    that optionals be unwrapped in this manner. We can combine verification and unwrapping
    in one step, called optional binding.
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optional binding is the recommended way to unwrap an optional. With optional
    binding, we perform a check to see whether the optional contains a valid value
    and, if so, unwrap it into a temporary variable or constant. This is all performed
    in one step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional binding is performed with `if` or `while` conditional statements.
    It takes the following format if we want to put the value of the optional in a
    constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to put the value in a variable, instead of a constant, we can use
    the `var` keyword, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to perform optional binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we define the `myString3` variable as an optional type. If the
    `myString3` optional contains a valid value, the new variable, named `tempvar`,
    is set to that value and is printed to the console. If the `myString3` optional
    does not contain a value, `No value` is printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are able to use optional binding to unwrap multiple optionals within the
    same optional binding line. For example, if we had three optionals named `optional1`,
    `optional2`, and `optional3`, we could use the following code to attempt to unwrap
    all three at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If any of the three optionals are `nil`, the whole optional binding statement
    fails. It is also perfectly acceptable with optional binding to assign the value
    to a variable of the same name. The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is that the temporary variable is scoped only for the conditional
    block and cannot be used outside it. To illustrate the scope of the temporary
    variable, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code would not compile because the `tmp` variable is only valid within
    the conditional block and we are attempting to use it outside the block.
  prefs: []
  type: TYPE_NORMAL
- en: Using optional binding is a lot cleaner and easier than manually verifying that
    the optional has a value and using forced unwrapping to retrieve the value of
    the optional. There are different ways that we can use optional typeswith tuples;,
    let's look at these.
  prefs: []
  type: TYPE_NORMAL
- en: Optional types with tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define a whole tuple as an optional or any of the elements within a
    tuple as an optional. It is especially useful to use optionals with tuples when
    we return a tuple from a function or method. This allows us to return part (or
    all) of the tuple as `nil`. The following example shows how to define a tuple
    as an optional, and also how to define individual elements of a tuple as optional
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines the whole tuple as an optional type. The second line
    defines the second value within the tuple as an optional, while the first value
    is a non-optional.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optional chaining allows us to call properties, methods, and subscripts on
    an optional that might be nil. If any of the chained values return nil, the return
    value will be nil. The following code gives an example of optional chaining using
    a fictitious `car` object. In this example, if either the `car` or `tires` optional
    variables are nil, the `tireSize` variable will be nil, otherwise the `tireSize`
    variable will be equal to the `tireSize` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will look at optional chaining again in *Chapter 8*, *Classes, Structures,
    and Protocols*.
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nil coalescing operator is similar to the ternary operator that we discussed
    in *Chapter 3*, *Learning about Variables, Constants, Strings, and Operators*.
    The ternary operator assigns a value to a variable, based on the evaluation of
    a comparison operator or a Boolean value. The nil coalescing operator attempts
    to unwrap an optional, and if it contains a value, it will return that value,
    or a default value if the optional is nil, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a prototype for the nil coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we demonstrate the `nil` coalescing operator when the optional
    is set to nil and also when it contains a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by initializing our `defaultName` variable to `Jon`.
    We then define two optionals, named `optionalA` and `optionalB`. The `optionalA`
    variable is set to `nil`, while the `optionalB` variable is set to `Buddy`.
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is used in the final two lines. Since the `optionalA`
    variable contains nil, the `nameA` variable will be set to the value of the `defaultName`
    variable, which is `Jon`. The `nameB` variable will be set to the value of the
    `optionalB` variable since it contains a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nil coalescing operator is shorthand for using the ternary operator as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the nil coalescing operator is much cleaner and easier to read
    than the equivalent ternary operator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we described what optionals actually are and how they are defined
    internally in the Swift language. It is important to understand this concept because
    optionals are used a lot in Swift, and knowing how they work internally will help
    you to use them properly. While the concept of optional types, as used in the
    Swift language, might seem a little confusing at first, the more you use them,
    the more they will make sense. One of the biggest advantages of optional types
    is the additional compile-time checks that alert us if we forget to initialize
    non-optionals prior to using them. We will see additional examples of optionals
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to use collections.
  prefs: []
  type: TYPE_NORMAL
