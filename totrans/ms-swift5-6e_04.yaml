- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optional Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started using Swift, the concept that I had the most trouble understanding
    was optional types. Coming from an Objective-C, C, Java, and Python background,
    I was able to relate most of Swift's features to how things worked in one of the
    other languages that I knew, but optionals were different. When Swift was first
    announced, there was really nothing like optionals in the other languages that
    I used, so it took a lot of reading to fully understand them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What are optional types?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need optional types in Swift?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to unwrap an optional
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is optional binding?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is optional chaining?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing optionals
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we declare variables in Swift, they are by default non-optional, which
    means that they must contain a valid, non-nil value. If we try to set a non-optional
    variable to `nil`, it will result in an error.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will throw an error when we attempt to set
    the `message` variable to `nil` because it is a non-optional type:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is very important to understand that `nil` in Swift is very different from
    `nil` in Objective-C or other C-based languages. In these languages, `nil` is
    a pointer to a non-existent object; however, in Swift, a `nil` value is the absence
    of a value. Grasping this concept is very important in order to fully understand
    optionals in Swift.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A variable defined as an optional can contain a valid value, or it can indicate
    the absence of a value. We indicate the absence of a value by assigning it a special
    `nil` value. Optionals of any type can be set to `nil`, whereas in Objective-C,
    only objects can be set to `nil`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'To really understand the concept behind optionals, let''s look at a line of
    code that defines an optional:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The question mark at the end indicates that the `myString` variable is an optional.
    We read this line of code as saying that the `myString` variable is an optional
    type, which may contain a value of the `string` type or may contain no value.
    How this line is written is very important in understanding how optionals work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionals are a special type in Swift. When we defined the `myString` variable,
    we actually defined it as an optional type. To understand this, let''s look at
    some more code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two declarations are equivalent. Both lines declare an optional type that
    may contain a`Sstring` type or may lack a value. In Swift, we can think of the
    absence of a value as being set to nil, but always remember that this is different
    than setting something to nil in Objective-C. In this book, when we refer to nil,
    we are referring to how Swift uses nil and not how Objective-C uses nil.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The optional type is an enumeration with two possible values, `None` and `Some(T)`,
    where `T` is the generic associated value of the appropriate type. We will discuss
    generics in *Chapter 11*, *Generics*. If we set the optional to `nil`, it will
    have a value of `None`, and if we set a value, the optional will have a value
    of `Some` with an associated value of the appropriate type. In *Chapter 3*, *Learning
    about Variables, Constants, Strings, and Operators*, we explained that an enumeration
    in Swift might have associated values. Associated values allow us to store additional
    information along with the enumeration's member values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可选类型是一个有两个可能值的枚举，`None`和`Some(T)`，其中`T`是与可选相关联的泛型值。我们将在*第11章*，*泛型*中讨论泛型。如果我们将可选设置为`nil`，它将具有`None`的值，如果我们设置一个值，可选将具有`Some`的值，并带有相关联的适当类型的值。在*第3章*，*了解变量、常量、字符串和运算符*中，我们解释了Swift中的枚举可能具有关联值。关联值允许我们在枚举成员值中存储额外的信息。
- en: 'Internally, an optional is defined as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，可选类型被定义为如下：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `T` is the type to associate with the optional. The `T` symbol is used
    to define a generic and can be used to represent any type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`T`是与可选相关联的类型。`T`符号用于定义泛型，可以用来表示任何类型。
- en: The need for optional types in Swift
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift中可选类型的需求
- en: 'Now, the burning question: why does Swift need optionals? To understand this
    question, we should examine what problems optionals are designed to solve.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个迫切的问题：为什么Swift需要可选类型？为了理解这个问题，我们应该检查可选类型旨在解决哪些问题。
- en: 'In most languages, it is possible to create a variable without giving it an
    initialized value. For example, in Objective-C, both of these lines of code are
    valid:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数语言中，可以在不提供初始化值的情况下创建一个变量。例如，在Objective-C中，这两行代码都是有效的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s say that the `MyObject` class, written in Objective-C, has the
    following method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设用Objective-C编写的`MyObject`类有以下方法：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This method takes the value passed in from the `i` parameter, multiplies it
    by two, and returns the results. Let''s try to call this method using the following
    code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受从`i`参数传递的值，将其乘以二，并返回结果。让我们尝试使用以下代码调用此方法：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our first thought might be that this code would display `Value: 10`, since
    we are pass athe value of `5` to a method that doubles the value passed in; however,
    this would be incorrect. In reality, this code would display `Value: 0` because
    we did not initialize the `m` object prior to using it.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的第一反应可能认为此代码将显示`Value: 10`，因为我们传递了`5`的值给一个将值加倍的方法；然而，这是不正确的。实际上，此代码将显示`Value:
    0`，因为我们没有在使用之前初始化`m`对象。'
- en: When we forget to initialize an object or set a value for a variable, we can
    get unexpected results at runtime, as we just demonstrated. The unexpected results
    can be, at times, very difficult to track down.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们忘记初始化一个对象或为变量设置值时，我们可能会在运行时得到意外的结果，就像我们刚才演示的那样。有时，这些意外的结果可能非常难以追踪。
- en: 'With optionals, Swift is able to detect problems such as this at compile time
    and alert us before it becomes a runtime issue. If we expect a variable or object
    to always contain a value prior to using it, we will declare the variable as a
    non-optional (this is the default declaration). Then we will receive an error
    if we try to use it prior to initializing it. Let''s look at an example of this.
    The following code would display an error because we are attempting to use a non-optional
    variable prior to initializing it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选类型，Swift能够在编译时检测到此类问题，并在它成为运行时问题之前提醒我们。如果我们期望在使用之前变量或对象始终包含一个值，我们将变量声明为非可选（这是默认声明）。然后，如果我们尝试在使用之前初始化它，我们将收到一个错误。让我们看看这个例子。以下代码将显示一个错误，因为我们试图在使用之前使用一个非可选变量：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If a variable is declared as an optional, it is good programming practice to
    verify that it contains a valid value before attempting to use it. We should only
    declare a variable as an optional if there is a valid reason for the variable
    to contain no value. This is the reason Swift declares variables as non-optional
    by default.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量被声明为可选，在尝试使用它之前验证它是否包含一个有效值是良好的编程实践。我们只应该将变量声明为可选，如果存在一个合理的理由让变量不包含值。这就是Swift默认将变量声明为非可选的原因。
- en: Now that we have a better understanding of what optionals are and what types
    of problems they are designed to solve, let's look at how to use them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对可选类型及其旨在解决的问题有了更好的理解，让我们看看如何使用它们。
- en: Defining an optional
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义可选类型
- en: 'One thing to keep in mind is that the type we define in the variable''s declaration
    is actually the associated value in the optional enumeration. The following code
    shows us how we would typically declare an optional:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code declares an optional variable that might contain a string or might
    contain no value. When a variable such as this is declared, by default it is set
    to nil. Now that we have seen how to define an optional, let's look at how we
    can use it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Using optionals
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to using optionals is to always verify that they contain a valid value
    prior to accessing them. The reason for this is if we attempt to use an optional
    value without verifying that it contains a valid value, we may encounter a runtime
    error, causing our application to crash. We use the term unwrapping to refer to
    the process of retrieving a value from an optional. We are going to introduce
    two methods for retrieving the values of an optional; please keep in mind that
    using optional binding is preferred.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Forced unwrapping of an optional
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To unwrap or retrieve the value of an optional, we place an exclamation mark
    (`!`) after the variable name. This is called forced unwrapping. Forced unwrapping,
    in this manner, is very dangerous and should be used only if we are certain that
    the variable contains a non-nil value. Otherwise, if it does contain a nil value,
    we will get a runtime error and the application will crash.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the exclamation point to unwrap an optional, we are telling the
    compiler that we know the optional contains a value, so go ahead and give it to
    us. Let''s look at how to do this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code will work as we expect it to, where the `test` variable will contain
    the `"test"` string; however, if the line that set the `myString1` optional to
    `test` was removed, we would receive a runtime error when the application is run.
    Note that the compiler will not alert us to an issue because we are using the
    exclamation point to unwrap the optional; therefore, the compiler assumes that
    we know what we are doing and will happily compile the code for us. We should
    verify that the `myString1` optional contains a valid value before unwrapping
    it. The following example is one way to do this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if the line that sets the `myString1` optional to `test` were removed,
    we would not receive a runtime error because we only unwrap the `myString1` optional
    if it contains a valid (non-nil) value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Unwrapping optionals, as we just described, is not optimal, and it is not recommended
    that optionals be unwrapped in this manner. We can combine verification and unwrapping
    in one step, called optional binding.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optional binding is the recommended way to unwrap an optional. With optional
    binding, we perform a check to see whether the optional contains a valid value
    and, if so, unwrap it into a temporary variable or constant. This is all performed
    in one step.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional binding is performed with `if` or `while` conditional statements.
    It takes the following format if we want to put the value of the optional in a
    constant:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定使用`if`或`while`条件语句执行。如果我们想将可选类型的值放入一个常量中，它将采取以下格式：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we need to put the value in a variable, instead of a constant, we can use
    the `var` keyword, as shown in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将值放入变量中，而不是常量，我们可以使用`var`关键字，如下例所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following example shows how to perform optional binding:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何执行可选绑定：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the example, we define the `myString3` variable as an optional type. If the
    `myString3` optional contains a valid value, the new variable, named `tempvar`,
    is set to that value and is printed to the console. If the `myString3` optional
    does not contain a value, `No value` is printed to the console.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将`myString3`变量定义为可选类型。如果`myString3`可选类型包含一个有效值，新变量`tempvar`将被设置为该值并打印到控制台。如果`myString3`可选类型不包含值，则控制台将打印`No
    value`。
- en: 'We are able to use optional binding to unwrap multiple optionals within the
    same optional binding line. For example, if we had three optionals named `optional1`,
    `optional2`, and `optional3`, we could use the following code to attempt to unwrap
    all three at once:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在同一可选绑定行中解包多个可选类型。例如，如果我们有三个名为`optional1`、`optional2`和`optional3`的可选类型，我们可以使用以下代码一次性尝试解包所有三个：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If any of the three optionals are `nil`, the whole optional binding statement
    fails. It is also perfectly acceptable with optional binding to assign the value
    to a variable of the same name. The following code illustrates this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中任何一个可选类型是`nil`，整个可选绑定语句将失败。使用可选绑定将值赋给同名的变量也是完全可以接受的。以下代码说明了这一点：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One thing to note is that the temporary variable is scoped only for the conditional
    block and cannot be used outside it. To illustrate the scope of the temporary
    variable, let''s take a look at the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一点是，临时变量仅限于条件块的作用域，不能在块外使用。为了说明临时变量的作用域，让我们看看以下代码：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code would not compile because the `tmp` variable is only valid within
    the conditional block and we are attempting to use it outside the block.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将无法编译，因为`tmp`变量仅在条件块内有效，而我们试图在块外使用它。
- en: Using optional binding is a lot cleaner and easier than manually verifying that
    the optional has a value and using forced unwrapping to retrieve the value of
    the optional. There are different ways that we can use optional typeswith tuples;,
    let's look at these.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选绑定比手动验证可选类型是否有值并使用强制解包来检索可选类型的值要干净和简单得多。我们可以以不同的方式使用元组中的可选类型，让我们来看看这些。
- en: Optional types with tuples
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组中的可选类型
- en: 'We can define a whole tuple as an optional or any of the elements within a
    tuple as an optional. It is especially useful to use optionals with tuples when
    we return a tuple from a function or method. This allows us to return part (or
    all) of the tuple as `nil`. The following example shows how to define a tuple
    as an optional, and also how to define individual elements of a tuple as optional
    types:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将整个元组定义为可选类型，或者将元组中的任何元素定义为可选类型。当从函数或方法返回元组时，使用可选类型与元组一起特别有用。这允许我们将元组的部分（或全部）作为`nil`返回。以下示例展示了如何将元组定义为可选类型，以及如何将元组的单个元素定义为可选类型：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line defines the whole tuple as an optional type. The second line
    defines the second value within the tuple as an optional, while the first value
    is a non-optional.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义整个元组为一个可选类型。第二行定义元组中的第二个值为可选，而第一个值不是可选的。
- en: Optional chaining
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选链
- en: 'Optional chaining allows us to call properties, methods, and subscripts on
    an optional that might be nil. If any of the chained values return nil, the return
    value will be nil. The following code gives an example of optional chaining using
    a fictitious `car` object. In this example, if either the `car` or `tires` optional
    variables are nil, the `tireSize` variable will be nil, otherwise the `tireSize`
    variable will be equal to the `tireSize` property:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链允许我们在可能为`nil`的可选类型上调用属性、方法和下标。如果链中的任何值返回`nil`，则返回值将为`nil`。以下代码给出了使用虚构的`car`对象进行可选链的示例。在这个例子中，如果`car`或`tires`可选变量中的任何一个为`nil`，则`tireSize`变量将为`nil`，否则`tireSize`变量将等于`tireSize`属性：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will look at optional chaining again in *Chapter 8*, *Classes, Structures,
    and Protocols*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章“类、结构和协议”中再次探讨可选链。
- en: The nil coalescing operator
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空合并运算符
- en: The nil coalescing operator is similar to the ternary operator that we discussed
    in *Chapter 3*, *Learning about Variables, Constants, Strings, and Operators*.
    The ternary operator assigns a value to a variable, based on the evaluation of
    a comparison operator or a Boolean value. The nil coalescing operator attempts
    to unwrap an optional, and if it contains a value, it will return that value,
    or a default value if the optional is nil, as shown in the following code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符与我们在*第3章*，*了解变量、常量、字符串和运算符*中讨论的三元运算符类似。三元运算符根据比较运算符或布尔值的评估给变量赋值。空合并运算符尝试展开一个可选值，如果它包含一个值，它将返回该值，或者在可选值为nil时返回默认值，如下面的代码所示。
- en: 'Let''s look at a prototype for the nil coalescing operator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看空合并运算符的原型：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we demonstrate the `nil` coalescing operator when the optional
    is set to nil and also when it contains a value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们演示了当可选值为nil以及它包含值时如何使用空合并运算符：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we begin by initializing our `defaultName` variable to `Jon`.
    We then define two optionals, named `optionalA` and `optionalB`. The `optionalA`
    variable is set to `nil`, while the `optionalB` variable is set to `Buddy`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先将`defaultName`变量初始化为`Jon`。然后我们定义了两个可选值，分别命名为`optionalA`和`optionalB`。`optionalA`变量被设置为nil，而`optionalB`变量被设置为`Buddy`。
- en: The nil coalescing operator is used in the final two lines. Since the `optionalA`
    variable contains nil, the `nameA` variable will be set to the value of the `defaultName`
    variable, which is `Jon`. The `nameB` variable will be set to the value of the
    `optionalB` variable since it contains a value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符用于最后两行。由于`optionalA`变量包含nil，`nameA`变量将被设置为`defaultName`变量的值，即`Jon`。`nameB`变量将被设置为`optionalB`变量的值，因为它包含一个值。
- en: 'The nil coalescing operator is shorthand for using the ternary operator as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符是以下使用三元运算符的简写：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, the nil coalescing operator is much cleaner and easier to read
    than the equivalent ternary operator.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，空合并运算符比等效的三元运算符更简洁、更容易阅读。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described what optionals actually are and how they are defined
    internally in the Swift language. It is important to understand this concept because
    optionals are used a lot in Swift, and knowing how they work internally will help
    you to use them properly. While the concept of optional types, as used in the
    Swift language, might seem a little confusing at first, the more you use them,
    the more they will make sense. One of the biggest advantages of optional types
    is the additional compile-time checks that alert us if we forget to initialize
    non-optionals prior to using them. We will see additional examples of optionals
    later in this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了可选值实际上是什么以及它们在Swift语言内部是如何定义的。理解这个概念很重要，因为可选值在Swift中使用得很多，了解它们是如何在内部工作的将有助于你正确地使用它们。虽然Swift语言中使用的可选类型的概念一开始可能有些令人困惑，但随着你使用它们的次数越多，它们就会变得更有意义。可选类型的一个最大优点是额外的编译时检查，它会提醒我们在使用之前忘记初始化非可选值。我们将在本书的后面部分看到更多关于可选值的示例。
- en: In the next chapter, we will look at how to use collections.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用集合。
