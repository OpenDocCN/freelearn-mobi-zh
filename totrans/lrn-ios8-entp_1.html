<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with iOS</h1></div></div></div><p>The mobile industry is the fastest growing domain among other IT domains. iOS plays a key role in the mobile industry; nowadays, even the key IT players are incorporating mobility in the enterprise way. This title will help you understand the basics of iOS development and its implementation from the perspective of enterprises.</p><p>To get started with iOS development, we will need the following things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Mac system</li><li class="listitem" style="list-style-type: disc">Xcode</li><li class="listitem" style="list-style-type: disc">The iOS SDK</li></ul></div><p>Basically, iOS development is based on the Objective-C language. Objective-C is an extension of the <a class="indexterm" id="id0"/>C programming language; this includes the <strong>OOP</strong> (<strong>object-oriented programming</strong>) concept and adds small-talk style messaging to C. Xcode is built to help you build great apps for iPad, iPhone, and <a class="indexterm" id="id1"/>Mac. Xcode is an <strong>IDE</strong> (<strong>Integrated Development Environment</strong>) for iOS.</p><p>You can download Xcode from the Apple store as shown in the following screenshot:</p><div><img alt="Getting Started with iOS" src="img/1829OT_01_01.jpg"/><div><p>The Xcode option</p></div></div><p>It is free; after downloading Xcode, it automatically appears in the launch pad. Xcode provides different features such as coding, design, a user interface, and testing for you.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interface and implementation classes</li><li class="listitem" style="list-style-type: disc">Types of methods in iOS</li><li class="listitem" style="list-style-type: disc">Datatypes</li><li class="listitem" style="list-style-type: disc">Arrays</li><li class="listitem" style="list-style-type: disc">Property and synthesize</li><li class="listitem" style="list-style-type: disc">Delegates</li><li class="listitem" style="list-style-type: disc">Building a simple app</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Interface and implementation</h1></div></div></div><p>In Objective-C, there <a class="indexterm" id="id2"/>are two types of files that represent a single class: one <a class="indexterm" id="id3"/>is the <code class="literal">interface</code> file and the other one is the <a class="indexterm" id="id4"/><code class="literal">implementation</code> file. In the <code class="literal">interface</code> file, the declaration of a method and variable is done; in the <code class="literal">implementation</code> file, we define this method and use the declared variable.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Code snippets for interface and implementation</h2></div></div></div><p>The <a class="indexterm" id="id5"/>following is the code snippet for the <code class="literal">interface</code> <a class="indexterm" id="id6"/>class:</p><div><pre class="programlisting">@interface MyClass:NSObject{ 
            // declare class variables here
}
            // class methods and instance methods are declared here
@end</pre></div><p>The <code class="literal">MyClass.h</code> file is an <code class="literal">interface</code> class. <code class="literal">NSObject</code> is a root class of all the classes, and it is a must to import the <code class="literal">NSObject</code> class. The <code class="literal">@end</code> keyword indicates that our interface block is completed.</p><p>The following is our <code class="literal">implementation</code> class named as <code class="literal">MyClass.m</code>:</p><div><pre class="programlisting">@implementation MyClass
                   // class methods are defined here
@end</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Types of methods in iOS</h1></div></div></div><p>The methods that <a class="indexterm" id="id7"/>we declare in the <code class="literal">interface</code> file are defined in the <code class="literal">implementation</code> file. Methods are declared in the following way:</p><div><pre class="programlisting">-(returnType)methodName:(typeName) variable1 :(typeName)variable2;</pre></div><p>There are two methods <a class="indexterm" id="id8"/>in iOS: one is the class method and the other is the instance method. In the class method, we do not have to create an object; we can directly access these methods using their class names. The class method is indicated by the <code class="literal">+</code> symbol. We can find static methods in languages such as Java and C++, and we will find class methods in languages such as Objective-C and Ruby. The difference between the static and class methods is that they have different language concepts.</p><p>The principal differences are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Static methods are shared between all instances (this doesn't exist in Objective-C).</li><li class="listitem" style="list-style-type: disc">The class method is a method on a class. In languages such as Objective-C and Ruby, a class itself is an instance of another class (metaclass). Using + before a method declaration means that the method will be defined on the class. Technically, it's just an instance method on a different object. The syntax for the class method is as follows:<div><pre class="programlisting">+(void)classMethod;</pre></div><p>In the instance method, we have to create an object. We can't access the instance method without creating an object. Memory is allocated for an object. The <a class="indexterm" id="id9"/><code class="literal">alloc</code> keyword is used to allocate <a class="indexterm" id="id10"/>memory. The following syntax is used for the instance method:</p><div><pre class="programlisting">-(void)InstanceMethod;  </pre></div></li></ul></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Creating objects</h2></div></div></div><p>An object is <a class="indexterm" id="id11"/>created in the <code class="literal">implementation</code> file as follows:</p><div><pre class="programlisting">MyClass  *object= [[MyClass alloc]init] ;
[object  InstanceMethod];</pre></div><p>Here, we used the <code class="literal">alloc</code> and <code class="literal">init</code> keywords. The <code class="literal">alloc</code> keyword is used to allocate memory to the object, and the <code class="literal">init</code> keyword is used to initialize that object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Important datatypes</h1></div></div></div><p>Like any other programming language, iOS also has different datatypes such as <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">double</code>, <code class="literal">char</code>, and <code class="literal">id</code>. Datatypes are used to specify the kind of data that is being stored in a variable. There are four important datatypes in iOS:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSString</code>: This <a class="indexterm" id="id12"/>is <a class="indexterm" id="id13"/>used to represent a string</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSInteger</code>: This <a class="indexterm" id="id14"/>is <a class="indexterm" id="id15"/>used to declare an integer</li><li class="listitem" style="list-style-type: disc"><code class="literal">CGFloat</code>: This <a class="indexterm" id="id16"/>is used <a class="indexterm" id="id17"/>to declare float values</li><li class="listitem" style="list-style-type: disc"><code class="literal">BOOL</code>: This <a class="indexterm" id="id18"/>is <a class="indexterm" id="id19"/>used to declare a Boolean (yes or no) value</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Array</h1></div></div></div><a class="indexterm" id="id20"/><p>Array is a collection of homogeneous datatypes with contiguous memory allocation. In iOS, arrays are of two types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSArray</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NSMutableArray</code></li></ul></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>NSArray</h2></div></div></div><p>
<code class="literal">NSArray</code> is an <a class="indexterm" id="id21"/>immutable array. <a class="indexterm" id="id22"/>In Objective-C, by default, arrays are immutable, that is, as the name indicates, it's object can't be changed or removed after the initialization of the array:</p><div><pre class="programlisting">       NSArray *xyz  =  [[NSArray alloc] init];
  Xyz = @[@"Harry", @"Tom", @"jack"];</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>NSMutableArray</h2></div></div></div><p>
<code class="literal">NSMutableArray</code> is a <a class="indexterm" id="id23"/>subclass of <code class="literal">NSArray</code>. This is a modifiable array, and <a class="indexterm" id="id24"/>its object can be removed or modified after the initialization of array:</p><div><pre class="programlisting">        NSMutableArray *xyz = [[NSMutableArray alloc] init];
  Xyz = @[@"Harry", @"Tom", @"jack"];</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>The concept of String is the same as in C. String also has two types: <code class="literal">NSMutableString</code> and <code class="literal">NSString</code>. Consider the following example for the <code class="literal">NSString</code> type:</p><div><pre class="programlisting">NSString *myName = @"Jack";</pre></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Property and Synthesize</h1></div></div></div><p>The properties of <a class="indexterm" id="id25"/>an object are defined to let other objects use or change their state. However, in object-oriented programming, it's not possible to access the internal state of an object directly from outside the class (except public accessors). Instead, accessor methods (getters and setters) are used to interact with the objects. The goal of the <code class="literal">@property</code> is to make it easier to create and configure properties by automatically generating these accessor methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@property</code>: This <a class="indexterm" id="id26"/>method implements the setter/getter methods in our code automatically; we don't have to write the code manually.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@synthesize</code>: This <a class="indexterm" id="id27"/>method synthesizes the properties with the given attributes, and the compiler will generate the setter and getter methods for our variables. However, now we do not use <code class="literal">synthesize</code>; instead of <code class="literal">@synthesize</code>, we use an underscore (<code class="literal">_</code>) or the <code class="literal">self</code> keyword.</li></ul></div><p>Let's understand these methods with a code snippet. This is the interface file:</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
@interface MyClass : NSObject
@property  void  methodname;
@end</pre></div><p>This is the implementation file:</p><div><pre class="programlisting">#import "MyClass.h"
@implementation Class
@synthesize methodname = _methodname; 
@end</pre></div><p>In Objective-C, every object holds a reference count. When an object is created, its reference count increases by one; when it releases the object, the reference count decreases by one. When the reference count reaches zero, it deallocates the memory by itself. The attributes of <code class="literal">@property</code> is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">atomic</code>: By default, every <a class="indexterm" id="id28"/>property is atomic. It will ensure that a whole value is always returned by the getter method or set by the setter method. Only a single thread can access a variable to get or set a value at a time. So, atomic is also thread-safe.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nonatomic</code>: In <code class="literal">nonatomic</code>, there is no guarantee that the value returned from a variable is the <a class="indexterm" id="id29"/>same one that the setter method sets. At the same time, more than one single thread can access a variable at a time.</li><li class="listitem" style="list-style-type: disc"><code class="literal">strong</code>: The <code class="literal">strong</code> <a class="indexterm" id="id30"/>attribute owns the object. The compiler will ensure that any object that we assign to this property will not be destroyed as long as we (or any other object) point to it with a strong reference.</li><li class="listitem" style="list-style-type: disc"><code class="literal">weak</code>: In a <code class="literal">weak</code> <a class="indexterm" id="id31"/>reference, we don't want to have control over the object's lifetime. The object we are referencing weakly only lives on because at least one other object holds a strong reference to it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">retain</code>: This <a class="indexterm" id="id32"/>specifies that <code class="literal">retain</code> should be invoked on the object upon assignment. It takes ownership of an object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assign</code>: This <a class="indexterm" id="id33"/>specifies that the setter uses simple assignment. It uses an attribute of the scalar type, such as <code class="literal">float</code> or <code class="literal">int</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">copy</code>: This copies <a class="indexterm" id="id34"/>an object during assignment and increases the retain count by one.</li></ul></div><p>Consider the following simple example using the attributes:</p><div><pre class="programlisting">   @property (nonatomic, assign) float radius;
       @property (atomic, strong) NSString *name;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Delegates</h1></div></div></div><p>A delegate is a <a class="indexterm" id="id35"/>tool through which one object can communicate with another; in turn, the objects can stay connected to each other. It is a method by which one object can act on behalf of another object. The delegating object keeps a reference to the other object and, at the appropriate time, sends a message to it. The message informs the delegate of an event that the delegating object is about to handle or that is to be handled.</p><p>Consider the following example of how to use a delegate.</p><p>Let's define the <code class="literal">FirstViewController.h</code> interface file as follows:</p><div><pre class="programlisting">#import "SecondViewController.h"

@interface FirstViewController : UIViewController &lt;SecondViewControllerDelegate&gt;
{
    IBOutlet UITextField *userNameTextField;
}

@property (nonatomic, strong) UITextField *userNameTextField;

-(IBAction)goNext:(id)sender;

@end</pre></div><p>Now, let's <a class="indexterm" id="id36"/>define the <code class="literal">FirstViewController.m</code> implementation file:</p><div><pre class="programlisting">#import "FirstViewController.h"

@interface FirstViewController ()

@end

@implementation FirstViewController

@synthesize userNameTextField;


-(void)goNext:(id)sender{

    SecondViewController *secondVC = [[SecondViewController alloc]init];

    secondVC.delegate = self;
    [self.navigationController pushViewController:secondVC animated:YES];   
}

-(void)done:(NSString*)name{

    NSLog(@"BACK in firstVC");
    userNameTextField.text = name;
}

@end</pre></div><p>Next, we will define the <code class="literal">SecondViewController.h</code> interface file as follows:</p><div><pre class="programlisting">#import "FirstViewController.h"

@protocol SecondViewControllerDelegate &lt;NSObject&gt;

-(void)done:(NSString*)someText;

@end
@interface SecondViewController : UIViewController{

    IBOutlet UITextField *someText;
    IBOutlet UIButton *returnButton;
    id delegate;
}

@property (assign, nonatomic) id &lt;SecondViewControllerDelegate&gt; delegate;
@property (strong, nonatomic) UITextField *someText;

-(IBAction)goBack:(id)sender;

@end</pre></div><p>Now, we will <a class="indexterm" id="id37"/>define the <code class="literal">SecondViewController.m</code> implementation file as follows:</p><div><pre class="programlisting">#import "SecondViewController.h"

@interface SecondViewController ()

@end

@implementation SecondViewController

@synthesize someText;
@synthesize delegate = _delegate;

-(void)goBack:(id)sender{


    [self.delegate done:someText.text];

    FirstViewController *firstVC = [[FirstViewController alloc]init];

    [self.navigationController pushViewController:firstVC animated:YES];
}

@end</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Building our first iPhone app</h1></div></div></div><p>Let's make our <a class="indexterm" id="id38"/>first iPhone app by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open Xcode; you will see the following screen. In the panel on the right-hand side, you can see your existing projects. You can open your project directly by selecting from the list of projects; for a new project, on the other hand, select <strong>Create a new Xcode project</strong>.<div><img alt="Building our first iPhone app" src="img/1829OT_01_02.jpg"/></div></li><li class="listitem">There are eight templates provided by Xcode. In the panel on the left-hand side, you can see there are <a class="indexterm" id="id39"/>two options: <strong>iOS</strong> and <strong>OS X</strong>. <strong>iOS</strong> is for Apple touch devices, and <strong>OS X</strong> is for desktop devices. Initially, choose <strong>Single View Application</strong>. Then, click on <strong>NEXT</strong>, as shown in the following screenshot:<div><img alt="Building our first iPhone app" src="img/1829OT_01_03.jpg"/></div></li><li class="listitem">Now, it is time to give <a class="indexterm" id="id40"/>a name to your project and choose <strong>iPhone</strong> from the <strong>Devices</strong> dropdown. Then, click on <strong>Next</strong>. The following screenshot will appear:<div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><div><img alt="Building our first iPhone app" src="img/1829OT_01_04.jpg"/></div></li><li class="listitem">Save your project in the directory of your choice:<div><img alt="Building our first iPhone app" src="img/1829OT_01_05.jpg"/></div></li><li class="listitem">Now, your editor will look like the following screenshot. In the left-hand-side panel, there is a <a class="indexterm" id="id41"/>declaration of classes. Select the storyboard from the left-hand-side panel. Storyboard provides the view to your application.<div><img alt="Building our first iPhone app" src="img/1829OT_01_06.jpg"/></div><p>This is your storyboard. At present, it is an empty view controller. Storyboard has many areas, such as the navigation area, editor area, utility area, and debug area, that are described as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Navigation area</strong>: In this pane, there are various navigators <a class="indexterm" id="id42"/>that we can switch between using the Navigator selector bar. The three navigators that we will use a lot are the Project, Search, and Issue navigators.</li><li class="listitem" style="list-style-type: disc"><strong>Editor area</strong>: The editor area is where we'll probably be spending most of <a class="indexterm" id="id43"/>our time! This is where all the coding happens.</li><li class="listitem" style="list-style-type: disc"><strong>Utility area</strong>: The Xcode utility area comprises two panes: the Inspector pane and the Library pane. The Inspector pane will give us <a class="indexterm" id="id44"/>details about the file. However, when we are looking at the storyboard, the Inspector pane will show us the different attributes that you can modify for a selected element. The Library pane won't be very useful until we look at a storyboard. When we use the Interface Builder part of Xcode, we can drag UI elements from the Library pane onto the editor area to add them to our user interface.</li><li class="listitem" style="list-style-type: disc"><strong>Debug area</strong>: The debug area will show us the console output and the <a class="indexterm" id="id45"/>state of various variables when you run your application.</li></ul></div><p>In the following screenshot, we can see an arrow before the view; this indicates that the view is a starting view of the application. When the application launches, this view will launch first:</p><div><img alt="Building our first iPhone app" src="img/1829OT_01_07.jpg"/></div></li><li class="listitem">On the right-hand side, a lot of components, such as button, label, and text fields, are present (we <a class="indexterm" id="id46"/>will learn about these components in the upcoming chapters). Drag-and-drop a button from the right-hand-side panel as shown in the following screenshot. Rename it by double-clicking on it; give it any name. For example, name it <code class="literal">Hello</code>.<div><img alt="Building our first iPhone app" src="img/1829OT_01_08.jpg"/></div><p>This is all our UI part. Now, let's move on to the coding section.</p></li><li class="listitem">Go to <code class="literal">ViewController.h</code> and write the following method in it. The <code class="literal">.h</code> file is an interface file of our project where we declare the property and method. If we want to declare variables, then they are declared under the braces of the interface; the property and methods are defined outside the braces:<div><pre class="programlisting">@interface ViewController : UIViewController
{
Int x;
}
@property (nonatomic, strong) NSString*recipeName;</pre></div><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Coming back to our program, we have to describe one method, <code class="literal">showMessage</code>, where we describe the <code class="literal">UIAlertview</code> function; this appears as a pop-up window with a message.</p></div></div><p>The following <a class="indexterm" id="id47"/>screenshot shows the editor area with the preceding code snippet:</p><div><img alt="Building our first iPhone app" src="img/1829OT_01_09.jpg"/></div><p>Let's understand the code line by line:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#import &lt;UIKit/UIKit.h&gt;</code>: This is a header file that we import in our code. <code class="literal">UIKit</code> is a framework that contains all the inbuilt library files for the UI part. The <code class="literal">UIKit</code> header file imports all the other header files available in the <code class="literal">UIKit</code> framework; after importing this header file, we don't have to import other <code class="literal">UIHeader</code> files such as <code class="literal">UIViewController.h</code>, <code class="literal">UIView.h</code>, or <code class="literal">UIButton.h</code> manually.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@interface ViewController: UIViewController</code>: This is an interface for the <code class="literal">ViewController.h</code> class. It inherits the <code class="literal">UIViewController</code> class, which is used to handle the flow of our screen or view.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(IBAction)showMessage</code>: This is a method that we created manually. When we want to perform some action on tapping a button, we will use <code class="literal">IBAction</code>. This is a kind of return type in iOS. Here, the name of the method is <code class="literal">showMessage</code> (we can give any name). <code class="literal">IBAction</code> tells the UI Builder that the method can be used as a selector (event receiver).</li><li class="listitem" style="list-style-type: disc"><code class="literal">@end</code>: This <a class="indexterm" id="id48"/>code indicates that our interface part is over.</li></ul></div></li><li class="listitem"> Now, go to <code class="literal">ViewController.m</code> and describe the method that is defined in the <code class="literal">.h</code> file. This is also called an <code class="literal">implementation</code> file. The following screenshot illustrates the code used in the implementation file:<div><img alt="Building our first iPhone app" src="img/1829OT_01_10.jpg"/></div><p>Once again, let's understand the code line by line:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#import "ViewController.h"</code>: This imports our <code class="literal">.h</code> class (interface class).</li><li class="listitem" style="list-style-type: disc"><code class="literal">@implementation ViewController</code>: From this snippet, our implementation of the method starts. The method that we declare in the interface file will be implemented here. It also contains some inbuilt methods such as <code class="literal">–(void)viewDidLoad</code>, <code class="literal">-(void)didRecieveMemoryWarning</code>, and so on. We can code inside these methods as needed. If we choose the <strong>Empty application</strong> template, then these inbuilt methods won't be provided.</li><li class="listitem" style="list-style-type: disc"><code class="literal">UIAlertView</code>: Alert views are the pop-up views or messages that appear over the current view. We can use this by making an object of it. Here, <code class="literal">Alert</code> is an object. <code class="literal">alloc</code> is a keyword use to allocated memory for an object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[Alert show]</code>: This snippet is used to display the pop up over the screen.</li></ul></div><p>Now we have to <a class="indexterm" id="id49"/>connect this button to the method that we declare. Without connecting the button, it won't work. Use the following steps to connect the button.</p></li><li class="listitem">Right-click on the button. A black pop-up window will appear. Select <strong>Touch Up Inside</strong> and connect it to <strong>View Controller</strong>, as shown in the following screenshot. After releasing the mouse, select <strong>showMessage</strong> from the pop up.<div><img alt="Building our first iPhone app" src="img/1829OT_01_11.jpg"/></div></li><li class="listitem">Now, your button is <a class="indexterm" id="id50"/>connected to the <code class="literal">Alert</code> method. This is the time to execute your project. Run your project and click on the <strong>Hello</strong> button. Your output will look like the following screenshot:<div><img alt="Building our first iPhone app" src="img/1829OT_01_12.jpg"/></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we learned the basics of iOS, such as methods, arrays, properties, delegates, and so on. After this chapter, we will also be able to use Xcode, and we can make simple apps using the UI component. In the next chapter, we will learn more about components.</p></div></body></html>