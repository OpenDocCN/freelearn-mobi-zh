<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-51"><em class="italic"><a id="_idTextAnchor055"/>Chapter 3</em>: Understanding Data Presentation on Android</h1>
			<p>In this chapter, we will study the libraries available for presenting data on the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). We will start this chapter by analyzing the lifecycles of activities and fragments (what responsibilities they had in the past and what responsibilities they have now) with the introduction of the <strong class="source-inline">ViewModel</strong> and <strong class="source-inline">Lifecycle</strong> libraries. We will then move on to analyze aspects of how the UI works and look at how the Jetpack Compose library revolutionized building UIs through its declarative approach. Finally, we will look at how we can navigate between different screens that are built in Compose by using the <strong class="source-inline">Navigation</strong> library with the <strong class="source-inline">Compose</strong> extension.</p>
			<p>In this chapter, we will cover the following main topics: </p>
			<ul>
				<li>Analyzing lifecycle-aware components</li>
				<li>Using Jetpack Compose to build UIs</li>
			</ul>
			<p>By the end of the chapter, you will become familiar with how to present data on the UI using ViewModel and Compose.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor056"/>Technical requirements </h1>
			<p>Hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3lmMIOg">https://bit.ly/3lmMIOg</a></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor057"/>Analyzing lifecycle-aware components</h1>
			<p>In this section, we <a id="_idIndexMarker254"/>will analyze the lifecycles of activities and fragments and the potential issues that are caused when working with them. We will also observe how the introduction of ViewModel and LiveData solves these problems.</p>
			<p>When the Android operating system and its development framework were released, activities were the most commonly used components when developing an application, as they represent the entry point of the interaction between an application and a user. As technology in displays and resolutions improved, apps could then present more information and controls that the user could interact with. For developers, this meant that the code required to manage the logic for a single activity increased, especially when dealing with different layouts for landscape and portrait. The introduction of fragments was meant to solve some of these problems. Responsibilities for handling the logic in different parts of the screen could now be divided into different fragments.</p>
			<p>The introduction of fragments, however, didn't solve all of the issues developers were dealing with, mainly because both activities and fragments have their own lifecycles. Dealing with lifecycles created the possibility of apps having context leaks, and the combination of lifecycles and inheritance made both activities and fragments hard to unit test.</p>
			<p>The lifecycle of an activity is as follows: </p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_3.01_B18320.jpg" alt="Figure 3.1 – Activity lifecycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Activity lifecycle</p>
			<p> In <em class="italic">Figure 3.1</em>, we <a id="_idIndexMarker255"/>can see the six most well-known states of an activity:</p>
			<ul>
				<li><em class="italic">CREATED</em>: The activity enters this state when the <strong class="source-inline">onCreate</strong> method is called. This will be called when the system creates the activity.</li>
				<li><em class="italic">STARTED</em>: The activity enters this state when the <strong class="source-inline">onStart</strong> method is called. This will be called when the activity is visible to the user.</li>
				<li><em class="italic">RESUMED</em>: The activity enters this state when the <strong class="source-inline">onResume</strong> method is called. This will be called when the activity is in focus (the user can interact with it).</li>
			</ul>
			<p>The next three states are called when the activity is no longer in focus. This can be caused either by the user closing the activity, putting it in the background, or another component gaining focus:</p>
			<ul>
				<li><em class="italic">PAUSED</em>: The activity enters this state when the <strong class="source-inline">onPause</strong> method is called. This will be called when the activity is visible but no longer in focus.</li>
				<li><em class="italic">STOPPED</em>: The activity enters this state when the <strong class="source-inline">onStop</strong> method is called. This will be called when the activity is no longer visible.</li>
				<li><em class="italic">DESTROYED</em>: The activity enters this state when the <strong class="source-inline">onDestroy</strong> method is called. This will be called when the activity is destroyed by the operating system.</li>
			</ul>
			<p>When we use <a id="_idIndexMarker256"/>activities in our code, dealing with the lifecycle will look something like this:</p>
			<p class="source-code">class MyActivity : Activity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onStart() {</p>
			<p class="source-code">        super.onStart()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onResume() {</p>
			<p class="source-code">        super.onResume()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onPause() {</p>
			<p class="source-code">        super.onPause()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onStop() {</p>
			<p class="source-code">        super.onStop()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onDestroy() {</p>
			<p class="source-code">        super.onDestroy()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We can see here that we need to extend the <strong class="source-inline">Activity</strong> class and, if we want to execute a particular operation in a particular state, we can override the method associated <a id="_idIndexMarker257"/>with the state and invoke the <strong class="source-inline">super</strong> call. This represents the main reason why activities are hard to unit test. The <strong class="source-inline">super</strong> calls would cause our test not only to invoke our code but also the parent class's code. Another reason activities are hard to test is because the system is the one instantiating the class, which means that we cannot use the constructor of the class for injection and must rely on setters to inject mock objects. </p>
			<p>An important distinction should be made between the <em class="italic">DESTROYED</em> state and garbage collection. A <em class="italic">DESTROYED</em> activity doesn't mean it will be garbage collected. A simple definition of what garbage collection means is that garbage collection is the process of deallocating memory that is no longer used. Each created object takes a certain amount of memory. When the garbage collector wants to free memory, it will look at objects that are no longer referenced by other objects. If we want to make sure that objects will be garbage collected, we will need to make sure that other objects that live longer than them will have no reference to the objects we want to be collected. In Android, we want <strong class="bold">context</strong> (such as activity and service) objects, or other objects with lifecycles, to be collected when their <strong class="source-inline">onDestroy</strong> methods are called. This is because they tend to occupy a lot of memory and we will end up with crashes or bugs if we end up invoking methods after <strong class="source-inline">onDestroy</strong> is called. Leaks that prevent context objects from <a id="_idIndexMarker258"/>being <a id="_idIndexMarker259"/>collected are called <strong class="bold">context leaks</strong>. Let's look at a simple example of this:</p>
			<p class="source-code">interface MyListener {</p>
			<p class="source-code">    fun onChange(newText: String)</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">object</strong> MyManager {</p>
			<p class="source-code">    private val listeners = mutableListOf&lt;MyListener&gt;()</p>
			<p class="source-code">    fun addListener(listener: MyListener) {</p>
			<p class="source-code">        listeners.add(listener)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fun performLogic() {</p>
			<p class="source-code">        listeners.forEach {</p>
			<p class="source-code">            it.onChange("newText")</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we have a <strong class="source-inline">MyManager</strong> class in which we collect a list of <strong class="source-inline">MyListener</strong> that will be invoked when <strong class="source-inline">performLogic</strong> is called. Note that the <strong class="source-inline">MyManager</strong> class is defined using the <strong class="source-inline">object</strong> keyword. This will make the <strong class="source-inline">MyManager</strong> class static, which means the instance of the class will live as long as the application process lives. If we want an activity to listen to when the <strong class="source-inline">performLogic</strong> method is called, we will have something like the following:</p>
			<p class="source-code">class MyActivity : Activity(), MyListener {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        MyManager.addListener(this)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onChange(newText: String) {</p>
			<p class="source-code">        myTextView.setText(newText)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">MyListener</strong> is<a id="_idIndexMarker260"/> implemented in <strong class="source-inline">MyActivity</strong>, and when <strong class="source-inline">onChange</strong> is called, <strong class="source-inline">myTextView</strong> will be updated. The context leak occurs here when the activity is destroyed. As <strong class="source-inline">MyActivity</strong> is a <strong class="source-inline">MyListener</strong> and a reference to it is kept in <strong class="source-inline">MyManager</strong>, which lives longer, the garbage collector will not remove the <strong class="source-inline">MyActivity</strong> instance from memory. If <strong class="source-inline">performLogic</strong> is called after <strong class="source-inline">MyActivity</strong> is destroyed, we will get <strong class="source-inline">NullPointerException</strong>, because <strong class="source-inline">myTextView</strong> will be set to null; or, if multiple instances of <strong class="source-inline">MyActivity</strong> leak, it could potentially lead to consuming the entire application's memory. A simple fix for this is to remove the reference to <strong class="source-inline">MyActivity</strong> when it is destroyed: </p>
			<p class="source-code">object MyManager {</p>
			<p class="source-code">    …</p>
			<p class="source-code"><strong class="bold">    fun removeListener(listener: MyListener){</strong></p>
			<p class="source-code"><strong class="bold">        listeners.remove(listener)</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyActivity : Activity(), MyListener {</p>
			<p class="source-code">    …</p>
			<p class="source-code"><strong class="bold">    override fun onDestroy() {</strong></p>
			<p class="source-code"><strong class="bold">        MyManager.removeListener(this)</strong></p>
			<p class="source-code"><strong class="bold">        super.onDestroy()</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>Here, we add a simple <a id="_idIndexMarker261"/>method to remove <strong class="source-inline">MyListener</strong> from the list and invoke it from the <strong class="source-inline">onDestroy</strong> method. </p>
			<p>Working with fragments will lead to the same type of problems as activities. Fragments have their own lifecycle and inherit from a parent <strong class="source-inline">Fragment</strong> class, which makes them vulnerable to context leaks and hard to unit test. </p>
			<p>The lifecycle of a fragment is as follows:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_3.02_B18320.jpg" alt="Figure 3.2 – Fragment lifecycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Fragment lifecycle</p>
			<p>In <em class="italic">Figure 3.2</em>, we can <a id="_idIndexMarker262"/>see that the fragment has similar lifecycle states to the activity. The <strong class="source-inline">onAttach</strong> and <strong class="source-inline">onDetach</strong> callbacks deal with when the fragment is attached to and detached from the activity. <strong class="source-inline">onActivityCreated</strong> is called when the activity completes its own <strong class="source-inline">onCreate</strong> call. The <strong class="source-inline">onCreateView</strong> and <strong class="source-inline">onDestroyView</strong> callbacks deal with inflating and destroying a fragment's views. One of the reasons these callbacks exist is because of the fragment back stack. This is a stack structure in which fragments are kept so that when the users press the <em class="italic">Back</em> button, the current fragment is popped out of the stack and the previous fragment is displayed. When fragments are replaced in the back stack, they aren't fully destroyed; just their views are destroyed to save memory. When they are popped back to be <a id="_idIndexMarker263"/>viewed by the user, they will not be re-created, and <strong class="source-inline">onCreateView</strong> will be called.</p>
			<p>In order to solve the problems caused by dealing with activity and fragment lifecycles, a set of libraries was created that are part of the <strong class="source-inline">androidx.lifecycle</strong> group. The <strong class="source-inline">Lifecycle</strong> class was introduced, which is responsible for keeping the current lifecycle state and handling transitions between lifecycle events. The events and states of the <strong class="source-inline">Lifecycle</strong> class would be as follows:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_3.03_B18320.jpg" alt="Figure 3.3 – Lifecycle states&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Lifecycle states</p>
			<p>In <em class="italic">Figure 3.3</em>, we can <a id="_idIndexMarker264"/>see that the <strong class="source-inline">Lifecycle</strong> class only has four states (<em class="italic">INITIALIZED</em>, <em class="italic">CREATED</em>, <em class="italic">STARTED</em>, and <em class="italic">DESTROYED</em>), and it will deal with six events (<strong class="source-inline">ON_CREATE</strong>, <strong class="source-inline">ON_START</strong>, <strong class="source-inline">ON_RESUME</strong>, <strong class="source-inline">ON_PAUSE</strong>, <strong class="source-inline">ON_STOP</strong>, and <strong class="source-inline">ON_DESTROY</strong>). If we wish for a certain class to be lifecycle-aware, it will need to implement the <strong class="source-inline">LifecycleOwner</strong> interface. Activities and fragments already implement this interface. We can see that for activities, the events match the existing callbacks, but for fragments, some changes are required to match these new events. The <strong class="source-inline">onAttach</strong>, <strong class="source-inline">onDetach</strong>, and <strong class="source-inline">onActivityCreated</strong> methods are deprecated, so they shouldn't be used with regard to the new <strong class="source-inline">Lifecycle</strong> library. The other change made for fragments is the introduction of a <strong class="source-inline">viewLifecycleObserver</strong> instance variable, which is used to handle the lifecycle between <strong class="source-inline">onCreateView</strong> and <strong class="source-inline">onDestroyView</strong>. This observer should be used when registering for lifecycle-aware components and you wish to update the UI.</p>
			<p>In Android, when a configuration change (device rotation and language change, for example) occurs, then activities and fragments are re-created (the current instance is destroyed and a new instance will be created). This typically causes problems when these configuration changes occur while data is loaded or when we want to restore the previously loaded data. The <strong class="source-inline">ViewModel</strong> class is meant to solve this problem, along with the issue of testability of activities and fragments. A ViewModel will live until the activity or <a id="_idIndexMarker265"/>fragment it is connected to is destroyed and not re-created. The ViewModel comes with an <strong class="source-inline">onCleared</strong> method, which can be overwritten to clear any subscriptions to any pending operations.</p>
			<p>ViewModels are often paired with a class called <strong class="source-inline">LiveData</strong>. This is a lifecycle-aware component that observes and emits data. The combination of the two classes eliminates the risks of context leaks, as <strong class="source-inline">LiveData</strong> will only emit data when the observer is in a <em class="italic">STARTED</em> or <em class="italic">RESUMED</em> state. An additional benefit is that it will keep the last data held; so, in the case of a configuration change, the last data kept in <strong class="source-inline">LiveData</strong> will be re-emitted. This benefit allows activities and fragments to observe the changes and restore the UI to the way it was before they were re-created. In Jetpack Compose, <strong class="source-inline">LiveData</strong> isn't necessary due to Compose's own set of state handling classes.</p>
			<p>To use <strong class="source-inline">ViewModel</strong> and <strong class="source-inline">LiveData</strong>, you will need the following libraries to be added to <strong class="source-inline">build.gradle</strong>:</p>
			<p class="source-code">implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0"</p>
			<p class="source-code">implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.4.0"</p>
			<p>For integration with Jetpack Compose we will need the following:</p>
			<p class="source-code">implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0"</p>
			<p class="source-code">implementation "androidx.compose.runtime:runtime-livedata:2.4.0 "</p>
			<p>An example of a <strong class="source-inline">ViewModel</strong> and <strong class="source-inline">LiveData</strong> implementation will look something like this:</p>
			<p class="source-code">class MyViewModel : ViewModel() {</p>
			<p class="source-code">    private val _myLiveData = MutableLiveData("")</p>
			<p class="source-code">    val myLiveData: LiveData&lt;String&gt; = _myLiveData</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        _myLiveData.value = "My new value"</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding <a id="_idIndexMarker266"/>example, we extend the <strong class="source-inline">ViewModel</strong> class and define two <strong class="source-inline">LiveData</strong> instance variables. The <strong class="source-inline">_myLiveData</strong> variable is defined as <strong class="source-inline">MutableLiveData</strong> and is set to private. This is to prevent other objects from changing the values of <strong class="source-inline">LiveData</strong>. The <strong class="source-inline">myLiveData</strong> variable is public and can be used by <strong class="source-inline">Lifecycle</strong> owners to observe changes on <strong class="source-inline">LiveData</strong>. </p>
			<p>To obtain the instance of a ViewModel in an activity or fragment, we can use the following:</p>
			<p class="source-code">class MainActivity : AppCompatActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        …</p>
			<p class="source-code">        <strong class="bold">val myViewModel : MyViewModel by viewModels()</strong></p>
			<p class="source-code">        …</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, the <strong class="source-inline">viewModels</strong> method will retrieve the instance of <strong class="source-inline">MyViewModel</strong>. The method provides the ability to pass along a <strong class="source-inline">ViewModelProvider.Factory</strong> object. This is useful in situations where we want to inject various objects in our ViewModel. This will look something like this:</p>
			<p class="source-code">        val myViewModel : MyViewModel by viewModels {</p>
			<p class="source-code">            object : ViewModelProvider.Factory {</p>
			<p class="source-code">                override fun &lt;T : ViewModel&gt; </p>
			<p class="source-code">                    create(modelClass: Class&lt;T&gt;): T {</p>
			<p class="source-code">                    return MyViewModel() as T</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p>If we want to<a id="_idIndexMarker267"/> observe the changes on <strong class="source-inline">LiveData</strong>, we would need to do something like this:</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        …</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        val myViewModel: MyViewModel by viewModels()</p>
			<p class="source-code">        myViewModel.myLiveData.observe(this) { text -&gt;</p>
			<p class="source-code">            myTextView.text = text</p>
			<p class="source-code">        }</p>
			<p class="source-code">        …</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we invoke the <strong class="source-inline">observe</strong> method, where we pass the activity as <strong class="source-inline">LifecycleOwner</strong> and pass a Lambda as <strong class="source-inline">Observer</strong>, which will be invoked when <strong class="source-inline">LiveData</strong> changes its value.</p>
			<p>If we want to use <strong class="source-inline">ViewModel</strong> with <strong class="source-inline">LiveData</strong> in Jetpack Compose, we must do the following:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MyScreen(<strong class="bold">viewModel: MyViewModel = viewModel()</strong>) {</p>
			<p class="source-code">    <strong class="bold">viewModel.myLiveData.observeAsState()</strong>.value?.let {</p>
			<p class="source-code">        MyComposable(it)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MyComposable(text: String){</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>Here, we are <a id="_idIndexMarker268"/>using the <strong class="source-inline">viewModel</strong> method to obtain the <strong class="source-inline">MyViewModel</strong> instance. This method also offers the possibility of passing a <strong class="source-inline">ViewModelProvider.Factory</strong> instance, such as the previous <strong class="source-inline">viewModel</strong> method. The <strong class="source-inline">observeAsState</strong> extension method will observe changes on <strong class="source-inline">LiveData</strong> and convert them into a Compose <strong class="source-inline">State</strong> object.</p>
			<p>In this section, we have discussed how lifecycles work in activities and fragments and the problems developers have when dealing with them. We have analyzed how the lifecycle-aware components (such as ViewModel and LiveData) solved these problems. The <strong class="source-inline">ViewModel</strong> class itself <a id="_idIndexMarker269"/>represents an implementation of the <strong class="bold">Model-View ViewModel</strong> (<strong class="bold">MVVM</strong>) pattern, which will be discussed in a future chapter. In the next section, we will look at an exercise in which we will use both ViewModel and LiveData and combine them with Kotlin flows.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor058"/>Exercise 3.1 – Using ViewModel and LiveData</h2>
			<p>Modify <em class="italic">Exercise 2.5</em> from <a href="B18320_02_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Deep Diving into Data Sources</em>, so that the state <a id="_idIndexMarker270"/>of the <a id="_idIndexMarker271"/>UI is<a id="_idIndexMarker272"/> kept in a <strong class="source-inline">LiveData</strong> object <a id="_idIndexMarker273"/>inside <strong class="source-inline">MainViewModel</strong>, instead of using the Compose <strong class="source-inline">State</strong> object, and display <strong class="source-inline">"Total request count: x"</strong>, where <strong class="source-inline">x</strong> is the number of requests at the top of the list.</p>
			<p>To complete the exercise, you will need to build the following:</p>
			<ul>
				<li>Add the specified text in <strong class="source-inline">strings.xml</strong>.</li>
				<li>Create a <strong class="source-inline">MainTextFormatter</strong> class that will have one method that will return the <strong class="source-inline">"Total request count: x"</strong> text.</li>
				<li>Add a dependency to <strong class="source-inline">MainTextFormatter</strong> in <strong class="source-inline">MainViewModel</strong>, and pass the formatted text as a value for the <strong class="source-inline">UiState.count</strong> object.</li>
				<li>Remove <strong class="source-inline">resultState</strong> and replace it with a <strong class="source-inline">LiveData</strong> object.</li>
				<li>Update the <strong class="source-inline">@Composable</strong> functions to use <strong class="source-inline">LiveData</strong>.</li>
			</ul>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li>Add the <strong class="source-inline">LiveData</strong> extension library for Jetpack Compose to <strong class="source-inline">app/build.gradle</strong>:<p class="source-code">    implementation "androidx.compose.runtime:runtime-livedata:$compose_version"</p></li>
				<li>Add the <strong class="source-inline">"Total request count"</strong> text in <strong class="source-inline">strings.xml</strong>:<p class="source-code">    &lt;string name="total_request_count"&gt;Total request count: %d&lt;/string&gt;</p></li>
				<li>Create the <strong class="source-inline">MainTextFormatter</strong> class as follows:<p class="source-code">class MainTextFormatter(private val </p><p class="source-code">    applicationContext: Context) {</p><p class="source-code">    fun getCounterText(count: Int) =</p><p class="source-code">        applicationContext.getString(R.string.total_request_co</p><p class="source-code">    unt, count)</p><p class="source-code">}</p></li>
			</ol>
			<p>The reason we created this class is to prevent possible context leaks by having a <strong class="source-inline">Context</strong> object inside the <strong class="source-inline">MainViewModel</strong> class. Here, we have a method that will take a count as a parameter and return the required text.</p>
			<ol>
				<li value="4">Inject <strong class="source-inline">MainTextFormatter</strong> in <strong class="source-inline">MainViewModel</strong> and use the formatted text <a id="_idIndexMarker274"/>as <a id="_idIndexMarker275"/>a <a id="_idIndexMarker276"/>value <a id="_idIndexMarker277"/>for the <strong class="source-inline">UiState.count</strong> object:<p class="source-code">class MainViewModel(</p><p class="source-code">    …</p><p class="source-code">    <strong class="bold">private val mainTextFormatter: MainTextFormatter</strong></p><p class="source-code">) : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    init {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">                …</p><p class="source-code">                .flatMapConcat { users -&gt;</p><p class="source-code">                    appDataStore.savedCount.map { </p><p class="source-code">                        count -&gt;</p><p class="source-code">                        UiState(</p><p class="source-code">                            users,</p><p class="source-code">                           <strong class="bold">mainTextFormatter.getCounterText(count)</strong></p><p class="source-code">                        )</p><p class="source-code">                    }</p><p class="source-code">                }</p><p class="source-code">                …</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, create<a id="_idIndexMarker278"/> the instance<a id="_idIndexMarker279"/> of the <strong class="source-inline">MainTextFormatter</strong> class<a id="_idIndexMarker280"/> in<a id="_idIndexMarker281"/> the <strong class="source-inline">MyApplication</strong> class:<p class="source-code">class MyApplication : Application() {</p><p class="source-code">    companion object {</p><p class="source-code">        …</p><p class="source-code">        <strong class="bold">lateinit var mainTextFormatter: </strong></p><p class="source-code"><strong class="bold">            MainTextFormatter</strong></p><p class="source-code">    }</p><p class="source-code">    override fun onCreate() {</p><p class="source-code">        super.onCreate()</p><p class="source-code">        …</p><p class="source-code">        <strong class="bold">mainTextFormatter = MainTextFormatter(this)</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, update <strong class="source-inline">MainViewModelFactory</strong> to use <strong class="source-inline">MainTextFormatter</strong>, which <a id="_idIndexMarker282"/>was <a id="_idIndexMarker283"/>just<a id="_idIndexMarker284"/> created, and pass<a id="_idIndexMarker285"/> it into <strong class="source-inline">MainViewModel</strong>:<p class="source-code">class MainViewModelFactory : ViewModelProvider.Factory {</p><p class="source-code">    override fun &lt;T : ViewModel&gt; create(modelClass: </p><p class="source-code">        Class&lt;T&gt;): T =</p><p class="source-code">        MainViewModel(</p><p class="source-code">            MyApplication.userService,</p><p class="source-code">            MyApplication.userDao,</p><p class="source-code">            MyApplication.appDataStore,</p><p class="source-code">            MyApplication.mainTextFormatter</p><p class="source-code">        ) as T</p><p class="source-code">}</p></li>
				<li>Next, add <strong class="source-inline">LiveData</strong> to <strong class="source-inline">MainViewModel</strong>:<p class="source-code">class MainViewModel(</p><p class="source-code">    …</p><p class="source-code">) : ViewModel() {</p><p class="source-code">    <strong class="bold">private val _uiStateLiveData = </strong></p><p class="source-code"><strong class="bold">        MutableLiveData(UiState())</strong></p><p class="source-code">    <strong class="bold">val uiStateLiveData: LiveData&lt;UiState&gt; = </strong></p><p class="source-code"><strong class="bold">        _uiStateLiveData</strong></p><p class="source-code">    init {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">                …</p><p class="source-code">                .collect {</p><p class="source-code">                    <strong class="bold">_uiStateLiveData.value = it</strong></p><p class="source-code">                }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have defined the two <strong class="source-inline">LiveData</strong> variables, one to update the value and the <a id="_idIndexMarker286"/>other <a id="_idIndexMarker287"/>to be observed, and in<a id="_idIndexMarker288"/> the <strong class="source-inline">collect</strong> method, we<a id="_idIndexMarker289"/> update the value of <strong class="source-inline">LiveData</strong>.</p>
			<ol>
				<li value="8">In <strong class="source-inline">MainActivity</strong>, update the <strong class="source-inline">@Composable</strong> functions to use <strong class="source-inline">LiveData</strong>:<p class="source-code">…</p><p class="source-code">@Composable</p><p class="source-code">fun Screen(viewModel: MainViewModel = viewModel(factory = MainViewModelFactory())) {</p><p class="source-code"><strong class="bold">    viewModel.uiStateLiveData.observeAsState().value?.let {</strong></p><p class="source-code"><strong class="bold">        UserList(uiState = it)</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p><p class="source-code">…</p></li>
			</ol>
			<p>Here, we call the <strong class="source-inline">observeAsState</strong> extension method on <strong class="source-inline">LiveData</strong> from <strong class="source-inline">MainViewModel</strong>, and then call the <strong class="source-inline">UserList</strong> method, which will redraw the UI for each new value.</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_3.04_B18320.jpg" alt="Figure 3.4 – Output of Exercise 3.1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Output of Exercise 3.1</p>
			<p>If we run <a id="_idIndexMarker290"/>the<a id="_idIndexMarker291"/> application, we <a id="_idIndexMarker292"/>will <a id="_idIndexMarker293"/>see the same list of users, and at the top, we will see <strong class="source-inline">"Total request count: x"</strong> instead of just the <strong class="source-inline">x</strong> character that was there before, as shown in <em class="italic">Figure 3.4</em>. In this exercise, we used Jetpack Compose for rendering the UI. In the section that follows, we will analyze how Android <a id="_idIndexMarker294"/>handles UIs and go more in-depth into the Jetpack Compose framework.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor059"/>Using Jetpack Compose to build UIs</h1>
			<p>In this <a id="_idIndexMarker295"/>section, we<a id="_idIndexMarker296"/> will analyze how to build UIs for Android applications using the <strong class="source-inline">View</strong> hierarchy and look at the implications this has for applications. We will then look at how Jetpack Compose simplifies and changes how UIs are built and how we can use Compose to create UIs. We will be looking at Jetpack Compose with the view of how we can integrate it with other libraries and how to build a simple UI. For more information on how to build more complex UIs, you can refer to the official documentation found here: <a href="https://developer.android.com/jetpack/compose">https://developer.android.com/jetpack/compose</a>.</p>
			<p>The way Android deals with UIs is through the <strong class="source-inline">View</strong> hierarchy. The subclasses of <strong class="source-inline">View</strong> deal with specific UI components that the user can interact with. The hierarchy looks similar to the following diagram:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_3.05_B18320.jpg" alt="Figure 3.5 – View hierarchy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – View hierarchy</p>
			<p>The <strong class="source-inline">TextView</strong> class deals with displaying text on the screen, <strong class="source-inline">EditText</strong> deals with handling text inputted by the user, and <strong class="source-inline">Button</strong> deals with rendering buttons on the screen. A specialized subclass of <strong class="source-inline">View</strong> is the <strong class="source-inline">ViewGroup</strong> class. This represents the base class for various layout classes that are responsible for how the views are grouped and arranged on the screen. Here, we find classes such as <strong class="source-inline">LinearLayout</strong> (which groups views one after the other either vertically or horizontally), <strong class="source-inline">RelativeLayout</strong> (which groups the views relative to the parent or to each other), or more recently, <strong class="source-inline">ConstraintLayout</strong>, which offers various ways to position views however we desire without creating many nested layouts (because it was bad for performance), which is why it became commonly used. When it comes to dealing with displaying lists of items of unknown lengths, objects such as <strong class="source-inline">ListView</strong> and <strong class="source-inline">RecyclerView</strong> are used. Both require creating adapters that will be responsible for pairing an object from a list with an associated <strong class="source-inline">View</strong> to render a row in the list in the UI. </p>
			<p>Using <strong class="source-inline">ListViews</strong> is <a id="_idIndexMarker297"/>prone <a id="_idIndexMarker298"/>to inefficiencies caused when scrolling where views are recreated for each new row, so in a long list of items, a lot of views would be created and then garbage collected. To solve this, developers had to implement a pattern called a <strong class="bold">ViewHolder</strong>, which<a id="_idIndexMarker299"/> is responsible for keeping references to the views created for each row and re-using them for new rows when the user scrolls away. <strong class="source-inline">RecyclerView</strong> addresses this issue so the adapter <strong class="source-inline">RecyclerView</strong> uses requires <strong class="source-inline">ViewHolder</strong>. This means that if a user views a list of 100 items and 10 are visible on the screen, for the 10 that are visible on the screen there would be 10 views to represent each row. When the user scrolls down, the 10 views that were created at the beginning would then display the items for the currently visible items. Developers can also create custom views by extending any of the existing <strong class="source-inline">View</strong> classes. This is useful when certain UI components have to be re-used in different activities, fragments, or other custom views.</p>
			<p>To display these views to the user, we would need to use activities and fragments. For activities, this would require invoking the <strong class="source-inline">setContentView</strong> method in the <strong class="source-inline">onCreate</strong> method, and in fragments, we would need to return a <strong class="source-inline">View</strong> object in the <strong class="source-inline">onCreateView</strong> method. We have the possibility of creating the entire layout for an activity or fragment in Java or Kotlin, but this would lead to a lot of code being written. This, and the fact that we can have different layouts for different screen sizes or device rotation, led to <a id="_idIndexMarker300"/>using the <strong class="source-inline">res/layout</strong> folder, in which we can specify how a layout might look. An example of how this might look is as follows:</p>
			<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p>
			<p class="source-code">&lt;androidx.constraintlayout.widget.ConstraintLayout</p>
			<p class="source-code">    xmlns:android="http://schemas.android.com/apk/res/android"</p>
			<p class="source-code">    xmlns:app="http://schemas.android.com/apk/res-auto"</p>
			<p class="source-code">    android:layout_width="match_parent"</p>
			<p class="source-code">    android:layout_height="match_parent"&gt;</p>
			<p class="source-code">    &lt;TextView</p>
			<p class="source-code">        android:id="@+id/text_view"</p>
			<p class="source-code">        android:layout_width="wrap_content"</p>
			<p class="source-code">        android:layout_height="wrap_content"</p>
			<p class="source-code">        android:text="Hello World"</p>
			<p class="source-code">        app:layout_constraintStart_toStartOf="parent"</p>
			<p class="source-code">        app:layout_constraintTop_toTopOf="parent" /&gt;</p>
			<p class="source-code">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</p>
			<p>In the<a id="_idIndexMarker301"/> preceding<a id="_idIndexMarker302"/> example, we define <strong class="source-inline">ConstraintLayout</strong>, which contains only <strong class="source-inline">TextView</strong> that displays a <strong class="source-inline">"Hello World"</strong> text. To obtain a reference to <strong class="source-inline">TextView</strong> to allow us to change the text because of an action or data being loaded, we would need to use the <strong class="source-inline">findViewById</strong> method from either the <strong class="source-inline">Activity</strong> class or the <strong class="source-inline">View</strong> class. This would look something like the following:</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        setContentView(R.layout.activity_main)</p>
			<p class="source-code">        val textView = </p>
			<p class="source-code">            findViewById&lt;TextView&gt;(R.id.text_view)</p>
			<p class="source-code">        textView.text = "Hello new world"</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This approach would lead to possible crashes within an application. Developers would need to make sure that when a layout was set for <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> and <strong class="source-inline">findViewById</strong> was used, then the view was added to the <strong class="source-inline">layout</strong> file. With the introduction of Kotlin, this was initially addressed through the Kotlin Synthetics framework, which generated extensions for the declared views in a layout. Kotlin Synthetics would generate an extension for a View's <strong class="source-inline">android:id</strong> XML tag, which would be accessible in the code. Later, this was replaced with <strong class="source-inline">ViewBinding</strong>. When <strong class="source-inline">ViewBinding</strong> is used in a project, a class is generated for each layout that will hold references to all the views in the layout, eliminating potential crashes related to <strong class="source-inline">findViewById</strong>. All these approaches with regard to creating your UI are defined as <strong class="bold">imperative</strong> because<a id="_idIndexMarker303"/> we need to specify the views that our interface uses and control how we update the views when data is changed. </p>
			<p>An <a id="_idIndexMarker304"/>alternative<a id="_idIndexMarker305"/> approach to this <a id="_idIndexMarker306"/>is the <strong class="bold">declarative</strong> way of creating the UI. This concept allows us to describe what we want to show on the UI and the framework by using the appropriate views based on the description we provide. The notions of <strong class="bold">state</strong> are introduced here, where the UIs are redrawn when states change, rather than updating the existing views. In Android, we can use Jetpack Compose to create UIs in a declarative way. We no longer have to deal with the <strong class="source-inline">View</strong> hierarchy and instead use <strong class="source-inline">@Composable</strong> functions, in which we specify what we want to display on the screen without thinking of how we need to display it, and we can also create the UI using Kotlin using less code than we would normally. In Compose, the <strong class="source-inline">Hello World</strong> example would look something like the following code:</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        setContent {</p>
			<p class="source-code">            Surface {</p>
			<p class="source-code">                HelloWorld()</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun HelloWorld() {</p>
			<p class="source-code">    Text(text = "Hello World")</p>
			<p class="source-code">}</p>
			<p>If we want to update the text because of a change in data, we will need to use <strong class="source-inline">State</strong> objects from the <strong class="source-inline">Compose</strong> library. Compose will observe these states and, when the values are changed, Compose<a id="_idIndexMarker307"/> will redraw the UI associated <a id="_idIndexMarker308"/>with that state. An example of this is as follows:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun HelloWorld() {</p>
			<p class="source-code">    val text = remember { mutableStateOf("Hello World") }</p>
			<p class="source-code">    ShowText(text = text.value) {</p>
			<p class="source-code">        text.value = text.value + "0"</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ShowText(text: String, onClick: () -&gt; Unit) {</p>
			<p class="source-code">    ClickableText(</p>
			<p class="source-code">        text = AnnotatedString(text = text),</p>
			<p class="source-code">        onClick = {</p>
			<p class="source-code">            onClick()</p>
			<p class="source-code">        })</p>
			<p class="source-code">}</p>
			<p>In this example, when the text is clicked, the <strong class="source-inline">0</strong> character is appended to the text and the UI is updated. This is because of the use of <strong class="source-inline">mutableStateOf</strong>. The <strong class="source-inline">remember</strong> method is needed because this state is kept inside a <strong class="source-inline">@Composable</strong> function, and it is used to keep the state intact while recomposition happens (the UI is redrawn). To make the text clickable, we needed to change from <strong class="source-inline">Text</strong> to <strong class="source-inline">ClickableText</strong>. The reason we are using two <strong class="source-inline">@Composable</strong> functions is that we want to keep the <strong class="source-inline">@Composable</strong> functions as re-usable as possible. This is <a id="_idIndexMarker309"/>called <strong class="bold">state hoisting</strong>, where we separate the stateful (<strong class="source-inline">HelloWorld</strong>) components from the stateless components (<strong class="source-inline">ShowText</strong>).</p>
			<p>When it<a id="_idIndexMarker310"/> comes to <a id="_idIndexMarker311"/>rendering lists of items, Compose offers a simple way of rendering them in the form of <strong class="source-inline">Column</strong> (for when the length of the list is known and short), and <strong class="source-inline">LazyColumn</strong> (when the list of items is unknown and could potentially be long). An example of this is from <em class="italic">Exercise 3.1</em>:</p>
			<p class="source-code">LazyColumn(modifier = Modifier.padding(16.dp)) {</p>
			<p class="source-code">        item(uiState.count) {</p>
			<p class="source-code">            Column(modifier = Modifier.padding(16.dp)) {</p>
			<p class="source-code">                Text(text = uiState.count)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        items(uiState.userList) {</p>
			<p class="source-code">            Column(modifier = Modifier.padding(16.dp)) {</p>
			<p class="source-code">                Text(text = it.name)</p>
			<p class="source-code">                Text(text = it.username)</p>
			<p class="source-code">                Text(text = it.email)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>Here, we display a header at the top of the item list, and we use another column to set the padding for the row; then, we display the entire list of items with the use of the <strong class="source-inline">items</strong> function, and for each row, we set the padding and display a group with three texts. </p>
			<p>If we want to display<a id="_idIndexMarker312"/> input<a id="_idIndexMarker313"/> fields and buttons, then we can look at how we implemented the UI in <em class="italic">Exercise 2.1</em>, from <a href="B18320_02_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Deep Diving into Data Sources</em>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Calculator(</p>
			<p class="source-code">    a: String, onAChanged: (String) -&gt; Unit,</p>
			<p class="source-code">    b: String, onBChanged: (String) -&gt; Unit,</p>
			<p class="source-code">    result: String,</p>
			<p class="source-code">    onButtonClick: () -&gt; Unit</p>
			<p class="source-code">) {</p>
			<p class="source-code">    Column(modifier = Modifier.padding(16.dp)) {</p>
			<p class="source-code">        OutlinedTextField(</p>
			<p class="source-code">            value = a,</p>
			<p class="source-code">            onValueChange = onAChanged,</p>
			<p class="source-code">            keyboardOptions = KeyboardOptions(keyboardType </p>
			<p class="source-code">                = KeyboardType.Number),</p>
			<p class="source-code">            label = { Text("a") }</p>
			<p class="source-code">        )</p>
			<p class="source-code">        OutlinedTextField(</p>
			<p class="source-code">            value = b,</p>
			<p class="source-code">            onValueChange = onBChanged,</p>
			<p class="source-code">            keyboardOptions = KeyboardOptions(keyboardType </p>
			<p class="source-code">                = KeyboardType.Number),</p>
			<p class="source-code">            label = { Text("b") }</p>
			<p class="source-code">        )</p>
			<p class="source-code">        Text(text = result)</p>
			<p class="source-code">        Button(onClick = onButtonClick) {</p>
			<p class="source-code">            Text(text = "Calculate")</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we used <strong class="source-inline">OutlinedTextField</strong> to render the equivalent of <strong class="source-inline">TextInputLayout</strong>. We could have used <strong class="source-inline">TextField</strong> if we wanted the equivalent of a simple <strong class="source-inline">EditText</strong>. For displaying a button, we can use the <strong class="source-inline">Button</strong> method, which uses <strong class="source-inline">Text</strong> for rendering <a id="_idIndexMarker314"/>the<a id="_idIndexMarker315"/> text on the button. </p>
			<p>Compose also has integrations with other libraries, such as <strong class="source-inline">ViewModel</strong> and <strong class="source-inline">LiveData</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Screen(viewModel: MainViewModel = viewModel(factory = MainViewModelFactory())) {</p>
			<p class="source-code">    viewModel.uiStateLiveData.observeAsState().value?.let {</p>
			<p class="source-code">        UserList(uiState = it)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we can pass <strong class="source-inline">ViewModel</strong> as a parameter in our <strong class="source-inline">Composable</strong> function and use the <strong class="source-inline">observeAsState</strong> function to convert <strong class="source-inline">LiveData</strong> into a <strong class="source-inline">State</strong> object, which will then be observed by Compose to redraw the UI. Compose also supports integration with the <strong class="source-inline">Hilt</strong> library. When Hilt is added to a project, then there is no need to specify <strong class="source-inline">Factory</strong> for the ViewModel. </p>
			<p>Another important feature of Compose is how it deals with navigation between different screens. The Compose navigation is built upon the <strong class="source-inline">androidx.navigation</strong> library. This allows Compose to use the <strong class="source-inline">NavHost</strong> and <strong class="source-inline">NavController</strong> components to navigate between different screens. The screens are built using Compose, which means that an application using only Compose would ideally have only one activity. This eliminates any potential problems regarding activity and fragment lifecycles. To introduce<a id="_idIndexMarker316"/> navigation<a id="_idIndexMarker317"/> into a project, the following library is required:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    … </p>
			<p class="source-code">    implementation "androidx.navigation:navigation-compose:2.4.0-rc01"</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>If we want to navigate from one screen to another, we will need to obtain <strong class="source-inline">NavHostController</strong> and pass it into a <strong class="source-inline">@Composable</strong> method that will represent the structure of the application:</p>
			<p class="source-code">Surface {</p>
			<p class="source-code">    val navController = rememberNavController()</p>
			<p class="source-code">    AppNavigation(navController = navController)</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">AppNavigation</strong> <strong class="source-inline">@Composable</strong> method <a id="_idIndexMarker318"/>will look something like this:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun AppNavigation(navController: NavHostController) {</p>
			<p class="source-code">    NavHost(navController, startDestination = "screen1") {</p>
			<p class="source-code">        composable(route = "screen1") {</p>
			<p class="source-code">            Screen1(navController)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        composable(</p>
			<p class="source-code">            route = "screen2/{param}",</p>
			<p class="source-code">            arguments = listOf(navArgument("param") { type </p>
			<p class="source-code">                = NavType.StringType })</p>
			<p class="source-code">        ) {</p>
			<p class="source-code">            Screen2(navController, </p>
			<p class="source-code">                it.arguments?.getString("param").orEmpty())</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In <strong class="source-inline">AppNavigation</strong>, we invoke the <strong class="source-inline">NavHost</strong> <strong class="source-inline">@Composable</strong> function in which we will place the screens of the application along with a route to each of them. In this case, <strong class="source-inline">Screen1</strong> will have <a id="_idIndexMarker319"/>a <a id="_idIndexMarker320"/>simple route to navigate to and <strong class="source-inline">Screen2</strong> will require an argument when it is navigated to indicated through the <strong class="source-inline">{param}</strong> notation. For arguments, we will need to specify the type of the argument. In this case, it will be <strong class="source-inline">String</strong>, and <strong class="source-inline">NavType.StringType</strong> indicates this. If we wish to pass more complex arguments, then we will need to supply our own custom types and indicate how they should be serialized and deserialized. When we want to navigate from <strong class="source-inline">Screen1</strong> to <strong class="source-inline">Screen2</strong>, then we will need to do the following:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Screen1(navController: NavController) {</p>
			<p class="source-code">    Column(modifier = Modifier.clickable {</p>
			<p class="source-code">        navController.navigate("screen2/test")</p>
			<p class="source-code">    }) {</p>
			<p class="source-code">        Text(text = "My text")</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When <strong class="source-inline">Column</strong> is clicked in <strong class="source-inline">Screen1</strong>, it will invoke <strong class="source-inline">NavController</strong> to navigate to <strong class="source-inline">Screen2</strong> and pass the <strong class="source-inline">test</strong> argument. <strong class="source-inline">Screen2</strong> will look like the following:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Screen2(navController: NavController, text: String) {</p>
			<p class="source-code">    Column {</p>
			<p class="source-code">        Text(text = text)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Screen2</strong> will use the text extracted from <strong class="source-inline">it.arguments?.getString("param").orEmpty()</strong> and it will display it on the UI. </p>
			<p>In this section, we have discussed how Android deals with UIs. We have looked over the imperative approach and then introduced the declarative approach for Uis. We have analyzed the Jetpack Compose library and the problems it attempts to solve, such as less code and no XML declarations for layouts. It follows the principles of libraries from other technologies (such as React and SwiftUI) and shows how UIs can be built from a functional <a id="_idIndexMarker321"/>programming point of view. In the next section, we<a id="_idIndexMarker322"/> will look at an exercise for how we can use Compose to navigate between two screens in an application.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor060"/>Exercise 3.2 – Navigating using Jetpack Compose</h2>
			<p>Modify <em class="italic">Exercise 3.1</em> so that<a id="_idIndexMarker323"/> the current <strong class="source-inline">@Composable</strong> functions are moved into a new file named <strong class="source-inline">UserListScreen</strong>, then create a new file with new <strong class="source-inline">@Composable</strong> functions that will render a simple text called <strong class="source-inline">UserScreen</strong>. When a user from the list is clicked, the new screen is opened and it will display the name of the user.</p>
			<p>To complete the exercise, you will need to build the following:</p>
			<ol>
				<li value="1">Create an <strong class="source-inline">AppNavigation</strong> sealed class that will have two variables. The first variable, named <strong class="source-inline">route</strong>, will be <strong class="source-inline">String</strong> and the second variable, named <strong class="source-inline">argumentName</strong>, will be <strong class="source-inline">String</strong> and default to <strong class="source-inline">empty</strong>. Two subclasses of <strong class="source-inline">AppNavigation</strong> will be <strong class="source-inline">Users</strong> (which will set the route variable to <strong class="source-inline">"users"</strong>) and <strong class="source-inline">User</strong> (which will set the route to <strong class="source-inline">"users/{name}"</strong>, then <strong class="source-inline">argumentName</strong> to <strong class="source-inline">name</strong>, and a method to create the route for a specific name).</li>
				<li>In <strong class="source-inline">MainActivity</strong>, rename the screen <strong class="source-inline">@Composable</strong> function to <strong class="source-inline">Users</strong>, and using the <strong class="source-inline">NavController</strong> object, set up a click listener on the list row and navigate to the route from the <strong class="source-inline">User</strong> class in <strong class="source-inline">AppNavigation</strong>. </li>
				<li>Create a<a id="_idIndexMarker324"/> new <strong class="source-inline">@Composable</strong> function named <strong class="source-inline">User</strong>, which will be responsible for showing a simple <strong class="source-inline">Text</strong> and will have the text displayed as a parameter.</li>
				<li>In <strong class="source-inline">MainActivity</strong>, create a <strong class="source-inline">@Composable</strong> function named <strong class="source-inline">MainApplication</strong>, which will use the <strong class="source-inline">NavHost</strong> <strong class="source-inline">@Composable</strong> function to link the navigation between the two screens.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">navigation</strong> library for Compose in <strong class="source-inline">app/build.gradle</strong>:<p class="source-code">dependencies {</p><p class="source-code">    … </p><p class="source-code">    implementation "androidx.navigation:navigation-compose:2.4.0-rc01"</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">AppNavigation</strong> class, which will hold the information for the routes and arguments for each of our screens:<p class="source-code">private const val ROUTE_USERS = "users"</p><p class="source-code">private const val ROUTE_USER = "users/%s"</p><p class="source-code">private const val ARG_USER_NAME = "name"</p><p class="source-code">sealed class AppNavigation(val route: String, val </p><p class="source-code">    argumentName: String = "") {</p><p class="source-code">    object Users : AppNavigation(ROUTE_USERS)</p><p class="source-code">    object User : AppNavigation</p><p class="source-code">        (String.format(ROUTE_USER, "{$ARG_USER_NAME}")</p><p class="source-code">            , ARG_USER_NAME) {</p><p class="source-code">        fun routeForName(name: String) = </p><p class="source-code">            String.format(ROUTE_USER, name)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>As the navigation<a id="_idIndexMarker325"/> relies on URLs to identify the different screens, we can take advantage of sealed classes and objects in Kotlin to keep track of the required inputs for each screen. </p>
			<ol>
				<li value="3">Rename the screen <strong class="source-inline">@Composable</strong> function to <strong class="source-inline">Users</strong> in <strong class="source-inline">MainActivity</strong> and add <strong class="source-inline">NavController</strong> as a parameter:<p class="source-code">@Composable</p><p class="source-code">fun Users(</p><p class="source-code">    navController: NavController,</p><p class="source-code">    viewModel: MainViewModel = viewModel(factory =  </p><p class="source-code">        MainViewModelFactory())</p><p class="source-code">) {</p><p class="source-code">    viewModel.uiStateLiveData.observeAsState().value?.let {</p><p class="source-code">        UserList(uiState = it, navController)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, pass<a id="_idIndexMarker326"/> the <strong class="source-inline">NavController</strong> parameter to <strong class="source-inline">UserList</strong> and implement the click listener for the user row:<p class="source-code">@Composable</p><p class="source-code">fun UserList(uiState: UiState, navController: NavController) {</p><p class="source-code">    LazyColumn(modifier = Modifier.padding(16.dp)) {</p><p class="source-code">        item(uiState.count) {</p><p class="source-code">            Column(modifier = Modifier.padding(16.dp)) {</p><p class="source-code">                Text(text = uiState.count)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        items(uiState.userList) {</p><p class="source-code">            Column(modifier = Modifier</p><p class="source-code">                .padding(16.dp)</p><p class="source-code">                .clickable {</p><p class="source-code">                    navController.navigate</p><p class="source-code">                      (AppNavigation.User.routeForName</p><p class="source-code">                           (it.name))</p><p class="source-code">                }) {</p><p class="source-code">                Text(text = it.name)</p><p class="source-code">                Text(text = it.username)</p><p class="source-code">                Text(text = it.email)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create<a id="_idIndexMarker327"/> the <strong class="source-inline">User</strong> <strong class="source-inline">@Composable</strong> function in <strong class="source-inline">MainActivity</strong>:<p class="source-code">@Composable</p><p class="source-code">fun User(text: String) {</p><p class="source-code">    Column {</p><p class="source-code">        Text(text = text)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, create an <strong class="source-inline">App</strong> <strong class="source-inline">@Composable</strong> function that will use <strong class="source-inline">NavHost</strong> to set up the navigation between the two screens in <strong class="source-inline">MainActivity</strong>:<p class="source-code">@Composable</p><p class="source-code">fun App(navController: NavHostController) {</p><p class="source-code">    NavHost(navController, startDestination = </p><p class="source-code">        AppNavigation.Users.route) {</p><p class="source-code">        composable(route = AppNavigation.Users.route) {</p><p class="source-code">            Users(navController)</p><p class="source-code">        }</p><p class="source-code">        composable(</p><p class="source-code">            route = AppNavigation.User.route,</p><p class="source-code">            arguments = listOf(navArgument</p><p class="source-code">                (AppNavigation.User.argumentName) {</p><p class="source-code">                type = NavType.StringType</p><p class="source-code">            })</p><p class="source-code">        ) {</p><p class="source-code">            User(it.arguments?.getString(AppNavigation.User.argumentName).orEmpty())</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Finally, invoke the <strong class="source-inline">App</strong> function <a id="_idIndexMarker328"/>when the <strong class="source-inline">Activity</strong> content is set in <strong class="source-inline">MainActivity</strong>:<p class="source-code">class MainActivity : ComponentActivity() {</p><p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p><p class="source-code">        super.onCreate(savedInstanceState)</p><p class="source-code">        setContent {</p><p class="source-code">            Exercise0302Theme { </p><p class="source-code">        // Replace this with your application's theme</p><p class="source-code">                Surface {</p><p class="source-code">                    <strong class="bold">val navController = </strong></p><p class="source-code"><strong class="bold">                        rememberNavController()</strong></p><p class="source-code">                    <strong class="bold">App(navController = navController)</strong></p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_3.06_B18320.jpg" alt="Figure 3.6 – Output of Exercise 3.2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Output of Exercise 3.2</p>
			<p>If we run the <a id="_idIndexMarker329"/>application, we should see the same list of users as before, and if we click on a user, it will transition to a new screen that will display the selected user's name, as shown in <em class="italic">Figure 3.6</em>. If we press the <em class="italic">Back</em> button, we should see the initial list of users; that's because, by default, the <strong class="source-inline">navigation</strong> library handles back navigation. </p>
			<p>In this exercise, we have analyzed how we can use Jetpack Compose to navigate between two<a id="_idIndexMarker330"/> screens in an application. In future chapters, we will revisit navigation when we must navigate between different screens in different modules.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor061"/>Summary</h1>
			<p>In this chapter, we have analyzed how data can be presented in Android and discussed the libraries we have available now. We have looked at Android lifecycles and the potential issues that applications could have regarding lifecycles and then looked at how libraries such as <strong class="source-inline">ViewModel</strong> and <strong class="source-inline">LiveData</strong> solve most of these problems. We then looked at how the UI works in Android and how we would need to deal with using XML to define layouts in which we would insert the views that the layouts needed to display, and how we would need to update the state of the views when the data changes. We then looked at how Jetpack Compose solves these issues in a declarative functional way. We built upon the exercises in the previous chapter to show how we can integrate multiple libraries in a single application and display data from the internet. </p>
			<p>In the next chapter, we will deal with managing the dependencies inside an application and the libraries available for doing so.</p>
		</div>
	</body></html>