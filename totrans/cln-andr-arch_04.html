<html><head></head><body>
		<div><h1 id="_idParaDest-51"><em class="italic"><a id="_idTextAnchor055"/>Chapter 3</em>: Understanding Data Presentation on Android</h1>
			<p>In this chapter, we will study the libraries available for presenting data on the <code>ViewModel</code> and <code>Lifecycle</code> libraries. We will then move on to analyze aspects of how the UI works and look at how the Jetpack Compose library revolutionized building UIs through its declarative approach. Finally, we will look at how we can navigate between different screens that are built in Compose by using the <code>Navigation</code> library with the <code>Compose</code> extension.</p>
			<p>In this chapter, we will cover the following main topics: </p>
			<ul>
				<li>Analyzing lifecycle-aware components</li>
				<li>Using Jetpack Compose to build UIs</li>
			</ul>
			<p>By the end of the chapter, you will become familiar with how to present data on the UI using ViewModel and Compose.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor056"/>Technical requirements </h1>
			<p>Hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3lmMIOg">https://bit.ly/3lmMIOg</a></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor057"/>Analyzing lifecycle-aware components</h1>
			<p>In this section, we <a id="_idIndexMarker254"/>will analyze the lifecycles of activities and fragments and the potential issues that are caused when working with them. We will also observe how the introduction of ViewModel and LiveData solves these problems.</p>
			<p>When the Android operating system and its development framework were released, activities were the most commonly used components when developing an application, as they represent the entry point of the interaction between an application and a user. As technology in displays and resolutions improved, apps could then present more information and controls that the user could interact with. For developers, this meant that the code required to manage the logic for a single activity increased, especially when dealing with different layouts for landscape and portrait. The introduction of fragments was meant to solve some of these problems. Responsibilities for handling the logic in different parts of the screen could now be divided into different fragments.</p>
			<p>The introduction of fragments, however, didn't solve all of the issues developers were dealing with, mainly because both activities and fragments have their own lifecycles. Dealing with lifecycles created the possibility of apps having context leaks, and the combination of lifecycles and inheritance made both activities and fragments hard to unit test.</p>
			<p>The lifecycle of an activity is as follows: </p>
			<div><div><img src="img/Figure_3.01_B18320.jpg" alt="Figure 3.1 – Activity lifecycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Activity lifecycle</p>
			<p> In <em class="italic">Figure 3.1</em>, we <a id="_idIndexMarker255"/>can see the six most well-known states of an activity:</p>
			<ul>
				<li><em class="italic">CREATED</em>: The activity enters this state when the <code>onCreate</code> method is called. This will be called when the system creates the activity.</li>
				<li><em class="italic">STARTED</em>: The activity enters this state when the <code>onStart</code> method is called. This will be called when the activity is visible to the user.</li>
				<li><em class="italic">RESUMED</em>: The activity enters this state when the <code>onResume</code> method is called. This will be called when the activity is in focus (the user can interact with it).</li>
			</ul>
			<p>The next three states are called when the activity is no longer in focus. This can be caused either by the user closing the activity, putting it in the background, or another component gaining focus:</p>
			<ul>
				<li><em class="italic">PAUSED</em>: The activity enters this state when the <code>onPause</code> method is called. This will be called when the activity is visible but no longer in focus.</li>
				<li><em class="italic">STOPPED</em>: The activity enters this state when the <code>onStop</code> method is called. This will be called when the activity is no longer visible.</li>
				<li><em class="italic">DESTROYED</em>: The activity enters this state when the <code>onDestroy</code> method is called. This will be called when the activity is destroyed by the operating system.</li>
			</ul>
			<p>When we use <a id="_idIndexMarker256"/>activities in our code, dealing with the lifecycle will look something like this:</p>
			<pre>class MyActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    }
    override fun onStart() {
        super.onStart()
    }
    override fun onResume() {
        super.onResume()
    }
    override fun onPause() {
        super.onPause()
    }
    override fun onStop() {
        super.onStop()
    }
    override fun onDestroy() {
        super.onDestroy()
    }
}</pre>
			<p>We can see here that we need to extend the <code>Activity</code> class and, if we want to execute a particular operation in a particular state, we can override the method associated <a id="_idIndexMarker257"/>with the state and invoke the <code>super</code> call. This represents the main reason why activities are hard to unit test. The <code>super</code> calls would cause our test not only to invoke our code but also the parent class's code. Another reason activities are hard to test is because the system is the one instantiating the class, which means that we cannot use the constructor of the class for injection and must rely on setters to inject mock objects. </p>
			<p>An important distinction should be made between the <em class="italic">DESTROYED</em> state and garbage collection. A <em class="italic">DESTROYED</em> activity doesn't mean it will be garbage collected. A simple definition of what garbage collection means is that garbage collection is the process of deallocating memory that is no longer used. Each created object takes a certain amount of memory. When the garbage collector wants to free memory, it will look at objects that are no longer referenced by other objects. If we want to make sure that objects will be garbage collected, we will need to make sure that other objects that live longer than them will have no reference to the objects we want to be collected. In Android, we want <code>onDestroy</code> methods are called. This is because they tend to occupy a lot of memory and we will end up with crashes or bugs if we end up invoking methods after <code>onDestroy</code> is called. Leaks that prevent context objects from <a id="_idIndexMarker258"/>being <a id="_idIndexMarker259"/>collected are called <strong class="bold">context leaks</strong>. Let's look at a simple example of this:</p>
			<pre>interface MyListener {
    fun onChange(newText: String)
}
<strong class="bold">object</strong> MyManager {
    private val listeners = mutableListOf&lt;MyListener&gt;()
    fun addListener(listener: MyListener) {
        listeners.add(listener)
    }
    fun performLogic() {
        listeners.forEach {
            it.onChange("newText")
        }
    }
}</pre>
			<p>Here, we have a <code>MyManager</code> class in which we collect a list of <code>MyListener</code> that will be invoked when <code>performLogic</code> is called. Note that the <code>MyManager</code> class is defined using the <code>object</code> keyword. This will make the <code>MyManager</code> class static, which means the instance of the class will live as long as the application process lives. If we want an activity to listen to when the <code>performLogic</code> method is called, we will have something like the following:</p>
			<pre>class MyActivity : Activity(), MyListener {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        MyManager.addListener(this)
    }
    override fun onChange(newText: String) {
        myTextView.setText(newText)
    }
}</pre>
			<p>Here, <code>MyListener</code> is<a id="_idIndexMarker260"/> implemented in <code>MyActivity</code>, and when <code>onChange</code> is called, <code>myTextView</code> will be updated. The context leak occurs here when the activity is destroyed. As <code>MyActivity</code> is a <code>MyListener</code> and a reference to it is kept in <code>MyManager</code>, which lives longer, the garbage collector will not remove the <code>MyActivity</code> instance from memory. If <code>performLogic</code> is called after <code>MyActivity</code> is destroyed, we will get <code>NullPointerException</code>, because <code>myTextView</code> will be set to null; or, if multiple instances of <code>MyActivity</code> leak, it could potentially lead to consuming the entire application's memory. A simple fix for this is to remove the reference to <code>MyActivity</code> when it is destroyed: </p>
			<pre>object MyManager {
    …
<strong class="bold">    fun removeListener(listener: MyListener){</strong>
<strong class="bold">        listeners.remove(listener)</strong>
<strong class="bold">    }</strong>
    …
}
class MyActivity : Activity(), MyListener {
    …
<strong class="bold">    override fun onDestroy() {</strong>
<strong class="bold">        MyManager.removeListener(this)</strong>
<strong class="bold">        super.onDestroy()</strong>
<strong class="bold">    }</strong>
    …
}</pre>
			<p>Here, we add a simple <a id="_idIndexMarker261"/>method to remove <code>MyListener</code> from the list and invoke it from the <code>onDestroy</code> method. </p>
			<p>Working with fragments will lead to the same type of problems as activities. Fragments have their own lifecycle and inherit from a parent <code>Fragment</code> class, which makes them vulnerable to context leaks and hard to unit test. </p>
			<p>The lifecycle of a fragment is as follows:</p>
			<div><div><img src="img/Figure_3.02_B18320.jpg" alt="Figure 3.2 – Fragment lifecycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Fragment lifecycle</p>
			<p>In <em class="italic">Figure 3.2</em>, we can <a id="_idIndexMarker262"/>see that the fragment has similar lifecycle states to the activity. The <code>onAttach</code> and <code>onDetach</code> callbacks deal with when the fragment is attached to and detached from the activity. <code>onActivityCreated</code> is called when the activity completes its own <code>onCreate</code> call. The <code>onCreateView</code> and <code>onDestroyView</code> callbacks deal with inflating and destroying a fragment's views. One of the reasons these callbacks exist is because of the fragment back stack. This is a stack structure in which fragments are kept so that when the users press the <em class="italic">Back</em> button, the current fragment is popped out of the stack and the previous fragment is displayed. When fragments are replaced in the back stack, they aren't fully destroyed; just their views are destroyed to save memory. When they are popped back to be <a id="_idIndexMarker263"/>viewed by the user, they will not be re-created, and <code>onCreateView</code> will be called.</p>
			<p>In order to solve the problems caused by dealing with activity and fragment lifecycles, a set of libraries was created that are part of the <code>androidx.lifecycle</code> group. The <code>Lifecycle</code> class was introduced, which is responsible for keeping the current lifecycle state and handling transitions between lifecycle events. The events and states of the <code>Lifecycle</code> class would be as follows:</p>
			<div><div><img src="img/Figure_3.03_B18320.jpg" alt="Figure 3.3 – Lifecycle states&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Lifecycle states</p>
			<p>In <em class="italic">Figure 3.3</em>, we can <a id="_idIndexMarker264"/>see that the <code>Lifecycle</code> class only has four states (<em class="italic">INITIALIZED</em>, <em class="italic">CREATED</em>, <em class="italic">STARTED</em>, and <em class="italic">DESTROYED</em>), and it will deal with six events (<code>ON_CREATE</code>, <code>ON_START</code>, <code>ON_RESUME</code>, <code>ON_PAUSE</code>, <code>ON_STOP</code>, and <code>ON_DESTROY</code>). If we wish for a certain class to be lifecycle-aware, it will need to implement the <code>LifecycleOwner</code> interface. Activities and fragments already implement this interface. We can see that for activities, the events match the existing callbacks, but for fragments, some changes are required to match these new events. The <code>onAttach</code>, <code>onDetach</code>, and <code>onActivityCreated</code> methods are deprecated, so they shouldn't be used with regard to the new <code>Lifecycle</code> library. The other change made for fragments is the introduction of a <code>viewLifecycleObserver</code> instance variable, which is used to handle the lifecycle between <code>onCreateView</code> and <code>onDestroyView</code>. This observer should be used when registering for lifecycle-aware components and you wish to update the UI.</p>
			<p>In Android, when a configuration change (device rotation and language change, for example) occurs, then activities and fragments are re-created (the current instance is destroyed and a new instance will be created). This typically causes problems when these configuration changes occur while data is loaded or when we want to restore the previously loaded data. The <code>ViewModel</code> class is meant to solve this problem, along with the issue of testability of activities and fragments. A ViewModel will live until the activity or <a id="_idIndexMarker265"/>fragment it is connected to is destroyed and not re-created. The ViewModel comes with an <code>onCleared</code> method, which can be overwritten to clear any subscriptions to any pending operations.</p>
			<p>ViewModels are often paired with a class called <code>LiveData</code>. This is a lifecycle-aware component that observes and emits data. The combination of the two classes eliminates the risks of context leaks, as <code>LiveData</code> will only emit data when the observer is in a <em class="italic">STARTED</em> or <em class="italic">RESUMED</em> state. An additional benefit is that it will keep the last data held; so, in the case of a configuration change, the last data kept in <code>LiveData</code> will be re-emitted. This benefit allows activities and fragments to observe the changes and restore the UI to the way it was before they were re-created. In Jetpack Compose, <code>LiveData</code> isn't necessary due to Compose's own set of state handling classes.</p>
			<p>To use <code>ViewModel</code> and <code>LiveData</code>, you will need the following libraries to be added to <code>build.gradle</code>:</p>
			<pre>implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0"
implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.4.0"</pre>
			<p>For integration with Jetpack Compose we will need the following:</p>
			<pre>implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0"
implementation "androidx.compose.runtime:runtime-livedata:2.4.0 "</pre>
			<p>An example of a <code>ViewModel</code> and <code>LiveData</code> implementation will look something like this:</p>
			<pre>class MyViewModel : ViewModel() {
    private val _myLiveData = MutableLiveData("")
    val myLiveData: LiveData&lt;String&gt; = _myLiveData
    init {
        _myLiveData.value = "My new value"
    }
}</pre>
			<p>In the preceding <a id="_idIndexMarker266"/>example, we extend the <code>ViewModel</code> class and define two <code>LiveData</code> instance variables. The <code>_myLiveData</code> variable is defined as <code>MutableLiveData</code> and is set to private. This is to prevent other objects from changing the values of <code>LiveData</code>. The <code>myLiveData</code> variable is public and can be used by <code>Lifecycle</code> owners to observe changes on <code>LiveData</code>. </p>
			<p>To obtain the instance of a ViewModel in an activity or fragment, we can use the following:</p>
			<pre>class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        …
        <strong class="bold">val myViewModel : MyViewModel by viewModels()</strong>
        …
    }
}</pre>
			<p>Here, the <code>viewModels</code> method will retrieve the instance of <code>MyViewModel</code>. The method provides the ability to pass along a <code>ViewModelProvider.Factory</code> object. This is useful in situations where we want to inject various objects in our ViewModel. This will look something like this:</p>
			<pre>        val myViewModel : MyViewModel by viewModels {
            object : ViewModelProvider.Factory {
                override fun &lt;T : ViewModel&gt; 
                    create(modelClass: Class&lt;T&gt;): T {
                    return MyViewModel() as T
                }
            }
        }</pre>
			<p>If we want to<a id="_idIndexMarker267"/> observe the changes on <code>LiveData</code>, we would need to do something like this:</p>
			<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        …
        super.onCreate(savedInstanceState)
        val myViewModel: MyViewModel by viewModels()
        myViewModel.myLiveData.observe(this) { text -&gt;
            myTextView.text = text
        }
        …
    }
}</pre>
			<p>In the preceding example, we invoke the <code>observe</code> method, where we pass the activity as <code>LifecycleOwner</code> and pass a Lambda as <code>Observer</code>, which will be invoked when <code>LiveData</code> changes its value.</p>
			<p>If we want to use <code>ViewModel</code> with <code>LiveData</code> in Jetpack Compose, we must do the following:</p>
			<pre>@Composable
fun MyScreen(<strong class="bold">viewModel: MyViewModel = viewModel()</strong>) {
    <strong class="bold">viewModel.myLiveData.observeAsState()</strong>.value?.let {
        MyComposable(it)
    }
}
@Composable
fun MyComposable(text: String){
    …
}</pre>
			<p>Here, we are <a id="_idIndexMarker268"/>using the <code>viewModel</code> method to obtain the <code>MyViewModel</code> instance. This method also offers the possibility of passing a <code>ViewModelProvider.Factory</code> instance, such as the previous <code>viewModel</code> method. The <code>observeAsState</code> extension method will observe changes on <code>LiveData</code> and convert them into a Compose <code>State</code> object.</p>
			<p>In this section, we have discussed how lifecycles work in activities and fragments and the problems developers have when dealing with them. We have analyzed how the lifecycle-aware components (such as ViewModel and LiveData) solved these problems. The <code>ViewModel</code> class itself <a id="_idIndexMarker269"/>represents an implementation of the <strong class="bold">Model-View ViewModel</strong> (<strong class="bold">MVVM</strong>) pattern, which will be discussed in a future chapter. In the next section, we will look at an exercise in which we will use both ViewModel and LiveData and combine them with Kotlin flows.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor058"/>Exercise 3.1 – Using ViewModel and LiveData</h2>
			<p>Modify <em class="italic">Exercise 2.5</em> from <a href="B18320_02_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Deep Diving into Data Sources</em>, so that the state <a id="_idIndexMarker270"/>of the <a id="_idIndexMarker271"/>UI is<a id="_idIndexMarker272"/> kept in a <code>LiveData</code> object <a id="_idIndexMarker273"/>inside <code>MainViewModel</code>, instead of using the Compose <code>State</code> object, and display <code>"Total request count: x"</code>, where <code>x</code> is the number of requests at the top of the list.</p>
			<p>To complete the exercise, you will need to build the following:</p>
			<ul>
				<li>Add the specified text in <code>strings.xml</code>.</li>
				<li>Create a <code>MainTextFormatter</code> class that will have one method that will return the <code>"Total request count: x"</code> text.</li>
				<li>Add a dependency to <code>MainTextFormatter</code> in <code>MainViewModel</code>, and pass the formatted text as a value for the <code>UiState.count</code> object.</li>
				<li>Remove <code>resultState</code> and replace it with a <code>LiveData</code> object.</li>
				<li>Update the <code>@Composable</code> functions to use <code>LiveData</code>.</li>
			</ul>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li>Add the <code>LiveData</code> extension library for Jetpack Compose to <code>app/build.gradle</code>:<pre>    implementation "androidx.compose.runtime:runtime-livedata:$compose_version"</pre></li>
				<li>Add the <code>"Total request count"</code> text in <code>strings.xml</code>:<pre>    &lt;string name="total_request_count"&gt;Total request count: %d&lt;/string&gt;</pre></li>
				<li>Create the <code>MainTextFormatter</code> class as follows:<pre>class MainTextFormatter(private val 
    applicationContext: Context) {
    fun getCounterText(count: Int) =
        applicationContext.getString(R.string.total_request_co
    unt, count)
}</pre></li>
			</ol>
			<p>The reason we created this class is to prevent possible context leaks by having a <code>Context</code> object inside the <code>MainViewModel</code> class. Here, we have a method that will take a count as a parameter and return the required text.</p>
			<ol>
				<li value="4">Inject <code>MainTextFormatter</code> in <code>MainViewModel</code> and use the formatted text <a id="_idIndexMarker274"/>as <a id="_idIndexMarker275"/>a <a id="_idIndexMarker276"/>value <a id="_idIndexMarker277"/>for the <code>UiState.count</code> object:<pre>class MainViewModel(
    …
    <strong class="bold">private val mainTextFormatter: MainTextFormatter</strong>
) : ViewModel() {
    …
    init {
        viewModelScope.launch {
                …
                .flatMapConcat { users -&gt;
                    appDataStore.savedCount.map { 
                        count -&gt;
                        UiState(
                            users,
                           <strong class="bold">mainTextFormatter.getCounterText(count)</strong>
                        )
                    }
                }
                …
        }
    }
}</pre></li>
				<li>Next, create<a id="_idIndexMarker278"/> the instance<a id="_idIndexMarker279"/> of the <code>MainTextFormatter</code> class<a id="_idIndexMarker280"/> in<a id="_idIndexMarker281"/> the <code>MyApplication</code> class:<pre>class MyApplication : Application() {
    companion object {
        …
        <strong class="bold">lateinit var mainTextFormatter: </strong>
<strong class="bold">            MainTextFormatter</strong>
    }
    override fun onCreate() {
        super.onCreate()
        …
        <strong class="bold">mainTextFormatter = MainTextFormatter(this)</strong>
    }
}</pre></li>
				<li>Now, update <code>MainViewModelFactory</code> to use <code>MainTextFormatter</code>, which <a id="_idIndexMarker282"/>was <a id="_idIndexMarker283"/>just<a id="_idIndexMarker284"/> created, and pass<a id="_idIndexMarker285"/> it into <code>MainViewModel</code>:<pre>class MainViewModelFactory : ViewModelProvider.Factory {
    override fun &lt;T : ViewModel&gt; create(modelClass: 
        Class&lt;T&gt;): T =
        MainViewModel(
            MyApplication.userService,
            MyApplication.userDao,
            MyApplication.appDataStore,
            MyApplication.mainTextFormatter
        ) as T
}</pre></li>
				<li>Next, add <code>LiveData</code> to <code>MainViewModel</code>:<pre>class MainViewModel(
    …
) : ViewModel() {
    <strong class="bold">private val _uiStateLiveData = </strong>
<strong class="bold">        MutableLiveData(UiState())</strong>
    <strong class="bold">val uiStateLiveData: LiveData&lt;UiState&gt; = </strong>
<strong class="bold">        _uiStateLiveData</strong>
    init {
        viewModelScope.launch {
                …
                .collect {
                    <strong class="bold">_uiStateLiveData.value = it</strong>
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we have defined the two <code>LiveData</code> variables, one to update the value and the <a id="_idIndexMarker286"/>other <a id="_idIndexMarker287"/>to be observed, and in<a id="_idIndexMarker288"/> the <code>collect</code> method, we<a id="_idIndexMarker289"/> update the value of <code>LiveData</code>.</p>
			<ol>
				<li value="8">In <code>MainActivity</code>, update the <code>@Composable</code> functions to use <code>LiveData</code>:<pre>…
@Composable
fun Screen(viewModel: MainViewModel = viewModel(factory = MainViewModelFactory())) {
<strong class="bold">    viewModel.uiStateLiveData.observeAsState().value?.let {</strong>
<strong class="bold">        UserList(uiState = it)</strong>
<strong class="bold">    }</strong>
}
…</pre></li>
			</ol>
			<p>Here, we call the <code>observeAsState</code> extension method on <code>LiveData</code> from <code>MainViewModel</code>, and then call the <code>UserList</code> method, which will redraw the UI for each new value.</p>
			<div><div><img src="img/Figure_3.04_B18320.jpg" alt="Figure 3.4 – Output of Exercise 3.1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Output of Exercise 3.1</p>
			<p>If we run <a id="_idIndexMarker290"/>the<a id="_idIndexMarker291"/> application, we <a id="_idIndexMarker292"/>will <a id="_idIndexMarker293"/>see the same list of users, and at the top, we will see <code>"Total request count: x"</code> instead of just the <code>x</code> character that was there before, as shown in <em class="italic">Figure 3.4</em>. In this exercise, we used Jetpack Compose for rendering the UI. In the section that follows, we will analyze how Android <a id="_idIndexMarker294"/>handles UIs and go more in-depth into the Jetpack Compose framework.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor059"/>Using Jetpack Compose to build UIs</h1>
			<p>In this <a id="_idIndexMarker295"/>section, we<a id="_idIndexMarker296"/> will analyze how to build UIs for Android applications using the <code>View</code> hierarchy and look at the implications this has for applications. We will then look at how Jetpack Compose simplifies and changes how UIs are built and how we can use Compose to create UIs. We will be looking at Jetpack Compose with the view of how we can integrate it with other libraries and how to build a simple UI. For more information on how to build more complex UIs, you can refer to the official documentation found here: <a href="https://developer.android.com/jetpack/compose">https://developer.android.com/jetpack/compose</a>.</p>
			<p>The way Android deals with UIs is through the <code>View</code> hierarchy. The subclasses of <code>View</code> deal with specific UI components that the user can interact with. The hierarchy looks similar to the following diagram:</p>
			<div><div><img src="img/Figure_3.05_B18320.jpg" alt="Figure 3.5 – View hierarchy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – View hierarchy</p>
			<p>The <code>TextView</code> class deals with displaying text on the screen, <code>EditText</code> deals with handling text inputted by the user, and <code>Button</code> deals with rendering buttons on the screen. A specialized subclass of <code>View</code> is the <code>ViewGroup</code> class. This represents the base class for various layout classes that are responsible for how the views are grouped and arranged on the screen. Here, we find classes such as <code>LinearLayout</code> (which groups views one after the other either vertically or horizontally), <code>RelativeLayout</code> (which groups the views relative to the parent or to each other), or more recently, <code>ConstraintLayout</code>, which offers various ways to position views however we desire without creating many nested layouts (because it was bad for performance), which is why it became commonly used. When it comes to dealing with displaying lists of items of unknown lengths, objects such as <code>ListView</code> and <code>RecyclerView</code> are used. Both require creating adapters that will be responsible for pairing an object from a list with an associated <code>View</code> to render a row in the list in the UI. </p>
			<p>Using <code>ListViews</code> is <a id="_idIndexMarker297"/>prone <a id="_idIndexMarker298"/>to inefficiencies caused when scrolling where views are recreated for each new row, so in a long list of items, a lot of views would be created and then garbage collected. To solve this, developers had to implement a pattern called a <code>RecyclerView</code> addresses this issue so the adapter <code>RecyclerView</code> uses requires <code>ViewHolder</code>. This means that if a user views a list of 100 items and 10 are visible on the screen, for the 10 that are visible on the screen there would be 10 views to represent each row. When the user scrolls down, the 10 views that were created at the beginning would then display the items for the currently visible items. Developers can also create custom views by extending any of the existing <code>View</code> classes. This is useful when certain UI components have to be re-used in different activities, fragments, or other custom views.</p>
			<p>To display these views to the user, we would need to use activities and fragments. For activities, this would require invoking the <code>setContentView</code> method in the <code>onCreate</code> method, and in fragments, we would need to return a <code>View</code> object in the <code>onCreateView</code> method. We have the possibility of creating the entire layout for an activity or fragment in Java or Kotlin, but this would lead to a lot of code being written. This, and the fact that we can have different layouts for different screen sizes or device rotation, led to <a id="_idIndexMarker300"/>using the <code>res/layout</code> folder, in which we can specify how a layout might look. An example of how this might look is as follows:</p>
			<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;TextView
        android:id="@+id/text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<p>In the<a id="_idIndexMarker301"/> preceding<a id="_idIndexMarker302"/> example, we define <code>ConstraintLayout</code>, which contains only <code>TextView</code> that displays a <code>"Hello World"</code> text. To obtain a reference to <code>TextView</code> to allow us to change the text because of an action or data being loaded, we would need to use the <code>findViewById</code> method from either the <code>Activity</code> class or the <code>View</code> class. This would look something like the following:</p>
			<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val textView = 
            findViewById&lt;TextView&gt;(R.id.text_view)
        textView.text = "Hello new world"
    }
}</pre>
			<p>This approach would lead to possible crashes within an application. Developers would need to make sure that when a layout was set for <code>Activity</code> or <code>Fragment</code> and <code>findViewById</code> was used, then the view was added to the <code>layout</code> file. With the introduction of Kotlin, this was initially addressed through the Kotlin Synthetics framework, which generated extensions for the declared views in a layout. Kotlin Synthetics would generate an extension for a View's <code>android:id</code> XML tag, which would be accessible in the code. Later, this was replaced with <code>ViewBinding</code>. When <code>ViewBinding</code> is used in a project, a class is generated for each layout that will hold references to all the views in the layout, eliminating potential crashes related to <code>findViewById</code>. All these approaches with regard to creating your UI are defined as <strong class="bold">imperative</strong> because<a id="_idIndexMarker303"/> we need to specify the views that our interface uses and control how we update the views when data is changed. </p>
			<p>An <a id="_idIndexMarker304"/>alternative<a id="_idIndexMarker305"/> approach to this <a id="_idIndexMarker306"/>is the <code>View</code> hierarchy and instead use <code>@Composable</code> functions, in which we specify what we want to display on the screen without thinking of how we need to display it, and we can also create the UI using Kotlin using less code than we would normally. In Compose, the <code>Hello World</code> example would look something like the following code:</p>
			<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Surface {
                HelloWorld()
            }
        }
    }
}
@Composable
fun HelloWorld() {
    Text(text = "Hello World")
}</pre>
			<p>If we want to update the text because of a change in data, we will need to use <code>State</code> objects from the <code>Compose</code> library. Compose will observe these states and, when the values are changed, Compose<a id="_idIndexMarker307"/> will redraw the UI associated <a id="_idIndexMarker308"/>with that state. An example of this is as follows:</p>
			<pre>@Composable
fun HelloWorld() {
    val text = remember { mutableStateOf("Hello World") }
    ShowText(text = text.value) {
        text.value = text.value + "0"
    }
}
@Composable
fun ShowText(text: String, onClick: () -&gt; Unit) {
    ClickableText(
        text = AnnotatedString(text = text),
        onClick = {
            onClick()
        })
}</pre>
			<p>In this example, when the text is clicked, the <code>0</code> character is appended to the text and the UI is updated. This is because of the use of <code>mutableStateOf</code>. The <code>remember</code> method is needed because this state is kept inside a <code>@Composable</code> function, and it is used to keep the state intact while recomposition happens (the UI is redrawn). To make the text clickable, we needed to change from <code>Text</code> to <code>ClickableText</code>. The reason we are using two <code>@Composable</code> functions is that we want to keep the <code>@Composable</code> functions as re-usable as possible. This is <a id="_idIndexMarker309"/>called <code>HelloWorld</code>) components from the stateless components (<code>ShowText</code>).</p>
			<p>When it<a id="_idIndexMarker310"/> comes to <a id="_idIndexMarker311"/>rendering lists of items, Compose offers a simple way of rendering them in the form of <code>Column</code> (for when the length of the list is known and short), and <code>LazyColumn</code> (when the list of items is unknown and could potentially be long). An example of this is from <em class="italic">Exercise 3.1</em>:</p>
			<pre>LazyColumn(modifier = Modifier.padding(16.dp)) {
        item(uiState.count) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(text = uiState.count)
            }
        }
        items(uiState.userList) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(text = it.name)
                Text(text = it.username)
                Text(text = it.email)
            }
        }
    }</pre>
			<p>Here, we display a header at the top of the item list, and we use another column to set the padding for the row; then, we display the entire list of items with the use of the <code>items</code> function, and for each row, we set the padding and display a group with three texts. </p>
			<p>If we want to display<a id="_idIndexMarker312"/> input<a id="_idIndexMarker313"/> fields and buttons, then we can look at how we implemented the UI in <em class="italic">Exercise 2.1</em>, from <a href="B18320_02_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Deep Diving into Data Sources</em>:</p>
			<pre>@Composable
fun Calculator(
    a: String, onAChanged: (String) -&gt; Unit,
    b: String, onBChanged: (String) -&gt; Unit,
    result: String,
    onButtonClick: () -&gt; Unit
) {
    Column(modifier = Modifier.padding(16.dp)) {
        OutlinedTextField(
            value = a,
            onValueChange = onAChanged,
            keyboardOptions = KeyboardOptions(keyboardType 
                = KeyboardType.Number),
            label = { Text("a") }
        )
        OutlinedTextField(
            value = b,
            onValueChange = onBChanged,
            keyboardOptions = KeyboardOptions(keyboardType 
                = KeyboardType.Number),
            label = { Text("b") }
        )
        Text(text = result)
        Button(onClick = onButtonClick) {
            Text(text = "Calculate")
        }
    }
}</pre>
			<p>Here, we used <code>OutlinedTextField</code> to render the equivalent of <code>TextInputLayout</code>. We could have used <code>TextField</code> if we wanted the equivalent of a simple <code>EditText</code>. For displaying a button, we can use the <code>Button</code> method, which uses <code>Text</code> for rendering <a id="_idIndexMarker314"/>the<a id="_idIndexMarker315"/> text on the button. </p>
			<p>Compose also has integrations with other libraries, such as <code>ViewModel</code> and <code>LiveData</code>:</p>
			<pre>@Composable
fun Screen(viewModel: MainViewModel = viewModel(factory = MainViewModelFactory())) {
    viewModel.uiStateLiveData.observeAsState().value?.let {
        UserList(uiState = it)
    }
}</pre>
			<p>Here, we can pass <code>ViewModel</code> as a parameter in our <code>Composable</code> function and use the <code>observeAsState</code> function to convert <code>LiveData</code> into a <code>State</code> object, which will then be observed by Compose to redraw the UI. Compose also supports integration with the <code>Hilt</code> library. When Hilt is added to a project, then there is no need to specify <code>Factory</code> for the ViewModel. </p>
			<p>Another important feature of Compose is how it deals with navigation between different screens. The Compose navigation is built upon the <code>androidx.navigation</code> library. This allows Compose to use the <code>NavHost</code> and <code>NavController</code> components to navigate between different screens. The screens are built using Compose, which means that an application using only Compose would ideally have only one activity. This eliminates any potential problems regarding activity and fragment lifecycles. To introduce<a id="_idIndexMarker316"/> navigation<a id="_idIndexMarker317"/> into a project, the following library is required:</p>
			<pre>dependencies {
    … 
    implementation "androidx.navigation:navigation-compose:2.4.0-rc01"
    …
}</pre>
			<p>If we want to navigate from one screen to another, we will need to obtain <code>NavHostController</code> and pass it into a <code>@Composable</code> method that will represent the structure of the application:</p>
			<pre>Surface {
    val navController = rememberNavController()
    AppNavigation(navController = navController)
}</pre>
			<p>The <code>AppNavigation</code> <code>@Composable</code> method <a id="_idIndexMarker318"/>will look something like this:</p>
			<pre>@Composable
fun AppNavigation(navController: NavHostController) {
    NavHost(navController, startDestination = "screen1") {
        composable(route = "screen1") {
            Screen1(navController)
        }
        composable(
            route = "screen2/{param}",
            arguments = listOf(navArgument("param") { type 
                = NavType.StringType })
        ) {
            Screen2(navController, 
                it.arguments?.getString("param").orEmpty())
        }
    }
}</pre>
			<p>In <code>AppNavigation</code>, we invoke the <code>NavHost</code> <code>@Composable</code> function in which we will place the screens of the application along with a route to each of them. In this case, <code>Screen1</code> will have <a id="_idIndexMarker319"/>a <a id="_idIndexMarker320"/>simple route to navigate to and <code>Screen2</code> will require an argument when it is navigated to indicated through the <code>{param}</code> notation. For arguments, we will need to specify the type of the argument. In this case, it will be <code>String</code>, and <code>NavType.StringType</code> indicates this. If we wish to pass more complex arguments, then we will need to supply our own custom types and indicate how they should be serialized and deserialized. When we want to navigate from <code>Screen1</code> to <code>Screen2</code>, then we will need to do the following:</p>
			<pre>@Composable
fun Screen1(navController: NavController) {
    Column(modifier = Modifier.clickable {
        navController.navigate("screen2/test")
    }) {
        Text(text = "My text")
    }
}</pre>
			<p>When <code>Column</code> is clicked in <code>Screen1</code>, it will invoke <code>NavController</code> to navigate to <code>Screen2</code> and pass the <code>test</code> argument. <code>Screen2</code> will look like the following:</p>
			<pre>@Composable
fun Screen2(navController: NavController, text: String) {
    Column {
        Text(text = text)
    }
}</pre>
			<p><code>Screen2</code> will use the text extracted from <code>it.arguments?.getString("param").orEmpty()</code> and it will display it on the UI. </p>
			<p>In this section, we have discussed how Android deals with UIs. We have looked over the imperative approach and then introduced the declarative approach for Uis. We have analyzed the Jetpack Compose library and the problems it attempts to solve, such as less code and no XML declarations for layouts. It follows the principles of libraries from other technologies (such as React and SwiftUI) and shows how UIs can be built from a functional <a id="_idIndexMarker321"/>programming point of view. In the next section, we<a id="_idIndexMarker322"/> will look at an exercise for how we can use Compose to navigate between two screens in an application.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor060"/>Exercise 3.2 – Navigating using Jetpack Compose</h2>
			<p>Modify <em class="italic">Exercise 3.1</em> so that<a id="_idIndexMarker323"/> the current <code>@Composable</code> functions are moved into a new file named <code>UserListScreen</code>, then create a new file with new <code>@Composable</code> functions that will render a simple text called <code>UserScreen</code>. When a user from the list is clicked, the new screen is opened and it will display the name of the user.</p>
			<p>To complete the exercise, you will need to build the following:</p>
			<ol>
				<li value="1">Create an <code>AppNavigation</code> sealed class that will have two variables. The first variable, named <code>route</code>, will be <code>String</code> and the second variable, named <code>argumentName</code>, will be <code>String</code> and default to <code>empty</code>. Two subclasses of <code>AppNavigation</code> will be <code>Users</code> (which will set the route variable to <code>"users"</code>) and <code>User</code> (which will set the route to <code>"users/{name}"</code>, then <code>argumentName</code> to <code>name</code>, and a method to create the route for a specific name).</li>
				<li>In <code>MainActivity</code>, rename the screen <code>@Composable</code> function to <code>Users</code>, and using the <code>NavController</code> object, set up a click listener on the list row and navigate to the route from the <code>User</code> class in <code>AppNavigation</code>. </li>
				<li>Create a<a id="_idIndexMarker324"/> new <code>@Composable</code> function named <code>User</code>, which will be responsible for showing a simple <code>Text</code> and will have the text displayed as a parameter.</li>
				<li>In <code>MainActivity</code>, create a <code>@Composable</code> function named <code>MainApplication</code>, which will use the <code>NavHost</code> <code>@Composable</code> function to link the navigation between the two screens.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Add the <code>navigation</code> library for Compose in <code>app/build.gradle</code>:<pre>dependencies {
    … 
    implementation "androidx.navigation:navigation-compose:2.4.0-rc01"
    …
}</pre></li>
				<li>Create the <code>AppNavigation</code> class, which will hold the information for the routes and arguments for each of our screens:<pre>private const val ROUTE_USERS = "users"
private const val ROUTE_USER = "users/%s"
private const val ARG_USER_NAME = "name"
sealed class AppNavigation(val route: String, val 
    argumentName: String = "") {
    object Users : AppNavigation(ROUTE_USERS)
    object User : AppNavigation
        (String.format(ROUTE_USER, "{$ARG_USER_NAME}")
            , ARG_USER_NAME) {
        fun routeForName(name: String) = 
            String.format(ROUTE_USER, name)
    }
}</pre></li>
			</ol>
			<p>As the navigation<a id="_idIndexMarker325"/> relies on URLs to identify the different screens, we can take advantage of sealed classes and objects in Kotlin to keep track of the required inputs for each screen. </p>
			<ol>
				<li value="3">Rename the screen <code>@Composable</code> function to <code>Users</code> in <code>MainActivity</code> and add <code>NavController</code> as a parameter:<pre>@Composable
fun Users(
    navController: NavController,
    viewModel: MainViewModel = viewModel(factory =  
        MainViewModelFactory())
) {
    viewModel.uiStateLiveData.observeAsState().value?.let {
        UserList(uiState = it, navController)
    }
}</pre></li>
				<li>Next, pass<a id="_idIndexMarker326"/> the <code>NavController</code> parameter to <code>UserList</code> and implement the click listener for the user row:<pre>@Composable
fun UserList(uiState: UiState, navController: NavController) {
    LazyColumn(modifier = Modifier.padding(16.dp)) {
        item(uiState.count) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(text = uiState.count)
            }
        }
        items(uiState.userList) {
            Column(modifier = Modifier
                .padding(16.dp)
                .clickable {
                    navController.navigate
                      (AppNavigation.User.routeForName
                           (it.name))
                }) {
                Text(text = it.name)
                Text(text = it.username)
                Text(text = it.email)
            }
        }
    }
}</pre></li>
				<li>Create<a id="_idIndexMarker327"/> the <code>User</code> <code>@Composable</code> function in <code>MainActivity</code>:<pre>@Composable
fun User(text: String) {
    Column {
        Text(text = text)
    }
}</pre></li>
				<li>Now, create an <code>App</code> <code>@Composable</code> function that will use <code>NavHost</code> to set up the navigation between the two screens in <code>MainActivity</code>:<pre>@Composable
fun App(navController: NavHostController) {
    NavHost(navController, startDestination = 
        AppNavigation.Users.route) {
        composable(route = AppNavigation.Users.route) {
            Users(navController)
        }
        composable(
            route = AppNavigation.User.route,
            arguments = listOf(navArgument
                (AppNavigation.User.argumentName) {
                type = NavType.StringType
            })
        ) {
            User(it.arguments?.getString(AppNavigation.User.argumentName).orEmpty())
        }
    }
}</pre></li>
				<li>Finally, invoke the <code>App</code> function <a id="_idIndexMarker328"/>when the <code>Activity</code> content is set in <code>MainActivity</code>:<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Exercise0302Theme { 
        // Replace this with your application's theme
                Surface {
                    <strong class="bold">val navController = </strong>
<strong class="bold">                        rememberNavController()</strong>
                    <strong class="bold">App(navController = navController)</strong>
                }
            }
        }
    }
}</pre></li>
			</ol>
			<div><div><img src="img/Figure_3.06_B18320.jpg" alt="Figure 3.6 – Output of Exercise 3.2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Output of Exercise 3.2</p>
			<p>If we run the <a id="_idIndexMarker329"/>application, we should see the same list of users as before, and if we click on a user, it will transition to a new screen that will display the selected user's name, as shown in <em class="italic">Figure 3.6</em>. If we press the <em class="italic">Back</em> button, we should see the initial list of users; that's because, by default, the <code>navigation</code> library handles back navigation. </p>
			<p>In this exercise, we have analyzed how we can use Jetpack Compose to navigate between two<a id="_idIndexMarker330"/> screens in an application. In future chapters, we will revisit navigation when we must navigate between different screens in different modules.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor061"/>Summary</h1>
			<p>In this chapter, we have analyzed how data can be presented in Android and discussed the libraries we have available now. We have looked at Android lifecycles and the potential issues that applications could have regarding lifecycles and then looked at how libraries such as <code>ViewModel</code> and <code>LiveData</code> solve most of these problems. We then looked at how the UI works in Android and how we would need to deal with using XML to define layouts in which we would insert the views that the layouts needed to display, and how we would need to update the state of the views when the data changes. We then looked at how Jetpack Compose solves these issues in a declarative functional way. We built upon the exercises in the previous chapter to show how we can integrate multiple libraries in a single application and display data from the internet. </p>
			<p>In the next chapter, we will deal with managing the dependencies inside an application and the libraries available for doing so.</p>
		</div>
	</body></html>