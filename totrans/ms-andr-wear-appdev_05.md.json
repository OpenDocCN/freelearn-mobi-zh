["```java\ndependencies {     \n  compile fileTree(dir: 'libs', include: ['*.jar'])     \n  wearApp project(':wear')     \n  testCompile 'junit:junit:4.12'\n  compile 'com.android.support:appcompat-v7:23.4.0'\n  compile 'com.google.android.support:wearable:2.0.0-alpha1'\n\n  // This version should match the same version in wearable app\n  compile 'com.google.android.gms:play-services-wearable:8.1.0'\n\n  // Use volley to make HTTP requests\n  compile 'com.android.volley:volley:1.0.0'\n\n  // Use JSoup for parsing HTML data\n  compile \"org.jsoup:jsoup:1.8.1\"\n}\n```", "```java\n<manifest \npackage=\"com.siddique.androidwear.today\">     \n  <uses-permission android:name=\"android.permission.INTERNET\" />       \n  <application\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:supportsRtl=\"true\"\n    android:theme=\"@style/AppTheme\">         \n\n  <meta-data \n    android:name=\"com.google.android.gms.version\"   \n    android:value=\"@integer/google_play_services_version\" />         \n\n  <activity\n    android:name=\".TodayMobileActivity\"\n    android:label=\"@string/app_name\"\n    android:windowSoftInputMode=\"stateHidden\"\n    android:configChanges=\"keyboardHidden|orientation|screenSize\"  >             \n\n    <intent-filter>                 \n      <action android:name=\"android.intent.action.MAIN\" />                    \n      <category android:name=\"android.intent.category.LAUNCHER\" />             \n    </intent-filter>\n\n  </activity>\n\n<!— Listens for incoming messages from Wearable devices—>\n\n  <service android:name=\".HandheldListenerService\">             \n    <intent-filter>                 \n      <action android:name=\"com.google.android.gms.wearable.DATA_CHANGED\" />                 \n      <action android:name=\"com.google.android.gms.wearable.MESSAGE_RECEIVED\" />                 \n      <data \n        android:scheme=\"wear\" \n        android:host=\"*\" \n        android:pathPrefix=\"/today\" />             \n    </intent-filter>         \n  </service>     \n  </application> \n</manifest>\n```", "```java\npublic class TodayMobileActivity extends Activity implements GoogleApiClient.ConnectionCallbacks,         GoogleApiClient.OnConnectionFailedListener \n{\n  private GoogleApiClient mGoogleApiClient;\n  public static final String TAG = TodayMobileActivity.class.getName();\n  private int CONNECTION_TIME_OUT_MS = 15000;\n  private TextView devicesConnectedTextView = null;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) \n  {\n    super.onCreate(savedInstanceState);         \n    setContentView(R.layout.main);         \n    Log.i(*TAG*, \"Creating Google Api Client\");\n    mGoogleApiClient = new GoogleApiClient.Builder(this)                 \n      .addApi(Wearable.*API*)                 \n      .addConnectionCallbacks(this)                 \n      .addOnConnectionFailedListener(this)                 \n      .build();\n    devicesConnectedTextView = (TextView) findViewById(R.id.devicesConnected);     \n  }\n\n  @Override\n  protected void onStart() \n  {\n    super.onStart();\n    if (!mGoogleApiClient.isConnected()) \n    {\n      mGoogleApiClient.connect();         \n    }     \n  }\n  @Override\n  public void onConnected(Bundle connectionHint) \n  {         \n    Log.i(TAG, \"Google Api Client Connected\");\n    new Thread(new Runnable() \n    {\n      @Override\n      public void run() \n      {\n        mGoogleApiClient.blockingConnect(CONNECTION_TIME_OUT_MS, TimeUnit.MILLISECONDS);                 \n        NodeApi.GetConnectedNodesResult result =                         Wearable.*NodeApi*.getConnectedNodes(mGoogleApiClient).await();\n        final List<Node> nodes = result.getNodes();                 \n        runOnUiThread(new Runnable() \n        {\n        public void run() \n        {                         \n          Log.i(*TAG*, \"Connected devices = \" + nodes.size());\n        devicesConnectedTextView.setText(String.valueOf(nodes.size()));                     \n        }                 \n      });             \n    }         \n  }).\n  start();     \n  }      \n  ...    \n}\n```", "```java\n<manifest package=\"com.siddique.androidwear.today\">     \n  <uses-feature android:name=\"android.hardware.type.watch\" />       \n  <application\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:supportsRtl=\"true\"\n    android:theme=\"@android:style/Theme.DeviceDefault\">\n\n<!— We need this entry to use Google Play Services —>\n\n  <meta-data \n    android:name=\"com.google.android.gms.version\"   \n    android:value=\"@integer/google_play_services_version\" />         \n\n  <activity\n    android:name=\".TodayActivity\"\n    android:label=\"@string/app_name\">             \n    <intent-filter>                 \n      <action android:name=\"android.intent.action.MAIN\" />                 \n      <category android:name=\"android.intent.category.LAUNCHER\" />             \n    </intent-filter>         \n  </activity>         \n\n  <activity\n    android:name=\".DayOfYearActivity\"\n    android:label=\"@string/day_of_year_card_title\" />         \n\n  <activity\n    android:name=\".OnThisDayActivity\"\n    android:label=\"@string/on_this_day_title\" />     \n  </application> \n</manifest>\n```", "```java\npublic class OnThisDayActivity extends Activity implementsDataApi.DataListener, GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener \n{\n  private GoogleApiClient mGoogleApiClient;private boolean mResolvingError;\n  private static final String TAG = OnThisDayActivity.class.getName();\n  private OnThisDay onThisDay = null;\n  @Override\n  protected void onCreate(Bundle savedInstanceState) \n  {\n    super.onCreate(savedInstanceState);         \n    setContentView(R.layout.activity_on_this_day);\n    if (onThisDay == null) \n    {             \n      Toast.makeText(this, \"Fetching from Wikipedia...\", Toast.LENGTH_LONG).show();\n      mGoogleApiClient = new GoogleApiClient.Builder(this)                     \n        .addApi(Wearable.API)                     \n        .addConnectionCallbacks(this)                     \n        .addOnConnectionFailedListener(this)                     \n        .build();         \n    } \n    else \n    {             \n      showOnThisDay(onThisDay);         \n    }     \n  }\n  @Override\n  protected void onStart() \n  {\n    super.onStart();\n    if (!mResolvingError && onThisDay == null) \n    {             \n      Log.i(TAG, \"Connecting to Google Api Client\");\n      mGoogleApiClient.connect();\n    } \n    else \n    {             \n      showOnThisDay(onThisDay);         \n    }     \n  }\n  @Override\n  public void onConnected(Bundle connectionHint) \n  {         \n    Log.i(TAG, \"Connected to Data Api\");         \n    Wearable.DataApi.addListener(mGoogleApiClient, this);\n*// send a message to the companion app that it needs to fetch data* \n    sendMessage(Constants.ON_THIS_DAY_REQUEST, \"OnThisDay\".getBytes());        \n  }\n  private void sendMessage(final String path, final byte[] data) \n  {         \n    Log.i(TAG, \"Sending message to path \" + path);          \n Wearable.NodeApi.getConnectedNodes(mGoogleApiClient).setResultCallback (new ResultCallback<NodeApi.GetConnectedNodesResult>() \n    {\n    @Override\n    public void onResult(NodeApi.GetConnectedNodesResult nodes) \n    {\n      for (Node node : nodes.getNodes()) \n      {                             \n        Wearable.MessageApi.sendMessage(mGoogleApiClient, node.getId(), path, data);                         \n      }                     \n    }                 \n  });     \n}\n\n@Override\npublic void onConnectionSuspended(int i) \n{         \n  Log.i(TAG, \"Connection Suspended\");     \n}\n\n@Override\nprotected void onStop() \n{\n  if (null != mGoogleApiClient && mGoogleApiClient.isConnected()) \n  {             \n    Wearable.DataApi.removeListener(mGoogleApiClient, this);\n    mGoogleApiClient.disconnect();         \n  }\n  super.onStop();     \n}\n@Override\npublic void onDataChanged(DataEventBuffer dataEvents) \n{         \n  Log.i(TAG, \"###### onDataChanged\");\n  for (DataEvent event : dataEvents) \n  {\n  if (event.getType() == DataEvent.TYPE_CHANGED) \n  {                 \n    DataItem dataItem = event.getDataItem();                 \n    DataMap dataMap = DataMapItem.fromDataItem(dataItem).getDataMap();                 \n    String heading = dataMap.get(Constants.ON_THIS_DAY_DATA_ITEM_HEADER);                 \n    ArrayList<String> listItems = dataMap.get(Constants.ON_THIS_DAY_DATA_ITEM_CONTENT);\n    onThisDay = new OnThisDay(heading, listItems);                 \n    showOnThisDay(onThisDay);             \n    }         \n  }     \n}\nprivate void showOnThisDay(OnThisDay onThisDay) \n{         \n  TextView heading = (TextView) findViewById(R.id.on_this_day_heading);         \n  heading.setText(Html.fromHtml(onThisDay.getHeadingHtml()));         \n  TextView content = (TextView) findViewById(R.id.on_this_day_content);         \n  content.setText(Html.fromHtml(onThisDay.getListItemsHtml()));     \n}\n\n@Override\npublic void onConnectionFailed(@NonNull ConnectionResult connectionResult) \n{         \n  Log.i(TAG, \"Connection Failed \" + connectionResult);\n  mResolvingError = true;     \n  } \n}\n```", "```java\npublic class HandheldListenerService extends WearableListenerService implements GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener \n{\n  ...\n  @Override\n  public void onMessageReceived(MessageEvent messageEvent)   \n  {\n    super.onMessageReceived(messageEvent);     \n    Log.i(TAG, \"Message received\" + messageEvent);\n    if (Constants.ON_THIS_DAY_REQUEST.equals(messageEvent.getPath()))   \n    {\n      //read Today's content from Wikipedia\n      getOnThisDayContentFromWikipedia();     \n    } \n  }\n  private void getOnThisDayContentFromWikipedia() \n  {\n    // Instantiate the RequestQueue\n    RequestQueue queue = Volley.newRequestQueue(this);     \n    String url = \"https://en.wikipedia.org/wiki/Special:FeedItem/onthisday/\" + DATE_FORMAT.format(new Date()) + \"000000/en\";\n    // Request a string response from the provided URL.\n    StringRequest stringRequest = new StringRequest(Request.Method.GET, url,new Response.Listener<String>() \n    {\n      @Override\n      public void onResponse(String response) \n      {                     \n        Log.i(TAG, \"Wikipedia response  = \" + response);                      \n        Document doc = Jsoup.parse(response);                     \n        Element heading = doc.select(\"h1\").first();                     \n        Log.i(TAG, \"Heading node = \" + heading);if (heading != null) \n        {\n          Log.i(TAG, \"Wikipedia page heading = \" + heading);                          \n          PutDataMapRequest dataMapRequest = PutDataMapRequest.create(Constants.ON_THIS_DAY_DATA_ITEM_HEADER);                         \n          DataMap dataMap = dataMapRequest.getDataMap();\n// We add a timestamp is to make this dataMap 'dirty'. This lets the wearable get updates\n         dataMap.putLong(Constants.ON_THIS_DAY_TIMESTAMP, new Date().getTime());                          \n         dataMap.putString(Constants.ON_THIS_DAY_DATA_ITEM_HEADER, heading.text());                         \n         Element listNode = doc.select(\"ul\").first();if (listNode != null) \n      {                             \n        Elements itemNodes = listNode.select(\"li\");int size = itemNodes.size();                             \n        ArrayList<String> items = new ArrayList<String>();for (int i = 0; i < size; i++) \n       {                                   \n         items.add(itemNodes.get(i).text());                             \n       }                             \n    dataMap.putStringArrayList(Constants.ON_THIS_DAY_DATA_ITEM_CONTENT, items);                         \n    }                         \n    Log.i(TAG, \"Sending dataMap request ...\");                         \n    PendingResult<DataApi.DataItemResult> pendingResult = Wearable.DataApi.putDataItem(mGoogleApiClient,   dataMapRequest.asPutDataRequest());                         \n    PendingResult.setResultCallback(new ResultCallback<DataApi.DataItemResult>() \n    {\n      @Override\n      public void onResult(final DataApi.DataItemResult result) \n      {\n        if (result.getStatus().isSuccess()) \n        {                                     \n         Log.d(TAG, \"Data item set: \" + result.getDataItem().getUri());                                      \n        }                             \n      }                         \n    });                     \n  }                 \n}             \n}, \nnew Response.ErrorListener() \n{\n  @Override\n  public void onErrorResponse(VolleyError error) \n  {             \n    Log.e(TAG, \"Error reading online content = \" + error);         \n  }     \n});\n// Add the request to the RequestQueue.\nqueue.add(stringRequest); \n}\n```"]