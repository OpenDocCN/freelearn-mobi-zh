<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Generating a Never-Ending World"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Generating a Never-Ending World</h1></div></div></div><p>The unique challenge of an endless flyer-style game is in procedurally generating a rich, entertaining game world that extends as far as your player can fly. We will first explore level design concepts and tooling in Xcode; Apple added a built-in level designer to Xcode 6, allowing developers<a id="id208" class="indexterm"/> to arrange nodes visually within a scene. Once we become familiar with the SpriteKit level design methodology, we will create a custom solution to generate our world. In this chapter, you will build an entertaining world for our penguin game and learn to design and implement levels in SpriteKit for any genre of game.</p><p>The topics in this chapter include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing levels with the SpriteKit scene editor</li><li class="listitem" style="list-style-type: disc">Building encounters for Pierre Penguin</li><li class="listitem" style="list-style-type: disc">Integrating scenes into the game</li><li class="listitem" style="list-style-type: disc">Looping encounters for a never-ending world</li><li class="listitem" style="list-style-type: disc">Adding the star power-up at random</li></ul></div><div class="section" title="Designing levels with the SpriteKit scene editor"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Designing levels with the SpriteKit scene editor</h1></div></div></div><p>The<a id="id209" class="indexterm"/> scene editor is a valuable addition to SpriteKit. Previously, developers would be forced to hardcode <a id="id210" class="indexterm"/>positional values or rely on third party tools or custom solutions. Now, we can lay out our levels directly within Xcode. We can create nodes, attach physics bodies and constraints, create physics fields, and edit properties directly from the interface.</p><p>Feel free to experiment with the scene editor and familiarize yourself with its interface. To use the scene editor, add a new scene file to your game and then select the scene in the project navigator. Here is a simple example scene you might build for a platformer game:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_01.jpg" alt="Designing levels with the SpriteKit scene editor"/></div><p>In this <a id="id211" class="indexterm"/>example, I simply <a id="id212" class="indexterm"/>dragged and positioned <span class="strong"><strong>Color Sprite</strong></span> in the scene. If you are making an unsophisticated game, you can paint nodes that do not require texture-based animation directly within the scene editor. By editing physics bodies in the editor, you can even create entire physics-based games in the editor, adding only a few lines of code for the controls.</p><p>Complex games require custom logic and texture animation for every object, so we will implement a system in our penguin game that only uses the scene editor as a layout generation tool. We will write code to parse the layout data from the editor and turn it into fully functioning versions of the game classes we have created throughout this book. In this way, we will separate our game logic from our data with minimal effort.</p><div class="section" title="Separating level data from game logic"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Separating level data from game logic</h2></div></div></div><p>Level layout is <a id="id213" class="indexterm"/>data, and it is best to separate data from code. You increase flexibility by separating the level data into scene files. The benefits include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Non-technical contributors, such as artists and designers, can add and edit levels without changing any code.</li><li class="listitem" style="list-style-type: disc">Iteration<a id="id214" class="indexterm"/> time improves since you do not need to run the game in the simulator each time you need to view your changes. Scene editor layouts provide immediate visual feedback.</li><li class="listitem" style="list-style-type: disc">Each level is in a unique file, which is ideal for avoiding merge conflicts when using source control solutions like Git.</li></ul></div></div><div class="section" title="Using empty nodes as placeholders"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Using empty nodes as placeholders</h2></div></div></div><p>The scene editor<a id="id215" class="indexterm"/> lacks the ability to create reusable classes and there is no strongly typed method to link your code classes to scene editor nodes. Instead, we will use empty nodes as placeholders in the scene editor and replace them in the code with instances of our own classes. You will often see variations of this technique. For instance, the SpriteKit adventure game demo from Apple uses this technique for parts of its level design.</p><p>You can assign names to nodes in the scene editor and then query those names in your code. For example, you can create empty nodes named <span class="strong"><strong>Bat</strong></span> in the scene editor, and then write code to replace every node named "Bat" with an instance of our <code class="literal">Bat</code> class in the <code class="literal">GameScene</code> class.</p><p>To illustrate this concept, we will create our first encounter for the penguin game.</p></div></div></div>
<div class="section" title="Encounters in endless flying"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Encounters in endless flying</h1></div></div></div><p>Endless flyer games<a id="id216" class="indexterm"/> continue until the player loses. They do not feature distinct levels; instead, we will design "encounters" for our protagonist penguin to explore. We can create an endless world by stringing together <a id="id217" class="indexterm"/>encounters one after the other and randomly recycling from the beginning when we need more content.</p><p>The following image illustrates the basic concept:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_10.jpg" alt="Encounters in endless flying"/></div><p>A finished <a id="id218" class="indexterm"/>game might include 20 or more encounters to feel varied and random. We will create three encounters in this chapter to populate the encounter recycling system.</p><p>We will build <a id="id219" class="indexterm"/>each encounter in its own scene file, in the same way we would approach a separate level in a standard platformer or physics game.</p><div class="section" title="Creating our first encounter"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Creating our first encounter</h2></div></div></div><p>First, create an <a id="id220" class="indexterm"/>encounter folder group to keep our project organized. Right-click your project in the project navigator and create a new group named <code class="literal">Encounters</code>. Then, right-click on <code class="literal">Encounters</code> and add a new SpriteKit scene file (from the <span class="strong"><strong>iOS</strong></span> | <span class="strong"><strong>Resource</strong></span> category) named <code class="literal">EncounterBats.sks</code>.</p><p>Xcode will add the new scene file to your project and open the scene editor. You should see a gray background with a yellow border, indicating the boundaries of the new scene. Scenes default to 1024 points wide by 768 points tall. We should change these values. It will be easy to chain encounters together if each encounter is 1000 pixels wide and 650 points tall.</p><p>You can easily change the scene's size values in the SKNode inspector. Towards the upper right of the scene editor, make sure you have the SKNode inspector open by selecting the far right icon, and then change the width and height, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_02.jpg" alt="Creating our first encounter"/></div><p>Next, we will <a id="id221" class="indexterm"/>create our first placeholder node for the <code class="literal">Bat</code> class. Follow these steps to create an <span class="strong"><strong>Empty Node</strong></span> in the scene editor:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You can drag nodes from the object library. To open the object library, look towards the lower right side of the scene editor and select the circular icon, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/Image_B04532_06_03.jpg" alt="Creating our first encounter"/></div></li><li class="listitem">Drag an<a id="id222" class="indexterm"/> <span class="strong"><strong>Empty Node</strong></span> onto your scene.</li><li class="listitem">Using the SKNode inspector on the upper right side, name your node <code class="literal">Bat</code>, as shown in this screenshot:<div class="mediaobject"><img src="graphics/Image_B04532_06_04.jpg" alt="Creating our first encounter"/></div></li></ol></div><p>You will see <a id="id223" class="indexterm"/>
<span class="strong"><strong>Bat</strong></span> appear above the Empty Node. Great, we have created our first placeholder. We will repeat this process until we have built an entire encounter for Pierre Penguin to navigate. We can use more than just bats, but we need to first define the names we will use to label each node. If you are making games in a team, you will want to agree on labels beforehand. Here are the labels I will use for each game object:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Game object class</p>
</th><th style="text-align: left" valign="bottom">
<p>Scene editor node name</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Bat</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Bat</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Bee</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Bee</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Blade</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Blade</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Coin</code> (bronze)</p>
</td><td style="text-align: left" valign="top">
<p>BronzeCoin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Coin</code> (gold)</p>
</td><td style="text-align: left" valign="top">
<p>GoldCoin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Ghost</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Ghost</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MadFly</code>
</p>
</td><td style="text-align: left" valign="top">
<p>MadFly</p>
</td></tr></tbody></table></div><p>Feel free to build out your bat encounter. Add more empty nodes and use the labels until you are satisfied with the design. Try to picture the penguin character flying through the encounter.</p><p>In my encounter, I created an easier path through the bats, filled with bronze coins, and a more difficult <a id="id224" class="indexterm"/>path below the bats and above a blade, filled with gold coins. You can use my bat encounter, shown in the following image, for inspiration:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_05.jpg" alt="Creating our first encounter"/></div></div></div>
<div class="section" title="Integrating scenes into the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Integrating scenes into the game</h1></div></div></div><p>Next, we <a id="id225" class="indexterm"/>will create a new class to manage the encounters in our game. Add a new Swift file to your project and name it <code class="literal">EncounterManager.swift</code>. The <code class="literal">EncounterManager</code> class will loop through our encounter scenes and use the positional data to create the appropriate game object classes in the game world. Add the following code inside the new file:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

class EncounterManager {
    // Store your encounter file names:
    let encounterNames:[String] = [
        "EncounterBats"
    ]
    // Each encounter is an SKNode, store an array:
    var encounters:[SKNode] = []
    
    init() {
        // Loop through each encounter scene:
        for encounterFileName in encounterNames {
            // Create a new node for the encounter:
            let encounter = SKNode()
            
            // Load this scene file into a SKScene instance:
            if let encounterScene = SKScene(fileNamed: 
                encounterFileName) {
                // Loop through each placeholder, spawn the 
                // appropriate game object:
                for placeholder in encounterScene.children {
                    if let node = placeholder as? SKNode {
                        switch node.name! {
                        case "Bat":
                            let bat = Bat()
                            bat.spawn(encounter, position: 
                                node.position)
                        case "Bee":
                            let bee = Bee()
                            bee.spawn(encounter, position: 
                                node.position)
                        case "Blade":
                            let blade = Blade()
                            blade.spawn(encounter, position: 
                                node.position)
                        case "Ghost":
                            let ghost = Ghost()
                            ghost.spawn(encounter, position: 
                                node.position)
                        case "MadFly":
                            let madFly = MadFly()
                            madFly.spawn(encounter, position: 
                                node.position)
                        case "GoldCoin":
                            let coin = Coin()
                            coin.spawn(encounter, position: 
                                node.position)
                            coin.turnToGold()
                        case "BronzeCoin":
                            let coin = Coin()
                            coin.spawn(encounter, position: 
                                node.position)
                        default:
                            println("Name error: \(node.name)") 
                        }
                    }
                }
            }
                
            // Add the populated encounter node to the array:
            encounters.append(encounter)
        }
    }
    
    // We will call this addEncountersToWorld function from
    // the GameScene to append all of the encounter nodes to the
    // world node from our GameScene:
    func addEncountersToWorld(world:SKNode) {
        for index in 0 ... encounters.count - 1 {
            // Spawn the encounters behind the action, with
            // increasing height so they do not collide:
            encounters[index].position = CGPoint(x: -2000, y: 
                index * 1000)
            world.addChild(encounters[index])
        }
    }
}</pre></div><p>Great, you just <a id="id226" class="indexterm"/>added the functionality to use our scene file data inside the game world. Next, follow these steps to wire up the <code class="literal">EncounterManager</code> class in the <code class="literal">GameScene</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new instance of the <code class="literal">EncounterManager</code> class as a constant on the <code class="literal">GameScene</code> class:<div class="informalexample"><pre class="programlisting">let encounterManager = EncounterManager()</pre></div></li><li class="listitem">At the bottom of the <code class="literal">didMoveToView</code> function, call <code class="literal">addEncountersToWorld</code> to add each encounter node as a child of the <code class="literal">GameScene</code> class world node:<div class="informalexample"><pre class="programlisting">encounterManager.addEncountersToWorld(self.world)</pre></div></li><li class="listitem">Since the <code class="literal">EncounterManager</code> class spawns encounters far off the screen, we will temporarily move our first encounter directly in front of the starting player position to test our code. Add this line in the <code class="literal">didMoveToView</code> function:<div class="informalexample"><pre class="programlisting">encounterManager.encounters[0].position = CGPoint(x: 300, y: 0)</pre></div></li></ol></div><p>Run the project. You <a id="id227" class="indexterm"/>will see Pierre flying through your new bat encounter. Your game should look something like this screenshot:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_06.jpg" alt="Integrating scenes into the game"/></div><p>Congratulations, you have implemented the core functionality of using placeholder nodes in the scene editor. You can remove the line that positions this encounter at the beginning of the game, which we added in step 3. Next, we will create a system that repositions each encounter ahead of Pierre Penguin.</p></div>
<div class="section" title="Checkpoint 6-A"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Checkpoint 6-A</h1></div></div></div><p>You can download my project to this point at this URL:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-6">http://www.thinkingswiftly.com/game-development-with-swift/chapter-6</a>
</p></div>
<div class="section" title="Spawning endless encounters"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Spawning endless encounters</h1></div></div></div><p>We need at least three<a id="id228" class="indexterm"/> encounters to <a id="id229" class="indexterm"/>endlessly cycle and create a never-ending world; two can be on the screen at any one time and a third positioned ahead of the player. We can track Pierre's progress and reposition the encounter nodes ahead of him.</p><div class="section" title="Building more encounters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Building more encounters</h2></div></div></div><p>We need to<a id="id230" class="indexterm"/> build at least two more encounters before we can implement the repositioning system. You can create more if you like; the system will support any number of encounters. For now, add two more scene files to your game: <code class="literal">EncounterBees.sks</code> and <code class="literal">EncounterCoins.sks</code>. You can completely fill these encounters with bees, ghosts, blades, coins, and bats – have fun!</p><p>For inspiration, here is my bee encounter:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_07.jpg" alt="Building more encounters"/></div><p>Here is my coin encounter:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_08.jpg" alt="Building more encounters"/></div></div><div class="section" title="Updating the EncounterManager class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Updating the EncounterManager class</h2></div></div></div><p>We have to<a id="id231" class="indexterm"/> let the <code class="literal">EncounterManager</code> class know about these new encounters. Open the <code class="literal">EncounterManager.swift</code> file and add the new encounter names to the <code class="literal">encounterNames</code> constant:</p><div class="informalexample"><pre class="programlisting">// Store your encounter file names:
let encounterNames:[String] = [
    "EncounterBats",
    "EncounterBees",
    "EncounterCoins"
]</pre></div><p>We also need to keep track of the encounters that can potentially be on the screen at any given time. Add two new properties to the <code class="literal">EncounterManager</code> class:</p><div class="informalexample"><pre class="programlisting">var currentEncounterIndex:Int?
var previousEncounterIndex:Int?</pre></div><div class="section" title="Storing metadata in SKSpriteNode userData property"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec21"/>Storing metadata in SKSpriteNode userData property</h3></div></div></div><p>We are <a id="id232" class="indexterm"/>going to recycle the encounter nodes as Pierre moves through the world, so we need to add the functionality to reset all of the game objects in an encounter before placing it in front of the player. Otherwise, Pierre's previous trips through the encounter would knock nodes out of place.</p><p>The <code class="literal">SKSpriteNode</code> class<a id="id233" class="indexterm"/> provides a property named <code class="literal">userData</code> that we can use to store any miscellaneous data about the sprite. We will use the <code class="literal">userData</code> property to store the initial position of each sprite in the encounter so we can reset the sprites when we reposition an encounter. Add these two new functions to the <code class="literal">EncounterManager</code> class:</p><div class="informalexample"><pre class="programlisting">// Store the initial positions of the children of a node:
func saveSpritePositions(node:SKNode) {
    for sprite in node.children {
        if let spriteNode = sprite as? SKSpriteNode {
            let initialPositionValue = NSValue(CGPoint: 
                sprite.position)
            spriteNode.userData = ["initialPosition": 
                initialPositionValue]
            // Save the positions for children of this node:
            saveSpritePositions(spriteNode)
        }
    }
}

// Reset all children nodes to their original position:
func resetSpritePositions(node:SKNode) {
    for sprite in node.children {
        if let spriteNode = sprite as? SKSpriteNode {
            // Remove any linear or angular velocity:
            spriteNode.physicsBody?.velocity = CGVector(dx: 0,
                dy: 0)
            spriteNode.physicsBody?.angularVelocity = 0
            // Reset the rotation of the sprite:
            spriteNode.zRotation = 0
            if let initialPositionVal = spriteNode.userData?.valueForKey("initialPosition") as? NSValue {
                // Reset the position of the sprite:
                spriteNode.position = 
                    initialPositionVal.CGPointValue()
            }
            
            // Reset positions on this node's children
            resetSpritePositions(spriteNode)
        }
    }
}</pre></div><p>We want to call our new <code class="literal">saveSpritePositions</code> function on <code class="literal">init</code>, when we are first spawning the<a id="id234" class="indexterm"/> encounters. Update the <code class="literal">init</code> function of <code class="literal">EncounterManager</code>, below the line that appends the encounter node to the encounters array (the new line in bold):</p><div class="informalexample"><pre class="programlisting">// Add the populated encounter node to the encounter array:
encounters.append(encounter)
// Save initial sprite positions for this encounter:
<span class="strong"><strong>saveSpritePositions(encounter)</strong></span>
</pre></div><p>Lastly, we need a function to reset encounters and reposition them in front of the player. Add this new function to the <code class="literal">EncounterManager</code> class:</p><div class="informalexample"><pre class="programlisting">func placeNextEncounter(currentXPos:CGFloat) {
    // Count the encounters in a random ready type (Uint32):
    let encounterCount = UInt32(encounters.count)
    // The game requires at least 3 encounters to function
    // so exit this function if there are less than 3
    if encounterCount &lt; 3 { return }
    
    // We need to pick an encounter that is not
    // currently displayed on the screen.
    var nextEncounterIndex:Int?
    var trulyNew:Bool?
    // The current encounter and the directly previous encounter
    // can potentially be on the screen at this time.
    // Pick until we get a new encounter
    while trulyNew == false || trulyNew == nil {
        // Pick a random encounter to set next:
        nextEncounterIndex = 
            Int(arc4random_uniform(encounterCount))
        // First, assert that this is a new encounter:
        trulyNew = true
        // Test if it is instead the current encounter:
        if let currentIndex = currentEncounterIndex {
            if (nextEncounterIndex == currentIndex) {
                trulyNew = false
            }
        }
        // Test if it is the directly previous encounter:
        if let previousIndex = previousEncounterIndex {
            if (nextEncounterIndex == previousIndex) {
                trulyNew = false
            }
        }
    }
    
    // Keep track of the current encounter:
    previousEncounterIndex = currentEncounterIndex
    currentEncounterIndex = nextEncounterIndex
    
    // Reset the new encounter and position it ahead of the player
    let encounter = encounters[currentEncounterIndex!]
    encounter.position = CGPoint(x: currentXPos + 1000, y: 0)
    resetSpritePositions(encounter)
}</pre></div></div></div><div class="section" title="Wiring up EncounterManager in the GameScene class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Wiring up EncounterManager in the GameScene class</h2></div></div></div><p>We will track Pierre's progress in<a id="id235" class="indexterm"/> the <code class="literal">GameScene</code> class and call the <code class="literal">EncounterManager</code> class code when appropriate. Follow these steps to wire up the <code class="literal">EncounterManager</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new property to the <code class="literal">GameScene</code> class to track when we should next position an encounter in front of the player. We will start with a value of <code class="literal">150</code> to spawn the first encounter right away:<div class="informalexample"><pre class="programlisting">var nextEncounterSpawnPosition = CGFloat(150)</pre></div></li><li class="listitem">Next, we simply need to check if the player moves past this position in the <code class="literal">didSimulatePhysics</code> function. Add this code at the bottom of <code class="literal">didSimulatePhysics</code>:<div class="informalexample"><pre class="programlisting">// Check to see if we should set a new encounter:
if player.position.x &gt; nextEncounterSpawnPosition {
    encounterManager.placeNextEncounter( nextEncounterSpawnPosition)
    nextEncounterSpawnPosition += 1400
}</pre></div></li></ol></div><p>Fantastic – we have added all the functionality we need for endlessly looping encounters in front of the player. Run the project. You should see your encounters looping in front of you forever. Enjoy flying through your hard work!</p></div></div>
<div class="section" title="Spawning the star power-up at random"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Spawning the star power-up at random</h1></div></div></div><p>We still need to add the <a id="id236" class="indexterm"/>star power-up into the <a id="id237" class="indexterm"/>world. We can randomly spawn a star every 10 encounters to add some extra excitement. Follow these steps to add the star logic:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new instance of the <code class="literal">Star</code> class as a constant on the <code class="literal">GameScene</code> class:<div class="informalexample"><pre class="programlisting">let powerUpStar = Star()</pre></div></li><li class="listitem">Call the star's <code class="literal">spawn</code> function, anywhere inside the <code class="literal">GameScene didMoveToView</code> function:<div class="informalexample"><pre class="programlisting">// Spawn the star, out of the way for now
powerUpStar.spawn(world, position: CGPoint(x: -2000, y: - 2000))</pre></div></li><li class="listitem">Inside <a id="id238" class="indexterm"/>the <code class="literal">GameScene didSimulatePhysics</code> function, update<a id="id239" class="indexterm"/> your new encounter code as follows:<div class="informalexample"><pre class="programlisting">// Check to see if we should set a new encounter:
if player.position.x &gt; nextEncounterSpawnPosition {
encounterManager.placeNextEncounter(
    nextEncounterSpawnPosition)
    nextEncounterSpawnPosition += 1400
    
    // Each encounter has a 10% chance to spawn a star:
    let starRoll = Int(arc4random_uniform(10))
    if starRoll == 0 {
        if abs(player.position.x - powerUpStar.position.x) &gt; 1200 {
            // Only move the star if it is off the screen.
            let randomYPos = CGFloat(arc4random_uniform(400))
            powerUpStar.position = CGPoint(x: 
                nextEncounterSpawnPosition, y: randomYPos)
            powerUpStar.physicsBody?.angularVelocity = 0
            powerUpStar.physicsBody?.velocity = CGVector(dx: 0, dy: 0)
        }
    }
}</pre></div></li></ol></div><p>Run the game again and you should see a star spawn occasionally inside your encounters, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/Image_B04532_06_09.jpg" alt="Spawning the star power-up at random"/></div></div>
<div class="section" title="Checkpoint 6-B"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Checkpoint 6-B</h1></div></div></div><p>To download my project to this point, visit this URL:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-6">http://www.thinkingswiftly.com/game-development-with-swift/chapter-6</a>
</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Summary</h1></div></div></div><p>Great job – we have covered a lot of ground in this chapter. You learned about Xcode's new scene editor, learned to use the scene editor to lay out placeholder nodes, and interpreted the node data to spawn game objects in our game world. Then, you created a system to loop encounters for our endless flyer game.</p><p>Congratulate yourself; the encounter system you built in this chapter is the most complex system in our game. You are officially in a great position to finish your first SpriteKit game!</p><p>Next, we will look at creating custom events when game objects collide. We will add health, damage, coin pick-up, invincibility, and more in <a class="link" href="ch07.html" title="Chapter 7. Implementing Collision Events">Chapter 7</a>, <span class="emphasis"><em>Implementing Collision Events</em></span>.</p></div></body></html>