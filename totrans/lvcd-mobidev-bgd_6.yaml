- en: Chapter 6. Making a Reminder Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Note to self…*'
  prefs: []
  type: TYPE_NORMAL
- en: '*To-do lists, alarms, birthday reminders, notes, shopping lists, and the list
    goes on. There should be an app to keep a list of the different apps that keep
    lists! At the time of writing this book, there were already over 8,000 iOS apps
    that were lists, planners, or alarms. Perhaps, there''s room for one more…*'
  prefs: []
  type: TYPE_NORMAL
- en: It could take a lot of research, and money, to explore all the reminder apps
    that are out there. The majority of apps will have a lot of features that you'll
    never use and at least one vital feature that is missing. If you're lucky, some
    combination of apps may do all the things you want in a reminder. However, don't
    forget that you use LiveCode and can make your own reminder app!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss what is meant by a *reminder*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create some time measuring utility functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a data structure to store information about an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make use of mobile device "notifications"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a flexible reminder app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of reminders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the list of a few of the things that you might call a "reminder":'
  prefs: []
  type: TYPE_NORMAL
- en: A shopping list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Christmas present list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A to-do list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alarm clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An egg timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A birthday reminder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, is there a single way to describe all of these things? Well, it may get
    wordy, but a reminder could be described as a notification message or sound that
    either appears automatically or shows when you look for it. It is used to let
    you know that a certain time has passed, a moment has arrived, or that an outstanding
    task has not been completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'See, pretty wordy. Breaking it down like this helps us to see what features
    a reminder app will need to have. Before getting to that, let''s test the definition
    against the preceding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A shopping list**: In this case, you go looking for the reminder. Although,
    we could set it up to automatically show when your location happens to be near
    the store! Other than that, this is effectively a task that has not been completed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Christmas present list**: This is much the same as a shopping list, but
    it could use a timed message that let''s you know how few shopping days are left
    for you to buy a Christmas present for your loved ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A to-do list**: Again, this is simply a list of tasks that are not yet complete.'
  prefs: []
  type: TYPE_NORMAL
- en: '**An alarm clock**: This gives you a notification that a moment in time has
    been reached.'
  prefs: []
  type: TYPE_NORMAL
- en: '**An egg timer**: This is a notification of a certain amount of time that has
    passed, which could be used as a sequence of such events that might be used in
    a cooking-buddy app.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A birthday reminder**: This shows whether a certain moment has been reached.
    Really though, you want to set the reminder so that it can notify you ahead of
    the actual event.'
  prefs: []
  type: TYPE_NORMAL
- en: At least as a starting point, we can use the definition to guide us as we outline
    the abilities the app will need to have.
  prefs: []
  type: TYPE_NORMAL
- en: Timing of notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mobile notifications that can be created with LiveCode will be sent the
    moment you ask for it to be sent. Strangely though, the value is based on the
    number of seconds since midnight on January 1st, 1970, specifically, in part of
    London! Well, it's named after an area of London called Greenwich.
  prefs: []
  type: TYPE_NORMAL
- en: '**Greenwich Mean Time**, often referred to as **GMT**, has been used as the
    standard for measuring time. It is somewhat superseded by **UTC** (**Coordinated
    Universal Time**), but in either case, it represents the exact current time at
    least for countries that are within the same time zone as Greenwich. The rest
    of us add or subtract some amount of time from that value.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to adapt to the fact that the Earth doesn't go around the Sun in an
    exact number of days or even an exact number of quarter days, calendars are adjusted
    by one day every four years, though not on 100 year boundaries, except for every
    400 years (for example, the year 2000 was a leap year). These adjustments are
    still not enough to keep the clocks on time! The clocks are out of time by about
    0.6 seconds a year, and so there are "Leap Seconds" added to compensate for that.
    In theory, Leap Seconds could be used to subtract one second, but as of yet, this
    hasn't been needed, as they have only been used to add one second.
  prefs: []
  type: TYPE_NORMAL
- en: None of this affects the number of seconds since midnight of January 1, 1970,
    but it does mean that converting LiveCode's **seconds** into time and date using
    your own arithmetic won't give you the right time. Yet, it's still used as the
    basis for notifications. This value is usually referred to as Unix Time.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter much though if you end up sending someone a Happy Birthday
    message 25 seconds early! Don't worry, the way we'll calculate the notification
    time will take care of the oddity.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time pickers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, mobile notifications use the number of
    seconds since midnight of January 1, 1970 and don't add on the 25 seconds, or
    Leap Seconds, that have occurred since then. When we present the date and time
    pickers to the user, the selections the user makes will come back as the actual
    current or future time. We will adjust for that later.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating date and time pickers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make another test-rig stack, which we''ll use to try out some date and
    time pickers:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Mainstack, name it `ReminderFunctions`, and save the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two fields and two new buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one field `dateinseconds` and the other `timeinseconds`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the buttons as `Pick Date` and `Pick Time`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the script of the **Pick Date** button to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the **Pick Time** button script to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the Standalone Application Settings so that you can test on iOS or Android.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your **Test Target** (in the following steps, you can see that the iPhone
    simulator was chosen in this case) and do a **Test**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Pick Date** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `December 25th, 2012` and click on **Done**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of seconds from midnight of January 1, 1970 to midnight of Christmas
    day 2012 will be shown in the first field that you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Pick Time** button and set the time to `1 am`. The following
    image shows how the picker looks different on iOS and the Android simulator:![Time
    for action – creating date and time pickers](img/image00283.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Done** and you will see the number of seconds from midnight of January
    1 1970 to 1 AM of the day you do this test in the right-hand side field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just made two simple scripts that call the native date or time picker and
    convert the result into seconds to then show them in a field. What is interesting
    to note is that for the Pick Time case, it doesn't return the number of seconds
    of the current day, that is, all the seconds since midnight of January 1, 1970\.
    In order to set a notification time for a particular time of a particular date,
    we have to do a little arithmetic. We'll go into that a little later when we make
    the actual reminder app in the *Making the reminders app* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – OA (odd acronyms!)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that the acronym for "Coordinated Universal Time" is UTC
    and not CUT. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: CUT is too common a word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So as not to upset the French.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The acronym committee members were dyslexics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: 2'
  prefs: []
  type: TYPE_NORMAL
- en: The French may not have proactively objected, but indeed, the acronym of UTC
    was chosen so as to not specifically match the English version of the phrase.
    It also fell in nicely with the other acronyms such as UT0, UT1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Where?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is something we can do in a mobile reminder app that would never work
    in a pen and paper version of a reminder; we can present the list of reminders
    based on where you are at the time that you check it! To make use of location,
    you need to know where you are now and how far your location is from the place
    associated with the reminder.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, there was no ability in LiveCode to directly
    pull in a map so that you could choose locations other than the one you are at
    right now. So, we'll work within that limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That being said, there is `mergMK` external (for more information, refer to
    [http://mergext.com](http://mergext.com)), which works with iOS versions before
    7.0 and was being updated at the time of writing this book. You could also use
    a combination of HTML and JavaScript as described in the article at [http://stackoverflow.com/questions/25629786/fetch-data-from-html-file-in-livecode](http://stackoverflow.com/questions/25629786/fetch-data-from-html-file-in-livecode).
    However, these are both beyond the scope of this beginner's book
  prefs: []
  type: TYPE_NORMAL
- en: The general technique while reading a mobile device's sensors, is to start tracking
    a given sensor, detect when changes happen, and to stop tracking the sensor. You
    can take a reading from the sensor at any time between the start and stop tracking
    commands. You can also specify how detailed a report you want and whether you
    want a precise reading. The precise reading of the location would dictate whether
    GPS was used or not. The advantage of using GPS is that you get greater accuracy
    (assuming there's a clear signal at the time) and the disadvantages are that it
    uses more battery power, and devices that don't have GPS cannot use this feature.
    When using location as part of a reminder, we're mainly interested in whether
    you're at home, the office, or perhaps at the supermarket. So, we'll use the less
    precise reading, the GPS one would be an overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – trying out native location tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Later in this chapter, we will add in a feature to allow the app user to add
    a set of favorite locations. For the moment, we''ll just try out the basic functions.
    Location doesn''t work in the simulators; you''ll have to try this on a real device:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the test-rig stack from the preceding steps and add a `Get Location` button
    and a `location` field. Make sure that the `location` field is as wide as the
    card window; it will show three long numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the script of the button to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `true` value in the second line is the one that defines a *loosely* value
    saying that we don't need the precision of GPS. The `false` value in the third
    line says that we don't need detailed information to be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Standalone Application Settings** and choose your target device as **iOS**
    or **Android**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For iOS, set the **Display Name**, **Internal App ID**, and **Profile**. Choose
    your device and SDK version):![Time for action – trying out native location tracking](img/image00284.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, in the iOS **Requirements and Restrictions** section, select **Location
    Services** and **GPS** as required. In the app, you will also have to accept Location
    Services when iOS prompts for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Android, set the **Label**, **Identifier**, and **Minimum Android Version**
    fields:![Time for action – trying out native location tracking](img/image00285.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, in the **Application Permissions** part of the Android settings,
    make sure that you have asked permission to get the **Coarse Location** permission:![Time
    for action – trying out native location tracking](img/image00286.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Save Standalone Application** and install the app onto your device.
    Follow the description given in [Chapter 2](part0026.xhtml#aid-OPEK1 "Chapter 2. Getting
    Started with LiveCode Mobile"), *Getting Started with LiveCode Mobile* if you
    need a reminder on how to do that!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the app, try the **Pick Date** and **Pick Time** buttons to see how they
    bring up the native controls and then click on the **Get Location** button. Three
    long numbers should appear in the `location` field:![Time for action – trying
    out native location tracking](img/image00287.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, there is very little code needed to read a location! If this
    was a tracking app, you would need to keep the tracking open and have functions
    to respond to the change of location messages, but for our app, we just need to
    know where you are at the time you take a look at your list of reminders.
  prefs: []
  type: TYPE_NORMAL
- en: The numbers that are shown in the location field are the latitude, longitude,
    and elevation of the position of the device. However, how will we use these numbers…?
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the distance between two points on the Earth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The plan is to make your app able to sort your reminders list in order of distance
    from where you are right now. Let's say you really use this app a lot and have
    dozens of reminders. The reminder you created about buying some bread may be at
    the bottom of the list, but if you have assigned the location of the supermarket
    to that reminder, sorting the list while you're outside the supermarket should
    bring the shopping list items to the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'When faced with a problem such as this one, how will you come to know the distance
    between two points on Earth; Google is a good starting place for you to find that
    out! It takes very little research and time to find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The article in this URL discusses the original formula for calculating this
    and then shows a JavaScript function. If you find it hard to convert the equation
    into LiveCode handlers, you ought to be able to convert the JavaScript, line by
    line, into the LiveCode equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'No need to type this in just yet, we''ll integrate it later; however, if you
    want to have a play, put these lines into the stack script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Try this in the message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This appears as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the distance between two points on the Earth](img/image00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, you should see a value of **5645.48065**.
    The two locations are somewhere near New York and London, and that value would
    be the distance in kilometers between the two along the surface of the Earth.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – what floor is my apartment on?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examine the screenshot (the one timed "6:53 PM", which precedes the previous
    screenshot), and given the clue that the building I live in is not much above
    sea level, which floor do I live on?
  prefs: []
  type: TYPE_NORMAL
- en: 40th floor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 73 floors below ground
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 11th floor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I'm homeless
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: 3'
  prefs: []
  type: TYPE_NORMAL
- en: The numbers coming back from the location sensor return as latitude, longitude,
    and elevation. This would make the elevation on where the device was at that time
    be about 37.5 meters, which is much too low to be the 40th floor. There is enough
    information in the screenshot for you to know exactly when it was taken and where
    on Earth!
  prefs: []
  type: TYPE_NORMAL
- en: Information needed in a reminder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're well on the way to know how to set a time and date for the reminder notification
    to occur, and we will be able to sort the reminders based on the distance from
    where we are. However, what exact information do we need in the reminder itself?
  prefs: []
  type: TYPE_NORMAL
- en: If this were a birthday reminder app, you would just need to ask for the person's
    name and the date of their birthday. If it were a shopping list app, you would
    need the name of the item and maybe the quantity. For a timer, you would need
    to ask what the event is called and would need to set a time for the event.
  prefs: []
  type: TYPE_NORMAL
- en: Here though, we're trying to make a completely flexible reminder app; it would
    be up to the user to describe the item in whatever manner they wish. So, we'll
    just ask for a title and a brief description. We will also need to offer the option
    of setting a date, time, an associated location, and whether an alert sound should
    be played.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to think about is; where will we store the information for the
    list of reminders? While making the WebScraper app in [Chapter 4,](part0056.xhtml#aid-1LCVG2
    "Chapter 4. Using Remote Data and Media") *Using Remote Data and Media*, we chose
    to duplicate the main application stack into the documents folder and to then
    jump into that copy of the stack. This enabled the ability to save changes to
    the stack. The reminder app is a simpler case; we're only trying to store a few
    text strings to define each reminder and it would be simpler to just write a text
    file using this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to allow the user to make a list of locations, so that a reminder can
    be associated with that location. Rather than writing a different text file, we
    will make the first piece of information in each entry be the function of that
    entry. Right now, the only two functions are `location` and `reminder`. The following
    is an example of how the text file might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Between each item in the line is a tab character, which will be used to separate
    the parts of the entry. The structure for a location is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function: `Location`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location's title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a reminder, it''s:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function: `Reminder`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Brief description
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notification time in seconds since midnight of January 1, 1970
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A location associated with this reminder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whether to play an alert sound (`true` or `false`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making the reminder app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ok, enough groundwork! Let's start making the reminder app. Rather than adding
    a feature at the time, along with any scripts, we'll make the various cards that
    will be needed to create the app's **GUI** (**graphical user interface**) first
    and then go back and add the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to make the first card of the stack be a place where you can see
    the current reminders, sort them by time or location, and add new reminders and
    locations. Then, we will make a second card to enter the location details and
    a third card to enter the details for a new reminder.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the reminder app screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The steps shown here are going to use the standard LiveCode fields and buttons,
    but feel free to make your version more attractive!
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Mainstack, give it the name `EasyReminder`, and save it. Other
    names, such as `Simple Reminders`, might be more descriptive, but it would be
    too long a name if you're using an older iPhone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the card size to the size of your device. The screenshots shown in this
    section are based on an older iPhone-sized stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Standalone Application Settings** and set the values in the same way
    that we did while testing the **Location** feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the name of the first card to be `home`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Sort by Time** button, a **Sort by Location** button, one field named
    `reminders`, another field named `data`, and two buttons named `Create Reminder…`
    and `Create Location…`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one more button named `Delete Location or Reminder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that both the fields have their **Lock text** and **Don't wrap** box
    checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have a screen that looks something like the following screenshot:![Time
    for action – creating the reminder app screens](img/image00289.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new card and name it `location`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a field and set its contents to: `Enter the latitude and longitude for
    this location`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two input fields named `latitude`, and `longitude`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a button named `Set to Current Location`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Avoid typos**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although we have placed a field for you to type in the location by hand, use
    the **Set to Current Location** button if possible or at least use that at your
    current location to see the format that is required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add another instructions field that says: `Enter a name for this location:`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a third input field named `location name`. Note that on older phones with
    smaller screens, this field location needs to be toward the top of the screen,
    so that it isn't covered by the keyboard popup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add a button named `Add Location` and `Cancel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this card, all the three fields need their **Lock text** box to be unchecked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The card should look like the following screenshot:![Time for action – creating
    the reminder app screens](img/image00290.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a third card and name it `reminder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two instructions fields that say: `Enter a title for this reminder:` and
    `Enter a brief description:`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two more input fields named `title`, and `description`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three buttons named `Set Related Location`, `Set Date`, and `Set Time`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three fields next to those buttons, which will be used to show the user
    that the selection they made has taken place. Name the fields `location field`,
    `date field`, and `time field`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a checkbox button named `Play Alert Sound`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, create two more buttons named `Add Reminder` and `Cancel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange all of these elements to appear as shown in the following screenshot:![Time
    for action – creating the reminder app screens](img/image00291.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've made all of the screens needed for the app to function. That was the easy
    bit. Just wait until you see how much typing you are going to do!
  prefs: []
  type: TYPE_NORMAL
- en: Stack-level scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is quite a bit of code ahead. Describing it feature by feature would require
    us to jump all over the place, which would add to the existing scripts in some
    cases and we would easily get lost in this situation. So, instead of doing it
    that way, we'll look at the code for each card at a time and also at the handlers
    that go into the stack script. It's shown here in the *Time for action* section,
    mainly to give you a break now and then! Without further ado, the stack script…
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding stack-level functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this app, we''re going to put some of the logic in the buttons on the cards
    themselves, but it still leaves a good amount that will have to go into the Stack
    script. To make it less overwhelming, we''ll show one or two functions at a time
    followed by some explanation about any interesting points in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Stack script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the the following handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Android OS keyboards generally have a button dedicated to the function putting
    the keyboard away. On iOS, this isn't the case, as the button that sits where
    the *Return* key should be, may have a special word instead, such as *Send*, or
    *Done*. Unfortunately, we are entering text into fields that are able to take
    a return character. To solve the issue, we set the Return button to say *Done*,
    which will lead the user to expect the keyboard to go away when that button is
    pressed. We will also trap the `returnInField` message and use it as a way to
    actually put the keyboard away.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, type in the functions that will read, and write the list of reminders
    as a text file to the documents folder on your device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: These two functions are using the straightforward ability that LiveCode has
    to read and write text files. Note that `specialFolderPath` is being used to help
    work out where the file will be saved. This works even when you test on desktop
    machines. The LiveCode Dictionary shows a full list of special folder paths, including
    many that don't apply to mobile apps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can put the following `showdata` function into the Home card''s Card script
    as well, but having it in the Stack level keeps it near other functions that are
    related to it. Type it in now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you recall the sample text file from earlier, the `showdata` function takes
    each line and splits the tab delimited items into chunks of information to present
    to the user. One cute trick is that the notification time, which is a long number
    of seconds, is converted into a human-readable form, showing both the date and
    time of the notification. The `data` field is used to show the raw data that has
    been saved. In the final application, you would not show this, but it's handy
    to check whether the reminder information looks correct or not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last functions in the Stack script are used to set up the notifications
    themselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Many mobile apps that use notifications don't ever clear them. In general, maybe
    they don't need to be cleared. Once they go by, they're gone for good! Well, not
    always. Sometimes, you'll go into an app just ahead of when a notification comes
    and you'd do the task, only to then be pestered with notifications about something
    you already did! In our app, we clear all the notifications that were due and
    recreate the whole list again. This way, any that you have deleted won't come
    back to haunt you later. To help in debugging, `alertPayload` is filled in with
    the entire reminder entry and will be shown to you when the notification comes
    in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to getting your fingers nicely warmed up, you entered all the functions
    to read and write the reminders data and to create and receive the notification
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Home card scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're not going to put any scripts into the card level; they can just be inside
    various buttons. Starting with the ones on the first card.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the home card buttons work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Sort** **by Location** button''s script is quite something. You should
    look forward to that! First, we''ll start with the **Sort by Time** button:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the script of the **Sort by Time** button on the first card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following short handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: LiveCode's sort command is powerful and in the preceding case, it sorts the
    list of reminders based on the notification seconds value. Once the lines are
    sorted, the list is recreated for the user to see and the text file is rewritten.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Get mentally prepared and then edit the script of the **Sort by Location** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in all of the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The first part of the `mouseUp` handler just gets your current location. The
    `distance` and `toRad` functions are the same ones we looked at earlier. The magic
    happens in the way that the sort line uses a function to determine the sort order.
    By passing the Location that you associated with each reminder into the `getdistance`
    function, it's possible to run through the list of locations to find a match and
    to then use that location's latitude and longitude to measure the distance from
    your current location. This distance is then used by the sort command to decide
    the order of the lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For a moment''s relaxation, edit the **Create Reminder…** button script and
    set it to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, set the **Create Location…** button script to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the last script for this card, edit the **Delete Location or Reminder**
    button script and type the following in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The delete handler uses `mobilePick` with a particular set of parameters. One
    interesting parameter is `checkmark`. Asking for that type of picker will then
    show a list with checkboxes in it when you're on iPad or Android. That would enable
    you to choose several entries to delete in one go. Hence, the repeat loop that
    goes through as many items as you choose.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All being well, you have recovered by now after trying to understand the sort-by-location
    function! You can at least see how tough the Stack script would have been if all
    of this code would have been placed in that one location. Let's go on to the next
    card…
  prefs: []
  type: TYPE_NORMAL
- en: Creating a location card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next up, we will create the card that we will show when the user touches the
    **Create a Location…** button on the first card.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the location card work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Location card has three fields in it for latitude, longitude, and a title
    for the location. The user could type in the details manually, but if they happen
    to be at the location in question, there''s a button there that will grab the
    location and fill in the numbers automatically. The following steps will guide
    you in making the location card work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the script of the **Set to Current Location** button and type in the following
    lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Nothing too tricky here; we just captured the location and stored the latitude
    and longitude entries in the two fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script of the **Cancel** button and change it to the following easy
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the last item for this card, edit the **Add Location** button script and
    type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of the handler just checks whether the user entered the required information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot less has happened than what happened on the first card! However, it was
    important all the same. Now, we have a way where the user can set up a location
    to be used by the reminders that they have created. That's where we're headed
    now…
  prefs: []
  type: TYPE_NORMAL
- en: The reminder entry form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This last card is essentially an entry form; we just want to ask the user what
    the reminder is for. There are some tricky aspects to it though and one or two
    lengthy functions to cope with that.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – taking in information about the reminder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Reminder card makes good use of pickers. There is little typing for the
    user to do, and because they pick an entry from a list we present, there''s a
    good chance the information won''t have any typos in it! Use the following steps
    for taking in information about the reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the script of the **Set Related Location** button and type in the following
    lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We made the first word of each line in the reminders data either Location or
    Reminder. Here's one place where we can make use of that. Once we pull out the
    lines that are "Location", presenting them inside a picker is easy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the script of the **Set Date** button and change it to the following easy-to-understand
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the script of the **Set Time** button to the following, which is almost
    an identical script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **Cancel** button script is the same as it is on the Location card given
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last, and far from least, the **Add Reminder** button script does all the hard
    work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the preceding script just combines the different bits of information
    together into one reminder entry with the parts delimited with a tab character.
    However, there is one bit of cute arithmetic going on in there too. At the start
    of this chapter, we looked at how Unix Time differs from the actual time at a
    rate of 0.6 seconds per year. If you want to set a notification at 8 AM five years
    from now, you can't take the value that the Set Time button gave you because that
    refers to today's 8 AM. You can't take the value that Set Date gave you because
    that would be midnight. So, by converting the time value to the short date format
    and then back to the seconds format, you can find out what the Unix Time was at
    midnight of the current day. Subtracting that from the value that Set Time gave
    you let's you know the number of seconds since midnight, regardless of how many
    seconds behind Unix Time is. Adding that value to the one from Set Date will give
    us an exact Unix Time in seconds for the notification to occur. Under iOS, there
    is a picker type that allows you to set the date and time together, but as that
    isn't on Android, we've used a way that works for both.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Phew! We got to the end! Try to run the app on your device. If your fingers
    aren't too numb, that is! Honestly, you could bet a fortune that it won't work
    the first time, but if it works well enough to show the raw text in the data field
    on the first card, hopefully, you'll be able to track down any errors in the code.
    You can also type in some test data into the stack on your computer and at least
    test the functions that don't require device-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – nice transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Really, if you've managed to get through and entered all that code to the point
    that the app is working, you're already a hero! However, read the section in the
    iOS and Android release notes for LiveCode about *Visual effects support*. Check
    whether you can get some typical mobile OS transitions happening as you go to
    and from the different cards.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was way more exciting than expected! A reminder app is absolutely
    not quite as impressive as Angry Birds, but making use of the location features
    of a mobile device makes it a little more novel. Along the way, we covered the
    process of reading and writing data to the special documents folder as well as
    the use of pickers for straightforward lists, dates, and time. We also showed
    how to read the current location of the device and how to set up local notification
    events.
  prefs: []
  type: TYPE_NORMAL
- en: In the best of cases, you can manage to make a mobile app in a few hours or
    a few days, but there is quite a lot that goes on before you can submit the app
    to the various app stores. Sounds like a good topic for the next chapter!
  prefs: []
  type: TYPE_NORMAL
