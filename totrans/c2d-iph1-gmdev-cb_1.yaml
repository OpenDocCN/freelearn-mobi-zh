- en: Chapter 1. Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。图形
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简介
- en: Drawing sprites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制精灵
- en: Coloring sprites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为精灵上色
- en: Animating sprites
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画精灵
- en: Drawing OpenGL primitives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制 OpenGL 原语
- en: Playing video files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放视频文件
- en: Grid, particle, and motion streak effects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格、粒子以及运动条纹效果
- en: Using Retina Display mode
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视网膜显示模式
- en: 1D and 2D Ease Actions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1D 和 2D 缓动动作
- en: Rendering and texturing 3D Cubes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染和纹理化 3D 立方体
- en: Rendering a texture filled polygon
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染填充纹理的多边形
- en: Animating a texture filled polygon
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画填充纹理的多边形
- en: Swapping palettes using layers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图层交换调色板
- en: Swapping palettes using CCTexture2DMutable
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CCTexture2DMutable 交换调色板
- en: Using AWTextureFilter for blur and font shadows
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWTextureFilter 进行模糊和字体阴影
- en: Taking and using screenshots
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获和使用屏幕截图
- en: Using CCParallaxNode
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CCParallaxNode
- en: Lighting using glColorMask
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 glColorMask 进行光照
- en: Introduction
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Cocos2d** is first and foremost a rich graphical API which allows a game
    developer easy access to a broad range of functionality. In this chapter we will
    go over some more advanced features of Cocos2d and how you can use these features
    to serve a variety of different purposes. We''ll also explain advanced techniques
    that are not yet part of the Cocos2d source.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cocos2d** 首先是一个丰富的图形 API，它允许游戏开发者轻松访问广泛的功能。在本章中，我们将介绍 Cocos2d 的更多高级功能以及您如何使用这些功能来服务于各种不同的目的。我们还将解释尚未成为
    Cocos2d 源代码一部分的高级技术。'
- en: For the purposes of this chapter **Graphics** can be considered an umbrella
    term. We will also go over advanced techniques using **Actions** and **Particles**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章节的目的，**图形**可以被认为是一个总称。我们还将介绍使用**动作**和**粒子**的高级技术。
- en: Drawing sprites
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制精灵
- en: The most fundamental task in 2D game development is drawing a **sprite**. Cocos2d
    provides the user with a lot of flexibility in this area. In this recipe we will
    cover drawing sprites using `CCSprite`, spritesheets, `CCSpriteFrameCache`, and
    `CCSpriteBatchNode`. We will also go over **mipmapping**. To keep things fun and
    interesting, many recipes in this book will have a distinct theme. In this recipe
    we see a scene with Alice from Through The Looking Glass.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2D 游戏开发中最基本的任务是绘制一个**精灵**。Cocos2d 为用户提供了在这个领域的大量灵活性。在本食谱中，我们将介绍使用 `CCSprite`、精灵表、`CCSpriteFrameCache`
    和 `CCSpriteBatchNode` 绘制精灵，还将介绍**米波映射**。为了使内容有趣且引人入胜，本书中的许多食谱都将有一个独特的主题。在本食谱中，我们看到的是来自《通过镜子看》的艾丽斯场景。
- en: '![Drawing sprites](img/4002_01_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![绘制精灵](img/4002_01_01.jpg)'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.PacktPub.com](http://www.PacktPub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    并注册以将文件直接通过电子邮件发送给您。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for the full working code of
    this recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取本食谱的完整工作代码。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe takes us through most of the common ways of drawing sprites:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将带我们了解绘制精灵的多数常见方法：
- en: 'Creating a CCSprite from a file:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件创建 CCSprite：
- en: 'First, we have the simplest way to draw a sprite. This involves using the CCSprite
    class method as follows:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们有绘制精灵最简单的方法。这涉及到使用 CCSprite 类的方法，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the most straightforward way to initialize a sprite and is adequate
    for many situations.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是初始化精灵最直接的方法，对于许多情况来说都是足够的。
- en: 'Other ways to load a sprite from a file:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件加载精灵的其他方法：
- en: After this, we will see examples of `CCSprite` creation using `UIImage/CGImageRef,
    CCTexture2D,` and a `CCSpriteFrame` instantiated using a `CCTexture2D` object.
    `CGImageRef` support allows you to tie Cocos2d into other frameworks and toolsets.
    `CCTexture2D` is the underlying mechanism for texture creation.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，我们将看到使用 `UIImage/CGImageRef`、`CCTexture2D` 和使用 `CCTexture2D` 对象实例化的 `CCSpriteFrame`
    创建 `CCSprite` 的示例。`CGImageRef` 的支持允许您将 Cocos2d 与其他框架和工具集结合。`CCTexture2D` 是纹理创建的底层机制。
- en: 'Loading spritesheets using CCSpriteFrameCache:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CCSpriteFrameCache 加载精灵表：
- en: 'Next, we will see the most powerful way to use sprites, the `CCSpriteFrameCache`
    class. Introduced in `Cocos2d-iPhone v0.99`, the `CCSpriteFrameCache` singleton
    is a cache of all sprite frames. Using a **spritesheet** and its associated `PLIST`,
    file (created using **Zwoptex**, more on this later) we can load multiple sprites
    into the cache. From here we can create `CCSprite` objects with sprites from the
    cache:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将看到使用精灵最强大的方式，即 `CCSpriteFrameCache` 类。自 `Cocos2d-iPhone v0.99` 版本引入，`CCSpriteFrameCache`
    单例是一个所有精灵帧的缓存。使用 **spritesheet** 及其关联的 `PLIST` 文件（使用 **Zwoptex** 创建，稍后会更详细地介绍）我们可以将多个精灵加载到缓存中。从这里，我们可以使用缓存中的精灵创建
    `CCSprite` 对象：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Mipmapping:**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mipmapping：**'
- en: 'Mipmapping allows you to scale a texture or to zoom in or out of a scene without
    aliasing your sprites. When we scale Alice down to a small size, aliasing will
    inevitably occur. With mipmapping turned on, Cocos2d dynamically generates lower
    resolution textures to smooth out any pixelation at smaller scales. Go ahead and
    comment out the following lines:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mipmapping 允许你在不产生精灵锯齿的情况下缩放纹理或放大缩小场景。当我们把爱丽丝缩小到很小的尺寸时，锯齿现象不可避免地会出现。开启 Mipmapping
    后，Cocos2d 会动态生成低分辨率的纹理，以平滑出较小尺度下的任何像素化。请取消以下行的注释：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you should see this pixelation as Alice gets smaller.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你应该能看到爱丽丝变小时像素化的效果。
- en: 'Drawing many derivative sprites with CCSpriteBatchNode:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CCSpriteBatchNode 绘制许多派生精灵：
- en: 'The `CCSpriteBatchNode` class, added in `v0.99.5`, introduces an efficient
    way to draw and re-draw the same sprite over and over again. A batch node is created
    with the following method:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CCSpriteBatchNode` 类，自 `v0.99.5` 版本开始添加，提供了一种高效的方式来重复绘制相同的精灵。创建批处理节点的方法如下：'
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, you create as many sprites as you want using the follow code:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下代码创建任意数量的精灵：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting the capacity to the number of sprites you plan to draw tells Cocos2d
    to allocate that much space. This is yet another tweak for extra efficiency, though
    it is not absolutely necessary that you do this. In these three examples we draw
    10 randomly placed clouds and 60 randomly placed bits of grass.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将容量设置为计划绘制的精灵数量，告诉 Cocos2d 分配这么多空间。这是另一种提高效率的调整，尽管你并不绝对需要这样做。在这三个例子中，我们绘制了 10
    个随机放置的云朵和 60 个随机放置的草丛。
- en: 'Drawing colored rectangles:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制彩色矩形：
- en: 'Finally, we have a fairly simple technique that has a variety of uses. By drawing
    a sprite with a blank 1px by 1px white texture and then coloring it and setting
    its `textureRect` property we can create very useful colored bars:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们有一个相当简单但用途多样的技术。通过绘制一个空白 1px x 1px 白色纹理的精灵，然后着色并设置其 `textureRect` 属性，我们可以创建非常有用的彩色条：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example we have used this technique to create very simple ground and
    sky backgrounds.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了这种技术来创建非常简单的地面和天空背景。
- en: Coloring sprites
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色精灵
- en: In the previous recipe we used colored rectangles to draw both the ground and
    the sky. The ability to set texture color and opacity are simple tools which,
    if used properly, can create very cool effects. In this recipe we will create
    a cinematic scene where two samurai face each other with glowing swords.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们使用彩色矩形来绘制地面和天空。设置纹理颜色和透明度的能力是简单的工具，如果使用得当，可以创建非常酷的效果。在这个配方中，我们将创建一个电影场景，其中两个武士面对面，手持发光的剑。
- en: '![Coloring sprites](img/4002_01_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![着色精灵](img/4002_01_02.jpg)'
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also, note that some code has been omitted for brevity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此配方的完整工作代码。另外，请注意，为了简洁，一些代码已被省略。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Execute the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows a number of color based techniques.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了多种基于颜色的技术。
- en: 'Setting sprite color:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置精灵颜色：
- en: 'The simplest use of color involves setting the color of a sprite using the
    following method:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最简单的颜色使用方法涉及使用以下方法设置精灵的颜色：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting sprite color effectively reduces the color you can display but it allows
    some programmatic flexibility in drawing. In this recipe we use `setColor` for
    a number of things, including drawing a blue sky, a yellow sun, black "dramatic
    movie bars", and more.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置精灵颜色有效地减少了你可以显示的颜色，但它允许在绘制中具有一定的程序灵活性。在这个配方中，我们使用 `setColor` 来做很多事情，包括绘制蓝色天空、黄色太阳、黑色“戏剧性电影条”等等。
- en: '`ccColor3B` is a C struct which contains three `GLubyte` variables. Use the
    following helper macro to create `ccColor3B` structures:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ccColor3B` 是一个包含三个 `GLubyte` 变量的 C 结构体。使用以下辅助宏来创建 `ccColor3B` 结构体：'
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Cocos2d also specifies a number of pre-defined colors as constants. These include
    the following:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cocos2d还指定了一些预定义的颜色作为常量。这些包括以下内容：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Fading to a color:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐变到颜色：
- en: 'To fade a scene to a specific color we use the blank.png technique we went
    over in the last recipe. We first draw a sprite as large as the screen, then color
    the sprite to the color we want to fade to, and then finally run a CCFadeIn action
    on the sprite to fade to that color:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将场景渐变到特定颜色，我们使用在上一个菜谱中提到的blank.png技术。我们首先绘制一个与屏幕大小相同的精灵，然后将精灵着色为我们想要渐变到的颜色，最后在精灵上运行一个CCFadeIn动作以渐变到该颜色：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using CCGradientLayer:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CCGradientLayer：
- en: 'Using the CCGradientLayer class we can programmatically create gradients. To
    make the mountains in the background fade into the ground the two samurai are
    standing on we created a gradient using this method:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用CCGradientLayer类，我们可以通过编程创建渐变。为了使背景中的山逐渐淡入到两个武士站立的地面上，我们使用这种方法创建了一个渐变：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because `CCGradientLayer` lets you control opacity as well as color, it has
    many uses. As you can see there is also a sinister red glow behind the evil samurai.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`CCGradientLayer`允许你控制不透明度和颜色，它有很多用途。正如你所见，在邪恶武士的背后还有一个邪恶的红色光芒。
- en: 'Making a sprite glow:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作发光的精灵：
- en: To make the swords in the demo glow we use subtle color manipulation, additive
    blending and fading and scaling actions. First we load the **fire.png** sprite
    supplied by Cocos2d. By changing its X and Y scale independently we can make it
    thinner or fatter. Once you have the desired scale ratio (in this demo we use
    x:y 3:11 because the sword is so thin) you can constantly scale and fade the sprite
    in and out to give some life to the effect. You also need to set the blend function
    to `{ GL_ONE, GL_ONE }` for additive blending. Finally this effect sprite is added
    to the actual sprite to make it seem like it glows.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让演示中的剑发光，我们使用微妙的颜色调整、加法混合和渐变缩放动作。首先，我们加载Cocos2d提供的**fire.png**精灵。通过独立改变其X和Y缩放比例，我们可以使它变细或变粗。一旦你得到了所需的缩放比例（在这个演示中我们使用x:y
    3:11，因为剑非常细），你可以不断缩放和淡入淡出精灵，以给效果增添一些活力。你还需要将混合函数设置为`{ GL_ONE, GL_ONE }`以实现加法混合。最后，将这个效果精灵添加到实际精灵上，使其看起来像在发光。
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Animating sprites
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画精灵
- en: Now it is time to add some animation to our sprites. One thing that should be
    stressed about animation is that it is only as complicated as you make it. In
    this recipe we will use very simple animation to create a compelling effect. We
    will create a scene where bats fly around a creepy looking castle. I've also added
    a cool lightning effect based on the technique used to make the swords glow in
    the previous recipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给我们的精灵添加一些动画了。关于动画，应该强调的是，它的复杂程度取决于你如何实现。在这个菜谱中，我们将使用非常简单的动画来创建一个引人入胜的效果。我们将创建一个场景，其中蝙蝠在看起来令人毛骨悚然的城堡周围飞翔。我还添加了一个基于之前菜谱中制作剑发光的技术的基础上的酷炫闪电效果。
- en: '![Animating sprites](img/4002_01_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![动画精灵](img/4002_01_03.jpg)'
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also note that some code has been omitted for brevity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目`RecipeCollection01`以获取此菜谱的完整工作代码。另外，请注意，为了简洁，一些代码已被省略。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe shows us how to structure animation based classes through the use
    of `SimpleAnimObject:`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何通过使用`SimpleAnimObject`来结构动画类：
- en: 'Animated object class structure:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画对象类结构：
- en: 'When switching from one animation to another it is often important to keep
    track of what state the animated object is in. In our example we use `SimpleAnimObject`,
    which keeps an arbitrary `animationType` variable. We also maintain a velocity
    variable that has a Y scalar value that is inversely proportional to the animation
    frame delay:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在切换动画时，通常需要跟踪动画对象的状态。在我们的例子中，我们使用`SimpleAnimObject`，它保持一个任意的`animationType`变量。我们还维护一个速度变量，它具有与动画帧延迟成反比的Y标量值：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Depending on how in-depth you want your animation system to be you should maintain
    more information such as, for example, a pointer to the running `CCAnimation`
    instance, frame information, and physical bodies.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你想要动画系统有多深入，你应该维护更多信息，例如，例如，指向正在运行的`CCAnimation`实例的指针、帧信息以及物理体。
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As you get more involved with Cocos2d game development you will become more
    and more tempted to use **asynchronous actions** for gameplay logic and AI. Derived
    from the `CCAction` class, these actions can be used for everything from moving
    a `CCNode` using `CCMoveBy` to animating a `CCSprite` using `CCAnimate`. When
    an action is run, an asynchronous timing mechanism is maintained in the background.
    First time game programmers often over-rely on this feature. The extra overhead
    required by this technique can multiply quickly when multiple actions are being
    run. In the following example we have used a simple integer timer that allows
    us to regulate how long lightning lasts onscreen:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对 Cocos2d 游戏开发的参与越来越深入，你将越来越倾向于使用 **异步操作** 来实现游戏逻辑和人工智能。这些操作由 `CCAction`
    类派生，可用于从使用 `CCMoveBy` 移动 `CCNode` 到使用 `CCAnimate` 动画 `CCSprite` 的各种操作。当执行操作时，后台会维护一个异步计时机制。第一次编写游戏程序的开发者往往过度依赖这个特性。当运行多个操作时，这种技术所需的额外开销会迅速增加。在下面的示例中，我们使用了一个简单的整数计时器，允许我们调节屏幕上闪电持续的时间：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Synchronous timers** like the one shown in the preceding code snippet are
    often, but not always, preferable to asynchronous actions. Keep this in mind as
    your games grow in size and scope.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步计时器**，如前面代码片段中所示，通常但并非总是比异步操作更可取。随着你的游戏规模和范围的增长，请记住这一点。'
- en: Drawing OpenGL primitives
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制 OpenGL 原始图形
- en: Sometimes in 2D game development we need to make use of good old-fashioned **OpenGL
    primitives**. With these we can make minimaps, heads up displays, and special
    effects like bullet tracers and lightning blasts to name a few. In the following
    scene I've created a simple figure using all of the primitive drawing functions
    supplied by Cocos2d as well as one I've tweaked and added.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在 2D 游戏开发中，我们需要使用传统的 **OpenGL 原始图形**。通过这些，我们可以制作迷你地图、抬头显示和像子弹追踪和闪电爆炸这样的特殊效果等。在下面的场景中，我使用
    Cocos2d 提供的所有原始绘图函数以及我调整并添加的一个函数创建了一个简单的图形。
- en: '![Drawing OpenGL primitives](img/4002_01_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![绘制 OpenGL 原始图形](img/4002_01_04.jpg)'
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe shows us how to use each primitive drawing function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱展示了如何使用每个原始绘图函数：
- en: 'Overriding the `draw` method:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖 `draw` 方法：
- en: 'In order to use OpenGL drawing routines we must override the following method
    of a `CCNode`:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使用 OpenGL 绘图例程，我们必须覆盖 `CCNode` 的以下方法：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As stated in `CCNode.h`, overriding this method gives us control of underlying
    OpenGL drawing routines. The following OpenGL statements are implicit:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如 `CCNode.h` 中所述，覆盖此方法使我们能够控制底层的 OpenGL 绘图例程。以下 OpenGL 语句是隐含的：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To overload this method we create a class named `ShapeLayer` which inherits
    from `CCLayer`, and therefore from `CCNode`. Once attached to the scene this overridden
    draw method will be called once every cycle.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了覆盖此方法，我们创建了一个名为 `ShapeLayer` 的类，它继承自 `CCLayer`，因此也继承自 `CCNode`。一旦附加到场景，这个覆盖的绘图方法将每周期调用一次。
- en: 'Primitive drawing functions:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始绘图函数：
- en: 'The following primitive drawing functions are available in Cocos2d:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cocos2d 中提供了以下原始绘图函数：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On top of all this we have tweaked `ccDrawCircle` to create `ccDrawSolidCircle`
    as follows:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有这些之上，我们对 `ccDrawCircle` 进行了调整，以创建 `ccDrawSolidCircle`，如下所示：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because we are controlling these OpenGL render calls for each frame this technique
    works well when used in a real-time minimap. We will explore this in a later recipe.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在控制每一帧的 OpenGL 渲染调用，因此当在实时迷你地图中使用时，这种技术效果很好。我们将在后面的菜谱中探讨这一点。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you are planning to use primitive drawing extensively you may want to consider
    using the **Vertex Buffer Object** OpenGL extension. Using the GL functions `glGenBuffers,
    glBindBuffer`, and `glBufferData` you can put vertex and other information into
    video memory rather than system memory. This can drastically improve performance
    depending on the situation. For more information view the section *Best Practices
    for Working with Vertex Data* in the Apple Developer document *OpenGL ES Programming
    Guide for iOS* located at [http://developer.apple.com/library/ios/#documentation/3DDrawing/
    Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html](http://developer.apple.com/library/ios/#documentation/3DDrawing/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算大量使用原始绘图，你可能想考虑使用 **顶点缓冲对象** OpenGL 扩展。使用 GL 函数 `glGenBuffers`、`glBindBuffer`
    和 `glBufferData`，你可以将顶点和其他信息放入视频内存而不是系统内存。这可能会根据情况大幅提高性能。有关更多信息，请查看 Apple 开发者文档中
    *OpenGL ES 编程指南 for iOS* 的 *处理顶点数据最佳实践* 部分，位于 [http://developer.apple.com/library/ios/#documentation/3DDrawing/
    Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html](http://developer.apple.com/library/ios/#documentation/3DDrawing/)。
- en: Playing video files
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放视频文件
- en: The **cutscene** is a concept that has existed since the early days of video
    games. Cutscenes are usually interspersed in between gameplay segments or shown
    when a game is loading. For more complex cutscenes it is often advantageous to
    use full motion video. In this recipe we will see how to insert a video into our
    game.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**过场场景**是一个自视频游戏早期就存在的概念。过场场景通常穿插在游戏玩法段落之间或在游戏加载时显示。对于更复杂的过场场景，使用全动态视频通常是有利的。在这个食谱中，我们将看到如何将视频插入到我们的游戏中。'
- en: '![Playing video files](img/4002_01_05.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![播放视频文件](img/4002_01_05.jpg)'
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此食谱的完整工作代码。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe requires the extra step of linking the **MediaPlayer iOS framework**
    to our project:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要额外的步骤将 **MediaPlayer iOS 框架**链接到我们的项目中：
- en: Right-click your project under **Groups & Files**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **组与文件**下右键点击你的项目。
- en: Click **Add | Existing Frameworks**
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加 | 已存在的框架**
- en: Under **iOS SDK** select **MediaPlayer.framework**
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **iOS SDK** 下选择 **MediaPlayer.framework**
- en: Keep in mind that `RecipeCollection01` already has this library linked.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`RecipeCollection01` 已经链接了这个库。
- en: 'Now, execute the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下代码：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows us how to load, play, and stop a movie.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱展示了如何加载、播放和停止一个电影。
- en: 'Using MPMoviePlayerController:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MPMoviePlayerController：
- en: This recipe is merely the tip of the iceberg regarding movie playback. Movies
    can also be played back in fullscreen mode, in portrait mode, and using a variety
    of other options. Please refer to official Apple documentation when customizing
    and/or adding to this technique.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个食谱只是关于电影播放的冰山一角。电影也可以在全屏模式、纵向模式和多种其他选项下播放。请参考官方 Apple 文档以自定义和/或添加此技术。
- en: '`UsingObjective-C` observers:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsingObjective-C` 观察者：'
- en: The **observer pattern** is not used very often while doing Cocos2d programming,
    but it is a powerful mechanism and it is the recommended way of knowing when your
    video has finished playback. You can read more about observers by referring to
    the official `Objective-C` documentation.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在进行 Cocos2d 编程时，**观察者模式**并不常用，但它是一个强大的机制，并且是推荐的方式来知道你的视频何时播放完毕。你可以通过参考官方的 `Objective-C`
    文档来了解更多关于观察者的信息。
- en: 'Movie file format:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影文件格式：
- en: 'According to Apple documentation it is recommended that you compress your movies
    using `H.264/MPEG-4` for video, `AAC` audio and one of the following file formats:
    `MOV, MP4, MPV, 3GP`.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据 Apple 文档，建议你使用 `H.264/MPEG-4` 对视频进行压缩，`AAC` 音频，以及以下文件格式之一：`MOV`、`MP4`、`MPV`、`3GP`。
- en: It is also recommended that your movies be no larger than `640x480` and run
    no faster than `30 FPS`.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还建议你的电影大小不超过 `640x480`，运行速度不超过 `30 FPS`。
- en: The movie used in the recipe was created and encoded using Apple's iMovie software.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于食谱中的电影是由 Apple 的 iMovie 软件创建和编码的。
- en: For more information please consult official Apple iOS SDK documentation.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如需更多信息，请查阅官方 Apple iOS SDK 文档。
- en: Grid, particle, and motion streak effects
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格、粒子以及运动条纹效果
- en: Cocos2d comes equipped with a variety of easy to use special effects. Here,
    we will only briefly go over all of the effects as they are fairly straightforward
    and are well covered in other texts.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d配备了各种易于使用的特殊效果。在这里，我们只简要介绍所有效果，因为它们相当直接，在其他文本中也有很好的介绍。
- en: '![Grid, particle, and motion streak effects](img/4002_01_06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![网格、粒子和动态条纹效果](img/4002_01_06.jpg)'
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目`RecipeCollection01`以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To get grid effects to show up properly in your game you first need to set the
    `EAGLView pixelFormat` to `kEAGLColorFormatRGBA8` (it is set to `kEAGLColorFormatRGB565`
    by default).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏中正确显示网格效果，你首先需要将`EAGLView pixelFormat`设置为`kEAGLColorFormatRGBA8`（默认设置为`kEAGLColorFormatRGB565`）。
- en: 'Do this by going into your project file''s `${PROJECT_NAME}AppDelegate.m` file
    and changing the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进入你的项目文件中的`${PROJECT_NAME}AppDelegate.m`文件并更改以下代码来实现：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change it to this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, execute the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下代码：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we see a number of things. For the sake of brevity I've only
    included one grid effect and two particle effects in the book. Every stock grid
    and particle effect is viewable in `RecipeCollection01`, along with some customized
    particle effects like `Waterfall` and `WaterSplash`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们看到了许多东西。为了简洁起见，我在书中只包含了一个网格效果和两个粒子效果。每个库存网格和粒子效果都可以在`RecipeCollection01`中查看，还有一些自定义粒子效果，如`Waterfall`和`WaterSplash`。
- en: 'Custom Particles:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义粒子：
- en: 'Cocos2d particles have many variables and it is most often advantageous to
    sub-class a built-in particle to help create your own. Here is a list of the built-in
    Cocos2d particles:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cocos2d粒子有许多变量，通常最有利的是通过子类化内置粒子来帮助你创建自己的。以下是一些内置的Cocos2d粒子：
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using CCMotionStreak:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CCMotionStreak：
- en: A motion streak is a great way to add a dynamic element a `CCNode`. These can
    often be combined with particles for a great effect.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动态条纹是向CCNode添加动态元素的好方法。这些通常可以与粒子结合，产生很好的效果。
- en: One thing to keep in mind when creating a motion streak is that the texture
    needs to look good when it bends in on itself. **Vertical textures** with **transparent
    gradient edges** usually look the best.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建动态条纹时，需要注意的一点是，当纹理弯曲回自身时，其纹理需要看起来很好。**垂直纹理**带有**透明渐变边缘**通常看起来最好。
- en: Using Retina Display mode
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Retina显示模式
- en: Both the iPhone 4 and the iPad support Apple's **Retina Display** mode. On the
    iPhone 4 this doubles the resolution to `960x640`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 4和iPad都支持Apple的**Retina显示**模式。在iPhone 4上，这使分辨率加倍达到`960x640`。
- en: 'The creators of Cocos2d have taken a lot of care in integrating this feature
    into the framework. Retina display can be turned on with the flick of a switch.
    Getting your game to run similarly in both hi-definition and standard-definition
    can be tricky though. Luckily they have taken this into consideration as well.
    In this recipe we will enable Retina Display and then display a hi-resolution
    image, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d的制作者在将此功能集成到框架中时非常用心。通过简单的开关即可开启Retina显示。然而，让游戏在高清和标清模式下运行相似可能有些棘手。幸运的是，他们也考虑到了这一点。在这个菜谱中，我们将启用Retina显示，并显示一个高分辨率图像，如下面的截图所示：
- en: '![Using Retina Display mode](img/4002_01_07.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用Retina显示模式](img/4002_01_07.jpg)'
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To properly see Retina Display you need a retina display device. In the simulator
    you need to do the following to switch to an **iPhone Retina** simulation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确查看Retina显示，你需要一个Retina显示设备。在模拟器中，你需要执行以下操作以切换到**iPhone Retina**模拟：
- en: Go to the iOS simulator.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开iOS模拟器。
- en: In the file menu click on **Hardware | Device | iPhone (Retina)**.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件菜单中点击**硬件 | 设备 | iPhone (Retina)**。
- en: You may also of course use a real iPhone 4 or iPad device.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然也可以使用真实的iPhone 4或iPad设备。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First you must enable **Retina Display** in your application. Go into `${PROJECT_NAME}AppDelegate.m`
    and *uncomment* the following lines:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须在应用程序中启用**Retina显示**。进入`${PROJECT_NAME}AppDelegate.m`并*取消注释*以下行：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Retina Display will now be turned on for devices that support it and turned
    off for devices that do not.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将开启支持Retina显示的设备上的Retina显示，并关闭不支持Retina显示的设备上的Retina显示。
- en: 'Now, execute the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下代码：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'One sprite for the price of two:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一物两用：
- en: As you can see the sprite we created is now very large and detailed. If you
    turn Retina Display off or run this on a device that does not support it you will
    see a smaller blurrier sprite. This happens because Retina Display chooses the
    higher resolution version of every sprite if there is one available. We specify
    the higher resolution version with the `-hd` suffix. So, in Retina Display mode
    Cocos2d automatically displays `cocos2d_beginner-hd.png` instead of `cocos2d_beginner.png`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所见，我们创建的精灵现在非常大且细节丰富。如果你关闭Retina Display或在一个不支持它的设备上运行，你会看到一个更小、更模糊的精灵。这是因为Retina
    Display会选择每个精灵的更高分辨率版本（如果有的话）。我们使用`-hd`后缀指定更高分辨率的版本。因此，在Retina Display模式下，Cocos2d会自动显示`cocos2d_beginner-hd.png`而不是`cocos2d_beginner.png`。
- en: 'Position, sizing, and so on:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置、尺寸等：
- en: Supposedly Cocos2d will convert all coordinate positions, size ratios, and anything
    else accordingly. The only thing you should have to change is adding the high
    resolution imagery.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 据说Cocos2d会相应地转换所有坐标位置、尺寸比率和任何其他内容。你唯一需要改变的是添加高分辨率图像。
- en: It is recomended that a number of caveats are practiced with this. Lower level
    OpenGL hacking often doesn't display as you would want it to. Be wary of this
    and be sure to test any complex techniques in Retina Display mode before thinking
    about supporting both modes.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议在使用此功能时注意以下几点。低级别的OpenGL黑客技术通常不会显示成你想要的样子。对此保持警惕，并在考虑支持两种模式之前，确保在Retina Display模式下测试任何复杂的技术。
- en: 'The downside of Retina Display:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Retina Display的缺点：
- en: The major downside of Retina Display is simply the amount of disk space it takes
    up. Including all of the HD images will more than double the space all of your
    art assets take up. Also, the higher resolution images take up more memory at
    runtime.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Retina Display的主要缺点仅仅是它占用的磁盘空间量。包括所有HD图像将使你的所有艺术资产占用的空间增加一倍以上。此外，更高分辨率的图像在运行时也会占用更多内存。
- en: The upside of Retina Display.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Retina Display的优点。
- en: On the other hand Apple keeps increasing app size limits and device memory.
    With newer hardware coming out and the ability to make desktop applications, increased
    resolution is a must for triple-A game titles.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，苹果不断增加应用大小限制和设备内存。随着新硬件的推出和制作桌面应用的能力，对于AAA游戏来说，提高分辨率是必须的。
- en: 1D and 2D Ease Actions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1D和2D缓动动作
- en: '**Ease Actions** allow you to fine tune the actions used in your game using
    a number of formulae. They can be applied to any action: moving, scaling, fading,
    and so on. Regarding movement specifically, a small tweak can be applied to allow
    for independent *Easing* on both the X and the Y axis. This can be used to create
    a number of cool effects.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓动动作**允许你使用多种公式微调游戏中使用的动作。它们可以应用于任何动作：移动、缩放、淡入淡出等。具体到移动，可以应用一个小调整，允许在X轴和Y轴上独立进行*缓动*。这可以用来创建许多酷炫的效果。'
- en: '![1D and 2D Ease Actions](img/4002_01_08.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![1D和2D缓动动作](img/4002_01_08.jpg)'
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目`RecipeCollection01`以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Upon executing this code you should see one character moving in a straight line
    toward the destination while the other moves there in a seemly erratic yet calculated
    way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，你应该看到其中一个角色沿着直线向目的地移动，而另一个角色则以看似无序但经过计算的方式移动。
- en: 'Uses of 2D eased movement actions:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D缓动动作的使用：
- en: While creating the iOS game *GoldenAgeBaseball* this summer I used `CCMoveByCustom`
    to simulate different pitches. A slider moved down and away, a cutter only away
    and a sinker only down. This variation of pitch styles was crucial to the development
    of the pitching/batting gameplay mechanic.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在今年夏天创建iOS游戏*GoldenAgeBaseball*时，我使用了`CCMoveByCustom`来模拟不同的投球。一个滑块向下移动并远离，一个切球只远离，一个沉球只向下。这种投球风格的变体对于投球/击球游戏机制的开发至关重要。
- en: Overall, Ease Actions give your game a polished and professional feel. Whether
    you are smoothing out a camera movement or simulating a baseball pitch, Ease Actions
    are a fine tool to help tweak your game to perfection.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总体而言，缓动动作给你的游戏带来了一种精致和专业的感觉。无论是平滑相机移动还是模拟棒球投球，缓动动作都是一项优秀的工具，可以帮助你将游戏调整到完美。
- en: Rendering and texturing 3D shapes
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和纹理化3D形状
- en: As odd as it sounds, sometimes in a 2D game you simply just want to add some
    simple **3D graphics**. Whether you are creating a cool 2D/3D hybrid or a simple
    3D game with a 2D HUD, 3D graphics are no easy thing to produce. The complexities
    of a third dimension often conflict with 2D programming paradigms.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来很奇怪，但在2D游戏中，有时你只是想添加一些简单的**3D图形**。无论你是创建酷炫的2D/3D混合游戏还是简单的带有2D用户界面的3D游戏，3D图形都不是一件容易产生的事情。第三维的复杂性常常与2D编程范式冲突。
- en: For the sake of simplicity, this recipe will show you how to create a **simple
    colored cube** and a **simple textured cube**. The uses of simple geometry are
    varied even when making a 2D game. However, more examples including **shaders**
    and **3D models** are beyond the scope of this book.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这个配方将向您展示如何创建一个**简单的彩色立方体**和一个**简单的纹理立方体**。即使在制作2D游戏时，简单几何形状的用途也很多。然而，包括**着色器**和**3D模型**在内的更多示例超出了本书的范围。
- en: '![Rendering and texturing 3D shapes](img/4002_01_09.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![渲染和纹理化3D形状](img/4002_01_09.jpg)'
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目`RecipeCollection01`以获取此配方的完整工作代码。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: What we see here is a crash course in OpenGL ES cube rendering with a Cocos2d
    twist. Like when we drew OpenGL primitives, here we create another `CCNode` and
    override its draw method to create more complex OpenGL geometry.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是OpenGL ES立方体渲染的快速入门课程，带有Cocos2d的变体。就像我们绘制OpenGL原语一样，这里我们创建另一个`CCNode`并重写其绘制方法以创建更复杂的OpenGL几何形状。
- en: 'Texturing:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理化：
- en: We harness a `CCSprite` method to load a texture into memory to allow us to
    bind that texture for 3D drawing. This process is fairly straightforward.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们利用`CCSprite`方法将纹理加载到内存中，以便我们可以将该纹理绑定用于3D绘制。这个过程相当直接。
- en: 'Depth testing, sizing, and translation:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度测试、尺寸和转换：
- en: Thanks to Cocos2d's built-in depth testing, cubes will be properly ordered based
    on the Z property. The `translation3D.z` value affects the actual size of the
    cube while its `translation3D.x` and `translation3D.y` values affect where it
    is on the screen proportional to `translation3D.z.`
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多亏了Cocos2d内置的深度测试，立方体将根据Z属性正确排序。`translation3D.z`值影响立方体的实际大小，而其`translation3D.x`和`translation3D.y`值影响它在屏幕上的位置，与`translation3D.z`成比例。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For more information about 3D graphics, please refer to the recipe *Using Cocos3d*
    in [Chapter 8](ch08.html "Chapter 8. Tips, Tools, and Ports"), *Tips, Tools, and
    Ports.*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有关3D图形的更多信息，请参考第8章中的配方*使用Cocos3d*，*提示、工具和端口*。
- en: Rendering a texture-filled polygon
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染纹理填充的多边形
- en: When creating games with large levels it is often easy to run into memory limitations.
    Large maps also contain repetitive drawing of things like grass, trees, mountains,
    and so on. This recipe will show you how to efficiently render a **polygon** that
    is filled in with a **repeated texture**. These can be drawn at any size and still
    only use a small amount of memory and CPU time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建大型关卡的游戏时，很容易遇到内存限制。大地图也包含诸如草地、树木、山脉等物体的重复绘制。这个配方将向您展示如何高效地渲染一个用**重复纹理**填充的**多边形**。这些可以绘制成任何大小，同时仍然只占用很少的内存和CPU时间。
- en: '![Rendering a texture-filled polygon](img/4002_01_10.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![渲染纹理填充的多边形](img/4002_01_10.jpg)'
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目`RecipeCollection01`以获取此配方的完整工作代码。
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`TexturedPolygon` takes a given set of **vertices** and uses a **polygon triangulation
    algorithm** to find all triangles contained within the polygon. It then textures
    and draws these triangles using OpenGL triangles strips.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`TexturedPolygon`接受一组给定的**顶点**，并使用**多边形三角化算法**找到多边形内包含的所有三角形。然后使用OpenGL三角形带对这些三角形进行纹理化和绘制。'
- en: 'Triangulation:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角化：
- en: Triangulation, depending on the polygon, can be a complex process. This is often
    performed while a map is loading. For very complex polygons it can be advantageous
    to perform polygon triangulation during level creation and store triangle **indices**
    along with the polygon vertices. This can speed up level load times.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 三角化，根据多边形的不同，可能是一个复杂的过程。这通常在地图加载时执行。对于非常复杂的多边形，在关卡创建期间执行多边形三角化并存储与多边形顶点一起的三角形**索引**可能是有益的。这可以加快关卡加载时间。
- en: 'Uses:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用途：
- en: Textured polygons have many uses including static map textures and background
    textures.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 纹理多边形有许多用途，包括静态地图纹理和背景纹理。
- en: 'Performance:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：
- en: Using this technique you can efficiently draw polygons of virtually any size.
    Space requirements rely on the size of each texture used rather that the size
    of each polygon. To use less space, modify `TexturedPolygon` to re-use pre-initialized
    textures.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种技术，你可以高效地绘制几乎任何大小的多边形。空间需求取决于使用的每个纹理的大小，而不是每个多边形的大小。为了节省空间，修改 `TexturedPolygon`
    以重用预先初始化的纹理。
- en: 'Caveats:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意事项：
- en: This technique has a few caveats. The textures used must be square and each
    side's size must be equal to 2n (16x16, 32x32, 64x64, and so on). Also, textures
    can only be single files, not sprite frames.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术有几个注意事项。使用的纹理必须是正方形，每边的尺寸必须是 2n（16x16、32x32、64x64 等）。此外，纹理只能是单个文件，不能是精灵帧。
- en: There's more...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: This recipe may be your first foray into combining `Objective-C` and `C++` code.
    This is commonly referred to as `Objective-C++`. For more information please refer
    to Apple's official developer documentation *Using C++ With Objective-C* at [http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱可能是你第一次尝试将 `Objective-C` 和 `C++` 代码结合使用。这通常被称为 `Objective-C++`。有关更多信息，请参阅苹果官方开发者文档
    *使用 C++ 与 Objective-C*，链接为 [http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html)。
- en: Animating a texture-filled polygon
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画纹理填充多边形
- en: The `TexturedPolygon` can also be easily animated. This is useful for animated
    crowds, ocean waves, bubbling lava pits, and so on. In the example we see an animated
    field of wheat.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`TexturedPolygon` 也可以轻松动画化。这对于动画人群、海浪、沸腾的熔岩坑等非常有用。在示例中，我们看到一片动画的麦田。'
- en: '![Animating a texture-filled polygon](img/4002_01_11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![动画纹理填充多边形](img/4002_01_11.jpg)'
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此食谱的完整工作代码。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: By dynamically changing the texture using `CCAnimation` we can create very simple
    tiled animation. The only extra cost of this operation is the extra space allocated
    for each frame of the animation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `CCAnimation` 动态更改纹理，我们可以创建非常简单的平铺动画。这个操作的唯一额外成本是为动画的每一帧分配的额外空间。
- en: Swapping palettes using layers
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图层交换调色板
- en: A vital tool in any game developer's repertoire is the ability to swap color
    palettes. From *The Legend of Zelda* on *NES* to *Halo* on the *Xbox*, palette
    swapping is a simple yet effective visual cue that can stretch a limited amount
    of art.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏开发者工具箱中的关键工具之一是能够交换颜色调色板。从 *NES* 上的 *The Legend of Zelda* 到 *Xbox* 上的 *Halo*，调色板交换是一种简单而有效的视觉提示，可以扩展有限的美术资源。
- en: In the following example you learn how to palette swap using layers. We are
    using an animated baseball player for this example.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将学习如何使用图层进行调色板交换。我们在这个例子中使用了一个动画棒球运动员。
- en: '![Swapping palettes using layers](img/4002_01_12.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![使用图层交换调色板](img/4002_01_12.jpg)'
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此食谱的完整工作代码。
- en: For this recipe you will need an image manipulation program. I recommend the
    free and easy to use *GIMP*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要一个图像处理程序。我推荐免费且易于使用的 *GIMP*。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first thing we will do is draw the sprite and the colorable areas:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是绘制精灵和可着色区域：
- en: Draw your texture with all dynamically colorable areas left blank. In your image
    editing program your texture should look something like the following:![How to
    do it...](img/4002_01_13.jpg)
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用所有可动态着色的区域留白的方式绘制你的纹理。在你的图像编辑程序中，你的纹理应该看起来像以下这样：![如何操作...](img/4002_01_13.jpg)
- en: Create a new layer and color a specific area white. In this example we are coloring
    his uniform (legs and shirt) white:![How to do it...](img/4002_01_14.jpg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新图层，并将特定区域着色为白色。在这个例子中，我们正在将他的制服（腿和衬衫）着色为白色：![如何操作...](img/4002_01_14.jpg)
- en: Hide the other layer and save that white-only layer as a separate texture.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐藏其他图层，并将仅包含白色的单独图层保存为单独的纹理。
- en: Repeat this for any other separately colored sections.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对任何其他单独着色的部分重复此操作。
- en: 'Once we have our textures we can write some code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了纹理，我们就可以编写一些代码：
- en: '[PRE33]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: By drawing the swappable layers under the main layer (the black outline) we
    cover up any imprecision in the coloring. This technique is slightly more difficult
    for art that doesn't use a thick black outline like the drawings shown in the
    preceding section.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在主层（黑色轮廓）下方绘制可交换层，我们掩盖了着色中的任何不精确之处。对于像前一部分中显示的没有使用厚黑色轮廓的绘图这样的艺术作品，这种方法稍微困难一些。
- en: 'Efficiency—Disk Space:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率—磁盘空间：
- en: Keeping your iOS app below a certain size on the disk is always a good idea.
    This technique is fairly easy on your disk space as the swappable textures take
    up only a small amount of space due to easy PNG compression of simplistic textures.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在磁盘上保持你的 iOS 应用程序大小不超过一定范围总是一个好主意。这种技术在磁盘空间上相当容易，因为可交换的纹理由于简单的 PNG 压缩只占用很少的空间。
- en: 'Efficiency—Memory Usage:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率—内存使用：
- en: Unfortunately the size of a texture in memory is determined by its pixel size.
    So, if you are palette swapping large animated textures you might run into memory
    consumption issues. Memory consumption for a palette swapped texture equals the
    normal memory size times the number of palettes to swap.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，内存中纹理的大小由其像素大小决定。因此，如果你正在交换大型动画纹理，可能会遇到内存消耗问题。调色板交换纹理的内存消耗等于正常内存大小乘以要交换的调色板数量。
- en: 'Efficiency—CPU:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率—CPU：
- en: When animating a palette swapped texture the CPU time used by the animation
    routine will also be multiplied by the number of swappable layers. This is usually
    fairly inconsequential as animation takes up very little CPU time as it is.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当动画化调色板交换的纹理时，动画例程使用的 CPU 时间也将乘以可交换层的数量。这通常并不重要，因为动画本身占用的 CPU 时间非常少。
- en: Swapping palettes using CCTexture2DMutable
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CCTexture2DMutable 交换调色板
- en: Another way to palette swap involves **sentinel colors** and the ability to
    modify a texture pixel by pixel. This method can help reclaim some extra space
    on the disk and in memory but it tends to take a lot of CPU time. It is also messier
    than the previous technique when used with anti-aliased or blended textures.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调色板交换的方法涉及 **哨兵颜色** 和逐像素修改纹理的能力。这种方法可以帮助回收一些额外的磁盘和内存空间，但它通常需要大量的 CPU 时间。当与抗锯齿或混合纹理一起使用时，这种方法比之前的技术更混乱。
- en: '![Swapping palettes using CCTexture2DMutable](img/4002_01_15.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CCTexture2DMutable 交换调色板](img/4002_01_15.jpg)'
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the `project RecipeCollection01` for full working code of this
    recipe. Also note the included library `CCTexture2DMutable` that is not included
    in the book itself.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 `project RecipeCollection01` 以获取此配方的完整工作代码。同时注意，包含的库 `CCTexture2DMutable`
    并未包含在书中。
- en: For this recipe you will need an image manipulation program. Once again I recommend
    the free and easy to use *GIMP*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要一个图像处理程序。再次推荐免费且易于使用的 *GIMP*。
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The first thing we will do is draw a sprite that contains colorable areas defined
    by sentinel colors. A sentinel color is usually a primary color that is easily
    recognizable and can be replaced programmatically. In this case we will use red,
    blue, and green:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是绘制一个包含由哨兵颜色定义的可着色区域的精灵。哨兵颜色通常是易于识别的基本颜色，并且可以程序化地替换。在这种情况下，我们将使用红色、蓝色和绿色：
- en: '![How to do it...](img/4002_01_16.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/4002_01_16.jpg)'
- en: It is best to avoid aliasing and blending as much as possible when using this
    technique. Adjusting your coloring algorithm's tolerance according to your texture
    can be tricky.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此技术时，最好尽可能避免抗锯齿和混合。根据你的纹理调整着色算法的容差可能很棘手。
- en: 'Now, execute the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下代码：
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For better or worse this technique works the same way color selection and replacement
    works in *Adobe Photoshop*, and similar drawing programs. Using `CCTexture2DMutable`
    can often be a slow process and this technique is only recommended for games that
    require pixel-perfect graphics or have very strict space/memory requirements.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 无论好坏，这种技术与 *Adobe Photoshop* 和类似绘图程序中的颜色选择和替换工作方式相同。使用 `CCTexture2DMutable`
    可能是一个缓慢的过程，并且这种方法仅推荐用于需要像素完美图形或对空间/内存要求非常严格的游戏。
- en: Using AWTextureFilter for blur and font shadows
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWTextureFilter 进行模糊和字体阴影
- en: 'By harnessing `CCTexture2DMutable` the class `AWTextureFilter` can be used
    to create some cool effects. These include **Gaussian Blur**, selective Gaussian
    Blur, and dynamically generated font shadows as shown in the following scene:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 `CCTexture2DMutable` 类，`AWTextureFilter` 类可以用来创建一些酷炫的效果。这些包括 **高斯模糊**、选择性的高斯模糊以及如下场景中所示动态生成的字体阴影：
- en: '![Using AWTextureFilter for blur and font shadows](img/4002_01_17.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![使用 AWTextureFilter 进行模糊和字体阴影](img/4002_01_17.jpg)'
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE35]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`AWTextureFilter` uses `CCTexture2DMutable` to achieve a compelling Gaussian
    Blur effect. This is one example of complex pixel manipulation.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`AWTextureFilter` 使用 `CCTexture2DMutable` 来实现令人印象深刻的高斯模糊效果。这是复杂像素操作的一个例子。'
- en: 'Font shadows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 字体阴影：
- en: '`CCTexture2DMutable` inherits from `CCTexture2D`. This allows us to use the
    following method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`CCTexture2DMutable` 继承自 `CCTexture2D`。这允许我们使用以下方法：'
- en: '[PRE36]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This creates a label texture that we can then use to create a blurred font shadow
    effect by creating a similar texture that we offset, darken, blur, and finally
    draw behind the original label texture.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个标签纹理，然后我们可以通过创建一个偏移、变暗、模糊并最终绘制在原始标签纹理后面的类似纹理来创建模糊的字体阴影效果。
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here are a few other suggestions for the use of this blurring technique:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些关于使用此模糊技术的其他建议：
- en: Blurring a screenshot as a background for the pause menu (see the next recipe
    in this chapter, *Taking and using screenshots)*
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将截图作为暂停菜单的背景进行模糊（参见本章下一节，*捕获和使用截图*）
- en: Combine with a color effect for a cool glow effect
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合颜色效果以产生酷炫的光晕效果
- en: Increase or decrease blur radius for reveal-based puzzle and trivia games
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据揭示类谜题和知识竞赛游戏的模糊半径进行增加或减少
- en: Taking and using screenshots
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获和使用截图
- en: As hinted in the last recipe, in-game screenshots can be taken and used in-game
    to create cool effects like a blurred background for a pause menu. For an example
    of this in a published app, take a look at the pause menu in *2K Sports NHL 2K11*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一次菜谱中所述，可以在游戏中捕获并使用截图来创建酷炫的效果，如暂停菜单的模糊背景。例如，在已发布的应用程序中，可以查看 *2K Sports NHL
    2K11* 的暂停菜单。
- en: '![Taking and using screenshots](img/4002_01_18.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![捕获和使用截图](img/4002_01_18.jpg)'
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also note the included library `Screenshot` that is not included in the
    book itself.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此菜谱的完整工作代码。同时请注意，包含的 `Screenshot` 库在书中并未包含。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE37]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The included `Screenshot` library uses some complex iOS techniques that are
    beyond the scope of this book. The library is included in `RecipeCollection01`.
    You can take a look at it there.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的 `Screenshot` 库使用了一些超出本书范围的复杂 iOS 技术。该库包含在 `RecipeCollection01` 中。你可以在那里查看它。
- en: Simply put, `Screenshot` takes a capture of what's currently on the screen and
    shoves that into a `CCTexture2D` for you to manipulate.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`Screenshot` 会捕获当前屏幕上的内容并将其推入 `CCTexture2D` 以供你操作。
- en: There's more...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Live screenshots can be used for a wide variety of things such as the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实时截图可用于各种用途，如下所示：
- en: Screenshot highlights and recaps of interesting moments of gameplay at the end
    of a match or level
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比赛或关卡结束时，截图游戏中的精彩瞬间和高潮
- en: Considering the fact that you can analyze exactly what the player is currently
    seeing you could "break the fourth wall" (think *Psycho Mantis* in *Metal Gear
    Solid* for *Sony PlayStation)*
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到你可以分析玩家当前正在看到的确切内容，你可以“打破第四面墙”（想想 *Metal Gear Solid* 中的 *Psycho Mantis*，在
    *Sony PlayStation* 上）
- en: An in-game user controlled camera like in *Pokemon Snap* for *Nintentdo 64*
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于在 *Nintendo 64* 上的 *Pokemon Snap* 的游戏内用户控制摄像头
- en: Using CCParallaxNode
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CCParallaxNode
- en: '**Parallaxing** is a staple of 2D side-scrolling video games. A competent developer
    would be remiss if he didn''t include a nice parallaxed background in a 2D side-scroller.
    Cocos2d makes parallaxing easy with CCParallaxNode.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parallaxing** 是 2D 侧滚动视频游戏的基础。一个有能力的开发者如果不在 2D 侧滚动游戏中包含一个漂亮的透视背景，那将是失职的。Cocos2d
    通过 CCParallaxNode 使透视变得简单。'
- en: '![Using CCParallaxNode](img/4002_01_19.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CCParallaxNode](img/4002_01_19.jpg)'
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 `RecipeCollection01` 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cocos2d makes it very easy to create a professional looking scrolling background.
    `CCParallaxNode` breaks the concept of parallaxing down to its key components.
    In the following example we attach four sprites to an instance of `CCParallaxNode`.
    Keep in mind that you can attach any `CCNode` to a `CCParallaxNode`. We then set
    `parallaxRatio` and `parallaxOffset` to create the desired effect.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d使得创建看起来专业的滚动背景变得非常容易。`CCParallaxNode`将视差的概念分解为其关键组件。在下面的示例中，我们将四个精灵附加到`CCParallaxNode`的一个实例上。请注意，您可以将任何`CCNode`附加到`CCParallaxNode`。然后我们设置`parallaxRatio`和`parallaxOffset`以创建所需的效果。
- en: '**Parallax Ratio:**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视差比率：**'
- en: This ratio determines how real game coordinates affect the coordinates of this
    particular parallaxed layer. A ratio of `ccp(2,0)` means the sprite will scroll
    twice as fast on the X and not at all on the Y. Higher (faster) ratios are typically
    drawn closer to the camera.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个比率决定了游戏坐标如何影响这个特定视差层的坐标。`ccp(2,0)`的比率意味着精灵在X轴上滚动速度是两倍，而在Y轴上则完全不滚动。更高的（更快的）比率通常绘制得离相机更近。
- en: '**Position Offset:**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置偏移：**'
- en: The position offset of each child node represents where it will be drawn when
    its parent (the `CCParallaxNode`) is at the origin or `ccp(0,0)`. Once the main
    `CCParallaxNode` instance moves the children will move with the proper ratio.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个子节点的位置偏移量代表当其父节点（`CCParallaxNode`）位于原点或`ccp(0,0)`时，它将被绘制的位置。一旦主`CCParallaxNode`实例移动，子节点将以适当的比率移动。
- en: There's more...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a number of ways to loop a parallaxed background. One involves checking
    the `parallaxNode` position at every step and adjusting all the child position
    offsets based on the integer value of the parallax node X position divided by
    the screen size:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以循环视差背景。一种方法是在每一步检查`parallaxNode`的位置，并根据视差节点X位置除以屏幕大小的整数值调整所有子节点的位置偏移量：
- en: '[PRE39]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This effectively resets the child positions after the `parallaxNode` has moved
    one full screen width.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在`parallaxNode`移动一个完整屏幕宽度后重置了子节点的位置。
- en: Lighting using glColorMask
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`glColorMask`进行光照
- en: '**Lighting** is a fundamental part of most 3D video games. 2D games do not
    naturally lend themselves to lighting effects, but with the right technique we
    can create a 2D experience where lighting plays a vital role. This adds suspense
    to our 2D scene.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**光照**是大多数3D视频游戏的基本组成部分。2D游戏本身并不自然地适合光照效果，但通过正确的技术，我们可以创建一个2D体验，其中光照扮演着至关重要的角色。这为我们的2D场景增添了悬念。'
- en: In this recipe we see a monk walking through a dark cave carrying a lantern.
    The monk's lantern gives off light in a circular shape that illuminates dark parts
    of the scene. As the monk moves through the cave a colony of bats becomes visible.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们看到一位僧人手持灯笼穿过一个黑暗的山洞。僧人的灯笼发出圆形的光，照亮了场景中的黑暗部分。随着僧人穿过山洞，一群蝙蝠变得可见。
- en: '![Lighting using glColorMask](img/4002_01_20.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![使用glColorMask进行光照](img/4002_01_20.jpg)'
- en: Getting ready
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also note that code used to create the 'flying bats' effect has been omitted
    as that was covered in a previous recipe.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目`RecipeCollection01`以获取此菜谱的完整工作代码。此外，请注意，用于创建“飞蝙蝠”效果的代码已被省略，因为那已经在之前的菜谱中介绍过了。
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE40]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Cocos2d exposes just the right amount of OpenGL drawing logic to make complex
    manipulations of rendering order look easy. To achieve this effect we use `CCRenderTexture`.
    First, we clear the screen using the following call:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d仅暴露了足够的OpenGL绘制逻辑，使得复杂的渲染顺序操作看起来很容易。为了实现这种效果，我们使用`CCRenderTexture`。首先，我们使用以下调用清除屏幕：
- en: '[PRE41]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We then limit drawing to only the **alpha channel** using a `glColorMask` call.
    This, in effect, tells OpenGL to modify the opacity (only the opacity, not the
    color) of the graphics buffer based on what we render. So, we render the `fire.png`
    texture to simulate light that is 2D and diffuses in a circle.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后通过`glColorMask`调用仅限制绘制到**alpha通道**。这实际上告诉OpenGL根据我们渲染的内容来修改图形缓冲区的透明度（只有透明度，而不是颜色）。因此，我们渲染`fire.png`纹理来模拟2D光并在圆形中扩散。
- en: Finally, we additively draw another `fire.png` texture over this one to simulate
    the brightness and color of the light.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在上面添加另一个`fire.png`纹理以模拟光亮和颜色。
- en: The node `darknessLayer` is only rendered within the screen's viewing area while
    `burnSprite` and `lightSprite` are rendered at the lantern's position.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 节点`darknessLayer`仅在屏幕的视图中绘制，而`burnSprite`和`lightSprite`则在灯笼的位置绘制。
- en: There's more...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using a similar technique lights can be created in all shapes, sizes, and colors.
    These can include animated lights like torches, shaped lights like a car's headlights,
    or short, quick lighting effects like a bright flash from an explosion.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的技术，可以创造出各种形状、大小和颜色的灯光。这包括像火炬这样的动画灯光、像汽车前灯这样的形状灯光，或者像爆炸时明亮的闪光这样的短暂快速灯光效果。
- en: Most importantly, this effect gives us the ability to tease the player with
    what may or may not lurk in the shadows of the game world.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，这种效果让我们能够用可能或可能不存在于游戏世界阴影中的事物来逗弄玩家。
