- en: Chapter 1. Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing OpenGL primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing video files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grid, particle, and motion streak effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Retina Display mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1D and 2D Ease Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering and texturing 3D Cubes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a texture filled polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a texture filled polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping palettes using layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping palettes using CCTexture2DMutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AWTextureFilter for blur and font shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking and using screenshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CCParallaxNode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting using glColorMask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cocos2d** is first and foremost a rich graphical API which allows a game
    developer easy access to a broad range of functionality. In this chapter we will
    go over some more advanced features of Cocos2d and how you can use these features
    to serve a variety of different purposes. We''ll also explain advanced techniques
    that are not yet part of the Cocos2d source.'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this chapter **Graphics** can be considered an umbrella
    term. We will also go over advanced techniques using **Actions** and **Particles**.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most fundamental task in 2D game development is drawing a **sprite**. Cocos2d
    provides the user with a lot of flexibility in this area. In this recipe we will
    cover drawing sprites using `CCSprite`, spritesheets, `CCSpriteFrameCache`, and
    `CCSpriteBatchNode`. We will also go over **mipmapping**. To keep things fun and
    interesting, many recipes in this book will have a distinct theme. In this recipe
    we see a scene with Alice from Through The Looking Glass.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing sprites](img/4002_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for the full working code of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe takes us through most of the common ways of drawing sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a CCSprite from a file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we have the simplest way to draw a sprite. This involves using the CCSprite
    class method as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the most straightforward way to initialize a sprite and is adequate
    for many situations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Other ways to load a sprite from a file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, we will see examples of `CCSprite` creation using `UIImage/CGImageRef,
    CCTexture2D,` and a `CCSpriteFrame` instantiated using a `CCTexture2D` object.
    `CGImageRef` support allows you to tie Cocos2d into other frameworks and toolsets.
    `CCTexture2D` is the underlying mechanism for texture creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Loading spritesheets using CCSpriteFrameCache:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will see the most powerful way to use sprites, the `CCSpriteFrameCache`
    class. Introduced in `Cocos2d-iPhone v0.99`, the `CCSpriteFrameCache` singleton
    is a cache of all sprite frames. Using a **spritesheet** and its associated `PLIST`,
    file (created using **Zwoptex**, more on this later) we can load multiple sprites
    into the cache. From here we can create `CCSprite` objects with sprites from the
    cache:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Mipmapping:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mipmapping allows you to scale a texture or to zoom in or out of a scene without
    aliasing your sprites. When we scale Alice down to a small size, aliasing will
    inevitably occur. With mipmapping turned on, Cocos2d dynamically generates lower
    resolution textures to smooth out any pixelation at smaller scales. Go ahead and
    comment out the following lines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you should see this pixelation as Alice gets smaller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Drawing many derivative sprites with CCSpriteBatchNode:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CCSpriteBatchNode` class, added in `v0.99.5`, introduces an efficient
    way to draw and re-draw the same sprite over and over again. A batch node is created
    with the following method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you create as many sprites as you want using the follow code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting the capacity to the number of sprites you plan to draw tells Cocos2d
    to allocate that much space. This is yet another tweak for extra efficiency, though
    it is not absolutely necessary that you do this. In these three examples we draw
    10 randomly placed clouds and 60 randomly placed bits of grass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Drawing colored rectangles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we have a fairly simple technique that has a variety of uses. By drawing
    a sprite with a blank 1px by 1px white texture and then coloring it and setting
    its `textureRect` property we can create very useful colored bars:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example we have used this technique to create very simple ground and
    sky backgrounds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coloring sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe we used colored rectangles to draw both the ground and
    the sky. The ability to set texture color and opacity are simple tools which,
    if used properly, can create very cool effects. In this recipe we will create
    a cinematic scene where two samurai face each other with glowing swords.
  prefs: []
  type: TYPE_NORMAL
- en: '![Coloring sprites](img/4002_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also, note that some code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows a number of color based techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting sprite color:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The simplest use of color involves setting the color of a sprite using the
    following method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting sprite color effectively reduces the color you can display but it allows
    some programmatic flexibility in drawing. In this recipe we use `setColor` for
    a number of things, including drawing a blue sky, a yellow sun, black "dramatic
    movie bars", and more.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ccColor3B` is a C struct which contains three `GLubyte` variables. Use the
    following helper macro to create `ccColor3B` structures:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Cocos2d also specifies a number of pre-defined colors as constants. These include
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fading to a color:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To fade a scene to a specific color we use the blank.png technique we went
    over in the last recipe. We first draw a sprite as large as the screen, then color
    the sprite to the color we want to fade to, and then finally run a CCFadeIn action
    on the sprite to fade to that color:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using CCGradientLayer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the CCGradientLayer class we can programmatically create gradients. To
    make the mountains in the background fade into the ground the two samurai are
    standing on we created a gradient using this method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because `CCGradientLayer` lets you control opacity as well as color, it has
    many uses. As you can see there is also a sinister red glow behind the evil samurai.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Making a sprite glow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make the swords in the demo glow we use subtle color manipulation, additive
    blending and fading and scaling actions. First we load the **fire.png** sprite
    supplied by Cocos2d. By changing its X and Y scale independently we can make it
    thinner or fatter. Once you have the desired scale ratio (in this demo we use
    x:y 3:11 because the sword is so thin) you can constantly scale and fade the sprite
    in and out to give some life to the effect. You also need to set the blend function
    to `{ GL_ONE, GL_ONE }` for additive blending. Finally this effect sprite is added
    to the actual sprite to make it seem like it glows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Animating sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to add some animation to our sprites. One thing that should be
    stressed about animation is that it is only as complicated as you make it. In
    this recipe we will use very simple animation to create a compelling effect. We
    will create a scene where bats fly around a creepy looking castle. I've also added
    a cool lightning effect based on the technique used to make the swords glow in
    the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating sprites](img/4002_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also note that some code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows us how to structure animation based classes through the use
    of `SimpleAnimObject:`
  prefs: []
  type: TYPE_NORMAL
- en: 'Animated object class structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When switching from one animation to another it is often important to keep
    track of what state the animated object is in. In our example we use `SimpleAnimObject`,
    which keeps an arbitrary `animationType` variable. We also maintain a velocity
    variable that has a Y scalar value that is inversely proportional to the animation
    frame delay:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on how in-depth you want your animation system to be you should maintain
    more information such as, for example, a pointer to the running `CCAnimation`
    instance, frame information, and physical bodies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you get more involved with Cocos2d game development you will become more
    and more tempted to use **asynchronous actions** for gameplay logic and AI. Derived
    from the `CCAction` class, these actions can be used for everything from moving
    a `CCNode` using `CCMoveBy` to animating a `CCSprite` using `CCAnimate`. When
    an action is run, an asynchronous timing mechanism is maintained in the background.
    First time game programmers often over-rely on this feature. The extra overhead
    required by this technique can multiply quickly when multiple actions are being
    run. In the following example we have used a simple integer timer that allows
    us to regulate how long lightning lasts onscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Synchronous timers** like the one shown in the preceding code snippet are
    often, but not always, preferable to asynchronous actions. Keep this in mind as
    your games grow in size and scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing OpenGL primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in 2D game development we need to make use of good old-fashioned **OpenGL
    primitives**. With these we can make minimaps, heads up displays, and special
    effects like bullet tracers and lightning blasts to name a few. In the following
    scene I've created a simple figure using all of the primitive drawing functions
    supplied by Cocos2d as well as one I've tweaked and added.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing OpenGL primitives](img/4002_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe shows us how to use each primitive drawing function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding the `draw` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to use OpenGL drawing routines we must override the following method
    of a `CCNode`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As stated in `CCNode.h`, overriding this method gives us control of underlying
    OpenGL drawing routines. The following OpenGL statements are implicit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To overload this method we create a class named `ShapeLayer` which inherits
    from `CCLayer`, and therefore from `CCNode`. Once attached to the scene this overridden
    draw method will be called once every cycle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Primitive drawing functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following primitive drawing functions are available in Cocos2d:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On top of all this we have tweaked `ccDrawCircle` to create `ccDrawSolidCircle`
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we are controlling these OpenGL render calls for each frame this technique
    works well when used in a real-time minimap. We will explore this in a later recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are planning to use primitive drawing extensively you may want to consider
    using the **Vertex Buffer Object** OpenGL extension. Using the GL functions `glGenBuffers,
    glBindBuffer`, and `glBufferData` you can put vertex and other information into
    video memory rather than system memory. This can drastically improve performance
    depending on the situation. For more information view the section *Best Practices
    for Working with Vertex Data* in the Apple Developer document *OpenGL ES Programming
    Guide for iOS* located at [http://developer.apple.com/library/ios/#documentation/3DDrawing/
    Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html](http://developer.apple.com/library/ios/#documentation/3DDrawing/).
  prefs: []
  type: TYPE_NORMAL
- en: Playing video files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **cutscene** is a concept that has existed since the early days of video
    games. Cutscenes are usually interspersed in between gameplay segments or shown
    when a game is loading. For more complex cutscenes it is often advantageous to
    use full motion video. In this recipe we will see how to insert a video into our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing video files](img/4002_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe requires the extra step of linking the **MediaPlayer iOS framework**
    to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click your project under **Groups & Files**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add | Existing Frameworks**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **iOS SDK** select **MediaPlayer.framework**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that `RecipeCollection01` already has this library linked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows us how to load, play, and stop a movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using MPMoviePlayerController:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe is merely the tip of the iceberg regarding movie playback. Movies
    can also be played back in fullscreen mode, in portrait mode, and using a variety
    of other options. Please refer to official Apple documentation when customizing
    and/or adding to this technique.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UsingObjective-C` observers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **observer pattern** is not used very often while doing Cocos2d programming,
    but it is a powerful mechanism and it is the recommended way of knowing when your
    video has finished playback. You can read more about observers by referring to
    the official `Objective-C` documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Movie file format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'According to Apple documentation it is recommended that you compress your movies
    using `H.264/MPEG-4` for video, `AAC` audio and one of the following file formats:
    `MOV, MP4, MPV, 3GP`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is also recommended that your movies be no larger than `640x480` and run
    no faster than `30 FPS`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The movie used in the recipe was created and encoded using Apple's iMovie software.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information please consult official Apple iOS SDK documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Grid, particle, and motion streak effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cocos2d comes equipped with a variety of easy to use special effects. Here,
    we will only briefly go over all of the effects as they are fairly straightforward
    and are well covered in other texts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid, particle, and motion streak effects](img/4002_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get grid effects to show up properly in your game you first need to set the
    `EAGLView pixelFormat` to `kEAGLColorFormatRGBA8` (it is set to `kEAGLColorFormatRGB565`
    by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'Do this by going into your project file''s `${PROJECT_NAME}AppDelegate.m` file
    and changing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we see a number of things. For the sake of brevity I've only
    included one grid effect and two particle effects in the book. Every stock grid
    and particle effect is viewable in `RecipeCollection01`, along with some customized
    particle effects like `Waterfall` and `WaterSplash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom Particles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cocos2d particles have many variables and it is most often advantageous to
    sub-class a built-in particle to help create your own. Here is a list of the built-in
    Cocos2d particles:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using CCMotionStreak:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A motion streak is a great way to add a dynamic element a `CCNode`. These can
    often be combined with particles for a great effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One thing to keep in mind when creating a motion streak is that the texture
    needs to look good when it bends in on itself. **Vertical textures** with **transparent
    gradient edges** usually look the best.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Retina Display mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the iPhone 4 and the iPad support Apple's **Retina Display** mode. On the
    iPhone 4 this doubles the resolution to `960x640`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creators of Cocos2d have taken a lot of care in integrating this feature
    into the framework. Retina display can be turned on with the flick of a switch.
    Getting your game to run similarly in both hi-definition and standard-definition
    can be tricky though. Luckily they have taken this into consideration as well.
    In this recipe we will enable Retina Display and then display a hi-resolution
    image, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Retina Display mode](img/4002_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To properly see Retina Display you need a retina display device. In the simulator
    you need to do the following to switch to an **iPhone Retina** simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the iOS simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the file menu click on **Hardware | Device | iPhone (Retina)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may also of course use a real iPhone 4 or iPad device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First you must enable **Retina Display** in your application. Go into `${PROJECT_NAME}AppDelegate.m`
    and *uncomment* the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Retina Display will now be turned on for devices that support it and turned
    off for devices that do not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One sprite for the price of two:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see the sprite we created is now very large and detailed. If you
    turn Retina Display off or run this on a device that does not support it you will
    see a smaller blurrier sprite. This happens because Retina Display chooses the
    higher resolution version of every sprite if there is one available. We specify
    the higher resolution version with the `-hd` suffix. So, in Retina Display mode
    Cocos2d automatically displays `cocos2d_beginner-hd.png` instead of `cocos2d_beginner.png`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Position, sizing, and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supposedly Cocos2d will convert all coordinate positions, size ratios, and anything
    else accordingly. The only thing you should have to change is adding the high
    resolution imagery.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is recomended that a number of caveats are practiced with this. Lower level
    OpenGL hacking often doesn't display as you would want it to. Be wary of this
    and be sure to test any complex techniques in Retina Display mode before thinking
    about supporting both modes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The downside of Retina Display:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The major downside of Retina Display is simply the amount of disk space it takes
    up. Including all of the HD images will more than double the space all of your
    art assets take up. Also, the higher resolution images take up more memory at
    runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The upside of Retina Display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand Apple keeps increasing app size limits and device memory.
    With newer hardware coming out and the ability to make desktop applications, increased
    resolution is a must for triple-A game titles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1D and 2D Ease Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ease Actions** allow you to fine tune the actions used in your game using
    a number of formulae. They can be applied to any action: moving, scaling, fading,
    and so on. Regarding movement specifically, a small tweak can be applied to allow
    for independent *Easing* on both the X and the Y axis. This can be used to create
    a number of cool effects.'
  prefs: []
  type: TYPE_NORMAL
- en: '![1D and 2D Ease Actions](img/4002_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upon executing this code you should see one character moving in a straight line
    toward the destination while the other moves there in a seemly erratic yet calculated
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uses of 2D eased movement actions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While creating the iOS game *GoldenAgeBaseball* this summer I used `CCMoveByCustom`
    to simulate different pitches. A slider moved down and away, a cutter only away
    and a sinker only down. This variation of pitch styles was crucial to the development
    of the pitching/batting gameplay mechanic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overall, Ease Actions give your game a polished and professional feel. Whether
    you are smoothing out a camera movement or simulating a baseball pitch, Ease Actions
    are a fine tool to help tweak your game to perfection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rendering and texturing 3D shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As odd as it sounds, sometimes in a 2D game you simply just want to add some
    simple **3D graphics**. Whether you are creating a cool 2D/3D hybrid or a simple
    3D game with a 2D HUD, 3D graphics are no easy thing to produce. The complexities
    of a third dimension often conflict with 2D programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, this recipe will show you how to create a **simple
    colored cube** and a **simple textured cube**. The uses of simple geometry are
    varied even when making a 2D game. However, more examples including **shaders**
    and **3D models** are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering and texturing 3D shapes](img/4002_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we see here is a crash course in OpenGL ES cube rendering with a Cocos2d
    twist. Like when we drew OpenGL primitives, here we create another `CCNode` and
    override its draw method to create more complex OpenGL geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Texturing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We harness a `CCSprite` method to load a texture into memory to allow us to
    bind that texture for 3D drawing. This process is fairly straightforward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Depth testing, sizing, and translation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to Cocos2d's built-in depth testing, cubes will be properly ordered based
    on the Z property. The `translation3D.z` value affects the actual size of the
    cube while its `translation3D.x` and `translation3D.y` values affect where it
    is on the screen proportional to `translation3D.z.`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about 3D graphics, please refer to the recipe *Using Cocos3d*
    in [Chapter 8](ch08.html "Chapter 8. Tips, Tools, and Ports"), *Tips, Tools, and
    Ports.*
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a texture-filled polygon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating games with large levels it is often easy to run into memory limitations.
    Large maps also contain repetitive drawing of things like grass, trees, mountains,
    and so on. This recipe will show you how to efficiently render a **polygon** that
    is filled in with a **repeated texture**. These can be drawn at any size and still
    only use a small amount of memory and CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering a texture-filled polygon](img/4002_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TexturedPolygon` takes a given set of **vertices** and uses a **polygon triangulation
    algorithm** to find all triangles contained within the polygon. It then textures
    and draws these triangles using OpenGL triangles strips.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Triangulation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triangulation, depending on the polygon, can be a complex process. This is often
    performed while a map is loading. For very complex polygons it can be advantageous
    to perform polygon triangulation during level creation and store triangle **indices**
    along with the polygon vertices. This can speed up level load times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Uses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textured polygons have many uses including static map textures and background
    textures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Performance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this technique you can efficiently draw polygons of virtually any size.
    Space requirements rely on the size of each texture used rather that the size
    of each polygon. To use less space, modify `TexturedPolygon` to re-use pre-initialized
    textures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Caveats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique has a few caveats. The textures used must be square and each
    side's size must be equal to 2n (16x16, 32x32, 64x64, and so on). Also, textures
    can only be single files, not sprite frames.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe may be your first foray into combining `Objective-C` and `C++` code.
    This is commonly referred to as `Objective-C++`. For more information please refer
    to Apple's official developer documentation *Using C++ With Objective-C* at [http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocCPlusPlus.html).
  prefs: []
  type: TYPE_NORMAL
- en: Animating a texture-filled polygon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TexturedPolygon` can also be easily animated. This is useful for animated
    crowds, ocean waves, bubbling lava pits, and so on. In the example we see an animated
    field of wheat.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating a texture-filled polygon](img/4002_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By dynamically changing the texture using `CCAnimation` we can create very simple
    tiled animation. The only extra cost of this operation is the extra space allocated
    for each frame of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping palettes using layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A vital tool in any game developer's repertoire is the ability to swap color
    palettes. From *The Legend of Zelda* on *NES* to *Halo* on the *Xbox*, palette
    swapping is a simple yet effective visual cue that can stretch a limited amount
    of art.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example you learn how to palette swap using layers. We are
    using an animated baseball player for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Swapping palettes using layers](img/4002_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe you will need an image manipulation program. I recommend the
    free and easy to use *GIMP*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we will do is draw the sprite and the colorable areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Draw your texture with all dynamically colorable areas left blank. In your image
    editing program your texture should look something like the following:![How to
    do it...](img/4002_01_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new layer and color a specific area white. In this example we are coloring
    his uniform (legs and shirt) white:![How to do it...](img/4002_01_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hide the other layer and save that white-only layer as a separate texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for any other separately colored sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have our textures we can write some code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By drawing the swappable layers under the main layer (the black outline) we
    cover up any imprecision in the coloring. This technique is slightly more difficult
    for art that doesn't use a thick black outline like the drawings shown in the
    preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Efficiency—Disk Space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping your iOS app below a certain size on the disk is always a good idea.
    This technique is fairly easy on your disk space as the swappable textures take
    up only a small amount of space due to easy PNG compression of simplistic textures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Efficiency—Memory Usage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately the size of a texture in memory is determined by its pixel size.
    So, if you are palette swapping large animated textures you might run into memory
    consumption issues. Memory consumption for a palette swapped texture equals the
    normal memory size times the number of palettes to swap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Efficiency—CPU:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When animating a palette swapped texture the CPU time used by the animation
    routine will also be multiplied by the number of swappable layers. This is usually
    fairly inconsequential as animation takes up very little CPU time as it is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Swapping palettes using CCTexture2DMutable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to palette swap involves **sentinel colors** and the ability to
    modify a texture pixel by pixel. This method can help reclaim some extra space
    on the disk and in memory but it tends to take a lot of CPU time. It is also messier
    than the previous technique when used with anti-aliased or blended textures.
  prefs: []
  type: TYPE_NORMAL
- en: '![Swapping palettes using CCTexture2DMutable](img/4002_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the `project RecipeCollection01` for full working code of this
    recipe. Also note the included library `CCTexture2DMutable` that is not included
    in the book itself.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe you will need an image manipulation program. Once again I recommend
    the free and easy to use *GIMP*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we will do is draw a sprite that contains colorable areas defined
    by sentinel colors. A sentinel color is usually a primary color that is easily
    recognizable and can be replaced programmatically. In this case we will use red,
    blue, and green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4002_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is best to avoid aliasing and blending as much as possible when using this
    technique. Adjusting your coloring algorithm's tolerance according to your texture
    can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For better or worse this technique works the same way color selection and replacement
    works in *Adobe Photoshop*, and similar drawing programs. Using `CCTexture2DMutable`
    can often be a slow process and this technique is only recommended for games that
    require pixel-perfect graphics or have very strict space/memory requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Using AWTextureFilter for blur and font shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By harnessing `CCTexture2DMutable` the class `AWTextureFilter` can be used
    to create some cool effects. These include **Gaussian Blur**, selective Gaussian
    Blur, and dynamically generated font shadows as shown in the following scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using AWTextureFilter for blur and font shadows](img/4002_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AWTextureFilter` uses `CCTexture2DMutable` to achieve a compelling Gaussian
    Blur effect. This is one example of complex pixel manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Font shadows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CCTexture2DMutable` inherits from `CCTexture2D`. This allows us to use the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This creates a label texture that we can then use to create a blurred font shadow
    effect by creating a similar texture that we offset, darken, blur, and finally
    draw behind the original label texture.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few other suggestions for the use of this blurring technique:'
  prefs: []
  type: TYPE_NORMAL
- en: Blurring a screenshot as a background for the pause menu (see the next recipe
    in this chapter, *Taking and using screenshots)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine with a color effect for a cool glow effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase or decrease blur radius for reveal-based puzzle and trivia games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking and using screenshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As hinted in the last recipe, in-game screenshots can be taken and used in-game
    to create cool effects like a blurred background for a pause menu. For an example
    of this in a published app, take a look at the pause menu in *2K Sports NHL 2K11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking and using screenshots](img/4002_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also note the included library `Screenshot` that is not included in the
    book itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The included `Screenshot` library uses some complex iOS techniques that are
    beyond the scope of this book. The library is included in `RecipeCollection01`.
    You can take a look at it there.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, `Screenshot` takes a capture of what's currently on the screen and
    shoves that into a `CCTexture2D` for you to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Live screenshots can be used for a wide variety of things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Screenshot highlights and recaps of interesting moments of gameplay at the end
    of a match or level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the fact that you can analyze exactly what the player is currently
    seeing you could "break the fourth wall" (think *Psycho Mantis* in *Metal Gear
    Solid* for *Sony PlayStation)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-game user controlled camera like in *Pokemon Snap* for *Nintentdo 64*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CCParallaxNode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Parallaxing** is a staple of 2D side-scrolling video games. A competent developer
    would be remiss if he didn''t include a nice parallaxed background in a 2D side-scroller.
    Cocos2d makes parallaxing easy with CCParallaxNode.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using CCParallaxNode](img/4002_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cocos2d makes it very easy to create a professional looking scrolling background.
    `CCParallaxNode` breaks the concept of parallaxing down to its key components.
    In the following example we attach four sprites to an instance of `CCParallaxNode`.
    Keep in mind that you can attach any `CCNode` to a `CCParallaxNode`. We then set
    `parallaxRatio` and `parallaxOffset` to create the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallax Ratio:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ratio determines how real game coordinates affect the coordinates of this
    particular parallaxed layer. A ratio of `ccp(2,0)` means the sprite will scroll
    twice as fast on the X and not at all on the Y. Higher (faster) ratios are typically
    drawn closer to the camera.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Position Offset:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position offset of each child node represents where it will be drawn when
    its parent (the `CCParallaxNode`) is at the origin or `ccp(0,0)`. Once the main
    `CCParallaxNode` instance moves the children will move with the proper ratio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of ways to loop a parallaxed background. One involves checking
    the `parallaxNode` position at every step and adjusting all the child position
    offsets based on the integer value of the parallax node X position divided by
    the screen size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This effectively resets the child positions after the `parallaxNode` has moved
    one full screen width.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting using glColorMask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lighting** is a fundamental part of most 3D video games. 2D games do not
    naturally lend themselves to lighting effects, but with the right technique we
    can create a 2D experience where lighting plays a vital role. This adds suspense
    to our 2D scene.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we see a monk walking through a dark cave carrying a lantern.
    The monk's lantern gives off light in a circular shape that illuminates dark parts
    of the scene. As the monk moves through the cave a colony of bats becomes visible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting using glColorMask](img/4002_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project `RecipeCollection01` for full working code of this
    recipe. Also note that code used to create the 'flying bats' effect has been omitted
    as that was covered in a previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cocos2d exposes just the right amount of OpenGL drawing logic to make complex
    manipulations of rendering order look easy. To achieve this effect we use `CCRenderTexture`.
    First, we clear the screen using the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We then limit drawing to only the **alpha channel** using a `glColorMask` call.
    This, in effect, tells OpenGL to modify the opacity (only the opacity, not the
    color) of the graphics buffer based on what we render. So, we render the `fire.png`
    texture to simulate light that is 2D and diffuses in a circle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we additively draw another `fire.png` texture over this one to simulate
    the brightness and color of the light.
  prefs: []
  type: TYPE_NORMAL
- en: The node `darknessLayer` is only rendered within the screen's viewing area while
    `burnSprite` and `lightSprite` are rendered at the lantern's position.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a similar technique lights can be created in all shapes, sizes, and colors.
    These can include animated lights like torches, shaped lights like a car's headlights,
    or short, quick lighting effects like a bright flash from an explosion.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, this effect gives us the ability to tease the player with
    what may or may not lurk in the shadows of the game world.
  prefs: []
  type: TYPE_NORMAL
