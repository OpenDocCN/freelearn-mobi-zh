<html><head></head><body>
		<div><h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor305"/>Chapter 10</em>: Test Your App with UI and Unit Tests</h1>
			<p>In the previous chapters, one of our main focuses was to have a testable architecture. We tried to achieve that by decoupling different components from each other.</p>
			<p>In this chapter, because of the architecture we put in place, we will see how easy it is to test in isolation different parts of the Restaurants app.</p>
			<p>In the <em class="italic">Exploring the fundamentals of testing</em> section, we will be understanding the benefits of testing and exploring various types of tests. In the <em class="italic">Learning the basics of testing your Compose UI</em> section, we will learn how to test our Compose UI. </p>
			<p>Finally, in the <em class="italic">Covering the basics of unit-testing your core logic</em> section, we will learn how to test the core functionality of your Restaurants app.</p>
			<p>To summarize, in this chapter we will be covering the following sections:</p>
			<ul>
				<li>Exploring the fundamentals of testing</li>
				<li>Learning the basics of testing your Compose UI</li>
				<li>Covering the basics of unit-testing your core logic</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor306"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you also have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>The Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_09</code> directory of the repository and import the Android project entitled <code>chapter_9_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_10</code> directory: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app</a></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor307"/>Exploring the fundamentals of testing</h1>
			<p>In this section, we will briefly cover the <a id="_idIndexMarker733"/>basics of testing. More precisely, we will be doing the following:</p>
			<ul>
				<li>Understanding the benefits of testing</li>
				<li>Exploring the types of tests</li>
			</ul>
			<p>Let's start with the benefits of testing!</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor308"/>Understanding the benefits of testing</h2>
			<p>Testing our <a id="_idIndexMarker734"/>code is essential. Through tests, we ensure that our app's functional behavior is correct and as expected, while also making sure that it's usable, just as it was designed. By performing tests, we can release stable and functional apps to end users.</p>
			<p>More importantly, if we develop an app and then test it consistently, we ensure that new updates with new functionality won't break the existing functionality, and no bugs will arise. This is often<a id="_idIndexMarker735"/> referred to as <strong class="bold">regression testing</strong>.</p>
			<p>You can test your app manually by navigating through it on your device or emulator and making sure that every piece of data is displayed correctly, while also being able to interact correctly with every UI component.</p>
			<p>However, manual testing is neither efficient nor fast. With manual testing, you must traverse every user flow, generate every user interaction, and verify the integrity of data displayed at any moment. Also, you must do this, consistently, on every application update. Moreover, manual testing scales poorly, as with every new update that contains a new functionality, the manual workload of testing the entire application increases.</p>
			<p>Over time, manual testing becomes a burden for medium- and large-sized applications. Also, manual testing involves a human tester, which generates a human factor â€“ this basically means that a tester may or may not in some circumstances overlook some bugs.</p>
			<p>To alleviate these issues, in this chapter, we will be writing automated tests. Practically, we will define some scripted tests and then allow tools to run them, automatically. This approach is faster, consistent, and more efficient, as it scales better with the size of the project.</p>
			<p>In other words, we will <a id="_idIndexMarker736"/>write other chunks of code that will test the code of our application. While this might sound weird, the approach of having automated tests is much more productive and reliable, and less time-consuming than manual testing.</p>
			<p>Next up, let's cover the different types of tests that we can write.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor309"/>Exploring types of tests</h2>
			<p>To better understand how<a id="_idIndexMarker737"/> to write tests, we must first decide <em class="italic">what exactly can be tested</em> in our apps. From this perspective, let's cover the most important types of tests:</p>
			<ul>
				<li><strong class="bold">Functional tests</strong>: Is the app <a id="_idIndexMarker738"/>doing what is expected? We already touched<a id="_idIndexMarker739"/> upon functional tests and their benefits in the <em class="italic">Understanding the benefits of testing</em> section.</li>
				<li><strong class="bold">Compatibility tests</strong>: Is the <a id="_idIndexMarker740"/>app working correctly on all devices and <a id="_idIndexMarker741"/>Android API levels? The Android ecosystem makes this particularly difficult if you consider the variety of devices and manufacturers.</li>
				<li><strong class="bold">Performance tests</strong>: Is the app fast or <a id="_idIndexMarker742"/>efficient enough? Sometimes, apps<a id="_idIndexMarker743"/> can suffer from bottlenecks and UI stutters that can be identified via performance benchmarks.</li>
				<li><strong class="bold">Accessibility tests</strong>: Is the app working <a id="_idIndexMarker744"/>well with accessibility<a id="_idIndexMarker745"/> services? Such services are used to assist users with disabilities in using our Android application.</li>
			</ul>
			<p>In this chapter, we will be mainly focusing on functional tests in an attempt to ensure the functional integrity of our application.</p>
			<p>Now, apart from deciding what has to be tested, we must also think about the <em class="italic">scope or size of the tests</em>. The scope<a id="_idIndexMarker746"/> indicates the size of the app's portion we're testing. From the perspective of the <a id="_idIndexMarker747"/>scope of the tests, we have the following:</p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: Often referred to as <a id="_idIndexMarker748"/>small tests, these test the functional behavior of methods, classes, or groups of classes in an isolated environment. Usually, unit tests target small portions of the app without interacting with the real-world environment; hence, they are more reliable than tests that depend on external input.</li>
				<li><strong class="bold">Integration tests</strong>: Often referred to<a id="_idIndexMarker749"/> as medium tests, these test whether multiple units interact and function correctly together.</li>
				<li><strong class="bold">End-to-end tests</strong>: Often <a id="_idIndexMarker750"/>referred to as big tests, these test large portions of the application, from multiple screens to entire user flows.</li>
			</ul>
			<p>Depending on the size of the tests, each type has a degree of isolation. The <strong class="bold">degree of isolation</strong> is tightly related to the <a id="_idIndexMarker751"/>scope of the tests, as it measures how <a id="_idIndexMarker752"/>dependent the component we're testing is on other components. As the size of the test increases, from small to big, the isolation level of the tests decreases.</p>
			<p>In this chapter, we will be mainly focusing on unit tests, as they are fast, with the simplest setup, and most reliable in helping us validate the functionality of our application. These traits are tightly related to the higher isolation level of unit tests from external components.</p>
			<p>Lastly, we must also classify tests based on the system they will be running on:</p>
			<ul>
				<li><strong class="bold">Local tests</strong>: Run on your <a id="_idIndexMarker753"/>workstation or development system (used in<a id="_idIndexMarker754"/> practices such as <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>)) without the need of an Android device or emulator. They are usually small and fast, isolating the component under test from the rest of the application. Most of the time, unit tests are local tests.</li>
				<li><strong class="bold">Instrumented tests</strong>: Run on an Android device, be it a physical device or emulator. Most of the time, UI tests are<a id="_idIndexMarker755"/> considered instrumented tests, since they allow the automated testing of an application on an Android device.</li>
			</ul>
			<p>In this chapter, our unit tests will be local when we will be testing the core logic of some components in isolation <a id="_idIndexMarker756"/>and instrumented when we will be performing UI unit tests for a specific screen in isolation.</p>
			<p>Let's proceed with local UI tests first!</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor310"/>Learning the basics of testing your Compose UI</h1>
			<p>UI tests allow us to evaluate <a id="_idIndexMarker757"/>the behavior of our Compose code against what is expected to be correct. This way, we can catch bugs early in our UI development process.</p>
			<p>To test our UI, we must first decide what we are aiming to evaluate. To keep it simple, in this section, we will unit-test our UI in an isolated environment. In other words, we want to test the following:</p>
			<ul>
				<li>That our composable screens consume the received state as expected. We want to make sure that the UI correctly represents the different state values that it can receive.</li>
				<li>For our composable screens, that user-generated events are correctly forwarded to the caller of the composable.</li>
			</ul>
			<p>To keep our tests simple, we will define these tests as unit tests and try to isolate screen composables from their <code>ViewModel</code> or from other screen composables; otherwise, our test will become an integration or an end-to-end test. </p>
			<p>In other words, we will test separately each screen, with total disregard of anything outside of their composable function definition. Even though our tests will run on an Android device, they will be testing only one unit â€“ a screen composable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some UI tests can also be considered unit tests, as long as they are testing only one part of the UI of your application, as we will do in this section.</p>
			<p>For starters, we<a id="_idIndexMarker758"/> need to test the first screen of our application, represented by the <code>RestaurantsScreen()</code> composable. Let's begin!</p>
			<ol>
				<li>First, add the following testing dependencies inside the <code>dependencies</code> block of the app-level <code>build.gradle</code> file:<pre>dependencies {
Â Â Â Â [â€¦]
<strong class="bold">Â Â Â Â androidTestImplementation "androidx.compose.ui:ui-</strong>
<strong class="bold">Â Â Â Â Â Â Â Â test-junit4:$compose_version"</strong>
<strong class="bold">Â Â Â Â debugImplementation "androidx.compose.ui:ui-test-</strong>
<strong class="bold">Â Â Â Â Â Â Â Â manifest:$compose_version"</strong>
}</pre></li>
			</ol>
			<p>These dependencies will allow us to run our Compose UI tests on an Android device.</p>
			<p>After updating the <code>build.gradle</code> file, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Before creating a test class, locate the <code>androidTest</code> package that is suited for instrumented tests:</li>
			</ol>
			<div><div><img src="img/B17788_10_01.jpg" alt="Figure 10.1 â€“ Observing the androidTest package for UI tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 â€“ Observing the androidTest package for UI tests</p>
			<p>In Android projects, this<a id="_idIndexMarker759"/> directory stores source files for UI tests. Also note that the pre-built <code>ExampleInstrumentedTest</code> class resides in this directory.</p>
			<ol>
				<li value="3">Create an empty Kotlin class named <code>RestaurantsScreenTest</code> inside the <code>androidTest</code> package.</li>
			</ol>
			<p>Inside this class, we will define a method for each independent test. Behind the scenes, every method will become a standalone UI test that can pass or fail.</p>
			<ol>
				<li value="4">Before creating our first test method, inside the <code>RestaurantsScreenTest</code> class, add the following code:<pre><strong class="bold">import androidx.compose.ui.test.junit4.*</strong>
<strong class="bold">import org.junit.Rule</strong>
class RestaurantsScreenTest {
<strong class="bold">Â Â Â Â @get:Rule</strong>
<strong class="bold">Â Â Â Â val testRule: ComposeContentTestRule = </strong>
<strong class="bold">Â Â Â Â Â Â Â Â createComposeRule()</strong>
}</pre></li>
			</ol>
			<p>To run our Compose UI tests, we are using the JUnit testing framework that will allow us to write repeatable unit tests <a id="_idIndexMarker760"/>in an isolated environment with the help of a test rule. <strong class="bold">Test rules</strong> allow us to add functionality to all the tests within a test class.</p>
			<p>In our case, we need to test Compose UI in every test method, so we had to use a special <code>ComposeContentTestRule</code> object. To access this rule, we have previously imported a special JUnit rule dependency so that our test class now defines a <code>testRule</code> variable and instantiates it by using the <code>createComposeRule()</code> method.</p>
			<p><code>ComposeContentTestRule</code> will not only allow us to set the Compose UI under test but also host tests on an Android device, while also giving us the ability to interact with the composables under test or perform UI assertions.</p>
			<p>Before writing our first test method though, we need to clearly understand what behavior we are trying to test.</p>
			<p>Let's have a look at how our <code>RestaurantsScreen()</code> composable consumes a <code>RestaurantsScreenState</code> instance from its <code>state</code> parameter, and how it forwards events to its caller through the <code>onItemClick</code> and <code>onFavoriteClick</code> function parameters:</p>
			<pre>@Composable
fun RestaurantsScreen(
Â Â Â Â <strong class="bold">state: RestaurantsScreenState</strong>,
Â Â Â Â <strong class="bold">onItemClick: (id: Int) -&gt; Unit</strong>,
Â Â Â Â <strong class="bold">onFavoriteClick: (id: Int, oldValue: Boolean) -&gt; Unit</strong>
) {
Â Â Â Â Box(â€¦) {
Â Â Â Â Â Â Â Â LazyColumn(â€¦) {
Â Â Â Â Â Â Â Â Â Â Â Â items(<strong class="bold">state.restaurants</strong>) { restaurant -&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â RestaurantItem(restaurant,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  onFavoriteClick = { id, oldValue -&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">onFavoriteClick</strong>(id, oldValue) },
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  onItemClick = { id -&gt; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">onItemClick </strong>(id) })
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if(<strong class="bold">state.isLoading</strong>)
Â Â Â Â Â Â Â Â Â Â Â Â CircularProgressIndicator()
Â Â Â Â Â Â Â Â if(<strong class="bold">state.error != null</strong>)
Â Â Â Â Â Â Â Â Â Â Â Â Text(state.error)
Â Â Â Â }
}</pre>
			<p>By looking at the previous snippet, we <a id="_idIndexMarker761"/>see that we can test how the <code>onItemClick</code> and <code>onFavoriteClick</code> functions are called, based on different UI interactions, and also that we can test whether the state is consumed correctly or not. Yet we can't infer very well the possible values of the state that our composable is receiving.</p>
			<p>To get an overview of the possible states that we want to feed into our <code>RestaurantsScreen()</code> so that we can test its behavior, we need to have a look at its state producer, <code>RestaurantsViewModel</code>:</p>
			<pre>class RestaurantsViewModel @Inject constructor(â€¦) : ViewModel() {
<strong class="bold">Â Â Â Â private val _state = mutableStateOf(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â RestaurantsScreenState(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â restaurants = listOf(),</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â isLoading = true</strong>
<strong class="bold">Â Â Â Â Â Â Â Â )</strong>
<strong class="bold">Â Â Â Â )</strong>
Â Â Â Â [â€¦]
Â Â Â Â private val errorHandler = CoroutineExceptionHandler
Â Â Â Â { ... -&gt;
Â Â Â Â Â Â Â Â exception.printStackTrace()
<strong class="bold">Â Â Â Â Â Â Â Â _state.value = _state.value.copy(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â error = exception.message,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false)</strong>
<strong class="bold">Â Â Â Â </strong>}
Â Â Â Â init { getRestaurants() }
Â Â Â Â fun toggleFavorite(itemId: Int, oldValue: Boolean) {
Â Â Â Â Â Â Â Â [â€¦]
Â Â Â Â }
Â Â Â Â private fun getRestaurants() {
Â Â Â Â Â Â Â Â viewModelScope.launch(errorHandler) {
Â Â Â Â Â Â Â Â Â Â Â Â val restaurants = getRestaurantsUseCase()
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â _state.value = _state.value.copy(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants = restaurants,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false)</strong>
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre>
			<p>We can say that our screen should have three<a id="_idIndexMarker762"/> possible states:</p>
			<ul>
				<li><code>ViewModel</code> class in the initialization of the <code>_state</code> variable, where the <code>restaurants</code> parameter of <code>RestaurantsScreenState</code> is set to <code>emptyList()</code> and the <code>isLoading</code> parameter is set to <code>true</code>.</li>
				<li><code>getRestaurants()</code> method where we mutated the initial state and set the <code>isLoading</code> parameter to <code>false</code>, while also passing the list of restaurants to the <code>restaurants</code> parameter.</li>
				<li><code>CoroutineExceptionHandler</code> where the <code>isLoading</code> parameter is set to <code>false</code> to reset the loading status, while also passing the message of <code>Exception</code> to the <code>error</code> parameter.</li>
			</ul>
			<p>Now that we know what behavior the <code>RestaurantsScreen</code> composable should exhibit and <a id="_idIndexMarker763"/>what input we should pass to it in order to produce such a behavior, it's time to actually put our composable screen under test.</p>
			<p>Let's begin by verifying whether the <code>RestaurantsScreen</code> composable correctly renders the first state â€“ that is, the initial loading state.</p>
			<ol>
				<li value="5">Inside the <code>RestaurantsScreenTest</code> class, add an empty test function named <code>initialState_isRendered()</code> that will later test whether our <code>RestaurantsScreen()</code> composable properly renders the initial state:<pre>class RestaurantsScreenTest {
Â Â Â Â @get:Rule
Â Â Â Â val testRule: ComposeContentTestRule = 
Â Â Â Â Â Â Â Â createComposeRule()
Â Â Â Â 
<strong class="bold">Â Â Â Â @Test</strong>
<strong class="bold">Â Â Â Â fun initialState_isRendered() {Â Â }</strong>
}</pre></li>
			</ol>
			<p>To tell the JUnit testing library to run an individual test for this method, we've annotated it with the <code>@Test</code> annotation.</p>
			<p>Also, note that we named this <a id="_idIndexMarker764"/>method around the specific behavior it's trying to test, going from what we're testing (the initial state) to how it's supposed to behave (to be rendered correctly), while separating these two with an underscore. For unit tests, there are a lot of naming conventions, yet we will try to stick to the simple version mentioned before.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Each test method annotated with <code>@Test</code> should focus on only one specific behavior, just as <code>initialState_isRendered()</code> will test whether the <code>RestaurantsScreen()</code> properly renders the initial state, and no other pieces. This allows us to focus on only one behavior on each test method so that we can better identify later which specific behavior is no longer working as expected.</p>
			<ol>
				<li value="6">Prepare the <code>initialState_isRendered()</code> method to set the Compose UI by calling <code>testRule.setContent()</code>, just as our <code>MainActivity</code> did with its own <code>setContent()</code> method:<pre>Â Â Â Â @Test
Â Â Â Â fun initialState_isRendered() {
Â Â Â Â Â Â Â Â <strong class="bold">testRule.setContent { }</strong>
Â Â Â Â }</pre></li>
				<li>Inside the block of code exposed by the <code>setContent()</code> method, we must pass the <strong class="bold">unit under test</strong>, which is nothing else than the composable we're trying to test.</li>
			</ol>
			<p>In our case, we will pass the <code>RestaurantsScreen()</code> composable, not before wrapping it inside the <code>RestaurantsAppTheme()</code> theme function so that the Compose UI that is under test mimics what our app is actually displaying in the production code:</p>
			<pre>@Test
fun initialState_isRendered() {
<strong class="bold">Â Â Â Â testRule.setContent {</strong>
<strong class="bold">Â Â Â Â Â Â Â Â RestaurantsAppTheme {</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen()</strong>
<strong class="bold">Â Â Â Â Â Â Â Â }</strong>
<strong class="bold">Â Â Â Â }</strong>
}</pre>
			<p>If you have named your app name differently, then<a id="_idIndexMarker765"/> the theme composable might have a different definition.</p>
			<ol>
				<li value="8">Now, the <code>RestaurantsScreen()</code> composable is expecting a <code>RestaurantsScreenState</code> object into its <code>state</code> parameter and two functions for its <code>onFavoriteClick()</code> and <code>onItemClick()</code> parameters. Let's add these while also passing the expected initial state from the screen's <code>ViewModel</code>:<pre>Â Â Â Â @Test
Â Â Â Â fun initialState_isRendered() {
Â Â Â Â Â Â Â Â testRule.setContent {
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">RestaurantsAppTheme {</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â state = RestaurantsScreenState(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants = emptyList(),</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = true),</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onFavoriteClick = </strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {Â Â _: Int, _: Boolean -&gt;Â Â },</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onItemClick = { })</strong>
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }</pre></li>
			</ol>
			<p>Since we're looking to test <a id="_idIndexMarker766"/>whether <code>RestaurantsScreen()</code> is correctly rendering the initial state, we have passed an instance of <code>RestaurantsScreenState</code> that had the <code>restaurants</code> parameter set to <code>emptyList()</code>, and the <code>isLoading</code> parameter is set to <code>true</code> while the <code>error</code> parameter is by default set to <code>null</code>.</p>
			<p>We have now finished setting up the <code>RestaurantsScreen()</code> composable and fed it with the expected initial state. It's time to perform the assertion of whether our composable is correctly consuming this initial state or not.</p>
			<p>In the <code>RestaurantsScreen()</code> composable, the initial state is a state mainly defined by the loading indicator that expresses how the app is waiting for content:</p>
			<pre>@Composable
fun RestaurantsScreen(â€¦) {
Â Â Â Â Box(â€¦) {
Â Â Â Â Â Â Â Â LazyColumn(â€¦) {â€¦}
Â Â Â Â Â Â Â Â if(<strong class="bold">state.isLoading</strong>)
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">CircularProgressIndicator()</strong>
Â Â Â Â Â Â Â Â if(state.error != null)
Â Â Â Â Â Â Â Â Â Â Â Â Text(state.error)
Â Â Â Â }
}</pre>
			<p>That's why we can check whether the <code>CircularProgressIndicator()</code> is visible on the screen. But how can we assert whether this composable is visible or not?</p>
			<p>Compose provides us with<a id="_idIndexMarker767"/> several testing APIs to help us find elements, verify their attributes, and even perform user actions. For UI tests with Compose, we consider pieces of UI as <strong class="bold">nodes</strong> that we can identify with the help of semantics. <strong class="bold">Semantics</strong> give meaning to a UI element, and for an entire composable hierarchy, a semantics tree is generated to describe it.</p>
			<p>In other words, we should be able to identify anything that is described on the screen with the help of its exposed semantics.</p>
			<p>To give an example, a <code>Text</code> composable that displays a <code>String</code> object such as <code>"Hello"</code> will become a node in the semantics tree that we can identify by its <code>text</code> property value â€“ <code>"Hello"</code>. Similarly, composables such as <code>Image</code> expose a mandatory <code>contentDescription</code> parameter whose value will allow us to identify the corresponding node in the semantics tree inside our tests. Don't worry â€“ we'll see a practical example of this in a second.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While the semantics attributes are mainly used for accessibility purposes (<code>contentDescription</code>, for example, is a parameter that allows people with disabilities to better understand what the visual element it describes is about), it's also a great tool that exposes semantics used to identify nodes in our tests.</p>
			<p>Now that we have briefly covered how we can use semantics information to identify UI elements as nodes, it's time to get back to our test, which should validate if, upon an initial state consumed by <code>RestaurantsScreen()</code>, its <code>CircularProgressIndicator()</code> is visible.</p>
			<p>However, if we look again at the usage of <code>CircularProgressIndicator()</code>, we can see that it exposes no semantics that we can use to identify it later in our test:</p>
			<pre>@Composable
fun RestaurantsScreen(â€¦) {
Â Â Â Â Box(â€¦) {
Â Â Â Â Â Â Â Â LazyColumn(â€¦) {â€¦}
Â Â Â Â Â Â Â Â if(state.isLoading)
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">CircularProgressIndicator()</strong>
Â Â Â Â Â Â Â Â [â€¦]
Â Â Â Â }
}</pre>
			<p>There is no <code>contentDescription</code> parameter and no visual text displayed. To be able to identify the node of <code>CircularProgressIndicator()</code> we must manually add a semantics <code>contentDescription</code> property.</p>
			<ol>
				<li value="9">For a moment, let's<a id="_idIndexMarker768"/> head out of the <code>androidTest</code> directory and go back inside the main package where our production code resides. Inside the <code>presentation</code> package, create a new <code>object</code> class named <code>Description</code> and define a constant description <code>String</code> variable for our loading composable:<pre>object Description {
Â Â Â Â const val RESTAURANTS_LOADING =
Â Â Â Â Â Â Â Â Â Â Â Â "Circular loading icon"
}</pre></li>
				<li>Inside the <code>RestaurantsScreen()</code> composable, pass a <code>semantics</code> modifier to the <code>CircularProgressIndicator()</code> composable and set its <code>contentDescription</code> property to the previously defined <code>RESTAURANTS_LOADING</code>:<pre>@Composable
fun RestaurantsScreen(â€¦) {
Â Â Â Â Box(â€¦) {
Â Â Â Â Â Â Â Â LazyColumn(â€¦) { â€¦ }
Â Â Â Â Â Â Â Â if (state.isLoading)
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">CircularProgressIndicator(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Modifier.semantics {</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â this.contentDescription =</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Description.RESTAURANTS_LOADING</strong>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">})</strong>
Â Â Â Â Â Â Â Â [â€¦]
Â Â Â Â }
}</pre></li>
			</ol>
			<p>Now, we will be able to identify the node represented by the <code>CircularProgressIndicator()</code> composable<a id="_idIndexMarker769"/> inside our UI tests by using the <code>contentDescription</code> semantics property.</p>
			<ol>
				<li value="11">Now, go back inside the <code>androidTest</code> directory and navigate to the <code>RestaurantsScreenTest</code> class, and in the <code>initialState_isRendered()</code> test method, use the <code>testRule</code> variable to identify the node with the <code>RESTAURANT_LOADING</code> content description with the help of the <code>onNodeWithContentDescription()</code> method, and finally, verify that the node is displayed with the <code>assertIsDisplayed()</code> method:<pre>@Test
fun initialState_isRendered() {
Â Â Â Â testRule.setContent {
Â Â Â Â Â Â Â Â RestaurantsAppTheme { RestaurantsScreen(â€¦) }
<code>initialState_isRendered()</code> method, every test method has two parts â€“ the setup of the expected behavior and then the assertions that verify that the resultant behavior is correct.</p></li>
				<li>Inside the <code>RestaurantsScreenTest</code> class and select <strong class="bold">Run RestaurantsScreenTest</strong>.</li>
			</ol>
			<p>This command will run all the<a id="_idIndexMarker770"/> tests inside this class (only one in our case) on an Android device (either your physical Android device or your emulator).</p>
			<p>If we switch to the <code>RestaurantsScreen()</code> was rendered correctly has passed:</p>
			<div><div><img src="img/B17788_10_02.jpg" alt="Figure 10.2 â€“ Observing the UI tests that have passed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 â€“ Observing the UI tests that have passed</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although we have defined a test where UI elements are identified via semantic properties, it's also possible to match a piece of UI by making it incorporate a <code>testTag</code> modifier that is later identified via the <code>hasTestTag()</code> matcher. However, you should avoid this practice, as you will be polluting your Compose UI production code with testing identifiers used only for tests.</p>
			<p>While your test ran on an Android device or emulator, you might have noticed that no UI was shown on its screen. This happens because the UI tests are really fast. If you want to see the UI that you're testing, you can add a <code>Thread.sleep()</code> call at the end of the test method; however, you should avoid such a practice in your production test code.</p>
			<p>Now, it's time to test whether the <code>RestaurantsScreen()</code> composable is rendering another state correctly â€“ the state with content. In this state, the restaurants have arrived, so <a id="_idIndexMarker771"/>we reset the loading status to <code>false</code> and render the restaurants.</p>
			<ol>
				<li value="13">Inside the <code>RestaurantsScreenTest</code> class, add another test function named <code>stateWithContent_isRendered()</code>, which should test whether the state with content is rendered correctly:<pre>@Test
fun stateWithContent_isRendered() {
Â Â Â Â testRule.setContent {
Â Â Â Â Â Â Â Â RestaurantsAppTheme {
Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â state = RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants =,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onFavoriteClick =Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â { _: Int, _: Boolean -&gt; },
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onItemClick = { }
Â Â Â Â Â Â Â Â Â Â Â Â )
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre></li>
			</ol>
			<p>Inside this test method, we have set the <code>RestaurantsScreen()</code> composable with a state whose <code>isLoading</code> field is <code>false</code> (as the restaurants have arrived) but haven't passed a list of restaurants yet. We need to create a dummy list of restaurants to mimic some restaurants from our data layer.</p>
			<ol>
				<li value="14">For a moment, let's head out of the <code>androidTest</code> directory and go back inside the main package<a id="_idIndexMarker772"/> where our production code resides. Inside the <code>restaurants</code> package, create a new <code>object</code> class named <code>DummyContent</code>, and inside this class, add a <code>getDomainRestaurants()</code> method that will return a dummy array list of <code>Restaurant</code> objects:<pre>object DummyContent {
Â Â Â Â fun getDomainRestaurants() = arrayListOf(
Â Â Â Â Â Â Â Â Restaurant(0, "title0", "description0", false),
Â Â Â Â Â Â Â Â Restaurant(1, "title1", "description1", false),
Â Â Â Â Â Â Â Â Restaurant(2, "title2", "description2", false),
Â Â Â Â Â Â Â Â Restaurant(3, "title3", "description3", false))
}</pre></li>
				<li>Now, go back inside the <code>androidTest</code> directory and navigate to the <code>RestaurantsScreenTest</code> class. Inside the <code>stateWithContent_isRendered()</code> method, declare a <code>restaurants</code> variable that will hold the dummy restaurants from the <code>DummyContent</code> class and pass it to the <code>restaurants</code> parameter of <code>RestaurantsScreenState</code>:<pre>@Test
fun stateWithContent_isRendered() {
Â Â Â Â <strong class="bold">val restaurants = DummyContent.getDomainRestaurants()</strong>
Â Â Â Â testRule.setContent {
Â Â Â Â Â Â Â Â RestaurantsAppTheme {
Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â state = RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">restaurants = restaurants,</strong>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false), [â€¦])
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre></li>
			</ol>
			<p>Now that we have finished the setup part of this test method, it's time to perform our assertions. Since <a id="_idIndexMarker773"/>we are testing that <code>RestaurantsScreen()</code> is correctly rendering the state that contains restaurants, let's have another quick look at the composable under test:</p>
			<pre>@Composable
fun RestaurantsScreen(<strong class="bold">state: RestaurantsScreenState</strong>, [â€¦]) {
Â Â Â Â Box(â€¦) {
Â Â Â Â Â Â Â Â LazyColumn(â€¦) {
Â Â Â Â Â Â Â Â Â Â Â Â items(<strong class="bold">state.restaurants</strong>) { restaurant -&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  RestaurantItem(â€¦)
Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if(<strong class="bold">state.isLoading</strong>)
Â Â Â Â Â Â Â Â Â Â Â Â CircularProgressIndicator()
Â Â Â Â Â Â Â Â if(state.error != null)
Â Â Â Â Â Â Â Â Â Â Â Â Text(state.error)
Â Â Â Â }
}</pre>
			<p>We can deduct that the two conditions we can assert are as follows:</p>
			<ul>
				<li>The restaurants from <code>RestaurantsScreenState</code> are displayed on the screen.</li>
				<li>The <code>CircularProgressIndicator()</code> composable is not rendered, so its node is not visible on the screen.</li>
			</ul>
			<p>Let's start off with the first <a id="_idIndexMarker774"/>assertion. Instead of relying on the <code>contentDescription</code> semantic property, we can use another semantic property that is more obvious â€“ the text displayed on the screen. Since <code>LazyColumn</code> will render a list of <code>RestaurantItem()</code> composables, each one will call a <code>Text</code> composable that will render the title and the description of the restaurant passed to its <code>text</code> parameter. With the help of our <code>ComposeContentTestRule</code>, we can identify a node with a certain text value by calling the <code>onNodeWithText()</code> method.</p>
			<ol>
				<li value="16">Back in the <code>stateWithContent_isRendered()</code> method, let's assert that <code>title</code> of the first <code>Restaurant</code> object from our dummy list is visible.</li>
			</ol>
			<p>Do that by passing the title of the first element from the <code>restaurants</code> variable to the <code>onNodeWithText()</code> method, thereby identifying its corresponding node. Finally, call the <code>assertIsDisplayed()</code> method to verify whether this node is displayed:</p>
			<pre>@Test
fun stateWithContent_isRendered() {
Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
Â Â Â Â testRule.setContent {
Â Â Â Â Â Â Â Â RestaurantsAppTheme {
Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â state = RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants = restaurants,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â [â€¦])
Â Â Â Â Â Â Â Â }
Â Â Â Â }
<strong class="bold">Â Â Â Â testRule.onNodeWithText(restaurants[0].title)</strong>
<strong class="bold">Â Â Â Â Â Â Â Â .assertIsDisplayed()</strong>
}</pre>
			<ol>
				<li value="17">Similarly, to assert <a id="_idIndexMarker775"/>whether the node of the title of the first restaurant from our dummy list is displayed, verify whether the node of the description of the first restaurant is displayed:<pre>@Test
fun stateWithContent_isRendered() {
Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
Â Â Â Â testRule.setContent { ... }
Â Â Â Â testRule.onNodeWithText(restaurants[0].title)
<strong class="bold">Â Â Â Â Â Â Â Â </strong>.assertIsDisplayed()
<strong class="bold">Â Â Â Â testRule.onNodeWithText(restaurants[0].description)</strong>
<strong class="bold">Â Â Â Â Â Â Â Â .assertIsDisplayed()</strong>
}</pre></li>
			</ol>
			<p>You might be wondering why we aren't asserting whether <code>title</code> or <code>description</code> of all the elements from the <code>DummyContent</code> class is visible. It's important to understand that our test is asserting whether some nodes are displayed on the screen.</p>
			<p>That's why, if our <code>restaurants</code> list contained 10 or 15 elements and we tested whether all titles and description nodes are visible, we could have had this test method pass on tall devices, since all the restaurants would fit and would be <em class="italic">composed</em> on the screen, but it could have failed if the test device was small and only some<a id="_idIndexMarker776"/> of the restaurants fitted on the screen and were composed.</p>
			<p>This would have made our test flaky. To prevent our test from being flaky, we only asserted whether the first restaurant is visible, therefore minimizing the chance of having the test run and fail on an incredibly small screen.</p>
			<p>Another interesting tactic that you can employ in order to test that content is correctly rendered would be to emulate a scroll action inside your test to the bottom of the list and check whether the last element is visible. This, however, is more complex, so we will proceed with the simpler version that we have implemented.</p>
			<ol>
				<li value="18">Lastly, let's assert that the node corresponding to the <code>CircularProgressIndicator()</code> composable does not exist, therefore ensuring that the app is not loading anything anymore. Do that by calling the <code>assertDoesNotExist()</code> method on the node with the <code>RESTAURANTS_LOADING</code> content description:<pre>@Test
fun stateWithContent_isRendered() {
Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
Â Â Â Â testRule.setContent { â€¦ }
Â Â Â Â testRule.onNodeWithText(restaurants[0].title)
Â Â Â Â Â Â Â Â .assertIsDisplayed()
Â Â Â Â testRule.onNodeWithText(restaurants[0].description)
Â Â Â Â Â Â Â Â .assertIsDisplayed()
<strong class="bold">Â Â Â Â testRule.onNodeWithContentDescription(</strong>
Â Â Â Â Â Â Â Â <strong class="bold">Description.RESTAURANTS_LOADING</strong>
<strong class="bold">Â Â Â Â ).assertDoesNotExist()</strong>
}</pre></li>
				<li>Now that we have<a id="_idIndexMarker777"/> finished writing our second test method asserting whether the <code>RestaurantsScreen()</code> composable is correctly rendering the state with content, inside the <code>RestaurantsScreenTest</code> class and select <strong class="bold">Run RestaurantsScreenTest</strong>.</li>
			</ol>
			<p>The tests should run and pass.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">Try writing a test method on your own that asserts whether the <code>RestaurantsScreen()</code> composable renders the error state correctly. As a hint, you should be passing an error text to the <code>error</code> parameter of the <code>RestaurantsScreen()</code>, and then you should be asserting whether a node with that particular text is visible, while also verifying that the node corresponding to the <code>CircularProgressIndicator()</code> composable does not exist.</p>
			<p>Finally, let's write a test method where we can verify whether upon clicking on a restaurant element from our dummy list, the correct callback is exposed by the parent <code>RestaurantsScreen()</code> composable:</p>
			<ol>
				<li value="20">Inside the <code>RestaurantsScreenTest</code> class, add another test function named <code>stateWithContent_ClickOnItem_isRegistered()</code>. Inside this method, store the dummy list inside a <code>restaurants</code> variable, and then store the first <a id="_idIndexMarker778"/>restaurant that we will click upon inside the <code>targetRestaurant</code> variable:<pre>@Test
fun stateWithContent_ClickOnItem_isRegistered() {
Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
Â Â Â Â val targetRestaurant = restaurants[0]
}</pre></li>
				<li>Then, set <code>RestaurantsScreen()</code> under test and feed it with a state with content by passing the contents of the <code>restaurants</code> variable to the <code>restaurants</code> parameter of <code>RestaurantsScreenState</code>:<pre>@Test
fun stateWithContent_ClickOnItem_isRegistered() {
Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
<strong class="bold">Â Â Â Â </strong>val targetRestaurant = restaurants[0]
<strong class="bold">Â Â Â Â testRule.setContent {</strong>
<strong class="bold">Â Â Â Â Â Â Â Â RestaurantsAppTheme {</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â state = RestaurantsScreenState(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants = restaurants,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false),</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onFavoriteClick = { _, _ -&gt; },</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onItemClick = { id -&gt;Â Â })</strong>
<strong class="bold">Â Â Â Â Â Â Â Â }</strong>
<strong class="bold">Â Â Â Â }</strong>
}</pre></li>
				<li>Then, identify the <a id="_idIndexMarker779"/>node that contains the <code>title</code> text of <code>targetRestaurant</code> and then simulate a user click on this node by calling the <code>performClick()</code> method:<pre>@Test
fun stateWithContent_ClickOnItem_isRegistered() {
Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
Â Â Â Â val targetRestaurant = restaurants[0]
Â Â Â Â testRule.setContent {
Â Â Â Â Â Â Â Â RestaurantsAppTheme {
Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â state = RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants = restaurants,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onFavoriteClick = { _, _ -&gt; },
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onItemClick = { id -&gt; })
Â Â Â Â Â Â Â Â }
Â Â Â Â }
<strong class="bold">Â Â Â Â testRule.onNodeWithText(targetRestaurant.title)</strong>
<strong class="bold">Â Â Â Â Â Â Â Â .performClick()</strong>
}</pre></li>
				<li>Now that we have simulated a user-click interaction, let's assert that the <code>id</code> value from the <code>onItemClick</code> callback<a id="_idIndexMarker780"/> exposed by the <code>RestaurantsScreen()</code> composable matches with the <code>id</code> value of the restaurant we have clicked on:<pre>@Test
fun stateWithContent_ClickOnItem_isRegistered() {
Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
Â Â Â Â val targetRestaurant = restaurants[0]
Â Â Â Â testRule.setContent {
Â Â Â Â Â Â Â Â RestaurantsAppTheme {
Â Â Â Â Â Â Â Â Â Â Â Â RestaurantsScreen(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â state = RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants = restaurants,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onFavoriteClick = { _, _ -&gt; },
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â onItemClick = { id -&gt;
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â assert(id == targetRestaurant.id)</strong>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â )
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â testRule.onNodeWithText(targetRestaurant.title)
Â Â Â Â Â Â Â Â .performClick()
}</pre></li>
				<li>Inside the <code>RestaurantsScreenTest</code> class and select <strong class="bold">Run RestaurantsScreenTest</strong>.</li>
			</ol>
			<p>The three tests <a id="_idIndexMarker781"/>should run and pass.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might have noticed that we haven't given any attention to testing how the UI updates when a user toggles a restaurant as a favorite or not a favorite. The only way we could have done that is by adding a dedicated semantic property to the heart icon of each restaurant from the list and then testing the value of that property. However, we would have tested a semantic property value and not the UI â€“ for such cases, it's better to look into <strong class="bold">screenshot testing</strong> strategies. Screenshot testing is a UI testing practice that generates screenshots of your app, which are then compared to the initially defined <em class="italic">correct</em> versions.</p>
			<p>Now that we briefly covered UI testing with Compose, it's time to unit-test our app's behind-the-scenes functionality!</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor311"/>Covering the basics of unit-testing your core logic</h1>
			<p>Apart from<a id="_idIndexMarker782"/> testing our UI layer, we must also test the core logic of our application. This means that we should try to verify as much behavior as possible in terms of presentation logic (testing <code>ViewModel</code> classes), business logic (testing <code>UseCase</code> classes), or even data logic (testing <code>Repository</code> classes).</p>
			<p>The easiest way of validating such logic is by writing unit tests for each class or group of classes whose behavior we're trying to verify.</p>
			<p>In this section, we will be writing unit tests for the <code>RestaurantsViewModel</code> class and the <code>ToggleRestaurantUseCase</code> class. Since these components don't interact directly with the UI, their unit tests will run<a id="_idIndexMarker783"/> directly on your local workstation's <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>), rather than running on an Android device, as our UI tests did.</p>
			<p>To summarize, in this<a id="_idIndexMarker784"/> section, we will be doing the following:</p>
			<ul>
				<li>Testing the functionality of a <code>ViewModel</code> class</li>
				<li>Testing the functionality of a <code>UseCase</code> class</li>
			</ul>
			<p>Let's begin by testing the <code>RestaurantsViewModel</code> class!</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor312"/>Testing the functionality of a ViewModel class</h2>
			<p>We want to test the <a id="_idIndexMarker785"/>functionality of our <code>RestaurantsViewModel</code> so that we can make sure that it's correctly performing the role of state producer for the <code>RestaurantsScreen()</code> composable.</p>
			<p>To achieve that, we will <a id="_idIndexMarker786"/>write unit tests for this <code>ViewModel</code> class in isolation. Let's begin:</p>
			<ol>
				<li value="1">First, locate the <code>test</code> package that is suited for regular unit tests: </li>
			</ol>
			<div><div><img src="img/B17788_10_03.jpg" alt="Figure 10.3 â€“ Observing the test package used for regular unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 â€“ Observing the test package used for regular unit tests</p>
			<p>Also, note that the pre-built <code>ExampleUnitTest</code> class resides inside this package.</p>
			<ol>
				<li value="2">Create an empty Kotlin class named <code>RestaurantsViewModelTest</code> inside the <code>test</code> package. Inside this <a id="_idIndexMarker787"/>class, we will define a method for each independent test. Behind the scenes, every method will become a standalone unit test that can pass or fail.</li>
			</ol>
			<p>Before starting to write <a id="_idIndexMarker788"/>our first test method, let's have another look at our <code>RestaurantsViewModel</code> class so that we can remind ourselves which cases we're looking to test:</p>
			<pre>class RestaurantsViewModel @Inject constructor(â€¦) : ViewModel() {
<strong class="bold">Â Â Â Â private val _state = mutableStateOf(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â RestaurantsScreenState(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â restaurants = listOf(),</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â isLoading = true</strong>
<strong class="bold">Â Â Â Â Â Â Â Â )</strong>
<strong class="bold">Â Â Â Â )</strong>
Â Â Â Â [â€¦]
Â Â Â Â private val errorHandler = CoroutineExceptionHandler
Â Â Â Â { â€¦ -&gt;
Â Â Â Â Â Â Â Â exception.printStackTrace()
Â Â Â Â Â Â Â Â <strong class="bold">_state.value = _state.value.copy(</strong>
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">error = exception.message, </strong>
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">isLoading = false)</strong>
Â Â Â Â }
Â Â Â Â init { getRestaurants() }
Â Â Â Â fun toggleFavorite(itemId: Int, oldValue: Boolean) {
Â Â Â Â Â Â Â Â [â€¦] 
Â Â Â Â }
Â Â Â Â private fun getRestaurants() {
Â Â Â Â Â Â Â Â viewModelScope.launch(errorHandler) {
Â Â Â Â Â Â Â Â Â Â Â Â val restaurants = getRestaurantsUseCase()
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â _state.value = _state.value.copy(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restaurants = restaurants,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false)</strong>
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre>
			<p>We can say that our <code>RestaurantsViewModel</code> should produce the exact three states that we<a id="_idIndexMarker789"/> fed to the <code>RestaurantsScreen()</code> composable in its own UI tests:</p>
			<ul>
				<li><code>ViewModel</code> class in the initialization of the <code>_state</code> variable, where the <code>restaurants</code> parameter of <code>RestaurantsScreenState</code> is set to <code>emptyList()</code> and the <code>isLoading</code> parameter is set to <code>true</code>.</li>
				<li><code>getRestaurants()</code> method, where we mutated the initial state and set the <code>isLoading</code> parameter to <code>false</code> while also passing the list of restaurants to the <code>restaurants</code> parameter.</li>
				<li><code>CoroutineExceptionHandler</code>, where the <code>isLoading</code> parameter is set to <code>false</code> to reset the loading status while also passing the message of <code>Exception</code> to the <code>error</code> parameter.</li>
			</ul>
			<p>In the end, what we basically have to do is assert that the value of the <code>state</code> variable (of type <code>RestaurantsScreenState</code>), which is exposed to the UI, evolves correctly over time, from the initial state to all possible states.</p>
			<p>Let's begin with a test method that asserts whether the initial state is produced as expected:</p>
			<ol>
				<li value="1">Inside the <code>RestaurantsViewModelTest</code> class, add an empty test function named <code>initialState_isProduced()</code> that will later test whether our <code>RestaurantsViewModel</code> class properly produces the initial state:<pre>Â Â Â Â @Test
Â Â Â Â fun initialState_isProduced() {Â Â }</pre></li>
			</ol>
			<p>As with the UI tests, we will make <a id="_idIndexMarker794"/>use of the JUnit testing library to define and run individual unit tests for each method annotated with the <code>@Test</code> annotation.</p>
			<p>Again similar to the UI tests, we<a id="_idIndexMarker795"/> named this method around the specific behavior it's trying to test, going from what we're testing (the initial state) to what should happen (the state being correctly produced).</p>
			<ol>
				<li value="2">Inside the <code>initialState_isProduced()</code> method, we must create an instance of the subject under test â€“ that is, <code>RestaurantsViewModel</code>. Define a <code>viewModel</code> variable and instantiate it with the value returned by the <code>getViewModel()</code> method, which we will define in a second:<pre>@Test
fun initialState_isProduced() {
<strong class="bold">Â Â Â Â val viewModel = getViewModel()</strong>
}</pre></li>
				<li>Still inside the <code>RestaurantsViewModelTest</code> class, define the <code>getViewModel()</code> method, which will return an instance of <code>RestaurantsViewModel</code>:<pre>private fun getViewModel(): RestaurantsViewModel {
Â Â Â Â return RestaurantsViewModel()
}</pre></li>
			</ol>
			<p>The problem now is that the <code>RestaurantsViewModel</code> constructor needs an instance of <code>GetInitialRestaurantsUseCase</code> and <code>ToggleRestaurantsUseCase</code>. In turn, these two classes also have other dependencies that we must instantiate. Let's have a <a id="_idIndexMarker796"/>clearer look at what classes we need to instantiate:</p>
			<div><div><img src="img/B17788_10_04.jpg" alt="Figure 10.4 â€“ Observing the direct and transitive dependencies of RestaurantsViewModel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 â€“ Observing the direct and transitive dependencies of RestaurantsViewModel</p>
			<p>We can see that both <code>GetInitialRestaurantsUseCase</code> and <code>ToggleRestaurantsUseCase</code> depend <a id="_idIndexMarker797"/>on <code>GetSortedRestaurantsUseCase</code> and <code>RestaurantsRepository</code>. The latter then depends on two library interfaces â€“ <code>RestaurantsApiService</code> and <code>RestaurantsDao</code>.</p>
			<p>Essentially, we must instantiate all these classes to test our <code>RestaurantsViewModel</code>.</p>
			<ol>
				<li value="4">Inside the <code>RestaurantsViewModelTest</code> class, refactor the <code>getViewModel()</code> method to <a id="_idIndexMarker798"/>construct all the necessary dependencies of <code>RestaurantsViewModel</code>:<pre>private fun getViewModel(): RestaurantsViewModel {
Â Â Â Â <strong class="bold">val restaurantsRepository = </strong>
<strong class="bold">Â Â Â Â Â Â Â Â RestaurantsRepository(?, ?)</strong>
<strong class="bold">Â Â Â Â val getSortedRestaurantsUseCase =</strong>
<strong class="bold">Â Â Â Â Â Â Â  GetSortedRestaurantsUseCase(restaurantsRepository)</strong>
<strong class="bold">Â Â Â Â val getInitialRestaurantsUseCase =</strong>
<strong class="bold">Â Â Â Â Â Â Â Â GetInitialRestaurantsUseCase(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â restaurantsRepository,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â getSortedRestaurantsUseCase)</strong>
<strong class="bold">Â Â Â Â val toggleRestaurantUseCase =</strong>
<strong class="bold">Â Â Â Â Â Â Â Â ToggleRestaurantUseCase(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â restaurantsRepository,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â getSortedRestaurantsUseCase</strong>
<strong class="bold">Â Â Â Â Â Â Â Â )</strong>
<strong class="bold">Â Â Â Â </strong>return RestaurantsViewModel(
<strong class="bold">Â Â Â Â Â Â Â Â getInitialRestaurantsUseCase,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â toggleRestaurantUseCase</strong>
<strong class="bold">Â Â Â Â )</strong>
}</pre></li>
			</ol>
			<p>If you read the previous snippet<a id="_idIndexMarker799"/> from bottom to top, you will notice that we were able to construct all the dependencies of the <code>RestaurantsViewModel</code>, and their dependencies, and so on until we hit <code>RestaurantsRepository</code>. This depends on two library interfaces, <code>RestaurantsApiService</code> and <code>RestaurantsDao</code>, whose implementations are provided by the Retrofit and Room libraries.</p>
			<p>In our production code, these two interfaces cross the boundary to the <em class="italic">real world</em> because<a id="_idIndexMarker800"/> their implementations, provided by the Retrofit and Room libraries, communicate with a real Firebase REST API and a real Room local database:</p>
			<div><div><img src="img/B17788_10_05.jpg" alt="Figure 10.5 â€“ Observing the real-world boundary crossed by the transitive &#13;&#10;dependencies of RestaurantsViewModel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 â€“ Observing the real-world boundary crossed by the transitive dependencies of RestaurantsViewModel</p>
			<p>If we were to use the existing implementations of these two interfaces provided by Retrofit and Room in our test code, the <code>RestaurantsViewModel</code> instance will communicate with the external world and our tests won't be isolated. Instead, our test code will be slow and not reliable because it will be dependent on our web REST API and a real local database.</p>
			<p>Yet how can we make our <code>RestaurantsViewModel</code> tests isolated, fast, and reliable? We can simply make sure that instead of having Retrofit and Room provide the implementations for <code>RestaurantsApiService</code> and <code>RestaurantsDao</code>, we define dummy implementations for these interfaces that won't communicate with the real world. </p>
			<p>These dummy implementations are often called fakes. <strong class="bold">Fakes</strong> are simplified implementations of the interfaces that<a id="_idIndexMarker801"/> we're looking to interact with in our tests. Such implementations mimic the behavior of the production implementations in a very simplified manner, often by returning dummy data. Fakes will only be used in our tests, so we can ensure that our testing environment is isolated.</p>
			<p>Apart from fakes, to <a id="_idIndexMarker802"/>mimic the functionality of components that cross the boundary to the real world, you can also use mocks. <strong class="bold">Mocks</strong> are objects that also simulate the behavior of a real object; however, you can configure their output on the fly without any additional classes. </p>
			<p>In this chapter, we will only focus on fakes, since most of the time, to create mocks, you need to use<a id="_idIndexMarker803"/> special mocking frameworks. Also, fakes tend to be more practical and can be reused across tests, whereas mocks tend to clutter your tests, as they bring a lot of boilerplate code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whenever you have a component that interacts with the <em class="italic">real world</em>, be it a web API, local database, or other production systems, you should define an interface for it. This way, in your production code, your other components interact with a real implementation of that interface, while your tests interact with a fake implementation of it.</p>
			<p>Let's see how we can implement fakes. In our case, <code>RestaurantsRepository</code> needs fake implementations of the <code>RestaurantsApiService</code> and <code>RestaurantsDao</code> interfaces. Let's begin with a fake implementation of the <code>RestaurantsApiService</code> interface:</p>
			<ol>
				<li value="1">To create a fake for the <code>RestaurantsApiService</code> interface, we must define a class that will implement the interface and simulate the functionality of a REST API. Inside the <code>test</code> package, create a Kotlin class named <code>FakeApiService</code> that implements the <code>RestaurantsApiService</code> interface and add the following code inside:<pre>class FakeApiService : RestaurantsApiService {
Â Â Â Â override suspend fun getRestaurants()
Â Â Â Â Â Â Â Â Â Â Â Â : List&lt;RemoteRestaurant&gt; {
Â Â Â Â Â Â Â Â delay(1000)
Â Â Â Â Â Â Â Â return DummyContent.getRemoteRestaurants()
Â Â Â Â }
Â Â Â Â override suspend fun getRestaurant(id: Int)
Â Â Â Â Â Â Â Â Â Â Â Â : Map&lt;String, RemoteRestaurant&gt; {
Â Â Â Â Â Â Â Â TODO("Not yet implemented")
Â Â Â Â }
}</pre></li>
			</ol>
			<p>Our <code>FakeApiService</code> overrides the required methods and returns some dummy restaurants from the <code>DummyContent</code> class. In the <code>getRestaurants()</code> method, we<a id="_idIndexMarker804"/> also call a coroutine-based <code>delay()</code> function of 1,000 milliseconds to better simulate an asynchronous response. Since <a id="_idIndexMarker805"/>we will not be using the <code>getRestaurant()</code> method in our tests right now, we haven't added any implementation inside it.</p>
			<p>Going back to the dummy content that is returned, note that the <code>getRestaurants()</code> method must return a list of <code>RemoteRestaurant</code> objects, so we called a non-existent <code>getRemoteRestaurants()</code> method on the <code>DummyContent</code> class. Let's define this method up next.</p>
			<ol>
				<li value="2">Head back inside the main source set where our production code resides. Inside the <code>DummyContent</code> class, add a new method called <code>getRemoteRestaurants()</code> that maps the list of <code>Restaurant</code> objects returned by the <code>getDomainRestaurants()</code> method to <code>RemoteRestaurant</code> objects:<pre>object DummyContent {
Â Â Â Â <strong class="bold">fun getDomainRestaurants() = arrayListOf(â€¦)</strong>
<strong class="bold">Â Â Â Â fun getRemoteRestaurants() = getDomainRestaurants()</strong>
<strong class="bold">Â Â Â Â Â Â Â Â .map {</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â RemoteRestaurant(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â it.id,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â it.title,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â it.description</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â )</strong>
<strong class="bold">Â Â Â Â Â Â Â Â }</strong>
}</pre></li>
				<li>Now, head back inside the <code>test</code> package. We've created a fake for the <code>RestaurantsApiService</code> interface, but we must also create one fake for the <code>RestaurantsDao</code> interface<a id="_idIndexMarker806"/> that will implement the interface and <a id="_idIndexMarker807"/>simulate the functionality of a local database. Inside the <code>test</code> package, create a Kotlin class named <code>FakeRoomDao</code> that implements the <code>RestaurantsDao</code> interface and add the following code inside:<pre>class FakeRoomDao : RestaurantsDao {
Â Â Â Â private var restaurants =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â HashMap&lt;Int, LocalRestaurant&gt;()
Â Â Â Â override suspend fun getAll()
Â Â Â Â Â Â Â Â Â Â Â Â : List&lt;LocalRestaurant&gt; {
Â Â Â Â Â Â Â Â delay(1000)
Â Â Â Â Â Â Â Â return restaurants.values.toList()
Â Â Â Â }
Â Â Â Â override suspend fun addAll(
Â Â Â Â Â Â Â Â restaurants: List&lt;LocalRestaurant&gt;
Â Â Â Â ) {
Â Â Â Â Â Â Â Â restaurants.forEach { 
Â Â Â Â Â Â Â Â Â Â Â Â this.restaurants[it.id] = it 
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â override suspend fun update(
Â Â Â Â Â Â Â Â partialRestaurant: PartialLocalRestaurant
Â Â Â Â ) {
Â Â Â Â Â Â Â Â delay(1000)
Â Â Â Â Â Â Â Â updateRestaurant(partialRestaurant)
Â Â Â Â }
Â Â Â Â override suspend fun updateAll(
Â Â Â Â Â Â Â Â partialRestaurants: List&lt;PartialLocalRestaurant&gt;
Â Â Â Â ) {
Â Â Â Â Â Â Â Â delay(1000)
Â Â Â Â Â Â Â Â partialRestaurants.forEach { 
Â Â Â Â Â Â Â Â Â Â Â Â updateRestaurant(it) 
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â override suspend fun getAllFavorited()
Â Â Â Â Â Â Â Â Â Â Â Â : List&lt;LocalRestaurant&gt; {
Â Â Â Â Â Â Â Â return restaurants.values.toList()
Â Â Â Â Â Â Â Â Â Â Â Â .filter { it.isFavorite }
Â Â Â Â }
}</pre></li>
			</ol>
			<p>Our <code>FakeRoomDao</code> class <a id="_idIndexMarker808"/>mimics the functionality of a real Room database, yet instead of storing restaurants in the local SQL database, it stores them in memory in the <code>restaurants</code> variable. We will not cover each method implementation of <code>FakeRoomDao</code>. </p>
			<p>However, we will conclude that each method simulates the interaction with a<a id="_idIndexMarker809"/> persistent storage service. Additionally, as our <code>FakeRoomDao</code> simulates interaction with a real local database, each of its actions will cause a delay triggered by the pre-built suspending <code>delay()</code> function.</p>
			<p>However, our <code>FakeRoom</code> class makes use of an <code>updateRestaurant()</code> method that we haven't defined so far. Let's do that now.</p>
			<ol>
				<li value="4">At the end of the body <a id="_idIndexMarker810"/>of the <code>FakeRoom</code> class, add the missing <code>updateRestaurant()</code> method that toggles the value of the <code>isFavorite</code> field:<pre>class FakeRoomDao : RestaurantsDao {
Â Â Â Â [...]
Â Â Â Â override suspend fun getAllFavorited()
Â Â Â Â Â Â Â Â Â Â Â Â : List&lt;LocalRestaurant&gt; { ... }
<strong class="bold">Â Â Â Â private fun updateRestaurant(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â partialRestaurant: PartialLocalRestaurant</strong>
<strong class="bold">Â Â Â Â ) {</strong>
<strong class="bold">Â Â Â Â Â Â  val restaurant = </strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â  this.restaurants[partialRestaurant.id]</strong>
<strong class="bold">Â Â Â Â Â Â  if (restaurant != null)</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â  this.restaurants[partialRestaurant.id] =</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â  restaurant.copy(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  isFavorite = </strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  partialRestaurant.isFavorite</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â Â Â  )</strong>
<strong class="bold">Â Â Â Â }</strong>
}</pre></li>
				<li>Now that we have finished implementing the fakes for our <code>RestaurantsApiService</code> and <code>RestaurantsDao</code> interfaces, it's time to pass them where we need them in our tests. Remember that the last missing piece was to provide fake<a id="_idIndexMarker811"/> implementations of the <code>RestaurantsRepository</code> dependencies so that our test is isolated.</li>
			</ol>
			<p>Head back inside the <code>RestaurantsViewModelTest</code> class and update the <code>getViewModel()</code> function to <a id="_idIndexMarker812"/>pass instances of the <code>FakeApiService</code> and <code>FakeRoomDao</code> classes to <code>RestaurantsRepository</code>:</p>
			<pre>private fun getViewModel(): RestaurantsViewModel {
Â Â Â Â val restaurantsRepository = RestaurantsRepository(
Â Â Â Â Â Â Â Â <strong class="bold">FakeApiService(), FakeRoomDao())</strong>
Â Â Â Â [â€¦]
Â Â Â Â return RestaurantsViewModel(â€¦)
}</pre>
			<p>Now that the <code>getViewModel()</code> method is able to return an instance of <code>RestaurantsViewModel</code> that we can <a id="_idIndexMarker813"/>easily test, let's get back to our <code>initialState_isProduced()</code> test method, which currently looks like this:</p>
			<pre>@Test
fun initialState_isProduced() {
Â Â Â Â val viewModel = getViewModel()
}</pre>
			<p>Remember that the scope of this test method is to verify that when our <code>RestaurantsViewModel</code> is initialized, it produces a correct initial state. Let's do that now.</p>
			<ol>
				<li value="6">First, inside the <code>initialState_isProduced()</code> test method, store the initial state inside an <code>initialState</code> variable:<pre>@Test
fun initialState_isProduced() {
Â Â Â Â val viewModel = getViewModel()
Â Â Â Â <strong class="bold">val initialState = viewModel.state.value</strong>
}</pre></li>
				<li>Next, by using the built-in <code>assert()</code> function, verify whether the content of <code>initialState</code> is as expected:<pre>@Test
fun initialState_isProduced() {
Â Â Â Â val viewModel = getViewModel()
Â Â Â Â val initialState = viewModel.state.value
<strong class="bold">Â Â Â Â assert(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â initialState == RestaurantsScreenState(</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â restaurants = emptyList(),</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â isLoading = true,</strong>
<strong class="bold">Â Â Â Â Â Â Â Â Â Â Â Â error = null)</strong>
<strong class="bold">Â Â Â Â )</strong>
}</pre></li>
			</ol>
			<p>In this test method, we're asserting whether<a id="_idIndexMarker814"/> the value of the <code>initialState</code> variable is a <code>RestaurantsScreenState</code> object with a <code>false</code> <code>isLoading</code> field and an <code>emptyList()</code> value inside the <code>restaurants</code> field. Additionally, we're testing that there is no value<a id="_idIndexMarker815"/> stored inside the <code>error</code> field.</p>
			<ol>
				<li value="8">Now that we have defined our first test method, it's time to run the test!</li>
			</ol>
			<p>Inside the <code>RestaurantsViewModelTest</code> class and select <strong class="bold">Run RestaurantsViewModelTest</strong>. This command will run all the tests inside this class (only one in our case) directly on your local JVM, rather than running on an Android device, as our UI tests did.</p>
			<p>If you switch to the <strong class="bold">Run</strong> tab, you will see that our test has failed:</p>
			<div><div><img src="img/B17788_10_06.jpg" alt="Figure 10.6 â€“ Observing how the test inside the RestaurantsViewModelTest class has failed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 â€“ Observing how the test inside the RestaurantsViewModelTest class has failed</p>
			<p>This exception is thrown because our Restaurants app handles asynchronous work with the help of coroutines, and our test code doesn't know how to interact with them.</p>
			<p>For instance, our <code>RestaurantsViewModel</code> launches coroutines that call several suspend functions, and <a id="_idIndexMarker816"/>all of these <a id="_idIndexMarker817"/>happen on <code>viewModelScope</code>, which h<a id="_idIndexMarker818"/>as the <code>Dispatchers.Main</code> dispatcher set by default:</p>
			<pre>@HiltViewModel
class RestaurantsViewModel @Inject constructor(...) : [â€¦] {
Â Â Â Â [...]
Â Â Â Â fun toggleFavorite(itemId: Int, oldValue: Boolean) {
Â Â Â Â Â Â Â Â <strong class="bold">viewModelScope.launch</strong>(errorHandler) { ... }
Â Â Â Â }
Â Â Â Â private fun getRestaurants() {
Â Â Â Â Â Â Â Â <strong class="bold">viewModelScope.launch</strong>(errorHandler) { ... }
Â Â Â Â }
}</pre>
			<p>The main issue here is that our coroutines are launched on the Main thread on our local JVM, which can't work with the UI thread.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>Dispatchers.Main</code> dispatcher uses the Android <code>Looper.getMainLooper()</code> function to run code in the UI thread. That method is available in UI tests but not in the regular unit tests that run on our JVM.</p>
			<p>To make our testing <a id="_idIndexMarker819"/>code compliant with the usage of coroutines, we need to use the Kotlin coroutines testing library, which will provide us with scopes and dispatchers that are dedicated to testing coroutines. If our test code is run from coroutines that are built with these dedicated scopes and <a id="_idIndexMarker820"/>dispatchers, our test will no longer fail.</p>
			<p>Let's add the Kotlin coroutines testing library!</p>
			<ol>
				<li value="1">In the app-level <code>build.gradle</code> file, add a <code>testImplementation</code> dependency to the Kotlin coroutines testing package: <pre>dependencies {
Â Â Â Â [â€¦]
Â Â Â Â testImplementation "com.google.truth:truth:1.1.2"
Â Â Â Â <strong class="bold">testImplementation 'org.jetbrains.kotlinx:kotlinx-</strong>
<strong class="bold">Â Â Â Â Â Â Â Â coroutines-test:1.6.1'</strong>
}</pre></li>
				<li>Synchronize your project with its Gradle files by clicking on the <strong class="bold">Sync your project with Gradle files</strong> button in Android Studio or by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Head back inside the <code>RestaurantsViewModelTest</code> class and define a variable for a <code>StandardTestDispatcher</code> object and a variable for a <code>TestScope</code> object based on the previously defined dispatcher:<pre><strong class="bold">@ExperimentalCoroutinesApi</strong>
class RestaurantsViewModelTest {
<strong class="bold">Â Â Â Â private val dispatcher = StandardTestDispatcher()</strong>
<strong class="bold">Â Â Â Â private val scope = TestScope(dispatcher)</strong>
Â Â Â Â @Test
Â Â Â Â fun initialState_isProduced() {â€¦}
Â Â Â Â private fun getViewModel(): RestaurantsViewModel {â€¦}
}</pre></li>
			</ol>
			<p>Additionally, we've added the <code>@ExperimentalCoroutinesApi</code> annotation to the <code>RestaurantsViewModelTest</code> class, since these testing APIs are still experimental.</p>
			<ol>
				<li value="4">Next up, make sure that all the code from within the body of the <code>initialState_isProduced()</code> test method is run inside a test-specific coroutine. To do that, launch a<a id="_idIndexMarker821"/> coroutine that wraps this method's body by calling the <code>runTest()</code> coroutine builder on our <code>scope</code> variable of type <code>TestScope</code>:<pre>@Test
fun initialState_isProduced()<strong class="bold"> = scope.runTest {</strong>
Â Â Â Â val viewModel = getViewModel()
<strong class="bold">Â Â Â Â </strong>val initialState = viewModel.state.value
Â Â Â Â assert(
Â Â Â Â Â Â Â Â initialState == RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â restaurants = emptyList(),
Â Â Â Â Â Â Â Â Â Â Â Â isLoading = true,
Â Â Â Â Â Â Â Â Â Â Â Â error = null))
<strong class="bold">}</strong></pre></li>
				<li>Run the <code>RestaurantsViewModelTest</code> class. If you switch to the <strong class="bold">Run</strong> tab, you will see that our test has failed again, with the same exception as before. Since we wrapped the body<a id="_idIndexMarker822"/> of our test method inside a test coroutine, our test code still throws an exception, telling us that we still need to<a id="_idIndexMarker823"/> change the dispatcher of the coroutine.</li>
			</ol>
			<p>If we have another look at <code>RestaurantsViewModel</code>, we can note that both the coroutines launched with <code>viewModelScope</code> have no dispatcher set, so they're using <code>Dispatchers.Main</code> behind the scenes:</p>
			<pre>@HiltViewModel
class RestaurantsViewModel @Inject constructor(...) : [â€¦] {
Â Â Â Â [...]
Â Â Â Â fun toggleFavorite(itemId: Int, oldValue: Boolean) {
Â Â Â Â Â Â Â Â viewModelScope.launch(errorHandler) { ... }
Â Â Â Â }
Â Â Â Â private fun getRestaurants() {
Â Â Â Â Â Â Â Â viewModelScope.launch(errorHandler) { ... }
Â Â Â Â }
}</pre>
			<p>However, in our test, all coroutines that are launched should use <code>StandardTestDispatcher</code> defined in our test class. So, how can we pass a test dispatcher to the coroutines launched in our <code>RestaurantsViewModel</code>?</p>
			<p>We can inject the dispatcher inside the <code>RestaurantsViewModel</code> class by using its constructor and making it accept a <code>CoroutineDispatcher</code> object, which will be passed to all the coroutines that are launched.</p>
			<p>This way, in our<a id="_idIndexMarker824"/> production code, <code>RestaurantsViewModel</code> will receive and use the <code>Dispatchers.Main</code> dispatcher, and inside our test code, it will receive and use the <code>StandardTestDispatcher</code> dispatcher.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The practice of injecting dispatchers into our coroutine-based classes is encouraged, as it allows us to have better isolation and control over the testing environment of our unit tests.</p>
			<ol>
				<li value="6">Head back inside the main source set where our production code resides. Inside <code>RestaurantsViewModel</code>, add a <code>dispatcher</code> constructor parameter of type <code>CoroutineDispatcher</code> and pass it to the <code>viewModelScope()</code> calls:<pre>@HiltViewModel
class RestaurantsViewModel @Inject constructor(
Â Â  private val getRestaurantsUseCase: [â€¦],
Â Â  private val toggleRestaurantsUseCase: [â€¦],
Â Â  <strong class="bold">private val dispatcher: CoroutineDispatcher</strong>) :Â Â 
<strong class="bold">Â Â Â Â Â Â  </strong>ViewModel(){
Â Â Â Â [...]
Â Â Â Â fun toggleFavorite(itemId: Int, oldValue: Boolean) {
Â Â Â Â Â Â Â Â viewModelScope.launch(errorHandler 
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">+ dispatcher</strong>) { â€¦ }
Â Â Â Â }
Â Â Â Â private fun getRestaurants() {
Â Â Â Â Â Â Â Â viewModelScope.launch(errorHandler 
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">+ dispatcher</strong>) { â€¦ }
Â Â Â Â }
}</pre></li>
			</ol>
			<p>However, if we build the project now, we will get an error because Hilt doesn't know how to provide an instance of <code>CoroutineDispatcher</code> to <code>RestaurantsViewModel</code>.</p>
			<p>To instruct Hilt on how to provide our <code>ViewModel</code> with the dispatcher it needs (that is, <code>Dispatchers.Main</code>), we must create a Hilt module.</p>
			<ol>
				<li value="7">Inside the <code>di</code> package, create a new class called <code>DispatcherModule</code> and add the following <a id="_idIndexMarker825"/>code that tells Hilt how to provide any <code>CoroutineDispatcher</code> dependencies with <code>Dispatchers.Main</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {
Â Â Â Â @Provides
Â Â Â Â fun providesMainDispatcher(): CoroutineDispatcher 
Â Â Â Â Â Â Â Â = Dispatchers.Main
}</pre></li>
			</ol>
			<p>However, right now, Hilt will always provide <code>Dispatchers.Main</code> to any <code>CoroutineDispatcher</code> dependencies. What if we need later to obtain a dispatcher different<a id="_idIndexMarker826"/> than <code>Dispatchers.Main</code>? Let's see how we can prepare for that.</p>
			<ol>
				<li value="8">At the top of the body of <code>DispatcherModule</code>, define an annotation class called <code>MainDispatcher</code> annotated with the <code>@Qualifier</code> annotation:<pre><strong class="bold">@Qualifier</strong>
<strong class="bold">@Retention(AnnotationRetention.BINARY)</strong>
<strong class="bold">annotation class MainDispatcher</strong>
 
@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {â€¦}</pre></li>
			</ol>
			<p>The <code>@Qualifier</code> annotation<a id="_idIndexMarker827"/> allows us to provide different dispatchers to the <code>CoroutineDispatcher</code> dependencies. In our case, we defined that a <code>@MainDispatcher</code> annotation will provide the <code>Dispatchers.Main</code> dispatcher.</p>
			<ol>
				<li value="9">Add the <code>@MainDispatcher</code> annotation to the <code>providesMainDispatcher()</code> method so that Hilt will know what dispatcher to provide when such an annotation is used on a dependency:<pre>@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class MainDispatcher
@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {
<strong class="bold">Â Â Â Â @MainDispatcher</strong>
Â Â Â Â @Provides
Â Â Â Â fun providesMainDispatcher(): CoroutineDispatcher
Â Â Â Â Â Â Â Â = Dispatchers.Main
}</pre></li>
				<li>Then, inside <code>RestaurantsViewModel</code>, annotate the <code>dispatcher</code> parameter with the newly<a id="_idIndexMarker828"/> created <code>@MainDispatcher</code> annotation so that Hilt will provide us with the <code>Dispatchers.Main</code> dispatcher:<pre>@HiltViewModel
class RestaurantsViewModel @Inject constructor(
Â Â  private val getRestaurantsUseCase: [â€¦],
Â Â  private val toggleRestaurantsUseCase: [â€¦],
Â Â  <strong class="bold">@MainDispatcher</strong> private val dispatcher: 
<strong class="bold">Â Â Â Â Â Â  </strong>CoroutineDispatcher
) : ViewModel() { ... }</pre></li>
				<li>Now that the <code>RestaurantsViewModel</code> uses the <code>Dispatcher.Main</code> dispatcher in our<a id="_idIndexMarker829"/> production code, head back inside the <code>test</code> source set and inside the <code>RestaurantsViewModelTest</code> class, update its <code>getViewModel()</code> method by passing the <code>dispatcher</code> member field to the <code>RestaurantsViewModel</code> constructor call:<pre>@ExperimentalCoroutinesApi
class RestaurantsViewModelTest {
Â Â Â Â private val dispatcher = StandardTestDispatcher()
Â Â Â Â private val scope = TestScope(dispatcher)
Â Â Â Â @Test
Â Â Â Â fun initialState_isProduced() = scope.runTest {â€¦}
Â Â Â Â private fun getViewModel(): RestaurantsViewModel {
Â Â Â Â Â Â Â Â [â€¦]
Â Â Â Â Â Â Â Â return RestaurantsViewModel(
Â Â Â Â Â Â Â Â Â Â Â Â getInitialRestaurantsUseCase,
Â Â Â Â Â Â Â Â Â Â Â Â toggleRestaurantUseCase,
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">dispatcher</strong>)
Â Â Â Â }
}</pre></li>
			</ol>
			<p>Now, in our test code, <code>RestaurantsViewModel</code> will use the <code>StandardTestDispatcher</code> dispatcher <a id="_idIndexMarker830"/>for all the launched coroutines.</p>
			<ol>
				<li value="12">Now, run the <code>RestaurantsViewModelTest</code> class again. If you switch to the <strong class="bold">Run</strong> tab, you will see that<a id="_idIndexMarker831"/> our test has now passed:</li>
			</ol>
			<div><div><img src="img/B17788_10_07.jpg" alt="Figure 10.7 â€“ Observing how the test inside the RestaurantsViewModelTest class has succeeded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 â€“ Observing how the test inside the RestaurantsViewModelTest class has succeeded</p>
			<p>Since our test uses the <code>runTest()</code> coroutine builder, any <code>delay()</code> calls in our fake implementations are skipped, making our test run fast, in just a few hundred milliseconds.</p>
			<p>Now that we have tested<a id="_idIndexMarker832"/> whether our <code>ViewModel</code> produces a correct initial state, it's time to test the state that comes after this initial state â€“ the state with content. This state is produced when the restaurants have arrived (from our data layer), so the <code>isLoading</code> field should be reset to <code>false</code>, while the <code>restaurants</code> field should contain a list of restaurants.</p>
			<ol>
				<li value="13">Add a new testing method inside <code>RestaurantsViewModelTest</code> called <code>stateWithContent_isProduced()</code> that asserts whether the state with restaurants is produced as expected:<pre>@Test
fun stateWithContent_isProduced() = scope.runTest {
Â Â Â Â val testVM = getViewModel()
Â Â Â Â val currentState = testVM.state.value
Â Â Â Â assert(
Â Â Â Â Â Â Â Â currentState == RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â restaurants = 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  DummyContent.getDomainRestaurants(),
Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false,
Â Â Â Â Â Â Â Â Â Â Â Â error = null)
Â Â Â Â )
}</pre></li>
			</ol>
			<p>Since the <code>FakeApiService</code> returns<a id="_idIndexMarker833"/> the dummy list of <code>RemoteRestaurant</code> from the <code>DummyContent</code> class, it's only natural that we're expecting to get the same content in <code>ViewModel</code> but in the shape of the <code>Restaurant</code> objects â€“ so we're asserting that the <code>restaurants</code> field of <code>currentState</code> contains the restaurants from <code>DummyContent</code>.</p>
			<p>Unfortunately, if we run the <code>RestaurantsViewModelTest</code> class, the <code>stateWithContent_isProduced()</code> test will fail, telling us that <code>currentState</code> has the <code>isLoading</code> field's value of <code>true</code> and there are no restaurants inside the <code>restaurants</code> field.</p>
			<p>This issue makes sense <a id="_idIndexMarker834"/>because we're basically obtaining the initial state and expecting it to be the state with content, which, in fact, comes later on. Because there are several <code>delay()</code> calls in our <code>FakeApiService</code> and <code>FakeRoomDao</code> implementations, we must allow time to pass so that <code>ViewModel</code> produces the second state â€“ the one with restaurants. But how can we do that?</p>
			<p>Inside a test, to immediately execute all pending tasks (such as the launched coroutine to get restaurants in our <code>ViewModel</code>) and to advance the virtual clock until after the last delay, we can call the <code>advanceUntilIdle()</code> function exposed<a id="_idIndexMarker835"/> by the coroutines test library.</p>
			<ol>
				<li value="14">Inside the <code>stateWithContent_isProduced()</code> test method, after <code>RestaurantsViewModel</code> is instantiated but before our assertion, add the <code>advanceUntilIdle()</code> method call:<pre>@Test
fun stateWithContent_isProduced() = scope.runTest {
Â Â Â Â val testVM = getViewModel()
<strong class="bold">Â Â Â Â advanceUntilIdle()</strong>
Â Â Â Â val currentState = testVM.state.value
Â Â Â Â assert(
Â Â Â Â Â Â Â Â currentState == RestaurantsScreenState(
Â Â Â Â Â Â Â Â Â Â Â Â restaurants = 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â DummyContent.getDomainRestaurants(),
Â Â Â Â Â Â Â Â Â Â Â Â isLoading = false,
Â Â Â Â Â Â Â Â Â Â Â Â error = null)
Â Â Â Â )
}</pre></li>
			</ol>
			<p>When we call <code>advanceUntilIdle()</code> inside our <code>scope</code> variable of type <code>TestScope</code>, we're advancing the virtual clock of <code>TestCoroutineScheduler</code> featured in the <code>StandardTestDispatcher</code> that we've initially passed to our <code>scope</code>.</p>
			<ol>
				<li value="15">Now, run the <code>RestaurantsViewModelTest</code> class again. If you switch to the <code>stateWithContent_isProduced()</code> test still failed.</li>
			</ol>
			<p>The main issue here is that while we're trying to advance the virtual clock of our test by leveraging the fact that our test instance of <code>RestaurantsViewModel</code> now launches its <a id="_idIndexMarker836"/>coroutines on the <code>StandardTestDispatcher</code> instance that we've passed to it, we have another class that is passing its own <code>CoroutineDispatcher</code>.</p>
			<p>If we have a closer look inside our <code>RestaurantsRepository</code>, we can see that it's passing a <a id="_idIndexMarker837"/>production-use <code>Dispatchers.IO</code> dispatcher to all its <code>withContext()</code> calls:</p>
			<pre>@Singleton
class RestaurantsRepository @Inject constructor(â€¦) {
Â Â Â Â suspend fun toggleFavoriteRestaurant(â€¦) =
Â Â Â Â Â Â Â Â withContext(<strong class="bold">Dispatchers.IO</strong>) {â€¦}
Â Â Â Â suspend fun getRestaurants() : List&lt;Restaurant&gt; {
Â Â Â Â Â Â Â Â return withContext(<strong class="bold">Dispatchers.IO</strong>) {â€¦}
Â Â Â Â }
Â Â Â Â suspend fun loadRestaurants() {
Â Â Â Â Â Â Â Â return withContext(<strong class="bold">Dispatchers.IO</strong>) {â€¦}
Â Â Â Â }
Â Â Â Â private suspend fun refreshCache() {â€¦}
}</pre>
			<p>Because the <code>RestaurantsRepository</code> instance that our <code>RestaurantsViewModel</code> indirectly depends on uses the <code>Dispatchers.IO</code> dispatcher and not the <code>StandardTestDispatcher</code> one, the virtual clock of our test is not advanced as <a id="_idIndexMarker838"/>expected. Let's fix this issue by injecting the dispatcher in the <code>RestaurantsRepository</code>, just as we did for <code>RestaurantsViewModel</code>.</p>
			<ol>
				<li value="16">However, before performing<a id="_idIndexMarker839"/> the injection, we must first define a new type of <code>CoroutineDispatcher</code> that Hilt should know how to inject â€“ the <code>Dispatchers.IO</code> dispatcher.</li>
			</ol>
			<p>Head inside the <code>DispatchersModule</code> class and, just as we did for the <code>Dispatchers.Main</code> dispatcher, instruct Hilt on how to provide us with the <code>Dispatchers.IO</code> dispatcher:</p>
			<pre>@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class MainDispatcher
<strong class="bold">@Qualifier</strong>
<strong class="bold">@Retention(AnnotationRetention.BINARY)</strong>
<strong class="bold">annotation class IoDispatcherÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </strong>Â Â  
@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {
Â Â Â Â @MainDispatcher
Â Â Â Â @Provides
Â Â Â Â fun providesMainDispatcher(): CoroutineDispatcher =Â Â Â Â Â Â Â Â 
<strong class="bold">Â Â Â Â Â Â Â Â </strong>Dispatchers.Main
<strong class="bold">Â Â Â Â @IoDispatcher</strong>
<strong class="bold">Â Â Â Â @Provides</strong>
<strong class="bold">Â Â Â Â fun providesIoDispatcher(): CoroutineDispatcher = </strong>
<strong class="bold">Â Â Â Â Â Â Â Â Dispatchers.IO</strong>
}</pre>
			<ol>
				<li value="17">Head back inside the main <a id="_idIndexMarker840"/>source set where our production code resides. Inside the <code>RestaurantsRepository</code> class, inject <code>CoroutineDispatcher</code>, annotate it with the <code>@IoDispatcher</code> qualifier, and then <a id="_idIndexMarker841"/>pass the injected <code>dispatcher</code> to all the <code>withContext()</code> calls:<pre>@Singleton
class RestaurantsRepository @Inject constructor(
Â Â Â Â private val restInterface: RestaurantsApiService,
Â Â Â Â private val restaurantsDao: RestaurantsDao,
<strong class="bold">Â Â Â Â @IoDispatcher private val dispatcher: </strong>
<strong class="bold">Â Â Â Â Â Â Â Â CoroutineDispatcher</strong>
) {
Â Â Â Â suspend fun toggleFavoriteRestaurant(â€¦) =Â Â 
Â Â Â Â Â Â Â Â withContext(<strong class="bold">dispatcher</strong>) {â€¦}
Â Â Â Â suspend fun getRestaurants() : List&lt;Restaurant&gt; {
Â Â Â Â Â Â Â Â return withContext(<strong class="bold">dispatcher</strong>) {â€¦}
Â Â Â Â }
Â Â Â Â suspend fun loadRestaurants() {
Â Â Â Â Â Â Â Â return withContext(<strong class="bold">dispatcher</strong>) {â€¦}
Â Â Â Â }
Â Â Â Â private suspend fun refreshCache() {â€¦}Â Â Â Â Â Â Â Â Â Â Â Â }</pre></li>
				<li>Then, heading back<a id="_idIndexMarker842"/> inside our <code>test</code> package, inside the <code>RestaurantsViewModelTest</code> class, update the <code>getViewModel()</code> method<a id="_idIndexMarker843"/> to pass our <code>dispatcher</code> field of type <code>StandardTestDispatcher</code> to the <code>RestaurantsRepository</code> constructor:<pre>private fun getViewModel(): RestaurantsViewModel {
Â Â Â Â val restaurantsRepository = RestaurantsRepository(
Â Â Â Â Â Â Â Â FakeApiService(), 
Â Â Â Â Â Â Â Â FakeRoomDao(),
Â Â Â Â Â Â Â Â <strong class="bold">dispatcher</strong>)
Â Â Â Â [â€¦]
Â Â Â Â return RestaurantsViewModel(
Â Â Â Â Â Â Â Â getInitialRestaurantsUseCase,
Â Â Â Â Â Â Â Â toggleRestaurantUseCase,
Â Â Â Â Â Â Â Â dispatcher)
}</pre></li>
				<li>Now, run the <code>RestaurantsViewModelTest</code> class again. If you switch to the <code>RestaurantsViewModel</code> is correctly producing an error state. As a tip, make sure to throw an instance of the <code>Exception</code> class inside <code>FakeApiService</code> but just for this specific test method where you're verifying the error state. To achieve that, you can configure a constructor parameter in <code>FakeApiService</code> so that it can throw an exception if needed.</p></li>
			</ol>
			<p>Now that we<a id="_idIndexMarker844"/> tested how <code>RestaurantsViewModel</code> is producing the UI state, let's briefly<a id="_idIndexMarker845"/> have a look at how we could test a business component.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor313"/>Testing the functionality of a UseCase class</h2>
			<p>Aside from unit-testing the <a id="_idIndexMarker846"/>presentation layer <a id="_idIndexMarker847"/>of our application, it's very important to also test the business rules present in the app. In our Restaurants app, the business logic is encapsulated in <code>UseCase</code> classes.</p>
			<p>Let's see say that we want to test <code>ToggleRestaurantUseCase</code>. Essentially, we want to make sure that when we execute this <code>UseCase</code> class for a specific restaurant, the business logic of negating the <code>isFavorite</code> field of the <code>Restaurant</code> is working.</p>
			<p>In other words, if one restaurant was not marked as favorite, after executing <code>ToggleRestaurantUseCase</code> for that specific restaurant, its <code>isFavorite</code> field should become <code>true</code>. While this business logic is indeed slim, in medium to large-sized applications, such business logic can become much more complex.</p>
			<p>Let's see how a unit test for <code>ToggleRestaurantUseCase</code> would look:</p>
			<pre>@ExperimentalCoroutinesApi
class ToggleRestaurantUseCaseTest {
Â Â Â Â private val dispatcher = StandardTestDispatcher()
Â Â Â Â private val scope = TestScope(dispatcher)
Â Â Â Â @Test
Â Â Â Â fun toggleRestaurant_IsUpdatingFavoriteField() = 
Â Â Â Â Â Â Â Â Â Â Â Â scope.runTest {
Â Â Â Â Â Â Â Â // Setup useCase
Â Â Â Â Â Â Â Â val restaurantsRepository = RestaurantsRepository(
Â Â Â Â Â Â Â Â Â Â Â Â FakeApiService(),
Â Â Â Â Â Â Â Â Â Â Â Â FakeRoomDao(),
Â Â Â Â Â Â Â Â Â Â Â Â dispatcher)
Â Â Â Â Â Â Â Â val getSortedRestaurantsUseCase = 
Â Â Â Â Â Â Â Â Â Â Â Â GetSortedRestaurantsUseCase(restaurantsRepository)
Â Â Â Â Â Â Â Â val useCase = ToggleRestaurantUseCase(
Â Â Â Â Â Â Â Â Â Â Â Â restaurantsRepository,
Â Â Â Â Â Â Â Â Â Â Â Â getSortedRestaurantsUseCase)
Â Â Â Â Â Â Â Â // Preload data
Â Â Â Â Â Â Â Â restaurantsRepository.loadRestaurants()
Â Â Â Â Â Â Â Â advanceUntilIdle()
Â Â Â Â Â Â Â Â // Execute useCase
Â Â Â Â Â Â Â Â val restaurants = DummyContent.getDomainRestaurants()
Â Â Â Â Â Â Â Â val targetItem = restaurants[0]
Â Â Â Â Â Â Â Â val isFavorite = targetItem.isFavorite
Â Â Â Â Â Â Â Â val updatedRestaurants = useCase(
Â Â Â Â Â Â Â Â Â Â Â Â targetItem.id, 
Â Â Â Â Â Â Â Â Â Â Â Â isFavorite
Â Â Â Â Â Â Â Â )
Â Â Â Â Â Â Â Â advanceUntilIdle()
Â Â Â Â Â Â Â Â // Assertion
Â Â Â Â Â Â Â Â restaurants[0] = targetItem.copy(isFavorite = 
Â Â Â Â Â Â Â Â Â Â Â Â !isFavorite)
Â Â Â Â Â Â Â Â assert(updatedRestaurants == restaurants)
Â Â Â Â }
}</pre>
			<p>This unit test is<a id="_idIndexMarker848"/> similar to the ones we wrote for <code>RestaurantsViewModel</code> in the sense that it's also using <code>StandardTestDispatcher</code> and <code>TestScope</code>, simply because the <code>invoke()</code> operator of <code>ToggleRestaurantUseCase</code> is a <code>suspending</code> function.</p>
			<p>The structure of the test is split into three parts, delimited by the suggestive comments:</p>
			<ul>
				<li><code>ToggleRestaurantUseCase</code> instance and its<a id="_idIndexMarker850"/> direct and transitive dependencies, while passing our test dispatcher to the dependencies that need it.</li>
				<li><code>ToggleRestaurantUseCase</code> to be able to execute its business logic on a specific <a id="_idIndexMarker851"/>restaurant, we first had to make sure that our <code>RestaurantsRepository</code> instance had loaded the dummy restaurants. We then called <code>advancedUntilIdle()</code>, allowing any suspending (blocking) work related to obtaining and caching dummy restaurants to finish.</li>
				<li><code>isFavorite</code> field we want to toggle as <code>targetItem</code>, obtained its current <code>isFavorite</code> field value, and executed <code>ToggleRestaurantUseCase</code>, storing the resultant restaurants inside the <code>updatedRestaurants</code> variable. Since this operation refreshes and re-obtains the restaurants from the fake local database, we then called <code>advancedUntilIdle()</code>, allowing any suspending work to finish.</li>
				<li><code>isFavorite</code> field. Finally, we asserted that the resultant <code>updatedRestaurants</code> list is the same as the one we would expect to be correct â€“ that is, <code>restaurants</code>. </li>
			</ul>
			<p>If you run this test, it should pass.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">Try testing the behaviour of other Use Case classes such as <code>GetSortedRestaurantsUseCase</code> or even classes from the data layer such as <code>RestaurantsRepository</code>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor314"/>Summary</h1>
			<p>In this chapter, we first had a look at the benefits of testing and classified tests based on different aspects. Afterward, we took a shot at testing our Compose-based UI and learned how to write UI unit tests by leveraging the power of the semantics modifiers.</p>
			<p>Finally, we learned how to write regular â€“ non-UI â€“ unit tests in order to validate the core functionality of our application. In this part, we learned how to test our coroutine-based code and how important it is to inject the <code>CoroutineDispatcher</code> objects.</p>
			<p>In the next chapter, we're steering away from the architectural side of Android development, and we will be incorporating data pagination with the help of yet another interesting library called Jetpack Paging.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor315"/>Further reading</h1>
			<p>In this chapter, we've briefly covered the basics of UI and unit testing, so the core concepts taught here should give you a solid starting point. However, there are several other topics that you might need while you continue your testing adventure:</p>
			<ul>
				<li>For UI tests, we used semantics modifiers to identify UI elements from our node hierarchy. When testing Compose UI, you should also be aware of the merged and unmerged semantics tree. Learn more about this topic by reading the official docs: <a href="https://developer.android.com/jetpack/compose/semantics">https://developer.android.com/jetpack/compose/semantics</a>.</li>
				<li>With UI tests, we only scratched the surface in terms of testing APIs. Make sure to check out this official testing cheat sheet: <a href="https://developer.android.com/jetpack/compose/testing-cheatsheet">https://developer.android.com/jetpack/compose/testing-cheatsheet</a>.</li>
				<li>Our unit tests are based on the JUnit testing framework. To discover the power and flexibility of Junit, check out its official docs: <a href="https://junit.org/junit4/">https://junit.org/junit4/</a>.</li>
				<li>In your coroutine-based tests, apart from the <code>advanceUntilIdle()</code> API, you can also use the <code>advancetimeBy()</code> API to fast-forward the virtual clock of the test by a certain amount. Learn more about this function from the official Coroutines docs: <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html">https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html</a>.</li>
				<li>Your unit tests must be deterministic in the sense that every run of one test for the same revision of code should always yield the same result. Learn more about deterministic and non-deterministic tests from Martin Fowler: <a href="https://martinfowler.com/articles/nonDeterminism.html">https://martinfowler.com/articles/nonDeterminism.html</a>.</li>
			</ul>
		</div>
	</body></html>