<html><head></head><body>
		<div id="_idContainer107">
			<h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor305"/>Chapter 10</em>: Test Your App with UI and Unit Tests</h1>
			<p>In the previous chapters, one of our main focuses was to have a testable architecture. We tried to achieve that by decoupling different components from each other.</p>
			<p>In this chapter, because of the architecture we put in place, we will see how easy it is to test in isolation different parts of the Restaurants app.</p>
			<p>In the <em class="italic">Exploring the fundamentals of testing</em> section, we will be understanding the benefits of testing and exploring various types of tests. In the <em class="italic">Learning the basics of testing your Compose UI</em> section, we will learn how to test our Compose UI. </p>
			<p>Finally, in the <em class="italic">Covering the basics of unit-testing your core logic</em> section, we will learn how to test the core functionality of your Restaurants app.</p>
			<p>To summarize, in this chapter we will be covering the following sections:</p>
			<ul>
				<li>Exploring the fundamentals of testing</li>
				<li>Learning the basics of testing your Compose UI</li>
				<li>Covering the basics of unit-testing your core logic</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor306"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you also have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>The Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_09</strong> directory of the repository and import the Android project entitled <strong class="source-inline">chapter_9_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_10</strong> directory:<span class="hidden"> </span><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_10/chapter_10_restaurants_app</a></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor307"/>Exploring the fundamentals of testing</h1>
			<p>In this section, we will briefly cover the <a id="_idIndexMarker733"/>basics of testing. More precisely, we will be doing the following:</p>
			<ul>
				<li>Understanding the benefits of testing</li>
				<li>Exploring the types of tests</li>
			</ul>
			<p>Let's start with the benefits of testing!</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor308"/>Understanding the benefits of testing</h2>
			<p>Testing our <a id="_idIndexMarker734"/>code is essential. Through tests, we ensure that our app's functional behavior is correct and as expected, while also making sure that it's usable, just as it was designed. By performing tests, we can release stable and functional apps to end users.</p>
			<p>More importantly, if we develop an app and then test it consistently, we ensure that new updates with new functionality won't break the existing functionality, and no bugs will arise. This is often<a id="_idIndexMarker735"/> referred to as <strong class="bold">regression testing</strong>.</p>
			<p>You can test your app manually by navigating through it on your device or emulator and making sure that every piece of data is displayed correctly, while also being able to interact correctly with every UI component.</p>
			<p>However, manual testing is neither efficient nor fast. With manual testing, you must traverse every user flow, generate every user interaction, and verify the integrity of data displayed at any moment. Also, you must do this, consistently, on every application update. Moreover, manual testing scales poorly, as with every new update that contains a new functionality, the manual workload of testing the entire application increases.</p>
			<p>Over time, manual testing becomes a burden for medium- and large-sized applications. Also, manual testing involves a human tester, which generates a human factor – this basically means that a tester may or may not in some circumstances overlook some bugs.</p>
			<p>To alleviate these issues, in this chapter, we will be writing automated tests. Practically, we will define some scripted tests and then allow tools to run them, automatically. This approach is faster, consistent, and more efficient, as it scales better with the size of the project.</p>
			<p>In other words, we will <a id="_idIndexMarker736"/>write other chunks of code that will test the code of our application. While this might sound weird, the approach of having automated tests is much more productive and reliable, and less time-consuming than manual testing.</p>
			<p>Next up, let's cover the different types of tests that we can write.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor309"/>Exploring types of tests</h2>
			<p>To better understand how<a id="_idIndexMarker737"/> to write tests, we must first decide <em class="italic">what exactly can be tested</em> in our apps. From this perspective, let's cover the most important types of tests:</p>
			<ul>
				<li><strong class="bold">Functional tests</strong>: Is the app <a id="_idIndexMarker738"/>doing what is expected? We already touched<a id="_idIndexMarker739"/> upon functional tests and their benefits in the <em class="italic">Understanding the benefits of testing</em> section.</li>
				<li><strong class="bold">Compatibility tests</strong>: Is the <a id="_idIndexMarker740"/>app working correctly on all devices and <a id="_idIndexMarker741"/>Android API levels? The Android ecosystem makes this particularly difficult if you consider the variety of devices and manufacturers.</li>
				<li><strong class="bold">Performance tests</strong>: Is the app fast or <a id="_idIndexMarker742"/>efficient enough? Sometimes, apps<a id="_idIndexMarker743"/> can suffer from bottlenecks and UI stutters that can be identified via performance benchmarks.</li>
				<li><strong class="bold">Accessibility tests</strong>: Is the app working <a id="_idIndexMarker744"/>well with accessibility<a id="_idIndexMarker745"/> services? Such services are used to assist users with disabilities in using our Android application.</li>
			</ul>
			<p>In this chapter, we will be mainly focusing on functional tests in an attempt to ensure the functional integrity of our application.</p>
			<p>Now, apart from deciding what has to be tested, we must also think about the <em class="italic">scope or size of the tests</em>. The scope<a id="_idIndexMarker746"/> indicates the size of the app's portion we're testing. From the perspective of the <a id="_idIndexMarker747"/>scope of the tests, we have the following:</p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: Often referred to as <a id="_idIndexMarker748"/>small tests, these test the functional behavior of methods, classes, or groups of classes in an isolated environment. Usually, unit tests target small portions of the app without interacting with the real-world environment; hence, they are more reliable than tests that depend on external input.</li>
				<li><strong class="bold">Integration tests</strong>: Often referred to<a id="_idIndexMarker749"/> as medium tests, these test whether multiple units interact and function correctly together.</li>
				<li><strong class="bold">End-to-end tests</strong>: Often <a id="_idIndexMarker750"/>referred to as big tests, these test large portions of the application, from multiple screens to entire user flows.</li>
			</ul>
			<p>Depending on the size of the tests, each type has a degree of isolation. The <strong class="bold">degree of isolation</strong> is tightly related to the <a id="_idIndexMarker751"/>scope of the tests, as it measures how <a id="_idIndexMarker752"/>dependent the component we're testing is on other components. As the size of the test increases, from small to big, the isolation level of the tests decreases.</p>
			<p>In this chapter, we will be mainly focusing on unit tests, as they are fast, with the simplest setup, and most reliable in helping us validate the functionality of our application. These traits are tightly related to the higher isolation level of unit tests from external components.</p>
			<p>Lastly, we must also classify tests based on the system they will be running on:</p>
			<ul>
				<li><strong class="bold">Local tests</strong>: Run on your <a id="_idIndexMarker753"/>workstation or development system (used in<a id="_idIndexMarker754"/> practices such as <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>)) without the need of an Android device or emulator. They are usually small and fast, isolating the component under test from the rest of the application. Most of the time, unit tests are local tests.</li>
				<li><strong class="bold">Instrumented tests</strong>: Run on an Android device, be it a physical device or emulator. Most of the time, UI tests are<a id="_idIndexMarker755"/> considered instrumented tests, since they allow the automated testing of an application on an Android device.</li>
			</ul>
			<p>In this chapter, our unit tests will be local when we will be testing the core logic of some components in isolation <a id="_idIndexMarker756"/>and instrumented when we will be performing UI unit tests for a specific screen in isolation.</p>
			<p>Let's proceed with local UI tests first!</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor310"/>Learning the basics of testing your Compose UI</h1>
			<p>UI tests allow us to evaluate <a id="_idIndexMarker757"/>the behavior of our Compose code against what is expected to be correct. This way, we can catch bugs early in our UI development process.</p>
			<p>To test our UI, we must first decide what we are aiming to evaluate. To keep it simple, in this section, we will unit-test our UI in an isolated environment. In other words, we want to test the following:</p>
			<ul>
				<li>That our composable screens consume the received state as expected. We want to make sure that the UI correctly represents the different state values that it can receive.</li>
				<li>For our composable screens, that user-generated events are correctly forwarded to the caller of the composable.</li>
			</ul>
			<p>To keep our tests simple, we will define these tests as unit tests and try to isolate screen composables from their <strong class="source-inline">ViewModel</strong> or from other screen composables; otherwise, our test will become an integration or an end-to-end test. </p>
			<p>In other words, we will test separately each screen, with total disregard of anything outside of their composable function definition. Even though our tests will run on an Android device, they will be testing only one unit – a screen composable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some UI tests can also be considered unit tests, as long as they are testing only one part of the UI of your application, as we will do in this section.</p>
			<p>For starters, we<a id="_idIndexMarker758"/> need to test the first screen of our application, represented by the <strong class="source-inline">RestaurantsScreen()</strong> composable. Let's begin!</p>
			<ol>
				<li>First, add the following testing dependencies inside the <strong class="source-inline">dependencies</strong> block of the app-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">dependencies {</p><p class="source-code">    […]</p><p class="source-code"><strong class="bold">    androidTestImplementation "androidx.compose.ui:ui-</strong></p><p class="source-code"><strong class="bold">        test-junit4:$compose_version"</strong></p><p class="source-code"><strong class="bold">    debugImplementation "androidx.compose.ui:ui-test-</strong></p><p class="source-code"><strong class="bold">        manifest:$compose_version"</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>These dependencies will allow us to run our Compose UI tests on an Android device.</p>
			<p>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Before creating a test class, locate the <strong class="source-inline">androidTest</strong> package that is suited for instrumented tests:</li>
			</ol>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B17788_10_01.jpg" alt="Figure 10.1 – Observing the androidTest package for UI tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Observing the androidTest package for UI tests</p>
			<p>In Android projects, this<a id="_idIndexMarker759"/> directory stores source files for UI tests. Also note that the pre-built <strong class="source-inline">ExampleInstrumentedTest</strong> class resides in this directory.</p>
			<ol>
				<li value="3">Create an empty Kotlin class named <strong class="source-inline">RestaurantsScreenTest</strong> inside the <strong class="source-inline">androidTest</strong> package.</li>
			</ol>
			<p>Inside this class, we will define a method for each independent test. Behind the scenes, every method will become a standalone UI test that can pass or fail.</p>
			<ol>
				<li value="4">Before creating our first test method, inside the <strong class="source-inline">RestaurantsScreenTest</strong> class, add the following code:<p class="source-code"><strong class="bold">import androidx.compose.ui.test.junit4.*</strong></p><p class="source-code"><strong class="bold">import org.junit.Rule</strong></p><p class="source-code">class RestaurantsScreenTest {</p><p class="source-code"><strong class="bold">    @get:Rule</strong></p><p class="source-code"><strong class="bold">    val testRule: ComposeContentTestRule = </strong></p><p class="source-code"><strong class="bold">        createComposeRule()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>To run our Compose UI tests, we are using the JUnit testing framework that will allow us to write repeatable unit tests <a id="_idIndexMarker760"/>in an isolated environment with the help of a test rule. <strong class="bold">Test rules</strong> allow us to add functionality to all the tests within a test class.</p>
			<p>In our case, we need to test Compose UI in every test method, so we had to use a special <strong class="source-inline">ComposeContentTestRule</strong> object. To access this rule, we have previously imported a special JUnit rule dependency so that our test class now defines a <strong class="source-inline">testRule</strong> variable and instantiates it by using the <strong class="source-inline">createComposeRule()</strong> method.</p>
			<p><strong class="source-inline">ComposeContentTestRule</strong> will not only allow us to set the Compose UI under test but also host tests on an Android device, while also giving us the ability to interact with the composables under test or perform UI assertions.</p>
			<p>Before writing our first test method though, we need to clearly understand what behavior we are trying to test.</p>
			<p>Let's have a look at how our <strong class="source-inline">RestaurantsScreen()</strong> composable consumes a <strong class="source-inline">RestaurantsScreenState</strong> instance from its <strong class="source-inline">state</strong> parameter, and how it forwards events to its caller through the <strong class="source-inline">onItemClick</strong> and <strong class="source-inline">onFavoriteClick</strong> function parameters:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(</p>
			<p class="source-code">    <strong class="bold">state: RestaurantsScreenState</strong>,</p>
			<p class="source-code">    <strong class="bold">onItemClick: (id: Int) -&gt; Unit</strong>,</p>
			<p class="source-code">    <strong class="bold">onFavoriteClick: (id: Int, oldValue: Boolean) -&gt; Unit</strong></p>
			<p class="source-code">) {</p>
			<p class="source-code">    Box(…) {</p>
			<p class="source-code">        LazyColumn(…) {</p>
			<p class="source-code">            items(<strong class="bold">state.restaurants</strong>) { restaurant -&gt;</p>
			<p class="source-code">                RestaurantItem(restaurant,</p>
			<p class="source-code">                   onFavoriteClick = { id, oldValue -&gt;</p>
			<p class="source-code">                        <strong class="bold">onFavoriteClick</strong>(id, oldValue) },</p>
			<p class="source-code">                   onItemClick = { id -&gt; </p>
			<p class="source-code">                        <strong class="bold">onItemClick </strong>(id) })</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if(<strong class="bold">state.isLoading</strong>)</p>
			<p class="source-code">            CircularProgressIndicator()</p>
			<p class="source-code">        if(<strong class="bold">state.error != null</strong>)</p>
			<p class="source-code">            Text(state.error)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>By looking at the previous snippet, we <a id="_idIndexMarker761"/>see that we can test how the <strong class="source-inline">onItemClick</strong> and <strong class="source-inline">onFavoriteClick</strong> functions are called, based on different UI interactions, and also that we can test whether the state is consumed correctly or not. Yet we can't infer very well the possible values of the state that our composable is receiving.</p>
			<p>To get an overview of the possible states that we want to feed into our <strong class="source-inline">RestaurantsScreen()</strong> so that we can test its behavior, we need to have a look at its state producer, <strong class="source-inline">RestaurantsViewModel</strong>:</p>
			<p class="source-code">class RestaurantsViewModel @Inject constructor(…) : ViewModel() {</p>
			<p class="source-code"><strong class="bold">    private val _state = mutableStateOf(</strong></p>
			<p class="source-code"><strong class="bold">        RestaurantsScreenState(</strong></p>
			<p class="source-code"><strong class="bold">            restaurants = listOf(),</strong></p>
			<p class="source-code"><strong class="bold">            isLoading = true</strong></p>
			<p class="source-code"><strong class="bold">        )</strong></p>
			<p class="source-code"><strong class="bold">    )</strong></p>
			<p class="source-code">    […]</p>
			<p class="source-code">    private val errorHandler = CoroutineExceptionHandler</p>
			<p class="source-code">    { ... -&gt;</p>
			<p class="source-code">        exception.printStackTrace()</p>
			<p class="source-code"><strong class="bold">        _state.value = _state.value.copy(</strong></p>
			<p class="source-code"><strong class="bold">            error = exception.message,</strong></p>
			<p class="source-code"><strong class="bold">            isLoading = false)</strong></p>
			<p class="source-code"><strong class="bold">    </strong>}</p>
			<p class="source-code">    init { getRestaurants() }</p>
			<p class="source-code">    fun toggleFavorite(itemId: Int, oldValue: Boolean) {</p>
			<p class="source-code">        […]</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private fun getRestaurants() {</p>
			<p class="source-code">        viewModelScope.launch(errorHandler) {</p>
			<p class="source-code">            val restaurants = getRestaurantsUseCase()</p>
			<p class="source-code"><strong class="bold">            _state.value = _state.value.copy(</strong></p>
			<p class="source-code"><strong class="bold">                restaurants = restaurants,</strong></p>
			<p class="source-code"><strong class="bold">                isLoading = false)</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We can say that our screen should have three<a id="_idIndexMarker762"/> possible states:</p>
			<ul>
				<li><strong class="bold">Initial loading state</strong>: At this point, we're waiting for restaurants, thus rendering a loading status. You can see this initial state declared at the top of the <strong class="source-inline">ViewModel</strong> class in the initialization of the <strong class="source-inline">_state</strong> variable, where the <strong class="source-inline">restaurants</strong> parameter of <strong class="source-inline">RestaurantsScreenState</strong> is set to <strong class="source-inline">emptyList()</strong> and the <strong class="source-inline">isLoading</strong> parameter is set to <strong class="source-inline">true</strong>.</li>
				<li><strong class="bold">State with content</strong>: The restaurants have arrived, so we reset the loading status and render them. You can see how this state is created inside the coroutine launched in the <strong class="source-inline">getRestaurants()</strong> method where we mutated the initial state and set the <strong class="source-inline">isLoading</strong> parameter to <strong class="source-inline">false</strong>, while also passing the list of restaurants to the <strong class="source-inline">restaurants</strong> parameter.</li>
				<li><strong class="bold">Error state</strong>: Something went wrong when the app tried to fetch its content – that is, restaurants. You can see how this state is created inside the block of code exposed by <strong class="source-inline">CoroutineExceptionHandler</strong> where the <strong class="source-inline">isLoading</strong> parameter is set to <strong class="source-inline">false</strong> to reset the loading status, while also passing the message of <strong class="source-inline">Exception</strong> to the <strong class="source-inline">error</strong> parameter.</li>
			</ul>
			<p>Now that we know what behavior the <strong class="source-inline">RestaurantsScreen</strong> composable should exhibit and <a id="_idIndexMarker763"/>what input we should pass to it in order to produce such a behavior, it's time to actually put our composable screen under test.</p>
			<p>Let's begin by verifying whether the <strong class="source-inline">RestaurantsScreen</strong> composable correctly renders the first state – that is, the initial loading state.</p>
			<ol>
				<li value="5">Inside the <strong class="source-inline">RestaurantsScreenTest</strong> class, add an empty test function named <strong class="source-inline">initialState_isRendered()</strong> that will later test whether our <strong class="source-inline">RestaurantsScreen()</strong> composable properly renders the initial state:<p class="source-code">class RestaurantsScreenTest {</p><p class="source-code">    @get:Rule</p><p class="source-code">    val testRule: ComposeContentTestRule = </p><p class="source-code">        createComposeRule()</p><p class="source-code">    </p><p class="source-code"><strong class="bold">    @Test</strong></p><p class="source-code"><strong class="bold">    fun initialState_isRendered() {  }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>To tell the JUnit testing library to run an individual test for this method, we've annotated it with the <strong class="source-inline">@Test</strong> annotation.</p>
			<p>Also, note that we named this <a id="_idIndexMarker764"/>method around the specific behavior it's trying to test, going from what we're testing (the initial state) to how it's supposed to behave (to be rendered correctly), while separating these two with an underscore. For unit tests, there are a lot of naming conventions, yet we will try to stick to the simple version mentioned before.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Each test method annotated with <strong class="source-inline">@Test</strong> should focus on only one specific behavior, just as <strong class="source-inline">initialState_isRendered()</strong> will test whether the <strong class="source-inline">RestaurantsScreen()</strong> properly renders the initial state, and no other pieces. This allows us to focus on only one behavior on each test method so that we can better identify later which specific behavior is no longer working as expected.</p>
			<ol>
				<li value="6">Prepare the <strong class="source-inline">initialState_isRendered()</strong> method to set the Compose UI by calling <strong class="source-inline">testRule.setContent()</strong>, just as our <strong class="source-inline">MainActivity</strong> did with its own <strong class="source-inline">setContent()</strong> method:<p class="source-code">    @Test</p><p class="source-code">    fun initialState_isRendered() {</p><p class="source-code">        <strong class="bold">testRule.setContent { }</strong></p><p class="source-code">    }</p></li>
				<li>Inside the block of code exposed by the <strong class="source-inline">setContent()</strong> method, we must pass the <strong class="bold">unit under test</strong>, which is nothing else than the composable we're trying to test.</li>
			</ol>
			<p>In our case, we will pass the <strong class="source-inline">RestaurantsScreen()</strong> composable, not before wrapping it inside the <strong class="source-inline">RestaurantsAppTheme()</strong> theme function so that the Compose UI that is under test mimics what our app is actually displaying in the production code:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">fun initialState_isRendered() {</p>
			<p class="source-code"><strong class="bold">    testRule.setContent {</strong></p>
			<p class="source-code"><strong class="bold">        RestaurantsAppTheme {</strong></p>
			<p class="source-code"><strong class="bold">            RestaurantsScreen()</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>If you have named your app name differently, then<a id="_idIndexMarker765"/> the theme composable might have a different definition.</p>
			<ol>
				<li value="8">Now, the <strong class="source-inline">RestaurantsScreen()</strong> composable is expecting a <strong class="source-inline">RestaurantsScreenState</strong> object into its <strong class="source-inline">state</strong> parameter and two functions for its <strong class="source-inline">onFavoriteClick()</strong> and <strong class="source-inline">onItemClick()</strong> parameters. Let's add these while also passing the expected initial state from the screen's <strong class="source-inline">ViewModel</strong>:<p class="source-code">    @Test</p><p class="source-code">    fun initialState_isRendered() {</p><p class="source-code">        testRule.setContent {</p><p class="source-code">            <strong class="bold">RestaurantsAppTheme {</strong></p><p class="source-code"><strong class="bold">                RestaurantsScreen(</strong></p><p class="source-code"><strong class="bold">                    state = RestaurantsScreenState(</strong></p><p class="source-code"><strong class="bold">                        restaurants = emptyList(),</strong></p><p class="source-code"><strong class="bold">                        isLoading = true),</strong></p><p class="source-code"><strong class="bold">                    onFavoriteClick = </strong></p><p class="source-code"><strong class="bold">                        {  _: Int, _: Boolean -&gt;  },</strong></p><p class="source-code"><strong class="bold">                    onItemClick = { })</strong></p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
			</ol>
			<p>Since we're looking to test <a id="_idIndexMarker766"/>whether <strong class="source-inline">RestaurantsScreen()</strong> is correctly rendering the initial state, we have passed an instance of <strong class="source-inline">RestaurantsScreenState</strong> that had the <strong class="source-inline">restaurants</strong> parameter set to <strong class="source-inline">emptyList()</strong>, and the <strong class="source-inline">isLoading</strong> parameter is set to <strong class="source-inline">true</strong> while the <strong class="source-inline">error</strong> parameter is by default set to <strong class="source-inline">null</strong>.</p>
			<p>We have now finished setting up the <strong class="source-inline">RestaurantsScreen()</strong> composable and fed it with the expected initial state. It's time to perform the assertion of whether our composable is correctly consuming this initial state or not.</p>
			<p>In the <strong class="source-inline">RestaurantsScreen()</strong> composable, the initial state is a state mainly defined by the loading indicator that expresses how the app is waiting for content:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(…) {</p>
			<p class="source-code">    Box(…) {</p>
			<p class="source-code">        LazyColumn(…) {…}</p>
			<p class="source-code">        if(<strong class="bold">state.isLoading</strong>)</p>
			<p class="source-code">            <strong class="bold">CircularProgressIndicator()</strong></p>
			<p class="source-code">        if(state.error != null)</p>
			<p class="source-code">            Text(state.error)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>That's why we can check whether the <strong class="source-inline">CircularProgressIndicator()</strong> is visible on the screen. But how can we assert whether this composable is visible or not?</p>
			<p>Compose provides us with<a id="_idIndexMarker767"/> several testing APIs to help us find elements, verify their attributes, and even perform user actions. For UI tests with Compose, we consider pieces of UI as <strong class="bold">nodes</strong> that we can identify with the help of semantics. <strong class="bold">Semantics</strong> give meaning to a UI element, and for an entire composable hierarchy, a semantics tree is generated to describe it.</p>
			<p>In other words, we should be able to identify anything that is described on the screen with the help of its exposed semantics.</p>
			<p>To give an example, a <strong class="source-inline">Text</strong> composable that displays a <strong class="source-inline">String</strong> object such as <strong class="source-inline">"Hello"</strong> will become a node in the semantics tree that we can identify by its <strong class="source-inline">text</strong> property value – <strong class="source-inline">"Hello"</strong>. Similarly, composables such as <strong class="source-inline">Image</strong> expose a mandatory <strong class="source-inline">contentDescription</strong> parameter whose value will allow us to identify the corresponding node in the semantics tree inside our tests. Don't worry – we'll see a practical example of this in a second.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While the semantics attributes are mainly used for accessibility purposes (<strong class="source-inline">contentDescription</strong>, for example, is a parameter that allows people with disabilities to better understand what the visual element it describes is about), it's also a great tool that exposes semantics used to identify nodes in our tests.</p>
			<p>Now that we have briefly covered how we can use semantics information to identify UI elements as nodes, it's time to get back to our test, which should validate if, upon an initial state consumed by <strong class="source-inline">RestaurantsScreen()</strong>, its <strong class="source-inline">CircularProgressIndicator()</strong> is visible.</p>
			<p>However, if we look again at the usage of <strong class="source-inline">CircularProgressIndicator()</strong>, we can see that it exposes no semantics that we can use to identify it later in our test:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(…) {</p>
			<p class="source-code">    Box(…) {</p>
			<p class="source-code">        LazyColumn(…) {…}</p>
			<p class="source-code">        if(state.isLoading)</p>
			<p class="source-code">            <strong class="bold">CircularProgressIndicator()</strong></p>
			<p class="source-code">        […]</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>There is no <strong class="source-inline">contentDescription</strong> parameter and no visual text displayed. To be able to identify the node of <strong class="source-inline">CircularProgressIndicator()</strong> we must manually add a semantics <strong class="source-inline">contentDescription</strong> property.</p>
			<ol>
				<li value="9">For a moment, let's<a id="_idIndexMarker768"/> head out of the <strong class="source-inline">androidTest</strong> directory and go back inside the main package where our production code resides. Inside the <strong class="source-inline">presentation</strong> package, create a new <strong class="source-inline">object</strong> class named <strong class="source-inline">Description</strong> and define a constant description <strong class="source-inline">String</strong> variable for our loading composable:<p class="source-code">object Description {</p><p class="source-code">    const val RESTAURANTS_LOADING =</p><p class="source-code">            "Circular loading icon"</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">RestaurantsScreen()</strong> composable, pass a <strong class="source-inline">semantics</strong> modifier to the <strong class="source-inline">CircularProgressIndicator()</strong> composable and set its <strong class="source-inline">contentDescription</strong> property to the previously defined <strong class="source-inline">RESTAURANTS_LOADING</strong>:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(…) {</p><p class="source-code">    Box(…) {</p><p class="source-code">        LazyColumn(…) { … }</p><p class="source-code">        if (state.isLoading)</p><p class="source-code">            <strong class="bold">CircularProgressIndicator(</strong></p><p class="source-code"><strong class="bold">                Modifier.semantics {</strong></p><p class="source-code"><strong class="bold">                    this.contentDescription =</strong></p><p class="source-code"><strong class="bold">                       Description.RESTAURANTS_LOADING</strong></p><p class="source-code">                <strong class="bold">})</strong></p><p class="source-code">        […]</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, we will be able to identify the node represented by the <strong class="source-inline">CircularProgressIndicator()</strong> composable<a id="_idIndexMarker769"/> inside our UI tests by using the <strong class="source-inline">contentDescription</strong> semantics property.</p>
			<ol>
				<li value="11">Now, go back inside the <strong class="source-inline">androidTest</strong> directory and navigate to the <strong class="source-inline">RestaurantsScreenTest</strong> class, and in the <strong class="source-inline">initialState_isRendered()</strong> test method, use the <strong class="source-inline">testRule</strong> variable to identify the node with the <strong class="source-inline">RESTAURANT_LOADING</strong> content description with the help of the <strong class="source-inline">onNodeWithContentDescription()</strong> method, and finally, verify that the node is displayed with the <strong class="source-inline">assertIsDisplayed()</strong> method:<p class="source-code">@Test</p><p class="source-code">fun initialState_isRendered() {</p><p class="source-code">    testRule.setContent {</p><p class="source-code">        RestaurantsAppTheme { RestaurantsScreen(…) }</p><p class="source-code"><strong class="bold">    </strong>}</p><p class="source-code"><strong class="bold">    testRule.onNodeWithContentDescription(</strong></p><p class="source-code"><strong class="bold">        Description.RESTAURANTS_LOADING</strong></p><p class="source-code"><strong class="bold">    ).assertIsDisplayed()</strong></p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">As you can see with the <strong class="source-inline">initialState_isRendered()</strong> method, every test method has two parts – the setup of the expected behavior and then the assertions that verify that the resultant behavior is correct.</p></li>
				<li>Inside the <strong class="bold">Project</strong> tab on the left, right-click on the <strong class="source-inline">RestaurantsScreenTest</strong> class and select <strong class="bold">Run RestaurantsScreenTest</strong>.</li>
			</ol>
			<p>This command will run all the<a id="_idIndexMarker770"/> tests inside this class (only one in our case) on an Android device (either your physical Android device or your emulator).</p>
			<p>If we switch to the <strong class="bold">Run</strong> tab, we will see that our test where we checked whether the initial state of <strong class="source-inline">RestaurantsScreen()</strong> was rendered correctly has passed:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B17788_10_02.jpg" alt="Figure 10.2 – Observing the UI tests that have passed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Observing the UI tests that have passed</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although we have defined a test where UI elements are identified via semantic properties, it's also possible to match a piece of UI by making it incorporate a <strong class="source-inline">testTag</strong> modifier that is later identified via the <strong class="source-inline">hasTestTag()</strong> matcher. However, you should avoid this practice, as you will be polluting your Compose UI production code with testing identifiers used only for tests.</p>
			<p>While your test ran on an Android device or emulator, you might have noticed that no UI was shown on its screen. This happens because the UI tests are really fast. If you want to see the UI that you're testing, you can add a <strong class="source-inline">Thread.sleep()</strong> call at the end of the test method; however, you should avoid such a practice in your production test code.</p>
			<p>Now, it's time to test whether the <strong class="source-inline">RestaurantsScreen()</strong> composable is rendering another state correctly – the state with content. In this state, the restaurants have arrived, so <a id="_idIndexMarker771"/>we reset the loading status to <strong class="source-inline">false</strong> and render the restaurants.</p>
			<ol>
				<li value="13">Inside the <strong class="source-inline">RestaurantsScreenTest</strong> class, add another test function named <strong class="source-inline">stateWithContent_isRendered()</strong>, which should test whether the state with content is rendered correctly:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_isRendered() {</p><p class="source-code">    testRule.setContent {</p><p class="source-code">        RestaurantsAppTheme {</p><p class="source-code">            RestaurantsScreen(</p><p class="source-code">                state = RestaurantsScreenState(</p><p class="source-code">                    restaurants =,</p><p class="source-code">                    isLoading = false),</p><p class="source-code">                onFavoriteClick =  </p><p class="source-code">                    { _: Int, _: Boolean -&gt; },</p><p class="source-code">                onItemClick = { }</p><p class="source-code">            )</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Inside this test method, we have set the <strong class="source-inline">RestaurantsScreen()</strong> composable with a state whose <strong class="source-inline">isLoading</strong> field is <strong class="source-inline">false</strong> (as the restaurants have arrived) but haven't passed a list of restaurants yet. We need to create a dummy list of restaurants to mimic some restaurants from our data layer.</p>
			<ol>
				<li value="14">For a moment, let's head out of the <strong class="source-inline">androidTest</strong> directory and go back inside the main package<a id="_idIndexMarker772"/> where our production code resides. Inside the <strong class="source-inline">restaurants</strong> package, create a new <strong class="source-inline">object</strong> class named <strong class="source-inline">DummyContent</strong>, and inside this class, add a <strong class="source-inline">getDomainRestaurants()</strong> method that will return a dummy array list of <strong class="source-inline">Restaurant</strong> objects:<p class="source-code">object DummyContent {</p><p class="source-code">    fun getDomainRestaurants() = arrayListOf(</p><p class="source-code">        Restaurant(0, "title0", "description0", false),</p><p class="source-code">        Restaurant(1, "title1", "description1", false),</p><p class="source-code">        Restaurant(2, "title2", "description2", false),</p><p class="source-code">        Restaurant(3, "title3", "description3", false))</p><p class="source-code">}</p></li>
				<li>Now, go back inside the <strong class="source-inline">androidTest</strong> directory and navigate to the <strong class="source-inline">RestaurantsScreenTest</strong> class. Inside the <strong class="source-inline">stateWithContent_isRendered()</strong> method, declare a <strong class="source-inline">restaurants</strong> variable that will hold the dummy restaurants from the <strong class="source-inline">DummyContent</strong> class and pass it to the <strong class="source-inline">restaurants</strong> parameter of <strong class="source-inline">RestaurantsScreenState</strong>:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_isRendered() {</p><p class="source-code">    <strong class="bold">val restaurants = DummyContent.getDomainRestaurants()</strong></p><p class="source-code">    testRule.setContent {</p><p class="source-code">        RestaurantsAppTheme {</p><p class="source-code">            RestaurantsScreen(</p><p class="source-code">                state = RestaurantsScreenState(</p><p class="source-code">                    <strong class="bold">restaurants = restaurants,</strong></p><p class="source-code">                    isLoading = false), […])</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now that we have finished the setup part of this test method, it's time to perform our assertions. Since <a id="_idIndexMarker773"/>we are testing that <strong class="source-inline">RestaurantsScreen()</strong> is correctly rendering the state that contains restaurants, let's have another quick look at the composable under test:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(<strong class="bold">state: RestaurantsScreenState</strong>, […]) {</p>
			<p class="source-code">    Box(…) {</p>
			<p class="source-code">        LazyColumn(…) {</p>
			<p class="source-code">            items(<strong class="bold">state.restaurants</strong>) { restaurant -&gt;</p>
			<p class="source-code">                 RestaurantItem(…)</p>
			<p class="source-code">             }</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if(<strong class="bold">state.isLoading</strong>)</p>
			<p class="source-code">            CircularProgressIndicator()</p>
			<p class="source-code">        if(state.error != null)</p>
			<p class="source-code">            Text(state.error)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We can deduct that the two conditions we can assert are as follows:</p>
			<ul>
				<li>The restaurants from <strong class="source-inline">RestaurantsScreenState</strong> are displayed on the screen.</li>
				<li>The <strong class="source-inline">CircularProgressIndicator()</strong> composable is not rendered, so its node is not visible on the screen.</li>
			</ul>
			<p>Let's start off with the first <a id="_idIndexMarker774"/>assertion. Instead of relying on the <strong class="source-inline">contentDescription</strong> semantic property, we can use another semantic property that is more obvious – the text displayed on the screen. Since <strong class="source-inline">LazyColumn</strong> will render a list of <strong class="source-inline">RestaurantItem()</strong> composables, each one will call a <strong class="source-inline">Text</strong> composable that will render the title and the description of the restaurant passed to its <strong class="source-inline">text</strong> parameter. With the help of our <strong class="source-inline">ComposeContentTestRule</strong>, we can identify a node with a certain text value by calling the <strong class="source-inline">onNodeWithText()</strong> method.</p>
			<ol>
				<li value="16">Back in the <strong class="source-inline">stateWithContent_isRendered()</strong> method, let's assert that <strong class="source-inline">title</strong> of the first <strong class="source-inline">Restaurant</strong> object from our dummy list is visible.</li>
			</ol>
			<p>Do that by passing the title of the first element from the <strong class="source-inline">restaurants</strong> variable to the <strong class="source-inline">onNodeWithText()</strong> method, thereby identifying its corresponding node. Finally, call the <strong class="source-inline">assertIsDisplayed()</strong> method to verify whether this node is displayed:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">fun stateWithContent_isRendered() {</p>
			<p class="source-code">    val restaurants = DummyContent.getDomainRestaurants()</p>
			<p class="source-code">    testRule.setContent {</p>
			<p class="source-code">        RestaurantsAppTheme {</p>
			<p class="source-code">            RestaurantsScreen(</p>
			<p class="source-code">                state = RestaurantsScreenState(</p>
			<p class="source-code">                    restaurants = restaurants,</p>
			<p class="source-code">                    isLoading = false</p>
			<p class="source-code">                ),</p>
			<p class="source-code">                […])</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    testRule.onNodeWithText(restaurants[0].title)</strong></p>
			<p class="source-code"><strong class="bold">        .assertIsDisplayed()</strong></p>
			<p class="source-code">}</p>
			<ol>
				<li value="17">Similarly, to assert <a id="_idIndexMarker775"/>whether the node of the title of the first restaurant from our dummy list is displayed, verify whether the node of the description of the first restaurant is displayed:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_isRendered() {</p><p class="source-code">    val restaurants = DummyContent.getDomainRestaurants()</p><p class="source-code">    testRule.setContent { ... }</p><p class="source-code">    testRule.onNodeWithText(restaurants[0].title)</p><p class="source-code"><strong class="bold">        </strong>.assertIsDisplayed()</p><p class="source-code"><strong class="bold">    testRule.onNodeWithText(restaurants[0].description)</strong></p><p class="source-code"><strong class="bold">        .assertIsDisplayed()</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>You might be wondering why we aren't asserting whether <strong class="source-inline">title</strong> or <strong class="source-inline">description</strong> of all the elements from the <strong class="source-inline">DummyContent</strong> class is visible. It's important to understand that our test is asserting whether some nodes are displayed on the screen.</p>
			<p>That's why, if our <strong class="source-inline">restaurants</strong> list contained 10 or 15 elements and we tested whether all titles and description nodes are visible, we could have had this test method pass on tall devices, since all the restaurants would fit and would be <em class="italic">composed</em> on the screen, but it could have failed if the test device was small and only some<a id="_idIndexMarker776"/> of the restaurants fitted on the screen and were composed.</p>
			<p>This would have made our test flaky. To prevent our test from being flaky, we only asserted whether the first restaurant is visible, therefore minimizing the chance of having the test run and fail on an incredibly small screen.</p>
			<p>Another interesting tactic that you can employ in order to test that content is correctly rendered would be to emulate a scroll action inside your test to the bottom of the list and check whether the last element is visible. This, however, is more complex, so we will proceed with the simpler version that we have implemented.</p>
			<ol>
				<li value="18">Lastly, let's assert that the node corresponding to the <strong class="source-inline">CircularProgressIndicator()</strong> composable does not exist, therefore ensuring that the app is not loading anything anymore. Do that by calling the <strong class="source-inline">assertDoesNotExist()</strong> method on the node with the <strong class="source-inline">RESTAURANTS_LOADING</strong> content description:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_isRendered() {</p><p class="source-code">    val restaurants = DummyContent.getDomainRestaurants()</p><p class="source-code">    testRule.setContent { … }</p><p class="source-code">    testRule.onNodeWithText(restaurants[0].title)</p><p class="source-code">        .assertIsDisplayed()</p><p class="source-code">    testRule.onNodeWithText(restaurants[0].description)</p><p class="source-code">        .assertIsDisplayed()</p><p class="source-code"><strong class="bold">    testRule.onNodeWithContentDescription(</strong></p><p class="source-code">        <strong class="bold">Description.RESTAURANTS_LOADING</strong></p><p class="source-code"><strong class="bold">    ).assertDoesNotExist()</strong></p><p class="source-code">}</p></li>
				<li>Now that we have<a id="_idIndexMarker777"/> finished writing our second test method asserting whether the <strong class="source-inline">RestaurantsScreen()</strong> composable is correctly rendering the state with content, inside the <strong class="bold">Project</strong> tab on the left, right-click on the <strong class="source-inline">RestaurantsScreenTest</strong> class and select <strong class="bold">Run RestaurantsScreenTest</strong>.</li>
			</ol>
			<p>The tests should run and pass.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">Try writing a test method on your own that asserts whether the <strong class="source-inline">RestaurantsScreen()</strong> composable renders the error state correctly. As a hint, you should be passing an error text to the <strong class="source-inline">error</strong> parameter of the <strong class="source-inline">RestaurantsScreen()</strong>, and then you should be asserting whether a node with that particular text is visible, while also verifying that the node corresponding to the <strong class="source-inline">CircularProgressIndicator()</strong> composable does not exist.</p>
			<p>Finally, let's write a test method where we can verify whether upon clicking on a restaurant element from our dummy list, the correct callback is exposed by the parent <strong class="source-inline">RestaurantsScreen()</strong> composable:</p>
			<ol>
				<li value="20">Inside the <strong class="source-inline">RestaurantsScreenTest</strong> class, add another test function named <strong class="source-inline">stateWithContent_ClickOnItem_isRegistered()</strong>. Inside this method, store the dummy list inside a <strong class="source-inline">restaurants</strong> variable, and then store the first <a id="_idIndexMarker778"/>restaurant that we will click upon inside the <strong class="source-inline">targetRestaurant</strong> variable:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_ClickOnItem_isRegistered() {</p><p class="source-code">    val restaurants = DummyContent.getDomainRestaurants()</p><p class="source-code">    val targetRestaurant = restaurants[0]</p><p class="source-code">}</p></li>
				<li>Then, set <strong class="source-inline">RestaurantsScreen()</strong> under test and feed it with a state with content by passing the contents of the <strong class="source-inline">restaurants</strong> variable to the <strong class="source-inline">restaurants</strong> parameter of <strong class="source-inline">RestaurantsScreenState</strong>:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_ClickOnItem_isRegistered() {</p><p class="source-code">    val restaurants = DummyContent.getDomainRestaurants()</p><p class="source-code"><strong class="bold">    </strong>val targetRestaurant = restaurants[0]</p><p class="source-code"><strong class="bold">    testRule.setContent {</strong></p><p class="source-code"><strong class="bold">        RestaurantsAppTheme {</strong></p><p class="source-code"><strong class="bold">            RestaurantsScreen(</strong></p><p class="source-code"><strong class="bold">                state = RestaurantsScreenState(</strong></p><p class="source-code"><strong class="bold">                    restaurants = restaurants,</strong></p><p class="source-code"><strong class="bold">                    isLoading = false),</strong></p><p class="source-code"><strong class="bold">                onFavoriteClick = { _, _ -&gt; },</strong></p><p class="source-code"><strong class="bold">                onItemClick = { id -&gt;  })</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
				<li>Then, identify the <a id="_idIndexMarker779"/>node that contains the <strong class="source-inline">title</strong> text of <strong class="source-inline">targetRestaurant</strong> and then simulate a user click on this node by calling the <strong class="source-inline">performClick()</strong> method:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_ClickOnItem_isRegistered() {</p><p class="source-code">    val restaurants = DummyContent.getDomainRestaurants()</p><p class="source-code">    val targetRestaurant = restaurants[0]</p><p class="source-code">    testRule.setContent {</p><p class="source-code">        RestaurantsAppTheme {</p><p class="source-code">            RestaurantsScreen(</p><p class="source-code">                state = RestaurantsScreenState(</p><p class="source-code">                    restaurants = restaurants,</p><p class="source-code">                    isLoading = false),</p><p class="source-code">                onFavoriteClick = { _, _ -&gt; },</p><p class="source-code">                onItemClick = { id -&gt; })</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code"><strong class="bold">    testRule.onNodeWithText(targetRestaurant.title)</strong></p><p class="source-code"><strong class="bold">        .performClick()</strong></p><p class="source-code">}</p></li>
				<li>Now that we have simulated a user-click interaction, let's assert that the <strong class="source-inline">id</strong> value from the <strong class="source-inline">onItemClick</strong> callback<a id="_idIndexMarker780"/> exposed by the <strong class="source-inline">RestaurantsScreen()</strong> composable matches with the <strong class="source-inline">id</strong> value of the restaurant we have clicked on:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_ClickOnItem_isRegistered() {</p><p class="source-code">    val restaurants = DummyContent.getDomainRestaurants()</p><p class="source-code">    val targetRestaurant = restaurants[0]</p><p class="source-code">    testRule.setContent {</p><p class="source-code">        RestaurantsAppTheme {</p><p class="source-code">            RestaurantsScreen(</p><p class="source-code">                state = RestaurantsScreenState(</p><p class="source-code">                    restaurants = restaurants,</p><p class="source-code">                    isLoading = false),</p><p class="source-code">                onFavoriteClick = { _, _ -&gt; },</p><p class="source-code">                onItemClick = { id -&gt;</p><p class="source-code"><strong class="bold">                    assert(id == targetRestaurant.id)</strong></p><p class="source-code">                }</p><p class="source-code">            )</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    testRule.onNodeWithText(targetRestaurant.title)</p><p class="source-code">        .performClick()</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="bold">Project</strong> tab on the left, right-click on the <strong class="source-inline">RestaurantsScreenTest</strong> class and select <strong class="bold">Run RestaurantsScreenTest</strong>.</li>
			</ol>
			<p>The three tests <a id="_idIndexMarker781"/>should run and pass.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might have noticed that we haven't given any attention to testing how the UI updates when a user toggles a restaurant as a favorite or not a favorite. The only way we could have done that is by adding a dedicated semantic property to the heart icon of each restaurant from the list and then testing the value of that property. However, we would have tested a semantic property value and not the UI – for such cases, it's better to look into <strong class="bold">screenshot testing</strong> strategies. Screenshot testing is a UI testing practice that generates screenshots of your app, which are then compared to the initially defined <em class="italic">correct</em> versions.</p>
			<p>Now that we briefly covered UI testing with Compose, it's time to unit-test our app's behind-the-scenes functionality!</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor311"/>Covering the basics of unit-testing your core logic</h1>
			<p>Apart from<a id="_idIndexMarker782"/> testing our UI layer, we must also test the core logic of our application. This means that we should try to verify as much behavior as possible in terms of presentation logic (testing <strong class="source-inline">ViewModel</strong> classes), business logic (testing <strong class="source-inline">UseCase</strong> classes), or even data logic (testing <strong class="source-inline">Repository</strong> classes).</p>
			<p>The easiest way of validating such logic is by writing unit tests for each class or group of classes whose behavior we're trying to verify.</p>
			<p>In this section, we will be writing unit tests for the <strong class="source-inline">RestaurantsViewModel</strong> class and the <strong class="source-inline">ToggleRestaurantUseCase</strong> class. Since these components don't interact directly with the UI, their unit tests will run<a id="_idIndexMarker783"/> directly on your local workstation's <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>), rather than running on an Android device, as our UI tests did.</p>
			<p>To summarize, in this<a id="_idIndexMarker784"/> section, we will be doing the following:</p>
			<ul>
				<li>Testing the functionality of a <strong class="source-inline">ViewModel</strong> class</li>
				<li>Testing the functionality of a <strong class="source-inline">UseCase</strong> class</li>
			</ul>
			<p>Let's begin by testing the <strong class="source-inline">RestaurantsViewModel</strong> class!</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor312"/>Testing the functionality of a ViewModel class</h2>
			<p>We want to test the <a id="_idIndexMarker785"/>functionality of our <strong class="source-inline">RestaurantsViewModel</strong> so that we can make sure that it's correctly performing the role of state producer for the <strong class="source-inline">RestaurantsScreen()</strong> composable.</p>
			<p>To achieve that, we will <a id="_idIndexMarker786"/>write unit tests for this <strong class="source-inline">ViewModel</strong> class in isolation. Let's begin:</p>
			<ol>
				<li value="1">First, locate the <strong class="source-inline">test</strong> package that is suited for regular unit tests: </li>
			</ol>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B17788_10_03.jpg" alt="Figure 10.3 – Observing the test package used for regular unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Observing the test package used for regular unit tests</p>
			<p>Also, note that the pre-built <strong class="source-inline">ExampleUnitTest</strong> class resides inside this package.</p>
			<ol>
				<li value="2">Create an empty Kotlin class named <strong class="source-inline">RestaurantsViewModelTest</strong> inside the <strong class="source-inline">test</strong> package. Inside this <a id="_idIndexMarker787"/>class, we will define a method for each independent test. Behind the scenes, every method will become a standalone unit test that can pass or fail.</li>
			</ol>
			<p>Before starting to write <a id="_idIndexMarker788"/>our first test method, let's have another look at our <strong class="source-inline">RestaurantsViewModel</strong> class so that we can remind ourselves which cases we're looking to test:</p>
			<p class="source-code">class RestaurantsViewModel @Inject constructor(…) : ViewModel() {</p>
			<p class="source-code"><strong class="bold">    private val _state = mutableStateOf(</strong></p>
			<p class="source-code"><strong class="bold">        RestaurantsScreenState(</strong></p>
			<p class="source-code"><strong class="bold">            restaurants = listOf(),</strong></p>
			<p class="source-code"><strong class="bold">            isLoading = true</strong></p>
			<p class="source-code"><strong class="bold">        )</strong></p>
			<p class="source-code"><strong class="bold">    )</strong></p>
			<p class="source-code">    […]</p>
			<p class="source-code">    private val errorHandler = CoroutineExceptionHandler</p>
			<p class="source-code">    { … -&gt;</p>
			<p class="source-code">        exception.printStackTrace()</p>
			<p class="source-code">        <strong class="bold">_state.value = _state.value.copy(</strong></p>
			<p class="source-code">            <strong class="bold">error = exception.message, </strong></p>
			<p class="source-code">            <strong class="bold">isLoading = false)</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    init { getRestaurants() }</p>
			<p class="source-code">    fun toggleFavorite(itemId: Int, oldValue: Boolean) {</p>
			<p class="source-code">        […] </p>
			<p class="source-code">    }</p>
			<p class="source-code">    private fun getRestaurants() {</p>
			<p class="source-code">        viewModelScope.launch(errorHandler) {</p>
			<p class="source-code">            val restaurants = getRestaurantsUseCase()</p>
			<p class="source-code"><strong class="bold">            _state.value = _state.value.copy(</strong></p>
			<p class="source-code"><strong class="bold">                restaurants = restaurants,</strong></p>
			<p class="source-code"><strong class="bold">                isLoading = false)</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We can say that our <strong class="source-inline">RestaurantsViewModel</strong> should produce the exact three states that we<a id="_idIndexMarker789"/> fed to the <strong class="source-inline">RestaurantsScreen()</strong> composable in its own UI tests:</p>
			<ul>
				<li><strong class="bold">Initial loading state</strong>: At this point, we're<a id="_idIndexMarker790"/> waiting for restaurants, thus rendering a loading status. You can see this initial state declared <a id="_idIndexMarker791"/>at the top of the <strong class="source-inline">ViewModel</strong> class in the initialization of the <strong class="source-inline">_state</strong> variable, where the <strong class="source-inline">restaurants</strong> parameter of <strong class="source-inline">RestaurantsScreenState</strong> is set to <strong class="source-inline">emptyList()</strong> and the <strong class="source-inline">isLoading</strong> parameter is set to <strong class="source-inline">true</strong>.</li>
				<li><strong class="bold">State with content</strong>: The restaurants have arrived. This state is produced inside the coroutine<a id="_idIndexMarker792"/> launched in the <strong class="source-inline">getRestaurants()</strong> method, where we mutated the initial state and set the <strong class="source-inline">isLoading</strong> parameter to <strong class="source-inline">false</strong> while also passing the list of restaurants to the <strong class="source-inline">restaurants</strong> parameter.</li>
				<li><strong class="bold">Error state</strong>: Something went <a id="_idIndexMarker793"/>wrong when the app tried to fetch its content. You can see how this state is created inside <strong class="source-inline">CoroutineExceptionHandler</strong>, where the <strong class="source-inline">isLoading</strong> parameter is set to <strong class="source-inline">false</strong> to reset the loading status while also passing the message of <strong class="source-inline">Exception</strong> to the <strong class="source-inline">error</strong> parameter.</li>
			</ul>
			<p>In the end, what we basically have to do is assert that the value of the <strong class="source-inline">state</strong> variable (of type <strong class="source-inline">RestaurantsScreenState</strong>), which is exposed to the UI, evolves correctly over time, from the initial state to all possible states.</p>
			<p>Let's begin with a test method that asserts whether the initial state is produced as expected:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RestaurantsViewModelTest</strong> class, add an empty test function named <strong class="source-inline">initialState_isProduced()</strong> that will later test whether our <strong class="source-inline">RestaurantsViewModel</strong> class properly produces the initial state:<p class="source-code">    @Test</p><p class="source-code">    fun initialState_isProduced() {  }</p></li>
			</ol>
			<p>As with the UI tests, we will make <a id="_idIndexMarker794"/>use of the JUnit testing library to define and run individual unit tests for each method annotated with the <strong class="source-inline">@Test</strong> annotation.</p>
			<p>Again similar to the UI tests, we<a id="_idIndexMarker795"/> named this method around the specific behavior it's trying to test, going from what we're testing (the initial state) to what should happen (the state being correctly produced).</p>
			<ol>
				<li value="2">Inside the <strong class="source-inline">initialState_isProduced()</strong> method, we must create an instance of the subject under test – that is, <strong class="source-inline">RestaurantsViewModel</strong>. Define a <strong class="source-inline">viewModel</strong> variable and instantiate it with the value returned by the <strong class="source-inline">getViewModel()</strong> method, which we will define in a second:<p class="source-code">@Test</p><p class="source-code">fun initialState_isProduced() {</p><p class="source-code"><strong class="bold">    val viewModel = getViewModel()</strong></p><p class="source-code">}</p></li>
				<li>Still inside the <strong class="source-inline">RestaurantsViewModelTest</strong> class, define the <strong class="source-inline">getViewModel()</strong> method, which will return an instance of <strong class="source-inline">RestaurantsViewModel</strong>:<p class="source-code">private fun getViewModel(): RestaurantsViewModel {</p><p class="source-code">    return RestaurantsViewModel()</p><p class="source-code">}</p></li>
			</ol>
			<p>The problem now is that the <strong class="source-inline">RestaurantsViewModel</strong> constructor needs an instance of <strong class="source-inline">GetInitialRestaurantsUseCase</strong> and <strong class="source-inline">ToggleRestaurantsUseCase</strong>. In turn, these two classes also have other dependencies that we must instantiate. Let's have a <a id="_idIndexMarker796"/>clearer look at what classes we need to instantiate:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B17788_10_04.jpg" alt="Figure 10.4 – Observing the direct and transitive dependencies of RestaurantsViewModel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Observing the direct and transitive dependencies of RestaurantsViewModel</p>
			<p>We can see that both <strong class="source-inline">GetInitialRestaurantsUseCase</strong> and <strong class="source-inline">ToggleRestaurantsUseCase</strong> depend <a id="_idIndexMarker797"/>on <strong class="source-inline">GetSortedRestaurantsUseCase</strong> and <strong class="source-inline">RestaurantsRepository</strong>. The latter then depends on two library interfaces – <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RestaurantsDao</strong>.</p>
			<p>Essentially, we must instantiate all these classes to test our <strong class="source-inline">RestaurantsViewModel</strong>.</p>
			<ol>
				<li value="4">Inside the <strong class="source-inline">RestaurantsViewModelTest</strong> class, refactor the <strong class="source-inline">getViewModel()</strong> method to <a id="_idIndexMarker798"/>construct all the necessary dependencies of <strong class="source-inline">RestaurantsViewModel</strong>:<p class="source-code">private fun getViewModel(): RestaurantsViewModel {</p><p class="source-code">    <strong class="bold">val restaurantsRepository = </strong></p><p class="source-code"><strong class="bold">        RestaurantsRepository(?, ?)</strong></p><p class="source-code"><strong class="bold">    val getSortedRestaurantsUseCase =</strong></p><p class="source-code"><strong class="bold">        GetSortedRestaurantsUseCase(restaurantsRepository)</strong></p><p class="source-code"><strong class="bold">    val getInitialRestaurantsUseCase =</strong></p><p class="source-code"><strong class="bold">        GetInitialRestaurantsUseCase(</strong></p><p class="source-code"><strong class="bold">            restaurantsRepository,</strong></p><p class="source-code"><strong class="bold">            getSortedRestaurantsUseCase)</strong></p><p class="source-code"><strong class="bold">    val toggleRestaurantUseCase =</strong></p><p class="source-code"><strong class="bold">        ToggleRestaurantUseCase(</strong></p><p class="source-code"><strong class="bold">            restaurantsRepository,</strong></p><p class="source-code"><strong class="bold">            getSortedRestaurantsUseCase</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code"><strong class="bold">    </strong>return RestaurantsViewModel(</p><p class="source-code"><strong class="bold">        getInitialRestaurantsUseCase,</strong></p><p class="source-code"><strong class="bold">        toggleRestaurantUseCase</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>If you read the previous snippet<a id="_idIndexMarker799"/> from bottom to top, you will notice that we were able to construct all the dependencies of the <strong class="source-inline">RestaurantsViewModel</strong>, and their dependencies, and so on until we hit <strong class="source-inline">RestaurantsRepository</strong>. This depends on two library interfaces, <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RestaurantsDao</strong>, whose implementations are provided by the Retrofit and Room libraries.</p>
			<p>In our production code, these two interfaces cross the boundary to the <em class="italic">real world</em> because<a id="_idIndexMarker800"/> their implementations, provided by the Retrofit and Room libraries, communicate with a real Firebase REST API and a real Room local database:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B17788_10_05.jpg" alt="Figure 10.5 – Observing the real-world boundary crossed by the transitive &#13;&#10;dependencies of RestaurantsViewModel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Observing the real-world boundary crossed by the transitive dependencies of RestaurantsViewModel</p>
			<p>If we were to use the existing implementations of these two interfaces provided by Retrofit and Room in our test code, the <strong class="source-inline">RestaurantsViewModel</strong> instance will communicate with the external world and our tests won't be isolated. Instead, our test code will be slow and not reliable because it will be dependent on our web REST API and a real local database.</p>
			<p>Yet how can we make our <strong class="source-inline">RestaurantsViewModel</strong> tests isolated, fast, and reliable? We can simply make sure that instead of having Retrofit and Room provide the implementations for <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RestaurantsDao</strong>, we define dummy implementations for these interfaces that won't communicate with the real world. </p>
			<p>These dummy implementations are often called fakes. <strong class="bold">Fakes</strong> are simplified implementations of the interfaces that<a id="_idIndexMarker801"/> we're looking to interact with in our tests. Such implementations mimic the behavior of the production implementations in a very simplified manner, often by returning dummy data. Fakes will only be used in our tests, so we can ensure that our testing environment is isolated.</p>
			<p>Apart from fakes, to <a id="_idIndexMarker802"/>mimic the functionality of components that cross the boundary to the real world, you can also use mocks. <strong class="bold">Mocks</strong> are objects that also simulate the behavior of a real object; however, you can configure their output on the fly without any additional classes. </p>
			<p>In this chapter, we will only focus on fakes, since most of the time, to create mocks, you need to use<a id="_idIndexMarker803"/> special mocking frameworks. Also, fakes tend to be more practical and can be reused across tests, whereas mocks tend to clutter your tests, as they bring a lot of boilerplate code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whenever you have a component that interacts with the <em class="italic">real world</em>, be it a web API, local database, or other production systems, you should define an interface for it. This way, in your production code, your other components interact with a real implementation of that interface, while your tests interact with a fake implementation of it.</p>
			<p>Let's see how we can implement fakes. In our case, <strong class="source-inline">RestaurantsRepository</strong> needs fake implementations of the <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RestaurantsDao</strong> interfaces. Let's begin with a fake implementation of the <strong class="source-inline">RestaurantsApiService</strong> interface:</p>
			<ol>
				<li value="1">To create a fake for the <strong class="source-inline">RestaurantsApiService</strong> interface, we must define a class that will implement the interface and simulate the functionality of a REST API. Inside the <strong class="source-inline">test</strong> package, create a Kotlin class named <strong class="source-inline">FakeApiService</strong> that implements the <strong class="source-inline">RestaurantsApiService</strong> interface and add the following code inside:<p class="source-code">class FakeApiService : RestaurantsApiService {</p><p class="source-code">    override suspend fun getRestaurants()</p><p class="source-code">            : List&lt;RemoteRestaurant&gt; {</p><p class="source-code">        delay(1000)</p><p class="source-code">        return DummyContent.getRemoteRestaurants()</p><p class="source-code">    }</p><p class="source-code">    override suspend fun getRestaurant(id: Int)</p><p class="source-code">            : Map&lt;String, RemoteRestaurant&gt; {</p><p class="source-code">        TODO("Not yet implemented")</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Our <strong class="source-inline">FakeApiService</strong> overrides the required methods and returns some dummy restaurants from the <strong class="source-inline">DummyContent</strong> class. In the <strong class="source-inline">getRestaurants()</strong> method, we<a id="_idIndexMarker804"/> also call a coroutine-based <strong class="source-inline">delay()</strong> function of 1,000 milliseconds to better simulate an asynchronous response. Since <a id="_idIndexMarker805"/>we will not be using the <strong class="source-inline">getRestaurant()</strong> method in our tests right now, we haven't added any implementation inside it.</p>
			<p>Going back to the dummy content that is returned, note that the <strong class="source-inline">getRestaurants()</strong> method must return a list of <strong class="source-inline">RemoteRestaurant</strong> objects, so we called a non-existent <strong class="source-inline">getRemoteRestaurants()</strong> method on the <strong class="source-inline">DummyContent</strong> class. Let's define this method up next.</p>
			<ol>
				<li value="2">Head back inside the main source set where our production code resides. Inside the <strong class="source-inline">DummyContent</strong> class, add a new method called <strong class="source-inline">getRemoteRestaurants()</strong> that maps the list of <strong class="source-inline">Restaurant</strong> objects returned by the <strong class="source-inline">getDomainRestaurants()</strong> method to <strong class="source-inline">RemoteRestaurant</strong> objects:<p class="source-code">object DummyContent {</p><p class="source-code">    <strong class="bold">fun getDomainRestaurants() = arrayListOf(…)</strong></p><p class="source-code"><strong class="bold">    fun getRemoteRestaurants() = getDomainRestaurants()</strong></p><p class="source-code"><strong class="bold">        .map {</strong></p><p class="source-code"><strong class="bold">            RemoteRestaurant(</strong></p><p class="source-code"><strong class="bold">                it.id,</strong></p><p class="source-code"><strong class="bold">                it.title,</strong></p><p class="source-code"><strong class="bold">                it.description</strong></p><p class="source-code"><strong class="bold">            )</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">}</p></li>
				<li>Now, head back inside the <strong class="source-inline">test</strong> package. We've created a fake for the <strong class="source-inline">RestaurantsApiService</strong> interface, but we must also create one fake for the <strong class="source-inline">RestaurantsDao</strong> interface<a id="_idIndexMarker806"/> that will implement the interface and <a id="_idIndexMarker807"/>simulate the functionality of a local database. Inside the <strong class="source-inline">test</strong> package, create a Kotlin class named <strong class="source-inline">FakeRoomDao</strong> that implements the <strong class="source-inline">RestaurantsDao</strong> interface and add the following code inside:<p class="source-code">class FakeRoomDao : RestaurantsDao {</p><p class="source-code">    private var restaurants =</p><p class="source-code">              HashMap&lt;Int, LocalRestaurant&gt;()</p><p class="source-code">    override suspend fun getAll()</p><p class="source-code">            : List&lt;LocalRestaurant&gt; {</p><p class="source-code">        delay(1000)</p><p class="source-code">        return restaurants.values.toList()</p><p class="source-code">    }</p><p class="source-code">    override suspend fun addAll(</p><p class="source-code">        restaurants: List&lt;LocalRestaurant&gt;</p><p class="source-code">    ) {</p><p class="source-code">        restaurants.forEach { </p><p class="source-code">            this.restaurants[it.id] = it </p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override suspend fun update(</p><p class="source-code">        partialRestaurant: PartialLocalRestaurant</p><p class="source-code">    ) {</p><p class="source-code">        delay(1000)</p><p class="source-code">        updateRestaurant(partialRestaurant)</p><p class="source-code">    }</p><p class="source-code">    override suspend fun updateAll(</p><p class="source-code">        partialRestaurants: List&lt;PartialLocalRestaurant&gt;</p><p class="source-code">    ) {</p><p class="source-code">        delay(1000)</p><p class="source-code">        partialRestaurants.forEach { </p><p class="source-code">            updateRestaurant(it) </p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override suspend fun getAllFavorited()</p><p class="source-code">            : List&lt;LocalRestaurant&gt; {</p><p class="source-code">        return restaurants.values.toList()</p><p class="source-code">            .filter { it.isFavorite }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Our <strong class="source-inline">FakeRoomDao</strong> class <a id="_idIndexMarker808"/>mimics the functionality of a real Room database, yet instead of storing restaurants in the local SQL database, it stores them in memory in the <strong class="source-inline">restaurants</strong> variable. We will not cover each method implementation of <strong class="source-inline">FakeRoomDao</strong>. </p>
			<p>However, we will conclude that each method simulates the interaction with a<a id="_idIndexMarker809"/> persistent storage service. Additionally, as our <strong class="source-inline">FakeRoomDao</strong> simulates interaction with a real local database, each of its actions will cause a delay triggered by the pre-built suspending <strong class="source-inline">delay()</strong> function.</p>
			<p>However, our <strong class="source-inline">FakeRoom</strong> class makes use of an <strong class="source-inline">updateRestaurant()</strong> method that we haven't defined so far. Let's do that now.</p>
			<ol>
				<li value="4">At the end of the body <a id="_idIndexMarker810"/>of the <strong class="source-inline">FakeRoom</strong> class, add the missing <strong class="source-inline">updateRestaurant()</strong> method that toggles the value of the <strong class="source-inline">isFavorite</strong> field:<p class="source-code">class FakeRoomDao : RestaurantsDao {</p><p class="source-code">    [...]</p><p class="source-code">    override suspend fun getAllFavorited()</p><p class="source-code">            : List&lt;LocalRestaurant&gt; { ... }</p><p class="source-code"><strong class="bold">    private fun updateRestaurant(</strong></p><p class="source-code"><strong class="bold">        partialRestaurant: PartialLocalRestaurant</strong></p><p class="source-code"><strong class="bold">    ) {</strong></p><p class="source-code"><strong class="bold">       val restaurant = </strong></p><p class="source-code"><strong class="bold">           this.restaurants[partialRestaurant.id]</strong></p><p class="source-code"><strong class="bold">       if (restaurant != null)</strong></p><p class="source-code"><strong class="bold">           this.restaurants[partialRestaurant.id] =</strong></p><p class="source-code"><strong class="bold">               restaurant.copy(</strong></p><p class="source-code"><strong class="bold">                   isFavorite = </strong></p><p class="source-code"><strong class="bold">                       partialRestaurant.isFavorite</strong></p><p class="source-code"><strong class="bold">               )</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
				<li>Now that we have finished implementing the fakes for our <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RestaurantsDao</strong> interfaces, it's time to pass them where we need them in our tests. Remember that the last missing piece was to provide fake<a id="_idIndexMarker811"/> implementations of the <strong class="source-inline">RestaurantsRepository</strong> dependencies so that our test is isolated.</li>
			</ol>
			<p>Head back inside the <strong class="source-inline">RestaurantsViewModelTest</strong> class and update the <strong class="source-inline">getViewModel()</strong> function to <a id="_idIndexMarker812"/>pass instances of the <strong class="source-inline">FakeApiService</strong> and <strong class="source-inline">FakeRoomDao</strong> classes to <strong class="source-inline">RestaurantsRepository</strong>:</p>
			<p class="source-code">private fun getViewModel(): RestaurantsViewModel {</p>
			<p class="source-code">    val restaurantsRepository = RestaurantsRepository(</p>
			<p class="source-code">        <strong class="bold">FakeApiService(), FakeRoomDao())</strong></p>
			<p class="source-code">    […]</p>
			<p class="source-code">    return RestaurantsViewModel(…)</p>
			<p class="source-code">}</p>
			<p>Now that the <strong class="source-inline">getViewModel()</strong> method is able to return an instance of <strong class="source-inline">RestaurantsViewModel</strong> that we can <a id="_idIndexMarker813"/>easily test, let's get back to our <strong class="source-inline">initialState_isProduced()</strong> test method, which currently looks like this:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">fun initialState_isProduced() {</p>
			<p class="source-code">    val viewModel = getViewModel()</p>
			<p class="source-code">}</p>
			<p>Remember that the scope of this test method is to verify that when our <strong class="source-inline">RestaurantsViewModel</strong> is initialized, it produces a correct initial state. Let's do that now.</p>
			<ol>
				<li value="6">First, inside the <strong class="source-inline">initialState_isProduced()</strong> test method, store the initial state inside an <strong class="source-inline">initialState</strong> variable:<p class="source-code">@Test</p><p class="source-code">fun initialState_isProduced() {</p><p class="source-code">    val viewModel = getViewModel()</p><p class="source-code">    <strong class="bold">val initialState = viewModel.state.value</strong></p><p class="source-code">}</p></li>
				<li>Next, by using the built-in <strong class="source-inline">assert()</strong> function, verify whether the content of <strong class="source-inline">initialState</strong> is as expected:<p class="source-code">@Test</p><p class="source-code">fun initialState_isProduced() {</p><p class="source-code">    val viewModel = getViewModel()</p><p class="source-code">    val initialState = viewModel.state.value</p><p class="source-code"><strong class="bold">    assert(</strong></p><p class="source-code"><strong class="bold">        initialState == RestaurantsScreenState(</strong></p><p class="source-code"><strong class="bold">            restaurants = emptyList(),</strong></p><p class="source-code"><strong class="bold">            isLoading = true,</strong></p><p class="source-code"><strong class="bold">            error = null)</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>In this test method, we're asserting whether<a id="_idIndexMarker814"/> the value of the <strong class="source-inline">initialState</strong> variable is a <strong class="source-inline">RestaurantsScreenState</strong> object with a <strong class="source-inline">false</strong> <strong class="source-inline">isLoading</strong> field and an <strong class="source-inline">emptyList()</strong> value inside the <strong class="source-inline">restaurants</strong> field. Additionally, we're testing that there is no value<a id="_idIndexMarker815"/> stored inside the <strong class="source-inline">error</strong> field.</p>
			<ol>
				<li value="8">Now that we have defined our first test method, it's time to run the test!</li>
			</ol>
			<p>Inside the <strong class="bold">Project</strong> tab on the left, right-click on the <strong class="source-inline">RestaurantsViewModelTest</strong> class and select <strong class="bold">Run RestaurantsViewModelTest</strong>. This command will run all the tests inside this class (only one in our case) directly on your local JVM, rather than running on an Android device, as our UI tests did.</p>
			<p>If you switch to the <strong class="bold">Run</strong> tab, you will see that our test has failed:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B17788_10_06.jpg" alt="Figure 10.6 – Observing how the test inside the RestaurantsViewModelTest class has failed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – Observing how the test inside the RestaurantsViewModelTest class has failed</p>
			<p>This exception is thrown because our Restaurants app handles asynchronous work with the help of coroutines, and our test code doesn't know how to interact with them.</p>
			<p>For instance, our <strong class="source-inline">RestaurantsViewModel</strong> launches coroutines that call several suspend functions, and <a id="_idIndexMarker816"/>all of these <a id="_idIndexMarker817"/>happen on <strong class="source-inline">viewModelScope</strong>, which h<a id="_idIndexMarker818"/>as the <strong class="source-inline">Dispatchers.Main</strong> dispatcher set by default:</p>
			<p class="source-code">@HiltViewModel</p>
			<p class="source-code">class RestaurantsViewModel @Inject constructor(...) : […] {</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    fun toggleFavorite(itemId: Int, oldValue: Boolean) {</p>
			<p class="source-code">        <strong class="bold">viewModelScope.launch</strong>(errorHandler) { ... }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private fun getRestaurants() {</p>
			<p class="source-code">        <strong class="bold">viewModelScope.launch</strong>(errorHandler) { ... }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The main issue here is that our coroutines are launched on the Main thread on our local JVM, which can't work with the UI thread.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">Dispatchers.Main</strong> dispatcher uses the Android <strong class="source-inline">Looper.getMainLooper()</strong> function to run code in the UI thread. That method is available in UI tests but not in the regular unit tests that run on our JVM.</p>
			<p>To make our testing <a id="_idIndexMarker819"/>code compliant with the usage of coroutines, we need to use the Kotlin coroutines testing library, which will provide us with scopes and dispatchers that are dedicated to testing coroutines. If our test code is run from coroutines that are built with these dedicated scopes and <a id="_idIndexMarker820"/>dispatchers, our test will no longer fail.</p>
			<p>Let's add the Kotlin coroutines testing library!</p>
			<ol>
				<li value="1">In the app-level <strong class="source-inline">build.gradle</strong> file, add a <strong class="source-inline">testImplementation</strong> dependency to the Kotlin coroutines testing package: <p class="source-code">dependencies {</p><p class="source-code">    […]</p><p class="source-code">    testImplementation "com.google.truth:truth:1.1.2"</p><p class="source-code">    <strong class="bold">testImplementation 'org.jetbrains.kotlinx:kotlinx-</strong></p><p class="source-code"><strong class="bold">        coroutines-test:1.6.1'</strong></p><p class="source-code">}</p></li>
				<li>Synchronize your project with its Gradle files by clicking on the <strong class="bold">Sync your project with Gradle files</strong> button in Android Studio or by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</li>
				<li>Head back inside the <strong class="source-inline">RestaurantsViewModelTest</strong> class and define a variable for a <strong class="source-inline">StandardTestDispatcher</strong> object and a variable for a <strong class="source-inline">TestScope</strong> object based on the previously defined dispatcher:<p class="source-code"><strong class="bold">@ExperimentalCoroutinesApi</strong></p><p class="source-code">class RestaurantsViewModelTest {</p><p class="source-code"><strong class="bold">    private val dispatcher = StandardTestDispatcher()</strong></p><p class="source-code"><strong class="bold">    private val scope = TestScope(dispatcher)</strong></p><p class="source-code">    @Test</p><p class="source-code">    fun initialState_isProduced() {…}</p><p class="source-code">    private fun getViewModel(): RestaurantsViewModel {…}</p><p class="source-code">}</p></li>
			</ol>
			<p>Additionally, we've added the <strong class="source-inline">@ExperimentalCoroutinesApi</strong> annotation to the <strong class="source-inline">RestaurantsViewModelTest</strong> class, since these testing APIs are still experimental.</p>
			<ol>
				<li value="4">Next up, make sure that all the code from within the body of the <strong class="source-inline">initialState_isProduced()</strong> test method is run inside a test-specific coroutine. To do that, launch a<a id="_idIndexMarker821"/> coroutine that wraps this method's body by calling the <strong class="source-inline">runTest()</strong> coroutine builder on our <strong class="source-inline">scope</strong> variable of type <strong class="source-inline">TestScope</strong>:<p class="source-code">@Test</p><p class="source-code">fun initialState_isProduced()<strong class="bold"> = scope.runTest {</strong></p><p class="source-code">    val viewModel = getViewModel()</p><p class="source-code"><strong class="bold">    </strong>val initialState = viewModel.state.value</p><p class="source-code">    assert(</p><p class="source-code">        initialState == RestaurantsScreenState(</p><p class="source-code">            restaurants = emptyList(),</p><p class="source-code">            isLoading = true,</p><p class="source-code">            error = null))</p><p class="source-code"><strong class="bold">}</strong></p></li>
				<li>Run the <strong class="source-inline">RestaurantsViewModelTest</strong> class. If you switch to the <strong class="bold">Run</strong> tab, you will see that our test has failed again, with the same exception as before. Since we wrapped the body<a id="_idIndexMarker822"/> of our test method inside a test coroutine, our test code still throws an exception, telling us that we still need to<a id="_idIndexMarker823"/> change the dispatcher of the coroutine.</li>
			</ol>
			<p>If we have another look at <strong class="source-inline">RestaurantsViewModel</strong>, we can note that both the coroutines launched with <strong class="source-inline">viewModelScope</strong> have no dispatcher set, so they're using <strong class="source-inline">Dispatchers.Main</strong> behind the scenes:</p>
			<p class="source-code">@HiltViewModel</p>
			<p class="source-code">class RestaurantsViewModel @Inject constructor(...) : […] {</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    fun toggleFavorite(itemId: Int, oldValue: Boolean) {</p>
			<p class="source-code">        viewModelScope.launch(errorHandler) { ... }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private fun getRestaurants() {</p>
			<p class="source-code">        viewModelScope.launch(errorHandler) { ... }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>However, in our test, all coroutines that are launched should use <strong class="source-inline">StandardTestDispatcher</strong> defined in our test class. So, how can we pass a test dispatcher to the coroutines launched in our <strong class="source-inline">RestaurantsViewModel</strong>?</p>
			<p>We can inject the dispatcher inside the <strong class="source-inline">RestaurantsViewModel</strong> class by using its constructor and making it accept a <strong class="source-inline">CoroutineDispatcher</strong> object, which will be passed to all the coroutines that are launched.</p>
			<p>This way, in our<a id="_idIndexMarker824"/> production code, <strong class="source-inline">RestaurantsViewModel</strong> will receive and use the <strong class="source-inline">Dispatchers.Main</strong> dispatcher, and inside our test code, it will receive and use the <strong class="source-inline">StandardTestDispatcher</strong> dispatcher.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The practice of injecting dispatchers into our coroutine-based classes is encouraged, as it allows us to have better isolation and control over the testing environment of our unit tests.</p>
			<ol>
				<li value="6">Head back inside the main source set where our production code resides. Inside <strong class="source-inline">RestaurantsViewModel</strong>, add a <strong class="source-inline">dispatcher</strong> constructor parameter of type <strong class="source-inline">CoroutineDispatcher</strong> and pass it to the <strong class="source-inline">viewModelScope()</strong> calls:<p class="source-code">@HiltViewModel</p><p class="source-code">class RestaurantsViewModel @Inject constructor(</p><p class="source-code">   private val getRestaurantsUseCase: […],</p><p class="source-code">   private val toggleRestaurantsUseCase: […],</p><p class="source-code">   <strong class="bold">private val dispatcher: CoroutineDispatcher</strong>) :  </p><p class="source-code"><strong class="bold">       </strong>ViewModel(){</p><p class="source-code">    [...]</p><p class="source-code">    fun toggleFavorite(itemId: Int, oldValue: Boolean) {</p><p class="source-code">        viewModelScope.launch(errorHandler </p><p class="source-code">            <strong class="bold">+ dispatcher</strong>) { … }</p><p class="source-code">    }</p><p class="source-code">    private fun getRestaurants() {</p><p class="source-code">        viewModelScope.launch(errorHandler </p><p class="source-code">            <strong class="bold">+ dispatcher</strong>) { … }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>However, if we build the project now, we will get an error because Hilt doesn't know how to provide an instance of <strong class="source-inline">CoroutineDispatcher</strong> to <strong class="source-inline">RestaurantsViewModel</strong>.</p>
			<p>To instruct Hilt on how to provide our <strong class="source-inline">ViewModel</strong> with the dispatcher it needs (that is, <strong class="source-inline">Dispatchers.Main</strong>), we must create a Hilt module.</p>
			<ol>
				<li value="7">Inside the <strong class="source-inline">di</strong> package, create a new class called <strong class="source-inline">DispatcherModule</strong> and add the following <a id="_idIndexMarker825"/>code that tells Hilt how to provide any <strong class="source-inline">CoroutineDispatcher</strong> dependencies with <strong class="source-inline">Dispatchers.Main</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">object DispatcherModule {</p><p class="source-code">    @Provides</p><p class="source-code">    fun providesMainDispatcher(): CoroutineDispatcher </p><p class="source-code">        = Dispatchers.Main</p><p class="source-code">}</p></li>
			</ol>
			<p>However, right now, Hilt will always provide <strong class="source-inline">Dispatchers.Main</strong> to any <strong class="source-inline">CoroutineDispatcher</strong> dependencies. What if we need later to obtain a dispatcher different<a id="_idIndexMarker826"/> than <strong class="source-inline">Dispatchers.Main</strong>? Let's see how we can prepare for that.</p>
			<ol>
				<li value="8">At the top of the body of <strong class="source-inline">DispatcherModule</strong>, define an annotation class called <strong class="source-inline">MainDispatcher</strong> annotated with the <strong class="source-inline">@Qualifier</strong> annotation:<p class="source-code"><strong class="bold">@Qualifier</strong></p><p class="source-code"><strong class="bold">@Retention(AnnotationRetention.BINARY)</strong></p><p class="source-code"><strong class="bold">annotation class MainDispatcher</strong></p><p class="source-code"> </p><p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">object DispatcherModule {…}</p></li>
			</ol>
			<p>The <strong class="source-inline">@Qualifier</strong> annotation<a id="_idIndexMarker827"/> allows us to provide different dispatchers to the <strong class="source-inline">CoroutineDispatcher</strong> dependencies. In our case, we defined that a <strong class="source-inline">@MainDispatcher</strong> annotation will provide the <strong class="source-inline">Dispatchers.Main</strong> dispatcher.</p>
			<ol>
				<li value="9">Add the <strong class="source-inline">@MainDispatcher</strong> annotation to the <strong class="source-inline">providesMainDispatcher()</strong> method so that Hilt will know what dispatcher to provide when such an annotation is used on a dependency:<p class="source-code">@Qualifier</p><p class="source-code">@Retention(AnnotationRetention.BINARY)</p><p class="source-code">annotation class MainDispatcher</p><p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">object DispatcherModule {</p><p class="source-code"><strong class="bold">    @MainDispatcher</strong></p><p class="source-code">    @Provides</p><p class="source-code">    fun providesMainDispatcher(): CoroutineDispatcher</p><p class="source-code">        = Dispatchers.Main</p><p class="source-code">}</p></li>
				<li>Then, inside <strong class="source-inline">RestaurantsViewModel</strong>, annotate the <strong class="source-inline">dispatcher</strong> parameter with the newly<a id="_idIndexMarker828"/> created <strong class="source-inline">@MainDispatcher</strong> annotation so that Hilt will provide us with the <strong class="source-inline">Dispatchers.Main</strong> dispatcher:<p class="source-code">@HiltViewModel</p><p class="source-code">class RestaurantsViewModel @Inject constructor(</p><p class="source-code">   private val getRestaurantsUseCase: […],</p><p class="source-code">   private val toggleRestaurantsUseCase: […],</p><p class="source-code">   <strong class="bold">@MainDispatcher</strong> private val dispatcher: </p><p class="source-code"><strong class="bold">       </strong>CoroutineDispatcher</p><p class="source-code">) : ViewModel() { ... }</p></li>
				<li>Now that the <strong class="source-inline">RestaurantsViewModel</strong> uses the <strong class="source-inline">Dispatcher.Main</strong> dispatcher in our<a id="_idIndexMarker829"/> production code, head back inside the <strong class="source-inline">test</strong> source set and inside the <strong class="source-inline">RestaurantsViewModelTest</strong> class, update its <strong class="source-inline">getViewModel()</strong> method by passing the <strong class="source-inline">dispatcher</strong> member field to the <strong class="source-inline">RestaurantsViewModel</strong> constructor call:<p class="source-code">@ExperimentalCoroutinesApi</p><p class="source-code">class RestaurantsViewModelTest {</p><p class="source-code">    private val dispatcher = StandardTestDispatcher()</p><p class="source-code">    private val scope = TestScope(dispatcher)</p><p class="source-code">    @Test</p><p class="source-code">    fun initialState_isProduced() = scope.runTest {…}</p><p class="source-code">    private fun getViewModel(): RestaurantsViewModel {</p><p class="source-code">        […]</p><p class="source-code">        return RestaurantsViewModel(</p><p class="source-code">            getInitialRestaurantsUseCase,</p><p class="source-code">            toggleRestaurantUseCase,</p><p class="source-code">            <strong class="bold">dispatcher</strong>)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, in our test code, <strong class="source-inline">RestaurantsViewModel</strong> will use the <strong class="source-inline">StandardTestDispatcher</strong> dispatcher <a id="_idIndexMarker830"/>for all the launched coroutines.</p>
			<ol>
				<li value="12">Now, run the <strong class="source-inline">RestaurantsViewModelTest</strong> class again. If you switch to the <strong class="bold">Run</strong> tab, you will see that<a id="_idIndexMarker831"/> our test has now passed:</li>
			</ol>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B17788_10_07.jpg" alt="Figure 10.7 – Observing how the test inside the RestaurantsViewModelTest class has succeeded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – Observing how the test inside the RestaurantsViewModelTest class has succeeded</p>
			<p>Since our test uses the <strong class="source-inline">runTest()</strong> coroutine builder, any <strong class="source-inline">delay()</strong> calls in our fake implementations are skipped, making our test run fast, in just a few hundred milliseconds.</p>
			<p>Now that we have tested<a id="_idIndexMarker832"/> whether our <strong class="source-inline">ViewModel</strong> produces a correct initial state, it's time to test the state that comes after this initial state – the state with content. This state is produced when the restaurants have arrived (from our data layer), so the <strong class="source-inline">isLoading</strong> field should be reset to <strong class="source-inline">false</strong>, while the <strong class="source-inline">restaurants</strong> field should contain a list of restaurants.</p>
			<ol>
				<li value="13">Add a new testing method inside <strong class="source-inline">RestaurantsViewModelTest</strong> called <strong class="source-inline">stateWithContent_isProduced()</strong> that asserts whether the state with restaurants is produced as expected:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_isProduced() = scope.runTest {</p><p class="source-code">    val testVM = getViewModel()</p><p class="source-code">    val currentState = testVM.state.value</p><p class="source-code">    assert(</p><p class="source-code">        currentState == RestaurantsScreenState(</p><p class="source-code">            restaurants = </p><p class="source-code">                   DummyContent.getDomainRestaurants(),</p><p class="source-code">            isLoading = false,</p><p class="source-code">            error = null)</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>Since the <strong class="source-inline">FakeApiService</strong> returns<a id="_idIndexMarker833"/> the dummy list of <strong class="source-inline">RemoteRestaurant</strong> from the <strong class="source-inline">DummyContent</strong> class, it's only natural that we're expecting to get the same content in <strong class="source-inline">ViewModel</strong> but in the shape of the <strong class="source-inline">Restaurant</strong> objects – so we're asserting that the <strong class="source-inline">restaurants</strong> field of <strong class="source-inline">currentState</strong> contains the restaurants from <strong class="source-inline">DummyContent</strong>.</p>
			<p>Unfortunately, if we run the <strong class="source-inline">RestaurantsViewModelTest</strong> class, the <strong class="source-inline">stateWithContent_isProduced()</strong> test will fail, telling us that <strong class="source-inline">currentState</strong> has the <strong class="source-inline">isLoading</strong> field's value of <strong class="source-inline">true</strong> and there are no restaurants inside the <strong class="source-inline">restaurants</strong> field.</p>
			<p>This issue makes sense <a id="_idIndexMarker834"/>because we're basically obtaining the initial state and expecting it to be the state with content, which, in fact, comes later on. Because there are several <strong class="source-inline">delay()</strong> calls in our <strong class="source-inline">FakeApiService</strong> and <strong class="source-inline">FakeRoomDao</strong> implementations, we must allow time to pass so that <strong class="source-inline">ViewModel</strong> produces the second state – the one with restaurants. But how can we do that?</p>
			<p>Inside a test, to immediately execute all pending tasks (such as the launched coroutine to get restaurants in our <strong class="source-inline">ViewModel</strong>) and to advance the virtual clock until after the last delay, we can call the <strong class="source-inline">advanceUntilIdle()</strong> function exposed<a id="_idIndexMarker835"/> by the coroutines test library.</p>
			<ol>
				<li value="14">Inside the <strong class="source-inline">stateWithContent_isProduced()</strong> test method, after <strong class="source-inline">RestaurantsViewModel</strong> is instantiated but before our assertion, add the <strong class="source-inline">advanceUntilIdle()</strong> method call:<p class="source-code">@Test</p><p class="source-code">fun stateWithContent_isProduced() = scope.runTest {</p><p class="source-code">    val testVM = getViewModel()</p><p class="source-code"><strong class="bold">    advanceUntilIdle()</strong></p><p class="source-code">    val currentState = testVM.state.value</p><p class="source-code">    assert(</p><p class="source-code">        currentState == RestaurantsScreenState(</p><p class="source-code">            restaurants = </p><p class="source-code">                DummyContent.getDomainRestaurants(),</p><p class="source-code">            isLoading = false,</p><p class="source-code">            error = null)</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>When we call <strong class="source-inline">advanceUntilIdle()</strong> inside our <strong class="source-inline">scope</strong> variable of type <strong class="source-inline">TestScope</strong>, we're advancing the virtual clock of <strong class="source-inline">TestCoroutineScheduler</strong> featured in the <strong class="source-inline">StandardTestDispatcher</strong> that we've initially passed to our <strong class="source-inline">scope</strong>.</p>
			<ol>
				<li value="15">Now, run the <strong class="source-inline">RestaurantsViewModelTest</strong> class again. If you switch to the <strong class="bold">Run</strong> tab, you will see that the <strong class="source-inline">stateWithContent_isProduced()</strong> test still failed.</li>
			</ol>
			<p>The main issue here is that while we're trying to advance the virtual clock of our test by leveraging the fact that our test instance of <strong class="source-inline">RestaurantsViewModel</strong> now launches its <a id="_idIndexMarker836"/>coroutines on the <strong class="source-inline">StandardTestDispatcher</strong> instance that we've passed to it, we have another class that is passing its own <strong class="source-inline">CoroutineDispatcher</strong>.</p>
			<p>If we have a closer look inside our <strong class="source-inline">RestaurantsRepository</strong>, we can see that it's passing a <a id="_idIndexMarker837"/>production-use <strong class="source-inline">Dispatchers.IO</strong> dispatcher to all its <strong class="source-inline">withContext()</strong> calls:</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">class RestaurantsRepository @Inject constructor(…) {</p>
			<p class="source-code">    suspend fun toggleFavoriteRestaurant(…) =</p>
			<p class="source-code">        withContext(<strong class="bold">Dispatchers.IO</strong>) {…}</p>
			<p class="source-code">    suspend fun getRestaurants() : List&lt;Restaurant&gt; {</p>
			<p class="source-code">        return withContext(<strong class="bold">Dispatchers.IO</strong>) {…}</p>
			<p class="source-code">    }</p>
			<p class="source-code">    suspend fun loadRestaurants() {</p>
			<p class="source-code">        return withContext(<strong class="bold">Dispatchers.IO</strong>) {…}</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private suspend fun refreshCache() {…}</p>
			<p class="source-code">}</p>
			<p>Because the <strong class="source-inline">RestaurantsRepository</strong> instance that our <strong class="source-inline">RestaurantsViewModel</strong> indirectly depends on uses the <strong class="source-inline">Dispatchers.IO</strong> dispatcher and not the <strong class="source-inline">StandardTestDispatcher</strong> one, the virtual clock of our test is not advanced as <a id="_idIndexMarker838"/>expected. Let's fix this issue by injecting the dispatcher in the <strong class="source-inline">RestaurantsRepository</strong>, just as we did for <strong class="source-inline">RestaurantsViewModel</strong>.</p>
			<ol>
				<li value="16">However, before performing<a id="_idIndexMarker839"/> the injection, we must first define a new type of <strong class="source-inline">CoroutineDispatcher</strong> that Hilt should know how to inject – the <strong class="source-inline">Dispatchers.IO</strong> dispatcher.</li>
			</ol>
			<p>Head inside the <strong class="source-inline">DispatchersModule</strong> class and, just as we did for the <strong class="source-inline">Dispatchers.Main</strong> dispatcher, instruct Hilt on how to provide us with the <strong class="source-inline">Dispatchers.IO</strong> dispatcher:</p>
			<p class="source-code">@Qualifier</p>
			<p class="source-code">@Retention(AnnotationRetention.BINARY)</p>
			<p class="source-code">annotation class MainDispatcher</p>
			<p class="source-code"><strong class="bold">@Qualifier</strong></p>
			<p class="source-code"><strong class="bold">@Retention(AnnotationRetention.BINARY)</strong></p>
			<p class="source-code"><strong class="bold">annotation class IoDispatcher                      </strong>   </p>
			<p class="source-code">@Module</p>
			<p class="source-code">@InstallIn(SingletonComponent::class)</p>
			<p class="source-code">object DispatcherModule {</p>
			<p class="source-code">    @MainDispatcher</p>
			<p class="source-code">    @Provides</p>
			<p class="source-code">    fun providesMainDispatcher(): CoroutineDispatcher =        </p>
			<p class="source-code"><strong class="bold">        </strong>Dispatchers.Main</p>
			<p class="source-code"><strong class="bold">    @IoDispatcher</strong></p>
			<p class="source-code"><strong class="bold">    @Provides</strong></p>
			<p class="source-code"><strong class="bold">    fun providesIoDispatcher(): CoroutineDispatcher = </strong></p>
			<p class="source-code"><strong class="bold">        Dispatchers.IO</strong></p>
			<p class="source-code">}</p>
			<ol>
				<li value="17">Head back inside the main <a id="_idIndexMarker840"/>source set where our production code resides. Inside the <strong class="source-inline">RestaurantsRepository</strong> class, inject <strong class="source-inline">CoroutineDispatcher</strong>, annotate it with the <strong class="source-inline">@IoDispatcher</strong> qualifier, and then <a id="_idIndexMarker841"/>pass the injected <strong class="source-inline">dispatcher</strong> to all the <strong class="source-inline">withContext()</strong> calls:<p class="source-code">@Singleton</p><p class="source-code">class RestaurantsRepository @Inject constructor(</p><p class="source-code">    private val restInterface: RestaurantsApiService,</p><p class="source-code">    private val restaurantsDao: RestaurantsDao,</p><p class="source-code"><strong class="bold">    @IoDispatcher private val dispatcher: </strong></p><p class="source-code"><strong class="bold">        CoroutineDispatcher</strong></p><p class="source-code">) {</p><p class="source-code">    suspend fun toggleFavoriteRestaurant(…) =  </p><p class="source-code">        withContext(<strong class="bold">dispatcher</strong>) {…}</p><p class="source-code">    suspend fun getRestaurants() : List&lt;Restaurant&gt; {</p><p class="source-code">        return withContext(<strong class="bold">dispatcher</strong>) {…}</p><p class="source-code">    }</p><p class="source-code">    suspend fun loadRestaurants() {</p><p class="source-code">        return withContext(<strong class="bold">dispatcher</strong>) {…}</p><p class="source-code">    }</p><p class="source-code">    private suspend fun refreshCache() {…}            }</p></li>
				<li>Then, heading back<a id="_idIndexMarker842"/> inside our <strong class="source-inline">test</strong> package, inside the <strong class="source-inline">RestaurantsViewModelTest</strong> class, update the <strong class="source-inline">getViewModel()</strong> method<a id="_idIndexMarker843"/> to pass our <strong class="source-inline">dispatcher</strong> field of type <strong class="source-inline">StandardTestDispatcher</strong> to the <strong class="source-inline">RestaurantsRepository</strong> constructor:<p class="source-code">private fun getViewModel(): RestaurantsViewModel {</p><p class="source-code">    val restaurantsRepository = RestaurantsRepository(</p><p class="source-code">        FakeApiService(), </p><p class="source-code">        FakeRoomDao(),</p><p class="source-code">        <strong class="bold">dispatcher</strong>)</p><p class="source-code">    […]</p><p class="source-code">    return RestaurantsViewModel(</p><p class="source-code">        getInitialRestaurantsUseCase,</p><p class="source-code">        toggleRestaurantUseCase,</p><p class="source-code">        dispatcher)</p><p class="source-code">}</p></li>
				<li>Now, run the <strong class="source-inline">RestaurantsViewModelTest</strong> class again. If you switch to the <strong class="bold">Run</strong> tab, you will see that both our tests have now passed.<p class="callout-heading">Assignment</p><p class="callout">Try testing on your own that <strong class="source-inline">RestaurantsViewModel</strong> is correctly producing an error state. As a tip, make sure to throw an instance of the <strong class="source-inline">Exception</strong> class inside <strong class="source-inline">FakeApiService</strong> but just for this specific test method where you're verifying the error state. To achieve that, you can configure a constructor parameter in <strong class="source-inline">FakeApiService</strong> so that it can throw an exception if needed.</p></li>
			</ol>
			<p>Now that we<a id="_idIndexMarker844"/> tested how <strong class="source-inline">RestaurantsViewModel</strong> is producing the UI state, let's briefly<a id="_idIndexMarker845"/> have a look at how we could test a business component.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor313"/>Testing the functionality of a UseCase class</h2>
			<p>Aside from unit-testing the <a id="_idIndexMarker846"/>presentation layer <a id="_idIndexMarker847"/>of our application, it's very important to also test the business rules present in the app. In our Restaurants app, the business logic is encapsulated in <strong class="source-inline">UseCase</strong> classes.</p>
			<p>Let's see say that we want to test <strong class="source-inline">ToggleRestaurantUseCase</strong>. Essentially, we want to make sure that when we execute this <strong class="source-inline">UseCase</strong> class for a specific restaurant, the business logic of negating the <strong class="source-inline">isFavorite</strong> field of the <strong class="source-inline">Restaurant</strong> is working.</p>
			<p>In other words, if one restaurant was not marked as favorite, after executing <strong class="source-inline">ToggleRestaurantUseCase</strong> for that specific restaurant, its <strong class="source-inline">isFavorite</strong> field should become <strong class="source-inline">true</strong>. While this business logic is indeed slim, in medium to large-sized applications, such business logic can become much more complex.</p>
			<p>Let's see how a unit test for <strong class="source-inline">ToggleRestaurantUseCase</strong> would look:</p>
			<p class="source-code">@ExperimentalCoroutinesApi</p>
			<p class="source-code">class ToggleRestaurantUseCaseTest {</p>
			<p class="source-code">    private val dispatcher = StandardTestDispatcher()</p>
			<p class="source-code">    private val scope = TestScope(dispatcher)</p>
			<p class="source-code">    @Test</p>
			<p class="source-code">    fun toggleRestaurant_IsUpdatingFavoriteField() = </p>
			<p class="source-code">            scope.runTest {</p>
			<p class="source-code">        // Setup useCase</p>
			<p class="source-code">        val restaurantsRepository = RestaurantsRepository(</p>
			<p class="source-code">            FakeApiService(),</p>
			<p class="source-code">            FakeRoomDao(),</p>
			<p class="source-code">            dispatcher)</p>
			<p class="source-code">        val getSortedRestaurantsUseCase = </p>
			<p class="source-code">            GetSortedRestaurantsUseCase(restaurantsRepository)</p>
			<p class="source-code">        val useCase = ToggleRestaurantUseCase(</p>
			<p class="source-code">            restaurantsRepository,</p>
			<p class="source-code">            getSortedRestaurantsUseCase)</p>
			<p class="source-code">        // Preload data</p>
			<p class="source-code">        restaurantsRepository.loadRestaurants()</p>
			<p class="source-code">        advanceUntilIdle()</p>
			<p class="source-code">        // Execute useCase</p>
			<p class="source-code">        val restaurants = DummyContent.getDomainRestaurants()</p>
			<p class="source-code">        val targetItem = restaurants[0]</p>
			<p class="source-code">        val isFavorite = targetItem.isFavorite</p>
			<p class="source-code">        val updatedRestaurants = useCase(</p>
			<p class="source-code">            targetItem.id, </p>
			<p class="source-code">            isFavorite</p>
			<p class="source-code">        )</p>
			<p class="source-code">        advanceUntilIdle()</p>
			<p class="source-code">        // Assertion</p>
			<p class="source-code">        restaurants[0] = targetItem.copy(isFavorite = </p>
			<p class="source-code">            !isFavorite)</p>
			<p class="source-code">        assert(updatedRestaurants == restaurants)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This unit test is<a id="_idIndexMarker848"/> similar to the ones we wrote for <strong class="source-inline">RestaurantsViewModel</strong> in the sense that it's also using <strong class="source-inline">StandardTestDispatcher</strong> and <strong class="source-inline">TestScope</strong>, simply because the <strong class="source-inline">invoke()</strong> operator of <strong class="source-inline">ToggleRestaurantUseCase</strong> is a <strong class="source-inline">suspending</strong> function.</p>
			<p>The structure of the test is split into three parts, delimited by the suggestive comments:</p>
			<ul>
				<li><strong class="bold">Setup</strong>: In this first <a id="_idIndexMarker849"/>phase, we have constructed a <strong class="source-inline">ToggleRestaurantUseCase</strong> instance and its<a id="_idIndexMarker850"/> direct and transitive dependencies, while passing our test dispatcher to the dependencies that need it.</li>
				<li><strong class="bold">Preload data</strong>: For <strong class="source-inline">ToggleRestaurantUseCase</strong> to be able to execute its business logic on a specific <a id="_idIndexMarker851"/>restaurant, we first had to make sure that our <strong class="source-inline">RestaurantsRepository</strong> instance had loaded the dummy restaurants. We then called <strong class="source-inline">advancedUntilIdle()</strong>, allowing any suspending (blocking) work related to obtaining and caching dummy restaurants to finish.</li>
				<li><strong class="bold">Execute Use Case</strong>: We defined the<a id="_idIndexMarker852"/> restaurant whose <strong class="source-inline">isFavorite</strong> field we want to toggle as <strong class="source-inline">targetItem</strong>, obtained its current <strong class="source-inline">isFavorite</strong> field value, and executed <strong class="source-inline">ToggleRestaurantUseCase</strong>, storing the resultant restaurants inside the <strong class="source-inline">updatedRestaurants</strong> variable. Since this operation refreshes and re-obtains the restaurants from the fake local database, we then called <strong class="source-inline">advancedUntilIdle()</strong>, allowing any suspending work to finish.</li>
				<li><strong class="bold">Assertion</strong>: We've<a id="_idIndexMarker853"/> first updated the dummy list we're expecting<a id="_idIndexMarker854"/> to be correct by manually toggling the first restaurant's <strong class="source-inline">isFavorite</strong> field. Finally, we asserted that the resultant <strong class="source-inline">updatedRestaurants</strong> list is the same as the one we would expect to be correct – that is, <strong class="source-inline">restaurants</strong>. </li>
			</ul>
			<p>If you run this test, it should pass.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">Try testing the behaviour of other Use Case classes such as <strong class="source-inline">GetSortedRestaurantsUseCase</strong> or even classes from the data layer such as <strong class="source-inline">RestaurantsRepository</strong>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor314"/>Summary</h1>
			<p>In this chapter, we first had a look at the benefits of testing and classified tests based on different aspects. Afterward, we took a shot at testing our Compose-based UI and learned how to write UI unit tests by leveraging the power of the semantics modifiers.</p>
			<p>Finally, we learned how to write regular – non-UI – unit tests in order to validate the core functionality of our application. In this part, we learned how to test our coroutine-based code and how important it is to inject the <strong class="source-inline">CoroutineDispatcher</strong> objects.</p>
			<p>In the next chapter, we're steering away from the architectural side of Android development, and we will be incorporating data pagination with the help of yet another interesting library called Jetpack Paging.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor315"/>Further reading</h1>
			<p>In this chapter, we've briefly covered the basics of UI and unit testing, so the core concepts taught here should give you a solid starting point. However, there are several other topics that you might need while you continue your testing adventure:</p>
			<ul>
				<li>For UI tests, we used semantics modifiers to identify UI elements from our node hierarchy. When testing Compose UI, you should also be aware of the merged and unmerged semantics tree. Learn more about this topic by reading the official docs: <a href="https://developer.android.com/jetpack/compose/semantics">https://developer.android.com/jetpack/compose/semantics</a>.</li>
				<li>With UI tests, we only scratched the surface in terms of testing APIs. Make sure to check out this official testing cheat sheet: <a href="https://developer.android.com/jetpack/compose/testing-cheatsheet">https://developer.android.com/jetpack/compose/testing-cheatsheet</a>.</li>
				<li>Our unit tests are based on the JUnit testing framework. To discover the power and flexibility of Junit, check out its official docs: <a href="https://junit.org/junit4/">https://junit.org/junit4/</a>.</li>
				<li>In your coroutine-based tests, apart from the <strong class="source-inline">advanceUntilIdle()</strong> API, you can also use the <strong class="source-inline">advancetimeBy()</strong> API to fast-forward the virtual clock of the test by a certain amount. Learn more about this function from the official Coroutines docs: <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html">https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html</a>.</li>
				<li>Your unit tests must be deterministic in the sense that every run of one test for the same revision of code should always yield the same result. Learn more about deterministic and non-deterministic tests from Martin Fowler: <a href="https://martinfowler.com/articles/nonDeterminism.html">https://martinfowler.com/articles/nonDeterminism.html</a>.</li>
			</ul>
		</div>
	</body></html>