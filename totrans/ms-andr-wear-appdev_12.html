<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Publishing Apps to Google Play</h1></div></div></div><div><blockquote class="blockquote"><p>
<em>"I always believe that the sky is the beginning of the limit."
                                                                           - MC Hammer</em>
</p></blockquote></div><p>Testing is an important precursor to the distribution of the app via Google Play store. In this chapter, we will provide an overview of the importance of testing our Android Wear app and the tooling available for it, as well as how to automate UI testing. We will conclude the chapter with step-by-step instructions on how to get the app ready for publishing.</p><div><div><div><div><h1 class="title"><a id="ch12lvl1sec73"/>Testing</h1></div></div></div><p>It does not take too long for any programmer to learn the hard and valuable lesson that testing code is as important as coding itself. Ignore that lesson and a QA team worth its salt will be sure to bring you to your knees. Testing all on its own is a topic that deserves a lot of attention. There are countless resources, including books, out there that will sell you on a wide array of testing methodologies and philosophies. <strong>Test-driven Development</strong> (<strong>TDD</strong>) is worth researching if you are new to testing.</p><p>However, all that is out of the scope of this book. In this chapter, we are more concerned about the testing tooling provided by the Android platform geared toward Wear development, as well as the test APIs that are at your disposal. Let's take a closer look at that in the sections that follow.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec69"/>The need for testing</h2></div></div></div><p>The single most compelling reason to test code, in general, is to catch regressions as early as possible in the application development life cycle. With every code change that is made, there is a possibility that it has impacted the way another area of the system works, often negatively. But by crafting well thought out (repeatable) tests for every isolated and smallest possible unit of code, we have a means to ensure that it continues to function as it is meant to. These unit tests are critical validation points that, through their failures, raise flags of code instability.</p><p>Since each piece of code is to be tested in isolation, it often becomes necessary to simulate the forces that are external to the unit of code in question. Mocking frameworks used in conjunction with unit tests make this easy; for example, mocking an external service that is called by the unit under test.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec70"/>Types of unit test</h2></div></div></div><p>Based on whether the unit of code runs independent of the Android platform, there are two types of tests, local tests and instrumented test:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Local tests</strong>: These tests are the unit tests that run on the local <strong>Java Virtual Machine</strong> (<strong>JVM</strong>). Any code run as a local test will run without any dependency on the Android system, or it will at the very least be able to simulate such a dependency through a mocking framework.<div><ul class="itemizedlist"><li class="listitem">The online documentation for the step-by-step instruction on unit tests can found at <a class="ulink" href="https://developer.android.com/training/testing/unit-testing/index.html">https://developer.android.com/training/testing/unit-testing/index.html</a>.</li></ul></div><p>
</p></li><li class="listitem"><strong>Instrumented tests</strong>: These tests, in contrast, run on an Android device or emulator and are the recommended approach to run unit tests that have Android dependencies that are too complex or involved to simulate using mocking frameworks. These tests provide ready access to instrumentation information, such as access to the global information about an application environment through the <code class="literal">android.content.Context</code> class.<div><ul class="itemizedlist"><li class="listitem">For step-by-step instructions on building instrumented tests, refer to the documentation at <a class="ulink" href="https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html">https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html</a>.</li></ul></div></li></ul></div><p>One difference that will jump out at you right away is that in your Android Studio project, the source files for local unit tests are stored in the <code class="literal">module-name/src/test/java</code> folder, while the source files for instrumented unit tests are stored in the <code class="literal">module-name/src/androidTest/java</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec71"/>Automating user interface tests</h2></div></div></div><p>For Wear apps in particular, there are certain aspects of development that need to be tested very carefully, and unit tests may not be sufficient in these cases. Complex UI interactions are one such example. Ideally, a human tester would be able to catch many of these issues, but it does not take long for that to prove inefficient in terms of time and cost, not to mention prone to human error and oversight.</p><p>By writing our UI tests to simulate human interaction, we can save time and increase confidence in the quality of our tests. Automated UI tests are coded in the same designated Android test folder as our instrumented unit tests, that is, the <code class="literal">module-name/src/androidTest/java</code> folder.</p><p>Code implemented in this folder is built by the Android plugin for Gradle and executed on the same device that the app is intended to run on. This lets us use UI testing frameworks to simulate user interactions on the target app. Furthermore, automated UI tests may span a single app or multiple apps.</p><p>Single app tests, using a UI testing framework such as <strong>Espresso</strong>, allow us to programmatically simulate user interactions such as entering a specific input on a specific activity. They also let us exercise the effects of user interactions on various activities of the app by letting us test that the correct UI output is rendered in response to a piece of user interaction.</p><p>Multi-app tests (also known as the cross-app functional tests), using a UI testing framework such as UI Automator, let us verify interactions between apps. For instance, if we wanted our test to launch (say) the calculator app and perform a calculation that will, in turn, be used to drive an input to a field in our app, <strong>UI Automator</strong> makes this possible.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec72"/>Test APIs</h2></div></div></div><p>Android tests are based on <strong>JUnit</strong>. We write our unit or integration test classes as JUnit 4 classes.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec16"/>JUnit</h3></div></div></div><p>JUnit is an instance of the <strong>xUnit</strong> architecture for unit testing frameworks. It offers a way to perform common setup, teardown, and assertion operations in our unit tests. A test class can contain one or more methods. Common JUnit annotations can be used to mark a method that performs setup work (the <code class="literal">@Before</code> class) or teardown work (the <code class="literal">@After</code> class) work. The <code class="literal">@Test</code> annotation marks a test method.</p><p>From within a JUnit test class, we can use the <code class="literal">AndroidJUnitRunner</code> test runner class to invoke the Espresso or UI Automator APIs to implement our user interactions and inter-app simulations.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec17"/>The AndroidJUnitRunner class</h3></div></div></div><p>The <code class="literal">AndroidJUnitRunner</code> class is a test runner that lets us run JUnit test classes on Android devices. The test runner loads our test package and our app to a device and then runs our tests and reports results. Apart from JUnit support, the <code class="literal">AndroidJUnitRunner</code> class includes the following features:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Access to instrumentation information</strong>: An <code class="literal">InstrumentationRegistry</code> class provides easy access to the instrumentation object, the target app's <code class="literal">Context</code> object, and the test app's <code class="literal">Context</code> object. This data becomes particularly useful when our tests use the UI Automator framework.</li><li class="listitem"><strong>Test filtering</strong>: In addition to standard annotations supported by JUnit 4, some Android-specific annotations are also available. The <code class="literal">@RequiresDevice</code> annotation specifies that the test should run only on physical devices (and not on emulators). The <code class="literal">@SdkSuppress</code> annotation keeps the test from running on an Android API level that is lower than a specified level; for example, the <code class="literal">@SDKSupress(minSdkVersion=18)</code> annotation will suppress tests on all API levels that are lower than 18.</li><li class="listitem"><strong>Test Sharding</strong>: The <code class="literal">AndroidJUnitRunner</code> class provides support to split a test suite into multiple shards thereby allowing the grouping of tests by any given shard (identifiable by an index number).</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec18"/>Espresso</h3></div></div></div><p>Espresso is a testing framework geared toward testing user flows within an app. It provides a set of APIs that let us craft tests that use the implementation details from the app that is being tested. Features include view and adapter matching, action APIs, and UI thread synchronization, each discussed briefly in the following sections.</p><div><div><div><div><h4 class="title"><a id="ch12lvl4sec0"/>View and Adapter matching</h4></div></div></div><p>The <code class="literal">Expresso.onView()</code> method gives us access to a specific UI component in the target app. The method searches the view hierarchy for a match and returns a View reference that meets the specified criteria (which is supplied as part of the matcher argument passed to the method). Consider the following example:</p><pre class="programlisting">onView(withId(R.id.my_button)); &#13;
</pre><p>The returned reference can then be used to perform user actions on it or test assertions against it.</p><p>While View matching lets you bring back a View reference, Adapter matching is useful when the target View is inside a layout that is subclassed from the <code class="literal">AdapterView</code> class. In this case, only a subset of the layout's views may be loaded in the current view hierarchy. The <code class="literal">Espresso.onData()</code> method can be used to access a target view element.</p></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec19"/>Action APIs</h3></div></div></div><p>Using the <code class="literal">android.support.test.espresso.action.ViewActions</code> API, we can perform user actions such as clicks, swipes, button presses, text entry, and hyperlinking.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec20"/>UI Automator</h3></div></div></div><p>Google's UI Automator provides a set of APIs that enables UI tests to interact with user apps and system apps. The UI Automator API lets us programmatically open the <strong>Settings</strong> menu or the app launcher on a test device. If the test code does not depend on the implementation details of the target app, then the UI Automator framework can be a good candidate for writing automated tests.</p><p>This framework includes the following components:</p><div><ul class="itemizedlist"><li class="listitem">The UI Automator viewer to inspect layout hierarchy and view properties of UI components that are visible in the device foreground. This tool is located in the <code class="literal">&lt;android-sdk&gt;/tools</code> directory.</li><li class="listitem">The <code class="literal">android.support.test.uiautomator.UiDevice</code> API to retrieve state information and perform operations on the device on which the target app is running. The <code class="literal">UiDevice</code> class supports operations such as changing the device rotation, pressing the back, home, or menu buttons; and taking a screenshot of the current view.<p>The following code snippet demonstrates how the <code class="literal">UiDevice</code> class can be used easily to simulate a short press on the home button:</p><pre class="programlisting">mDevice = UiDevice.getInstance(getInstrumentation()); &#13;
mDevice.pressHome(); &#13;
</pre></li><li class="listitem">The UI Automator APIs that support cross-app UI testing. These APIs let us capture and manipulate UI components across multiple apps.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec21"/>Monkey and monkeyrunner</h3></div></div></div><p>Monkey is a command-line tool that sends pseudorandom streams of gestures, keystrokes and touches to devices. It is run via the <strong>Android Debug Bridge</strong> (<strong>ADB</strong>) tool, and is primarily meant to stress test your app.</p><p>Monkeyrunner is an API and execution environment for test programmers coded in Python. It includes functions for connecting to a device, installing and uninstalling packages, taking screenshots, and so on. A monkeyrunner command-line tool is available to run programs that use the monkeyrunner API.</p><p>For a more in-depth look at these topics, as well as how to measure UI performance and automate UI performance tests, we should take a look at the online documentation on the developer's site (<a class="ulink" href="https://developer.android.com/training/testing/start/index.html">https://developer.android.com/training/testing/start/index.html</a>) as our primary reference.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec73"/>The human touch</h2></div></div></div><p>No matter how solid our automated testing strategy, we really haven't tested our app until we have used it. That is why it is paramount to set time aside in our development cycle to test out the various features of our app, as well as user interactions. Every UI implementation code path must be exercised. There is no substitute for visual verification when it comes to confirming that our screens render acceptably in both square and round watch faces.</p><p>There may also be valuable insights gained to help us improve the way our user interactions are implemented. We should leverage the material design concepts we covered in previous chapters and use them to our advantage as much as possible.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec74"/>App distribution</h1></div></div></div><p>In the previous section, we covered in some detail how to test our app. Testing is a prerequisite for distribution, and it would serve us well to familiarize ourselves with what differentiates a Wear app in terms of quality. Check out the article from the online documentation at <a class="ulink" href="https://developer.android.com/distribute/essentials/quality/wear.html">https://developer.android.com/distribute/essentials/quality/wear.html</a>, which serves as a reminder in this regard.</p><p>Once we have implemented our well-designed app and tested it as much as we can, we can start preparing to distribute it to potential users. That is the focus of this section to examine how to ready and distribute our Wear apps to users through Google Play.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec74"/>Packaging</h2></div></div></div><p>As we go through the process of building our release APKs using Android Studio, we find that two different APKs are generated, one for mobile and one for wearable.</p><p>Packaging a wearable app in Android Studio involves the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Replicate all permissions from the manifest file of the wearable app module to the manifest file of the handheld app module.</li><li class="listitem">Ensure that the wearable and handheld app modules have the same package name and version number.</li><li class="listitem">Specify a Gradle dependency in the handheld app's <code class="literal">build.gradle</code> file to the wearable app module.</li><li class="listitem">Navigate to <strong>Build</strong> | <strong>Generate Signed APK...</strong>.</li></ol><div></div><p>These steps are illustrated in the following screenshot:</p><p>
</p><div><img src="img/image00234.jpeg" alt="Packaging"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Pick a module to generate the APK for mobile or wear, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00235.jpeg" alt="Packaging"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Specify your release keystore by creating a new one or picking the one you already have available:</p><p>
</p><div><img src="img/image00236.jpeg" alt="Packaging"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Here, we create a new keystore path and sign our app using it:</p><p>
</p><div><img src="img/image00237.jpeg" alt="Packaging"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Specify a destination folder for the APK files and then click <strong>Finish</strong>, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00238.jpeg" alt="Packaging"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>We should now find the two APK files available in the folder we specified:</p><p>
</p><div><img src="img/image00239.jpeg" alt="Packaging"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec75"/>Publishing and opt-in</h2></div></div></div><p>Once we have built our APKs, run it through our tests for Wear app quality and determined that it is ready for release, we upload it to the <strong>Developer Console</strong>. This is the step during which we set up distribution options and update the store listing with any screenshots of our Wear app. A detailed launch checklist is available in the online documentation (<a class="ulink" href="https://developer.android.com/distribute/tools/launch-checklist.html">https://developer.android.com/distribute/tools/launch-checklist.html</a>), and it is recommended that you read it prior to publishing.</p><p>Once our app is ready for release, we may opt into Android Wear from the <em>Pricing and Distribution</em> section of the Developer Console. Opt-in implies that our app meets the Wear app quality criteria and is an affirmation that we want our app to be made more discoverable to Android Wear users through Google Play. Consider the following diagram depicting the process:</p><p>
</p><div><img src="img/image00240.jpeg" alt="Publishing and opt-in"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once we have opted in, we can publish our app as usual, at which stage Google Play submits our app for review against the <strong>Wear App Quality criteria</strong>. We are notified of the results once they become available. If the app is found to meet all the Wear App quality criteria, Google Play will proceed to make it more discoverable to Android Wear users.</p><p>If, however, the app is found to fall short, then an e-mail notification is sent to our developer account address with the areas highlighted requiring our attention. Once we address these issues, we can upload a new version of our app to the Developer Console to initiate another round of opt-in and review.</p><p>The <em>Pricing and Distribution</em> page in the <em>Android Wear</em> section of the <strong>Google Play Developer Console</strong> holds the review and approval status of our app at any given time.</p><p>We click on the <strong>Add new application</strong> button, as shown in the following screenshot, to upload our app:</p><p>
</p><div><img src="img/image00241.jpeg" alt="Publishing and opt-in"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>We specify a default language and a title before proceeding to upload the APK:</p><p>
</p><div><img src="img/image00242.jpeg" alt="Publishing and opt-in"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Choose the type of release, that is, <strong>Production</strong>, <strong>Beta</strong>, or <strong>Alpha Testing</strong> , and then click the relevant <strong>Upload</strong> button:</p><p>
</p><div><img src="img/image00243.jpeg" alt="Publishing and opt-in"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>We then pick our Wear (or mobile) APK file and attempt the upload, depicted in the following screenshot:</p><p>
</p><div><img src="img/image00244.jpeg" alt="Publishing and opt-in"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>At this point, we are prompted to fill in app metadata that is necessary for publishing:</p><p>
</p><div><img src="img/image00245.jpeg" alt="Publishing and opt-in"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>We can click on the <strong>Why can't I publish?</strong>  link in the top-right corner to display any items that are missing. Here is an example of all the items needed to publish the app. Once they are added, the app should be ready for publishing:</p><p>
</p><div><img src="img/image00246.jpeg" alt="Publishing and opt-in"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec75"/>Summary</h1></div></div></div><p>In this chapter, we introduced Android testing and distinguished between local unit tests and instrumented tests. We then summarized the tooling available for testing our wear apps in Android Studio before we took a brief look at how to accomplish automation with UI testing. We concluded with a discussion of the stages that must be traversed when preparing our apps for distribution via Google Play.</p></div></body></html>