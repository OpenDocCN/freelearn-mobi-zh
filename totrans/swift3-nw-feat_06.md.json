["```swift\nlet scores = [0, 5, 6, 8, 9] \n         .flatMap{ [$0, $0 * 2] } \nprint(scores)  // [0, 0, 5, 10, 6, 12, 8, 16, 9, 18] \n\n```", "```swift\nlet oddSquared = [1, 2, 3, 4, 5, 10].flatMap { n in \n    n % 2 == 1 ? n*n : nil \n} \nprint(oddSquared) // [1, 9, 25] \n\n```", "```swift\nlet scores = [0, 5, 6, 8, 9] \n    .lazy \n    .flatMap{ [$0, $0 * 2] } // lazy assignment has not executed \n\nfor score in scores{  \n    print(score) \n} \n\n```", "```swift\nlet oddSquared = [1, 2, 3, 4, 5, 10] \n    .lazy               // lazy assignment but has not executed \n    .flatMap { n in \n    n % 2 == 1 ? n*n : nil \n} \n\nfor odd in oddSquared{ \n    print(odd) \n} \n\n```", "```swift\n[\"Jack\", \"Roger\", \"Rachel\", \"Joey\"].first { (name) -> Bool in\nname.contains(\"Ro\")\n} // =>returns Roger\n```", "```swift\npublic func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)> \n\npublic func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State> \n\npublic struct UnfoldSequence<Element, State> : Sequence, IteratorProtocol \n\n```", "```swift\n/// - Parameter first: The first element to be returned from the sequence. \n/// - Parameter next: A closure that accepts the previous sequence element and \n///   returns the next element. \n/// - Returns: A sequence that starts with `first` and continues with every \n///   value returned by passing the previous element to `next`. \n/// \nfunc sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)> \n\n```", "```swift\nlet mysequence = sequence(first: 1.1) { $0 < 2 ? $0 + 0.1 : nil } \nfor x in mysequence{ \n    print (x) \n} // 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 \n\n```", "```swift\n/// - Parameter state: The initial state that will be passed to the closure. \n/// - Parameter next: A closure that accepts an `inout` state and returns the \n///   next element of the sequence. \n/// - Returns: A sequence that yields each successive value from `next`. \n/// \npublic func sequence<T, State>(state: State, next: (inout State) -> T?) -> UnfoldSequence<T, State> \n\n```", "```swift\nclass Item{ \n    var parent: Item? \n    var name: String = \"\" \n} \n\n```", "```swift\nlet parent = Item() \nparent.name = \"parent\" \n\nlet child1 = Item() \nchild1.name = \"child1\" \nchild1.parent = parent \n\nlet child2 = Item() \nchild2.name = \"child2\" \nchild2.parent = child1 \n\n```", "```swift\nlet itemSeq = sequence(state: child2, next: { \n    (next: inout Item)->Item? in \n    let parent = next.parent \n    next = parent != nil ? parent! : next \n    return parent \n}) \n\nfor item in itemSeq{ \n    print(\"name: \\(item.name)\") \n} \n\n```", "```swift\nlet numbers = [10, 20, 30, 40, 50, 60] \nlet twoAheadIndex = numbers.index(numbers.startIndex, offsetBy: 2) \nprint(numbers[twoAheadIndex]) //=> 30   \n\n```", "```swift\npublic protocol Collection : Indexable, Sequence { ... } \n\n```", "```swift\nstruct MyCollection<T>: Collection{ \n    typealias Index = Int \n    var startIndex: Index \n    var endIndex: Index \n\n    var _collection: [T] \n\n    subscript(position: Index) -> T{ \n        return _collection[position] \n    } \n\n    func index(after i: Index) -> Index { \n        return i + 1 \n    } \n\n    init(){ \n        startIndex = 0 \n        endIndex = 0 \n        _collection = [] \n    } \n\n    mutating func add(item: T){ \n        _collection.append(item) \n    } \n} \n\nvar myCollection: MyCollection<String> = MyCollection() \nmyCollection.add(item: \"Harry\") \nmyCollection.add(item: \"William\") \nmyCollection[0] \n\n```", "```swift\nvar seed = 10 \nlet simpleAdderClosure = { (inout seed: Int)->Int in \n    seed += 1 \n    return seed * 10 \n} \n\nvar result = simpleAdderClosure(&seed)  //=> seed = 11; result = 110 \nprint(seed) // => 11 \n\n```", "```swift\nlet modifiedClosure = { (inout seed: Int)-> (Int)->Int in \n    return { (Int)-> Int in \n        seed += 1 \n        return seed * 10 \n    } \n} \n\nprint(seed)  //=> 11 \nvar resultFn = modifiedClosure(&seed) \nvar result = resultFn(1) \nprint(seed) // => 11 \n\n```", "```swift\nvar callbacks:[String : ()->String] = [:] \nfunc myEscapingFunction(name:String, callback:()->String){ \n    callbacks[name] = callback \n} \nmyEscapingFunction(\"cb1\", callback: {\"just another cb\"}) \nfor cb in callbacks{ \n    print(\"name: \\(cb.0) value: \\(cb.1())\")  \n} \n\n```", "```swift\nvar callbacks:[String : ()->String] = [:] \nfunc myEscapingFunction(name:String, callback: @escaping ()->String){ \n    callbacks[name] = callback \n} \nmyEscapingFunction(name:\"cb1\", callback: {\"just another cb\"}) \nfor cb in callbacks{ \n    print(\"name: \\(cb.0) value: \\(cb.1())\")  \n} \n\n```"]