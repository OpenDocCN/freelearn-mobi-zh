<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Mastering the Tool Chain"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Mastering the Tool Chain</h1></div></div></div><p>So far, we have taken a deep dive into the code and policies that drive SE for Android technologies, but the build system and tools are often overlooked. Mastering the tool chain will help you improve your development practices. In this chapter, we will look at all the components of the SE for Android build and how they work. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building specific targets</li><li class="listitem" style="list-style-type: disc">The sepolicy <code class="literal">Android.mk</code> file</li><li class="listitem" style="list-style-type: disc">Custom build policy configuration</li><li class="listitem" style="list-style-type: disc">Build tools:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">check_seapp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">insertkeys.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">checkpolicy</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">checkfc</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sepolicy-check</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sepolicy-analyze</code></li></ul></div></li></ul></div><div class="section" title="Building subcomponents – targets and projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec64"/>Building subcomponents – targets and projects</h1></div></div></div><p>So far, we<a id="id348" class="indexterm"/> have run some magical commands such as <code class="literal">mm</code>, <code class="literal">mmm</code>, and <code class="literal">make bootimage</code> to<a id="id349" class="indexterm"/> actually build various portions of the SE for Android code. Google officially describes some of these tools in the documents at <a class="ulink" href="https://source.android.com/source/building-running.html">https://source.android.com/source/building-running.html</a>, but most commands are not listed. Nonetheless, <a class="ulink" href="http://elinux.org/Android_Build_System">http://elinux.org/Android_Build_System</a> has a write up that is more comprehensive.</p><p>In Google's "building and running" documentation, they describe the target as the device, which is ultimately what you lunch for. When building Android, the <code class="literal">lunch</code> command sets up environment variables for the <code class="literal">make</code> command you execute later. It sets up the build system to output the correct configuration for the target device. This concept of a target is <span class="emphasis"><em>not</em></span> what will be discussed in this chapter. Instead, when <code class="literal">target</code> is mentioned herein, it means a specific <code class="literal">make</code> target. However, in the event of needing to mention the target device, the complete phrase "<code class="literal">target device</code>" will be used. While somewhat confusing, this terminology is standard and will be understood by engineers in the field.</p><p>We have<a id="id350" class="indexterm"/> issued <code class="literal">make</code> a few times, optionally providing a target as an argument <a id="id351" class="indexterm"/>and an option, for example the <code class="literal">-j16</code> option. Something like <code class="literal">make</code> or <code class="literal">make -j16</code> essentially builds all of Android. Optionally, you can specify a target or list of targets as command arguments. An example of this is when <code class="literal">boot.img</code> was built. The <code class="literal">boot.img</code> file can be built and rebuilt by specifying the <code class="literal">bootimage</code> target. The command we use for this purpose is <code class="literal">make bootimage</code>. It helps to expedite builds by rebuilding only the portions of the system that are needed. But what if you only need to rebuild a particular file? Perhaps, you only want to rebuild <code class="literal">sepolicy</code>. You can specify that as the target to build, as in <code class="literal">make sepolicy</code>. This leads to the question, "What about the other files such as <code class="literal">mac_permissions.xml</code>, <code class="literal">seapp_contexts</code>, and so on?" They can be built in the same way. The more intriguing question is, "How does one know what the target name is? Is it always the file output name?"</p><p>Android's build system is constructed on top of GNU <code class="literal">make</code> (<a class="ulink" href="http://www.gnu.org/software/make/">http://www.gnu.org/software/make/</a>). The core of the Android build system's makefiles system can be found in <code class="literal">build/core</code>, and the documentation can be found in the NDK (<a class="ulink" href="https://developer.android.com/tools/sdk/ndk/index.html">https://developer.android.com/tools/sdk/ndk/index.html</a>). The major take away from that reading is that a typical <code class="literal">Android.mk</code> file defines something called <code class="literal">LOCAL_MODULE := mymodulename</code>, and something called <code class="literal">mymodulename</code> is built. The target names are defined by these <code class="literal">LOCAL_MODULE</code> statements. Let's look at the <code class="literal">Android.mk</code> for external sepolicy, and focus on the sepolicy portion of it, as there are other local modules or targets defined in that <code class="literal">Makefile</code>. The following is an example from Android 4.3:</p><div class="informalexample"><pre class="programlisting">include $(CLEAR_VARS)
LOCAL_MODULE := sepolicy
LOCAL_MODULE_CLASS := ETC
LOCAL_MODULE_TAGS := optional
LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
...</pre></div><p>One can find all the modules for within an <code class="literal">Android.mk</code> file by just looking for lines that begin with <code class="literal">LOCAL_MODULE</code> declarations and are whole word matches:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -w '^LOCAL_MODULE' Android.mk</strong></span>
<span class="strong"><strong>LOCAL_MODULE := sepolicy</strong></span>
<span class="strong"><strong>LOCAL_MODULE := file_contexts</strong></span>
<span class="strong"><strong>LOCAL_MODULE := seapp_contexts</strong></span>
<span class="strong"><strong>LOCAL_MODULE := property_contexts</strong></span>
<span class="strong"><strong>LOCAL_MODULE := selinux-network.sh</strong></span>
<span class="strong"><strong>LOCAL_MODULE := mac_permissions.xml</strong></span>
<span class="strong"><strong>LOCAL_MODULE := eops.xml</strong></span>
</pre></div><p>Regular expressions dictate that ^ is the beginning of the line, and the <code class="literal">grep</code> man page states that <code class="literal">-w</code> provides whole word search.</p><p>The <a id="id352" class="indexterm"/>preceding list is comprehensive for the version of Android we are <a id="id353" class="indexterm"/>using on the UDOO. However, you should run the command on your exact version of the <code class="literal">Makefile</code> to get an idea of what things can be built.</p><p>Android has some additional tools that are separate from building targets and get added to your environment when you use <code class="literal">source build/envsetup.sh</code>. These are <code class="literal">mm</code> and <code class="literal">mmm</code>. They both perform the same task, which is to build all the targets specified in an <code class="literal">Android.mk</code> file, however, differing that they do not build any of their dependencies. The two commands only differ in where they source the location of the <code class="literal">Android.mk</code> to scour for build targets. The <code class="literal">mm</code> command uses the current working directory, whereas <code class="literal">mmm</code> uses a supplied path. Also, a great option for either command is <code class="literal">-B</code>, which forces a rebuild. An engineer can save a lot of time by using the <code class="literal">mm(m)</code> commands over <code class="literal">make &lt;target&gt;</code>. The full <code class="literal">make</code> command wastes a lot of time figuring out the dependency tree, so executing <code class="literal">mmm path/to/project</code> on a previously built source tree (if you know that all your changes are within a project) can save a few minutes. However, since it doesn't build the dependencies, you'll need to ensure that they are already built and have no dependent changes.</p></div></div>
<div class="section" title="Exploring sepolicy's Android.mk"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec65"/>Exploring sepolicy's Android.mk</h1></div></div></div><p>The <a id="id354" class="indexterm"/>project located at <code class="literal">external/sepolicy</code> uses an <code class="literal">Android.mk</code> file, like any other Android project, to build their outputs. Let's dissect this file and see what it does.</p><div class="section" title="Building sepolicy"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec46"/>Building sepolicy</h2></div></div></div><p>We'll <a id="id355" class="indexterm"/>start in the middle by looking at the target<a id="id356" class="indexterm"/> for <code class="literal">sepolicy</code>. It starts off with fairly boilerplate <code class="literal">Android.mk</code> stuff:</p><div class="informalexample"><pre class="programlisting">...
include $(CLEAR_VARS)
LOCAL_MODULE := sepolicy
LOCAL_MODULE_CLASS := ETC
LOCAL_MODULE_TAGS := optional
LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
include $(BUILD_SYSTEM)/base_rules.mk
...</pre></div><p>The next portion is a bit more like standard <code class="literal">make</code>. It starts off by declaring a target file that gets built into the <code class="literal">intermediates</code> location. The <code class="literal">intermediates</code> location is defined by the Android build system. It then assigns the values of <code class="literal">MLS_SENS</code> and <code class="literal">MLS_CATS</code> to some<a id="id357" class="indexterm"/> local variables for later use. The last line is <a id="id358" class="indexterm"/>the most interesting. It uses a <code class="literal">make</code> function, called <code class="literal">build_policy</code>, and takes filenames as arguments:</p><div class="informalexample"><pre class="programlisting">...
sepolicy_policy.conf := $(intermediates)/policy.conf
$(sepolicy_policy.conf): PRIVATE_MLS_SENS := $(MLS_SENS)
$(sepolicy_policy.conf): PRIVATE_MLS_CATS := $(MLS_CATS)
$(sepolicy_policy.conf) : $(call build_policy, security_classes initial_sids access_vectors global_macros mls_macros mls policy_capabilities te_macros attributes bools *.te roles users initial_sid_contexts fs_use genfs_contexts port_contexts)
...</pre></div><p>Next, we define the recipe for building this intermediate target, <code class="literal">policy.conf</code>. The interesting bits of the recipe are the <code class="literal">m4</code> command and the <code class="literal">sed</code> command.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>For more information on <code class="literal">m4</code>, see <a class="ulink" href="http://www.gnu.org/software/m4/manual/m4.html">http://www.gnu.org/software/m4/manual/m4.html</a>, and for more information on <code class="literal">sed</code>, refer to <a class="ulink" href="https://www.gnu.org/software/sed/manual/sed.html">https://www.gnu.org/software/sed/manual/sed.html</a>.</p></div></div><p>SELinux policy files get processed using <code class="literal">m4</code>. <code class="literal">m4</code> is a macro processor language that is often used as a frontend to a compiler. The <code class="literal">m4</code> command takes some of the values such as <code class="literal">PRIVATE_MLS_SENS</code> and <code class="literal">PRIVATE_MLS_CATS</code> and passes them through as macro definitions. This is analogous to the <code class="literal">gcc -D</code> option. It then takes the dependencies for the target as input via the <code class="literal">make</code> expansion, <code class="literal">$^</code>, and outputs them to the target name using the <code class="literal">make</code> expansion of <code class="literal">$@</code>. It also takes that output and generates a <code class="literal">.dontaudit</code> version. That version has all of the <code class="literal">dontaudit</code> lines deleted from the policy file using <code class="literal">sed</code>. The MLS values tell SELinux how many categories and sensitivities to generate. These must be statically defined in the policy blob that is loaded into the kernel, as follows:</p><div class="informalexample"><pre class="programlisting">...
@mkdir -p $(dir $@)
$(hide) m4 -D mls_num_sens=$(PRIVATE_MLS_SENS) -D mls_num_cats=$(PRIVATE_MLS_CATS) -s $^ &gt; $@
$(hide) sed '/dontaudit/d' $@ &gt; $@.dontaudit
...</pre></div><p>The next portion defines the recipe for building the actual target, named from <code class="literal">LOCAL_MODULE_POLICY</code>, even if this is not obvious. <code class="literal">LOCAL_BUILT_MODULE</code> expands to the intermediate file to be built, <code class="literal">sepolicy</code> in this case. It finally gets copied by the Android build system as <code class="literal">LOCAL_INSTALLED_MODULE</code> behind the scenes. This target depends on the intermediate <code class="literal">policy.conf</code> file and on <code class="literal">checkpolicy</code>. It uses <code class="literal">checkpolicy</code> to transform the <code class="literal">m4</code> expanded <code class="literal">policy.conf</code> and <code class="literal">policy.conf.dontaudit</code> into two sepolicy files, <code class="literal">sepolicy</code> and <code class="literal">sepolicy.dontaudit</code>. The actual tool that is used to compile the SELinux statements in binary <a id="id359" class="indexterm"/>form to load to the kernel is <code class="literal">checkpolicy</code>, as follows:</p><div class="informalexample"><pre class="programlisting">...
$(LOCAL_BUILT_MODULE) : $(sepolicy_policy.conf) $(HOST_OUT_EXECUTABLES)/checkpolicy
@mkdir -p $(dir $@)
$(hide) $(HOST_OUT_EXECUTABLES)/checkpolicy -M -c $(POLICYVERS) -o $@ $&lt;
$(hide) $(HOST_OUT_EXECUTABLES)/checkpolicy -M -c $(POLICYVERS) -o $(dir $&lt;)/$(notdir $@).dontaudit $&lt;.dontaudit
...</pre></div><p>Finally, it <a id="id360" class="indexterm"/>ends by setting a local variable, <code class="literal">built_policy</code>, for use elsewhere within the <code class="literal">Android.mk</code> file, and clears <code class="literal">policy.conf</code> to avoid polluting the global namespace of <code class="literal">make</code>, as shown:</p><div class="informalexample"><pre class="programlisting">...
built_sepolicy := $(LOCAL_BUILT_MODULE)
sepolicy_policy.conf :=
...</pre></div><p>Additionally, building <code class="literal">sepolicy</code> also depends on the <code class="literal">POLICYVERS</code> variable, which is conditionally assigned a value of <code class="literal">26</code> if not set. This is the policy version number used by <code class="literal">checkpolicy</code>, and as we saw earlier in the book, we had to override this for our UDOO.</p></div><div class="section" title="Controlling the policy build"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec47"/>Controlling the policy build</h2></div></div></div><p>We saw<a id="id361" class="indexterm"/> that the <code class="literal">sepolicy</code> statement<a id="id362" class="indexterm"/> calls the <code class="literal">build_policy</code> function. We also see its use in that <code class="literal">Android.mk</code> file for building <code class="literal">sepolicy</code>, <code class="literal">file_contexts</code>, <code class="literal">seapp_contexts</code>, <code class="literal">property_contexts</code>, and <code class="literal">mac_permissions.xml</code>, so it reasons that it is fairly important. This function outputs a list of fully resolved paths used for policy files. The function takes as inputs a variable argument list of filenames and includes regular expression support (note <code class="literal">*.te</code> in the <code class="literal">build_policy</code> for target sepolicy). Internally, that function uses some magic to allow you to override or append to the current policy build without modifying the <code class="literal">external/sepolicy</code> directory directly. This is meant for OEMs and device builders to be able to augment policy to cover their specific devices.</p><p>When building a policy, you can set the following <code class="literal">make</code> variables, typically in the device's <code class="literal">Makefile</code>, to control the resulting build. The variables are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BOARD_SEPOLICY_DIRS</code>: This is the <a id="id363" class="indexterm"/>search path for potential policy files</li><li class="listitem" style="list-style-type: disc"><code class="literal">BOARD_SEPOLICY_UNION</code>: This is a <a id="id364" class="indexterm"/>policy file of name to append to all files with the same name</li><li class="listitem" style="list-style-type: disc"><code class="literal">BOARD_SEPOLICY_REPLACE</code>: This is<a id="id365" class="indexterm"/> a policy file used to override the base <code class="literal">external/sepolicy</code> policy file</li><li class="listitem" style="list-style-type: disc"><code class="literal">BOARD_SEPOLICY_IGNORE</code>: This is used <a id="id366" class="indexterm"/>to remove a particular policy file from the build, given a repository's relative path</li></ul></div><p>Using <a id="id367" class="indexterm"/>the UDOO as an example, the proper <a id="id368" class="indexterm"/>way to author a policy was never to modify <code class="literal">external/sepolicy</code> but to create a directory in <code class="literal">device/fsl/udoo/sepolicy</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir &lt;PATH&gt;</strong></span>
</pre></div><p>Then we modify the <code class="literal">BoardConfig.mk</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vim BoardConfig.mk</strong></span>
</pre></div><p>Next, we add the following lines:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_DIRS += device/fsl/udoo/sepolicy</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Be very careful with <code class="literal">+=</code> as opposed to <code class="literal">:=</code>. In large project trees, some of these variables may be set higher in the build tree by common <code class="literal">BoardConfigs</code>, and you could wipe out their settings. Typically, the safest bet is <code class="literal">+=</code>. For further details, see <span class="emphasis"><em>Variable Assignment</em></span> in the GNU make manual, at <a class="ulink" href="http://www.gnu.org/software/make/manual/make.html">http://www.gnu.org/software/make/manual/make.html</a>.</p></div></div><p>This will tell the <code class="literal">build_policy()</code> function in <code class="literal">Android.mk</code> to search not only <code class="literal">external/sepolicy</code> but also <code class="literal">device/fsl/udoo/sepolicy</code> for policy files.</p><p>Next, we can create a <code class="literal">file_contexts</code> file in this directory, and move our changes for labeling to this directory by creating a new <code class="literal">file_contexts</code> file in <code class="literal">device/fsl/udoo/sepolicy</code>.</p><p>After this, we need to instruct the build system to combine, or union, our <code class="literal">file_contexts</code> file with the one in <code class="literal">external/sepolicy</code>. We accomplish this by adding the following statement to the <code class="literal">BoardConfig.mk</code> file:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_UNION += file_contexts</pre></div><p>You can do this for any policy file, even custom files. It does a match on the filename by basename only (no directories). For instance, if you had a <code class="literal">watchdog.te</code> rules file you wanted to add to the base <code class="literal">watchdog.te</code> rules file, you could just add <code class="literal">watchdog.te</code>, as shown:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_UNION += file_contexts watchdog.te</pre></div><p>This produces a new <code class="literal">watchdog.te</code> file during the build that unions your new rules with the ones found in <code class="literal">external/sepolicy/watchdog.te</code>.</p><p>Also note that you add new files into the build with <code class="literal">BOARD_SEPOLICY_UNION</code>, so to add a <code class="literal">.te</code> file for a custom domain, such as <code class="literal">custom.te</code>, you could:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_UNION += file_contexts watchdog.te custom.te</pre></div><p>Let's say you want to override the <code class="literal">external/sepolicy watchdog.te</code> file with your own. You can add it to <code class="literal">BOARD_SEPOLICY_REPLACE</code>, as shown:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_REPLACE := watchdog.te</pre></div><p>Note <a id="id369" class="indexterm"/>that you can't replace a file that does<a id="id370" class="indexterm"/> not exist in the base policy. Also, you can't have the same file appear in <code class="literal">UNION</code> and <code class="literal">REPLACE</code>, as it's ambiguous. You can't have more than one specification of <code class="literal">BOARD_SEPOLICY_REPLACE</code> on the same policy file.</p><p>Suppose we have a hierarchical build occurring for two fictitious devices, device X and device Y. The two devices, device X and device Y, both inherit <code class="literal">BoardConfigCommon.mk</code> from device A. Device A is not a real device, but since X and Y share commonalities, the common bits are kept in device A.</p><p>Suppose the <code class="literal">BoardConfigCommon.mk</code> for device A contains these statements:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_DIRS += device/OEM/A
BOARD_SEPOLICY_UNION += file_contexts custom.te</pre></div><p>Suppose that device X's <code class="literal">BoardConfig.mk</code> contains:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_DIRS += device/OEM/X
BOARD_SEPOLICY_UNION += file_contexts custom.te</pre></div><p>Finally, suppose device Y's <code class="literal">BoardConfig.mk</code> contains:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_DIRS += device/OEM/Y
BOARD_SEPOLICY_UNION += file_contexts custom.te</pre></div><p>The resulting policy sets used to build device X and device Y are the following:</p><p>Device X policy set:</p><div class="informalexample"><pre class="programlisting">device/OEM/A/file_contexts
device/OEM/A/custom.te
device/OEM/X/file_contexts
device/OEM/X/custome.te
external/sepolicy/* (base policy files)</pre></div><p>Device Y also contains:</p><div class="informalexample"><pre class="programlisting">device/OEM/A/file_contexts
device/OEM/A/custom.te
device/OEM/Y/file_contexts
device/OEM/Y/custom.te
external/sepolicy/* (base policy files)</pre></div><p>In a common scenario, you might not want the resulting policy set for device Y to contain <code class="literal">device/OEM/A/custom.te</code>. This is a use case for <code class="literal">BOARD_SEPOLICY_IGNORE</code>. You can use this to filter out specific policy files. However, you have to be specific and use the repository's relative path. For example, in device Y's <code class="literal">BoardConfig.mk</code>:</p><div class="informalexample"><pre class="programlisting">BOARD_SEPOLICY_IGNORE += device/OEM/A/custom.te</pre></div><p>Now, when<a id="id371" class="indexterm"/> you build a policy for device Y, the policy <a id="id372" class="indexterm"/>set will not include that file. <code class="literal">BOARD_SEPOLICY_IGNORE</code> can also be used with <code class="literal">BOARD_SEPOLICY_REPLACE</code>, allowing multiple uses in the device hierarchy, but only one <code class="literal">BOARD_SEPOLICY_REPLACE</code> statement takes effect.</p></div><div class="section" title="Digging deeper into build_policy"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec48"/>Digging deeper into build_policy</h2></div></div></div><p>Now<a id="id373" class="indexterm"/> that we have seen how to use some new<a id="id374" class="indexterm"/> mechanisms to control the policy build, let's actually dissect where in the build process happens. As stated earlier, the policy build is controlled by the <code class="literal">Android.mk</code> file. We encountered calls to the <code class="literal">build_policy()</code> function earlier, and this is precisely where the magic happens with respect to all of the <code class="literal">BOARD_SEPOLICY_*</code> variables we set. Examining the <code class="literal">build_policy</code> function, we see references to the <code class="literal">sepolicy_replace_paths</code> variable, so let's start by looking at that variable.</p><p>The <code class="literal">sepolicy_replace_paths</code> variable begins life by getting evaluated when the <code class="literal">Makefile</code> is evaluated. In other words, it is executed unconditionally. The code starts off by looping over all the <code class="literal">BOARD_SEPOLICY_REPLACE</code> files and checks whether any are in <code class="literal">BOARD_SEPOLICY_UNION</code>. If one is found, an error is printed and the build fails, showing <code class="literal">Ambiguous request for sepolicy $(pf). Appears in both BOARD_SEPOLICY_REPLACE and BOARD_SEPOLICY_UNION</code>, where <code class="literal">$(pf)</code> is expanded to the offending policy file. After that, it expands the <code class="literal">BOARD_SEPOLICY_REPLACE</code> entries with those found on the search paths set by <code class="literal">BOARD_SEPOLICY_DIRS</code>, thus resulting in full relative paths from the root of the Android tree. Then it filters these entries against <code class="literal">BOARD_SEPOLICY_IGNORE</code>, dropping anything that should be ignored. It then ensures that only one file candidate for replacement is found. Otherwise, it issues the appropriate error message. Lastly, it ensures that the file exists in the <code class="literal">LOCAL_PATH</code> or base policy, and if none of the two is found, it issues an error message:</p><div class="informalexample"><pre class="programlisting">...
# Quick edge case error detection for BOARD_SEPOLICY_REPLACE.
# Builds the singular path for each replace file.
sepolicy_replace_paths :=
$(foreach pf, $(BOARD_SEPOLICY_REPLACE), \
  $(if $(filter $(pf), $(BOARD_SEPOLICY_UNION)), \
    $(error Ambiguous request for sepolicy $(pf). Appears in both \
      BOARD_SEPOLICY_REPLACE and BOARD_SEPOLICY_UNION), \
  ) \
  $(eval _paths := $(filter-out $(BOARD_SEPOLICY_IGNORE), \
  $(wildcard $(addsuffix /$(pf), $(BOARD_SEPOLICY_DIRS))))) \
  $(eval _occurrences := $(words $(_paths))) \
  $(if $(filter 0,$(_occurrences)), \
    $(error No sepolicy file found for $(pf) in $(BOARD_SEPOLICY_DIRS)), \
  ) \
  $(if $(filter 1, $(_occurrences)), \
    $(eval sepolicy_replace_paths += $(_paths)), \
    $(error Multiple occurrences of replace file $(pf) in $(_paths)) \
  ) \
  $(if $(filter 0, $(words $(wildcard $(addsuffix /$(pf), $(LOCAL_PATH))))), \
    $(error Specified the sepolicy file $(pf) in BOARD_SEPOLICY_REPLACE, \
      but none found in $(LOCAL_PATH)), \
  ) \
)</pre></div><p>After this, calls<a id="id375" class="indexterm"/> to build policy can use <code class="literal">replace_paths</code> as an expanded list of files that will be replaced during the build.</p><p>The<a id="id376" class="indexterm"/> arguments of the <code class="literal">build_policy</code> function are the filenames you wish to expand into their Android root-relative path names, using the power provided by the <code class="literal">BOARD_SEPOLICY_* </code>family of variables. For instance, a call to <code class="literal">$(build_policy, file_contexts)</code> in the context of our devices A, X, and Y would result in this:</p><div class="informalexample"><pre class="programlisting">device/OEM/A/file_contexts
device/OEM/Y/file_contexts</pre></div><p>The <code class="literal">build_policy</code> function is a bit tricky to read. Many nested function calls result in the deepest indents running first. However, like all code, we read it from top to bottom and left to right, so the explanation will begin there. The function starts by looping through all the files passed as arguments. It then expands them against the <code class="literal">BOARD_SEPOLICY_DIRS</code> once for replace and once for a union. The <code class="literal">sepolicy_replace_paths</code> variable is error checked to ensure a file does not appear in both locations, replace and union. For the replace path expansion, it checks whether the expanded path is in <code class="literal">sepolicy_replace_dirs</code>, and if it is, replaces it. For the union portion, it just expands them. The results of these expansions are then fed through a filter on <code class="literal">BOARD_SEPOLICY_IGNORE</code>, thus dropping any of the explicitly ignored paths:</p><div class="informalexample"><pre class="programlisting"># Builds paths for all requested policy files w.r.t
# both BOARD_SEPOLICY_REPLACE and BOARD_SEPOLICY_UNION
# product variables.
# $(1): the set of policy name paths to build
build_policy = $(foreach type, $(1), \
  $(filter-out $(BOARD_SEPOLICY_IGNORE), \
    $(foreach expanded_type, $(notdir $(wildcard $(addsuffix /$(type), $(LOCAL_PATH)))), \
      $(if $(filter $(expanded_type), $(BOARD_SEPOLICY_REPLACE)), \
        $(wildcard $(addsuffix $(expanded_type), $(sort $(dir $(sepolicy_replace_paths))))), \
        $(LOCAL_PATH)/$(expanded_type) \
      ) \
    ) \
    $(foreach union_policy, $(wildcard $(addsuffix /$(type), $(BOARD_SEPOLICY_DIRS))), \
      $(if $(filter $(notdir $(union_policy)), $(BOARD_SEPOLICY_UNION)), \
        $(union_policy), \
      ) \
    ) \
  ) \
)
...</pre></div></div><div class="section" title="Building mac_permissions.xml"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec49"/>Building mac_permissions.xml</h2></div></div></div><p>The <code class="literal">mac_permissions.xml</code> build is a bit tricky, as we saw in <a class="link" href="ch10.html" title="Chapter 10. Placing Applications in Domains">Chapter 10</a>, <span class="emphasis"><em>Placing Applications in Domains</em></span>. First, <code class="literal">mac_permissions.xml</code> can be used with all the <code class="literal">BOARD_SEPOLICY_*</code> variables introduced thus far. The end result is one XML file adhering to the rules<a id="id377" class="indexterm"/> of those variables. Additionally, the raw XML files are processed by a tool called <code class="literal">insertkeys.py</code>, located in <code class="literal">sepolicy/tools</code>. The <code class="literal">insertkeys.py</code> tool uses <code class="literal">keys.conf</code> to<a id="id378" class="indexterm"/> map tags in the XML file signature stanza with <code class="literal">.pem</code> files containing the certificate. The <code class="literal">keys.conf</code> file is also subject to use in <code class="literal">BOARD_SEPOLICY_*</code> variables. The build recipe first calls <code class="literal">build_policy</code> on <code class="literal">keys.conf</code> and uses <code class="literal">m4</code> to concatenate the results. Thus, <code class="literal">m4</code> declarations in <code class="literal">keys.conf</code> will be respected. However, this has not been used. The initial intention was to use the <code class="literal">m4 -s</code> sync lines so that you can follow the inclusion chain in the <code class="literal">keys.conf</code> file when concatenated by <code class="literal">m4</code> processing. On the other hand, sync lines are provided by <code class="literal">m4</code> when concatenating many files, and they provide commented lines adhering to the <code class="literal">#line NUM "FILE"'</code> lines. These are useful because <code class="literal">m4</code> takes multiple input files and combines them into a single, expanded output file. There will be sync lines indicating the beginning of each of those files, and they can help you track down issues. Continuing back to the <code class="literal">mac_permissions.xml</code> build, after expansion of <code class="literal">keys.conf</code> by <code class="literal">m4</code>, this file, along with all the <code class="literal">mac_permissions.xml</code> files from a call to <code class="literal">build_policy()</code> are finally fed to <code class="literal">insertkeys.py</code>. The <code class="literal">insertkeys.py</code> tool then uses the <code class="literal">keys.conf</code> file to replace all matching <code class="literal">signature=&lt;TAG&gt;</code> lines with an actual hex-encoded X509 from the PEM file, that is, <code class="literal">signature=308E3600</code>. Additionally, the <code class="literal">insertkeys.py</code> tool combines the XML files into one<a id="id379" class="indexterm"/> file, and strips whitespace and comments <a id="id380" class="indexterm"/>to reduce its size on disk. This has no build dependencies on the other major files such as <code class="literal">sepolicy</code>, <code class="literal">seapp_contexts</code>, <code class="literal">property_contexts</code>, and <code class="literal">mac_permissions.xml</code>.</p></div><div class="section" title="Building seapp_contexts"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec50"/>Building seapp_contexts</h2></div></div></div><p>The <code class="literal">seapp_contexts</code> file is also subject to all the <code class="literal">BOARD_SEPOLICY_*</code> variables. All of the <code class="literal">seapp_contexts</code> files<a id="id381" class="indexterm"/> from a resultant <a id="id382" class="indexterm"/>call to <code class="literal">build_policy()</code> are also fed through <code class="literal">m4 -s</code> to get a single <code class="literal">seapp_contexts</code> file that contains sync lines. Again, like <code class="literal">mac_permissions.xml</code> file's build of <code class="literal">keys.conf</code>, <code class="literal">m4</code> hasn't been used other than for the synclines. This resulting, concatenated <code class="literal">seapp_contexts</code> file is then fed into <code class="literal">check_seapp</code>. This tool is authored in the C programming language and built into an executable during the build. The source can be found in <code class="literal">tools/check_seapp</code>. This tool reads the <code class="literal">seapp_contexts</code> file and checks its syntax. It verifies that there are no invalid key value pairs, that <code class="literal">levelFrom</code> is a valid identifier, and that the type and domain fields are valid for a given <code class="literal">sepolicy</code>. This build is dependent on <code class="literal">sepolicy</code> for the strict type checking of domain and type fields against the policy file.</p></div><div class="section" title="Building file_contexts"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec51"/>Building file_contexts</h2></div></div></div><p>The <code class="literal">file_contexts</code> file is also subject to all of the <code class="literal">BOARD_SEPOLICY_*</code> variables. The resulting<a id="id383" class="indexterm"/> set is passed through <code class="literal">m4 -s</code>, and <a id="id384" class="indexterm"/>the single output is run through the <code class="literal">checkfc</code> tool. The <code class="literal">checkfc</code> tool checks the grammar and syntax of the file and also verifies that the types exist in the built <code class="literal">sepolicy</code>. Because of this, it is dependent on the <code class="literal">sepolicy</code> build.</p></div><div class="section" title="Building property_contexts"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec52"/>Building property_contexts</h2></div></div></div><p>The <code class="literal">property_contexts</code> behaves exactly like the <code class="literal">file_contexts</code> build, except that it checks<a id="id385" class="indexterm"/> a <code class="literal">property_contexts</code> file. It <a id="id386" class="indexterm"/>also uses <code class="literal">checkfc</code>.</p></div><div class="section" title="Current NSA research files"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec53"/>Current NSA research files</h2></div></div></div><p>Additionally, work<a id="id387" class="indexterm"/> on Enterprise Operations (<code class="literal">eops</code>) is already underway at the NSA. As this feature hasn't been merged into <a id="id388" class="indexterm"/>mainstream Android and is likely to change wildly, it won't be covered here. However, the best place for the bleeding edge is always the source and NSA Bitbucket repositories. The <code class="literal">selinux-network.sh</code> also falls under this category; it hasn't seen mainstream adoption yet, and will likely be dropped from AOSP (<a class="ulink" href="https://android-review.googlesource.com/#/c/114380/">https://android-review.googlesource.com/#/c/114380/</a>).</p></div></div>
<div class="section" title="Standalone tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec66"/>Standalone tools</h1></div></div></div><p>There are<a id="id389" class="indexterm"/> also some standalone tools built for Android policy evaluation that you may find useful. We will explore some of them and their usages. Most of the standard desktop tools you'll find in other references still work on SE for Android SELinux policy. Note that if you run any of the following tools and get a segmentation fault, you will likely need to apply the patch from the thread at <a class="ulink" href="http://marc.info/?l=seandroid-list&amp;m=141684060409894&amp;w=2">http://marc.info/?l=seandroid-list&amp;m=141684060409894&amp;w=2</a>.</p><div class="section" title="sepolicy-check"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec54"/>sepolicy-check</h2></div></div></div><p>This tool <a id="id390" class="indexterm"/>allows you to see whether a given allow rule <a id="id391" class="indexterm"/>exists in a policy file. The basic syntax of its command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sepolicy-check -s &lt;domain&gt; -t &lt;type&gt; -c &lt;class&gt; -p &lt;permission&gt; -P &lt;policy_file&gt;</strong></span>
</pre></div><p>For instance, if you want to see whether <code class="literal">system_app</code> can write to <code class="literal">system_data_file</code> for class file, you can execute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sepolicy-check -s system_app -t system_data_file -c file -p write -P $OUT/root/sepolicy</strong></span>
</pre></div></div><div class="section" title="sepolicy-analyze"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec55"/>sepolicy-analyze</h2></div></div></div><p>This is<a id="id392" class="indexterm"/> a good tool to check for common issues in <a id="id393" class="indexterm"/>SELinux development and it catches some of the common pitfalls of new SELinux policy writers. It can check for equivalent domains, duplicate allow rules. It can also perform policy type difference checks.</p><p>The domain equivalence check feature is very helpful. It shows you domains you may (in theory) want to be different, even though they converged in the implementation. These types would be ideal candidates to coalesce. However, it might have also shown an issue in the design of the policy that should be corrected. In other words, you didn't expect these domains to be equivalent. Invoking the command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sepolicy-analyze -e -P $OUT/root/sepolicy</strong></span>
</pre></div><p>The duplicate allow rule checks whether allow rules exist on types that also exist on attributes that the type inherits from. The allow rule on the specific type is a candidate for removal, since there is already an <code class="literal">allow</code> on the attribute. To execute this check, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$sepolicy-analyze -D -P $OUT/root/sepolicy</strong></span>
</pre></div><p>The difference is also handy is also handy to view type differences within a file. If you want to <a id="id394" class="indexterm"/>see what the difference between two domains is, you<a id="id395" class="indexterm"/> can use this feature. This is useful for identifying possible domains to coalesce. To perform this check, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$sepolicy-analyze -d -P $OUT/root/sepolicy</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec67"/>Summary</h1></div></div></div><p>In this chapter, we covered how the various components that control the policy on the device are actually built and created, such as <code class="literal">sepolicy</code> and <code class="literal">mac_permissions.xml</code>. This chapter also presented the <code class="literal">BOARD_SEPOLICY_*</code> variables used to manage and build a policy across devices and configurations. Then we reviewed the <code class="literal">Android.mk</code> components, detailing how the heart of the build and configuration management works.</p></div></body></html>