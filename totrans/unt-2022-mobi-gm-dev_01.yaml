- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start on our journey of building mobile games using the Unity game engine,
    it’s important that you are familiar with the engine itself before we dive into
    the specifics of building things for mobile platforms. Although there is a chance
    that you’ve already built a game and want to transition it to mobile, there will
    also be those of you who haven’t touched **Unity** before or may not have used
    it in a long time. This chapter will act as an introduction to newcomers and a
    refresher for those coming back, and it will provide some best practices for those
    who are already familiar with Unity. While you may skip this chapter if you’re
    already familiar with Unity, I think it’s also a good idea to go through the project
    so that you know the thought processes behind why the project is made in the way
    that it is, so that you can keep it in mind for your own future titles.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a 3D endless runner game in the same vein as
    *Imangi Studios LLC’s* *Temple Run* series. In our case, we will have a player
    who will run continuously in a certain direction and dodge the obstacles that
    are in their way. We can also add additional features to the game easily, as the
    game will endlessly have new things added to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be split into several topics. It will contain simple, step-by-step
    processes for you to follow. Here is an outline of our tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the player through a C# script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving scripts using attributes and XML comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update function versus FixedUpdate function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having the camera follow our player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic tile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the game endless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book utilizes *Unity 2022.1.0b14* and *Unity Hub 3.3.1*, but the steps
    should work with minimal changes in future versions of the editor. If you would
    like to download the exact version used in this book, and there is a new version
    out, you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the *Unity Editor system* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our goals in mind, let’s start building our project:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, open Unity Hub on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From startup, we’ll opt to create a new project by clicking on the **New** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, under `MobileDev`), and under **Templates**, make sure that **3D** is
    selected. Afterward, click on **CREATE** and wait for Unity to load up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Creating a 3D project](img/B18868_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Creating a 3D project
  prefs: []
  type: TYPE_NORMAL
- en: 'After it’s finished, you’ll see the Unity Editor pop up for the first time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.2 – The Unity Editor](img/B18868_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – The Unity Editor
  prefs: []
  type: TYPE_NORMAL
- en: 'If your layout doesn’t look the same as in the preceding screenshot, go to
    the top-right section of the toolbar and select the drop-down menu there that
    reads **Layout**. From there, select **Default** from the options presented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – The Layout button](img/B18868_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – The Layout button
  prefs: []
  type: TYPE_NORMAL
- en: We now have opened Unity for the first time and have the default layout displayed!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If this is your first time working with Unity, then I highly recommend that
    you read the *Unity’s interface* section of the *Unity Manual*, which you can
    access at [https://docs.unity3d.com/Manual/UsingTheEditor.html](https://docs.unity3d.com/Manual/UsingTheEditor.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Unity open, we can actually start building our project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we’ll build a player that will always move forward. Let’s start
    with that now:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we will create some ground for our player to walk on. To do
    that, go to the top menu and select **GameObject** | **3D Object** | **Cube**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From there, we’ll move over to the `Floor`. Then, for the `0`, `0`, `0`). This
    can be done by either typing the values in or right-clicking on the **Transform**
    component and then selecting the **Reset** **Position** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will set the `7`, `0.1`, `10`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Creating the ground](img/B18868_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Creating the ground
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, by default, `1` unit of space is representative of 1 meter in real
    life. So, our **Scale** values will make the floor longer than it is wide (**X**
    and **Z**), and we have some size on the ground (**Y**), so the player will collide
    and land on it because we have a **Box Collider** component attached to it by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **Box Collider** component is added automatically when creating a **Cube**
    object and is required to have objects collide with it. For more information on
    the **Box Collider** component, check out [https://docs.unity3d.com/Manual/class-BoxCollider.html](https://docs.unity3d.com/Manual/class-BoxCollider.html).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create our player, which will be a sphere. To do this, we will
    go to **GameObject** | **3D Object** | **Sphere**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename the sphere to `Player` and set the `0`, `1`, `-4`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Positioning the player](img/B18868_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Positioning the player
  prefs: []
  type: TYPE_NORMAL
- en: This places the ball slightly above the ground and shifts it back to near the
    starting point. Note that the camera object (see the camera icon) is pointing
    toward the ball by default because it is positioned at (`0`, `1`, `-10`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the ball to move, so we will need to tell the physics engine that we
    want to have this object react to forces, so we will need to add a **Rigidbody**
    component. To do so, with the **Player** object selected, go to the menu and select
    **Component** | **Physics** | **Rigidbody**. To see what happens now, let’s click
    on the **Play** button, which can be seen in the middle of the first toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Current state of the game](img/B18868_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: As in the preceding screenshot, you should see the ball fall down onto the ground
    when we play the game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can disable/enable having the **Game** tab take up the entire screen when
    being played by clicking on the **Maximize On Play** button at the top, or by
    right-clicking on the **Game** tab and then selecting **Maximize**.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Play** button again to turn the game off and go back to the **Scene**
    tab, if it doesn’t happen automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the objects for both the floor and the player in the game and have
    told the player to react to physics! Next, we will add interactivity to the player
    through the use of code.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the player through a C# script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want the player to move, so in order to do that, we will create our own
    piece of functionality in a script, effectively creating our own custom component
    in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a script, we will go to the **Project** window and select the **Create**
    button in the top-left corner of the menu by clicking on the **+** icon, and then
    we will select **Folder**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Location of the + icon](img/B18868_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Location of the + icon
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can also access the **Create** menu by right-clicking on the right-hand
    side of the **Project** window. With this method, you can right-click and then
    select **Create** | **Folder**.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we’ll name this folder `Scripts`. It’s always a good idea to organize
    our projects, so this will help with that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you happen to misspell the name of an item in the **Project** window, you
    can rename it by either right-clicking and selecting the **Rename** option or
    selecting the object and then single-clicking on the name.
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the folder to enter it, create a script by going to `PlayerBehaviour`
    (no spaces).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason I’m using the *behaviour* spelling instead of *behavior* is that
    all components in Unity are children of another class called `MonoBehaviour`,
    and I’m following Unity’s lead in that regard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the script to open up the script editor (IDE) of your choice
    and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have a couple of variables that we will be working
    with. The `rb` variable is a reference to the GameObject’s `Rigidbody` component
    that we added previously. It gives us the ability to make the object move, which
    we will use in the `Update` function. We also have two variables, `dodgeSpeed`
    and `rollSpeed`, which dictate how quickly the player will move when moving left/right
    or when moving forward, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Since our object has only one `Rigidbody` component, we assign `rb` once in
    the `Start` function, which is called when the GameObject is loaded into the scene
    at the beginning of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `Update` function to check whether our player is pressing keys
    to move left or right based on Unity’s `Input.GetAxis` function will return to
    us a negative value, moving to `-1` if we press *A* or the left arrow. If we press
    the right arrow or *D*, we will get a positive value up to `1` returned to us,
    and the input will move toward `0` if nothing is pressed. We then multiply this
    by `dodgeSpeed` in order to increase the speed so that the movement of the object
    is easier to see.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the Input Manager, check out [https://docs.unity3d.com/Manual/class-InputManager.html](https://docs.unity3d.com/Manual/class-InputManager.html).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once we have that value, we will apply a force to our ball’s `horizontalSpeed`
    units on the *X* axis and `rollSpeed` on the *Z* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Save your script and return to the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now need to assign this script to our player by selecting the `Player`
    object in the `PlayerBehaviour` script from the `Player` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that when writing scripts, if we declare a variable as `public`, it will
    show up in the `public` when we want designers to tweak the values for gameplay
    purposes, but it also allows other scripts to access the property in code. By
    default, variables and methods are `private`, which means they can only be used
    within the class. For more information on access modifiers, check out [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers).
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, we should see the script appear on our object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.8 – The PlayerBehaviour co\uFEFFmponent added](img/B18868_01_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – The PlayerBehaviour component added
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your scene by going to **File** | **Save**. Afterward, play the game and
    use the left and right arrows to see the player moving according to your input,
    but no matter what, moving forward by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.9 – The current state of the game](img/B18868_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see that the ball moves automatically, and our input is received
    correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Improving our scripts with attributes and XML comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could stop working with the `PlayerBehaviour` class script here, but I want
    to touch on a couple of things that we can use in order to improve the quality
    and style of our code. This becomes especially useful when you start building
    projects in teams. As you’ll be working with other people, some of them will be
    working on code with you. Then, there will be designers and artists who will not
    be working on code with you but will still need to use the things that you’ve
    programmed.
  prefs: []
  type: TYPE_NORMAL
- en: When writing scripts, we want them to be as error-proof as possible. Making
    the `rb` variable `private` starts that process, as now the user will not be able
    to modify that anywhere outside of this class. We want our teammates to modify
    `dodgeSpeed` and `rollSpeed`, but we may want to give them some advice as to what
    it is and/or how it will be used. To do this in the **Inspector** window, we can
    make use of something called an **attribute**.
  prefs: []
  type: TYPE_NORMAL
- en: Using attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes are things we can add to the beginning of a variable, class, or function
    declaration, which allow us to attach additional functionality to them. There
    are many of them that exist inside Unity, and you can write your very own attributes
    as well, but right now, we’ll talk about the ones that I use most often.
  prefs: []
  type: TYPE_NORMAL
- en: The Tooltip attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ve used Unity for a period of time, you may have noted that some components
    in the `Rigidbody`, have a nice feature—if you move your mouse over a variable
    name, you’ll see a description of what the variables are and/or how to use them.
    The first thing you’ll learn is how we can get the same effect in our own components
    by making use of the `Tooltip` attribute. If we do this for the `dodgeSpeed` and
    `rollSpeed` variables, it will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding script and return to the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Tooltip attribute example](img/B18868_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Tooltip attribute example
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we highlight the variable using the mouse and leave it there, the
    text we placed will be displayed. This is a great habit to get into, as your teammates
    can always tell what it is that your variables are being used for without having
    to actually look at the script itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the `Tooltip` attribute, check out [https://docs.unity3d.com/ScriptReference/TooltipAttribute.html](https://docs.unity3d.com/ScriptReference/TooltipAttribute.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Range attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another thing that we can use to protect our code is the `Range` attribute.
    This will allow us to specify a minimum and maximum value for a variable. Since
    we want the player to always be moving forward, we may want to restrict the player
    from moving backward. To do that, we can add the following highlighted line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script, and return to the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.11 – R\uFEFFange attribute example](img/B18868_01_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Range attribute example
  prefs: []
  type: TYPE_NORMAL
- en: We have now added a slider beside our value, and we can drag it to adjust between
    our minimum and maximum values. Not only does this protect our variable from being
    changed to an invalid state but also makes it so that our designers can tweak
    things easily by just dragging them around.
  prefs: []
  type: TYPE_NORMAL
- en: The RequireComponent attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, we are using the `Rigidbody` component in order to create our script.
    When working as a team member, others may not be reading your scripts but are
    still expected to use them when creating gameplay. Unfortunately, this means that
    they may do things that have unintended results, such as removing the `Rigidbody`
    component, which will cause errors when our script is run. Thankfully, we also
    have the `RequireComponent` attribute, which we can use to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By adding this attribute, we state that when we include this component in a
    GameObject and it doesn’t have a `Rigidbody` component attached to its GameObject,
    the component will be added automatically. It also makes it so that if we were
    to try to remove the `Rigidbody` component from this object, the editor will warn
    us that we can’t, unless we remove the `PlayerBehaviour` component first. Note
    that this works for any class extended from `MonoBehaviour`; just replace `Rigidbody`
    with whatever it is that you wish to keep.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we go into the Unity Editor and try to remove the `Rigidbody` component
    by right-clicking on it in **Inspector** and selecting **Remove Component**, the
    following message will be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Can’t remove component window](img/B18868_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Can’t remove component window
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what we want, and this ensures that the component will be there,
    allowing us not to have to include `if` checks every time we want to use a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, previously, we did not use a `Tooltip` attribute on the private
    `rb` variable. Since it’s not being displayed in the editor, it’s not really needed.
    However, there is a way that we can enhance that as well: using XML comments.'
  prefs: []
  type: TYPE_NORMAL
- en: XML comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can achieve a couple of nice things with XML comments that we otherwise couldn’t
    with traditional comments, which we were using previously. When using variables/functions
    instead of code in Visual Studio, we will now see a comment about it. This will
    help other coders on your team with additional information and details to ensure
    that they are using your code correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'XML comments look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It may appear that a lot more writing is needed to use this format, but I did
    not actually type the entire thing out. XML comments are a fairly standard C#
    feature, so if you are using MonoDevelop or Visual Studio and type `///`, the
    action will automatically generate the summary blocks for you (and the `param`
    tags needed, if there are parameters needed for something such as a function).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, why would we want to do this? Well, if you select the variable in IntelliSense,
    it will display the following information to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – An example of tooltips from XML comments](img/B18868_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – An example of tooltips from XML comments
  prefs: []
  type: TYPE_NORMAL
- en: This is a great help when other people are trying to use your code and it is
    how Unity’s staff write their code. We can also extend this to functions and classes
    to ensure that our code is more self-documented.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, XML comments do not show up in the Inspector, and the `Tooltip`
    attribute can’t be used for some aspects of projects such as functions. With that
    in mind, I use `Tooltip` for public instructions and/or things that will show
    up in the **Inspector** window and XML comments for everything else.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in looking into XML comments more, feel free to check out
    [https://msdn.microsoft.com/en-us/library/b2s063f7.aspx](https://msdn.microsoft.com/en-us/library/b2s063f7.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at ways of improving the formatting of our code; let’s
    look at how we can improve the performance by looking at some of the different
    `Update` functions Unity provides.
  prefs: []
  type: TYPE_NORMAL
- en: Update function versus FixedUpdate function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing to look at is our movement code. You may have noticed that we
    are currently using the `Update` function in order to move our player. As the
    comment above it states, the `Update` function is called once per frame that the
    game is running. One thing to consider is that the frequency of `Update` being
    called is variable, meaning that it can change over time. This is dependent on
    a number of factors, including the hardware that is being used. This means that
    the more times the `Update` function is called, the better the computer is. We
    want a consistent experience for all of our players, and one of the ways that
    we can do that is by using the `FixedUpdate` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`FixedUpdate` is similar to `Update` with some key differences. The first is
    that it is called at fixed timesteps, meaning the same time between calls. It’s
    also important to note that physics calculations are done after `FixedUpdate`
    is called. This means code-modifying physics-based objects should be executed
    within the `FixedUpdate` function generally, apart from one-off events such as
    jumping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By adjusting the code to use `FixedUpdate`, the ball should be much more consistent
    in its movement speed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `FixedUpdate`, check out [https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html).
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of the stuff we’ve been talking about, we can now have the final version
    of the script, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I hope that you also agree that this makes the code easier to understand and
    better to work with. Now, we can move on to additional features in the game!
  prefs: []
  type: TYPE_NORMAL
- en: Having the camera following our player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our camera stays in the same spot while the game is going on. This
    does not work very well for this game, as the player will be moving while the
    game is going on. There are two main ways that we can move our camera. We can
    just move the camera and make it a child of the player, but that will not work
    due to the fact that the camera would have the same rotation as the ball, which
    would cause the camera to spin around constantly and likely cause dizziness and
    disorientation for the players. Due to that, we will likely want to use a script
    to move it instead. Thankfully, we can modify how our camera looks at things fairly
    easily, so let’s go ahead and fix that next:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Project window and create a new C# script called `CameraBehaviour`.
    From there, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script will set the position of the object it is attached to to the position
    of a target with an offset. Afterward, it will change the rotation of the object
    to face the target. Both of the parameters are marked as `public`, so they can
    be tweaked in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and dive back into the Unity Editor. Select the `CameraBehaviour`
    component to it. You may do this by dragging and dropping the script from the
    **Project** window onto the GameObject or by clicking on the **Add Component**
    button at the bottom of the **Inspector** window, typing in the name of our component,
    and then hitting *Enter* to confirm once it is highlighted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Afterward, drag and drop the `Player` object from the **Hierarchy** window
    into the **Target** property of the script in the **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF.14 – CameraBehaviour component setup](img/B18868_01_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – CameraBehaviour component setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the scene and play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.15 – The current state of the game](img/B18868_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: The camera now follows the player as it moves. Feel free to tweak the variables
    and see how it affects the look of the camera to get the feeling you’d like best
    for the project. After this, we can have a place for the ball to move toward,
    which we will be covering in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic tile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want our game to be endless, but in order to achieve that, we will need
    to have pieces that we can spawn to build our environment; let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we will first need to create a single repeatable piece for our
    runner game. To do that, we’ll add some walls to the floor we already have. From
    the `Left Wall`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `1`, `2`, `10`). From there, select the **Move** tool by clicking
    on the button with arrows on the tools overlay or by pressing the *W* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A recent addition to Unity is the concept of **Overlays**, which have replaced
    the original toolbar. For more information about them and how to use them, check
    out [https://docs.unity3d.com/2022.1/Documentation/Manual/overlays.html](https://docs.unity3d.com/2022.1/Documentation/Manual/overlays.html).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Unity’s built-in shortcuts, check out [https://docs.unity3d.com/Manual/UnityHotkeys.html](https://docs.unity3d.com/Manual/UnityHotkeys.html).
  prefs: []
  type: TYPE_NORMAL
- en: We want this wall to match up with the floor, so hold down the *V* key to enter
    *Vertex Snap* mode. In Vertex Snap mode, we can select any of the vertices on
    a mesh and move them to the same position as another vertex on a different object.
    This is really useful for making sure that objects don’t have holes between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With Vertex Snap mode on, select the inner edge and drag it until it hits the
    edge of the floor. Alternatively, you can set the `3`, `0.95`, `0`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.16 – Left Wall setup](img/B18868_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.16 – Left Wall setup
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on moving objects through the scene, including more details
    on Vertex Snap mode, check out [https://docs.unity3d.com/Manual/PositioningGameObjects.html](https://docs.unity3d.com/Manual/PositioningGameObjects.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, duplicate this wall and put the other object on the other side (`-3`,
    `0.95`, `0`), naming it `Right Wall`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.17 – Right Wall setup](img/B18868_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.17 – Right Wall setup
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, we now protect the player from falling
    off the left and right edges of the play area. Due to how the walls are set up,
    if we move the `Floor` object, the walls will move as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For information on moving Unity’s camera or navigating to the **Scene** view,
    check out [https://docs.unity3d.com/Manual/SceneViewNavigation.html](https://docs.unity3d.com/Manual/SceneViewNavigation.html).
  prefs: []
  type: TYPE_NORMAL
- en: The way this game is designed, after the ball rolls past a single tile, we will
    no longer need it to be there anymore. If we just leave it there, the game will
    get slower over time due to us having so many things in the game environment using
    memory, so it’s a good idea to remove assets we are no longer using. We also need
    to have some way to figure out when we should spawn new tiles to continue the
    path the player can take.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we also want to know where this piece ends, so we’ll add an object with
    a trigger collider in it. Select `Tile End`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will add a `7`, `2`, `1`) to fit the size of the space the player
    can walk in. Note that there is a green box around that space showing where collisions
    can take place. Set the `0`, `1`, `10`) to reach past the end of our tile. Finally,
    check the **Is Trigger** property so that the collision engine will turn the collider
    into a trigger, which will be able to run code events when it is hit, but will
    not prevent the player from moving through it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.18 – Caption](img/B18868_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.18 – Caption
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned briefly before, this trigger will be used to tell the game that
    our player has finished walking over this tile. This is positioned past the tile
    due to the fact that we want to still see tiles until they pass what the camera
    can see. We’ll tell the engine to remove this tile from the game, but we will
    dive more into that later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all of the objects created, we want to group our objects together
    as one piece that we can create duplicates of. To do this, let’s create an empty
    GameObject instance by going to `Basic Tile`. Set the `0`, `0`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, go to the **Hierarchy** window and drag and drop the **Floor**, **Tile
    End**, **Left Wall**, and **Right Wall** objects on top of it to make them children
    of the **Basic** **Tile** object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Currently, the camera can see the start of the tiles, so to fix that, let’s
    set the `0`, `0`, `-5`). As you can see in the following screenshot, now the entire
    tile will shift back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Shifting the tile back](img/B18868_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19 – Shifting the tile back
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will need to know at what position we should spawn the next piece,
    so create another empty GameObject by going to `Next Spawn Point`, and set its
    `0`, `0`, `5`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we modify an object that has a parent, the position is relative
    to the parent, not its world position.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the spawn point position will now be on the edge of our current
    title:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Next Spawn Point position](img/B18868_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20 – Next Spawn Point position
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a single tile that is fully completed. Instead of duplicating this
    a number of times by hand, we will make use of Unity’s concept of **Prefabs**.
    Prefabs, or prefabricated objects, are blueprints of GameObjects and components
    that we can turn into files, which can be duplicated. There are other interesting
    features that Prefabs have, but we will discuss them as we make use of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `Prefabs`. Then, drag and drop the **Basic Tile** object from the
    **Hierarchy** window to the **Project** window inside the **Prefabs** folder.
    If the text for the **Basic Tile** name in the **Hierarchy** window becomes blue,
    we will know that it was made correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21 – Basic Tile Prefab created](img/B18868_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21 – Basic Tile Prefab created
  prefs: []
  type: TYPE_NORMAL
- en: We now have a tile prefab that we can create duplicates of through code to extend
    our environment.
  prefs: []
  type: TYPE_NORMAL
- en: Making it endless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a foundation, let’s make it so that we can continue running
    instead of stopping after a short time by spawning copies of this basic tile in
    front of each other:'
  prefs: []
  type: TYPE_NORMAL
- en: To start off with, we have our prefab, so we can delete the original **Basic
    Tile** in the **Hierarchy** window by selecting it and then pressing the *Delete*
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to have a place to create all of these tiles and potentially manage
    information for the game, such as the player’s score. In Unity, this is typically
    referred to as a `GameManager`. From the `GameManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script in your IDE and use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script will spawn a number of tiles, one after another, based on the `tile`
    and `initSpawnNum` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your script and dive back into Unity. From there, create a new `empty
    GameObject` and name it `Game Controller`, optionally resetting the position if
    wanted for organizational purposes. Drag and drop it at the top of the **Hierarchy**
    window. For clarity’s sake, go ahead and reset the position if you want to. Then,
    attach the **Game Manager** script to the object and then set the **Tile** property
    by dragging and dropping the **Basic Tile** prefab from the **Project** window
    into the **Tile** slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.22 – Assigning the Tile property](img/B18868_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.22 – Assigning the Tile property
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your scene and run the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.23 – The current state of the game](img/B18868_01_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.23 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: Great, but now we will need to create new objects after these, and we don’t
    want to spawn a crazy number of these at once. It’s better that once we reach
    the end of a tile, we create a new tile and remove it. We’ll work on optimizing
    this more later, but that way, we always have about the same number of tiles in
    the game at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the `TileEndBehaviour`, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to assign it to the prefab, we can go to the **Project** window and then
    go into the **Prefabs** folder. From there, double-click on the **Basic Tile**
    object to open up its editor. From the **Hierarchy** tab, select the **Tile End**
    object and then add a **Tile End Behaviour** component to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.24 – Adding the Tile End Behaviour](img/B18868_01_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.24 – Adding the Tile End Behaviour
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the left arrow next to the prefab name to return to the basic scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.25 – Left Arrow location](img/B18868_01_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.25 – Left Arrow location
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can also open the prefab editor by selecting a prefab object from the **Project**
    window, going to the **Inspector** tab, and clicking the **Open** **Prefab** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your scene and play. You’ll now note that as the player continues to move,
    new tiles will spawn as you go; if you switch to the **Scene** tab while playing,
    you’ll see that as the ball passes the tiles, they will destroy themselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Fig\uFEFFure 1.26 – Tiles automatically being destroyed](img/B18868_01_26.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 1.26 – Tiles automatically being destroyed
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure that there will be tiles in front of the player to visit! But
    of course, this is just an endless straight line. In the next section, we will
    see how to make the game much more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Creating obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s great that we have some basic tiles, but it’s a good idea to give the
    player something to do, or in our case, something to avoid. This will provide
    the player with some kind of challenge and a basic gameplay goal, which is avoiding
    obstacles here. In this section, you’ll learn how to customize your tiles to add
    obstacles for your player to avoid. So, let’s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Just like we created a prefab for our basic tile, we will create a single obstacle
    through code. I want to make it easy to see what the obstacle will look like in
    the world and make sure that it’s not too large, so I’ll drag and drop a **Basic
    Tile** prefab back into the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create a cube by going to `Obstacle`. Change the `2` and position
    it above the platform at (`0`, `1`, `0.25`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.27 – Adding obstacles](img/B18868_01_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.27 – Adding obstacles
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then play the game to see how that’ll work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.28 – Obstacles stop the player](img/B18868_01_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.28 – Obstacles stop the player
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, the player gets stopped, but nothing
    really happens. In this instance, we want the player to lose when they hit this
    obstacle and then restart the game; to do that, we’ll need to write a script.
    From the `ObstacleBehaviour`. We’ll use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and return to the editor, attaching the script to the `Obstacle`
    GameObject we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save your scene and try the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.29 – Obstacles destroy the player](img/B18868_01_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.29 – Obstacles destroy the player
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, once we hit the obstacle, the player
    gets destroyed, and then after a few seconds, the game starts up again. You’ll
    learn how to use particle systems and other things to polish this up, but at this
    point, it’s functional, which is what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know it works correctly, we can make it a prefab. Just as we did
    with the original tile, go ahead and drag and drop the **Obstacle** object from
    **Hierarchy** into the **Project** tab and into the **Prefabs** folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1.30 – Creating the Obstacle \uFEFFprefab](img/B18868_01_30.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 1.30 – Creating the Obstacle prefab
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will remove the **Obstacle** object, as we’ll spawn it upon creating
    the tile. To do so, select the **Obstacle** object in the **Hierarchy** window
    and then press the *Delete* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will make markers to indicate where we would possibly like to spawn our obstacles.
    Expand the `Next Spawn Point``0`, `1`, `4`). We will then rename the object `Center`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Afterward, to help see the objects within the **Scene** window, go to the **Inspector**
    window and click on the *gray cube* icon, and then on the **Select Icon** menu,
    select whichever of the color options you’d like (I went with blue). Upon doing
    this, you’ll see that we can see the text inside the editor if we are close to
    the object (but it won’t show up in the **Game** tab by default):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.31 – Creating a Center marker](img/B18868_01_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.31 – Creating a Center marker
  prefs: []
  type: TYPE_NORMAL
- en: 'We want a way to get all of the potential spawn points we will want in case
    we decide to extend the project in the future, so we will assign a tag as a reference
    to make those objects easier to find. To do that, at the top of the `ObstacleSpawn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.32 – Creating the ObstacleSpawn tag](img/B18868_01_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.32 – Creating the ObstacleSpawn tag
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back and select the **Center** object and assign the **Tag** property to
    **ObstacleSpawn**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.33 – Assigning the tag to the Center object](img/B18868_01_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.33 – Assigning the tag to the Center object
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on tags and why we’d want to use them, check out [https://docs.unity3d.com/Manual/Tags.html](https://docs.unity3d.com/Manual/Tags.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and duplicate this twice and name the others `Left` and `Right`, moving
    them two units to the left and right of the center to become other possible obstacle
    points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.34 – Creating the Left and Right markers](img/B18868_01_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.34 – Creating the Left and Right markers
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that these changes don’t affect the original prefab, by default; that’s
    why the objects are currently black text. To make this happen, select **Basic
    Tile**, and then in the **Inspector** window under the **Prefab** section, click
    on **Overrides** and select **Apply All**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 1.35 – Applying changes to the prefab](img/B18868_01_35.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 1.35 – Applying changes to the prefab
  prefs: []
  type: TYPE_NORMAL
- en: Now that the prefab is set up correctly, we can go ahead and remove it by selecting
    it in the **Hierarchy** window and pressing *Delete*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then need to go into the `GameManager` script and make some modifications.
    To start with, we will need to introduce some new variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first of these variables is a reference to the obstacle that we will be
    creating copies of. The second is a parameter of how many tiles should be spawned
    before spawning obstacles. This is to ensure that the player can see the obstacles
    before they need to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to modify the `SpawnNextTile` function in order to spawn obstacles
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we modified the `SpawnNextTile` function to now have a default parameter
    set to `true`, which will tell us whether we want to spawn obstacles or not. At
    the beginning of the game, we may not want the player to have to start dodging
    immediately, but we can tweak the value to increase or decrease the number we
    are using. Because it has a default value of `true`, the original version of calling
    this in the `Start` function will still work without an error, but we will be
    modifying it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we ask whether the value is `true` to call a function called `SpawnObstacle`,
    but that isn’t written yet. We will add that next, but first, we will be making
    use of the `List` class and we want to make sure that the compiler knows which
    `List` class we are referring to, so we need to add a `using` statement at the
    top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can write the `SpawnObstacle` function. Add the following function to
    the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, let’s update the `Start` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, as long as `i` is less than the value of `initNoObstacles`, it will not
    spawn a variable, effectively giving us a buffer of four tiles that can be adjusted
    by changing the `initNoObstacles` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script and go back to the Unity Editor. Then, assign the `Obstacle`
    variable of the **Game Manager (Script)** component in the **Inspector** window
    with the **Obstacle** prefab we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.36 – Assigning the Obstacle property](img/B18868_01_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.36 – Assigning the Obstacle property
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit hard to see things currently due to the default light settings, so
    let’s go to the **Hierarchy** window and select the **Directional Light** object.
    A directional light acts similar to how the Sun works on Earth, shining everywhere
    from a certain position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the default settings, the light is a bit too bright and the shadows are
    too dark by default, so in the `0.5` and then the `0.5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.37 – Adjusting the Directional Light](img/B18868_01_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.37 – Adjusting the Directional Light
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your scene and play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.38 – The current state of the game](img/B18868_01_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.38 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, we now have a number of obstacles
    for our player to avoid!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on directional lights and the other lighting types that
    Unity has, check out [https://unity3d.com/learn/tutorials/topics/graphics/light-types?playlist=17102](https://unity3d.com/learn/tutorials/topics/graphics/light-types?playlist=17102).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There you have it! A solid foundation – but just that, a foundation. However,
    that being said, we covered a lot of content in this chapter. We discussed how
    to create a new project in Unity, and we built a player that will move continuously,
    as well as take inputs to move horizontally. We then discussed how we can use
    Unity’s attributes and XML comments to improve our code quality and help us when
    working in teams. We also covered how to have a moving camera. We created a tile-based
    level design system where we created new tiles as the game continued, randomly
    spawning obstacles for the player to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will explore more that we can do to improve this project
    and polish it while changing it to make for the best experience possible on mobile
    platforms. However, before we get to that, we’ll actually need to figure out how
    to deploy our projects, which is what we will be working on in the next chapter.
  prefs: []
  type: TYPE_NORMAL
