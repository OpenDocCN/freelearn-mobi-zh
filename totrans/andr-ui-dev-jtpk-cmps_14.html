<html><head></head><body><div><div><h1 id="_idParaDest-140"><a id="_idTextAnchor174"/>Chapter 11: Conclusion and Next Steps</h1>
			<p>This book shows you how to write beautiful, fast, and maintainable Jetpack Compose apps. In Chapters 1 to 3, I introduced you to the fundamentals of Jetpack Compose, explained core techniques and principles, as well as important interfaces, classes, packages, and, of course, composable functions. Chapters 4 to 7 focused on building Compose UIs. You learned how to manage state and navigate to different screens. We also explored the ViewModel and Repository patterns. Chapters 8 to 10 covered advanced topics such as animation, interoperability, testing, and debugging.</p>
			<p>This final chapter is all about what you can do next. We'll investigate the near future of Jetpack Compose and explore neighboring platforms, because you can apply your Compose knowledge there, too. The main sections of this chapter are the following:</p>
			<ul>
				<li>Exploring the future</li>
				<li>Migrating to Material You</li>
				<li>Moving beyond Android</li>
			</ul>
			<p>We'll start by looking at the next version of Jetpack Compose, 1.1, which was not yet stable when this book went into production. This iteration will bring bug fixes, performance improvements, and new features, for example, <code>ExposedDropdownMenuBox()</code>, an exposed drop-down menu, and <code>NavigationRail()</code>. This vertical navigation bar is intended for foldables and large-screen devices.</p>
			<p>The second main section, <em class="italic">Migrating to Material You</em>, introduces you to Material 3 for Compose. This package contains <em class="italic">Material You</em>, the latest iteration of Google's beautiful design language, to Jetpack Compose apps. We'll look at some differences between Material 2 and Material 3, for example, the simplified typography and color schemes.</p>
			<p>The <em class="italic">Moving beyond Android</em> section shows you how to use your Jetpack Compose knowledge on other platforms, for example, desktop and the web. I will briefly explain how to bring one of my sample composable functions to desktop.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor175"/>Technical requirements</h1>
			<p>This chapter is based on the <code>ExposedDropdownMenuBoxDemo</code> and <code>NavigationRailDemo</code> samples. Please refer to the <em class="italic">Technical requirements</em> section in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, and how to get the repository accompanying this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_11">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_11</a>.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor176"/>Exploring the future</h1>
			<p>This book is based on Jetpack Compose 1.0, the first stable version of the library, which was released<a id="_idIndexMarker402"/> in July 2021. Just like all other Jetpack components, Google is constantly enhancing and updating Compose. At the time of finishing the manuscript, version 1.1 was<a id="_idIndexMarker403"/> in beta. When it becomes stable, I will update the repository accompanying this book to reflect the changes. You can find the latest version of the samples of this book at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose</a>.</p>
			<p>Jetpack Compose 1.1 will offer bug fixes, new functionality, and performance improvements. New features<a id="_idIndexMarker404"/> include the following:</p>
			<ul>
				<li>The Compose compiler will support older versions of the Compose runtime. This allows you to use the latest tooling while still targeting older Compose versions.</li>
				<li>Touch target sizing (UI elements may get extra spacing to make them more accessible).</li>
				<li><code>ImageVector</code> caching.</li>
				<li>Support for Android 12 stretch overscroll.</li>
			</ul>
			<p>Several previously experimental APIs (for example, <code>AnimatedVisibility</code>, <code>EnterTransition</code>, and <code>ExitTransition</code>) will become stable. Additionally, Jetpack Compose 1.1 will support newer versions of Kotlin. Unfortunately, you will also face some breaking changes. For example, lambdas in <code>EnterTransition</code> and <code>ExitTransition</code> factories may be moved to the last position in the parameter list.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor177"/>Showing exposed drop-down menus</h2>
			<p>There are also new Material UI elements. For example, <code>ExposedDropdownMenuBox()</code> shows an exposed drop-down menu, which displays the currently selected<a id="_idIndexMarker405"/> menu item above the list of options. The <code>ExposedDropdownMenuBoxDemo</code> sample illustrates the usage of the composable function (<em class="italic">Figure 11.1</em>).</p>
			<div><div><img src="img/B17505_11_1.jpg" alt="Figure 11.1 – The ExposedDropdownMenuBoxDemo sample&#13;&#10;" width="1146" height="575"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – The ExposedDropdownMenuBoxDemo sample</p>
			<p>Currently, <code>ExposedDropdownMenuBox()</code> is marked experimental. Therefore, you must add the <code>@ExperimentalMaterialApi</code> annotation:</p>
			<pre>@ExperimentalMaterialApi
@Composable
fun ExposedDropdownMenuBoxDemo() {
  val titles = List(3) { i -&gt;
    stringResource(id = R.string.item, i + 1)
  }
  var expanded by remember { mutableStateOf(false) }
  var selectedTxt by remember { mutableStateOf(titles[0]) }
  Box(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp),
    contentAlignment = Alignment.TopCenter
  ) {
    ...
  }
}</pre>
			<p><code>ExposedDropdownMenuBoxDemo()</code> puts <code>ExposedDropdownMenuBox()</code> in a <code>Box()</code> and horizontally centers the menu at the top. The menu items are stored in a list (<code>titles</code>). The <code>expanded</code> state reflects<a id="_idIndexMarker406"/> the visibility of the menu items. <code>selectedTxt</code> represents the currently selected text. Here's how they are used:</p>
			<pre>ExposedDropdownMenuBox(expanded = expanded,
  onExpandedChange = {
    expanded = !expanded
  }) {
  TextField(value = selectedTxt,
    onValueChange = { },
    readOnly = true,
    label = {
      Text(text = stringResource(id = R.string.label))
    },
    trailingIcon = {
      ExposedDropdownMenuDefaults.TrailingIcon(
        expanded = expanded
      )
    }
  )
  ExposedDropdownMenu(expanded = expanded,
    onDismissRequest = {
      expanded = false
    }) {
    for (title in titles) {
      DropdownMenuItem(onClick = {
        expanded = false
        selectedTxt = title
      }) {
        Text(text = title)
      }
    }
  }
}</pre>
			<p><code>ExposedDropdownMenuBox()</code> has two<a id="_idIndexMarker407"/> children, read-only <code>TextField()</code> and <code>ExposedDropdownMenu()</code>. The text field shows <code>selectedTxt</code>. As <code>readOnly</code> is set to <code>true</code>, the <code>onValueChange</code> block can be empty. <code>expanded</code> controls the trailing icon, which reflects the visibility of the menu items. The <code>onExpandedChange</code> lambda expression passed to <code>ExposedDropdownMenuBox()</code> is executed when the user clicks on the exposed drop-down menu. Usually, you will negate <code>expanded</code>.</p>
			<p><code>ExposedDropdownMenu()</code> has at least one <code>DropdownMenuItem()</code> as its content. Typically, you will want to hide the menu (<code>expanded = false</code>) and update the text field (<code>selectedTxt = title</code>). The <code>onDismissRequest</code> block passed to <code>ExposedDropdownMenu()</code> should also close the menu, but not update the text field.</p>
			<p>So, <code>ExposedDropdownMenuBox()</code> is a very compact way of showing a selection of items and allowing the user<a id="_idIndexMarker408"/> to choose one. In the following section, I show you another Material UI element that debuts in Compose 1.1. <code>NavigationRail()</code> presents top-level navigation destinations vertically.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor178"/>Using NavigationRail()</h2>
			<p>Compose offers several ways<a id="_idIndexMarker409"/> to navigate to top-level destinations within your app. For example, you can place a navigation bar at the bottom of the screen using <code>BottomNavigation()</code>. I show you how to use it in the <em class="italic">Adding navigation</em> section of <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>. Jetpack Compose 1.1 includes another UI element for top-level navigation. <code>NavigationRail()</code> implements the <strong class="bold">navigation rail</strong> interaction pattern, a vertical navigation bar especially for large screens such as tablets and open foldables.</p>
			<p>If the screen is not big enough, or the foldable is closed, a standard bottom navigation bar should be displayed instead. The <code>NavigationRailDemo</code> sample shows how to achieve this. In <em class="italic">Figure 11.2</em>, you can see the app in portrait mode.</p>
			<div><div><img src="img/B17505_11_2.jpg" alt="Figure 11.2 – The NavigationRailDemo sample in portrait mode&#13;&#10;" width="693" height="951"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – The NavigationRailDemo sample in portrait mode</p>
			<p>To continue, an elaborate approach would be to use the Jetpack <code>WindowManager</code> library, however this is beyond the scope of the book. Instead, we will use <code>NavigationRailDemo ( )</code> for the sake of simplicity, which determines whether the navigation rail should be used by simply comparing the current width of the screen with the minimum size (600 density-independent pixels):</p>
			<pre>@Composable
fun NavigationRailDemo() {
<strong class="bold">  val showNavigationRail =</strong>
<strong class="bold">          LocalConfiguration.current.screenWidthDp &gt;= 600</strong>
  val index = rememberSaveable { mutableStateOf(0) }
  Scaffold(topBar = {
    TopAppBar(title = {
      Text(text = stringResource(id = R.string.app_name))
    })
  },
    bottomBar = {
      <strong class="bold">if (!showNavigationRail)</strong>
        BottomBar(index)
    }) {
    Content(showNavigationRail, index)
  }
}</pre>
			<p><code>Scaffold()</code> receives bottom bars through the <code>bottomBar</code> lambda expression. If the navigation rail should not be shown (<code>showNavigationRail</code> is <code>false</code>), my <code>BottomBar()</code> composable is invoked. Otherwise, no bottom bar is added. The currently active screen is stored in a mutable <code>Int</code> state (<code>index</code>). It is passed to <code>BottomBar()</code> and <code>Content()</code>. Next, let's briefly revisit how <code>BottomNavigation()</code> works by looking at my <code>BottomBar()</code> composable:</p>
			<pre>@Composable
fun BottomBar(index: MutableState&lt;Int&gt;) {
  BottomNavigation {
    for (i in 0..2)
      BottomNavigationItem(selected = i == index.value,
        onClick = { index.value = i },
        icon = {
          Icon(
            painter = painterResource(id =
                R.drawable.ic_baseline_android_24),
            contentDescription = null
          )
        },
        label = {
          MyText(index = i)
        }
      )
  }
}</pre>
			<p>The content of <code>BottomNavigation()</code> consists of several <code>BottomNavigationItem()</code> elements with an icon, a label, and an <code>onClick</code> block. My implementation just updates the <code>index</code> state, which is also used inside <code>Content()</code>. This composable<a id="_idIndexMarker410"/> displays the navigation rail if needed, and the main content (screen), which is just a box with text centered inside:</p>
			<pre>@Composable
fun Content(showNavigationRail: Boolean, index:
   MutableState&lt;Int&gt;) {
  Row(
    modifier = Modifier.fillMaxSize()
  ) {
    if (showNavigationRail) {
      NavigationRail {
        for (i in 0..2)
          NavigationRailItem(selected = i == index.value,
            onClick = {
              index.value = i
            },
            icon = {
              Icon(
                painter = painterResource(id =
                    R.drawable.ic_baseline_android_24),
                contentDescription = null
              )
            },
            label = {
              MyText(index = i)
            })
      }
    }
    Box(
      modifier = Modifier
        .fillMaxSize()
        .background(color = MaterialTheme.colors.surface),
      contentAlignment = Alignment.Center
    ) {
      MyText(
        index = index.value,
        style = MaterialTheme.typography.h3
      )
    }
  }
}</pre>
			<p>The navigation rail and the screen are arranged horizontally in <code>Row()</code>. Like <code>BottomNavigation()</code>, <code>NavigationRail()</code> gets one or more child elements that represent the navigation<a id="_idIndexMarker411"/> destinations. The children (<code>NavigationRailItem()</code>) have a label, an icon, and an <code>onClick</code> block. <em class="italic">Figure 11.3</em> shows the <code>NavigationRailDemo</code> sample in landscape<a id="_idTextAnchor179"/><a id="_idTextAnchor180"/> mode.</p>
			<div><div><img src="img/B17505_11_3.jpg" alt="Figure 11.3 – The NavigationRailDemo sample in landscape mode&#13;&#10;" width="1441" height="674"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – The NavigationRailDemo sample in landscape mode</p>
			<p>While Jetpack Compose 1.1 will add some Material UI elements and polish the existing ones, it still implements <em class="italic">Material Design</em> as present in previous Android versions, including 11 (sometimes referred to as Material 2). <em class="italic">Material You</em>, which debuted with Android 12, will be available<a id="_idIndexMarker412"/> for Compose, too. However, it is not an in-place update of the existing packages but comes as a new library. In the following section, we look at Material 3 for Jetpack Compose, which was in early alpha at the time this chapter was written. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may be wondering what the difference between Material You and Material 3 is. I am referring<a id="_idIndexMarker413"/> to Material 3 as the latest version of the Material Design specification, whereas Material You<a id="_idIndexMarker414"/> is the implementation on Android 12.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor181"/>Migrating to Material You</h1>
			<p><strong class="bold">Material You</strong> is the latest iteration of Google's design language Material Design. It was announced<a id="_idIndexMarker415"/> during Google I/O 2021 and was first available on Pixel smartphones running Android 12. Eventually, it will be rolled out to other devices, form factors, and frameworks. Like its predecessors, Material You is based on typography, animation, and layers. But it emphasizes personalization: depending on the platform, <em class="italic">Material You</em> implementations may use color palettes derived from the system wallpaper.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor182"/>Looking at some differences between Material 2 and Material 3 for Compose</h2>
			<p>To use <em class="italic">Material You</em> in your Compose app, you must add an implementation dependency to <code>androidx.compose.material3:material3</code> in the module-level <code>build.gradle</code> file. The base package<a id="_idIndexMarker416"/> for composables, classes, and interfaces changes to <code>androidx.compose.material3</code>. If you want to migrate an existing Compose app to this new version, you at least need to change imports. Unfortunately, the names of quite a few composable functions will change, too. To get an idea of the differences, I have reimplemented <code>NavigationRailDemo</code> for <em class="italic">Material You</em>. The project is named <code>NavigationRailDemo_Material3</code>. This way, you can easily examine the changes by comparing important files.</p>
			<div><div><img src="img/B17505_11_4.jpg" alt="Figure 11.4 – The NavigationRailDemo_Material3 sample in landscape mode&#13;&#10;" width="1376" height="694"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – The NavigationRailDemo_Material3 sample in landscape mode</p>
			<p>Specifically, <code>TopAppBar()</code> needs to be<a id="_idIndexMarker417"/> replaced by <code>SmallTopAppBar()</code> or one of its bigger siblings, <code>MediumTopAppBar()</code> and <code>LargeTopAppBar()</code>. Other changes include the following:</p>
			<ul>
				<li><code>BottomNavigation()</code> will be generalized to <code>NavigationBar()</code>.</li>
				<li><code>BottomNavigationItem()</code> is now called <code>NavigationBarItem()</code>.</li>
				<li><code>NavigationRailItem()</code> remains unchanged.</li>
			</ul>
			<p>The last bullet point is interesting: as <code>NavigationRailItem()</code> elements very much resemble <code>NavigationBarItem()</code>, I wonder if these two may be generalized in the future.</p>
			<p>Several properties that control the visual representation of UI elements will change considerably. For example, Material colors belong to <code>MaterialTheme.colorScheme</code> instead of the former <code>MaterialTheme.colors</code>. For more information about colors in Material 3, please refer to<a id="_idIndexMarker418"/> the official documentation at <a href="https://m3.material.io/styles/color/dynamic-color/overview">https://m3.material.io/styles/color/dynamic-color/overview</a>.</p>
			<p>Styled texts may also require some adaptions because the members of the <code>Typography</code> class will be simplified. For example, instead of <code>h1</code>, <code>h2</code>, <code>h3</code>, and so on, you will use <code>headlineLarge</code>, <code>headlineMedium</code>, or <code>headlineSmall</code>.</p>
			<p>This concludes<a id="_idIndexMarker419"/> our brief look at the changes regarding Material 3 and the near future of Jetpack Compose. Did you know you can write Compose apps for the web and desktop, too? In the following section, we give it a try.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor183"/>Moving beyond Android</h1>
			<p>While Jetpack Compose is the new UI toolkit<a id="_idIndexMarker420"/> on Android, its underlying ideas and principles make it attractive<a id="_idIndexMarker421"/> for other platforms, too. Let's see why this is the case:</p>
			<ol>
				<li>The declarative approach was first implemented on the web.</li>
				<li>SwiftUI, Apple's implementation of a declarative UI framework, works well for iPhones, iPads, watches, and macOS devices.</li>
				<li>Jetpack Compose UI elements use Material Design, which is designed for different platforms, device categories, and form factors.</li>
			</ol>
			<p>Most importantly, core concepts such as state and composable functions are not Android-specific. Therefore, if someone provides the toolchain (for example, the Kotlin compiler and the Compose compiler), any platform capable of showing graphics <em class="italic">may</em> be able to execute Compose apps. Certainly, there is an awful lot of work to be done.</p>
			<p>For example, the Compose UI must be hosted <em class="italic">somewhere</em>. On Android, activities are used. On the web, this would be a browser window. And on desktop, it would be a window provided by some UI toolkit. Any other functionality (for example, network and file I/O, connectivity, memory management, threading) must be addressed by other libraries or frameworks.</p>
			<p>JetBrains, the inventor of Kotlin and IntelliJ, decided to tackle this. In recent years, the company gained a lot of experience in targeting multiple platforms and sharing code among them. For example, with <em class="italic">Kotlin Multiplatform Mobile</em> you can use a single code base<a id="_idIndexMarker422"/> for the business logic of iOS and Android apps. <em class="italic">Compose Multiplatform</em> aims to simplify<a id="_idIndexMarker423"/> and speed up the development of UIs for<a id="_idIndexMarker424"/> desktop and the web, and to share UI code<a id="_idIndexMarker425"/> among them and Android.</p>
			<p>In the following section, I will briefly show how to create a simple Compose for Desktop application using the IntelliJ IDE.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor184"/>Setting up a sample project</h2>
			<p>The easiest way to create<a id="_idIndexMarker426"/> a Compose for Desktop project<a id="_idIndexMarker427"/> is to use the project wizard of the IntelliJ IDE. This requires IntelliJ IDEA Community Edition or Ultimate Edition 2020.3 or later. Setting up<a id="_idIndexMarker428"/> IntelliJ is beyond the scope of this book and is not detailed here. <em class="italic">Figure 11.5</em> shows you how to fill in the project wizard dialog.</p>
			<div><div><img src="img/B17505_11_5.jpg" alt="Figure 11.5 – The IntelliJ project wizard&#13;&#10;" width="953" height="629"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – The IntelliJ project wizard</p>
			<p>JetBrains maintains a <em class="italic">Getting started with Compose Multiplatform</em> tutorial on GitHub at <a href="https://github.com/JetBrains/compose-jb/blob/master/tutorials/Getting_Started/README.md">https://github.com/JetBrains/compose-jb/blob/master/tutorials/Getting_Started/README.md</a>. Please refer to this for additional information.</p>
			<p>The project wizard<a id="_idIndexMarker429"/> adds a simple <code>Main.kt</code> file inside <code>src/main/kotlin</code>. You can run it from the <strong class="bold">Gradle</strong> tool<a id="_idIndexMarker430"/> window by double-clicking on <strong class="bold">Tasks</strong> | <strong class="bold">compose desktop</strong> | <strong class="bold">run</strong> (<em class="italic">Figure 11.6</em>).</p>
			<div><div><img src="img/B17505_11_6.jpg" alt="Figure 11.6 – The IntelliJ Gradle tool window&#13;&#10;" width="487" height="460"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – The IntelliJ Gradle tool window</p>
			<p>The source code<a id="_idIndexMarker431"/> contains a composable called <code>App()</code>. It is invoked from the <code>main()</code> function. Let's replace<a id="_idIndexMarker432"/> the body of <code>App()</code> with one of my samples, for example, <code>StateChangeDemo()</code> from <a href="B17505_08_ePub.xhtml#_idTextAnchor135"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with Animations</em>: </p>
			<pre>@Composable
@Preview
fun App() {
  var toggled by remember {
    mutableStateOf(false)
  }
  val color = if (toggled)
    Color.White
  else
    Color.Red
  Column(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Button(onClick = {
      toggled = !toggled
    }) {
      Text(text = "Toggle")
    }
    Box(
      modifier = Modifier
        .padding(top = 32.dp)
        .background(color = color)
        .size(128.dp)
    )
  }
}</pre>
			<p>Have you noticed that I changed one line? The original version uses the <code>stringResource()</code> composable. However, Android resources are not available on desktop so you must replace the invocation with something different. A simple workaround is to hardcode the text. Real-world applications may want to choose a mechanism that supports multiple languages. Compose for Desktop relies on the Java Virtual Machine, so you can use Java's internationalization support.</p>
			<p>The app running on macOS is shown in <em class="italic">Figure 11.7</em>.</p>
			<div><div><img src="img/B17505_11_7.jpg" alt="Figure 11.7 – A simple Compose for Desktop app&#13;&#10;" width="800" height="600"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – A simple Compose for Desktop app</p>
			<p>This concludes<a id="_idIndexMarker433"/> our brief look at Compose for Desktop<a id="_idIndexMarker434"/> and Compose Multiplatform. To learn more, please visit<a id="_idIndexMarker435"/> the product page at <a href="https://www.jetbrains.com/de-de/lp/compose-mpp/">https://www.jetbrains.com/de-de/lp/compose-mpp/</a>.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor185"/>Summary</h1>
			<p>In this final chapter, we looked at the near future of Jetpack Compose and glimpsed neighboring platforms. Jetpack Compose 1.1 will bring bug fixes, performance improvements, and new features, for example, <code>ExposedDropdownMenuBox()</code> and <code>NavigationRail()</code>. Two samples (<code>ExposedDropdownMenuBoxDemo</code> and <code>NavigationRailDemo</code>) show you how to use them.</p>
			<p>The second main section, <em class="italic">Migrating to Material You</em>, introduced you to Material 3 for Compose. This package brings <em class="italic">Material You</em>, the latest iteration of Google's beautiful design language, to Jetpack Compose apps. We looked at some differences between Material 2 and Material 3, for example, the simplified typography and color schemes.</p>
			<p><em class="italic">Moving beyond Android</em> showed you how to use your Jetpack Compose knowledge on another platform. I explained how to bring one of my sample composable functions to desktop.</p>
			<p>I sincerely hope you enjoyed reading this book. You now have a thorough understanding of the core principles of Jetpack Compose, as well as the important advantages over the traditional Android View system. Using a declarative approach makes writing great-looking apps easier than ever. I can't wait to see which beautiful ideas you are going to turn into code.</p>
		</div>
	</div></body></html>