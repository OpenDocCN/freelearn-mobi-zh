- en: Chapter 15. Swift Formatting and Style Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout my development experience, every time I learned a new programming
    language, there was usually some mention of how code for that language should
    be written and formatted. Early in my development career (which was a long time
    ago), these recommendations were very basic formatting recommendations, such as
    how to indent your code, or just having one statement per line. It really wasn't
    until the last 10 to 12 years that I started to see complex and detailed formatting
    and style guides for different programming languages. Today, you will be hard
    pressed to find a development shop with more than two or three developers who
    did not have style/formatting guides for each language that they use. Even companies
    that do not create their own style guides generally refer back to some standard
    guide published by other companies, such as Google, Oracle, or Microsoft. These
    style guides help teams to write consistent and easy-to-maintain code.
  prefs: []
  type: TYPE_NORMAL
- en: What is a programming style guide?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding styles are very personal and every developer has his or her own preferred
    style. These styles can vary from language to language, person to person, and
    also change over time. The personal nature of coding styles can make it difficult
    to have a consistent and readable code base when numerous individuals are contributing
    to the code.
  prefs: []
  type: TYPE_NORMAL
- en: While most developers might have their own preferred styles, the recommended
    or preferred style between languages can vary. As an example, in C#, when we name
    a method or function, it is preferred to use camel case with the first letter
    being capitalized. While in most languages, such as C, Objective-C, and Java,
    it is also recommended that we use camel case, but we should make the first letter
    lower case.
  prefs: []
  type: TYPE_NORMAL
- en: The best applications are coded properly, and by properly, we do not just mean
    that they function correctly but also that they are easy to maintain and the code
    is easy to read. It is hard for large projects and companies with a large number
    of developers to have code that is easy to maintain and read if every developer
    uses their own coding style. This is why companies and projects with multiple
    developers usually adopt programming style guides for each language that they
    use.
  prefs: []
  type: TYPE_NORMAL
- en: A programming style guide defines a set of rules and guidelines that a developer
    should follow while writing applications with a specific language within a project
    or company. These style guides can differ greatly between companies or projects
    and reflect how that company or project expects code to be written. These guides
    can also change over time. It is important to follow these style guides to maintain
    a consistent code base.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of developers do not like the idea of being told how they should write
    code, and claim that as long as their code functions correctly, why should it
    matter how they format their code. I link this to a basketball team. If all of
    the players come in believing that how they want to play is correct and believe
    that the team is better when they are doing their own thing, then that team is
    probably going to lose the majority of their games. It is impossible for a basketball
    team (or any sports team, for that matter) to win the majority of their games
    unless they are working together. It is up to the coach to make sure that everyone
    is working together and executing the same game plan, just like it is up to the
    team leader of the development project to make sure all the developers are writing
    code according to the adopted style guide.
  prefs: []
  type: TYPE_NORMAL
- en: Your style guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The style guide that we define in this book is just a guide. It reflects the
    author's opinion on how Swift code should be written and is meant to be a good
    starting point for creating your own style guide. If you really like this guide
    and adopt it as it is, great. If there are parts that you do not agree with and
    you change them within your guide, that is great as well. The appropriate style
    for you and your team is the one that you and your team feel comfortable with,
    and it may or may not be different from the guide in this book. We should also
    point out that Swift is a very young language and people are still trying to figure
    out the appropriate style to use with Swift; therefore, what is recommended today
    maybe frowned upon tomorrow. Don't be afraid to adjust your style guide as needed.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is noticeable in the style guide within this chapter, and most
    good style guides, is that there is very little explanation about why each item
    is preferred or not preferred. Style guides should give enough details so that
    the reader understands the preferred and non-preferred methods for each item,
    but should also be small and compact to make it easy and quick to read.
  prefs: []
  type: TYPE_NORMAL
- en: If a developer has questions about why a particular method is preferred, he
    or she should bring that concern up to the development group.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's get started with the guide.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use semicolons at the end of statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike a lot of languages, Swift does not require semicolons at the end of
    statements. Therefore, we should not use them. Let''s take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do not use parentheses for conditional statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike a lot of languages, the parentheses are not required around conditional
    statements; therefore, we should avoid using them unless they are needed for clarification.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We should always use descriptive names with camel case for classes, methods,
    variables, constants, and so on. Let's look at some general naming rules.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Class names should have a descriptive name that describes what the class is
    for. The name should begin with a capital letter and be in camel case. Here are
    examples of proper names and non-proper names based on our style guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Functions and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Function names should be descriptive, describing the function or method. They
    should begin with a lowercase letter and be in camel case. Here are some examples
    of proper and non-proper names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Constants and variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constants and variables should have a descriptive name. Generally, they begin
    with a lowercase letter and are in camel case. The only exception is when the
    constant is global; in that case, the name of the constant should contain all
    the uppercase characters with the words separated by underscores. I have seen
    numerous guides that frown on having all uppercase names, but I personally like
    them for constants in the global scope because it stands out that they are globally,
    not locally, scoped. Here are some examples of proper and non-proper names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Indenting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The indenting width in Xcode, by default, is defined as four spaces, and the
    tab width is also defined as four spaces. We should leave this as the default.
    The following screenshot shows the indentation setting in Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indenting](img/B05115_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We should also add an extra blank line between functions/methods. We should
    also use a blank line to separate the functionality within a function or method.
    That being said, using many blank lines within a function or method might signify
    that we should break the function into multiple functions.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should use comments as needed to explain how and why our code is written.
    We should use block comments before classes and functions, while we should use
    the double slashes to comment code in line. Here is an example of how to write
    comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are commenting methods, we should also use the documentation tags that
    will generate documentation in Xcode, as shown in the preceding example. At a
    minimum, we should use the following tags if they apply to our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:param`: This is used for parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:return`: This is used for what is returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the self keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Swift does not require us to use the `self` keyword when accessing properties
    or invoking methods of an object, we should avoid using it unless we need to distinguish
    between an object''s property and local variables. Here is an example of when
    you should use the `self` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of when not to use the `self` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should always use Swift native types when possible. If we remember, Swift
    offers bridging to Objective-C types, so even if we are using a Swift native type,
    we still have access to the full set of methods offered by Objective-C types.
    The following code shows the preferred and non-preferred ways to use native types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Constants and variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difference between constants and variables is that the value of a constant
    never changes, whereas the value of a variable may change. Wherever possible,
    we should define constants rather than variables.
  prefs: []
  type: TYPE_NORMAL
- en: One of the easiest ways of doing this is to define everything as a constant,
    by default, and then change the definition to a variable only after you reach
    a point in your code that requires you to change it. With Swift 2, you will get
    a warning if you define a variable and then never change the value within your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Optional types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only use optional types when absolutely necessary. If there is no absolute need
    for a nil value to be assigned to a variable, we should not define it as an optional.
  prefs: []
  type: TYPE_NORMAL
- en: Use optional binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should avoid forced unwrapping of optionals as there is rarely any need to
    do this. We should prefer optional binding or optional chaining for force unwrapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show the preferred and non-preferred methods where the
    `myOptional` variable is defined as an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is more than one optional that we need to unwrap, we should include
    them on the same line rather than unwrapping them on separate lines if our business
    logic does not require separate paths if the unwrapping fails. The following examples
    show the preferred and non-preferred methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Use optional chaining over optional binding for multiple unwrapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we need to unwrap multiple layers, we should use optional chaining over
    multiple optional binding statements. The following example shows the preferred
    and non-preferred methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Use type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than defining the variable types, we should let Swift infer the type.
    The only time we should define the variable or constant type is when we are not
    giving it a value while defining it. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use shorthand declaration for collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When declaring native Swift collection types, we should use the shorthand syntax,
    and unless absolutely necessary, we should initialize the collection. The following
    example shows the preferred and non-preferred methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Use for-in loops over for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should use `for-in` loops over `for` loops, especially when looping through
    collections. The following examples show the preferred and non-preferred methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Use switch rather than multiple if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wherever possible, we should prefer to use a single `switch` statement over
    multiple `if` statements. The following example shows the preferred and non-preferred
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Don't leave commented-out code in your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we comment out a block of code while we attempt to replace it, once we are
    comfortable with the changes, we should remove the code that we commented out.
    Having large blocks of code commented out can make the code base look messy and
    harder to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Grand Central Dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grand Central Dispatch, which was discussed in [Chapter 14](ch14.html "Chapter 14. Concurrency
    and Parallelism in Swift"), *Concurrency and Parallelism in Swift*, is a low-level
    C-based API that allows specific tasks to be queued up for execution and schedules
    the execution on any of the available processor cores.
  prefs: []
  type: TYPE_NORMAL
- en: Set the attribute in the dispatch_queue_create() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the `dispath_queue_create()` function to create a serial queue,
    we are able to set the `attribute` parameter to `nil` (which defines a serial
    queue); however, we should always set the attribute to `DISPATCH_QUEUE_SERIAL`
    or `DISPATCH_QUEUE_CONCURRENT` to explicitly define what type of queue we are
    creating. The following example shows the preferred and non-preferred methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Use a reverse DNS name for the tag parameter of the dispatch_queue_create()
    function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are able to set the `tag` parameter of the `dispatch_queue_create` function
    to any valid string; however, for consistency and easy troubleshooting, we should
    always use a reverse DNS naming scheme. The following code shows the preferred
    and non-preferred methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Use dispatch_get_global_queue() over dispatch_queue_create()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it is perfectly acceptable to use the `dispatch_queue_create()` function
    to create a new concurrent queue, we should prefer to use the `dispatch_get_global_queue()`
    function to retrieve a concurrent queue that is already created for use. The following
    examples show the preferred and non-preferred methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are developing an application in a team environment, it is important
    to have a well-defined coding style that everyone on the team adheres to. This
    allows us to have a code base that is easy to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: If a style guide remains static for too long, it means that it is probably not
    keeping up with the latest changes within the language. What is too long is different
    for each language. For example, with the C language, too long will be defined
    in years, since the language is very stable; however, with Swift, the language
    is so new and changes are coming pretty often, so too long can probably be defined
    as a couple of months.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that we keep our style guides in a versioning control system
    so that we can refer to the older versions if need be. This allows us to pull
    the older versions of the style guide and refer back to them when we are looking
    at older code.
  prefs: []
  type: TYPE_NORMAL
