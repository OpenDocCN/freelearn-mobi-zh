- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Creating a Photo Editor Using CameraX
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CameraX创建照片编辑器
- en: In the smartphone era, taking and sharing photos has become second nature, and
    platforms such as Instagram have shown us how powerful a single photo can be.
    For apps like these, it’s not just about snapping a picture; it’s about enhancing
    and personalizing that image to tell a story. But have you ever wondered what
    lies behind those in-app camera buttons and filters?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能手机时代，拍照和分享照片已经成为第二本能，像Instagram这样的平台向我们展示了单张照片的强大力量。对于这类应用程序，不仅仅是拍一张照片；它还涉及到增强和个性化图像，以讲述一个故事。但你有没有想过那些应用内相机按钮和滤镜背后的东西？
- en: Enter CameraX, Android’s go-to tool for everything camera-related. This tool
    doesn’t just make capturing photos seamless; it’s also the bridge to editing and
    refining them. In this chapter, we’ll get hands-on with CameraX, discovering how
    it can transform the Packtagram photography experience. We’ll also design an interactive
    space for users to tweak and enhance their shots, adding that personal touch.
    And for the cherry on top? We’ll dive into a bit of smart tech, teaching our app
    to recognize photo themes and suggest relevant hashtags.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 进入CameraX，这是Android在所有与相机相关事务中的首选工具。这个工具不仅使拍照变得无缝，而且也是编辑和精炼照片的桥梁。在本章中，我们将亲身体验CameraX，了解它如何改变Packtagram的摄影体验。我们还将为用户设计一个互动空间，让他们调整和增强他们的照片，增加个人风格。而且，作为点睛之笔？我们将深入研究一些智能技术，教我们的应用程序识别照片主题并建议相关的标签。
- en: Building on our prior work – crafting the screens and feed for our Instagram-inspired
    app – we’re now diving deeper into the app’s features. With CameraX, intuitive
    editing tools, and some clever features, we’re set to elevate our app’s photo-sharing
    game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的工作基础上——为我们的Instagram风格应用程序制作屏幕和动态内容——我们现在正在深入探索应用程序的功能。借助CameraX、直观的编辑工具和一些巧妙的功能，我们准备提升我们的照片分享游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting to know CameraX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解CameraX
- en: Integrating CameraX into our Packtagram app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CameraX集成到我们的Packtagram应用程序中
- en: Adding photo-editing functionalities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加照片编辑功能
- en: Using **machine learning** (**ML**) to categorize photos and generate hashtags
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**机器学习**（**ML**）对照片进行分类并生成标签
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have Android Studio (or another
    editor of your preference) installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，您需要安装Android Studio（或您偏好的其他编辑器）。
- en: 'You can find the complete code that we will be using in this chapter in this
    book’s GitHub repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-5](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-5).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中找到本章将使用的完整代码：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-5](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-5)。
- en: Getting to know CameraX
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解CameraX
- en: Since the inception of the Android platform, cameras have played a pivotal role
    in defining the feature set of smartphones. From capturing moments to enabling
    augmented reality experiences, the camera has evolved from a mere hardware component
    to a powerful tool for developers. This evolution, however, has not been without
    its complexities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Android平台诞生以来，相机在定义智能手机功能集方面发挥了关键作用。从捕捉瞬间到实现增强现实体验，相机已经从单纯的硬件组件发展成为一个强大的开发工具。然而，这种演变并非没有复杂性。
- en: The evolution of camera libraries in Android
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android中相机库的演变
- en: Since the first version of Android, developers interacted with the camera hardware
    through the Camera API; this was Android’s first attempt at giving developers
    the power to harness the capabilities of onboard cameras.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Android的第一个版本以来，开发者通过Camera API与相机硬件进行交互；这是Android首次尝试赋予开发者利用内置相机功能的能力。
- en: As devices proliferated and features such as more advanced photo hardware grew,
    the need for a more robust API became evident. Consequently, Camera2 API was introduced
    in API level 21 (Lollipop). While this offered more granular control over camera
    capabilities and supported the expanding features of new hardware, its steep learning
    curve made camera development challenging for many in terms of complexity and
    performance overhead.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着设备的普及和如更先进的摄影硬件等功能的增长，对更强大的API的需求变得明显。因此，Camera2 API在API级别21（Lollipop）中被引入。虽然这提供了对相机功能的更细粒度控制，并支持新硬件的扩展功能，但其陡峭的学习曲线使得许多人在复杂性和性能开销方面发现相机开发具有挑战性。
- en: Given the intricacies of Camera2 and the variances in camera hardware across
    different devices, developers found it increasingly difficult to provide a consistent
    camera experience to end users. This fragmentation, alongside the complexity of
    Camera2, made it imperative for a more streamlined, developer-friendly solution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Camera2 的复杂性以及不同设备之间相机硬件的差异，开发者发现为最终用户提供一致的相机体验变得越来越困难。这种碎片化，加上 Camera2 的复杂性，使得一个更简洁、更易于开发者使用的解决方案变得至关重要。
- en: Enter CameraX.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 CameraX。
- en: The importance and advantages of CameraX
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CameraX 的重要性和优势
- en: '**CameraX** is Android’s modern solution for camera app development that was
    developed with the primary goal of simplifying the process while reducing the
    fragmentation between devices. Here’s why it has quickly become indispensable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**CameraX** 是 Android 为相机应用程序开发提供的现代解决方案，其开发的主要目标是简化流程，同时减少设备之间的碎片化。以下是它迅速成为不可或缺的原因：'
- en: '**Consistency across devices**: CameraX abstracts the differences between device-specific
    camera behaviors, ensuring that most features work consistently across a wide
    range of devices.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨设备一致性**：CameraX 抽象了不同设备特定相机行为之间的差异，确保大多数功能在广泛的设备上都能保持一致。'
- en: '**Life cycle awareness**: Gone are the days of tedious life cycle management.
    CameraX is integrated with Android’s life cycle libraries, meaning less boilerplate
    code and more focus on core camera functionality.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期感知**：繁琐的生命周期管理时代已经过去。CameraX 与 Android 的生命周期库集成，这意味着更少的样板代码，更多关注核心相机功能。'
- en: '**Use case-based approach**: Instead of dealing with low-level tasks, developers
    can now focus on specific use cases, such as image preview, image capture, and
    image analysis. This makes development faster and less error-prone.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于用例的方法**：开发者现在可以专注于特定的用例，例如图像预览、图像捕获和图像分析，而不是处理低级任务。这使得开发更快，且错误更少。'
- en: '**Extensions for enhanced capabilities**: With the CameraX Extensions API,
    developers can access device-specific features such as portrait mode, HDR, and
    more, further enriching the camera experience.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强功能的扩展**：通过 CameraX 扩展 API，开发者可以访问设备特定的功能，如人像模式、HDR 等，进一步丰富相机体验。'
- en: '**Backward compatibility**: CameraX offers compatibility with devices running
    Android 5.0 (API level 21) and beyond, ensuring a wider reach than Camera2.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向后兼容性**：CameraX 与运行 Android 5.0（API 级别 21）及更高版本的设备兼容，确保其覆盖范围比 Camera2 更广。'
- en: '**Performance and quality**: CameraX provides optimized performance out of
    the box, delivering high-quality images and videos without the need for extra
    tuning.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和质量**：CameraX 提供了开箱即用的优化性能，无需额外调整即可提供高质量的图像和视频。'
- en: In summary, CameraX has not only simplified camera app development but also
    bridged the gap that’s caused by hardware discrepancies. As we delve deeper into
    this chapter, you’ll come to appreciate the nuances and capabilities that CameraX
    brings to the table, setting the stage for powerful, consistent, and high-quality
    camera applications on Android.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，CameraX 不仅简化了相机应用程序的开发，还弥合了由硬件差异造成的差距。随着我们深入本章，你会逐渐欣赏到 CameraX 带来的细微差别和功能，为在
    Android 上构建强大、一致且高质量的相机应用程序奠定基础。
- en: Now, let’s start using CameraX and configuring its dependencies in our project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用 CameraX 并在我们的项目中配置其依赖项。
- en: Setting up CameraX
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 CameraX
- en: 'To set up CameraX, we need to add the necessary dependencies to our version
    catalog file, `libs.versions.toml`, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 CameraX，我们需要将必要的依赖项添加到我们的版本目录文件 `libs.versions.toml` 中，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code block, we are adding the dependencies that are needed to use CameraX,
    plus a library called Accompanist.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码块中，我们添加了使用 CameraX 所需的依赖项，以及一个名为 Accompanist 的库。
- en: '**Accompanist** is a collection of extension libraries that are designed to
    complement Jetpack Compose. It fills the gaps by offering utilities for specific
    use cases and easing the integration of Compose with other Android capabilities.
    The features of Accompanist include image loading integrations, useful components
    such as ViewPager, tools to manage system UI insets, Compose navigation enhancements,
    and permissions handling. To learn more and expand on this information, please
    refer to the official documentation: [https://google.github.io/accompanist/](https://google.github.io/accompanist/).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accompanist** 是一系列设计用来补充Jetpack Compose的扩展库。它通过提供特定用例的实用工具以及简化Compose与其他Android功能的集成来填补空白。Accompanist的功能包括图像加载集成、有用的组件（如ViewPager）、管理系统UI嵌入的工具、Compose导航增强和权限处理。要了解更多信息并扩展这些信息，请参阅官方文档：[https://google.github.io/accompanist/](https://google.github.io/accompanist/)。'
- en: In our case, we are going to use it to simplify the process of checking and
    asking the user for camera permissions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用它来简化检查和请求用户相机权限的过程。
- en: 'Regarding the dependencies to use CameraX, we are adding the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用CameraX的依赖项，我们将添加以下内容：
- en: '**cameraCore**: This dependency provides the core functionality of CameraX,
    including the ability to manage camera devices, configure capture sessions, and
    receive frames from the camera. It is the foundation for all other CameraX dependencies.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraCore**: 这个依赖提供了CameraX的核心功能，包括管理相机设备、配置捕获会话和从相机接收帧的能力。它是所有其他CameraX依赖的基础。'
- en: '**cameraCamera2**: This dependency provides the Camera2 implementation of CameraX,
    which is the most powerful and flexible way to access the camera on Android devices.
    It provides low-level access to the camera’s hardware and allows for custom capture
    configurations and processing pipelines.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraCamera2**: 这个依赖提供了CameraX的Camera2实现，这是在Android设备上访问相机最强大和最灵活的方式。它提供了对相机硬件的低级访问，并允许自定义捕获配置和处理管道。'
- en: '**cameraView**: This dependency provides a pre-built view component that integrates
    with CameraX to simplify the process of displaying camera preview frames. It takes
    care of the layout and setup of the view so that you can focus on capturing and
    processing the camera data.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraView**: 这个依赖提供了一个预构建的视图组件，它可以与CameraX集成，简化显示相机预览帧的过程。它负责视图的布局和设置，这样你就可以专注于捕捉和处理相机数据。'
- en: '**cameraExtensions**: This dependency provides a set of extensions for CameraX
    that add additional features, such as support for focus peaking, image stabilization,
    and panorama capture. It also includes extensions for working with ML models on
    camera frames.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraExtensions**: 这个依赖提供了一组针对CameraX的扩展，增加了额外的功能，例如支持焦点峰值、图像稳定和全景捕获。它还包括用于在相机帧上处理ML模型的扩展。'
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The versions in the previous code are the latest stable ones at the time of
    writing this book, but there will likely be new ones by the time you are reading
    this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的版本是在编写本书时最新的稳定版本，但在你阅读本书时可能会有新的版本。
- en: 'After adding these dependencies to the version catalog, we need to add them
    to the `build.gradle.kts` file of the `:feature:stories` module, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些依赖项添加到版本目录后，我们需要将它们添加到`:feature:stories`模块的`build.gradle.kts`文件中，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that our project is ready to use CameraX, let’s learn more about the library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们项目已经准备好使用CameraX，让我们更深入地了解这个库。
- en: Learning about CameraX’s core concepts
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解CameraX的核心概念
- en: In this section, we’ll learn about some of CameraX’s most important concepts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解CameraX的一些重要概念。
- en: View life cycle
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图生命周期
- en: CameraX, a Jetpack support library, simplifies camera development across Android
    devices, and its life-cycle-aware nature seamlessly integrates with Jetpack Compose,
    empowering developers to create resilient and efficient camera applications. At
    the core of CameraX’s design philosophy lies its inherent support for Android’s
    life cycle, which eliminates the complexities of managing camera resources. CameraX
    automatically handles camera start, stop, and resource release based on life cycle
    events, streamlining the development process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CameraX，一个Jetpack支持库，简化了Android设备上的相机开发，并且由于其生命周期感知特性，它可以无缝地与Jetpack Compose集成，使开发者能够创建健壮且高效的相机应用程序。CameraX设计哲学的核心是其对Android生命周期的内在支持，消除了管理相机资源的复杂性。CameraX根据生命周期事件自动处理相机的启动、停止和资源释放，从而简化了开发过程。
- en: Jetpack Compose, the declarative UI toolkit for Android, is also deeply rooted
    in life cycle concepts. Composables inherently possess life cycle states, such
    as `onActive` and `onDispose`, that get triggered during their existence within
    the UI hierarchy. Combining the powers of CameraX and Compose offers a harmonized
    approach to managing the camera’s life cycle within Composable UI components.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose，Android 的声明式 UI 工具包，也深深植根于生命周期概念。可组合组件天生具有生命周期状态，如 `onActive`
    和 `onDispose`，这些状态在它们存在于 UI 层级中时会触发。结合 CameraX 和 Compose 的力量，为在可组合 UI 组件中管理摄像头的生命周期提供了一种协调的方法。
- en: Image analysis
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像分析
- en: 'CameraX goes beyond just capturing images. With **image analysis**, developers
    can process live camera feeds in real time. This is perfect for features such
    as barcode scanning, face detection, or even applying live filters. Here is an
    example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CameraX 不仅仅只是捕获图像。通过 **图像分析**，开发者可以实时处理实时摄像头流。这对于条形码扫描、人脸检测或甚至应用实时滤镜等特性来说非常完美。以下是一个示例：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code defines a composable function called `CameraPreviewWithImageAnalysis`
    that displays a camera preview and analyzes the live camera feed, utilizing Jetpack
    Compose and CameraX to achieve this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为 `CameraPreviewWithImageAnalysis` 的可组合函数，用于显示摄像头预览并分析实时摄像头流，利用 Jetpack
    Compose 和 CameraX 来实现这一点。
- en: First, the `rememberCameraProvider` function is used to retrieve the camera
    provider instance, which is responsible for managing the camera’s life cycle and
    providing access to camera controls. Then, a `Preview` instance is created using
    `Preview.Builder` to define the camera preview surface. This preview will display
    the live camera feed on the screen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `rememberCameraProvider` 函数检索摄像头提供程序实例，该实例负责管理摄像头的生命周期并提供对摄像头控制的访问。然后，使用
    `Preview.Builder` 创建了一个 `Preview` 实例来定义摄像头预览表面。此预览将在屏幕上显示实时摄像头流。
- en: After that, an `ImageAnalysis` instance is created using `ImageAnalysis.Builder`
    to process the live camera feed. The `setAnalyzer` method is used to specify an
    analyzer function that will be called whenever a new image frame is available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用 `ImageAnalysis.Builder` 创建了一个 `ImageAnalysis` 实例，用于处理实时摄像头流。`setAnalyzer`
    方法用于指定一个分析器函数，每当有新的图像帧可用时，该函数将被调用。
- en: A `LaunchedEffect` block is used to start a coroutine that binds the camera
    preview and image analyzer to the camera’s life cycle. The `bindToLifecycle` method
    is used to connect the use cases to the camera’s life cycle, ensuring that they
    start and stop automatically when the app starts and stops.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LaunchedEffect` 块启动一个协程，将摄像头预览和图像分析器绑定到摄像头的生命周期。`bindToLifecycle` 方法用于将用例连接到摄像头的生命周期，确保它们在应用启动和停止时自动开始和停止。
- en: A `mutableStateOf` variable text is used to store the current state of the analysis.
    The text variable is updated within the analyzer function to reflect the results
    of the image analysis.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mutableStateOf` 变量文本来存储分析当前状态。文本变量在分析器函数内更新，以反映图像分析的结果。
- en: Finally, the `Box` composable is used to lay out the camera preview and the
    text. The `fillMaxSize` modifier is used to make `Box` occupy the entire screen.
    The `Preview` composable is placed inside `Box` to display the camera preview.
    The `Text` composable is also placed inside `Box` to display the current state
    of the analysis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `Box` 可组合组件来布局摄像头预览和文本。`fillMaxSize` 修改器用于使 `Box` 占据整个屏幕。`Preview` 可组合组件放置在
    `Box` 内以显示摄像头预览。`Text` 可组合组件也放置在 `Box` 内以显示当前分析状态。
- en: 'This is a basic example of how to apply image analysis, but there are some
    already existing image analyzers, such as `BarcodeScanner`. The following code
    is built upon the previous one, adding this analyzer:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应用图像分析的基本示例，但已经存在一些图像分析器，例如 `BarcodeScanner`。以下代码基于上一个示例，添加了此分析器：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similar to the previous example, this code defines a composable function called
    `BarcodeScannerPreview` that displays a camera preview and analyzes the live camera
    feed for barcodes. However, this code specifically focuses on barcode scanning
    and utilizes the ML Kit `BarcodeScanner` library to achieve this functionality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例类似，此代码定义了一个名为 `BarcodeScannerPreview` 的可组合函数，用于显示摄像头预览并分析实时摄像头流中的条形码。然而，此代码特别关注条形码扫描，并使用
    ML Kit 的 `BarcodeScanner` 库来实现此功能。
- en: First, the `rememberCameraProvider` and `Preview` functions are used in the
    same way as they were in the previous example to retrieve the camera provider
    instance and create a preview instance for displaying the live camera feed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，与上一个示例中的用法相同，使用`rememberCameraProvider`和`Preview`函数来检索摄像头提供程序实例并创建一个用于显示实时摄像头流的预览实例。
- en: Then, a `BarcodeScanner` instance is created using `BarcodeScanner.Builder`,
    specifying the barcode formats to be detected. In this case, all barcode formats
    are specified using `BarcodeScannerOptions.BarcodeFormat.ALL_FORMATS`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`BarcodeScanner.Builder`创建了一个`BarcodeScanner`实例，指定要检测的条形码格式。在这种情况下，使用`BarcodeScannerOptions.BarcodeFormat.ALL_FORMATS`指定了所有条形码格式。
- en: Following this, an `ImageAnalysis` instance is created using `ImageAnalysis.Builder`,
    and the analyzer function is defined to process each image frame. First, the analyzer
    function retrieves the image rotation from the `imageInfo` object. Then, it converts
    the `ImageProxy` instance into an `InputImage` format that’s compatible with ML
    Kit’s `BarcodeScanner`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，使用`ImageAnalysis.Builder`创建了一个`ImageAnalysis`实例，并定义了分析函数以处理每个图像帧。首先，分析函数从`imageInfo`对象中检索图像旋转。然后，它将`ImageProxy`实例转换为与ML
    Kit的`BarcodeScanner`兼容的`InputImage`格式。
- en: The `BarcodeScanner.processImage` method is called on the `InputImage` instance
    to detect barcodes. Here, `OnSuccessListener` is used to handle the successful
    barcode detection, while `OnFailureListener` is used to handle any errors that
    occur during barcode scanning.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InputImage`实例上调用`BarcodeScanner.processImage`方法以检测条形码。在这里，使用`OnSuccessListener`来处理成功的条形码检测，而使用`OnFailureListener`来处理条形码扫描过程中发生的任何错误。
- en: If barcodes are detected, the `displayValue` value of the first barcode is extracted
    and stored in the `barcodeText` mutable state variable. This variable is used
    to update the text field with the detected barcode information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到条形码，则提取第一个条形码的`displayValue`值并将其存储在可变状态变量`barcodeText`中。此变量用于更新文本字段以包含检测到的条形码信息。
- en: 'With this, we have created our first image analyzer to get barcode information.
    Let’s move on to the next feature: `CameraSelector`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经创建了我们第一个图像分析器以获取条形码信息。让我们继续到下一个功能：`CameraSelector`。
- en: CameraSelector
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CameraSelector
- en: 'When dealing with cameras, it’s not always about just one camera – many modern
    devices come with multiple camera lenses. This is where `CameraSelector` comes
    to the rescue, allowing developers to programmatically choose between, say, the
    front or rear camera. Whether you’re building a selfie app or a more standard
    photo application, `CameraSelector` ensures consistent behavior across the board.
    Let’s see how we can allow a user to select which camera they want to use:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理摄像头时，并不总是只关注一个摄像头——许多现代设备都配备了多个摄像头镜头。这就是`CameraSelector`发挥作用的地方，它允许开发者以编程方式在前后摄像头之间进行选择。无论是构建自拍应用还是更标准的照片应用，`CameraSelector`都能确保一致的行为。让我们看看我们如何允许用户选择他们想要使用的摄像头：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code will display a camera preview and a button. Clicking the
    button will switch between the front and rear cameras. The `isUsingFrontCamera`
    mutable state variable is used to keep track of which camera is currently being
    used. Then, `cameraSelector` is updated whenever the `isUsingFrontCamera` variable
    changes. The camera preview is automatically updated to reflect the new camera
    selection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将显示相机预览和一个按钮。点击按钮将在前后摄像头之间切换。使用可变状态变量`isUsingFrontCamera`来跟踪当前正在使用的摄像头。然后，每当`isUsingFrontCamera`变量发生变化时，更新`cameraSelector`。相机预览会自动更新以反映新的摄像头选择。
- en: It’s also possible to provide your users with more control over the camera functionality.
    So, let’s talk about `CameraControls`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以为用户提供更多对摄像头功能的控制。因此，让我们来谈谈`CameraControls`。
- en: CameraControls
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CameraControls
- en: A comprehensive camera experience isn’t just about capturing or analyzing an
    image. It’s also about control. With `CameraControls`, developers gain access
    to an array of functions that allow them to manipulate the camera feed. From zooming
    into a subject and adjusting focus for that crystal-clear shot to toggling the
    torch for those night-time snaps, `CameraControls` ensures users always get the
    perfect shot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全面的摄像头体验不仅仅是捕捉或分析图像。它还关乎控制。通过`CameraControls`，开发者可以访问一系列功能，允许他们操纵摄像头流。从放大主题并调整焦点以获得清晰的照片到切换手电筒以拍摄夜间快照，`CameraControls`确保用户始终获得完美的拍摄效果。
- en: 'Here is an example of how to use `CameraControls` to zoom, adjust focus, and
    toggle the torch, starting with the first part of the code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用`CameraControls`来缩放、调整焦点和切换手电筒的示例，从代码的第一部分开始：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we are defining the `rememberCameraProvider` function,
    which is used to retrieve the camera provider instance. It manages the camera’s
    life cycle and provides access to camera controls. Then, `Preview.Builder()` is
    used to create a `Preview` instance, which defines the surface on which the live
    camera feed will be displayed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在定义`rememberCameraProvider`函数，该函数用于检索相机提供程序实例。它管理相机的生命周期并提供对相机控制器的访问。然后，使用`Preview.Builder()`创建一个`Preview`实例，该实例定义了实时相机流将显示的表面。
- en: 'Three `mutableStateOf` variables are used to store the state of the zoom level,
    focus point, and torch status:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个`mutableStateOf`变量来存储缩放级别、焦点和手电筒状态：
- en: '**zoomLevel**: This stores the current zoom level, ranging from 1.0f (no zoom)
    to 5.0f (maximum zoom)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zoomLevel**：此变量存储当前的缩放级别，范围从1.0f（无缩放）到5.0f（最大缩放）'
- en: '**focusPoint**: This stores the current focus point, represented as a pair
    of coordinates (*x*, *y*) within the preview frame'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**focusPoint**：此变量存储当前的焦点，表示为预览框架内的坐标对(*x*, *y*)'
- en: '**isTorchEnabled**: This stores the current torch status, indicating whether
    the torch is enabled or disabled'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isTorchEnabled**：此变量存储当前的手电筒状态，指示手电筒是否启用或禁用'
- en: 'Let’s continue with the next part of the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一部分的代码：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the `cameraControl.getCameraControl(preview)` method retrieves the `CameraControl`
    instance associated with the preview. This instance provides access to various
    camera controls:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cameraControl.getCameraControl(preview)`方法检索与预览关联的`CameraControl`实例。此实例提供了访问各种相机控制的功能：
- en: '**cameraControl.setZoomRatio(zoomLevel.value)**: This control sets the zoom
    level using the value stored in the **zoomLevel** variable'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraControl.setZoomRatio(zoomLevel.value)**：此控制使用存储在**zoomLevel**变量中的值设置缩放级别'
- en: '**cameraControl.setFocusPoint(focusPoint.value)**: This control sets the focus
    point using the coordinates stored in the **focusPoint** variable'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraControl.setFocusPoint(focusPoint.value)**：此控制使用存储在**focusPoint**变量中的坐标设置焦点'
- en: '**cameraControl.enableTorch(isTorchEnabled.value)**: This control enables or
    disables the torch based on the value stored in the **isTorchEnabled** variable'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraControl.enableTorch(isTorchEnabled.value)**：此控制根据存储在**isTorchEnabled**变量中的值启用或禁用手电筒'
- en: 'Now, let’s move on to the last chunk of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到最后一段代码：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this last code block, the controls are configured and used within the `Column`
    layout:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的代码块中，控件在`Column`布局中被配置和使用：
- en: A **Slider** component is used to adjust the zoom level. The **valueRange**
    property defines the range of zoom levels (1.0f to 5.0f), and the **onValueChange**
    callback updates the **zoomLevel** variable with the selected zoom level.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**滑动条**组件来调整缩放级别。**valueRange**属性定义了缩放级别的范围（1.0f到5.0f），而**onValueChange**回调将选定的缩放级别更新到**zoomLevel**变量。
- en: A **Button** component triggers a change in the focus point. When clicked, it
    updates the **focusPoint** variable between two predefined locations (0.5f to
    0.5f and 0.1f to 0.1f).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮**组件触发焦点位置的变化。点击时，它将在两个预定义的位置（0.5f到0.5f和0.1f到0.1f）之间更新**focusPoint**变量。'
- en: Another **Button** component toggles the torch status. When clicked, it updates
    the **isTorchEnabled** variable and calls **cameraControl.enableTorch** to set
    the torch accordingly.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个**按钮**组件用于切换手电筒状态。点击时，它会更新**isTorchEnabled**变量，并调用**cameraControl.enableTorch**来相应地设置手电筒。
- en: In conclusion, CameraX provides a robust and versatile platform for developing
    high-quality camera applications on Android. It offers a simplified API, streamlined
    use cases, and a comprehensive set of features, making it an ideal choice for
    building modern camera-centric apps. Now, we are ready to use it in our app.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，CameraX为在Android上开发高质量的相机应用提供了一个强大且灵活的平台。它提供了一个简化的API、流畅的使用案例和一套全面的特性，使其成为构建现代以相机为中心的应用的理想选择。现在，我们已准备好在我们的应用中使用它。
- en: Integrating CameraX into our Packtagram app
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CameraX集成到我们的Packtagram应用中
- en: Now that we know more about CameraX, let’s start integrating it into our app.
    First, we will need to deal with the camera permissions, providing a way for the
    user to accept them. Then, we will set up our camera preview and add the camera
    capture functionality to our code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对CameraX有了更多的了解，让我们开始将其集成到我们的应用中。首先，我们需要处理相机权限，为用户提供接受权限的方式。然后，我们将设置相机预览并添加相机捕获功能到我们的代码中。
- en: Setting up the permissions checker with Accompanist
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Accompanist 设置权限检查器
- en: 'There are several ways to check if the camera permissions have been granted,
    and if not, to request them: we could do this manually or use a library. In this
    case, we will use the Accompanist library, as we introduced at the beginning of
    this chapter.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以检查摄像头权限是否已被授予，如果没有，则请求它们：我们可以手动完成或使用库。在这种情况下，我们将使用 Accompanist 库，正如我们在本章开头所介绍的。
- en: 'Before requesting any permission at runtime, it’s fundamental to declare the
    same permissions in the app’s `AndroidManifest.xml` file. This declaration informs
    the Android operating system of the app’s intentions. For the camera permission,
    you need to add the following line within the `<``manifest>` tag:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时请求任何权限之前，在应用的`AndroidManifest.xml`文件中声明相同的权限是基本要求。这种声明通知Android操作系统应用的目的。对于摄像头权限，您需要在`<manifest>`标签内添加以下行：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While the manifest informs the system of the app’s needs, runtime permissions
    are about seeking the user’s explicit consent. Ensure you always have both in
    place when accessing protected features or user data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然清单通知系统应用的需求，但运行时权限是关于寻求用户的明确同意。确保在访问受保护的功能或用户数据时，始终具备这两者。
- en: Now, let’s go into the permissions checker code. Our aim here is to create a
    reusable composable function that can handle the camera permission elegantly.
    It should be able to request the permission, handle user decisions, and, if necessary,
    explain why the app needs this permission.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入权限检查器代码。我们的目标是创建一个可重用的可组合函数，可以优雅地处理摄像头权限。它应该能够请求权限，处理用户决策，并在必要时解释为什么应用需要这个权限。
- en: 'First, we need to import the required libraries:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入所需的库：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the `@OptIn` annotation indicates that we’re using an experimental API
    from the Accompanist permissions library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@OptIn` 注解表明我们正在使用 Accompanist 权限库中的实验性 API。
- en: 'Now, inside `CameraPermissionRequester`, we need to add the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`CameraPermissionRequester`内部，我们需要添加以下内容：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `rememberPermissionState` is a helper function that recalls the current
    state of the camera permission. It provides information such as whether the permission
    is granted, if we’ve already asked the user, or if we should show a rationale.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`rememberPermissionState` 是一个辅助函数，它回忆起摄像头权限的当前状态。它提供有关权限是否已授予、我们是否已经询问过用户或是否应该显示理由等信息。
- en: 'With the permission state in hand, we can create a UI flow that responds to
    this state:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有权限状态后，我们可以创建一个响应此状态的 UI 流程：
- en: '**Permission granted**: If permission is already granted, the user can directly
    proceed to use the camera.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限已授予**：如果权限已经授予，用户可以直接使用摄像头。'
- en: '**Show rationale**: Sometimes, if a user denies a certain permission, it’s
    helpful to explain why the app needs that permission. This is where the rationale
    comes into play.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示理由**：有时，如果用户拒绝某个权限，解释应用为什么需要这个权限是有帮助的。这就是理由发挥作用的地方。'
- en: '**Permission not yet requested**: If the app hasn’t asked for the permission
    yet, we want to provide a button to initiate the request.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尚未请求权限**：如果应用尚未请求权限，我们希望提供一个按钮来启动请求。'
- en: '**Permission denied without rationale**: In some cases, users deny permissions
    and opt not to be asked again. It’s good practice to guide them to the app settings
    if they change their mind.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未提供理由拒绝权限**：在某些情况下，用户拒绝权限并选择不再被询问。如果他们改变主意，引导他们到应用设置是一个好习惯。'
- en: 'Let’s learn how to handle all these possible flows. First, we will create a
    new composable called `CameraPermissionRequester`. The `onPermissionGranted` callback
    is provided to handle the scenario when the camera permission has been granted:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何处理所有这些可能的流程。首先，我们将创建一个新的可组合函数，称为 `CameraPermissionRequester`。`onPermissionGranted`
    回调用于处理摄像头权限已被授予的情况：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will retrieve `cameraPermissionState`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检索 `cameraPermissionState`：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `rememberPermissionState(permission)` function retrieves the current state
    of the specified permission. In this case, we’re checking the status of the `CAMERA`
    permission, which is necessary for accessing the device’s camera. The result is
    stored in the `cameraPermissionState` variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`rememberPermissionState(permission)` 函数用于检索指定权限的当前状态。在本例中，我们正在检查`CAMERA`权限的状态，这是访问设备摄像头的必要条件。结果存储在`cameraPermissionState`变量中。'
- en: 'Now, let’s evaluate the different values it could have:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们评估它可能具有的不同值：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code block, we are starting to evaluate the `status.isGranted`
    property of the `cameraPermissionState` object, which indicates whether the permission
    has been granted. If it’s true, it means the permission is available, and we can
    call the `onPermissionGranted` callback to proceed with using the camera features.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，我们开始评估`cameraPermissionState`对象的`status.isGranted`属性，该属性指示权限是否已被授予。如果是真的，这意味着权限可用，我们可以调用`onPermissionGranted`回调来继续使用相机功能。
- en: 'If it is false, this means that the permission hasn’t been granted, so we will
    have to communicate that situation to the user and give them the option to grant
    it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是假的，这意味着权限尚未被授予，因此我们必须向用户传达这种情况，并给他们提供授予权限的选项：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code block, we’re displaying a message explaining the need for
    the permission and providing a `Button` component to initiate the permission request
    process. The `onClick` handler of the button triggers the `launchPermissionRequest()`
    method of the `cameraPermissionState` object, which prompts the user to grant
    the permission.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，我们显示了一条消息，解释了请求权限的原因，并提供了一个`Button`组件来启动权限请求过程。按钮的`onClick`处理程序触发`cameraPermissionState`对象的`launchPermissionRequest()`方法，提示用户授予权限。
- en: The `launchPermissionRequest()` method opens a system dialogue requesting the
    user to grant the `CAMERA` permission. The dialogue provides clear instructions
    and explains the reasons why the permission is required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`launchPermissionRequest()`方法打开一个系统对话框，请求用户授予`CAMERA`权限。对话框提供了清晰的说明并解释了为什么需要此权限。'
- en: 'If we run this code now, we should see the two screens. First, we will see
    our screen with the message to request the permissions (left). Once we click **Request
    permission**, we will see the system prompt to accept the permission (right):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这段代码，我们应该看到两个屏幕。首先，我们会看到我们的屏幕上显示请求权限的消息（左侧）。一旦我们点击**请求权限**，我们会看到系统提示接受权限（右侧）：
- en: '![Figure 5.1: Camera permission requested in our app (left) and system prompt
    to grant capture and record permissions (right)](img/B19443_05_001.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：在我们的应用中请求相机权限（左侧）和系统提示授予捕获和录制权限（右侧）](img/B19443_05_001.jpg)'
- en: 'Figure 5.1: Camera permission requested in our app (left) and system prompt
    to grant capture and record permissions (right)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：在我们的应用中请求相机权限（左侧）和系统提示授予捕获和录制权限（右侧）
- en: Once the permissions have been granted, `CameraPreview` can start working. We
    will use the `onPermissionGranted` callback to show it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦权限被授予，`CameraPreview`就可以开始工作了。我们将使用`onPermissionGranted`回调来显示它。
- en: Creating our own CameraPreview
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们自己的CameraPreview
- en: 'The following `CameraPreview` composable function is designed to elegantly
    integrate CameraX into the Jetpack Compose ecosystem. At the time of writing,
    there is not an official composable implementation for the CameraX preview, so
    we will use `AndroidView`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`CameraPreview`组合函数旨在优雅地将CameraX集成到Jetpack Compose生态系统。在撰写本文时，还没有官方的组合实现用于CameraX预览，因此我们将使用`AndroidView`：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This composable function takes two parameters: `cameraController`, which is
    an instance of `LifecycleCameraController` to control the camera, and an optional
    modifier, which is used to specify layout options.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合函数接受两个参数：`cameraController`，它是一个`LifecycleCameraController`实例，用于控制相机，以及一个可选的修饰符，用于指定布局选项。
- en: Inside the function, an `AndroidView` composable is used to bridge traditional
    Android views with the Jetpack Compose UI framework. The factory parameter of
    `AndroidView` is a Lambda that provides context and returns a `PreviewView` object.
    The `PreviewView` object is a standard Android view that’s used to display the
    camera feed. It is configured with `implementationMode` set to `COMPATIBLE` to
    ensure compatibility with different devices and scenarios (one of the most relevant
    CameraX features).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，使用了一个`AndroidView`组合来连接传统的Android视图与Jetpack Compose UI框架。`AndroidView`的工厂参数是一个Lambda，它提供上下文并返回一个`PreviewView`对象。`PreviewView`对象是一个标准的Android视图，用于显示相机流。它配置了`implementationMode`设置为`COMPATIBLE`，以确保与不同设备和场景的兼容性（CameraX最相关的功能之一）。
- en: The modifier parameter of `AndroidView` is set to the passed modifier to allow
    the layout to be customized. The `update` parameter is another Lambda that’s called
    to perform updates on `PreviewView`. In this case, it assigns `cameraController`
    to the controller property of `PreviewView`, linking the camera preview to `LifecycleCameraController`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidView`的修饰符参数设置为传递的修饰符，以允许布局被定制。`update`参数是另一个Lambda，它被调用以在`PreviewView`上执行更新。在这种情况下，它将`cameraController`分配给`PreviewView`的控制器属性，将摄像头预览链接到`LifecycleCameraController`。'
- en: 'Now, let’s integrate the preview into our existing code. In the `StoryContent`
    composable, we will include the following code, where we expect to have the camera
    image:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将预览集成到我们现有的代码中。在`StoryContent`可组合组件中，我们将包含以下代码，其中我们期望有摄像头图像：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that, we should be ready to use the camera! At this point, we’ve learned
    how to integrate `CameraPreview`, check the permissions, and show the camera image
    stream. Now, let’s add the possibility of saving the photos!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们应该准备好使用摄像头了！在这个阶段，我们已经学习了如何集成`CameraPreview`、检查权限以及显示摄像头图像流。现在，让我们添加保存照片的可能性！
- en: Adding photo-saving functionality
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加照片保存功能
- en: The capture functionality is a staple for every app using the camera. We will
    need to add some logic to our existing code to handle the capture storage. Let’s
    start with a use case (where we are going to put our domain logic) to store the
    captured image.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获功能是每个使用摄像头的应用程序的基本功能。我们需要在我们的现有代码中添加一些逻辑来处理捕获存储。让我们从一个用例（我们将在这里放置我们的领域逻辑）开始，以存储捕获的图像。
- en: Creating the SaveCaptureUseCase
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建`SaveCaptureUseCase`
- en: The primary responsibility of `SaveCaptureUseCase` will be to take a bitmap
    object (the format we will use for our photos) and save it as an image file in
    the device’s gallery. Additionally, it will handle the different approaches based
    on the Android version as how media storage is accessed is different, depending
    on the version.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaveCaptureUseCase`的主要责任将是获取位图对象（我们将用于照片的格式）并将其保存为设备相册中的图像文件。此外，它将处理基于Android版本的不同方法，因为根据版本的不同，媒体存储的访问方式也不同。'
- en: 'For example, we will need to obtain the URI (the route in the storage of the
    device) where we are going to store the image. If the user has a version of Android
    more recent than 9.0, the location will be different than in the previous versions.
    The following code block shows what the check to obtain the corresponding route
    will look like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要获取我们将存储图像的URI（设备存储中的路径）。如果用户的Android版本比9.0新，位置将不同于之前的版本。以下代码块显示了获取相应路径的检查将看起来像什么：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are evaluating if the version is major or equal to Android 9.0 and
    obtaining the URI using `MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)`.
    If the version doesn’t meet those requirements, we obtain the URI from `MediaStore.Images.Media.EXTERNAL_CONTENT_URI`.
    We should take all these different cases into account so that our use case handles
    the different Android versions properly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在评估版本是否为主版本或等于Android 9.0，并使用`MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)`获取URI。如果版本不符合这些要求，我们从`MediaStore.Images.Media.EXTERNAL_CONTENT_URI`获取URI。我们应该考虑所有这些不同的情况，以便我们的用例能够正确处理不同的Android版本。
- en: 'Now, let’s create the `SaveCaptureUse` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`SaveCaptureUse`类：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can create the main function of this use case, `save()`, which will
    take care of saving the capture:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建这个用例的主函数`save()`，它将负责保存捕获的内容：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code block, we are starting to create the save function. As it is marked
    as a `suspend` function, the save function is designed to be called within a coroutine
    context. It uses `withContext(Dispatchers.IO)` to ensure that all I/O operations
    are performed on a background thread. This is crucial for maintaining UI responsiveness
    as I/O operations can be time-consuming.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们开始创建保存函数。由于它被标记为`suspend`函数，保存函数被设计为在协程上下文中调用。它使用`withContext(Dispatchers.IO)`来确保所有I/O操作都在后台线程上执行。这对于保持UI响应性至关重要，因为I/O操作可能很耗时。
- en: Next, we are declaring `ContextResolver`. This resolver is used to interact
    with `MediaStore`, which is Android’s central repository for media files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`ContextResolver`。这个解析器用于与`MediaStore`交互，它是Android的媒体文件中央存储库。
- en: Then, the function will call `getImageCollectionUri()`, a helper function that
    provides the appropriate URI for `MediaStore` based on the Android version. This
    URI is where the image will be saved. We will implement this function next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数将调用`getImageCollectionUri()`，这是一个辅助函数，根据Android版本提供适当的`MediaStore` URI。此URI是图像将被保存的位置。我们将在下一个实现此函数。
- en: After, the current system time (`nowTimestamp`) is captured, and `createContentValues
    (nowTimestamp)` is invoked to prepare the metadata for the image. This metadata,
    which is stored in a `ContentValues` object, includes details such as the image’s
    display name, `MIME` type, and timestamps.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，捕获当前系统时间（`nowTimestamp`），并调用`createContentValues (nowTimestamp)`以准备图像的元数据。此元数据存储在`ContentValues`对象中，包括图像的显示名称、`MIME`类型和时间戳等详细信息。
- en: The function then attempts to insert a new record into `MediaStore` using the
    resolved URI and the prepared metadata. The `insert` method returns a URI that
    points to the newly created record. If this operation is successful, a non-null
    URI is returned, representing the location of the new image record in `MediaStore`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后尝试使用解析的URI和准备好的元数据将新记录插入到`MediaStore`中。`insert`方法返回一个指向新创建记录的URI。如果此操作成功，则返回非空URI，表示新图像记录在`MediaStore`中的位置。
- en: Finally, if the URI is not null, the `saveBitmapToUri` function is called with
    the resolver, the URI, the bitmap to be saved, and the image metadata. This function
    handles the actual process of writing the bitmap data to the location pointed
    to by the URI. We will implement it soon.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果URI不为空，则使用解析器、URI、要保存的位图和图像元数据调用`saveBitmapToUri`函数。此函数处理将位图数据写入URI指向的位置的实际过程。我们很快就会实现它。
- en: Regarding error handling, our `save` function uses Kotlin’s `Result` class for
    structured error handling. If the insertion into the MediaStore is successful
    and the bitmap is saved correctly, the function returns `Result.success(Unit)`.
    If there is a failure at any point (for example, the URI is null, indicating that
    the insertion failed), the function returns `Result.failure`, encapsulating an
    exception with an appropriate error message.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于错误处理，我们的`save`函数使用Kotlin的`Result`类进行结构化错误处理。如果MediaStore中的插入成功且位图正确保存，则函数返回`Result.success(Unit)`。如果在任何点上出现失败（例如，URI为空，表示插入失败），则函数返回`Result.failure`，封装一个适当的错误消息的异常。
- en: 'Now, let’s implement the `getImageCollectionUri()` function, which will return
    the correct URI based on the Android version:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`getImageCollectionUri()`函数，该函数将根据Android版本返回正确的URI：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we can create the `createContentValues` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建`createContentValues`函数：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `createContentValues` function is designed to prepare the metadata for
    an image file before it is saved to the device’s gallery via `MediaStore`. This
    method is pivotal in ensuring that the saved image has the correct and necessary
    information associated with it. So, let’s break down its functionality:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`createContentValues`函数旨在在通过`MediaStore`将图像文件保存到设备的相册之前准备图像文件的元数据。此方法对于确保保存的图像具有正确的和必要的信息至关重要。因此，让我们分解其功能：'
- en: First, the function initiates a **ContentValues** object. Here, **ContentValues**
    is a key-value pair that’s used in Android to store a set of values that **ContentResolver**
    can process. It is commonly used for passing data to Android’s content providers
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，函数初始化一个**ContentValues**对象。在这里，**ContentValues**是一个键值对，在Android中用于存储一组**ContentResolver**可以处理的值。它通常用于将数据传递给Android的内容提供者。
- en: Next, the display name of the image in **MediaStore** is set. We will use a
    predefined **FILE_NAME_PREFIX** constant and append the current timestamp to it,
    followed by the **.jpg** extension, ensuring each saved image has a unique name.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，设置**MediaStore**中图像的显示名称。我们将使用预定义的**FILE_NAME_PREFIX**常量，并将其与当前时间戳连接，然后附加**.jpg**扩展名，确保每个保存的图像都有一个唯一的名称。
- en: Then, the **MIME** type of the image is set to **image/jpg**. This information
    is used by **MediaStore** and other apps to understand the file format of the
    image.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将图像的**MIME**类型设置为**image/jpg**。此信息由**MediaStore**和其他应用程序用于理解图像的文件格式。
- en: 'We have to store it differently, depending on the Android version of the device:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须根据设备的Android版本以不同的方式存储它：
- en: 'For Android Q (API Level 29) and above, we must do the following:'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Android Q（API级别29）及以上版本，我们必须执行以下操作：
- en: We need to add the timestamp of when the image is being stored and use the **MediaStore.MediaColumns.DATE_TAKEN**
    key.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要添加图像存储时的时间戳，并使用**MediaStore.MediaColumns.DATE_TAKEN**键。
- en: We must use the **createContentValues** function to specify a relative path
    for the image file, pointing to a directory within the **Digital Camera Images**
    (**DCIM**) folder using **put(MediaStore.MediaColumns.RELATIVE_PATH, "${Environment.DIRECTORY_DCIM}/Packtagram")**.
    This helps in organizing the saved images in a specific subdirectory, making them
    easier to locate.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须使用**createContentValues**函数指定图像文件的相对路径，使用**put(MediaStore.MediaColumns.RELATIVE_PATH,
    "${Environment.DIRECTORY_DCIM}/Packtagram")**指向**数字相机图像**（**DCIM**）文件夹内的一个目录。这有助于在特定子目录中组织保存的图像，使其更容易找到。
- en: We need to update the **ContentValues** instance and set **IS_PENDING** to **1**
    (true), indicating that file creation is in progress. This is a way to inform
    the system and other apps that the file is not yet fully written and should not
    be accessed until the status is reverted.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要更新**ContentValues**实例并将**IS_PENDING**设置为**1**（true），表示文件创建正在进行中。这是通知系统和其他应用程序文件尚未完全写入，并且应在状态恢复之前不应访问文件的一种方式。
- en: For Android R (API Level 30) and above, our function should add more metadata,
    including the date added, date modified, author name, and a description. This
    is part of the enhanced metadata management in newer Android versions, allowing
    for more detailed information to be stored with media files.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Android R（API级别30）及以上版本，我们的函数应该添加更多元数据，包括添加日期、修改日期、作者姓名和描述。这是新版本Android中增强的元数据管理的一部分，允许存储与媒体文件相关的更详细的信息。
- en: 'Now that we are handling the URI that’s needed to store the file, as well as
    the values and metadata needed to create the file, let’s proceed to do the saving
    itself. To do so, we will create a new private function called `saveBitmapToUri`,
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在处理存储文件所需的URI，以及创建文件所需的值和元数据，让我们继续进行保存操作。为此，我们将创建一个新的私有函数`saveBitmapToUri`，如下所示：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function starts by attempting to open `OutputStream` for the given URI.
    This stream is where the bitmap data will be written. Here, `Resolver.openOutputStream(uri)`
    is used to obtain the stream, and the `use` block ensures that this stream is
    closed properly after its operations, following the best practices in resource
    management.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先尝试为给定的URI打开`OutputStream`。这个流是位图数据将被写入的地方。在这里，使用`Resolver.openOutputStream(uri)`来获取流，而`use`块确保在操作完成后正确关闭此流，遵循资源管理的最佳实践。
- en: Inside the `use` block, the function checks if `outputStream` is not `null`,
    throwing an exception with a descriptive message if it is. If the stream is valid,
    the bitmap is compressed and written to this stream. The compression format is
    set to JPEG, and the quality is determined by the `IMAGE_QUALITY` constant.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`use`块内部，该函数会检查`outputStream`是否为`null`，如果是，则会抛出一个带有描述性信息的异常。如果流有效，则将位图压缩并写入此流。压缩格式设置为JPEG，质量由`IMAGE_QUALITY`常量确定。
- en: 'Now, if the image is saved successfully, we have to update and return the result.
    If something has failed, we have to return an error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果图像保存成功，我们必须更新并返回结果。如果发生错误，我们必须返回一个错误：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For devices running Android Q (API level 29) or higher, after the image is saved,
    the function updates the `MediaStore` entry to indicate that the image is no longer
    pending. This is done by clearing the existing `contentValues`, setting `IS_PENDING`
    to `0` (false), and then updating the `MediaStore` entry with these new values.
    This step is crucial for making the image available to the user and other applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行Android Q（API级别29）或更高版本的设备，在图像保存后，该函数会更新`MediaStore`条目以指示图像不再挂起。这是通过清除现有的`contentValues`，将`IS_PENDING`设置为`0`（false），然后使用这些新值更新`MediaStore`条目来完成的。这一步对于使图像可供用户和其他应用程序使用至关重要。
- en: The entire operation is wrapped in a `runCatching` block, which is a Kotlin
    construct that’s used for simplified exception handling. This block captures any
    exceptions that occur during the `OutputStream` operation or `MediaStore` update.
    If an exception occurs, it is logged, and the function attempts to delete the
    possibly corrupted or incomplete file from `MediaStore`. This cleanup is essential
    to prevent cluttering the storage with unusable files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 整个操作被包裹在一个`runCatching`块中，这是一个Kotlin构造，用于简化异常处理。此块捕获在`OutputStream`操作或`MediaStore`更新期间发生的任何异常。如果发生异常，则会记录，并且函数会尝试从`MediaStore`中删除可能已损坏或不完整的文件。这种清理对于防止存储空间被不可用的文件杂乱无章地占用至关重要。
- en: The function returns `Result<Uri>`, indicating the success or failure of the
    operation. In case of success, `Result.success(uri)` is returned. In case of an
    exception, `Result.failure(exception)` is returned, encapsulating the exception
    details.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回 `Result<Uri>`，表示操作的成功或失败。在成功的情况下，返回 `Result.success(uri)`。在发生异常的情况下，返回
    `Result.failure(exception)`，封装异常详细信息。
- en: 'The only thing left will be to add the parameters that will be used during
    the development of these classes. For simplicity, we will add them as constants,
    but they could also be provided to the class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是添加在开发这些类期间将使用的参数。为了简单起见，我们将它们添加为常量，但它们也可以提供给类：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The next step is to integrate this use case in `StoryEditorViewModel`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此用例集成到 `StoryEditorViewModel` 中。
- en: Integrating SaveCaptureUseCase in StoryEditorViewModel
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 StoryEditorViewModel 中集成 SaveCaptureUseCase
- en: 'Here, we need to create a new property and function in `StoryEditorViewModel`
    to store the captured image:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要在 `StoryEditorViewModel` 中创建一个新的属性和函数来存储捕获的图片：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this `storePhotoInGallery` function, we are just launching a coroutine to
    call the `saveCaptureUseCase.save` method. Then, once we’ve obtained the URI,
    we check if it is not `null` and update the `imageCaptured` property.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `storePhotoInGallery` 函数中，我们只是启动一个协程来调用 `saveCaptureUseCase.save` 方法。然后，一旦我们获得了
    URI，我们检查它是否不是 `null` 并更新 `imageCaptured` 属性。
- en: Finally, we are ready to add this functionality to the UI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好将此功能添加到 UI 中。
- en: Adding the capture functionality to StoryContent
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将捕获功能添加到 StoryContent
- en: 'To add the capture functionality to `StoryContent`, we need to add a Lambda
    to the `StoryContent` composable so that whenever we use `StoryContent`, capture
    handling will be delegated. For example, in our case, we will call the already
    implemented `storePhotoInGallery` function from `StoryEditorViewModel`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要将捕获功能添加到 `StoryContent`，我们需要向 `StoryContent` 可组合函数添加一个 Lambda，以便每次使用 `StoryContent`
    时，捕获处理将被委派。例如，在我们的案例中，我们将调用已实现的 `storePhotoInGallery` 函数从 `StoryEditorViewModel`：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, let’s integrate the code that’s needed to take the capture from our camera:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们集成从我们的相机捕获所需的代码：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The parameters we are using in the previous code block are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的代码块中使用以下参数：
- en: '**context**: The Android context that we will use to obtain **MainExecutor**.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**context**：我们将使用它来获取 **MainExecutor** 的 Android 上下文。'
- en: '**cameraController**: A **LifecycleCameraController** object from **CameraX**,
    which controls the camera’s life cycle and operations.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cameraController**：来自 **CameraX** 的 **LifecycleCameraController** 对象，用于控制摄像头的生命周期和操作。'
- en: '**onPhotoCaptured**: The callback function that will be invoked when a photo
    is successfully captured and processed. It accepts a **Bitmap** as its parameter.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onPhotoCaptured**：当照片成功捕获并处理时将被调用的回调函数。它接受一个 **Bitmap** 作为其参数。'
- en: '**onError**: A callback function to handle any errors that occur during the
    photo capture process.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onError**：一个回调函数，用于处理拍照过程中发生的任何错误。'
- en: 'Let’s continue by defining the necessary properties:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义必要的属性：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we will retrieve `MainExecutor`. This executor is used to run tasks on
    the Android main thread, which is essential for UI updates and certain CameraX
    operations. It is needed for `CameraController`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将检索 `MainExecutor`。这个执行器用于在 Android 主线程上运行任务，这对于 UI 更新和某些 CameraX 操作至关重要。它对于
    `CameraController` 是必需的。
- en: 'Next, we will execute the take picture action:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行拍照动作：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we call the `cameraController.takePicture` method. We will need to provide
    it with the executor and an `ImageCapture.OnImageCapturedCallback` class. This
    class provides callback methods for when an image is successfully captured or
    when an error occurs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们调用 `cameraController.takePicture` 方法。我们需要提供执行器和 `ImageCapture.OnImageCapturedCallback`
    类。这个类提供了在成功捕获图像或发生错误时的回调方法。
- en: 'In the case of success, we will switch to the `onPhotoCaptured` Lambda from
    the main dispatcher. Alternatively, if there is any error, we will receive them
    via the `onError(exception: ImageCaptureException)` callback. Then, we will pass
    the error to the `onError` callback function, which we received as the parameter
    of the `capturePhoto()` function.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '在成功的情况下，我们将从主分发器切换到 `onPhotoCaptured` Lambda。或者，如果有任何错误，我们将通过 `onError(exception:
    ImageCaptureException)` 回调接收它们。然后，我们将错误传递给作为 `capturePhoto()` 函数参数接收的 `onError`
    回调函数。'
- en: 'Now, let’s link the capture functionality with our UI. We already have a button
    for doing the capture in our `StoryContent` composable, `OutlinedButton`, so let’s
    see how we can call this capture function from it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将捕获功能与我们的UI链接起来。在我们的`StoryContent`可组合组件中，我们已经有了一个用于捕获的按钮`OutlinedButton`，所以让我们看看我们如何从它调用这个捕获函数：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, we are calling the `capturePhoto` function from the `onClick`
    button.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们是从`onClick`按钮调用`capturePhoto`函数。
- en: 'With this, we are ready to capture our photos:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好捕捉我们的照片了：
- en: '![Figure 5.2: Image preview with the capture button](img/B19443_05_002.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：带有捕获按钮的图像预览](img/B19443_05_002.jpg)'
- en: 'Figure 5.2: Image preview with the capture button'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：带有捕获按钮的图像预览
- en: With that, we have created a use case so that we can store our photos and link
    the functionality with our already existing UI. Our users can also capture and
    store their photos. Next, let’s see if we can enable them so that we can edit
    some aspects of them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建了一个用例，以便我们可以存储我们的照片并将功能与我们的现有UI链接起来。我们的用户也可以捕捉并存储他们的照片。接下来，让我们看看我们是否可以启用它们，以便我们可以编辑它们的一些方面。
- en: Adding photo-editing functionalities
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加照片编辑功能
- en: 'There are multiple operations that we can enable for the user to edit and modify
    their images: we can allow them to crop, resize, and rotate the image, as well
    as adjust the brightness and contrast, apply filters, or add text overlays.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为用户启用多个操作来编辑和修改他们的图片：我们可以允许他们裁剪、调整大小和旋转图片，以及调整亮度和对比度，应用过滤器，或添加文字覆盖。
- en: 'As part of this chapter, we are going to implement two operations: a black-and-white
    filter and a text overlay.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们将实现两个操作：黑白过滤器和文字覆盖。
- en: Adding filters
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加过滤器
- en: 'Creating filters over an existing image is as easy as modifying the values
    of the bitmap that contains the image. There are several well-known filters, such
    as sepia, vintage, and black and white. As an example, we are going to implement
    the black and white filter, like so:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有图片上创建过滤器就像修改包含图片的位图值一样简单。有几个著名的过滤器，如棕褐色、复古和黑白。作为一个例子，我们将实现黑白过滤器，如下所示：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function starts by accepting `imageUri`, which is the URI representing
    the image to be displayed, and an optional modifier parameter to customize the
    layout.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先接受`imageUri`，它表示要显示的图片的URI，以及一个可选的修饰符参数来定制布局。
- en: Within the function, a state variable called `isBlackAndWhiteEnabled` is declared
    using `remember` and `mutableStateOf`, which tracks whether the black-and-white
    filter is applied. Here, `LocalContext.current` provides the context needed to
    load the image from the URI.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，使用`remember`和`mutableStateOf`声明了一个名为`isBlackAndWhiteEnabled`的状态变量，该变量跟踪是否应用了黑白过滤器。在这里，`LocalContext.current`提供了从URI加载图片所需的上下文。
- en: A `Box` composable is used to contain the entire layout, ensuring that the content
    fills the available space. Inside `Box`, a `Canvas` composable is used to draw
    the image. The `Canvas` modifier is set to fill the available size.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Box`可组合组件来包含整个布局，确保内容填充可用空间。在`Box`内部，使用`Canvas`可组合组件来绘制图像。将`Canvas`修饰符设置为填充可用大小。
- en: The `Canvas` composable uses the `getBitmapFromUri` function to load the image
    as a `Bitmap`, which is then converted into `ImageBitmap` using the `asImageBitmap`
    extension function. If the `isBlackAndWhiteEnabled` state is true, a `ColorMatrix`
    value with zero saturation is applied to create a black-and-white `ColorFilter`.
    Otherwise, no color filter is applied.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`可组合组件使用`getBitmapFromUri`函数将图片作为`Bitmap`加载，然后使用`asImageBitmap`扩展函数将其转换为`ImageBitmap`。如果`isBlackAndWhiteEnabled`状态为真，则应用一个饱和度为零的`ColorMatrix`值来创建黑白`ColorFilter`。否则，不应用颜色过滤器。'
- en: The `getCanvasImageOffset` and `getCanvasImageScale` functions are used to calculate
    the offset and scale factor needed to center and scale the image within the canvas.
    The `with(drawContext.canvas)` block is used to draw the image. Within this block,
    `save` and `restore` are called to save and restore the canvas state, ensuring
    that transformations do not affect subsequent drawing operations. The `translate`
    function applies the calculated offsets, and the `scale` function applies the
    scale factor, to fill the entire `Canvas` with the image. Finally, the `drawImage`
    function draws the image on the canvas with the optional color filter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCanvasImageOffset`和`getCanvasImageScale`函数用于计算将图像居中和缩放所需的偏移量和缩放因子。`with(drawContext.canvas)`块用于绘制图像。在此块内，调用`save`和`restore`以保存和恢复画布状态，确保变换不会影响后续的绘图操作。`translate`函数应用计算出的偏移量，而`scale`函数应用缩放因子，以将整个`Canvas`填满图像。最后，`drawImage`函数使用可选的颜色过滤器在画布上绘制图像。'
- en: Below `Canvas`, a `Button` composable is placed within `Box`. This button is
    used to toggle the `isBlackAndWhiteEnabled` state when clicked. The button’s `onClick`
    Lambda updates the state variable, and the button’s text is set to **Apply Black
    and White Filter**. The modifier parameter for the button includes padding to
    ensure it is not placed at the edge of the screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Canvas`下方，一个`Button` composable被放置在`Box`内。此按钮用于在点击时切换`isBlackAndWhiteEnabled`状态。按钮的`onClick`
    Lambda更新状态变量，按钮的文本设置为**应用黑白过滤器**。按钮的修饰参数包括填充，以确保它不会放置在屏幕边缘。
- en: Now that we have built our first filter, let’s learn how to implement text overlays.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了第一个过滤器，让我们学习如何实现文本叠加。
- en: Adding a text overlay
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加文本叠加
- en: Adding a text overlay is a typical image editing functionality that allows us
    to tag other people, add a hashtag to an image, or add an accompanying written
    message. Let’s see how we can offer our users this functionality.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文本叠加是典型的图像编辑功能，允许我们标记其他人，给图像添加标签，或添加伴随的书面信息。让我们看看我们如何为用户提供此功能。
- en: 'First, we are going to create a composable that contains the state of the `Text`
    and `Image` components. This state will update as the user updates the text. Here’s
    the code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个包含`Text`和`Image`组件状态的composable。当用户更新文本时，此状态将更新。以下是代码：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This example defines a composable function called `ImageWithTextOverlay`. It
    accepts a bitmap object named `capturedBitmap`, which represents the captured
    image that will be displayed with a text overlay.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了一个名为`ImageWithTextOverlay`的composable函数。它接受一个名为`capturedBitmap`的位图对象，该对象表示将带有文本叠加显示的捕获图像。
- en: 'The function starts by defining two pieces of state:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先定义了两件状态：
- en: First, we have **textOverlay**, which holds the text that will be displayed
    over the image. It’s initially set to a default value of **Add your** **text here**.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有**textOverlay**，它包含将在图像上显示的文本。它最初设置为默认值**在此处添加您的文本**。
- en: Then, we have a **showTextField** Boolean, which determines whether the text
    editing field (**TextField**) is visible or not. It’s initially set to **false**.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个**showTextField**布尔值，它确定文本编辑字段（**TextField**）是否可见。它最初设置为**false**。
- en: Within the function, we use a `Box` composable as a container. The `Box` composable
    allows us to layer its child components, and we set its size to fill the maximum
    available space. This creates an area where we can overlay text on top of an image.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们使用`Box` composable作为容器。`Box` composable允许我们堆叠其子组件，并将大小设置为填充最大可用空间。这创建了一个可以在图像上叠加文本的区域。
- en: The first child of the `Box` composable is an `Image` composable, which is responsible
    for displaying the captured photo. The photo is passed to this function as a bitmap,
    and we ensure that it fills the entire parent container, ensuring that the image
    takes up the whole screen space available.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box` composable的第一个子项是一个`Image` composable，它负责显示捕获的照片。照片作为位图传递给此函数，我们确保它填充整个父容器，确保图像占据整个屏幕空间。'
- en: Next, we check the state of `showTextField`. If it’s `true`, we display `TextField`
    in the center of the screen. This `TextField` allows the user to input or edit
    the text that will be overlaid on the image. As the user types, the text in `textOverlay`
    is updated in real time thanks to the two-way binding provided by Jetpack Compose.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`showTextField`的状态。如果它是`true`，我们在屏幕中心显示`TextField`。此`TextField`允许用户输入或编辑将叠加到图像上的文本。由于Jetpack
    Compose提供的双向绑定，用户键入时，`textOverlay`中的文本会实时更新。
- en: Regardless of the state of `showTextField`, we always display a `Text` composable.
    This component is responsible for rendering the overlay text on top of the image.
    We style this text to be white and of a reasonable font size, ensuring it’s visible
    against a variety of backgrounds.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 `showTextField` 的状态如何，我们总是显示一个 `Text` 可组合组件。这个组件负责在图像上渲染叠加文本。我们为这个文本设置白色和合理的字体大小，确保它在各种背景上都是可见的。
- en: Finally, at the bottom corner of the `Box` composable, we place `FloatingActionButton`.
    This button, when clicked, toggles the visibility of `TextField`, allowing the
    user to switch between viewing the overlaid text and editing it. The button is
    intuitively designed with an edit icon, signaling its purpose to the user.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `Box` 可组合组件的底部角落放置 `FloatingActionButton`。当按钮被点击时，它会切换 `TextField` 的可见性，使用户能够在查看叠加文本和编辑文本之间切换。按钮的设计直观，带有编辑图标，向用户传达其功能。
- en: 'Now, imagine that we want to allow the user to move the text whenever they
    want in the image. Let’s implement some drag-and-drop magic. We will start by
    updating the `ImageWithTextOverlay` composable function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要允许用户在图像中随时移动文本。让我们实现一些拖放魔法。我们将从更新 `ImageWithTextOverlay` 可组合函数开始：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this updated version of the `ImageWithTextOverlay` composable function, we’ve
    introduced an interactive feature that allows users to drag and position the text
    overlay anywhere on the image. To achieve this, we added a new state variable,
    `textPosition`, initialized to `Offset.Zero`. This state holds the current position
    of the text overlay on the screen. Now, we must create a new composable function,
    `DraggableText`, to handle the text display and its draggable functionality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新版本的 `ImageWithTextOverlay` 可组合函数中，我们引入了一个交互功能，允许用户将文本叠加拖放到图像上的任何位置。为了实现这一点，我们添加了一个新的状态变量
    `textPosition`，初始化为 `Offset.Zero`。这个状态保存文本叠加在屏幕上的当前位置。现在，我们必须创建一个新的可组合函数 `DraggableText`
    来处理文本显示及其可拖动功能。
- en: 'Let’s add this `DraggableText` to our existing code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个 `DraggableText` 添加到现有的代码中：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the existing functionality for editing the text through `TextField` is
    the same. The `TextField` field appears when the user wishes to edit the text,
    facilitated by a floating action button. This button toggles the visibility of
    `TextField`, allowing users to switch seamlessly between editing the text and
    adjusting its position.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过 `TextField` 编辑文本的现有功能相同。当用户想要编辑文本时，`TextField` 字段会出现，由一个浮动操作按钮提供便利。这个按钮切换
    `TextField` 的可见性，使用户能够在编辑文本和调整其位置之间无缝切换。
- en: 'Now, we are ready to create the `DraggableText` composable:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好创建 `DraggableText` 可组合组件：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `DraggableText` composable takes several parameters, including the text
    to display, its current position, and a callback function, `onPositionChange`,
    which updates this position. Within `DraggableText`, we utilize the draggable
    modifier on the `Text` composable. This modifier is pivotal as it allows the text
    to be moved across the screen. As the user drags the text, the drag offset is
    updated, which, in turn, updates the `textPosition` state in the main `ImageWithTextOverlay`
    function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`DraggableText` 可组合组件接受多个参数，包括要显示的文本、其当前位置以及一个回调函数 `onPositionChange`，该函数更新此位置。在
    `DraggableText` 中，我们利用 `Text` 可组合组件上的可拖动修饰符。这个修饰符至关重要，因为它允许文本在屏幕上移动。当用户拖动文本时，拖动偏移量会更新，进而更新主
    `ImageWithTextOverlay` 函数中的 `textPosition` 状态。'
- en: 'Finally, define the variables that are needed and the `Text` composable to
    show the text:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义所需的变量和用于显示文本的 `Text` 可组合组件：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We begin by initializing a state to hold the current drag offset. This state
    will track the position of the text as it is dragged.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化一个状态来保存当前的拖动偏移量。这个状态将跟踪文本被拖动时的位置。
- en: Next, we define the `Text` composable to display our draggable text. To control
    the positioning of the text, we use the offset modifier, which positions the text
    based on the current drag offset.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `Text` 可组合组件来显示我们的可拖动文本。为了控制文本的位置，我们使用偏移修饰符，该修饰符根据当前的拖动偏移量定位文本。
- en: The `pointerInput` modifier allows us to handle drag gestures on the text element.
    Within the `detectDragGestures` block, we update the drag offset by adding the
    drag amount to the current offset each time the user drags the text. The gesture
    change is consumed to indicate that the drag event has been handled, and we call
    a function to handle any additional actions that are needed when the position
    changes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointerInput`修饰符允许我们处理文本元素上的拖拽手势。在`detectDragGestures`块中，我们通过将拖拽量添加到当前偏移量来更新拖拽偏移量，每次用户拖拽文本时都会这样做。手势变化被消耗以指示拖拽事件已被处理，并且我们调用一个函数来处理位置变化时所需的任何附加操作。'
- en: 'And with that, here are the two filters we have created:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，以下是我们已经创建的两个滤镜：
- en: '![Figure 5.3: The black and white filter composable (left) and text overlay
    (right)](img/B19443_05_003.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：黑白滤镜组件（左）和文本叠加（右）](img/B19443_05_003.jpg)'
- en: 'Figure 5.3: The black and white filter composable (left) and text overlay (right)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：黑白滤镜组件（左）和文本叠加（右）
- en: At this point, we have already implemented some cool features for our users,
    such as a black-and-white filter and the possibility to add a caption. So, why
    don’t leverage the use of ML to build outstanding features? We’ll look at this
    in the next section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为用户实现了一些酷炫的功能，例如黑白滤镜和添加字幕的可能性。那么，为什么不利用机器学习来构建出色的功能呢？我们将在下一节中探讨这一点。
- en: Using ML to categorize photos and generate hashtags
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习对照片进行分类并生成标签
- en: ML is a branch of **artificial intelligence** (**AI**) that focuses on building
    systems that can learn from and make decisions based on data. Unlike traditional
    software, which follows explicitly programmed instructions, ML algorithms use
    statistical techniques to enable computers to improve at tasks with experience.
    The fundamental premise of ML is to develop algorithms that can receive input
    data and use statistical analysis to predict or make decisions about some aspect
    of the data.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是**人工智能**（**AI**）的一个分支，专注于构建可以从数据中学习和基于数据做出决策的系统。与遵循明确编程指令的传统软件不同，机器学习算法使用统计技术使计算机能够通过经验提高任务性能。机器学习的基本前提是开发能够接收输入数据并使用统计分析来预测或对数据的一些方面做出决策的算法。
- en: 'ML is a huge field that is outside the scope of this book, but we still can
    do interesting things using already-built libraries. For example, **ML Kit** is
    a powerful ML solution offered by Google for mobile developers that provides a
    suite of ready-to-use APIs for various ML tasks, both on-device and cloud-based.
    These functionalities are designed to be easily integrated into mobile applications,
    facilitating the use of ML without requiring deep expertise in the field. Here’s
    an overview of the key functionalities offered by ML Kit:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个巨大的领域，超出了本书的范围，但我们仍然可以使用现成的库做一些有趣的事情。例如，**ML Kit**是Google为移动开发者提供的强大机器学习解决方案，它提供了一系列现成的API，用于各种机器学习任务，包括设备端和基于云的任务。这些功能被设计成易于集成到移动应用程序中，便于使用机器学习而无需在该领域有深入的专业知识。以下是ML
    Kit提供的关键功能概述：
- en: '**Image labeling**: Identifies objects, locations, activities, animal species,
    products, and more within an image.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像标注**：在图像中识别对象、位置、活动、动物种类、产品等。'
- en: '**Text recognition**: Extracts text from images. This can be useful for **optical
    character recognition** (**OCR**) applications, such as scanning documents, business
    cards, or any printed or handwritten text.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本识别**：从图像中提取文本。这可以用于**光学字符识别**（**OCR**）应用，例如扫描文档、名片或任何打印或手写的文本。'
- en: '**Face detection**: Detects faces in an image, including key facial features
    such as eyes and nose, and characteristics such as smiles or head tilt. This is
    useful in applications such as photo tagging and facial recognition.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人脸检测**：在图像中检测人脸，包括眼睛和鼻子等关键面部特征，以及微笑或头部倾斜等特征。这在照片标记和面部识别等应用中非常有用。'
- en: '**Barcode scanning**: Reads and scans barcodes and QR codes. It supports various
    formats, including UPC, EAN, Code 39, and others.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条码扫描**：读取和扫描条码和二维码。它支持包括UPC、EAN、Code 39在内的各种格式。'
- en: '**Object detection and tracking**: Identifies and tracks objects in an image
    or video stream. This feature is useful in scenarios such as real-time video analysis.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标检测和跟踪**：在图像或视频流中识别和跟踪对象。这个功能在实时视频分析等场景中非常有用。'
- en: You can learn more about ML Kit’s features at [https://developers.google.com/ml-kit](https://developers.google.com/ml-kit).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developers.google.com/ml-kit](https://developers.google.com/ml-kit)了解更多关于ML
    Kit的功能。
- en: 'As an example, we are going to create the logic to identify and label elements
    in the photo that could be used in the future to categorize the images or create
    automatic hashtags. We will start by adding the corresponding dependencies to
    `libs.versions.toml`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将创建识别和标记照片中元素的逻辑，这些元素将来可用于对图像进行分类或创建自动标签。我们首先将相应的依赖项添加到 `libs.versions.toml`：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we will add these dependencies to the `build.gradle` file of the module.
    This is where we are creating this functionality (`feature:stories`):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将将这些依赖项添加到模块的 `build.gradle` 文件中。这是创建此功能的地方 (`feature:stories`)：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we can create the actual code. We are going to leverage the image analysis
    feature from CameraX and analyze the preview using MLKitLabeling before using
    the results to write them in over the image. To do this, we will create a new
    preview composable just for this feature:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建实际的代码。我们将利用 CameraX 的图像分析功能，在将结果写入图像之前使用 MLKitLabeling 分析预览。为此，我们将创建一个新的预览组合器，专门用于此功能：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The start of this function is pretty similar to our already existing `CameraPreview`
    composable. After the camera provider is defined, an `ImageAnalysis` instance
    is configured with a target resolution of 1,280x720 pixels and a backpressure
    strategy set to `STRATEGY_KEEP_ONLY_LATEST` to process the latest image frame.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的开始与我们的现有 `CameraPreview` 组合器非常相似。在定义相机提供者之后，配置一个 `ImageAnalysis` 实例，目标分辨率为
    1,280x720 像素，并将背压策略设置为 `STRATEGY_KEEP_ONLY_LATEST` 以处理最新的图像帧。
- en: The `imageAnalysis.setAnalyzer` method sets an analyzer to process image frames
    using ML Kit’s Image Labeler. The `processImageProxyForLabeling` function is called
    to process each image frame. The detected labels are passed to a Lambda function
    that updates the `labels` state variable. We will see how to implement this function
    shortly.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`imageAnalysis.setAnalyzer` 方法设置一个分析器，使用 ML Kit 的图像标签器处理图像帧。调用 `processImageProxyForLabeling`
    函数来处理每个图像帧。检测到的标签传递给一个 Lambda 函数，该函数更新 `labels` 状态变量。我们很快就会看到如何实现这个函数。'
- en: In the end, the `Box` composable is used to overlay `PreviewView` and a `Canvas`
    composable. The `Canvas` composable is used to draw the detected labels on top
    of the camera preview. The `drawIntoCanvas` method accesses the native `canvas`
    for drawing. A `Paint` object is configured with a red color and a text size of
    60 pixels. The `forEachIndexed` method iterates over the labels list, drawing
    each label at a specified position on the canvas.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `Box` 组合器将 `PreviewView` 和 `Canvas` 组合器叠加。`Canvas` 组合器用于在相机预览上绘制检测到的标签。`drawIntoCanvas`
    方法访问原生的 `canvas` 进行绘制。配置一个 `Paint` 对象，颜色为红色，文本大小为 60 像素。`forEachIndexed` 方法遍历标签列表，在画布上指定位置绘制每个标签。
- en: 'Now, let’s learn how we can implement the image analyzer:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何实现图像分析器：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function takes the `ImageProxy` object and a callback function, `onLabelsDetected`,
    as parameters, where the callback function is invoked with a list of detected
    labels.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受 `ImageProxy` 对象和一个回调函数 `onLabelsDetected` 作为参数，其中回调函数使用检测到的标签列表调用。
- en: Within the function, `mediaImage` is extracted from the `ImageProxy` object.
    If `mediaImage` is not `null`, it is converted into `InputImage` using the `InputImage.fromMediaImage`
    method, which requires the media image and the rotation degrees from `imageProxy`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，`mediaImage` 从 `ImageProxy` 对象中提取出来。如果 `mediaImage` 不是 `null`，则使用 `InputImage.fromMediaImage`
    方法将其转换为 `InputImage`，这需要从 `imageProxy` 获取媒体图像和旋转角度。
- en: An instance of the image labeler is obtained by calling `ImageLabeling.getClient`
    with `ImageLabelerOptions.DEFAULT_OPTIONS`. This sets up the labeler with default
    configuration options suitable for general-purpose image labeling.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `ImageLabeling.getClient` 并传入 `ImageLabelerOptions.DEFAULT_OPTIONS` 来获取图像标签器的实例。这设置了具有适合通用图像标签的默认配置选项的标签器。
- en: 'The `labeler.process` method processes `InputImage` asynchronously. After,
    the processing outcome is handled by two listeners:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`labeler.process` 方法异步处理 `InputImage`。之后，处理结果由两个监听器处理：'
- en: In **addOnSuccessListener**, the function receives a list of labels if the processing
    is successful. Each label in this list represents an element identified in the
    image, accompanied by a confidence score. The function iterates through these
    labels, logging the identified element (**label.text**) and its confidence score
    (**label.confidence)**. In future iterations, we could use this information to
    auto-create automatic overlays over the image or to inform the user of which could
    be the best hashtags for the image.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**addOnSuccessListener**中，如果处理成功，函数将接收一个标签列表。列表中的每个标签代表图像中识别出的元素，并附带一个置信度分数。函数遍历这些标签，记录识别出的元素（**label.text**）及其置信度分数（**label.confidence**）。在未来的迭代中，我们可以使用这些信息来自动创建图像上的自动覆盖，或告知用户哪些可能是最佳的图片标签。
- en: In case of any failure during image processing, **addOnFailureListener** is
    invoked, which logs the error. This error handling is crucial for diagnosing issues
    that might occur during the ML process, such as problems with the input image
    or internal errors in the ML Kit processing pipeline.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像处理过程中出现任何故障时，将调用**addOnFailureListener**，该监听器会记录错误。这种错误处理对于诊断ML过程中可能发生的问题至关重要，例如输入图像问题或ML
    Kit处理管道中的内部错误。
- en: 'Now, if we replace our `CameraPreview` composable with the `CameraPreviewImageLabeler`
    composable, we should see the results of the image analysis taking place:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用`CameraPreview`可组合组件替换为`CameraPreviewImageLabeler`可组合组件，我们应该能看到图像分析的结果：
- en: '![Figure 5.4: ML labeling taking place in the live preview](img/B19443_05_004.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：在实时预览中进行的ML标记](img/B19443_05_004.jpg)'
- en: 'Figure 5.4: ML [labeling taking place in the liv](https://developer.android.com/ml)e
    preview'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：在实时预览中进行的ML[标记](https://developer.android.com/ml)
- en: If you want to know more about what can be done with the ML Kit library, check
    out [https://developer.android.com/ml](https://developer.android.com/ml).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于ML Kit库可以做什么的信息，请查看[https://developer.android.com/ml](https://developer.android.com/ml)。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by familiarizing ourselves with CameraX, a key component
    of the Android Jetpack suite. We learned how to set up CameraX in our applications
    while enabling features such as live camera preview and image capture.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先熟悉了CameraX，它是Android Jetpack套件的关键组件。我们学习了如何在应用中设置CameraX，同时启用实时相机预览和图像捕获等功能。
- en: Moving on, we delved into the practical implementation of capturing images using
    CameraX. Additionally, we introduced basic image editing functionalities, guiding
    you through the process of creating a filter and adding a text overlay. These
    skills are pivotal in enhancing the interactivity and user experience of photography
    apps.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入探讨了使用CameraX捕获图像的实际实现。此外，我们介绍了基本的图像编辑功能，指导您创建过滤器并添加文本覆盖的过程。这些技能对于增强摄影应用的交互性和用户体验至关重要。
- en: Finally, we unveiled the integration of Google’s ML Kit, demonstrating how to
    add advanced ML capabilities to the app. We explored how to use ML Kit to identify
    elements in images, such as objects. This experience highlighted the practical
    application of these technologies in enhancing the functionality of photography
    apps.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了Google的ML Kit的集成，演示了如何将高级ML功能添加到应用中。我们探讨了如何使用ML Kit识别图像中的元素，如物体。这次体验突出了这些技术在增强摄影应用功能方面的实际应用。
- en: At this point, you should have gained valuable insights and practical skills
    in building feature-rich photography apps using CameraX and ML Kit.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经获得了使用CameraX和ML Kit构建功能丰富摄影应用的有价值见解和实用技能。
- en: In the next chapter, we will give life to those images by learning how to capture
    and edit video for our Packtagram app.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何为Packtagram应用捕获和编辑视频，为这些图像注入生命。
