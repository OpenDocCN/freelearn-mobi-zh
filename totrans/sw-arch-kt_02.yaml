- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Principles of Software Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover the fundamental principles of software
    architecture. They are vitally important to every part of software architecture.
    We should constantly remind ourselves of these, just like professional pianists
    practice scales every day.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go through different ways to describe and view software architecture first.
    Then we’ll cover a few important principles that will be referenced in later chapters.
    It is intended that you might go back to this chapter anytime and contemplate
    again some of these key concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Perspectives, dimensions, and qualities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns, cohesiveness, and coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAGNI and future-proof architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Law of Demeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/Packt
    Publishing/Software-Architecture-with-Kotlin/tree/main/chapter-2](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-2%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Perspectives, dimensions, and qualities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software systems are not physical objects that we can easily see or touch. At
    their roots, they are instructions that are interpreted by a machine. So, we will
    need to visualize software systems in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: The major purpose of visualizing software systems is to demonstrate how stakeholder
    concerns are addressed. There is usually a lengthy list of concerns. Each stakeholder
    usually has multiple concerns at various levels of abstraction. It is not possible
    to address all concerns from all angles in one visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of **View** was introduced in the 1970s to describe software architecture.
    Since then, there have been numerous efforts to codify and standardize methods
    in describing software architecture. **ISO/IEC/IEEE 42010:2022** is the current
    standard in specifying software architecture, by which the architectural concepts,
    structure, and language are defined.
  prefs: []
  type: TYPE_NORMAL
- en: In a View, only selected perspectives of software architecture are portrayed.
    The selection aims at addressing certain stakeholder concerns. Moreover, there
    are multiple Views so each View can target specific concerns and specific stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: A **View Model** is a collection of Views wherein each View has a dedicated
    focus, purpose, and language for visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The **4+1 architecture view model** was created by Philippe Kruchten in 1995\.
    It includes four views of a software system, plus selected scenarios that help
    different stakeholders understand the software system from the perspectives of
    other stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A 4+1 architecture view model](img/B21737_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – A 4+1 architecture view model
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each view from the 4+1 architecture view model in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Logical view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **logical view** focuses on the business functionality of the system and
    how it is implemented. It is agnostic to the technical concerns. It is an abstract
    view of how a business feature works without involving technical terms, using
    the language that both technical and non-technical stakeholders understand. It
    is suitable for communication with non-technical stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example of the state transition of a service exchange contract between
    households, the logical view is expressed in the UML state diagram that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – A 4+1 architecture view model – logical view](img/B21737_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – A 4+1 architecture view model – logical view
  prefs: []
  type: TYPE_NORMAL
- en: A service contract between two households is first drafted by one household.
    The contract is of the **Drafted** state. Once the draft is complete, the household
    submits the contract to be reviewed by the other household.
  prefs: []
  type: TYPE_NORMAL
- en: The contract could be amended by both households before they reach an agreement.
    Both households must agree to the terms before going further. However, in some
    cases, the contract may be rejected by a household and thus enter the **Rejected**
    terminal state.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that both households agreed to the terms, there is still a chance that
    the contract could be withdrawn due to other circumstances. Assuming that the
    contract goes ahead, both households then exercise and fulfill the terms of the
    contract. This concludes the contract and reaches the end of its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Physical view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **physical view** focuses on the deployable software components and the
    interconnections between them. It is also called the **deployment view**. It is
    suitable for communication with system engineers, platform engineers, and infrastructure
    engineers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that the ADR example we demonstrated in the previous chapter was approved.
    There is a central service to keep the master records of service exchange contracts.
    The physical view may look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – A 4+1 architecture view model – physical view](img/B21737_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – A 4+1 architecture view model – physical view
  prefs: []
  type: TYPE_NORMAL
- en: The software has been moved to a browser-based web application. Users access
    the system via a web browser as a client and submit requests for service. The
    load balancer is the first component to receive these requests and distribute
    them to the appropriate instance of the **Exchange service** based on the load
    of each instance. Any static content such as images is fetched from a web server.
    The **Exchange service** processes the request and persists the result in the
    **Relational database**.
  prefs: []
  type: TYPE_NORMAL
- en: Process View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **process view** focuses on the real-time behaviors of the system. It is
    usually close to the system’s operation, where internal employees or other systems
    are involved. It is useful in showcasing issues involving concurrency, performance,
    and scalability. This view facilitates communication among technical stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: UML diagrams such as sequence diagrams, interaction diagrams, activity diagrams,
    communication diagrams, and timing diagrams are useful to represent a process
    view. **Business Process Modeling and Notation** (**BPMN**) diagrams are also
    useful in describing how the system behaves in the context of business processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the service contract exchange system has an email notification function,
    it may look like the figure that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – A 4+1 architecture view model – process view](img/B21737_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – A 4+1 architecture view model – process view
  prefs: []
  type: TYPE_NORMAL
- en: When **Household A** submits a draft contract, the **Exchange service** validates
    the request and updates the corresponding records in the **Relational database**.
    Afterward, the **Exchange service** makes a call to the **Email service** to send
    an email notification to **Household B** for the service contract submitted by
    **Household A**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Household B**, in this case, is notified of the service contract in the email.
    Then **Household B** submits a request to agree to the contract terms to the **Exchange
    service**. The **Exchange service** then updates the records in the **Relational
    database**.'
  prefs: []
  type: TYPE_NORMAL
- en: Development view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **development view** concentrates on software management. The target audience
    is programmers who are coding hands-on in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The view focuses on the static organization of the software in the development
    environment. This includes how multiple components collaborate to form a software
    system at various levels, such as packages of source code, call hierarchies from
    higher-order business functions to lower-level utility functions, inheritance
    hierarchies of classes, and dependency trees of software artifacts. The details
    of this view can be found in the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: UML package and component diagrams can be used to represent this view. An organized
    source code repository may find these diagrams redundant. However, these diagrams
    are good at highlighting any dependency issues between packages and modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Exchange service** in the service contract exchange system may be expressed
    in a UML package diagram, as in the figure that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – A 4+1 architecture view model – development view](img/B21737_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – A 4+1 architecture view model – development view
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Exchange service** has a business package that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A module that controls the workflow of a service contract
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A module that master’s the records of households
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A module that searches the history of service contracts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Business** package uses the **Persistence** package to perform the actual
    relational database operations for service contracts and households.
  prefs: []
  type: TYPE_NORMAL
- en: The **Business** package has a dependency on the **Validation** package, which
    contains a few standalone validators for addresses, emails, dates, and service
    contracts.
  prefs: []
  type: TYPE_NORMAL
- en: The **Integration** module is responsible for communicating with other services
    such as the **Email service**. This module is used by the **Business** module
    to notify households.
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the 4+1 architecture view model, scenarios are represented by the *+1* because
    only important scenarios would be chosen to be documented. It focuses on user-system
    interactions and on how the system facilitates users in their workflow. It is
    often used in communication with users, both internal and external.
  prefs: []
  type: TYPE_NORMAL
- en: UML use case diagrams are used for scenarios. In the example of the service
    contract exchange system, the drafting and exercising of the service contract
    are selected use cases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – A 4+1 architecture view model – scenario](img/B21737_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – A 4+1 architecture view model – scenario
  prefs: []
  type: TYPE_NORMAL
- en: '**Household A** submits a drafted contract to be reviewed by **Household B**.
    The contract can be amended before it is agreed to. Once the households agree
    to the contract terms, they exercise the service contract to completion.'
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the 4+1 architecture view model, which visualizes the architecture
    of a system from at least five perspectives. Each perspective visualizes the system
    using different dimensions to highlight certain aspects at a time. Each view is
    useful in communicating with its own audience.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to explore system quality attributes, which can be used to
    describe, measure, and predict how well a system can perform.
  prefs: []
  type: TYPE_NORMAL
- en: System quality attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are two functionally identical systems, how might we compare and evaluate
    which system performs better? We can use system quality attributes to measure
    and compare the two systems.
  prefs: []
  type: TYPE_NORMAL
- en: System quality attributes exist independently of the business functions that
    the system provides. They are purely technical attributes that determine whether
    a system runs smoothly or not. The requirements to have certain system quality
    attributes are called **Non-Functional Requirements** (**NFRs**) or **Cross-Functional**
    **Requirements** (**CFRs**).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to differentiate between functional requirements and NFRs. Functional
    requirements define what the system does, while NFRs define how the requirements
    are fulfilled. Functional requirements specify the features of a system, while
    NFRs define its qualities, behaviors, and performance characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many dimensions for system quality attributes. Here we will highlight
    several system quality attributes that we will cover in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Correctness**: This measures whether the system behaves as described in the
    specifications. This could be referred to as **Application Programming Interface**
    (**API**) documentation, operation manuals, or simply function contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: This measures the uptime of the system or the time when it
    can operate and serve its purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robustness**: This refers to the level of service the system can provide
    when the system has faulty parts and/or is under heavy traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: This refers to how quickly the system can recover from faults,
    continue to operate, and bounce back from unexpected disruption to a fully functional
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: This measures how quickly the system can respond to requests
    and how many requests the system can process at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: This measures how flexibly the system can scale to cope with
    changing the volume and latency requirements. It is the ability of the system
    to expand or shrink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observability**: This refers to how well the external view of the system
    helps us determine its internal state. The external view can be represented by
    log messages, charts, alerts, files, or the payload of a system remote call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manageability**: This measures how easy it is to manage and control a system
    in terms of operations, monitoring, configuration, and administration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: This measures how easy it is to maintain a working system.
    This can include source code, updating infrastructure, modifying build pipelines,
    and tweaking environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: This measures the ease of extending the current capability
    of the system to include new functions as the business grows. It includes the
    time, complexity, and effort required to modify and enhance the current system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: This measures the extent to which tests can cover the functionality
    of the system. It is not limited to the business functions to be tested but also
    includes the assessment of other system quality attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: This refers to the extent to which the individual components
    of the system can be reused for other purposes. This includes not only the software
    modules and source code but also the business functions and processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: This translates to how good the user experience is while working
    with the system. It is not limited to end users who treat the system as a black
    box but also includes other stakeholders such as internal users, system operators,
    administrators, and programmers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered a few important system quality attributes that we will mention
    in later chapters. We are going to discuss the fundamental architecture principles
    that drive modern software architecture and help us improve current systems.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns, cohesiveness, and coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A system is composed of many components and the interconnections among them.
    The ability to group and separate elements in the system has become a crucial
    factor in ensuring it is maintainable, reusable, and extendable. We are going
    to cover three fundamental concepts that will help us group and separate elements
    appropriately, namely **separation of concerns**, **cohesiveness**, and **coupling**.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Separation of concerns is a fundamental principle that we should apply in every
    corner of the system. It is a principle that advocates segregating the system
    into independent components and having each component address a specific concern.
    Separation of concerns aims at creating a system that is easier to maintain, reason,
    and update, and which can adapt to changes in requirements over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take the following scenario as an example: the submission of a draft
    service exchange contract from a household’s browser to **Exchange service** via
    **Representational State Transfer** (**REST**) with payload in the **JavaScript
    Object Notation** (**JSON**) format.'
  prefs: []
  type: TYPE_NORMAL
- en: The first concern will likely be to ensure that **Exchange service** only takes
    the correct information to create a draft service in the **Relational database**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the correctness category, there are multiple levels:'
  prefs: []
  type: TYPE_NORMAL
- en: The request payload needs to conform to the agreed structure; otherwise, an
    HTTP `400` (Bad request) status should be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The services to be exchanged must not be empty; otherwise, an HTTP `400` (Bad
    request) status should be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The households in the contract must already exist in the system records; otherwise,
    an HTTP `404` (Not found) status should be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The household that submitted the draft contract must already have logged on;
    otherwise, an HTTP `401` (Unauthorized) status should be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The household that submitted the draft contract must already have been verified;
    otherwise, an HTTP `403` (Forbidden) status should be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request passes all validation checks and the contract persists, an HTTP
    `200` (OK) status should be returned with the payload of the persisted record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request passes all validation and the contract persists, the contract
    should be in the **Drafted** state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list goes on. However, we could see that, for example, the payload is at
    the syntactical level. Returned HTTP statuses, on the other hand, are at the contractual
    communication level, while being in the correct state is at a semantic level.
  prefs: []
  type: TYPE_NORMAL
- en: If a change addressing one concern for a part of the system is made without
    affecting the other concerns, then this change is aligned with the separation
    of concerns principle.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to separate concerns when modifying a system, some parts of the system
    will need to be grouped together and other parts need to be separated.
  prefs: []
  type: TYPE_NORMAL
- en: The degree to which the software elements within a component are closely related
    can be measured by cohesiveness. The degree of independence of each component
    can be measured by coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Cohesiveness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software components that are strongly related to each other have a few properties.
    Firstly, they share similar responsibilities and most likely have a common objective.
    Secondly, if you change one component, it is likely that the rest of the components
    will require changes as well. Finally, they coordinate and cooperate in at least
    one manner. Chained function calls are examples of cohesive components.
  prefs: []
  type: TYPE_NORMAL
- en: Software components can be cohesive in the following ways.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal cohesiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Horizontally cohesive components are grouped together to provide features related
    to a certain implementation. For example, components related to integration with
    a particular external system are grouped together to separate the concerns of
    vendor-specific implementation from the functional behaviors that the system provides.
    In the case of reviewing vendor choices, engineers can replace this group of components
    with another group that targets a different vendor system. This cohesive approach
    supports a plug-and-play structure that is easy to maintain and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical cohesiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vertically cohesive components are grouped together based on the functional
    behaviors that they collectively provide. Vertical cohesiveness usually involves
    **encapsulation** of data and behaviors shared among components in the group.
    For example, components responsible for providing **Create, Read, Update, Delete**
    (**CRUD**) operations for managing households can be grouped together. This grouping
    provides clarity on how the system behaves. When the behaviors must be modified,
    engineers can focus on a small area and lower the risk of change.
  prefs: []
  type: TYPE_NORMAL
- en: Linear cohesiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linearly cohesive components are grouped together due to the sequence of their
    execution or the flow of control. This could be manifested by chains of function
    calls or by a chained reaction of event communication. This grouping provides
    clarity and visibility for how smaller tasks or processes emerge into a larger
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive cohesiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interactively cohesive components are grouped based on the frequency of communication
    and interaction patterns among them. For example, the HTTP service and the client
    library of a certain function are grouped under a project of different modules.
    When there is a change in communication protocol, engineers can find most of the
    necessary changes in one project. This reduces the cost and effort of making a
    change. It also keeps the change contained in one area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the example of household validation that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A household has a name and a list of members. Each member has a few basic fields
    such as first and last names. A basic household validation would involve ensuring
    that the household name is not empty; moreover, it also requires that each person
    in the household passes the validation. For example, age cannot be a negative
    number.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the validation of a household depends on the validation of
    a person in that household. The functions to validate both the household and the
    person are vertically cohesive because they behave as a validation feature in
    the form of a higher-order function. They are also linearly cohesive because the
    validation function of a household invokes the validation function of a person.
  prefs: []
  type: TYPE_NORMAL
- en: High cohesiveness concentrates related components in one place. This illustrates
    the overall behavior of the components and makes the behavior easier to understand.
    It also promotes better testability as engineers can test the components’ overall
    behavior in one place. Keeping related components in one place also means fewer
    moving parts when making a change, which lowers risk. The overall behavior can
    be treated as one unit that other parts of the system can reuse.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, low cohesiveness results in related components being scattered
    around, making them difficult to understand, modify, and maintain. It creates
    inappropriate coupling between components, making it riskier to make changes without
    affecting unrelated parts of the system. Attempting to modify one system quality
    attribute can result in the unintended effect of changing the others. You are
    also more likely to create bugs when making a change. It then becomes difficult
    to reuse the component as it brings dependencies that are unlikely to be suitable
    for the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coupling is a bad idea in the context of cohesiveness, but the measurement of
    coupling is not bad at all. It provides a view of how interdependent the software
    components in the system are.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling is inevitable, but it can be minimized in a way that promotes better
    maintainability, reusability, and understanding. It is preferable to limit the
    interactions among components as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Functional coupling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To limit the interactions among components, we must separate what needs to be
    done from how to do it. In the previous example, the “what” is the validation
    of households including their members; the “how” is that the validation functions
    run through each field and add violated conditions to a list to be returned. The
    household is valid if the returned list is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the work performed by a software component is a contract between
    the provider and the invoker. It typically consists of an input, an optional state,
    and an output. The invoker is concerned with the input to supply and the output
    to receive, but not with what happens internally within the software component.
    On the other hand, the provider is concerned with how to compute the output and
    optionally update the state based on the given input.
  prefs: []
  type: TYPE_NORMAL
- en: This contract is often referred to as an interface between the provider and
    the invoker. It gives a good foundation for loosely coupled software components.
    With the interaction of both parties centered around the interfaces, the invoker
    now has the flexibility to switch to a different provider who can fulfill the
    contract. The provider need not do anything extra for another invoker who wants
    to reuse this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This type of coupling is called **functional coupling**. It is based on the
    contracts or interfaces among software components.
  prefs: []
  type: TYPE_NORMAL
- en: Data coupling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A software component may require the data that it shares with another to function
    properly. The ownership of data is a topic in itself. However, in a simple sense,
    if there is only one component that creates, updates, or deletes a category of
    data, then that component owns the data.
  prefs: []
  type: TYPE_NORMAL
- en: It is almost guaranteed that if more than one component owns the same piece
    of data, there will be a big problem in keeping the data reliable and consistent.
    In this situation, it is better for the two components to truly own their data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several options to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Should the components that share the same data be merged into one component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the ownership of the data be split among the components so they no longer
    share the same data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a new component be extracted to own the data, while other components become
    the listeners of the data change?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should one of the components take all the responsibility of creating, updating,
    and deleting the data, effectively becoming the owner of the data? This would
    mean that the other components become the listeners of the data change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should each component own a copy of the data and let each copy be diverse in
    each component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can each component keep a separate copy of the data owned by another component
    while there are reconciliation processes in place to process the difference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that a software component can own the data, it is important for the component
    to decide how much of the data should be exposed externally. The component should
    encapsulate the data to hide any internal data and only expose the fields that
    are related to the interface to other components.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it is often useful to separate the internal and external representations
    of the data. For instance, a list of internal error enumeration values may contain
    information that exposes the internal state of the component unintentionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given that there are several internal error enumeration values
    for a log-on operation, then the Kotlin enum class would look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we expose all these values externally, the invoker of the component will
    be able to understand whether a username exists even if the log-on operation failed,
    or if both were valid but failed the captcha challenge. These are unnecessary
    details to the outside of the component and should be hidden. This is without
    mentioning the obvious security concern that is also at play. So, we could create
    a list of external error enumeration values to only show what is of interest to
    the invoker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Temporal coupling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two software components can be temporally coupled if they both need to be available
    for the whole operation to run through. Component A might need to invoke a synchronous
    remote call to component B to continue to handle its incoming requests, for example.
    An even worse situation would be a chain of multiple remote cascading calls to
    multiple components. An example of temporally coupled components is described
    in the UML sequence diagram that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – A Synchronous pull interaction](img/B21737_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – A Synchronous pull interaction
  prefs: []
  type: TYPE_NORMAL
- en: Each time a synchronous call is made, it blocks the thread until there is an
    answer returned or until it times out. This is also called the **pull-based**
    approach. If we had multiple of these calls, it would be quite easy to cause a
    timed-out error to the original request.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous remote calls have the nature of blocking the thread, pulling data,
    and depending on the component’s availability. There are cases where synchronous
    remote calls may be necessary due to time sensitivity, such as when the service
    must authenticate a user within a given number of seconds or time out.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all the synchronous remote calls are only there to provide data, then we
    can consider an asynchronous and **push-based** approach. Using this approach,
    component A subscribes to a topic whereby component B publishes an event when
    the data changes. Component A then keeps a copy of the data locally. Then component
    A no longer requires component B to be available to handle requests; component
    A uses the last known value instead. An example of asynchronous push interactions
    among components is illustrated as a UML sequence diagram in *Figure 2**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – An asynchronous push interaction](img/B21737_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – An asynchronous push interaction
  prefs: []
  type: TYPE_NORMAL
- en: 'If the interaction between components A and B is more procedural and sequential,
    then the components can still be loosely coupled by being reactive and asynchronous
    using events. In this scenario, component A has processed up to the point where
    it needs component B, so component A sends an event, and component B receives
    it. Then component B performs the work. When component B finishes its part, it
    sends an event that component A receives. Component A then continues the rest
    of the work. An example of the asynchronous reactive event-driven interaction
    among components can be expressed by a UML sequence diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – An asynchronous reactive event-driven interaction](img/B21737_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – An asynchronous reactive event-driven interaction
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the principles of separation of concerns, cohesiveness, and
    coupling. We went through why they are important and how the application of these
    concepts affects system quality attributes. We also covered the sub-categories
    of cohesiveness and coupling with real-time world examples. They are three different
    concepts but relate to each other often.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to cover the **SOLID principles**. These principles encourage
    software architecture with separate concerns, highly cohesive components, and
    low coupling between components.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SOLID principles are a set of five software architecture principles that
    advocate for creating maintainable, understandable, flexible, and modular software.
    Though they were originally targeted at object-oriented software, the concepts
    behind them are useful and can be applied to systems other than object orientation.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts were first introduced by Robert J. Martin in his *Design Principles
    and Design Patterns* paper in 2000\. However, the SOLID acronym was introduced
    later by Michael Feathers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The acronym SOLID stands for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility** **Principle** (**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-Closed** **Principle** (**OCP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution** **Principle** (**LSP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation** **Principle** (**ISP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion** **Principle** (**DIP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will walk through each of them and use the concepts that we have covered
    for discussion.
  prefs: []
  type: TYPE_NORMAL
- en: SRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SRP states that a class should have one responsibility or concern, and only
    one. There is only one reason to change. If a class conforming to this principle
    has a clear and well-defined purpose and it is then easier to understand, test,
    and maintain, it can be counted as an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us have a look at a class that violates the SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `HouseholdService` interface is responsible for creating a household, drafting
    a contract, and notifying the households involved in a contract. This class can
    change due to a change in any one of these operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor the example to conform to SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now `HouseholdService` is only responsible for managing households. The `ContractService`
    interface is solely responsible for drafting a contract. `NotificationService`
    only aims to notify the households involved in a contract. Now each class only
    has one responsibility and one reason to change.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more benefits that come with this change. Each class is now
    more testable, easier to understand, and easier to maintain. Each class can evolve
    and extend its functions independently. A concern in a single class can be addressed
    without impacting the others. Other classes can also reuse one of these classes
    easily without pulling in some never-to-be-used functions.
  prefs: []
  type: TYPE_NORMAL
- en: OCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OCP states that software components such as classes, modules, and functions
    should be open for extension but closed for modification.
  prefs: []
  type: TYPE_NORMAL
- en: A component is *open* if its behaviors can be extended without modifying the
    existing code. A highly cohesive component already contains all strongly related
    elements, so an extension of the behavior only needs to use what is already provided
    and does not need to modify the code inside.
  prefs: []
  type: TYPE_NORMAL
- en: A component is *closed* if it can be used by other components. We should be
    able to modify the implementation without changing the behaviors. A loosely coupled
    component offers a simple and straightforward way for it to be used by other components
    without pulling in dependencies that others may not wish to include.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, there is a `NotificationService` that notifies households
    of the status of the contract in which they are involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an interface that defines a `notifyHouseholds(contract: Contract)`
    function. `SmsNotificationService` and `EmailNotificationService` are concrete
    implementations of the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to extend the behavior by adding a new medium of communication, such
    as phone app notifications, we can create a new concrete implementation without
    modifying any existing code. This interface is *open* for extension.
  prefs: []
  type: TYPE_NORMAL
- en: We can reuse this interface in other situations where we need to notify households
    about their contract. We can update the way in which `EmailNotificationService`
    is authenticated with the **Simple Mail Transfer Protocol** (**SMTP**) server
    without changing the interface. This interface is *closed* for modification.
  prefs: []
  type: TYPE_NORMAL
- en: LSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LSP states that the objects of a superclass can be replaced by objects of
    its subclasses with no change in the correction of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, all subclasses should behave functionally identically to their
    superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous example, `NotificationService` specifies that the `notifyHouseholds`
    function would notify the households involved in the given contract. From a behavioral
    function point of view, it can do this via emails, text messages, or any other
    ways of communication. However, all these subclasses should notify the households
    that are involved in the given contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the contrary, if there is a `PhoneNotificationService` that not only notifies
    households involved in a contract but also updates the contract status to `UNDER_REVIEW`,
    it would violate the LSP. This is because if `EmailNotificationService` is replaced
    by `PhoneNotificationService`, the contract status will be updated, which would
    not happen before the replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we adhere to the LSP, then we will have classes that are highly cohesive,
    as it only focuses on classes being behaviorally equivalent to their superclasses
    and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: ISP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ISP states that clients should not be forced to depend upon interfaces that
    they do not use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This principle promotes that interfaces should be designed to be specific to
    the needs of the clients that use them. This could result in a few outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Small and numerous interfaces**: The interface is small, so the clients do
    not need to depend on functions from an interface that they do not use. Since
    each interface is smaller, there are likely to be more interfaces to cover the
    same scope of functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relevance**: The interface is relevant and specific to the needs of the clients.
    Different clients may have unique needs. Therefore, there may be a few specific
    interfaces for different clients. There may be an overlap of functionalities and
    some clients may want unique behaviors that are only relevant to them for different
    clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher cohesiveness**: Each interface shall contain only related functions
    and ideally focus on one responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Looser coupling**: Since the interfaces are smaller, the coupling with other
    components is also looser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of a violation of the ISP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Human` interface has two functions: `logOn` and `exerciseContract`. There
    are two concrete implementations: `User` and `HouseholdMember`. While both users
    and household members are human, they have nothing in common functionally. Both
    subclasses were forced to implement functions that they had no use for. The interface
    should be segregated so that they are specifically targeted toward the functions
    for users and household members.'
  prefs: []
  type: TYPE_NORMAL
- en: DIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The DIP consists of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level components should not depend on low-level components directly. Both
    should depend on abstractions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details; details should depend on abstractions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstractions can be referred to as interfaces and details can be referred to
    as concrete implementations. The rationale behind the principle is that the user
    of a component should only care about the behaviors of the component, not its
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to reuse the component that notifies the households
    involved in a contract in a workflow, then the principle suggests that we reference
    the component as the `NotificationService` type, even if we know that `EmailNotificationService`
    is the concrete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach brings a few benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The `NotificationService` interface can be mocked or replaced by a `EmailNotificationService`.
    Our unit tests focus on how to interact with `NotificationService`, handling several
    types of outcomes from the `notifyHouseholds` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency on `NotificationService` can be injected or looked up at runtime.
    This gives us the flexibility to swap it with a different concrete implementation
    and have the function still run correctly. An **Inversion of Control** (**IoC**)
    container framework can support the implementation of the injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coupling with `NotificationService` is loosened to only care about the behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is easier to maintain as swapping the concrete implementation of `NotificationService`
    requires no code changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to extend `NotificationService` by providing a different concrete
    implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us look at the ensuing example and see whether it adheres to the DIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`ContractWorkflowService` has a function to mark a contract as `agreed`. After
    the contract is agreed to, it invokes `EmailNotificationService` to notify households
    about the agreement. However, `ContractWorkflowService` uses the function from
    the interface `NotificationService` and not the subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no need for `ContractWorkflowService` to reference the concrete implementation
    as the service does not concern itself with whether the notification is sent via
    email or another channel. This is a violation of the DIP.
  prefs: []
  type: TYPE_NORMAL
- en: The Law of Demeter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Law of Demeter**, or the principle of least knowledge, states that a software
    component should have limited knowledge about the inner details of other components.
    More specifically, a component should not know about the internal details of another
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us say there is a function that returns the city in the address of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Person` class directly accesses the `city` property inside the `Address`
    class. The `Person` class should not have this knowledge, as this is a violation
    of the **Law** **of Demeter**.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a coupling between `Person` and `Address`. The coupling dictates
    that if the `city` property changes its data type, then both classes will need
    to change. It also means that the code change is bigger than it needs to be, hence
    making it less maintainable and testable.
  prefs: []
  type: TYPE_NORMAL
- en: To conform to the Law of Demeter, the `getAddressCity` function should be provided
    by the `Address` class. This reduces the responsibility of the `Person` class
    for getting the city of an address and thereby reduces the complexity of the code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI and future-proof architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**You Ain’t Gonna Need It** **(YAGNI**) is a principle that states that functionalities
    should not be implemented until they are needed. This principle came from **Extreme
    Programming** (**XP**) as an approach to improve software quality and respond
    to changing business requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: This principle is also related to the idea of minimalism in software development,
    which states that we should avoid unnecessary code and complexity in exchange
    for clean, easy-to-understand, and extensible software.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to describe YAGNI is as the imperative to do the simplest thing
    that works. This is by no means an incomplete design or unfulfilled user requirement.
    It still promotes complete and functional software that satisfies user requirements
    with the simplest design available.
  prefs: []
  type: TYPE_NORMAL
- en: 'YAGNI aims at a few practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple and lean code base**: By implementing only what is necessary now,
    a lot of complexity can be avoided. As a result, the code base is simple, clean,
    and maintainable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prevention of over-engineering**: Over-engineering happens when an engineer
    anticipates future requirements and includes unused features in the system. It
    not only results in wasted time on unnecessary work but also becomes a dead weight
    in the code base, which is then made harder to maintain. Over-engineered code
    also implies a design choice made before there is sufficient information to make
    that choice, locking in the approach prematurely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptive and flexible implementation**: By delaying the implementation of
    a feature until it is needed, engineers have more options to adapt to changes
    when the feature is finally needed. It also encourages a more organic evolution
    of the system whereby engineers respond more effectively to changing requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Productivity**: By focusing on the absolute must-have requirements, engineers
    can deliver changes more quickly and efficiently. Any unnecessary features can
    be postponed, saving time and resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also an opposite idea though: **future-proof architecture**. It aims
    at creating systems that are unlikely to be obsolete or to fail in the future.
    This sounds very appealing. If we can build a system that can fulfill future requirements,
    we will have saved time and effort that would otherwise be spent continuously
    evolving it.'
  prefs: []
  type: TYPE_NORMAL
- en: However, there is an assumption behind this. You need to predict the new requirements
    and you need to be right. That is equivalent to knowing the future. It rarely
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: If you are certain about requiring a feature in the future, then it is neither
    a prediction nor a future requirement. It is simply a requirement now.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean that we should build systems based on short-term objectives
    or take shortcuts. Instead, we should build systems that are ready to adapt to
    new requirements but not have these implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '**Capacity planning** should not be mistaken for future-proof architecture.
    Capacity planning is an operational concern related to deployment and physical
    resources. For instance, building a road to handle twice the current traffic is
    different from building a branch of the road that goes nowhere. Leaving headroom
    for expansion, extra volume, and extra traffic is part of the readiness for evolution.
    Capacity planning is an NFR, not a future requirement. We would not want the system
    to run on edges that may collapse in response to a fluctuation in the volume of
    requests.'
  prefs: []
  type: TYPE_NORMAL
- en: This mindset leads to a few outcomes. The software architecture aims for modular,
    extensible, and flexible components that are ready to make changes when they become
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: It implies that each component is highly cohesive but loosely coupled. It means
    that interfaces are small and specific. It also means that interactions among
    components are based on abstract interfaces and not concrete implementations.
    It further means that subclasses conform to the behaviors of their superclasses
    and are ready to be extended. Furthermore, it means that each component has only
    one reason to change. It also means that modifying a component does not require
    recompiling the entire system. It also means that concerns are separated so that
    when we want to adjust system quality attributes, we can address the particular
    concern in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the 4+1 architecture view model, as well as system quality attributes,
    separation of concerns, cohesiveness, coupling, the SOLID principles, and the
    Law of Demeter. We have demonstrated them with code examples. These demonstrated
    that adhering to these principles lets the code become modular, flexible, maintainable,
    extensible, and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: We have also discussed the conflicting concepts of the YAGNI principle and future-proof
    architecture. We clarified what future-proofing is and how it is different from
    capacity planning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore polymorphism and its alternative approaches.
  prefs: []
  type: TYPE_NORMAL
