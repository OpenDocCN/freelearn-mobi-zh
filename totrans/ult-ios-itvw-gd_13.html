<html><head></head><body>
		<div><h1 id="_idParaDest-197" class="chapter-number"><a id="_idTextAnchor299" class="calibre6 pcalibre pcalibre1"/>10</h1>
			<h1 id="_idParaDest-198" class="calibre5"><a id="_idTextAnchor300" class="calibre6 pcalibre pcalibre1"/>Libraries Management</h1>
			<p class="calibre3">So far, we have discussed the code <em class="italic">we write</em> – Swift, UIKit, and SwiftUI. But modern developers’ work doesn’t simply amount to writing code. Knowing how to integrate code can be a productivity multiplier, greatly enhancing our efficiency and allowing us to accomplish more in less time than simply knowing how to code.</p>
			<p class="calibre3"><em class="italic"><a id="_idTextAnchor301" class="calibre6 pcalibre pcalibre1"/>CocoaPods</em> and the <em class="italic">Swift Package Manager</em> are the leading solutions we have today for managing third-party and local dependencies. It is essential for any iOS developer to understand these tools thoroughly.</p>
			<p class="calibre3">This chapter covers CocoaPods and the Swift Package Manager in terms of the following topics:</p>
			<ul class="calibre10">
				<li class="calibre11">Learning <em class="italic">how CocoaPods is built</em>, including different components such as <strong class="source-inline1">Podfile</strong> and <strong class="source-inline1">Podspec</strong> files</li>
				<li class="calibre11">Going over <em class="italic">CocoaPods’ best practices</em> and use cases</li>
				<li class="calibre11">Covering the Swift Package Manager <em class="italic">creation process</em></li>
				<li class="calibre11">Learning the Swift Package Manager’s <em class="italic">common commands</em></li>
				<li class="calibre11">Learning how to <em class="italic">use a Swift Package</em> in our projects</li>
				<li class="calibre11">Going over the <em class="italic">different advantages</em> the Swift Package Manager has compared to CocoaPods</li>
				<li class="calibre11"><em class="italic">Organizing our projects</em> with the Swift Package Manager</li>
			</ul>
			<p class="calibre3">This is a “simple” chapter, yet it is a crucial topic in today’s iOS development world. Let’s start with CocoaPods as our first dependency manager.</p>
			<h1 id="_idParaDest-199" class="calibre5"><a id="_idTextAnchor302" class="calibre6 pcalibre pcalibre1"/>Mastering CocoaPods</h1>
			<p class="calibre3"><strong class="bold">CocoaPods</strong> is one of the <a id="_idIndexMarker755" class="calibre6 pcalibre pcalibre1"/>most popular dependency managers for iOS developers and has been maintained for many years as an open source project.</p>
			<p class="calibre3">CocoaPods is often the first choice for many library developers and has a massive collection of frameworks that can be easily integrated with iOS projects.</p>
			<p class="calibre3">Besides having a <a id="_idIndexMarker756" class="calibre6 pcalibre pcalibre1"/>vast collection of frameworks, CocoaPods supports integration with local frameworks. It can help us modularize our project to different libraries and make it more flexible and organized.</p>
			<p class="calibre3">Let’s see how CocoaPods works and how it is built.</p>
			<h2 id="_idParaDest-200" class="calibre7"><a id="_idTextAnchor303" class="calibre6 pcalibre pcalibre1"/>Learning how CocoaPods is built</h2>
			<p class="calibre3">When we <a id="_idIndexMarker757" class="calibre6 pcalibre pcalibre1"/>use CocoaPods to manage dependencies in our Xcode project, CocoaPods creates a new workspace, which includes both our project and any dependencies we specified in our <code>Podfile</code> file. CocoaPods creates this workspace automatically when we run the <code>pod </code><code>install</code> command.</p>
			<p class="callout-heading">Xcode Workspace</p>
			<p class="callout">In Xcode, a workspace is a container for one or more Xcode projects and any other files and resources needed to <a id="_idIndexMarker758" class="calibre6 pcalibre pcalibre1"/>build our app. Workspaces are used to organize and manage the different components of our app and make it easier to develop and test our code.</p>
			<p class="calibre3">Using a workspace in CocoaPods has several benefits. It simplifies dependency management by including <a id="_idIndexMarker759" class="calibre6 pcalibre pcalibre1"/>the project and its dependencies in the same workspace, simplifies integration, and follows the separation of concern principle by keeping the dependencies up to date, regardless of our main project.</p>
			<p class="calibre3">Besides the workspace, CocoaPods comprises several different components, each of which plays a role in managing dependencies for iOS.</p>
			<p class="calibre3">Here are some of the key components of CocoaPods.</p>
			<h3 class="calibre9">Podfile</h3>
			<p class="calibre3"><code>Podfile</code> is a file that <a id="_idIndexMarker760" class="calibre6 pcalibre pcalibre1"/>specifies which dependencies are <a id="_idIndexMarker761" class="calibre6 pcalibre pcalibre1"/>required for our project. It uses a simple Ruby syntax to declare each pod’s name and version number, as well as any options or configurations needed. <code>Podfile</code> is typically located in a project’s root directory.</p>
			<p class="calibre3">Here’s an example of a <code>Podfile</code> file:</p>
			<pre class="source-code">
platform :ios, 16.0'target 'MyApp' do
  use_framewo<a id="_idTextAnchor304" class="pcalibre pcalibre1 calibre17"/>rks!
  pod 'Alamofire', '~&gt; 5.4'
  pod 'SwiftyJSON', '~&gt; 4.0'
end</pre>
			<p class="calibre3">Now, let’s <a id="_idIndexMarker762" class="calibre6 pcalibre pcalibre1"/>understand how the file is built:</p>
			<ul class="calibre10">
				<li class="calibre11">The platform <a id="_idIndexMarker763" class="calibre6 pcalibre pcalibre1"/>to target is iOS 16.0</li>
				<li class="calibre11">The target of <strong class="source-inline1">Podfile</strong> is an Xcode project called <strong class="bold">MyApp</strong></li>
				<li class="calibre11">The <strong class="source-inline1">use_frameworks!</strong> directive tells CocoaPods to build the dependencies as <strong class="bold">dynamic frameworks</strong></li>
				<li class="calibre11">The pod directives specify the two dependencies for the project, <strong class="source-inline1">Alamofire</strong> and <strong class="source-inline1">SwiftyJSON</strong>, along with their version requirements</li>
			</ul>
			<p class="calibre3">The <code>~&gt;</code> operator is an <strong class="bold">optimistic operator</strong>, which is used to specify a version for the pod and allows it to <a id="_idIndexMarker764" class="calibre6 pcalibre pcalibre1"/>be updated to the next major version.</p>
			<p class="calibre3">For example, look at the following row:</p>
			<pre class="source-code">
pod 'Alamofire', '~&gt; 5.4'</pre>			<p class="calibre3">In this case, CocoaPods will install and update the <code>Alamofire</code> pod up to version 6.0 (not including 6.0 itself). This allows us to enjoy hotfixes and minor versions without breaking backward compatibility.</p>
			<p class="calibre3"><code>Podfile</code> is our project configuration file for all our dependencies and must be maintained carefully.</p>
			<h3 class="calibre9">Podfile.lock</h3>
			<p class="calibre3"><code>Podfile.lock</code> is a file that stores information about the specific versions of the dependencies <a id="_idIndexMarker765" class="calibre6 pcalibre pcalibre1"/>installed in our project. It ensures that the same <a id="_idIndexMarker766" class="calibre6 pcalibre pcalibre1"/>dependencies’ versions are installed on every machine, which helps prevent version conflicts and other issues.</p>
			<p class="calibre3">Here’s how it looks:</p>
			<pre class="source-code">
PODS:  - AFNetworking (2.6.3)
  - Firebase/Analytics (7.6.0)
  - Firebase/CoreOnly (7.6.0)
  - FirebaseAnalytics (7.6.0)
  - FirebaseCore (7.6.0)
  - FirebaseCoreDiagnostics (7.6.0)
  - FirebaseInstallations (7.6.0)
  - GoogleAppMeasurement (7.6.0)
DEPENDENCIES:
  - AFNetworking (~&gt; 2.6.3)
  - Firebase/Analytics
  - GoogleAppMeasurement (~&gt; 7.6.0)</pre>
			<p class="calibre3">CocoaPods automatically generates <code>Podfile.lock</code> when we run <code>pod update</code> or <code>pod install</code>, and we shouldn’t update it manually, as it can cause conflicts and issues.</p>
			<h3 class="calibre9">The Pods directory</h3>
			<p class="calibre3">The <code>Pods</code> directory is a <a id="_idIndexMarker767" class="calibre6 pcalibre pcalibre1"/>directory that contains all the <a id="_idIndexMarker768" class="calibre6 pcalibre pcalibre1"/>dependencies installed by CocoaPods for our project. It includes each pod’s source code, headers, and compiled binaries.</p>
			<h3 class="calibre9">Podspec</h3>
			<p class="calibre3">A <code>Podspec</code> is a file that <a id="_idIndexMarker769" class="calibre6 pcalibre pcalibre1"/>describes a single pod, including <a id="_idIndexMarker770" class="calibre6 pcalibre pcalibre1"/>its name, version, source code location, dependencies, and other metadata. Podspecs are published to the CocoaPods repository and used by CocoaPods to download and install a pod.</p>
			<p class="calibre3">Let’s see an example of a podspec file:</p>
			<pre class="source-code">
Pod::Spec.new do |s|  s.name         = "MyLibrary"
  s.version      = "1.0.0"
  s.summary      = "A library for iOS and macOS
      development."
  s.description  = "MyLibrary provides a set of tools and
      utilities for iOS and macOS development."
  s.homepage     = "https://github.com/
      myusername/MyLibrary"
  s.license      = "MIT"
  s.author       = { "My Name" =&gt; "myemail@example.com" }
  s.platform     = :ios, '14.0'
  s.source       = { :git =&gt; "https://github.com/
      myusername/MyLibrary.git", :tag =&gt; "#{s.version}" }
  s.source_files = "Sources/**/*.{h,m,swift}"
  s.swift_version = '5.4'
  s.dependency   "Alamofire", "~&gt; 5.4"
  s.dependency   "SwiftyJSON", "~&gt; 4.0"
end</pre>
			<p class="calibre3">The podspec file is written in Ruby, a dynamic and object-oriented programming language. In fact, the <code>Podfile</code> file is also written in Ruby, as it is considered a convenient and popular way to write configuration files for frameworks.</p>
			<p class="calibre3">The podspec file, in this <a id="_idIndexMarker771" class="calibre6 pcalibre pcalibre1"/>example, describes a library named <code>MyLibrary</code> with <a id="_idIndexMarker772" class="calibre6 pcalibre pcalibre1"/>a version of <code>1.0.0</code>. We can also see a summary, a description, and other general details, such as the home page, license, and author.</p>
			<p class="calibre3">In the source and source files, we can see where the Git repository is located (in this case, in GitHub) and <a id="_idIndexMarker773" class="calibre6 pcalibre pcalibre1"/>what files are included<a id="_idTextAnchor305" class="calibre6 pcalibre pcalibre1"/> in the pod in the <strong class="bold">wildcard pattern</strong>.</p>
			<p class="callout-heading">The wildcard pattern</p>
			<p class="callout">In Podfile, a wildcard pattern can be used to define directories where the pods should be installed.</p>
			<p class="callout">The wildcard pattern (“<strong class="source-inline1">*</strong>”) represents any character to match any file or directory. For example, if we want to specify <a id="_idIndexMarker774" class="calibre6 pcalibre pcalibre1"/>all directories that start with “M,” we can use the following:</p>
			<p class="callout"><strong class="source-inline1">Pod "MyPod", :path =&gt; "</strong><strong class="source-inline1">M*"</strong></p>
			<p class="callout">The wildcard pattern is not a Podfile-only pattern – it is used in many Unix-like command-line tools and terminals.</p>
			<p class="calibre3">Finally, we add the dependencies our pod requires so that CocoaPods will know to manage its dependencies tree accordingly.</p>
			<p class="calibre3">It is important to note that we can easily use a podspec file to create a local library and integrate it with our project. Here’s a podspec file example for a local library:</p>
			<pre class="source-code">
Pod::Spec.new do |s|  s.name         = "MyFramework"
  s.version      = "1.0.0"
  s.summary      = "A framework that modularizes code from
      MyProject."
  s.homepage     = "https://github.com/
      myusername/MyFramework"
  s.license      = "MIT"
  s.author       = { "My Name" =&gt; "myemail@example.com" }
  s.platform     = :ios, '14.0'
  s.source       = { :path =&gt; "." }
  s.source_files = "MyFramework/**/*.{h,m,swift}"
  s.public_header_files = "MyFramework/**/*.h"
  s.frameworks   = "UIKit"
  s.dependency   "Alamofire", "~&gt; 5.4"
  s.dependency   "SwiftyJSON", "~&gt; 4.0"
  s.swift_version = '5.4'
  s.pod_target_xcconfig = {
    'SWIFT_INCLUDE_PATHS' =&gt; '$(SRCROOT)
        /MyProject/MyModule'
  }
end</pre>
			<p class="calibre3">Apart from modifying our <code>source</code> and <code>source_files</code> attributes, we can also see that we now have a <code>pod_target_xcconfig</code> attribute to specify the path to the source code <a id="_idIndexMarker775" class="calibre6 pcalibre pcalibre1"/>for the module in our project.</p>
			<p class="calibre3"><code>Podfile</code>, in this <a id="_idIndexMarker776" class="calibre6 pcalibre pcalibre1"/>case, will look like this:</p>
			<pre class="source-code">
platform :ios, '14.0'target 'MyApp' do
  use_frameworks!
<strong class="bold1">  pod 'MyFramework', :path =&gt; '../MyFramework'</strong>
end</pre>
			<p class="calibre3">In <code>Podfile</code>, we direct <code>MyFramework</code> to its local path, where the source file exists.</p>
			<h3 class="calibre9">Pod command-line tool</h3>
			<p class="calibre3">The pod command-line tool is the primary interface for working with CocoaPods. It provides a command set that <a id="_idIndexMarker777" class="calibre6 pcalibre pcalibre1"/>allows us to install, update, <a id="_idIndexMarker778" class="calibre6 pcalibre pcalibre1"/>and manage dependencies for our project.</p>
			<p class="calibre3">These are some commonly used commands we can use:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">pod install</strong>: This command installs the dependencies specified in <strong class="source-inline1">Podfile</strong> and generates an Xcode workspace, containing our project and the installed dependencies.</li>
				<li class="calibre11"><strong class="source-inline1">pod update</strong>: This command updates the dependencies specified in <strong class="source-inline1">Podfile</strong> to their latest versions and installs them. We can select a specific pod or a list of pods to update.</li>
				<li class="calibre11"><strong class="source-inline1">pod lib create</strong>: This command generates a new CocoaPods library template. We can use it to quickly set up a new pod’s directory structure, files, and configuration.</li>
				<li class="calibre11"><strong class="source-inline1">pod search</strong>: This command searches the CocoaPods repository for pods that match a given query. We can search for pods by name, description, author, or other criteria.</li>
			</ul>
			<p class="calibre3">Like many development tools, CocoaPods is based on command-line tools, configuration files, and a terminal, so “terminal-phobia” is not recommended in the case of CocoaPods!</p>
			<p class="calibre3">We discussed five different CocoaPods components for managing and understanding CocoaPods. If you have never used CocoaPods before or didn’t create your pod, it’s a good idea to create a new project and play with it, followed by reading the CocoaPods documentation, which is <a id="_idIndexMarker779" class="calibre6 pcalibre pcalibre1"/>clear and straightforward. I promise you that things <a id="_idIndexMarker780" class="calibre6 pcalibre pcalibre1"/>will be much easier to understand after an hour.</p>
			<p class="calibre3">Now, let’s jump into two questions about CocoaPods that we may en<a id="_idTextAnchor306" class="calibre6 pcalibre pcalibre1"/>counter in an interview.</p>
			<h2 id="_idParaDest-201" class="calibre7"><a id="_idTextAnchor307" class="calibre6 pcalibre pcalibre1"/>“What best practices do you follow when working with CocoaPods, and<a id="_idTextAnchor308" class="calibre6 pcalibre pcalibre1"/><a id="_idTextAnchor309" class="calibre6 pcalibre pcalibre1"/><a id="_idTextAnchor310" class="calibre6 pcalibre pcalibre1"/> why are they important?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">CocoaPods, or any other dependencies manager for that matter, is an essential part of a project.</p>
			<p class="calibre3">In a way, we <a id="_idIndexMarker781" class="calibre6 pcalibre pcalibre1"/>can even say <em class="italic">it’s the vulnerable part of our project</em> for a few reasons:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">It’s not code we have written ourselves</strong>: CocoaPods integrates thousands of lines of code that other developers wrote into our project. We have little control over the security, performance, and stability effect of adding code someone else writes. However, it will have probably gone through many fixes and testing cycles.</li>
				<li class="calibre11"><strong class="bold">There’s a potential for dependencies conflicts</strong>: A poorly structured <strong class="source-inline1">Podfile</strong> can cause conflicts between different versions of dependencies and may harm a project’s stability.</li>
				<li class="calibre11"><strong class="bold">Out<a id="_idTextAnchor311" class="calibre6 pcalibre pcalibre1"/>dated frameworks can cause security breaches</strong>: Developers often lock frameworks to specific versions to keep their project stability high. This can lead to obsolete code with security and stability issues.</li>
			</ul>
			<p class="calibre3">Because of the reasons I just described, a well-structured <code>Podfile</code> tremendously af<a id="_idTextAnchor312" class="calibre6 pcalibre pcalibre1"/>fects our project quality.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">We can follow a <a id="_idIndexMarker782" class="calibre6 pcalibre pcalibre1"/>few best practices when working with CocoaPods:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Keeping our frameworks up to date</strong>: We need to ensure we get the latest bug fixes and features to keep our project stable. The <strong class="source-inline1">~&gt;</strong> operator I mentioned earlier is recommended to get the latest hotfixes and minor versions.</li>
				<li class="calibre11"><strong class="bold">Understanding semantic versioning</strong>: Keeping frameworks up to date is essential. However, we should understand how semantic versioning works. We want to ensure backward compatibility and avoid breaking changes.</li>
				<li class="calibre11"><strong class="bold">Keeping dependencies at a minimum</strong>: We should only include frameworks that we really need in our project and remove those that the Apple SDK can replace. Keeping our project light and simple is vital, avoiding potential issues such as conflicts and crashes.</li>
				<li class="calibre11"><strong class="bold">Keeping our Podfile organized and readable</strong>: We should treat our <strong class="source-inline1">Podfile</strong> as part of our code base. Grouping dependencies in a logical way can provide us with flexibility and clarity. Another best practice here is to add comments next to each pod and explain why we added each pod. Pods can live in our app for years, and the comments we ad<a id="_idTextAnchor313" class="calibre6 pcalibre pcalibre1"/>d can help us in the future.</li>
				<li class="calibre11"><strong class="bold">Implementing the adapter pattern</strong>: While the adapter pattern is not unique to CocoaPods, it is an excellent pattern for integrating a pod into our project seamlessly. Often, the pod’s interface does not naturally align with our existing code base. By introducing <a id="_idIndexMarker783" class="calibre6 pcalibre pcalibre1"/>a class that acts as an interface between our code base and the library, we can effectively connect these two components. Additionally, the adapter can assist in decoupling our code base from the pod and reducing dependencies.</li>
			</ul>
			<p class="calibre3">We must remember something important – pods are part of our code. We should take care of our third-party frameworks with the same attention that we manage our project code base with, as they tremendously affec<a id="_idTextAnchor314" class="calibre6 pcalibre pcalibre1"/>t how our project performs.</p>
			<h2 id="_idParaDest-202" class="calibre7"><a id="_idTextAnchor315" class="calibre6 pcalibre pcalibre1"/>“What is the difference between pod update and pod install?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">In the previous question, we talked about best practices for managing CocoaPods. One crucial aspect we covered was managing pods to prevent them from causing any issues or breaking our code.</p>
			<p class="calibre3">Both the <code>pod update</code> and <code>pod install</code> commands help us to decide our strategy to update <a id="_idIndexMarker784" class="calibre6 pcalibre pcalibre1"/>our pods, implementing a careful and responsible way to keep our third-party libraries up to date.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3"><code>pod install</code> and <code>pod update</code> are commands used in the CocoaPods dependency manager for iOS projects. The main difference between them is how they handle dependency resolution.</p>
			<p class="calibre3"><code>pod install</code> installs the dependencies specified in <code>Podfile.lock</code> and ensures that a pod won’t receive unintended updates.</p>
			<p class="calibre3">On the other hand, <code>pod update</code> updates the current pods to the latest minor version and, ultimately, updates <code>Podfile.lock</code> to the new version.</p>
			<p class="calibre3">One thing to note is that if there is no <code>Podfile.lock</code>, <em class="italic">both commands </em><em class="italic">behave similarly</em>.</p>
			<p class="calibre3">The difference between the commands in day-to-day work is critical. <code>Podfile.lock</code> helps us control our framework’s updates and keeps our pods in a specific version, as long as we use <code>pod install</code>, whereas <code>pod update</code> can bypass what’s written in <code>Podfile.lock</code>.</p>
			<p class="calibre3">I advise including <code>Podfile.lock</code> in a project’s code base when discussing best practices. This is particularly crucial when collaborating with a team, as <code>Podfile.lock</code> guarantees that all team members use identical framework versions.</p>
			<p class="calibre3">To summarize this section, by now, we should understand how CocoaPods works and how to use it to link <a id="_idIndexMarker785" class="calibre6 pcalibre pcalibre1"/>third-party libraries and maintain a stable and robust project.</p>
			<p class="calibre3">As an essential tool to manage dependencies in iOS projects, CocoaPods should be treated with the utmost importance. This applies to any dependency manager, including the Swift Package Manager, which we will now review.</p>
			<h1 id="_idParaDest-203" class="calibre5"><a id="_idTextAnchor316" class="calibre6 pcalibre pcalibre1"/>Learning about the Swift Package Manager</h1>
			<p class="calibre3">CocoaPods and Carthage have played a significant part over the years in managing<a id="_idTextAnchor317" class="calibre6 pcalibre pcalibre1"/> dependencies in iOS projects.</p>
			<p class="calibre3">While CocoaPods and Carthage are terrific tools, every platform needs to have its in-house dependency <a id="_idIndexMarker786" class="calibre6 pcalibre pcalibre1"/>manager, and Apple indeed developed a native dependency manager called the <strong class="bold">Swift Package </strong><strong class="bold">Manager</strong> (<strong class="bold">SPM</strong>).</p>
			<p class="calibre3">So, what is the SPM?</p>
			<p class="calibre3">The SPM is a dependency manager built right into Xcode and allows developers to easily create, manage, and share Swift packages, which are self-contained units of code that can be used in different projects. A package can contain one or more targets, each of which is a module that can be imported and used by other packages or projects.</p>
			<p class="calibre3">Let’s start creating a Swift package from scratch.</p>
			<h2 id="_idParaDest-204" class="calibre7"><a id="_idTextAnchor318" class="calibre6 pcalibre pcalibre1"/>Creating a Swift package</h2>
			<p class="calibre3">Creating a new <a id="_idIndexMarker787" class="calibre6 pcalibre pcalibre1"/>Swift package is simple. There are two ways to do it – using the <em class="italic">terminal</em> and <em class="italic">Xcode</em>:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Using the terminal</strong>: Open the <strong class="bold">Terminal</strong> app, go to the project folder (or any other folder), and <a id="_idIndexMarker788" class="calibre6 pcalibre pcalibre1"/>type the following command:<pre class="source-code">
swift package init --type library</pre></li>			</ul>
			<p class="calibre3">This command will create a new folder with the relevant subfolders and files to set up a basic and empty Swift package.</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Creating a Swift package with Xcode</strong>: If you don’t want to use the Terminal to <a id="_idIndexMarker789" class="calibre6 pcalibre pcalibre1"/>create a Swift package, the other option is to use Xcode.</li>
			</ul>
			<p class="calibre3">Let’s go over the steps required to create a new Swift package:</p>
			<ol class="calibre15">
				<li class="calibre11">Open Xcode and select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Package</strong> from the menu bar.</li>
				<li class="calibre11">In the <strong class="bold">Create a new Swift Package</strong> dialog, enter the package details, such as the package <a id="_idIndexMarker790" class="calibre6 pcalibre pcalibre1"/>name, organization, and type. You can choose between a library or executable package and specify the package’s platforms and products.</li>
				<li class="calibre11">Click <strong class="bold">Create</strong> to create the new Swift package. Xcode will generate a basic project structure with a <strong class="source-inline1">Sources</strong> directory and a <strong class="source-inline1">Package.swift</strong> manifest file.</li>
			</ol>
			<p class="calibre3">Both options are simple and intuitive and take a few seconds to complete. Now, let’s understand what we created.</p>
			<h2 id="_idParaDest-205" class="calibre7"><a id="_idTextAnchor319" class="calibre6 pcalibre pcalibre1"/>Going over the package manifest and folders</h2>
			<p class="calibre3">The Swift package is built from three components: </p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">The </strong><strong class="source-inline1">Sources</strong><strong class="bold"> directory</strong>: This directory <a id="_idIndexMarker791" class="calibre6 pcalibre pcalibre1"/>contains the Swift source files for our package. By default, it <a id="_idIndexMarker792" class="calibre6 pcalibre pcalibre1"/>includes a single subdirectory with the same name as the package, and a single source file with the same name as the directory.</li>
				<li class="calibre11"><strong class="bold">The </strong><strong class="source-inline1">Tests</strong><strong class="bold"> directory</strong>: This directory contains the test files for our code. By default, it includes a <a id="_idIndexMarker793" class="calibre6 pcalibre pcalibre1"/>single subdirectory, with a single test file with the same name as the directory.</li>
				<li class="calibre11"><strong class="source-inline1">Package.swift</strong>: This file is the package manifest file. It contains information about the <a id="_idIndexMarker794" class="calibre6 pcalibre pcalibre1"/>package, such as its name, version, and dependencies, and is used by the SPM to build and manage the package.</li>
			</ul>
			<p class="calibre3">In the <em class="italic">Mastering CocoaPods</em> section, we discussed CocoaPods and mentioned the <code>podspec</code> file. In the SPM, <code>package.swift</code> serves a similar purpose to the <code>podspec</code> file in CocoaPods.</p>
			<p class="calibre3">Here’s a short <a id="_idIndexMarker795" class="calibre6 pcalibre pcalibre1"/>example of standard <code>package.swift</code> file content:</p>
			<pre class="source-code">
// Package.swiftimport PackageDescription
let package = Package(
    name: "MyPackage",
    platforms: [
        .macOS(.v10_12), .iOS(.v10), .watchOS(.v3), .tvOS(.v10)
    ],
    products: [
        .library(name: "MyPackage", targets: ["MyPackage"])
    ],
    dependencies: [
        .package(url: "https://github.com/
            Alamofire/Alamofire.git", from: "5.0.0")
    ],
    targets: [
        .target(name: "MyPackage", dependencies: ["Alamofire"]),
        .testTarget(name: "MyPackageTests", dependencies:
            ["MyPackage"])
    ]
)</pre>
			<p class="calibre3">We can see <a id="_idIndexMarker796" class="calibre6 pcalibre pcalibre1"/>that the <code>package.swift</code> file is written in, well… <em class="italic">Swift</em>. Therefore, reading it should be <a id="_idIndexMarker797" class="calibre6 pcalibre pcalibre1"/>simple for iOS developers. Let’s understand what it says.</p>
			<p class="calibre3">This <code>Package.swift</code> file specifies the details of a Swift package named <code>"MyPackage"</code>. The package targets multiple platforms – macOS, iOS, watchOS, and tvOS. It provides a single library product with the same name as the package.</p>
			<p class="calibre3">The package depends on the <code>Alamofire</code> package, specified as a dependency with a minimum version of <code>5.0.0</code>. The package also contains two targets, one for the package itself and one for its tests. The package target depends on the <code>Alamofire</code> package, and the test target depends on the <code>MyPackage</code> target.</p>
			<p class="calibre3">When the SPM installs <a id="_idIndexMarker798" class="calibre6 pcalibre pcalibre1"/>our package, it also establishes the dependencies <a id="_idIndexMarker799" class="calibre6 pcalibre pcalibre1"/>we define inside the <code>package.swift</code> file, just the way it works with CocoaPods.</p>
			<p class="calibre3">Another interesting thing we should know is why it is called a “package” and not a “library.” The reason is that a Swift package can contain <em class="italic">multiple libraries</em> (under “products”) and various targets, and it is crucial to understand that hierarchy to create a flexible package.</p>
			<p class="calibre3">How do we build and test the package? Let’s see.</p>
			<h2 id="_idParaDest-206" class="calibre7"><a id="_idTextAnchor320" class="calibre6 pcalibre pcalibre1"/>Swift package common commands</h2>
			<p class="calibre3">While it is possible to use the SPM from within Xcode, having a good understanding of the primary terminal commands is still essential. This is because user interfaces tend to change more frequently, while command-line tools remain more consistent over time.</p>
			<p class="calibre3">However, a more significant reason is that terminal commands provide us with the ability to <em class="italic">integrate them into scripts and CI machines</em>, making them powerful and effective.</p>
			<p class="calibre3">Here is the list of commands:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">swift package init</strong>: We saw <a id="_idIndexMarker800" class="calibre6 pcalibre pcalibre1"/>this command earlier when we discussed Swift package creation. It initializes a new and empty Swift package in the current directory.</li>
				<li class="calibre11"><strong class="source-inline1">swift package update</strong>: This updates the package’s dependencies to their latest compatible versions. It’s similar to <strong class="source-inline1">pod update</strong> in CocoaPods.</li>
				<li class="calibre11"><strong class="source-inline1">swift build</strong>: This builds the package and its dependencies, generating a binary or library product.</li>
				<li class="calibre11"><strong class="source-inline1">swift test</strong>: This runs the package’s unit tests, building the package if necessary.</li>
				<li class="calibre11"><strong class="source-inline1">swift package clean</strong>: This deletes the build artifacts for the package, including the <a id="_idIndexMarker801" class="calibre6 pcalibre pcalibre1"/>build directory.</li>
			</ul>
			<p class="calibre3">In the context of an interview, think of this command list as a “features list.” This list should show us how to operate and maintain a Swift package.</p>
			<h2 id="_idParaDest-207" class="calibre7"><a id="_idTextAnchor321" class="calibre6 pcalibre pcalibre1"/>Using a Swift package</h2>
			<p class="calibre3">Using a Swift package library is like any other library we add to our project. Everything we know about <a id="_idIndexMarker802" class="calibre6 pcalibre pcalibre1"/>access levels also applies in this case.</p>
			<p class="calibre3">For example, an app can access only <em class="italic">public</em> and <em class="italic">open</em> functions, classes, and properties, while the <em class="italic">internal</em> level is reserved for the library.</p>
			<p class="calibre3">Also, to use a library, we need to import it into our code. Here’s an example:</p>
			<pre class="source-code">
import MyPackagelet myObject = MyClass()
myObject.myMethod()</pre>
			<p class="calibre3">In this example, we first import the <code>MyPackage</code> module into our code using the <code>import</code> statement. Then, we create an instance of the <code>MyClass</code> class and call its <code>myMethod</code> function. In this case, <code>MyClass</code> is part of <code>MyPackage</code>. This example is relevant for the app and the package when working with its dependencies.</p>
			<p class="calibre3">Generally speaking, using the SPM is pretty simple and straightforward. Apple did a great job integrating it within Xcode while maintaining its ability to perform everything in terminal commands.</p>
			<p class="calibre3">The goal here was to briefly explain the SPM befo<a id="_idTextAnchor322" class="calibre6 pcalibre pcalibre1"/>re we move on to the next interview questions.</p>
			<h2 id="_idParaDest-208" class="calibre7">“What are the advantages and disadva<a id="_idTextAnchor323" class="calibre6 pcalibre pcalibre1"/>ntages of using the SPM compared to CocoaPods?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Both tools are <a id="_idIndexMarker803" class="calibre6 pcalibre pcalibre1"/>excellent to <a id="_idIndexMarker804" class="calibre6 pcalibre pcalibre1"/>manage <a id="_idIndexMarker805" class="calibre6 pcalibre pcalibre1"/>dependencies <a id="_idIndexMarker806" class="calibre6 pcalibre pcalibre1"/>in iOS, but just like any other tool, they have their strengths and weaknesses.</p>
			<p class="calibre3">Understanding the practical differences between the tools is perhaps even more important than using them, as the latter is straightforward and technical. Choosing the right tool signifi<a id="_idTextAnchor324" class="calibre6 pcalibre pcalibre1"/>cantly impacts our app’s maintenance and stability.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Like any cons and pros, the answer depends on a project’s needs and requirements. However, there are some known differences between CocoaPods and the SPM.</p>
			<p class="calibre3">These are the <em class="italic">SPM's advantages</em>:</p>
			<ul class="calibre10">
				<li class="calibre11">A <em class="italic">built-in</em> tool for Swift projects, so no need for third-party dependencies</li>
				<li class="calibre11">A simple and <em class="italic">easy-to-use</em> syntax</li>
				<li class="calibre11"><em class="italic">Integration with Swift and Xcode</em>, including support to generate Xcode projects</li>
				<li class="calibre11"><em class="italic">Automatic dependency resolution</em> and caching</li>
				<li class="calibre11"><em class="italic">Faster</em> build times for more minor projects</li>
			</ul>
			<p class="calibre3">These are the <em class="italic">SPM's disadvantages</em>:</p>
			<ul class="calibre10">
				<li class="calibre11">Limited support for binary dependencies</li>
				<li class="calibre11">No support for Objective-C or mixed-language projec<a id="_idTextAnchor325" class="calibre6 pcalibre pcalibre1"/>ts</li>
				<li class="calibre11">Limited customization options for build settings</li>
			</ul>
			<p class="calibre3">This list suggests that the advantages and disadvantages of the SPM are inverse to the ones mentioned earlier in the <em class="italic">Mastering </em><em class="italic">CocoaPods</em> section.</p>
			<p class="calibre3">On one hand, CocoaPods is more used and flexible than the SPM. On the other hand, it is more complex and slow and <a id="_idIndexMarker807" class="calibre6 pcalibre pcalibre1"/>performs <a id="_idIndexMarker808" class="calibre6 pcalibre pcalibre1"/>as a foreign <a id="_idIndexMarker809" class="calibre6 pcalibre pcalibre1"/>citizen in Apple’s development ecosystem.</p>
			<p class="calibre3">Before you start the interview, you should try each of the solutions to understand how they feel and what is possible.</p>
			<h2 id="_idParaDest-209" class="calibre7"><a id="_idTextAnchor326" class="calibre6 pcalibre pcalibre1"/>“What are some best practices for organizing and structuring Swift packages to optimize build times and minimize dependency conflicts?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This question is <a id="_idIndexMarker810" class="calibre6 pcalibre pcalibre1"/>beyond technical. As we <a id="_idIndexMarker811" class="calibre6 pcalibre pcalibre1"/>already saw, <a id="_idIndexMarker812" class="calibre6 pcalibre pcalibre1"/>the technical part <a id="_idIndexMarker813" class="calibre6 pcalibre pcalibre1"/>of handling Swift packages is simple, even for junior developers. However, organizing a project for packages effectively and efficiently is the real challenge.</p>
			<p class="calibre3">The abundance of articles and research on code modularity and organization demonstrates the importance of this question. Most of them do not even mention the SPM.</p>
			<p class="calibre3">Following even a tiny portion of the best practices here can significantly impact our project.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There are some best practices for organizing our code to optimize build times and decouple our dependencies:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Keeping packages small</strong>: Large packages with many dependencies can slow down build times and increase the risk of conflicts. To minimize these issues, keeping packages small and modular is a good practice. This makes it easier to manage dependencies and reduces the risk of conflicts.</li>
				<li class="calibre11"><strong class="bold">Minimizing dependencies</strong>: To reduce the risk of conflicts and improve build times, it’s a good practice to minimize dependencies wherever possible. This can be achieved by using only the essential dependencies for the package and avoiding unnecessary or duplicate dependencies.</li>
				<li class="calibre11"><strong class="bold">Using semantic versioning</strong>: We can use semantic versioning to manage version <a id="_idIndexMarker814" class="calibre6 pcalibre pcalibre1"/>numbers for a package <a id="_idIndexMarker815" class="calibre6 pcalibre pcalibre1"/>and its <a id="_idIndexMarker816" class="calibre6 pcalibre pcalibre1"/>dependencies. By <a id="_idIndexMarker817" class="calibre6 pcalibre pcalibre1"/>using semantic versioning, we can communicate changes and compatibility requirements to other developers and users of the package.</li>
				<li class="calibre11"><strong class="bold">Using</strong><strong class="bold"> incremental builds</strong>: The SPM supports incremental builds, which means that only the necessary parts of the package are rebuilt when changes are made. This can help to improve build times and reduce unnecessary recompilation.</li>
			</ul>
			<p class="calibre3">We can say that the best practices described here can be used to modularize any project or even any class. A flat hierarchy, minimum dependencies, and small libraries are all great tips for managing libraries in our projects.</p>
			<h1 id="_idParaDest-210" class="calibre5"><a id="_idTextAnchor327" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">Dependency managers are like double-edged swords. Both the SPM and CocoaPods can be time savers and great add-ons for our projects regarding modularity and separation. Conversely, they can have a devastating effect on our app's stability and architecture's simplicity if not handled correctly. That’s why it’s a topic we must master as iOS developers.</p>
			<p class="calibre3">In this chapter, we learned the basics of CocoaPods and the SPM, including the best practices and their pros and cons. By now, we should have everything covered when asked about the most common third-party dependency managers for iOS.</p>
			<p class="calibre3">In a way, our next chapter is linked to what we have discussed in this chapter. We will slowly move away from the standard Swift and UIKit topics into the world of design and architecture.</p>
			<p class="calibre3">Our next chapter will be exciting!</p>
		</div>
	</body></html>