<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Labeling Properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Labeling Properties</h1></div></div></div><p>In this chapter, we will cover how to label properties via the <code class="literal">property_contexts</code> file.</p><p>Properties are a unique Android feature we learned about in <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <span class="emphasis"><em>Android Is Weird</em></span>. We want to label these to restrict setting of our properties to only the domains that should set them, preventing a classic DAC root attack from inadvertently changing the value. In this chapter, we will learn to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create new properties</li><li class="listitem" style="list-style-type: disc">Label new and existing properties</li><li class="listitem" style="list-style-type: disc">Interpret and deal with property denials</li><li class="listitem" style="list-style-type: disc">Enumerate special Android properties and their behaviors</li></ul></div><div class="section" title="Labeling via property_contexts"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec58"/>Labeling via property_contexts</h1></div></div></div><p>All <a id="id331" class="indexterm"/>properties are labeled using the <code class="literal">property_contexts</code> file, and its syntax is similar to <code class="literal">file_contexts</code>. However, instead of <a id="id332" class="indexterm"/>working on file paths, it works on property names or property keys (properties in Android are a key-value store). The property keys themselves are typically delimited with periods (<code class="literal">.</code>). This is analogous to <code class="literal">file_contexts</code>, except the slash (<code class="literal">/</code>) becomes a period. Some sample properties and their entries in <code class="literal">property_contexts</code> would look like the following:</p><div class="informalexample"><pre class="programlisting">ctl.ril-daemon  u:object_r:ctl_rildaemon_prop:s0
ctl.   u:object_r:ctl_default_prop:s0</pre></div><p>Notice how all <code class="literal">ctl.</code> properties are labeled with the <code class="literal">ctl_default_prop</code> type, but <code class="literal">ctl.ril-daemon</code> has a different type label of <code class="literal">ctl_rildaemon_prop</code>. These are representative of how you can start generically and move to more specific values/types as necessary.</p><p>Additionally, anything not explicitly labeled defaults to <code class="literal">default_prop</code> through a "match all" expression in <code class="literal">property_contexts</code>:</p><div class="informalexample"><pre class="programlisting"># default property context
* u:object_r:default_prop:s0</pre></div></div></div>
<div class="section" title="Permissions on properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec59"/>Permissions on properties</h1></div></div></div><p>One<a id="id333" class="indexterm"/> can view the current properties on the system, and create new ones with the command line utilities <code class="literal">getprop</code> and <code class="literal">setprop</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # getprop</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>[sys.usb.state]: [mtp,adb]</strong></span>
<span class="strong"><strong>[wifi.interface]: [wlan0]</strong></span>
<span class="strong"><strong>[wlan.driver.status]: [unloaded]</strong></span>
</pre></div><p>Recall from <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <span class="emphasis"><em>Android Is Weird</em></span>, that properties are mapped into everyone's address space, thus anyone can read them. However, not everyone can set (write) them. The DAC permission model for properties is hardcoded into <code class="literal">system/core/init/property_service.c</code>:</p><div class="informalexample"><pre class="programlisting">/* White list of permissions for setting property services. */
struct {
  const char *prefix;
  unsigned int uid;
  unsigned int gid;
} property_perms[] = {
  { "net.rmnet0.", AID_RADIO, 0 },
  { "net.gprs.", AID_RADIO, 0 },
  { "net.ppp", AID_RADIO, 0 },
...
  { "persist.service.bdroid.", AID_BLUETOOTH, 0 },
  { "selinux." , AID_SYSTEM, 0 },
  { "persist.audio.device", AID_SYSTEM, 0 },
  { NULL, 0, 0 }</pre></div><p>You must have the UID or GID in the <code class="literal">property_perms</code> array to set any property that the prefix matches with. For instance, in order to set the <code class="literal">selinux. </code>properties, you must be UID <code class="literal">AID_SYSTEM</code> (uid 1000) or root. Yes, root can always set a property, and this is a key benefit to applying SELinux to Android properties. Unfortunately, there is no way to <code class="literal">getprop -Z</code> to list the properties and their labels, like with <code class="literal">ls -Z</code> and files.</p></div>
<div class="section" title="Relabeling existing properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec60"/>Relabeling existing properties</h1></div></div></div><p>In<a id="id334" class="indexterm"/> order to become more comfortable with labeling properties, let's relabel the <code class="literal">wifi.interface</code> property. First, let's verify its context by causing a denial and viewing the denial log, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # setprop wifi.interface wlan0</strong></span>
<span class="strong"><strong>avc: denied { set } for property=wifi.interface scontext=u:r:shell:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service</strong></span>
</pre></div><p>An interesting action occurred when we executed the <code class="literal">setprop</code> command over the UDOO serial console. The AVC denial record was printed out. This is because the serial console includes anything printed from the kernel using <code class="literal">printk()</code>. What happens here is the <code class="literal">init</code> process, which controls <code class="literal">setprops</code> as detailed in <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <span class="emphasis"><em>Android Is Weird</em></span>, writes a message to the kernel log. This log message shows up when we execute our <code class="literal">setprop</code> command. If you run this through <code class="literal">adb shell</code>, you'll see the message on the serial console, but not in the <code class="literal">adb</code> console. To do this, however, you must reboot your system because SELinux only prints denial records once while in permissive mode.</p><p>The command using <code class="literal">adb shell</code> is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell setprop wifi.interface wlan0</strong></span>
</pre></div><p>The command using the serial console is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # avc: denied {set} for property=wifi.interface scontext=u:r:shell:s0 tcontext=u:object_r:default_prop</strong></span>
<span class="strong"><strong>usb 2-1.3: device descriptor read/64, error -110</strong></span>
</pre></div><p>From the denial output, we can see that the property type label is <code class="literal">default_prop</code>. Let's change this to <code class="literal">wifi_prop</code>.</p><p>We start by editing <code class="literal">property.te</code> in the <code class="literal">sepolicy </code>directory to declare the new type to label these properties by appending the following line:</p><div class="informalexample"><pre class="programlisting">type wifi_prop, property_type;</pre></div><p>With the type declared, the next step is to apply the label by modifying <code class="literal">property_contexts</code> by adding the following:</p><div class="informalexample"><pre class="programlisting"># wifi properties
wifi. u:object_r:wifi_prop:s0</pre></div><p>Build the policy, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mmm external/sepolicy</strong></span>
</pre></div><p>Push the new <code class="literal">property_contexts</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb push out/target/product/udoo/root/property_contexts /data/security/current</strong></span>
<span class="strong"><strong>51 KB/s (2261 bytes in 0.042s)</strong></span>
</pre></div><p>Trigger a dynamic reload:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell setprop selinux.reload_policy 1</strong></span>
<span class="strong"><strong># setprop wifi.interface wlan0</strong></span>
<span class="strong"><strong>avc: denied { set } for property=wifi.interface scontext=u:r:shell:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service</strong></span>
</pre></div><p>Ok, that didn't work! The <code class="literal">property_contexts</code> file must be in <code class="literal">/data/security</code>, not <code class="literal">/data/security/current</code>.</p><p>To <a id="id335" class="indexterm"/>discover this, search the <code class="literal">libselinux/src/android.c</code> file. There is no mention of <code class="literal">property_contexts</code> in this file; thus, it must be mentioned elsewhere. This leads us to search <code class="literal">system/core</code>, which contains the property service for uses of that file. The matches are on code in <code class="literal">init.c</code> to load the file from priority locations.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -rn property_contexts *</strong></span>
<span class="strong"><strong>init/init.c:745: { SELABEL_OPT_PATH, "/data/security/property_contexts" },</strong></span>
<span class="strong"><strong>init/init.c:746: { SELABEL_OPT_PATH, "/property_contexts" },</strong></span>
<span class="strong"><strong>init/init.c:760: ERROR("SELinux: Could not load property_contexts: %s\n",</strong></span>
</pre></div><p>Let's push the <code class="literal">property_contexts</code> file to the proper location and try again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb push out/target/product/udoo/root/property_contexts /data/security</strong></span>
<span class="strong"><strong>51 KB/s (2261 bytes in 0.042s)</strong></span>
<span class="strong"><strong>$ adb shell setprop selinux.reload_policy 1</strong></span>
<span class="strong"><strong>root@udoo:/ # setprop wifi.interface wlan0</strong></span>
<span class="strong"><strong>avc: received policyload notice (seqno=3)</strong></span>
<span class="strong"><strong>init: sys_prop: permission denied uid:0 name:wifi.interface</strong></span>
</pre></div><p>Wow! It failed yet again. This exercise was meant to point out how tricky this can be if you forget to do something. No informative denial messages were displayed, only an indicator that it <span class="emphasis"><em>was</em></span> denied. This is because the <code class="literal">sepolicy</code> file that contains the type declaration for <code class="literal">wifi_prop</code> was never pushed. This causes <code class="literal">check_mac_perms()</code> in <code class="literal">system/core/init/property_service.c</code> to fail in the <code class="literal">selinux_check_access()</code> function because it cannot find the type to compute the access check against, even though the look up in <code class="literal">property_contexts</code> succeeded. There are no verbose error logs from this.</p><p>We can correct this by ensuring that the <code class="literal">sepolicy</code> is pushed as well:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb push out/target/product/udoo/root/sepolicy /data/security/current/</strong></span>
<span class="strong"><strong>550 KB/s (87385 bytes in 0.154s)</strong></span>
<span class="strong"><strong>$ adb shell setprop selinux.reload_policy 1</strong></span>
<span class="strong"><strong>root@udoo:/ # setprop wifi.interface wlan0</strong></span>
<span class="strong"><strong>avc: received policyload notice (seqno=4)</strong></span>
<span class="strong"><strong>avc: denied { set } for property=wifi.interface scontext=u:r:shell:s0 tcontext=u:object_r:wifi_prop:s0 tclass=property_service</strong></span>
</pre></div><p>Now we see a denial message, as expected, but the label of the target (or property) is <code class="literal">u:object_r:wifi_prop:s0</code>.</p><p>Now <a id="id336" class="indexterm"/>with the target property labeled, you can allow access to it. Note that this is a contrived example, and in the real world, you probably would <span class="emphasis"><em>not</em></span> want to allow access from shell to most properties. The policy should align with your security goals and the property of least privilege.</p><p>We can add an <code class="literal">allow</code> rule in <code class="literal">shell.te</code> in the following way:</p><div class="informalexample"><pre class="programlisting"># wifi prop
allow shelldomain wifi_prop:property_service set;</pre></div><p>Compile the policy, push it to the phone, and trigger a dynamic reload:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mmm external/sepolicy/</strong></span>
<span class="strong"><strong>$ adb push out/target/product/udoo/root/sepolicy /data/security/current/</strong></span>
<span class="strong"><strong>547 KB/s (87397 bytes in 0.155s)</strong></span>
<span class="strong"><strong>$ adb shell setprop selinux.reload_policy 1</strong></span>
</pre></div><p>Now attempt to set the <code class="literal">wifi.interface</code> property and notice the lack of denial.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # setprop wifi.interface wlan0</strong></span>
<span class="strong"><strong>avc: received policyload notice (seqno=5)</strong></span>
</pre></div></div>
<div class="section" title="Creating and labeling new properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Creating and labeling new properties</h1></div></div></div><p>All<a id="id337" class="indexterm"/> properties are dynamically created in the system using <code class="literal">setprop</code> calls <a id="id338" class="indexterm"/>or function calls that do the equivalent from C (<code class="literal">bionic/libc/include/sys/system_properties.h</code>) and Java (<code class="literal">android.os.SystemProperties</code>). Note that the <code class="literal">System.getProperty()</code> and <code class="literal">System.setProperty()</code> Java calls work on application private property stores and are not tied into the global one.</p><p>For DAC controls, you need to modify <code class="literal">property_perms[]</code> as noted earlier to have permissions for non-root users to create or set the property. Note that root can always <code class="literal">set</code> and <code class="literal">create</code>, unless constrained by SELinux policy.</p><p>Suppose we want to create the <code class="literal">udoo.name</code> and <code class="literal">udoo.owner</code> properties; we only want the root user and shell domain to access them. We could create them like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # setprop udoo.name udoo</strong></span>
<span class="strong"><strong>avc: denied { set } for property=udoo.name scontext=u:r:shell:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service</strong></span>
<span class="strong"><strong>root@udoo:/ # setprop udoo.owner William</strong></span>
</pre></div><p>Notice the denial shows these as being <code class="literal">default_prop</code> type. To correct this, we would relabel <a id="id339" class="indexterm"/>these, exactly <a id="id340" class="indexterm"/>as we did in the preceding section, <span class="emphasis"><em>Relabeling existing properties</em></span>.</p></div>
<div class="section" title="Special properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>Special properties</h1></div></div></div><p>In <a id="id341" class="indexterm"/>Android, there are some special properties that have different behaviors. We enumerate the property names and meanings in the proceeding sections.</p><div class="section" title="Control properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec43"/>Control properties</h2></div></div></div><p>Properties<a id="id342" class="indexterm"/> that start with <code class="literal">ctl</code> are reserved as control <a id="id343" class="indexterm"/>properties for controlling services through <code class="literal">init</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>: Starts a service (<code class="literal">setprop ctl.start &lt;servicename&gt;</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">stop</code>: Stops a service (<code class="literal">setprop ctl.stop &lt;servicename&gt;</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">restart</code>: Restarts a service (<code class="literal">setprop ctl.restart &lt;servicename&gt;</code>)</li></ul></div></div><div class="section" title="Persistent properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec44"/>Persistent properties</h2></div></div></div><p>Any<a id="id344" class="indexterm"/> property starting with the prefix <code class="literal">persist</code> persists<a id="id345" class="indexterm"/> across reboots and is restored. The data is saved to <code class="literal">/data/property</code> in files of the same name as the property.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # ls /data/property/</strong></span>
<span class="strong"><strong>persist.gps.oacmode</strong></span>
<span class="strong"><strong>persist.service.bdroid.bdaddr</strong></span>
<span class="strong"><strong>persist.sys.profiler_ms</strong></span>
<span class="strong"><strong>persist.sys.usb.config</strong></span>
</pre></div></div><div class="section" title="SELinux properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec45"/>SELinux properties</h2></div></div></div><p>The <code class="literal">selinux.reload_policy</code> property is special. As<a id="id346" class="indexterm"/> we<a id="id347" class="indexterm"/> have seen, its use is for triggering a dynamic reload event.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec63"/>Summary</h1></div></div></div><p>In this chapter, we have examined how to create and label new and existing properties and some of the oddities that occur when doing so. We have also examined the hard coded DAC permission table for properties in <code class="literal">property_service.c</code>, as well as the hardcoded specialty properties like the <code class="literal">ctl.</code> family. In the next chapter, we look at how the tool chain builds and creates all the policy files we have been using.</p></div></body></html>