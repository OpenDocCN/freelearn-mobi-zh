<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Function and Operator Changes – New Ways to Get Things Done</h1></div></div></div><p>If you want to write useful code in Swift, or in any programming language, you have to, at the very least, create functions and use operators. In this chapter, we will examine what's changed in function declaration and usage and how those changes translate into better Swift code. We will also explain operator changes and highlight several that have been removed from the language.</p><p>Continuing the theme from the last chapter, I will provide you the Swift Evolution proposal numbers. Let's get started!</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Function declaration changes</h1></div></div></div><p>Swift provides a very flexible set of rules for defining functions. You can create functions with no parameters, with parameters, or even with argument labels. Every Swift function has a type, parameters (or no parameters), and a return type. For Swift 3, the language has been tweaked to make things more consistent and less complex.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec14"/>Consistent parameter labeling [SE-0046]</h2></div></div></div><p>Parameter labels are used for naming each argument in the function definition. In Swift 2.2 and earlier, function parameters could be defined with a local and an external label. The local argument label is required as this label is used to refer to the parameter in the body of the function. The external argument label, when provided, was used in the actual function call. You can think of the external label as your <em>shiny descriptive name at the call site</em> to provide good insight into what the argument represents. The internal label is, as the name implies, the name your function uses in the implementation of your logic. Since no one sees that local parameter, you could make it shorter to save some keystrokes.</p><p>Here's where things get interesting. By default, Swift 2.2 drops your external name when your function is called. Further adding to the confusion, Swift uses your local name as the external name for any remaining parameters, when external names are not present. The truly odd thing is that Swift only does this for functions. When you create a class, structure, or enumeration initializer (a special type of function to set initial values), Swift will create an external name for every parameter.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Swift Enumerations can be defined using a raw-value type. When you create a Swift enum using a raw-value, you will either get an initialized enum or nil. You can read more about Swift enums at <a class="ulink" href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145">https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145</a>
</p></div></div><p>The main reason for dropping the first argument name seems to be for historical correctness with Objective-C. Objective-C developers were instructed to incorporate the first parameter name into the function name. This same behavior was adopted by Swift and may have been a side effect of the initial translation of Objective-C libraries to Swift via the migrator.</p><p>Swift is an evolving language and is getting better with each new version. To stay consistent with the new API naming guidelines, Swift 3 now defaults to using the local names as the external names for all arguments including the first one.</p><p>In Swift 2.2:</p><pre class="programlisting">func gettingSwiftyUsingPeopleNamed(names: [String],  &#13;
                                   descriptionNames: [String],    &#13;
                                   shouldCapitalize: Bool){ &#13;
    // our function only has local names so those are the ones used &#13;
} &#13;
 &#13;
gettingSwiftyUsingPeopleNamed(["Joe", "Mark", "Roy", "Jessica"], &#13;
           descriptionNames: ["Awesome", "Silly", "Tall", "Short"], &#13;
           shouldCapitalize: true) &#13;
 &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">func gettingSwiftyUsing(names: [String],  &#13;
                         descriptions:[String],  &#13;
                         shouldCapitalize: Bool){ &#13;
    // our function only has local names so those are the ones used &#13;
} &#13;
 &#13;
gettingSwiftyUsing(names: ["Joe", "Mark", "Roy", "Jessica"],  &#13;
descriptions: ["Awesome", "Silly", "Tall", "Short"],  &#13;
shouldCapitalize: true) &#13;
</pre><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Last thought — if you prefer to not use argument labels in your function calls, you can suppress them using an underscore as the external name. This works for any of the argument positions.</p></div></div><pre class="programlisting">func boxit(_ width: Double, _ height: Double){ &#13;
    // argument label will be omitted in function call &#13;
} &#13;
 &#13;
boxit(23, 14)</pre><div><div><h3 class="title"><a id="note23"/>Note</h3><p>You can read the proposal at the following link <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md">https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md</a>
</p></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec7"/>Removing currying func syntax in declaration [SE0002]</h3></div></div></div><p>In Swift 2, you had the ability to create curried functions; which were rather confusing and seem to have little value in Swift. Much of the developer confusion in using them centers on whether the curried arguments are part of the main argument list or if the curried arguments signify the beginning of the argument list for a new function. Let's consider the following example that uses curried arguments:</p><pre class="programlisting">func curried(cosx: Int)(siny: Int) -&gt; Float { &#13;
    return (Float(cosx) * Float(siny)) / Float(cosx) &#13;
} &#13;
 &#13;
let result = curried(2)(siny:3) &#13;
</pre><p>It's extremely confusing to tell if the <code class="literal">(siny: Int)-&gt; Float</code> is part of the argument. The Swift team ultimately decided that we just don't need this in the language. Therefore, Swift 3 removes this syntax and suggests that you re-write your function to return a closure instead:</p><pre class="programlisting">func curriedV2(cosx: Int)-&gt;(Int)-&gt;Float{ &#13;
    return { siny in &#13;
        (Float(cosx) * Float(siny)) / Float(cosx) &#13;
    } &#13;
} &#13;
 &#13;
let intermediateFunctionReturn = curriedV2(2) &#13;
let result2 = intermediateFunctionReturn(3) &#13;
 &#13;
</pre><p>In our revised example, we define our function to return a closure. We then assign the result of this initial call to a variable named <code class="literal">intermediateFunctionReturn</code>. Last, we call the <code class="literal">intermediateFunctionReturn</code> closure, passing our Int argument, to get our final result.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md">https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md</a>
</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec15"/>Warning on Unused Results by Default [SE-0047]</h2></div></div></div><p>Attributes are special constructs that you apply to a declaration or type. You specify an attribute using the <code class="literal">@</code> symbol followed by a name and optionally any attribute arguments in parentheses.</p><pre class="programlisting">@&lt;attribute name&gt; &#13;
@&lt;attribute name&gt;(attribute arguments) &#13;
</pre><p>In Swift 2, the <code class="literal">@warn_unused_result</code> attribute is applied to a function or method to let the compiler know that it should provide a warning to the user if the attributed method or function is called without using the result. The <code class="literal">@warn_unused_result</code> attribute also allows you to provide either a message or <code class="literal">mutable_variant</code> attribute argument. The <code class="literal">mutable_variant</code> option is used when you want to let the developer know the name of the mutating method that accomplishes the same thing. The intent of using the attribute is to give guidance to the developer using your method, that the returned value is important and should be used.</p><p>For example, Swift 2 provides a <code class="literal">sort()</code> method and a <code class="literal">sortInPlace()</code> method (mutating) on the Foundation collection classes. If you were to call <code class="literal">sort()</code>(non-mutating) on an array but not use the result, then the compiler would warn you that you might really need the <code class="literal">sortInPlace()</code> method, which mutates the array and doesn't return anything. You can see an example usage of the <code class="literal">@warn_unused_result</code> below.</p><pre class="programlisting">@warn_unused_result(mutable_variant="sortInPlace") &#13;
    public func sort() -&gt; [Self.Generator.Element] &#13;
</pre><p>The main issue that developers have with <code class="literal">@warn_unused_result</code> is that it is only helpful if you apply the attribute to all of the relevant places (i.e. it is a proactive strategy on your part). If you forget to add the attribute, then no warnings will be sent. In Swift 3, the logic is reversed and you now get a warning on unused results by default. If you want to explicitly let the compiler know that the return value can safely be ignored, you can use the <code class="literal">@discardableResult</code> attribute. Here is an example that demonstrates its usage.</p><pre class="programlisting">@discardableResult &#13;
func complexFunctionNonEssentialResult()-&gt;Int{ &#13;
    // do complex logic &#13;
    // return trivial status code &#13;
    return 123 &#13;
} &#13;
 &#13;
</pre><div><div><h3 class="title"><a id="note25"/>Note</h3><p>In Swift 3, the mutating method <code class="literal">sortInPlace()</code> became <code class="literal">sort()</code> and the non-mutating version changed from <code class="literal">sort()</code> to <code class="literal">sorted()</code>.</p></div></div><div><div><h3 class="title"><a id="note26"/>Note</h3><p>You can read more about the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md">https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md</a>
</p></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec8"/>Removing var from function parameter lists [SE-0003]</h3></div></div></div><p>Using var in a function parameter list was valid in Swift 2. Since parameter types are immutable by default, developers attempted to use var in the parameter list to pass a mutable parameter to their function implementation. While you could do this in Swift, it actually proved to be a fairly useless tactic. Let me explain. Yes, you can use the var keyword to pass a mutable variant to your function body. However, any changes you make to the variable are not propagated back to the original type. Therefore, you are using a mutable copy that is scoped to the function's body. Let's examine how this works in practice with an example:</p><pre class="programlisting">func booyah(howHigh: Int){ &#13;
    howHigh += 100 // -&gt; illegal assignment &#13;
} &#13;
 &#13;
func booyahTake2(var yaFeelMe: Int){ &#13;
    yaFeelMe += 100   // -&gt; legal but doesn't write back to caller &#13;
} &#13;
</pre><p>You could have, just as easily, accomplished the same objective by assigning the passed in parameter to a local copy within the function body. See below for the equivalent function definition:</p><pre class="programlisting">func booyahTake3(yaFeelMe: Int){ &#13;
    var yaFeelMe = yaFeelMe &#13;
    yaFeelMe += 100 &#13;
} &#13;
</pre><p>Finally, many developers were confusing var parameters with those marked as inout. Either version will give a mutable local copy but only the inout variant will propagate changes back to function caller. Given the overall confusion, var as a parameter modifier has been removed in Swift 3. In the following example, the <code class="literal">howManyTimes</code> variable is updated with its value propagated back to the function caller because it is marked as an inout parameter:</p><pre class="programlisting">func trifecta(inout howManyTimes: Int){ &#13;
    howManyTimes += 2000  // updates the actual passed in variable &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note27"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md">https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec9"/>Removing ++ and -- operators [SE-0004]</h3></div></div></div><p>The increment (<code class="literal">++</code>) and decrement (<code class="literal">--</code>) operators were added to Swift because they existed in C. In addition, many developers coming to Swift are used to seeing them in the other languages. Let's examine how these operators work and then we can cover the gotchas.</p><pre class="programlisting">var row = 0 &#13;
let currentRow = ++row   // pre - adds 1 to row than assigns new value &#13;
let nextRow = row++       // post - assigns than adds 1 from row  &#13;
let previousRow = --row  // pre - minus 1 from row than assigns to value &#13;
let backOneRow = row--   // post - assigns than subtracts 1 from row &#13;
</pre><p>Disadvantages /Gotchas:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It's easy to get the pre and post part of the increment/decrement operator wrong, which gives you an incorrect output</li><li class="listitem" style="list-style-type: disc">The syntax is shorthand for <code class="literal">+=</code> or <code class="literal">-=</code>, which doesn't save you that many keystrokes over <code class="literal">+= 1</code> or <code class="literal">-= 1</code></li><li class="listitem" style="list-style-type: disc">The operators are largely used in C style <code class="literal">for…loops</code>, where the return value is ignored. Since we have <code class="literal">for…loops</code> loops, ranges, maps, and enumerate/iterate functions, we don't need these operators</li><li class="listitem" style="list-style-type: disc">You can only use these operators with a small set of types (such as integers and floating point scalars)</li><li class="listitem" style="list-style-type: disc">If you are learning your first programming language, these operators increase the amount of stuff you have to learn without providing meaningful value you couldn't get through other features that Swift offers</li></ul></div><p>Essentially, the Swift team felt the disadvantages of keeping these operators outweighed the advantages and opted to remove them in Swift 3.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>You can read the proposal here: <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md">https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Removing C-style for loops [SE-0007]</h3></div></div></div><p>Similar to the increment and decrement operators we just discussed, the C-style <code class="literal">for…in</code> loop also seems to have been added to Swift for its C language ancestry. Swift offers several <em>Swifty</em> conventions for iterating and looping that are better options than the C-style loop. In fact, C-style loops really aren't used all that much. Once a developer starts to master Swift concepts, the developer generally chooses not to use C-style loops. When considering the iteration of a collection, <code class="literal">for…in</code> loops are considerably harder to implement than <code class="literal">for…in</code> statements. Finally, if C-style <code class="literal">for</code> loops did not already exist in Swift; no one would miss them or beg for their inclusion into the language. With Swift 3, C-style for loops are officially eliminated from the language.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>You can read more about the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md">https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec11"/>Removing implicit tuple splat from functions [SE-0029]</h3></div></div></div><p>In previous versions of Swift, function calls allowed developers to pass an argument list in the form of a tuple, commonly referred to as a <em>tuple splat</em>. A <em>tuple splat</em> could be defined in one place and then passed to a function as one object, removing the need to pass individual arguments to a function. Let's take a look at an example to make this concept clearer.</p><pre class="programlisting">func fooTastic(members: [String], instruments:[String]){ &#13;
    // fantastic work happening here... &#13;
} &#13;
 &#13;
let foo = (["Jackson", "Carey", "Wonderland"], instruments:["drums", "bass", "keyboard"]) &#13;
fooTastic(foo) &#13;
 &#13;
</pre><p>In our example, we create the <code class="literal">fooTastic()</code> function to accept two String array arguments. We then created a tuple that encapsulates the arguments we want to pass to our function. Last, we call <code class="literal">fooTastic()</code> passing in our foo tuple. This works, but here are some disadvantages to consider:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our <code class="literal">foo</code> tuple has to mirror the way the arguments are represented in the function: meaning we have to drop the members parameter label. We must include the instruments label in our tuple or the compiler will complain when we pass the tuple as an argument.</li><li class="listitem" style="list-style-type: disc">Passing just a tuple to the function makes our method appear to have overloads, which is confusing to anyone tasked with maintaining this code.</li><li class="listitem" style="list-style-type: disc">The current implement of tuple splats is inconsistent and buggy in terms of implementation.</li></ul></div><p>All things considered, we just don't need this added complexity in the language and hence this feature has been removed from Swift 3.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>You can read more about the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md">https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec12"/>Adjusting inout declarations for type decoration [SE-0031]</h3></div></div></div><p>This is a minor change for Swift 3. The <em>inout</em> keyword has been moved to the right of the colon (:) and next to the type in function definitions. Nothing has changed about how <code class="literal">inout</code> variables behave in code. You are still giving the parameter decorated with <code class="literal">inout </code>the ability to mutate the value within the body of the function. The change is meant to move the decoration name closer to the type it is actually modifying. Since we are modifying the type and not the label, it makes more sense for the keyword to be next to the type.</p><p>In Swift 2:</p><pre class="programlisting">func trifecta(inout howManyTimes: Int){ &#13;
    howManyTimes += 2000 &#13;
} &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">func trifecta(howManyTimes: inout Int){ &#13;
    howManyTimes += 2000 &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note31"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md">https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec13"/>Replacing equal signs with colons for attribute arguments [SE-0040]</h3></div></div></div><p>As we discussed in <em>[SE-0047]</em>, attributes are special constructs that you apply to a declaration or type. You specify an attribute using the <code class="literal">@</code> symbol followed by a name and optionally any attribute arguments in parentheses:</p><pre class="programlisting">@&lt;attribute name&gt; &#13;
@&lt;attribute name&gt;(attribute arguments) &#13;
 &#13;
</pre><p>Unlike regular functions and parameter labels, you use <code class="literal">=</code> instead of a colon to separate the argument name from its value. This is inconsistent with our standard mode of operation in the rest of Swift. Therefore, in Swift 3, attribute arguments will receive the same treatment as other Swift arguments, using the colon over and equal sign.</p><p>In Swift 2:</p><pre class="programlisting">@warn_unused_result(mutable_variant="sortInPlace") &#13;
    public func sort() -&gt; [Self.Generator.Element] &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">@available(*, deprecated, renamed: "NSUnderlyingErrorKey") &#13;
    public static let underlyingErrorKey: ErrorUserInfoKey &#13;
</pre><div><div><h3 class="title"><a id="note32"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md">https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec14"/>Standardizing function type argument syntax to require parentheses [SE-0066]</h3></div></div></div><p>Functions are defined in Swift to use parentheses to enclose their argument lists. The purpose is to make it clear where the function declaration begins and ends. However, Swift 2 allowed you to call a function, under certain conditions, without using the parentheses. Let's look at an example to make this concept clearer. In the following example, we define functions using parentheses and their equivalents by dropping the parentheses:</p><pre class="programlisting">let a: (Int) -&gt; Int &#13;
let b: (Int) -&gt; (Int)-&gt; Int &#13;
</pre><p>This can also be written without parentheses as:</p><pre class="programlisting">let a1: Int -&gt; Int &#13;
var b1: Int -&gt; Int -&gt; Int &#13;
</pre><p>Granted, the second form is a bit shorter since it omits the parentheses. However, the trade-off introduces code that is not consistent with the way the function types are defined in the rest of the language. Frankly, you don't get any real value or expressive components by omitting the parentheses. Crafting function types this way is only syntactic sugar with no substance. In Swift 3, you will no longer be able to use this shortcut form when defining function types.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>You can read more about the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md">https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Enforcing the order of defaulted parameters [SE-0060]</h3></div></div></div><p>Order matters when you call a function in Swift, but there is one exception to this rule for functions that contain parameters with default arguments. Under this edge case, you can call this type of function using only a portion of the argument names. Let's look at some examples of how you can call a function that contains default parameters.</p><p>In Swift 2:</p><pre class="programlisting">func shifty(arg1: String = "", arg2: String = "", arg3: Int = 1){} &#13;
</pre><p>The first way to call the <code class="literal">shifty()</code> function is to use all of the default parameters, meaning we don't pass anything at the call site. This is valid in Swift 2 and is generally expected behavior. See below for an example using just the function with all default parameter values:</p><pre class="programlisting">shifty() &#13;
</pre><p>Another way to call the <code class="literal">shifty()</code> would be to omit the arguments we don't care about and only pass in the ones we do. We could pass in just one argument such as arg2 or arg3 and our function would continue to work. In the following example, we demonstrate calling our shifty function while omitting some of the parameters:</p><pre class="programlisting">shifty(arg2: "") &#13;
shifty(arg3: 3) &#13;
</pre><p>Finally, we could call the function with multiple arguments. See below for example usage of the shifty function with multiple arguments:</p><pre class="programlisting">shifty(arg2: "", arg3: 3) &#13;
 &#13;
shifty("", arg3: 3) &#13;
 &#13;
shifty(arg2: "", arg3: 4) &#13;
</pre><p>Allowing this behavior is actually a bit confusing to developers and goes against the strict ordering that is enforced throughout the rest of the language. Swift 3 removes this behavior and forces you to maintain the parameter ordering when using default parameters. Let's see how our <code class="literal">shifty()</code> function works now in Swift 3.</p><p>In Swift 3:</p><pre class="programlisting">func shifty(arg1: String = "arg1", arg2: String = "arg2", arg3: Int = 0){} &#13;
</pre><p>There is no change to how we call a function using all defaulted arguments:</p><pre class="programlisting">shifty() &#13;
</pre><p>When we call a function with just one argument, we have to use the argument label for our parameter. The other difference is that we can not just call the arguments in any order we choose. We can omit defaulted parameters but we can not call them in any order we choose. Let's examine some of the ways we can call our <code class="literal">shifty()</code> function in Swift 3.</p><pre class="programlisting">shifty(arg1: "") // valid &#13;
shifty(arg2: "") // valid &#13;
   shifty(arg3: 3)   //valid &#13;
   shifty(arg3: 3, arg1: "test")   //invalid! &#13;
</pre><p>If you think about this for a while, I bet you could see why the Swift team made this change. We sacrifice a shorter syntax for enhanced readability.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md">https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec16"/>Making optional requirements Objective-C only [SE-0070]</h3></div></div></div><p>Objective-C protocols have a feature that allows the developer to mark some of the behavior as optional. While this makes sense for Objective-C, it would not make sense as a Swift feature. In Swift, the protocol author could provide a default implementation using protocol extensions and protocol inheritance. Similarly, with protocol inheritance, the author could add the optional methods to a separate protocol that a developer could adopt if the optional behavior is of interest and not make it a requirement for all users of the protocol. The main takeaway is that you have better options in Swift for tackling optional protocol requirements and, therefore, adding Objective-C optional features on protocols to Swift is not necessary.</p><p>Now that we know why the Swift team opted not to include this as a Swift feature, let's discuss how to handle Objective-C optional in Swift 3. Basically, we use the <code class="literal">@objc</code> attribute to decorate the parts of the protocol we want to distinguish as an Objective-C only requirement. We also add the optional keyword to each of the function signatures. For the most part, you won't have to change anything on your end in Swift. You also don't have to modify your Objective-C code. The migrator handles all of the work for you.</p><p>In Objective-C:</p><pre class="programlisting">@protocol UICollectionViewDataSource &lt;NSObject&gt; &#13;
@required &#13;
 &#13;
- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; &#13;
 &#13;
- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; &#13;
 &#13;
@optional &#13;
 &#13;
- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView; &#13;
 &#13;
- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath; &#13;
 &#13;
- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath; &#13;
 &#13;
- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath; &#13;
 &#13;
@end &#13;
 &#13;
 &#13;
Swift &#13;
public protocol UICollectionViewDataSource : NSObjectProtocol { &#13;
 &#13;
public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#13;
 &#13;
public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#13;
 &#13;
optional public func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#13;
 &#13;
optional public func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -&gt; UICollectionReusableView &#13;
 &#13;
optional public func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -&gt; Bool &#13;
 &#13;
optional public func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) &#13;
}</pre><p>Our code snippets above show the Objective-C protocol (with optional methods) and the Swift version once it is passed through the migrator.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md">https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md</a>
</p></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter we covered how functions are created and called. We touched on several features that weren't very <em>Swifty</em> and have been removed in Swift 3. We also explored attributes and attribute arguments, focusing on syntax changes, and new additions and subtractions from the language. In the next chapter, we will do a deep dive into closures and collections.</p></div></body></html>