<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Gameplay, UI, and Effects</h1>
            </header>

            <article>
                
<p>In the previous chapter, we created basic gameplay and made sure the correct animation was triggered and the controls are in place. In this chapter, we will finish up the game play by adding a proper game loop so that there is a start, scoring, and gameover.</p>
<p>For the scoring, we will initially use debug to log out the health of the player and the AI. Later, we will look at Unity's <strong>Graphical User Interface</strong> (<strong>GUI</strong>) system and add a health indicator for both the player and the enemy.</p>
<p>Finally, we will also look at the Unity's particle system and the different parameters that we can manipulate to get the desired particle effect for the game.</p>
<p>This chapter includes the following topics:</p>
<ul>
<li>Finishing up the gameplay</li>
<li>Understanding Unity GUI</li>
<li>Adding GUI for health and gameover condition</li>
<li>Introduction to Particle Effects</li>
<li>Creating confetti Particle Effect</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Finishing up gameplay</h1>
            </header>

            <article>
                
<p>To track the player and enemy's health, we need variables to track how much health both have and how much damage both can do to each other.</p>
<p>For this, open up <kbd>playerScript</kbd> and add variables called <kbd>health</kbd> and <kbd>damage</kbd> at the top of the class. Then, set the value of the <kbd>health</kbd> variable to 100 and that of the <kbd>damage</kbd> variable to 10. So, the player will start with a health of 100, and when they hit the enemy, they will do a damage of 10 to the enemy:</p>
<pre>
    using UnityEngine; <br/>    using System.Collections; <br/>    public class playerScript : MonoBehaviour { <br/>        public int health = 100; <br/>        public int damage = 20; <br/><br/>        private Animator anim; <br/>        // other code <br/>    } 
</pre>
<p>Similarly, add the same code as that of <kbd>playerScript</kbd> class to the <kbd>enemyScipt</kbd> class as well. Since we want to be fair, we will set the enemy's health to be 100 as well and set the damage that they can do to 10. Make sure you use the <kbd>public</kbd> access specifier because only then we will be able to access the health variable when we try to access it in other classes:</p>
<pre>
    public class enemyScript : MonoBehaviour { <br/><br/>        public int health = 100; <br/>        public int damage = 10; <br/><br/>        private Animator anim; <br/>        // other code    <br/>    } 
</pre>
<p>Now, whenever the player/enemy takes a hit, we have to make sure that the health is reduced by the amount of damage that other player/enemy can inflict on them. So, in the section of the <kbd>Update</kbd> function, when we check whether the player or the enemy is getting hit, we have to reduce the amount of health by the damage.</p>
<p>In the <kbd>enemyScript</kbd> class, for checking if the enemy is hit, change the code as shown here:</p>
<pre>
    GameObject player = GameObject.Find("theDude"); <br/>    Animator pAnim = player.GetComponent&lt;Animator&gt;(); <br/><br/>    playerScript pScript = player.GetComponent&lt;playerScript&gt;(); <br/><br/>    //Getting Hit <br/><br/>    if (pAnim.GetBool("tIsPunching")){ <br/>        if (anim.GetBool("bEnemyIsDefending") == false) { <br/>            Debug.Log("enemy got hit"); <br/>            anim.SetTrigger("tEnemyGotHit"); <br/>            anim.SetBool("bEnemyIsDefending", true); <br/><strong>            health -= pScript.damage;</strong> <br/>        } <br/>    }  
</pre>
<p>We get the access to the player script by getting the <kbd>gameobject</kbd> player and adding the <kbd>GetComponent</kbd> component of the player script.</p>
<p>Once we have access to the script, we can get the amount of damage the player can do and reduce the current health of the enemy by the amount of damage. Now, move to <kbd>playerScript</kbd>, as we have to implement the same in the player script as well when the player gets hit by the enemy:</p>
<pre>
    GameObject enemy = GameObject.Find("Enemy"); <br/><br/>    Animator eAnim = enemy.GetComponent&lt;Animator&gt;(); <br/><br/>    enemyScript eScript = enemy.GetComponent&lt;enemyScript&gt;(); <br/><br/>    if (eScript.isPunching == true) { <br/>        if (anim.GetBool("bIsDefending") == false) { <br/>            Debug.Log("player got hit"); <br/>            anim.SetTrigger("tGotHit"); <br/>            health -= eScript.damage; <br/>        } <br/>    } 
</pre>
<p>Here, we will get access to the enemy script so that we can get the enemy damage as we did in the enemy script. Once we have access to the <kbd>damage</kbd> variable, we will reduce the health of the player by the amount of damage that was set in the enemy script. Now, you can run the game and the <kbd>Debug.log</kbd> script. The <kbd>Player Health</kbd> and <kbd>Enemy Health</kbd> entities seem to be getting affected, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="201" src="assets/image_05_001.png" width="258"/></div>
<p>Once we have the player and enemy health being calculated, we can set the game over condition. Once the player's health or enemy's health gets less than or equal to zero, it is game over.</p>
<p>The gameloop is the controller by the third script. We will call this script <kbd>gameScript</kbd>.</p>
<p>It is a very simple script that gets access to both <kbd>playerScript</kbd> and <kbd>enemyScript</kbd>, and it checks for the health of both the player and the enemy. Once either of the player or enemy script becomes less than zero, it announces that the game is over.</p>
<p>So, we will create a new script called <kbd>gameScript</kbd> and add the following lines of code to the script:</p>
<pre>
    using System.Collections; <br/>    using System.Collections.Generic; <br/>    using UnityEngine; <br/><br/>    public class gameScript : MonoBehaviour { <br/><br/>        playerScript pScript; <br/>        enemyScript eScript; <br/>        public bool bGameover = false; <br/><br/>        // Use this for initialization <br/>        void Start () { <br/><br/>            GameObject player = GameObject.Find("theDude"); <br/>            pScript = player.GetComponent&lt;playerScript&gt;(); <br/><br/>            GameObject enemy = GameObject.Find("Enemy"); <br/>            eScript = enemy.GetComponent&lt;enemyScript&gt;(); <br/>        } <br/><br/>        // Update is called once per frame <br/>        void Update () { <br/>            if (!bGameover) { <br/><br/>                int playerHealth = pScript.health; <br/>                int enemyHealth = eScript.health; <br/><br/>                /* Debug.Log("PlayerHealth: " + playerHealth + "  <br/>                EnemyHealth: " + enemyHealth); */ <br/><br/>                if (playerHealth&lt;= 0 || enemyHealth&lt;= 0) { <br/>                    bGameover = true; <br/>                    Debug.Log(" +++++ GAMEOVER +++++"); <br/>                } <br/>            } <br/>        } <br/>    } 
</pre>
<p>At the top of the class, we created three variables. The first two are for getting access to the player and enemy scripts. The third variable is a public Boolean that sets whether the game is over or not. Since it is the start of the game and it is not over yet, we set it to false at the start.</p>
<p>In the <kbd>Start</kbd> function, we found the player and the enemy and got access to the individual scripts using the get component function.</p>
<p>Then, in the <kbd>Update</kbd> function ,we first checked whether the game is not over. If it is not over, then we get the player's and enemy's health and store it in a local variable called <kbd>playerHealth</kbd> and <kbd>enemyHealth</kbd>, respectively.</p>
<p>We then do a check if the player health or the enemy health is less than or equal to 0. If that is the case then we set the <kbd>bGameover</kbd> Boolean variable to <kbd>true</kbd> and the <kbd>Debug.log</kbd> is called, that it is gameover.</p>
<p>Now for the script to actually run it needs to be attached to an object in the scene. It could be a dummy object or any other object in the scene. Luckily we have a camera that is just sitting there and is part of the scene. So, we will attach the <kbd>gameScript</kbd> to the camera as a component.</p>
<p>Once the script is attached to the camera run the game and see if it reaches gameover condition:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="211" src="assets/image_05_002.png" width="262"/></div>
<p>You will notice now that even though the game is over, the enemy keeps punching the player and the player can still punch the enemy. We don't want this as it may lead to some unnecessary bugs in the game.</p>
<p>So, in the player and enemy scripts, we need to get access to the <kbd>gameScript</kbd> class and make sure that once it is gameover, nothing updates. In the player's class, we will create a new <kbd>GameObject</kbd> called <kbd>mainCamera</kbd> at the top of the class as shown in the following code:</p>
<pre>
    public class playerScript : MonoBehaviour { <br/><br/>        public int health = 100; <br/>        public int damage = 20; <br/><br/>        float totalTime = 0.0f; <br/>        float timeSinceLastHit = 0.0f; <br/>        float hitTimeInterval = 0.0f; <br/><br/>        private Animator anim; <br/><br/><strong>        public GameObject mainCamera;</strong> <br/><br/>        // other code <br/>    } 
</pre>
<p>In the <kbd>Update</kbd> function, we get access to the <kbd>gameScript</kbd> complement of the camera and then whatever is in the <kbd>Update</kbd> function, we put it in an <kbd>if</kbd> condition, which will check whether the game is over.</p>
<p>If the game is not over, then everything inside the <kbd>if</kbd> condition will be updated. Otherwise, it will skip through and not update. Here is the updated <kbd>Update</kbd> function (no pun intended):</p>
<pre>
    void Update () { <br/>        gameScript gScript = mainCamera.GetComponent&lt;gameScript&gt;(); <br/><br/>        if (!gScript.bGameover) { <br/>            totalTime += Time.deltaTime; <br/><br/>            //Getting Hit  <br/>            GameObject enemy = GameObject.Find("Enemy"); <br/>            Animator eAnim = enemy.GetComponent&lt;Animator&gt;(); <br/>            enemyScript eScript = enemy.GetComponent&lt;enemyScript&gt;(); <br/><br/>            if (eScript.isPunching == true) { <br/>                if (anim.GetBool("bIsDefending") == false) { <br/><br/>                    //Debug.Log("player got hit"); <br/>                    anim.SetTrigger("tGotHit"); <br/><br/>                    health -= eScript.damage; <br/>                    Debug.Log("Player Health: " + health); <br/>                } <br/>            } <br/>            // Defending <br/>            if (Input.GetButtonDown("Fire2")) { <br/>                //Debug.Log("Jump pressed"); <br/>                anim.SetBool("bIsDefending", true); <br/>            } <br/>            else if (Input.GetButtonUp("Fire2")) { <br/>                anim.SetBool("bIsDefending", false); <br/>            } <br/><br/>            // Debug.Log("Delta time" + timeChangeInMillis); <br/>            // Attacking <br/>            if (totalTime&gt;= timeSinceLastHit + hitTimeInterval) { <br/>                if (Input.GetButtonDown("Fire1")) {     <br/>                    anim.SetBool("bIsDefending", false); <br/>                    anim.SetTrigger("tIsPunching"); <br/><br/>                    timeSinceLastHit = totalTime; <br/>                    //Debug.Log("Fire pressed"); <br/>                } <br/>            } <br/>        } // check if gameover <br/>    } // update  
</pre>
<p>Now, we have to do the similar operations on enemy script as well. Here is the updated code for the enemy class:</p>
<pre>
    using UnityEngine; <br/>    using System.Collections; <br/><br/>    public class enemyScript : MonoBehaviour { <br/><br/>        public int health = 100; <br/>        public int damage = 10; <br/><br/>        private Animator anim; <br/><br/>        public GameObjectmainCamera; <br/><br/>        // public GameObject player; <br/><br/>        int myTick = 0; <br/>        int currentTick = 0; <br/>        int prevTick = 0; <br/>        int nextTick = 10; <br/>        int punchTick = 0; <br/><br/>        public bool isPunching = false; <br/><br/>        int[] pattern = new[] {120, 30, 180, 30, 60, 30, 40, 60, 180,  <br/>                               30, 30, 30 ,120, 60, 60, 180, 30, 30,  <br/>                               120, 30 }; <br/>        int patternCount = 0; <br/>        // Use this for initialization <br/><br/>        void Start () { <br/>            anim = GetComponent&lt;Animator&gt;(); <br/>            anim.SetBool("bEnemyIsDefending", true); <br/><br/>            Shuffle(pattern); <br/><br/>            nextTick = pattern[0]; <br/>        } //start <br/><br/>        // Update is called once per frame <br/>        void Update () { <br/><br/>            punchTick--; <br/>            myTick++; <br/>            currentTick = myTick; <br/>     <br/>            gameScript gScript = mainCamera.GetComponent&lt;gameScript&gt;(); <br/><br/>            if (!gScript.bGameover) { <br/><br/>                GameObject player = GameObject.Find("theDude"); <br/>                Animator pAnim = player.GetComponent&lt;Animator&gt;(); <br/>                playerScript pScript = player.GetComponent&lt;playerScript&gt;(); <br/><br/>                //Getting Hit <br/>                if (pAnim.GetBool("tIsPunching")) { <br/>                    if (anim.GetBool("bEnemyIsDefending") == false) { <br/>                        // Debug.Log("enemy got hit"); <br/>                        anim.SetTrigger("tEnemyGotHit"); <br/>                        anim.SetBool("bEnemyIsDefending", true); <br/><br/>                        health -= pScript.damage; <br/><br/>                        Debug.Log("Enemy Health: " + health); <br/>                    } <br/>                } <br/>     <br/>                if (currentTick == prevTick + nextTick) { <br/>                    int choice = Random.Range(1, 4); <br/>                    // Debug.Log("Choice" + choice); 
</pre>
<p>Depending on a random number going from one to three, we will choose whether the AI will punch, defend, or be idle:</p>
<pre>
                switch (choice) <br/>                { <br/>                    //will punch <br/>                    case 1: <br/>                        anim.SetBool("bEnemyIsDefending", false); <br/>                        anim.SetTrigger("tEnemyIsPunching"); <br/>                        anim.SetBool("bEnemyIsDefending", true); <br/>                        isPunching = true; <br/>                        punchTick = 1; <br/>                        break; <br/><br/>                    //will defend <br/>                    case 2: <br/>                        anim.SetBool("bEnemyIsDefending", true); <br/>                        break; <br/><br/>                    //will be idle  <br/>                    case 3:  <br/>                        anim.SetBool("bEnemyIsDefending", false);  <br/>                        break; <br/>                } <br/><br/>                prevTick = currentTick; <br/>                nextTick = pattern[patterCount];//Random.Range(20, 300); <br/><br/>                if ((patterCount + 1) &gt;= pattern.Length) { <br/>                    patterCount = 0; <br/>                    Shuffle(pattern); <br/>                }  <br/>                else { <br/>                    patterCount++; <br/>                } <br/>            } <br/><br/>            if (punchTick&lt;= 0) { <br/>                punchTick = 0; <br/>                isPunching = false; <br/>            } <br/>        } // check if gameover <br/>    } // Update 
</pre>
<p>The <kbd>Shuffle</kbd> function rearranges the initial array so that we get a different set of random numbers:</p>
<pre>
    void Shuffle(int[] a) {  <br/>        for (int i = a.Length - 1; i &gt; 0; i--){ <br/>            int rnd = Random.Range(0, i); <br/>            int temp = a[i]; <br/><br/>            a[i] = a[rnd]; <br/>            a[rnd] = temp; <br/>        } <br/><br/>        for (int i = 0; i &lt;a.Length; i++){ <br/>            // Debug.Log(a[i]); <br/>        } <br/><br/>    } // shuffle 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Understanding Unity uGUI</h1>
            </header>

            <article>
                
<p>With the introduction of the Unity's <strong>uGUI</strong> system, it has been very convenient to set up GUI elements in Unity. We will look at how uGUI works and how to display image and text on to the scene. We will also see how to change the text dynamically in the next topic when we implement the health for the player and the enemy.</p>
<p>All the UI elements in Unity are present in the <span class="packt_screen">GameObject</span> dropdown in the menu in Unity, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="384" src="assets/image_05_003.png" width="398"/></div>
<p>You can create three types of basic UI elements: <span class="packt_screen">Text</span>, <span class="packt_screen">Image</span>, and <span class="packt_screen">Raw Image</span>.</p>
<p>The <span class="packt_screen">Text</span> option in the menu is a basic text element used to display text-like score, health, energy, and so on. So, like any text element, you can specify text height and font, such as bold or italic. When you create a new text element, there are options such as <span class="packt_screen">Canvas</span>, <span class="packt_screen">Text</span>, and <span class="packt_screen">EventSystem</span> added for each text element that you add:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_004.png"/></div>
<p>When a new text UI element is created, it is placed at the center by default, with the default text <span class="packt_screen">New Text</span>, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_005.png"/></div>
<p>The <span class="packt_screen">Canvas</span> option in the menu represents where the text component exists in the scene and is also responsible for rendering the text on to the scene. Components to the canvas element can also be added directly by right-clicking on it. You can also add empty game objects to it:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="426" src="assets/image_05_006.png" width="207"/></div>
<p>Canvas is made up three scripts: <span class="packt_screen">Canvas</span>, <span class="packt_screen">Canvas Scalar</span>, and <span class="packt_screen">Graphics Ray Caster</span>.</p>
<p>By default, the canvas is set to <span class="packt_screen">Screenspace Overlay</span>. There is also <span class="packt_screen">Screenspace Camera</span> and <span class="packt_screen">World Space</span> options. In <span class="packt_screen">Screenspace Overlay</span>, the text will set on top of everything in the scene irrespective of whether the camera is in focus. This is used in traditional games where the UI needs to sit on top of the game.</p>
<p>If you want different UIs depending on which camera is selected, you can use <span class="packt_screen">ScreenSpace Camera</span> and then you can attach different UIs to the cameras. To navigate between the different UIs, you will go back and forth between the cameras for the two UIs.</p>
<p>In <span class="packt_screen">World Space</span>, the canvas is placed with respect to the world position. So, you can place the button or text in 3D space and position it accordingly. You can move, rotate, and scale the text as well. The user will still be able to navigate and use the UI element. This gives absolute freedom to place the UI element wherever you want in the 3D space.</p>
<p>You can select the <span class="packt_screen">Pixel Perfect</span> option if you want your text to be aligned to a pixel grid. <span class="packt_screen">Canvas Scalar</span> will scale the text up and down based on the resolution. By default, it is set to <span class="packt_screen">Constant Pixel Size</span>. You can also set it to <span class="packt_screen">Scale with Screen Size</span> or <span class="packt_screen">Constant Physical size</span>.</p>
<p>The <span class="packt_screen">Graphics RayCaster</span> script is responsible for getting input from the keyboard, mouse, or touch. If removed, the UI element will no longer accept mouse clicks and keyboard events.</p>
<p>Talking about the <span class="packt_screen">EventSystem</span> option, let us look at the EventSystem components.</p>
<p>An EventSystem is also created. The event system handles input from mouse, keyboard, and controllers. If you want certain events to be triggers at the click of the mouse, this would be specified here:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="337" src="assets/image_05_007.png" width="213"/></div>
<p>Whenever you create and new UI component and new Canvas and EventSystem is automatically created. Select the text so that we can have a closer look at the component in detail:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="512" src="assets/image_05_008.png" width="223"/></div>
<p>A UI game object is just like any other game object, but unlike others, it has <kbd>RectTransform</kbd> instead of a regular transform, has a Canvas Renderer, and also has a <span class="packt_screen">Text (Script)</span> option attached to it.</p>
<p><span class="packt_screen">Rect Transform</span> is made up of different properties. The important one is positions;<br/>
the others are width and height. These depend on how our anchors are set up. By default, <span class="packt_screen">Rect Transform</span> is set to middle and center. You can click on the <span class="packt_screen">Anchor Presents</span> option to change the preset:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_009.png"/></div>
<p>Changing <span class="packt_screen">Anchor Presets</span> will also affect the <span class="packt_screen">X</span> and <span class="packt_screen">Y</span> positions of the button or text on the scene. Anchors can also be manually changed as per your requirement:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_010.png"/></div>
<p>Next, we will talk about the <span class="packt_screen">Pivot</span> field. The pivot is the position around which the UI will rotate. Then, there are <span class="packt_screen">Rotate</span> and <span class="packt_screen">Scale</span> fields, which work as other transform objects.</p>
<p>Now, let's look at the Text Script. The Text Script has a text box. This is where you can type whatever text you want be displayed on to the scene.</p>
<p>After that, there is the <span class="packt_screen">Character</span> section. Here, you can change the property of the character. You can change the font, font style--that is, if you want normal, bold, or italic; size of the font--and line spacing. Note that Unity doesn't let you set the distance between the characters horizontally.</p>
<p>The <span class="packt_screen">Paragraph</span> section lets you control the position, color, and material of the paragraph itself. You can center align the paragraph, set the horizontal and vertical overflow, or set it to best fit.</p>
<p>Instead of a <span class="packt_screen">Text</span>, if you add an <span class="packt_screen">Image</span> UI element, <span class="packt_screen">Canvas</span> and <span class="packt_screen">EventSystem</span> are maintained, but the image itself has the usual <span class="packt_screen">Rect Transform</span> and <span class="packt_screen">Canvas Renderder</span> properties. Instead of the Text (Script), there is an Image (Script) that is added:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="325" src="assets/image_05_011.png" width="329"/></div>
<p><span class="packt_screen">Image (Script)</span> has fewer objects in it. We have the <span class="packt_screen">Source Image</span> option in which you can specify the image to be displayed. You can change the color or material of the image as well.</p>
<p>With all this information, let's add player and enemy text and also a gameover text overlay, which will appear once the game is over.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Adding GUI for health and gameover</h1>
            </header>

            <article>
                
<p>In the game scene, add three texts and name them <kbd>enemyHealthText</kbd>, <kbd>playerHealthText</kbd>, and <kbd>gameOverText</kbd>.</p>
<p>The <span class="packt_screen">enemyHealthText</span> text is positioned, as shown in the following screenshot, with the anchor at the center and the font height set to 32. The rest are set to default:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_012.png"/></div>
<p>The <span class="packt_screen">playerHealthText</span> text is set at a position, as shown in the following screenshot, with text height changed to 32:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_013.png"/></div>
<p>The text color has been changed to blue for the enemy and red for the player. The <span class="packt_screen">gameoverText</span> text is set to the middle of the canvas, with text height set to 75 and the color set to a nice purple so that it is easily visible.</p>
<p>In the <span class="packt_screen">Text</span> field, add the text <span class="packt_screen">GAME OVER!!!</span>, as shown in the following screenshot:.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="510" src="assets/image_05_014.png" width="329"/></div>
<p>One thing we haven't seen yet is how to control the text by code. Let's see next how to do that.</p>
<p>In the <span class="packt_screen">gameScript</span> script, add three public variables of type <kbd>Text</kbd>, as given the following code snippet. This will hold the text object from the <kbd>Text</kbd> UI elements created:</p>
<pre>
    public Text enemyTextInstance; <br/>    public Text playerTextInstance; <br/>    public Text gameOverText;  
</pre>
<p>You will also need to add the UI namespace at the top of the class for it to work, so add the following line at the top of the class:</p>
<pre>
    using UnityEngine.UI; 
</pre>
<p>Next, in the <kbd>Update</kbd> function, after we get the health values from the enemy and the player, assign the values to the newly created text variables as follows:</p>
<pre>
    int playerHealth = pScript.health; <br/>    int enemyHealth = eScript.health; <br/><br/>    enemyTextInstance.text = "Health: " + enemyHealth.ToString(); <br/>    playerTextInstance.text = "Health: " + playerHealth.ToString(); 
</pre>
<p>In <kbd>MainCamera</kbd> on which <kbd>gameScript</kbd> is attached, make sure you drag and drop <span class="packt_screen">enemyHealthText (Text)</span>, <span class="packt_screen">playerHealthText (Text)</span>, and <span class="packt_screen">gameOverText (Text)</span> from the Hierarchy on to the script component, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_015.png"/></div>
<p>Finally, to make sure that the gameover text only appears once it is game over, in the start function of <span class="packt_screen">gameScript</span>, disable <kbd>gameOverText</kbd>, as shown in the following code:</p>
<pre>
    gameOverText.enabled = false; 
</pre>
<p>In the <kbd>Update</kbd>  function, once the <kbd>bGameover</kbd> Boolean variable is set to <kbd>true</kbd>, enable the <kbd>gameOverText</kbd> as shown in the following code:</p>
<pre>
    gameOverText.enabled = true; 
</pre>
<p>Now, if you run the game, you will see the score getting updated:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="474" src="assets/image_05_016.png" width="546"/></div>
<p>Once the game is over, you will see the gameover text overlay:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="496" src="assets/image_05_017.png" width="576"/></div>
<p>Now that we are done with the gameplay, let's add some effects to the scene using Particle Effect.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction to Particle Effects</h1>
            </header>

            <article>
                
<p>Particle Effects are a very big part of a game experience; they add ambience to the game or let us know that something special is going to happen or is happening. We see particles in the form of dust, clouds, rain, and also in the form of the celebration that happens at the end of the game. They can really be whatever you plan to make of them. For the purpose of our game, we are going to add confetti at the gameover.</p>
<p>A particle system in Unity is also a game object, so to create a particle system, go to the <span class="packt_screen">GameObject</span> menu and select the <span class="packt_screen">Particle System</span> option:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="187" src="assets/image_05_018.png" width="248"/></div>
<p>Press the <em>F</em> key on the keyboard to highlight the <span class="packt_screen">Particle System</span> option as it might be created away from the main camera. In my case, it was created at 900, 300, and -26. Don't worry about the positioning of the particle. We will manually change where we want the particle to be created at the end when we want it to be spawned.</p>
<p>Once you zoom in on the Particle System, you will see a cone shape and see particles coming out of the shape. The cone specifies the shape of the emitter, and the white particles are the actual particles that are emitted from the Particle System. This is represented by the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="295" src="assets/image_05_019.png" width="313"/></div>
<p>Like any game object, you will also see three arrows that let you position the particle system. You also need to press the <em>Q</em>, <em>W</em>, and <em>E</em> keys to position, rotate, and scale the size of the emitter, respectively.</p>
<p>Once you select <span class="packt_screen">Particle System</span> in the Hierarchy, it will show how the particles will be created in the scene. If you select some other object or deselect the Particle System, the animation stops. So, if you would like to preview how the particles are getting created, then select the Particle System in the Hierarchy to get a preview of it.</p>
<p>Let's see some of the important parameters that you can modify in the <span class="packt_screen">Inspector</span> pane for the Particle System:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_020.png"/></div>
<p>Like all other game objects, you can position, rotate, and scale the Particle System, the first set of parameters are as shown in the following screenshot. These parameters control how the particles are initially created:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_021.png"/></div>
<p>A brief description of all the parameters is given here:</p>
<ul>
<li><span class="packt_screen">Duration</span>: This specifies for how long initially the particles are created. By default, it is set to 5 seconds. At present, you won't see a difference as looping is enabled. If you disable looping, then if you select <span class="packt_screen">Particle System</span> in the Hierarchy, you will see that the particles emit for 5 seconds and then stop.</li>
<li><span class="packt_screen">Looping</span>: This should be disabled if you don't want the particles to be spawned continuously. So, if you want a burst of particles, disable looping.</li>
<li><span class="packt_screen">Prewarm</span>: This parameter loads the particles beforehand so that it won't look as if the particles are getting generated at the start of the scene. For example, if you have a water fall particle system and when the scene loads, it should look as if the water fall was running before the scene was loaded. If the waterfall starts to form just after the scene was loaded, it won't look practical.</li>
<li><span class="packt_screen">Start Delay</span>: You can set the particles form after a delay in using this parameter. Right now the particles start forming right after you click the particle system in the hierarchy, but if you want the particles to be formed a second after, then you will type <kbd>1.0</kbd> and the particles will form a second after you click the Particle System.</li>
<li><span class="packt_screen">Start Lifetime</span>: Each particle lasts for a certain period of time and then it gets deleted from the scene. By default, the particle is always set to be deleted after 5 seconds. If you want the particle to last longer in the scene, this parameter can be changed to cater to your needs.</li>
<li><span class="packt_screen">Start Speed</span>: This is the initial speed of each particle. By default, this is also set to 5.</li>
<li><span class="packt_screen">Start Size</span>: This is the initial size of the particle. By default, it is set to 1. It is the particle object in the initial size that it was created. If you created particles bigger and you would like to reduce the size by half, you will type in 0.5.</li>
<li><span class="packt_screen">Start Rotation</span>: If you want the particles to be generated at an angle in which they were created, then you can set the angle here.</li>
<li><span class="packt_screen">Randomize Rotation</span>: If you want the particles to be created at different angles, then you can specify the angle here. Unlike start rotation, which would create all the particles at the same angle, randomize rotation will create each particle at a different angle.</li>
<li><span class="packt_screen">Start Color</span>: This specifies the initial color in which each of the particles is created. By default, it is set to white. You can change the color by clicking on the white bar and specifying the color.</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="410" src="assets/image_05_022.png" width="215"/></div>
<ul>
<li><span class="packt_screen">Gravity Modifier</span>: This enables gravity. By default, the value is set to 0, meaning that there is no gravity. If you set the value to 1, you have enabled gravity to the maximum. You can also set the value to between zero and one for an appropriate gravity level as you desire.</li>
<li><span class="packt_screen">Simulation Space</span>: This specifies all the changes that are made after the each particle locally; that is, with respect to the origin of individual particle. By default, set it to local.</li>
<li><span class="packt_screen">Simulation Speed</span>: This specifies the speed at which the simulation is calculated. You can speed up or slow down the simulation. This is useful to see how your particles will behave if you have a particle system that takes time to mature.</li>
<li><span class="packt_screen">Scale Mode</span>: Set this to local. This specifies that the scale affects each particle with respect to the particle's origin and not the origin of the emitter or the world.</li>
<li><span class="packt_screen">Play on Awake</span>: The particles system becomes active as soon as the scene starts. If you don't wish the particle to start immediately at the start of the scene, then you need to uncheck this parameter.</li>
<li><span class="packt_screen">Max Particles</span>: This is the maximum number of particles that can be present in the scene at a time. By default, set it to 1,000. This should be kept as minimum as possible as it would significantly reduce the performance of the game, because the more particles you have in the scene, the more render calls are required and more calculation is required for each particle.</li>
<li><span class="packt_screen">Auto Random</span>: Seed generates a seed to automatically randomize the spawn and movement of each of the particle.</li>
</ul>
<p>The next set of parameters is optional and requires checking and unchecking if you would like to enable or disable these features:</p>
<ul>
<li><span class="packt_screen">Emission</span>: This specifies the amount of particles getting generated in a second. The <span class="packt_screen">Rate over Time</span> option is set to 10, meaning there are 10 particles generated in a span of 1 second. If you set it to 1, then you will see 1 particle each second. The <span class="packt_screen">Rate over Distance</span> option will work only when World Space Simulation is used. In the <span class="packt_screen">Bursts</span> mode, you can create a burst of particle depending on the duration that you initially set. So, here, when you click on the <span class="packt_screen">+</span> icon, it will create 30 particles every 5 seconds:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_023.png"/></div>
<ul>
<li><span class="packt_screen">Shape</span>: This specifies the shape of the particle system itself. By default, it is set to <span class="packt_screen">Cone</span>. Since the Particle System is the shape of the cone, you can see that the particles are generated and move upward in the specified shape. If you want the particle to spread in all directions, then you can specify sphere. You can also select between box, mesh, circle, and edge. By selecting mesh, you can specify a certain mesh and let the particle be generated from that specified mesh shape.</li>
<li>There are other parameters as well, such as angle, radius.</li>
<li><span class="packt_screen">Emit from:</span> This specifies from where the particles will be generated from, such as Base, Base Shell, Volume, and Volume Shell.</li>
<li>You can also randomize the direction or align to a specific direction:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_024.png"/></div>
<ul>
<li><span class="packt_screen">Velocity over Lifetime</span>: If you would like the velocity to be changed over time, then you can specify here. If not specified, then the speed would be kept constant, and it would be the same that was set initially.</li>
<li><span class="packt_screen">Limit velocity Over Lifetime</span>: This can limit the speed of the particle so that once the particle has reached a specific speed over lifetime, it is set either to that speed or slowly reduces over time to the initial speed set.</li>
<li><span class="packt_screen">Inherit Velocity</span>: This controls the speed of the particle depending on the speed of the emitter itself. The faster the emitter moves, the faster the particles are.</li>
<li><span class="packt_screen">Force Over Lifetime</span>: This sets the force of each particle over the lifetime. So, the particle will move faster over a period of time if this value is set.</li>
<li><span class="packt_screen">Color Over Lifetime</span>: The color of each particle can be changed depending on when it was generated.</li>
<li><span class="packt_screen">Color by Speed</span>: The color of each particle is specified by the speed of the particle itself.</li>
</ul>
<p>Similarly, we have size and rotation, which are either controlled by what stage they are in their lifetime or the speed at which they are moving:</p>
<ul>
<li><span class="packt_screen">External Force</span>: You can simulate the exertion of external force on the particle by changing the multiplier on the external force, for example, the case of wind.</li>
<li><span class="packt_screen">Noise</span>: You can also generate randomness using noise, which will use perlin noise-like texture to create random movement and behavior of the particles:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_025.png"/></div>
<ul>
<li><span class="packt_screen">Collision</span>: The particles as of yet won't react to other objects in the scene, so if you place an object in from of the particle, the particle would just go through the object. When you enable collision, the particle will collide with the object instead of going through it:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_026.png"/></div>
<ul>
<li><span class="packt_screen">Triggers</span>: Particles can also be used as triggers if the <span class="packt_screen">Triggers</span> option setting is turned on:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_027.png"/></div>
<ul>
<li><span class="packt_screen">Sub Emitter</span>: Each particle can also emit objects when you enable the <span class="packt_screen">Sub Emitter</span> option. Also, each particle will also emit other particles.</li>
<li><span class="packt_screen">Texture Sheet Animation</span>: Instead of static images, you can also specify a texture sheet so that each particle is animated instead of displaying a static image:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_028.png"/></div>
<ul>
<li><span class="packt_screen">Lights and Trils</span>: Each particle can also have a light source and trails attached to them to make the scene more eye catching and pretty.</li>
<li><span class="packt_screen">Renderer</span>: This specifies a lot of parameters like the shape of the particle itself, if it needs to be a billboard or a mesh. So, in a mesh, you can specify 3D objects such as a box, sphere, cone, and the normal direction of the particle and the material.</li>
</ul>
<p>You can specify the sort mode, minimum and maximum particle size, alignment, and pivot. Each particle and cast receiving shadows has light probes, reflects light probes, and so on:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_029.png"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating confetti Particle Effect</h1>
            </header>

            <article>
                
<p>For the confetti, we create a Particle System as usual. For the initial values, we keep the position to be 0,0,-7.5. For rotation and scale value, we keep at default.</p>
<p>We keep the duration at 4 and uncheck the Looping option as we don't want the confetti to be created over and over. <span class="packt_screen">Start Delay</span> is set to 0.</p>
<p><span class="packt_screen">Start Speed</span> is set to 5 and <span class="packt_screen">3D Start Size</span> is set to 0.25 in the <kbd>X</kbd>, <kbd>Y</kbd>, and <kbd>Z</kbd> directions. The <span class="packt_screen">3D Start Rotation</span> option is disabled. <span class="packt_screen">Start Rotation</span> and <span class="packt_screen">Randomize Rotation</span> are set to 0.</p>
<p><span class="packt_screen">Start Color</span> is set to randomize between two colors, red and blue. <span class="packt_screen">Gravity Multipler</span> is set to 0.125, and we want the confetti to fall down after it has reached its maximum height.</p>
<p>The rest of the initial values are set to default:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_030.png"/></div>
<p><span class="packt_screen">Emission</span> is set to 20 for <span class="packt_screen">Rate over Time</span>, and <span class="packt_screen">Shape</span> is set to <span class="packt_screen">Cone</span>.</p>
<p>To make the confetti more colorful and also change color over time, the color over lifetime is changed. So, change it to your needs. The <span class="packt_screen">Color over Speed</span> parameter is also changed similarly. Both are set to <span class="packt_screen">Random Between 2 Gradients</span>.</p>
<p>Size over lifetime is changed so that the size of the particles changes over time. <span class="packt_screen">Size</span> is set to a curve so that the particle starts out small and then becomes full size at the end of the lifecycle.</p>
<p>The shape of the curve is as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_031.png"/></div>
<p>The <span class="packt_screen">Rotation over Lifetime</span> and <span class="packt_screen">Rotation by Speed</span> options are set to 45 so that the particles rotate in air once created:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_032.png"/></div>
<p>For <span class="packt_screen">Renderer</span>, I wanted to take 3D objects as particles, so I selected <span class="packt_screen">Mesh</span>, and for <span class="packt_screen">Mesh</span>, I selected <span class="packt_screen">Cube</span>, <span class="packt_screen">Cylinder</span>, and <span class="packt_screen">Sphere</span> by clicking the <span class="packt_screen">+</span> sign at the bottom. Rest of the values are kept as default:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_033.png"/></div>
<p>Now, our Particle System is created. We will now create a prefab object in the <kbd>Assets</kbd> folder and drag the Particle System in it so that we can instantiate the prefab at gameover. Call the prefab <span class="packt_screen">particleSystem</span>. You will notice that once you drag the Particle System into the prefab, it becomes blue, as shown in the following screenshot. Now, delete the Particle System from the Hierarchy:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_05_034.png"/></div>
<p>Next in <span class="packt_screen">gameScript</span>, create a new <kbd>GameObject</kbd> at the top and call it <kbd>particlePrefab</kbd> and make the variable <kbd>public</kbd>, as given in the following code:</p>
<pre>
    public GameObject particlePrefab; 
</pre>
<p>In the <kbd>Update</kbd>  function, after the <kbd>gameover</kbd> Boolean variable is set to instantiate the particle prefab as following:</p>
<pre>
    if (playerHealth&lt;= 0 || enemyHealth&lt;= 0) { <br/>        bGameover = true; <br/>        gameOverText.enabled = true; <br/><strong>        Instantiate(particlePrefab);</strong> <br/>        Debug.Log(" +++++ GAMEOVER +++++"); <br/>    } 
</pre>
<p>Don't forget to drag and drop the <span class="packt_screen">particleSystem</span> prefab on to <span class="packt_screen">Particle Prefab</span> in the <span class="packt_screen">gameScript</span> script component that is attached to the MainCamera:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="103" src="assets/image_05_035.png" width="219"/></div>
<p>Now, when you run the game and when it is gameover, you will have a nice confetti Particle System:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="311" src="assets/image_05_036.png" width="499"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we saw how to add in a GUI element to show the player's and enemy's health and also added the gameover text so that we know that it is the end of the game. We also added a very basic particle system just to demonstrate the ability to add particles. You can go in and change the particle system to see what more can be done.</p>
<p>The gameplay is over, and next, we can see how to add in scenes to the game, so we will create a main menu scene, which will show at the start of the game. We will also see how to add buttons so that at the click of the play button, the scene will swap to the gameplay scene.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>