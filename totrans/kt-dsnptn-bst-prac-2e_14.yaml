- en: '*Chapter 11*: Reactive Microservices with Vert.x'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用 Vert.x 的响应式微服务'
- en: In the previous chapter, we familiarized ourselves with the Ktor framework.
    We created a web service that could store cats in its database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们熟悉了 Ktor 框架。我们创建了一个可以存储猫的数据库的 Web 服务。
- en: 'In this chapter, we''ll continue working on the example from the previous chapter,
    but this time using the Vert.x framework and Kotlin. **Vert.x** is a Reactive
    framework that is built on top of Reactive principles, which we discussed in [*Chapter
    7*](B17816_07_ePub.xhtml#_idTextAnchor178), *Controlling the Data Flow*. We''ll
    list some of the other benefits of the Vert.x framework in this chapter. You can
    always read more about Vert.x by going to the official website: [https://vertx.io](https://vertx.io).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续使用上一章的例子，但这次使用 Vert.x 框架和 Kotlin。**Vert.x** 是一个基于响应式原则构建的响应式框架，我们在
    [*第7章*](B17816_07_ePub.xhtml#_idTextAnchor178) *控制数据流* 中讨论了这些原则。在本章中，我们还将列出 Vert.x
    框架的一些其他优点。您可以通过访问官方网站了解更多关于 Vert.x 的信息：[https://vertx.io](https://vertx.io)。
- en: The microservice we'll develop in this chapter will provide an endpoint for
    health checks – the same as the one we created in Ktor – and will be able to delete
    and update the cats in our database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将开发的微服务将提供一个健康检查的端点——与我们在 Ktor 中创建的相同——并且能够删除和更新我们数据库中的猫。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with Vert.x
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Vert.x
- en: Routing in Vert.x
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x 中的路由
- en: Verticles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Verticles
- en: Handling requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理请求
- en: Testing Vert.x applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Vert.x 应用程序
- en: Working with databases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: Understanding Event Loop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: Communicating with Event Bus
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过事件总线进行通信
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll need the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要以下内容：
- en: '**JDK 11** or later'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK 11** 或更高版本'
- en: IntelliJ IDEA
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: '**Gradle 6.8** or later'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gradle 6.8** 或更高版本'
- en: '**PostgreSQL 14** or later'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL 14** 或更高版本'
- en: Like the previous chapter, this chapter will also assume that you have PostgreSQL
    already installed and that you have basic knowledge of working with it. We'll
    also use the same table structure we created with Ktor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，本章也将假设您已经安装了 PostgreSQL，并且您对其有基本的了解。我们还将使用与 Ktor 创建的相同的表结构。
- en: 'You can find the full source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的完整源代码：[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11)。
- en: Getting started with Vert.x
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Vert.x
- en: '**Vert.x** is a Reactive framework that is asynchronous and non-blocking. Let''s
    understand what this means by looking at a concrete example.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vert.x** 是一个异步且非阻塞的响应式框架。让我们通过一个具体的例子来理解这意味着什么。'
- en: 'We''ll start by creating a new Kotlin Gradle project or by using [start.vertx.io](http://start.vertx.io):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的 Kotlin Gradle 项目，或者使用 [start.vertx.io](http://start.vertx.io)：
- en: From your IntelliJ IDEA application, select **File** | **New** | **Project**
    and choose **Kotlin** from the **New Project** wizard.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的 IntelliJ IDEA 应用程序中选择 **文件** | **新建** | **项目**，并在 **新建项目** 向导中选择 **Kotlin**。
- en: Then, specify a name for your project – `CatsShelterVertx`, in my case – and
    choose **Gradle Kotlin** as your **Build System**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为您的项目指定一个名称——例如，我的项目名为 `CatsShelterVertx`——并选择 **Gradle Kotlin** 作为您的 **构建系统**。
- en: 'Then, select the **Project JDK** version that you have installed from the dropdown.
    The output should look as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从下拉菜单中选择您已安装的 **项目 JDK** 版本。输出应如下所示：
- en: '![Figure 11.1 – Creating a Kotlin application'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 创建 Kotlin 应用程序'
- en: '](img/Figure_11.1_B17816.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B17816.jpg)'
- en: Figure 11.1 – Creating a Kotlin application
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 创建 Kotlin 应用程序
- en: 'Next, add the following dependencies to your `build.gradle.kts` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下依赖项添加到您的 `build.gradle.kts` 文件中：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similar to what we discussed in the previous chapter, all the dependencies must
    be of the same version to avoid any conflicts. That's the reason we are using
    a variable for the library version – to be able to change all of them together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章中讨论的类似，所有依赖项都必须是同一版本，以避免任何冲突。这就是我们为什么使用库版本变量——以便能够一起更改它们。
- en: 'The following is an explanation of each dependency:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每个依赖项的解释：
- en: '`vertx-core` is the core library.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-core` 是核心库。'
- en: '`vertx-web` is needed since we want our service to be REST-based.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-web` 是必需的，因为我们希望我们的服务是基于 REST 的。'
- en: '`vertx-lang-kotlin` provides idiomatic ways to write Kotlin code with Vert.x.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertx-lang-kotlin`提供了使用Vert.x编写Kotlin代码的惯用方法。'
- en: Finally, `vertx-lang-kotlin-coroutines` integrates with the coroutines, which
    we discussed in detail in [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164),
    *Threads and Coroutines*.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`vertx-lang-kotlin-coroutines`与协程集成，我们在[*第6章*](B17816_06_ePub.xhtml#_idTextAnchor164)，*线程和协程*中详细讨论了它。
- en: 'Then, we must create a file called `server.kt` in the `src/main/kotlin` folder
    with the following content:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在`src/main/kotlin`文件夹中创建一个名为`server.kt`的文件，并包含以下内容：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's all you need to start a web server that will respond with `OK` when you
    open `http://localhost:8081` in your browser.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要启动一个web服务器的所有内容，当你在浏览器中打开`http://localhost:8081`时，它会返回`OK`。
- en: Now, let's understand what happens here. First, we create a Vert.x instance
    using the Factory method from [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解这里发生了什么。首先，我们使用[*第3章*](B17816_03_ePub.xhtml#_idTextAnchor080)，*理解结构模式*中的工厂方法创建一个Vert.x实例。
- en: The `requestHandler` method is just a simple listener or a subscriber. If you
    don't remember how it works, check out [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, for the Observable design pattern.
    In our case, it will be called for each new request. That's the asynchronous nature
    of Vert.x in action.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestHandler`方法只是一个简单的监听器或订阅者。如果你不记得它是如何工作的，请查看[*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)，*熟悉行为模式*，了解Observable设计模式。在我们的情况下，它将为每个新的请求被调用。这就是Vert.x的异步特性在起作用。'
- en: Next, let's learn how to add routes in Vert.x.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何在Vert.x中添加路由。
- en: Routing in Vert.x
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vert.x中的路由
- en: Notice that no matter which URL we specify, we always get the same result. Of
    course, that's not what we want to achieve. Let's start by adding the most basic
    endpoint, which will only tell us that the service is up and running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论我们指定哪个URL，我们总是得到相同的结果。当然，这不是我们想要达到的效果。让我们先添加最基础的端点，它只会告诉我们服务正在运行。
- en: 'For that, we''ll use `Router`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用`Router`：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Router` lets you specify handlers for different HTTP methods and URLs.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`允许你为不同的HTTP方法和URL指定处理器。'
- en: 'Now, let''s add a `/status` endpoint that will return an HTTP status code of
    `200` and a message stating `OK` to our user:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`/status`端点，它将返回HTTP状态码`200`和一个消息，告知用户`OK`：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, instead of specifying the request handler as a block, we will pass this
    function to our `router` object. This makes our code easier to manage.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再将请求处理器指定为一个块，而是将这个函数传递给我们的`router`对象。这使得我们的代码更容易管理。
- en: 'We learned how we return a flat text response in the very first example. So,
    now, let''s return JSON instead. Most real-life applications use JSON for communication.
    Let''s replace the body of our status handler with the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一个示例中学习了如何返回纯文本响应。所以，现在，让我们返回JSON。大多数实际应用都使用JSON进行通信。让我们用以下代码替换状态处理器的主体：
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we are using a DSL, which we discussed in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, to create a JSON object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一种DSL，我们在[*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)，*熟悉行为模式*中讨论了它，来创建一个JSON对象。
- en: 'You can open `http://localhost:8081/status` in your browser and make sure that
    you get `{"status": "OK"}` as a response.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在浏览器中打开`http://localhost:8081/status`并确保你得到`{"status": "OK"}`作为响应。'
- en: Now, let's discuss how we can structure our code better with the Vert.x framework.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何使用Vert.x框架更好地组织我们的代码。
- en: Verticles
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Verticles
- en: Our current code resides in the `server.kt` file, which is getting bigger and
    bigger. We need to find a way to split it. In Vert.x, code is split into classes
    called **verticles**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的代码存储在`server.kt`文件中，这个文件正在变得越来越庞大。我们需要找到一种方法来将其拆分。在Vert.x中，代码被拆分成称为**verticles**的类。
- en: You can think of a verticle as a lightweight actor. We discussed Actors in [*Chapter
    5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional Programming*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将verticle视为一个轻量级的actor。我们在[*第5章*](B17816_05_ePub.xhtml#_idTextAnchor144)，*介绍函数式编程*中讨论了Actors。
- en: 'Let''s see how we can create a new verticle that will encapsulate our server:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何创建一个新的verticle，它将封装我们的服务器：
- en: '[PRE36]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Every verticle has a `start()` method that handles its initialization. As you
    can see, we moved all the code from our `main()` function to the `start()` method.
    If we run the code now, though, nothing will happen. That's because the verticle
    hasn't been started yet.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个垂直方向都有一个`start()`方法，用于处理其初始化。正如你所见，我们将所有代码从`main()`函数移动到了`start()`方法。然而，如果我们现在运行代码，什么也不会发生。这是因为垂直方向还没有被启动。
- en: 'There are different ways to start a verticle, but the simplest way is to pass
    the instance of the class to the `deployVerticle()` method. In our case, this
    is the `ServerVerticle` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个垂直方向有多种方法，但最简单的方法是将类的实例传递给`deployVerticle()`方法。在我们的例子中，这是`ServerVerticle`类：
- en: '[PRE51]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is another, more flexible way to specify the class name as a string:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种更灵活的方法来指定类名作为字符串：
- en: '[PRE55]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If our verticle class is not in the default package, we'll need to specify the
    fully qualified path for Vert.x to be able to initialize it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的垂直方向类不在默认包中，我们需要指定完全限定的路径，以便 Vert.x 能够初始化它。
- en: Now, our code has been split into two files, `ServerVerticle.kt` and `server.kt`,
    and is organized better. Next, we'll learn how we can do the same refactoring
    to organize our routes in a better way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码已经分为两个文件，`ServerVerticle.kt`和`server.kt`，并且组织得更好。接下来，我们将学习如何以相同的方式进行重构，以更好地组织我们的路由。
- en: Handling requests
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求
- en: As we discussed earlier in this chapter, all requests in Vert.x are handled
    by the `Router` class. We covered the concept of routing in the previous chapter,
    so now, let's just discuss the differences between the Ktor and Vert.x approaches
    to routing requests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面讨论的，Vert.x 中所有请求都由`Router`类处理。我们在上一章中介绍了路由的概念，现在，让我们仅讨论 Ktor 和 Vert.x
    在处理请求路由方面的不同方法。
- en: 'We''ll declare two endpoints to delete cats from the database and update information
    about a particular cat. We''ll use the `delete` and `put` verbs, respectively,
    for this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明两个端点，用于从数据库中删除猫和更新特定猫的信息。我们将分别使用`delete`和`put`动词：
- en: '[PRE59]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Both endpoints receive a URL parameter. In Vert.x, we use a colon notation for
    this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 两个端点都接收一个 URL 参数。在 Vert.x 中，我们使用冒号表示法来表示。
- en: 'To be able to parse JSON requests and responses, Vert.x has a `BodyHandler`
    class. Now, let''s declare it as well. This should come just after the instantiation
    of our router:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够解析 JSON 请求和响应，Vert.x 有一个`BodyHandler`类。现在，让我们也声明它。这应该在创建我们的路由对象之后进行：
- en: '[PRE65]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This will tell Vert.x to parse the request body into JSON for any request.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 Vert.x 解析任何请求的请求体为 JSON。
- en: Notice that the `/cat` prefix is repeated multiple times in our code now. To
    avoid that and make our code more modular, we can use a subrouter, which we'll
    discuss in the next section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们的代码中`/cat`前缀重复多次。为了避免这种情况并使我们的代码更加模块化，我们可以使用子路由，我们将在下一节中讨论。
- en: Subrouting the requests
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子路由请求
- en: '**Subrouting** allows us to split routes into multiple classes to keep our
    code more organized. Let''s move the new routes to a new function by following
    these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**子路由**允许我们将路由拆分成多个类，以使我们的代码更加有序。让我们按照以下步骤将新路由移动到新函数中：'
- en: 'We''ll leave the `/alive` endpoint as is, but we''ll extract all the other
    endpoints into a separate function:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保持`/alive`端点不变，但将所有其他端点提取到一个单独的函数中：
- en: '[PRE67]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Inside this function, we create a separate `Router` object that will only handle
    the routes for cats, not the status routes.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们创建了一个单独的`Router`对象，它将仅处理猫的路由，而不是状态路由。
- en: 'Now, we need to connect `SubRouter` to our main router:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将`SubRouter`连接到我们的主路由：
- en: '[PRE68]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Keeping our code clean and well separated is very important. Extracting routes
    into subrouters helps us with that.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持我们的代码干净和分离非常重要。将路由提取到子路由中帮助我们做到这一点。
- en: Now, let's discuss how this code can be tested.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何测试这段代码。
- en: Testing Vert.x applications
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Vert.x 应用程序
- en: To test our Vert.x application, we'll use the **JUnit 5** framework, which we
    discussed in the previous chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的 Vert.x 应用程序，我们将使用我们在上一章中讨论的**JUnit 5**框架。
- en: 'You''ll need the following two dependencies in your `build.gradle.kts` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的`build.gradle.kts`文件中添加以下两个依赖项：
- en: '[PRE69]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Our first test will be located in the `/src/test/kotlin/ServerTest.kt` file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测试将位于`/src/test/kotlin/ServerTest.kt`文件中。
- en: 'The basic structure of all the integration tests looks something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集成测试的基本结构看起来像这样：
- en: '[PRE76]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This structure is different from what we've seen in Ktor. Here, we start the
    server ourselves, in the `setup()` method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构与我们在 Ktor 中看到的不同。在这里，我们自己在`setup()`方法中启动服务器。
- en: Since Vert.x is Reactive, the `deployVerticle()` method will return a `Future`
    object immediately, releasing the thread, but that doesn't mean that the server
    verticle has started yet.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Vert.x 是响应式的，`deployVerticle()` 方法将立即返回一个 `Future` 对象，释放线程，但这并不意味着服务器 verticle
    已经启动。
- en: To avoid this race, we can use the `await()` method, which will block the execution
    of our tests until the server is ready to receive requests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种竞争，我们可以使用 `await()` 方法，这将阻塞我们的测试执行，直到服务器准备好接收请求。
- en: Now, we want to issue an actual HTTP call to our `/status` endpoint, for example,
    and check the response code. For that, we'll use the Vert.x web client.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要向我们的 `/status` 端点发出实际的 HTTP 请求，例如，并检查响应代码。为此，我们将使用 Vert.x 网络客户端。
- en: 'Let''s add it to our `build.gradle.kts` dependencies section:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它添加到我们的 `build.gradle.kts` 依赖项部分：
- en: '[PRE94]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Since we only plan to use `WebClient` in tests, we specify `testImplementation`
    instead of `implementation`. But `WebClient` is so useful that you'll probably
    end up using it in your production code anyway.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只计划在测试中使用 `WebClient`，所以我们指定 `testImplementation` 而不是 `implementation`。但
    `WebClient` 非常有用，你可能会最终在生产代码中也要使用它。
- en: 'After adding this new dependency, we need to instantiate our web client in
    the `setup` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个新的依赖项之后，我们需要在 `setup` 方法中实例化我们的网络客户端：
- en: '[PRE95]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `setup()` method will be called once before all the tests start. In this
    method, we are deploying our server verticle and creating a web client with some
    defaults for all our tests to share.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 方法将在所有测试开始之前被调用一次。在这个方法中，我们部署我们的服务器 verticle，并为所有测试创建一个带有一些默认值的网络客户端，以便所有测试可以共享。'
- en: 'Now, let''s write a test to check that our server is up and running:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个测试来检查我们的服务器是否正在运行：
- en: '[PRE106]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, let''s understand what happens in this test:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解这个测试中发生了什么：
- en: '`client` is an instance of `WebClient` that is shared by all our tests. We
    invoke the `/status` endpoint using the `get` verb. This is a Builder design pattern,
    so to issue our request, we need to use the `send()` method. Otherwise, nothing
    will happen.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client` 是一个 `WebClient` 的实例，它被所有我们的测试共享。我们使用 `get` 动词调用 `/status` 端点。这是一个
    Builder 设计模式，因此要发出我们的请求，我们需要使用 `send()` 方法。否则，什么都不会发生。'
- en: Vert.x is a Reactive framework, so instead of blocking our thread until a response
    is received, the `send()` method returns a Future. Then, we use `await()`, which
    adapts a Future to a Kotlin coroutine to be able to wait for the results concurrently.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Vert.x 是响应式框架，所以 `send()` 方法不会阻塞我们的线程直到收到响应，而是返回一个 Future。然后，我们使用 `await()`，它将
    Future 转换为 Kotlin 协程，以便能够并发地等待结果。
- en: Once the response is received, we check it in the same way that we did in other
    tests – by using the `assertEquals` function, which comes from JUnit.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦收到响应，我们就像在其他测试中做的那样进行检查——使用来自 JUnit 的 `assertEquals` 函数。
- en: Now that we know how to write tests in Vert.x, let's discuss how we can work
    with databases in a Reactive manner.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何在 Vert.x 中编写测试，那么让我们讨论如何以响应式的方式与数据库进行交互。
- en: Working with databases
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库交互
- en: To be able to progress further with our tests, we need the ability to create
    entities in the database. For that, we'll need to connect to the database.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够进一步进行我们的测试，我们需要在数据库中创建实体的能力。为此，我们需要连接到数据库。
- en: 'First, let''s add the following two lines to our `build.gradle.kts` dependencies
    section:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将以下两行添加到我们的 `build.gradle.kts` 依赖项部分：
- en: '[PRE113]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The first line of code fetches the PostgreSQL driver. The second one adds the
    Vert.x JDBC client, which allows Vert.x, which has the driver, to connect to any
    database that supports JDBC.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码获取 PostgreSQL 驱动程序。第二行添加了 Vert.x JDBC 客户端，这使得拥有驱动程序的 Vert.x 能够连接到任何支持 JDBC
    的数据库。
- en: Managing configuration
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理配置
- en: 'Now, we want to hold the database configuration somewhere. For local development,
    it may be fine to have those configurations hardcoded. We''ll execute the following
    steps to do this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望将数据库配置保存在某个地方。对于本地开发，可能将配置硬编码是可行的。我们将执行以下步骤来完成此操作：
- en: 'When we connect to the database, we need to specify the following parameters
    at the very least:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们连接到数据库时，我们至少需要指定以下参数：
- en: Username
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Password
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Host
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机
- en: Database name
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库名
- en: 'We''ll store the preceding parameters in a `Singleton` object:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将存储上述参数在一个 `Singleton` 对象中：
- en: '[PRE115]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Our `Singleton` object has four members. For each, we check whether an environment
    variable was set, and if there's no such environment variable, we provide a default
    value using the Elvis operator.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `Singleton` 对象有四个成员。对于每个成员，我们检查是否设置了环境变量，如果没有设置这样的环境变量，我们将使用 Elvis 运算符提供默认值。
- en: 'Now, let''s add a function that will return a connection pool:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个函数，该函数将返回一个连接池：
- en: '[PRE116]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Our `connect()` method creates two configuration objects: `PgConnectOptions`
    sets the configuration for the database we want to connect to, while `PoolOptions`
    specifies the configuration of the connection pool.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`connect()`方法创建了两个配置对象：`PgConnectOptions`设置了我们要连接的数据库的配置，而`PoolOptions`指定了连接池的配置。
- en: 'Now, all we need to do is instantiate the database client in our test:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要在我们的测试中实例化数据库客户端：
- en: '[PRE117]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Having done that, let''s create a new `Nested` class in our test file for cases
    where we expect to have a cat in our database:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做完这些之后，让我们在我们的测试文件中创建一个新的`Nested`类，用于处理我们预期数据库中会有猫的情况：
- en: '[PRE118]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Unlike the Exposed framework, which we discussed in the previous chapter, the
    database client in Vert.x doesn't have specific methods for insertion, deletion,
    and so on. Instead, it provides a lower-level API that allows us to execute any
    type of query on the database.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们在上一章中讨论的Exposed框架不同，Vert.x中的数据库客户端没有特定的插入、删除等方法。相反，它提供了一个更底层的API，允许我们在数据库上执行任何类型的查询。
- en: 'First, let''s write a query that will clean our database:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个查询来清理我们的数据库：
- en: '[PRE119]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The basic structure for working with the database client in Vert.x is to pass
    a query to the `prepareQuery()` method, then execute it using `execute()`.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Vert.x中与数据库客户端一起工作的基本结构是将查询传递给`prepareQuery()`方法，然后使用`execute()`方法执行它。
- en: We want to wait for the query to complete before we move on to the next test,
    so we use the `await()` function to wait for the current coroutine, and we use
    the `runBlocking()` adapter method to have a coroutine context to do so.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望在继续下一个测试之前等待查询完成，因此我们使用`await()`函数等待当前的协程，并使用`runBlocking()`适配器方法来创建一个协程上下文以实现这一点。
- en: 'Now, let''s write another query that will add a cat to the database before
    each test runs:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写另一个查询，在每次测试运行之前将猫添加到数据库中：
- en: '[PRE120]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Here, we are using the `preparedQuery()` method once more, but this time, our
    SQL query string contains placeholders. Each placeholder starts with a dollar
    sign and their indexes start with `1`.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用`preparedQuery()`方法，但这次我们的SQL查询字符串包含占位符。每个占位符都以美元符号开始，它们的索引从`1`开始。
- en: Then, we pass the values for those placeholders to the `execute()` method. `Tuple.of`
    is a Factory method design pattern that you should be able to recognize well by
    now.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将这些占位符的值传递给`execute()`方法。`Tuple.of`是一个你应该现在已经很熟悉的工厂方法设计模式。
- en: We also want to remember the ID of the cat that we create since we'll use that
    ID to delete or update the cat. For this reason, we store the created row in a
    `lateinit` variable.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还想要记住我们创建的猫的ID，因为我们将会使用这个ID来删除或更新猫。出于这个原因，我们将创建的行存储在一个`lateinit`变量中。
- en: 'We now have everything prepared to write our test:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为编写测试做好了准备：
- en: '[PRE121]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: First, we get the ID of the cat we want to delete from the database row using
    the `getInteger()` method. Unlike parameters that start with `1`, the columns
    of a database row start with `0`. So, by getting an integer at index `0`, we get
    the ID of our cat.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们使用`getInteger()`方法从数据库行中获取我们想要删除的猫的ID。与以`1`开始的参数不同，数据库行的列从`0`开始。因此，通过获取索引为`0`的整数，我们得到了我们猫的ID。
- en: Then, we invoke the web client's `delete()` method and wait for it to complete.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们调用网络客户端的`delete()`方法并等待其完成。
- en: Afterward, we execute a `SELECT` statement on our database, checking that the
    row was indeed deleted.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，我们在数据库上执行一个`SELECT`语句，检查该行确实已被删除。
- en: If you run this test now, it will fail, because we haven't implemented the `delete`
    endpoint yet. We'll do that in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这个测试，它将会失败，因为我们还没有实现`delete`端点。我们将在下一节中完成这个任务。
- en: Understanding Event Loop
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: The goal of the **Event Loop** design pattern is to continuously check for new
    events in a queue, and each time a new event comes in, to quickly dispatch it
    to someone who knows how to handle it. This way, a single thread or a very limited
    number of threads can handle a huge number of events.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件循环**设计模式的目的是在队列中持续检查新事件，并且每次有新事件到来时，都要快速将其派发给知道如何处理它的人。这样，单个线程或非常有限数量的线程就可以处理大量的事件。'
- en: In the case of web frameworks such as Vert.x, events may be requests to our
    server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vert.x等Web框架的情况下，事件可能是对服务器的请求。
- en: 'To understand the concept of the Event Loop better, let''s go back to our server
    code and attempt to implement an endpoint for deleting a cat:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解事件循环的概念，让我们回到我们的服务器代码，并尝试实现一个删除猫的端点：
- en: '[PRE122]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This code is very similar to what we've written in our tests in the previous
    section. We read the URL parameter from the request using the `getParam()` function,
    then we pass this ID to the prepared query. This time, though, we can't use the
    `runBlocking` adapter function, since it will block the Event Loop.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前章节测试中写的非常相似。我们使用 `getParam()` 函数从请求中读取 URL 参数，然后将此 ID 传递给预准备的查询。不过，这次我们不能使用
    `runBlocking` 适配器函数，因为它会阻塞事件循环。
- en: Vert.x uses a limited number of threads, as many as twice the number of your
    CPU cores, to run all its code efficiently. However, this means that we cannot
    execute any blocking operations on those threads since it will negatively impact
    the performance of our application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 使用有限数量的线程，大约是 CPU 核心数的两倍，以高效地运行所有代码。然而，这意味着我们无法在这些线程上执行任何阻塞操作，因为这会负面影响我们应用程序的性能。
- en: 'To solve this issue, we can use a coroutine builder we''re already familiar
    with: `launch()`. Let''s see how this works:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用我们已熟悉的协程构建器：`launch()`。让我们看看它是如何工作的：
- en: '[PRE128]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Since our verticle extends `CoroutineVerticle`, we have access to all the regular
    coroutine builders that will run on the Event Loop.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的垂直扩展了 `CoroutineVerticle`，我们可以访问所有将在事件循环上运行的常规协程构建器。
- en: 'Now, all we need to do is mark our routing functions with the `suspend` keyword:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将我们的路由函数标记为 `suspend` 关键字：
- en: '[PRE135]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now, let''s add another test for updating a cat:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加另一个测试来更新一只猫：
- en: '[PRE141]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This test is very similar to the deletion test, with the only major difference
    being that we use `sendBuffer` and not the `send()` method, so we can send a JSON
    body to our `put` endpoint.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与删除测试非常相似，唯一的重大区别是我们使用 `sendBuffer` 而不是 `send()` 方法，这样我们就可以向我们的 `put` 端点发送
    JSON body。
- en: We create the JSON similarly to what we saw when we implemented the `/status`
    endpoint earlier in this chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建 JSON 的方式与我们在本章前面实现 `/status` 端点时看到的方式类似。
- en: 'Now, let''s implement the `put` endpoint for the test to pass:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现 `put` 端点以通过测试：
- en: '[PRE158]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Here, the main difference from the previous endpoint we've implemented is that
    this time, we need to parse our request `body`. We can do that by using the `bodyAsJson`
    property. Then, we can use the `getString` and `getInteger` methods, which are
    available in JSON, to get the new values for `name` and `age`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与之前我们实现的端点的主要区别是，这次我们需要解析我们的请求 `body`。我们可以通过使用 `bodyAsJson` 属性来完成，然后我们可以使用
    JSON 中可用的 `getString` 和 `getInteger` 方法来获取 `name` 和 `age` 的新值。
- en: With this, you should have all the required knowledge to implement other endpoints
    as needed. Now, let's learn how to structure our code in a better way using the
    concept of Event Bus since it all resides in a single large class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你应该拥有所有所需的知识来实现其他端点。现在，让我们学习如何使用事件总线概念以更好的方式来结构化我们的代码，因为所有内容都位于一个单一的大类中。
- en: Communicating with Event Bus
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过事件总线进行通信
- en: '**Event Bus** is an implementation of the Observable design pattern, which
    we discussed in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件总线** 是观察者设计模式的实现，我们在 [*第 4 章*](B17816_04_ePub.xhtml#_idTextAnchor115)，*熟悉行为模式*
    中讨论过。'
- en: We've already mentioned that Vert.x is based on the concept of verticles, which
    are isolated actors. We've already seen the other types of actors in [*Chapter
    6*](B17816_06_ePub.xhtml#_idTextAnchor164), *Threads and Coroutines*. Kotlin's
    `coroutines` library provides the `actor()` and `producer()` coroutine generators,
    which create a coroutine bound to a channel.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，Vert.x 基于垂直的概念，这些是隔离的演员。我们已经在 [*第 6 章*](B17816_06_ePub.xhtml#_idTextAnchor164)，*线程和协程*
    中看到了其他类型的演员。Kotlin 的 `coroutines` 库提供了 `actor()` 和 `producer()` 协程生成器，它们创建一个与通道绑定的协程。
- en: Similarly, all the verticles in the Vert.x framework are bound by Event Bus
    and can pass messages to one another using it. Now, let's extract the code from
    our `ServerVerticle` class into a new class, which we'll call `CatVerticle`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Vert.x 框架中的所有垂直都由事件总线绑定，并且可以使用它相互传递消息。现在，让我们将 `ServerVerticle` 类中的代码提取到一个新的类中，我们将称之为
    `CatVerticle`。
- en: 'Any verticle can send a message over Event Bus by choosing between the following
    methods:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 任何垂直都可以通过选择以下方法之一通过事件总线发送消息：
- en: '`request()` will send a message to only one subscriber and wait for a response.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request()` 将向单个订阅者发送消息并等待响应。'
- en: '`send()` will send a message to only one subscriber, without waiting for a
    response.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()` 将向单个订阅者发送消息，而不等待响应。'
- en: '`publish()` will send a message to all subscribers, without waiting for a response.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish()`将向所有订阅者发送消息，而不等待响应。'
- en: No matter which method is used to send the message, you subscribe to it using
    the `consumer()` method on Event Bus.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种方法发送消息，你都可以使用Event Bus上的`consumer()`方法来订阅它。
- en: 'Now, let''s subscribe to an event in our `CatsVerticle` class:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`CatsVerticle`类中订阅一个事件：
- en: '[PRE173]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The generic type of the `consumer()` method specifies the type of message we'll
    receive. In this case, it's `Int`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`consumer()`方法的泛型类型指定了我们将接收的消息类型。在这种情况下，它是`Int`。'
- en: The string that we provide to the method – in our case, `cats:delete` – is the
    address we subscribe to. It can be any string, but it is good to have some convention,
    such as what type of object we operate on and what we want to do with it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给方法的字符串——在我们的例子中，`cats:delete`——是我们订阅的地址。它可以是一个任何字符串，但有一个约定会更好，比如我们操作的对象类型以及我们想要对其做什么。
- en: Once the delete action has been executed, we respond to our publisher with the
    `reply()` method. Since we don't have any information to send back, we simply
    send `null`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了删除操作，我们就使用`reply()`方法对我们的发布者做出响应。由于我们没有要发送的信息，我们简单地发送`null`。
- en: 'Now, let''s replace our previous `delete` route with the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码替换我们之前的`delete`路由：
- en: '[PRE186]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Here, we send the ID of the cat we received from the request to one of our listeners
    using the `request()` method, and we specify that the type of our message is `Int`.
    We also use the same address we specified in the consumer code.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`request()`方法将我们从请求中接收到的猫的ID发送给我们的一个监听器，并指定我们的消息类型是`Int`。我们还使用了与消费者代码中指定的相同地址。
- en: 'Since we have split our code into a new verticle, we need to remember to start
    it as well. Add the following line to both the `main()` function and the `setup()`
    method in your test:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将代码拆分成了一个新的verticle，我们需要记住也要启动它。在你的测试中，向`main()`函数和`setup()`方法中添加以下行：
- en: '[PRE192]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Next, let's learn how to send complex objects over Event Bus.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何通过Event Bus发送复杂对象。
- en: Sending JSON over Event Bus
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Event Bus发送JSON
- en: As our final exercise, let's learn how to update a cat. For that, we'll need
    to send more than just an ID over Event Bus.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的最终练习，让我们学习如何更新一只猫。为此，我们需要通过Event Bus发送比ID更多的信息。
- en: 'Let''s rewrite our `put` handler, as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写我们的`put`处理器，如下所示：
- en: '[PRE193]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Here, you can see that we can send JSON objects over Event Bus easily. We merge
    the ID we receive as a URL parameter with the rest of the request `body` and send
    this JSON over an Event Bus. When a response is received, we output it back to
    the user.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们可以轻松地通过Event Bus发送JSON对象。我们将接收到的ID与请求的其余`body`合并，并通过Event Bus发送这个JSON。当收到响应时，我们将它输出给用户。
- en: 'Now, let''s see how we consume the event we just sent:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何消费我们刚刚发送的事件：
- en: '[PRE204]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: We moved our logic from `Router` to our `CatsVerticle` class, but since we use
    JSON to communicate, the code stayed almost the same. In our verticle, we listen
    to the `cats:update` event, and once we receive the response, we extract `name`,
    `age`, and `id` from the JSON object to confirm that the operation was successful.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逻辑从`Router`移动到了我们的`CatsVerticle`类，但由于我们使用JSON进行通信，代码几乎保持不变。在我们的verticle中，我们监听`cats:update`事件，一旦我们收到响应，我们就从JSON对象中提取`name`、`age`和`id`以确认操作成功。
- en: This concludes our chapter. There is still much for you to learn about the Vert.x
    framework in case you're curious, but with the knowledge you've gained from this
    chapter at hand, you should be able to do so with some confidence.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章。如果你对Vert.x框架感兴趣，还有很多东西要学，但凭借你从本章中获得的知识，你应该能够有信心地这样做。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter concludes our journey into the design patterns in Kotlin. Vert.x
    uses actors, called verticles, to organize the logic of the application. Actors
    communicate between themselves using Event Bus, which is an implementation of
    the Observable design pattern.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了我们对Kotlin中设计模式的探索。Vert.x使用称为verticle的actor来组织应用程序的逻辑。actor通过Event Bus进行通信，Event
    Bus是Observable设计模式的一种实现。
- en: We also discussed the Event Loop pattern, how it allows Vert.x to process lots
    of events concurrently, and why it's important not to block its execution.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了Event Loop模式，它如何允许Vert.x并发处理大量事件，以及为什么不要阻塞其执行很重要。
- en: Now, you should be able to write microservices in Kotlin using two different
    frameworks, and you can choose what approach works best for you.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够使用两种不同的框架用Kotlin编写微服务，你可以选择最适合你的方法。
- en: Vert.x provides a lower-level API than Ktor, which means that we may think more
    about how we structure our code, but the resulting application may be more performant
    as well. Since this is the end of this book, all that's left is for me to wish
    you the best of luck in learning about Kotlin and its ecosystem. You can always
    get some help from me and other Kotlin enthusiasts by going to [https://stackoverflow.com/questions/tagged/kotlin](https://stackoverflow.com/questions/tagged/kotlin)
    and [https://discuss.kotlinlang.org/](https://discuss.kotlinlang.org/).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 提供的 API 比 Ktor 更底层，这意味着我们可能需要更多地考虑如何结构化我们的代码，但生成的应用程序也可能更高效。由于这是本书的结尾，我剩下的只是祝愿你在学习
    Kotlin 及其生态系统方面一切顺利。你总是可以通过访问 [https://stackoverflow.com/questions/tagged/kotlin](https://stackoverflow.com/questions/tagged/kotlin)
    和 [https://discuss.kotlinlang.org/](https://discuss.kotlinlang.org/) 来从我和其他 Kotlin
    爱好者那里获得一些帮助。
- en: '*Happy learning!*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*快乐学习！*'
- en: Questions
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's a verticle in Vert.x?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Vert.x 中，“verticle”是什么意思？
- en: What's the goal of the Event Bus?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件总线（Event Bus）的目标是什么？
- en: Why shouldn't we block the Event Loop?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不应该阻塞事件循环（Event Loop）？
