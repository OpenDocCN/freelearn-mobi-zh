- en: '*Chapter 11*: Reactive Microservices with Vert.x'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we familiarized ourselves with the Ktor framework.
    We created a web service that could store cats in its database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll continue working on the example from the previous chapter,
    but this time using the Vert.x framework and Kotlin. **Vert.x** is a Reactive
    framework that is built on top of Reactive principles, which we discussed in [*Chapter
    7*](B17816_07_ePub.xhtml#_idTextAnchor178), *Controlling the Data Flow*. We''ll
    list some of the other benefits of the Vert.x framework in this chapter. You can
    always read more about Vert.x by going to the official website: [https://vertx.io](https://vertx.io).'
  prefs: []
  type: TYPE_NORMAL
- en: The microservice we'll develop in this chapter will provide an endpoint for
    health checks – the same as the one we created in Ktor – and will be able to delete
    and update the cats in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Vert.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing in Vert.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verticles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Vert.x applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Event Loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with Event Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JDK 11** or later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gradle 6.8** or later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL 14** or later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the previous chapter, this chapter will also assume that you have PostgreSQL
    already installed and that you have basic knowledge of working with it. We'll
    also use the same table structure we created with Ktor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vert.x** is a Reactive framework that is asynchronous and non-blocking. Let''s
    understand what this means by looking at a concrete example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a new Kotlin Gradle project or by using [start.vertx.io](http://start.vertx.io):'
  prefs: []
  type: TYPE_NORMAL
- en: From your IntelliJ IDEA application, select **File** | **New** | **Project**
    and choose **Kotlin** from the **New Project** wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, specify a name for your project – `CatsShelterVertx`, in my case – and
    choose **Gradle Kotlin** as your **Build System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select the **Project JDK** version that you have installed from the dropdown.
    The output should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Creating a Kotlin application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B17816.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Creating a Kotlin application
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following dependencies to your `build.gradle.kts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Similar to what we discussed in the previous chapter, all the dependencies must
    be of the same version to avoid any conflicts. That's the reason we are using
    a variable for the library version – to be able to change all of them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an explanation of each dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vertx-core` is the core library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertx-web` is needed since we want our service to be REST-based.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertx-lang-kotlin` provides idiomatic ways to write Kotlin code with Vert.x.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `vertx-lang-kotlin-coroutines` integrates with the coroutines, which
    we discussed in detail in [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164),
    *Threads and Coroutines*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we must create a file called `server.kt` in the `src/main/kotlin` folder
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's all you need to start a web server that will respond with `OK` when you
    open `http://localhost:8081` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's understand what happens here. First, we create a Vert.x instance
    using the Factory method from [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: The `requestHandler` method is just a simple listener or a subscriber. If you
    don't remember how it works, check out [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, for the Observable design pattern.
    In our case, it will be called for each new request. That's the asynchronous nature
    of Vert.x in action.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's learn how to add routes in Vert.x.
  prefs: []
  type: TYPE_NORMAL
- en: Routing in Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that no matter which URL we specify, we always get the same result. Of
    course, that's not what we want to achieve. Let's start by adding the most basic
    endpoint, which will only tell us that the service is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we''ll use `Router`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Router` lets you specify handlers for different HTTP methods and URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a `/status` endpoint that will return an HTTP status code of
    `200` and a message stating `OK` to our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of specifying the request handler as a block, we will pass this
    function to our `router` object. This makes our code easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned how we return a flat text response in the very first example. So,
    now, let''s return JSON instead. Most real-life applications use JSON for communication.
    Let''s replace the body of our status handler with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a DSL, which we discussed in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, to create a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open `http://localhost:8081/status` in your browser and make sure that
    you get `{"status": "OK"}` as a response.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss how we can structure our code better with the Vert.x framework.
  prefs: []
  type: TYPE_NORMAL
- en: Verticles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current code resides in the `server.kt` file, which is getting bigger and
    bigger. We need to find a way to split it. In Vert.x, code is split into classes
    called **verticles**.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a verticle as a lightweight actor. We discussed Actors in [*Chapter
    5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create a new verticle that will encapsulate our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Every verticle has a `start()` method that handles its initialization. As you
    can see, we moved all the code from our `main()` function to the `start()` method.
    If we run the code now, though, nothing will happen. That's because the verticle
    hasn't been started yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to start a verticle, but the simplest way is to pass
    the instance of the class to the `deployVerticle()` method. In our case, this
    is the `ServerVerticle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another, more flexible way to specify the class name as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If our verticle class is not in the default package, we'll need to specify the
    fully qualified path for Vert.x to be able to initialize it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our code has been split into two files, `ServerVerticle.kt` and `server.kt`,
    and is organized better. Next, we'll learn how we can do the same refactoring
    to organize our routes in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier in this chapter, all requests in Vert.x are handled
    by the `Router` class. We covered the concept of routing in the previous chapter,
    so now, let's just discuss the differences between the Ktor and Vert.x approaches
    to routing requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll declare two endpoints to delete cats from the database and update information
    about a particular cat. We''ll use the `delete` and `put` verbs, respectively,
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Both endpoints receive a URL parameter. In Vert.x, we use a colon notation for
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to parse JSON requests and responses, Vert.x has a `BodyHandler`
    class. Now, let''s declare it as well. This should come just after the instantiation
    of our router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This will tell Vert.x to parse the request body into JSON for any request.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `/cat` prefix is repeated multiple times in our code now. To
    avoid that and make our code more modular, we can use a subrouter, which we'll
    discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Subrouting the requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Subrouting** allows us to split routes into multiple classes to keep our
    code more organized. Let''s move the new routes to a new function by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll leave the `/alive` endpoint as is, but we''ll extract all the other
    endpoints into a separate function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside this function, we create a separate `Router` object that will only handle
    the routes for cats, not the status routes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to connect `SubRouter` to our main router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keeping our code clean and well separated is very important. Extracting routes
    into subrouters helps us with that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's discuss how this code can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Vert.x applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test our Vert.x application, we'll use the **JUnit 5** framework, which we
    discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need the following two dependencies in your `build.gradle.kts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Our first test will be located in the `/src/test/kotlin/ServerTest.kt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of all the integration tests looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This structure is different from what we've seen in Ktor. Here, we start the
    server ourselves, in the `setup()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Since Vert.x is Reactive, the `deployVerticle()` method will return a `Future`
    object immediately, releasing the thread, but that doesn't mean that the server
    verticle has started yet.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this race, we can use the `await()` method, which will block the execution
    of our tests until the server is ready to receive requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to issue an actual HTTP call to our `/status` endpoint, for example,
    and check the response code. For that, we'll use the Vert.x web client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add it to our `build.gradle.kts` dependencies section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Since we only plan to use `WebClient` in tests, we specify `testImplementation`
    instead of `implementation`. But `WebClient` is so useful that you'll probably
    end up using it in your production code anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding this new dependency, we need to instantiate our web client in
    the `setup` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The `setup()` method will be called once before all the tests start. In this
    method, we are deploying our server verticle and creating a web client with some
    defaults for all our tests to share.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a test to check that our server is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s understand what happens in this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '`client` is an instance of `WebClient` that is shared by all our tests. We
    invoke the `/status` endpoint using the `get` verb. This is a Builder design pattern,
    so to issue our request, we need to use the `send()` method. Otherwise, nothing
    will happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vert.x is a Reactive framework, so instead of blocking our thread until a response
    is received, the `send()` method returns a Future. Then, we use `await()`, which
    adapts a Future to a Kotlin coroutine to be able to wait for the results concurrently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the response is received, we check it in the same way that we did in other
    tests – by using the `assertEquals` function, which comes from JUnit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to write tests in Vert.x, let's discuss how we can work
    with databases in a Reactive manner.
  prefs: []
  type: TYPE_NORMAL
- en: Working with databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to progress further with our tests, we need the ability to create
    entities in the database. For that, we'll need to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the following two lines to our `build.gradle.kts` dependencies
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code fetches the PostgreSQL driver. The second one adds the
    Vert.x JDBC client, which allows Vert.x, which has the driver, to connect to any
    database that supports JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: Managing configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we want to hold the database configuration somewhere. For local development,
    it may be fine to have those configurations hardcoded. We''ll execute the following
    steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we connect to the database, we need to specify the following parameters
    at the very least:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Username
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Password
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Host
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Database name
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll store the preceding parameters in a `Singleton` object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `Singleton` object has four members. For each, we check whether an environment
    variable was set, and if there's no such environment variable, we provide a default
    value using the Elvis operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s add a function that will return a connection pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `connect()` method creates two configuration objects: `PgConnectOptions`
    sets the configuration for the database we want to connect to, while `PoolOptions`
    specifies the configuration of the connection pool.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, all we need to do is instantiate the database client in our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having done that, let''s create a new `Nested` class in our test file for cases
    where we expect to have a cat in our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unlike the Exposed framework, which we discussed in the previous chapter, the
    database client in Vert.x doesn't have specific methods for insertion, deletion,
    and so on. Instead, it provides a lower-level API that allows us to execute any
    type of query on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, let''s write a query that will clean our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The basic structure for working with the database client in Vert.x is to pass
    a query to the `prepareQuery()` method, then execute it using `execute()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We want to wait for the query to complete before we move on to the next test,
    so we use the `await()` function to wait for the current coroutine, and we use
    the `runBlocking()` adapter method to have a coroutine context to do so.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s write another query that will add a cat to the database before
    each test runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using the `preparedQuery()` method once more, but this time, our
    SQL query string contains placeholders. Each placeholder starts with a dollar
    sign and their indexes start with `1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we pass the values for those placeholders to the `execute()` method. `Tuple.of`
    is a Factory method design pattern that you should be able to recognize well by
    now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also want to remember the ID of the cat that we create since we'll use that
    ID to delete or update the cat. For this reason, we store the created row in a
    `lateinit` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now have everything prepared to write our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we get the ID of the cat we want to delete from the database row using
    the `getInteger()` method. Unlike parameters that start with `1`, the columns
    of a database row start with `0`. So, by getting an integer at index `0`, we get
    the ID of our cat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we invoke the web client's `delete()` method and wait for it to complete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Afterward, we execute a `SELECT` statement on our database, checking that the
    row was indeed deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you run this test now, it will fail, because we haven't implemented the `delete`
    endpoint yet. We'll do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Event Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the **Event Loop** design pattern is to continuously check for new
    events in a queue, and each time a new event comes in, to quickly dispatch it
    to someone who knows how to handle it. This way, a single thread or a very limited
    number of threads can handle a huge number of events.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of web frameworks such as Vert.x, events may be requests to our
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the concept of the Event Loop better, let''s go back to our server
    code and attempt to implement an endpoint for deleting a cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: This code is very similar to what we've written in our tests in the previous
    section. We read the URL parameter from the request using the `getParam()` function,
    then we pass this ID to the prepared query. This time, though, we can't use the
    `runBlocking` adapter function, since it will block the Event Loop.
  prefs: []
  type: TYPE_NORMAL
- en: Vert.x uses a limited number of threads, as many as twice the number of your
    CPU cores, to run all its code efficiently. However, this means that we cannot
    execute any blocking operations on those threads since it will negatively impact
    the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this issue, we can use a coroutine builder we''re already familiar
    with: `launch()`. Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Since our verticle extends `CoroutineVerticle`, we have access to all the regular
    coroutine builders that will run on the Event Loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is mark our routing functions with the `suspend` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add another test for updating a cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: This test is very similar to the deletion test, with the only major difference
    being that we use `sendBuffer` and not the `send()` method, so we can send a JSON
    body to our `put` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We create the JSON similarly to what we saw when we implemented the `/status`
    endpoint earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `put` endpoint for the test to pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Here, the main difference from the previous endpoint we've implemented is that
    this time, we need to parse our request `body`. We can do that by using the `bodyAsJson`
    property. Then, we can use the `getString` and `getInteger` methods, which are
    available in JSON, to get the new values for `name` and `age`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you should have all the required knowledge to implement other endpoints
    as needed. Now, let's learn how to structure our code in a better way using the
    concept of Event Bus since it all resides in a single large class.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with Event Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Event Bus** is an implementation of the Observable design pattern, which
    we discussed in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*.'
  prefs: []
  type: TYPE_NORMAL
- en: We've already mentioned that Vert.x is based on the concept of verticles, which
    are isolated actors. We've already seen the other types of actors in [*Chapter
    6*](B17816_06_ePub.xhtml#_idTextAnchor164), *Threads and Coroutines*. Kotlin's
    `coroutines` library provides the `actor()` and `producer()` coroutine generators,
    which create a coroutine bound to a channel.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, all the verticles in the Vert.x framework are bound by Event Bus
    and can pass messages to one another using it. Now, let's extract the code from
    our `ServerVerticle` class into a new class, which we'll call `CatVerticle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any verticle can send a message over Event Bus by choosing between the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request()` will send a message to only one subscriber and wait for a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send()` will send a message to only one subscriber, without waiting for a
    response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publish()` will send a message to all subscribers, without waiting for a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter which method is used to send the message, you subscribe to it using
    the `consumer()` method on Event Bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s subscribe to an event in our `CatsVerticle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The generic type of the `consumer()` method specifies the type of message we'll
    receive. In this case, it's `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: The string that we provide to the method – in our case, `cats:delete` – is the
    address we subscribe to. It can be any string, but it is good to have some convention,
    such as what type of object we operate on and what we want to do with it.
  prefs: []
  type: TYPE_NORMAL
- en: Once the delete action has been executed, we respond to our publisher with the
    `reply()` method. Since we don't have any information to send back, we simply
    send `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s replace our previous `delete` route with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Here, we send the ID of the cat we received from the request to one of our listeners
    using the `request()` method, and we specify that the type of our message is `Int`.
    We also use the same address we specified in the consumer code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have split our code into a new verticle, we need to remember to start
    it as well. Add the following line to both the `main()` function and the `setup()`
    method in your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's learn how to send complex objects over Event Bus.
  prefs: []
  type: TYPE_NORMAL
- en: Sending JSON over Event Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our final exercise, let's learn how to update a cat. For that, we'll need
    to send more than just an ID over Event Bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `put` handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we can send JSON objects over Event Bus easily. We merge
    the ID we receive as a URL parameter with the rest of the request `body` and send
    this JSON over an Event Bus. When a response is received, we output it back to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we consume the event we just sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: We moved our logic from `Router` to our `CatsVerticle` class, but since we use
    JSON to communicate, the code stayed almost the same. In our verticle, we listen
    to the `cats:update` event, and once we receive the response, we extract `name`,
    `age`, and `id` from the JSON object to confirm that the operation was successful.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our chapter. There is still much for you to learn about the Vert.x
    framework in case you're curious, but with the knowledge you've gained from this
    chapter at hand, you should be able to do so with some confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concludes our journey into the design patterns in Kotlin. Vert.x
    uses actors, called verticles, to organize the logic of the application. Actors
    communicate between themselves using Event Bus, which is an implementation of
    the Observable design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the Event Loop pattern, how it allows Vert.x to process lots
    of events concurrently, and why it's important not to block its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to write microservices in Kotlin using two different
    frameworks, and you can choose what approach works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Vert.x provides a lower-level API than Ktor, which means that we may think more
    about how we structure our code, but the resulting application may be more performant
    as well. Since this is the end of this book, all that's left is for me to wish
    you the best of luck in learning about Kotlin and its ecosystem. You can always
    get some help from me and other Kotlin enthusiasts by going to [https://stackoverflow.com/questions/tagged/kotlin](https://stackoverflow.com/questions/tagged/kotlin)
    and [https://discuss.kotlinlang.org/](https://discuss.kotlinlang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '*Happy learning!*'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's a verticle in Vert.x?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the goal of the Event Bus?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why shouldn't we block the Event Loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
