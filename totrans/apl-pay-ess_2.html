<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Payment Request Workflow</h1></div></div></div><p>When your customer decides to purchase an item that is offered in your app, it is your responsibility to give the user a smooth, fast, and pain-free payment experience. Thankfully, Apple has taken the brunt of this effort by implementing Apple Pay. Users do not have to dig up<a id="id49" class="indexterm"/> their credit cards and enter shipping addresses to complete an order, even if it is the first time that they use your app. By asking only for the information that is strictly necessary to perform a transaction, you provide your customers with a compelling purchasing experience, which will encourage subsequent purchases from your app.</p><p>This chapter describes the things that your app needs to do to give its users a pleasant shopping experience, one in which the barrier between desiring something and having this product shipped to your doorstep is reduced to the gentle touch of a smooth, round button. At the same time, you reduce or eliminate the need to ask for and store your customers' payment information, which is a sensible approach in light of the notable increase in breaches of computer systems to obtain information on active payment cards. You will probably also welcome the marked increase in purchases from the same customers who, in addition to having a better purchasing experience than the ones offered by other apps, have confidence that their payment information will not be compromised (because their card information is not stored in their phones). Having a seamless payment experience will place your app high in its users' list of <em>loved</em> and <em>highly liked</em> apps, and apps that they would readily recommend to their family and friends.</p><p>This chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Providing an overview of a simple inventory web service that provides inventory information to its clients</li><li class="listitem" style="list-style-type: disc">Describing the implementation of a product card that displays essential product information and either an <strong>Apple</strong> <strong>Pay</strong> button or a regular <strong>Buy</strong> button depending on the availability of Apple Pay on the user's device</li><li class="listitem" style="list-style-type: disc">Walking through the process of creating a payment request and displaying a payment sheet with order information for the user to authorize payment (when Apple Pay is available)</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Getting information from an inventory service</h1></div></div></div><p>If users of your app can <a id="id50" class="indexterm"/>purchase tangible goods through it, then the app must get information about the availability of such products. One way to accomplish this is through a <a id="id51" class="indexterm"/>
<em>web service</em>. A web service is an app (web app or web process) that runs on a web server and to which clients (desktop or mobile apps) can connect to access resources such as an inventory, product images, orders, and payments. The most web-centric<a id="id52" class="indexterm"/> way to access such resources is through the use of <em>RESTful API</em>. <strong>Representational State Transfer</strong> (<strong>REST</strong>) provides a way for a computer to communicate with other computers, akin to the way people browse the web.</p><p>When you visit a web page, the page will likely offer options (links) that you can use to access content that is related to this page or the workflow (transaction) in which you are engaged. You then analyze each link to decide which related page to go to next. The RESTful API provides clients with an organic way to interact with resources that are hosted by web servers. Instead of having to follow a rigid API that is dictated by the web service, clients can ask for specific representations of a resource (a browser may ask for its XHTML version, while an iOS app may ask for JavaScript Object Notation or JSON). Embedded in the resource are links to related resources or to operations that modify the state of the resource. For example, after creating an order, the web server may provide links to operations that return the state of this order, modify it, or cancel it. This type of interaction is known as <em>hypermedia</em>. Hypermedia refers to the way distributed systems operate, accessing resources by their unique identifiers through a small set of HTTP verbs, such as <code class="literal">POST</code>, <code class="literal">PUT</code>, <code class="literal">GET</code>, and <code class="literal">DELETE</code>. This simple communication style provides great flexibility to distributed systems in establishing specialized-communication protocols.</p><p>The example solution (iOS app and web service) described in this book (and available for download) makes use of RESTful API to provide access to inventory, orders, and payments. By basing the app's interaction with its web service on a simple RESTful API, we can focus our attention on the main aspects of incorporating Apple Pay in your app and processing payments on your web server.</p><p>Before your app can present product information to your customers, it must get this information from your web servers. Shipping information is also important because the shipping methods that you offer may change from time to time, and the app should also get this information regularly. The app would present the shipping methods that are available on the payment sheet to let the user accept the default shipping method or change it. The following sections describe how the example solution gets inventory and shipping information from a web server to the user's device.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Getting inventory information</h2></div></div></div><p>The example<a id="id53" class="indexterm"/> app is very simple. On launch, it requests<a id="id54" class="indexterm"/> two things from the web server: the inventory, and the shipping methods that are available. Then, it displays the inventory in a list, as in the following screenshot:</p><div><img src="img/B05093_02_01.png.jpg" alt="Getting inventory information"/></div><p>To get the inventory information, the app requests a representation of the resource from the server using a REST API. The resource is found by accessing the <code class="literal">http://red:12345/inventory</code>
<a id="id55" class="indexterm"/> <strong>Uniform Resource Identifier</strong> (<strong>URI</strong>). After receiving the data, the app uses the <code class="literal">NSJSONSerialization</code> class to convert the data that is received (encoded in JSON) into an <code class="literal">NSDictionary</code> instance, which is the data source for the table (a <code class="literal">UITableView</code> instance) whose rows display the name of each product in inventory.</p><p>This listing shows the<a id="id56" class="indexterm"/> model that is used by the web<a id="id57" class="indexterm"/> service (implemented in Node.js), the Objective-C class that defines the corresponding iOS model, and the code that converts the JSON into the products dictionary:</p><div><pre class="programlisting">// Web service JavaScript
var Product_schema= new Schema({
   name:             String,
   description:      String,
   image_uri:        String,
   quantity_on_hand: Number,
   price:            String
});

// Product.h
@interface Product : NSObject
@property NSString*  name;
@property NSString*  description;
@property NSString*  image_uri;
@property NSUInteger quantity_on_hand;
@property NSString*  price;
@end

// ProductList.m
@interface ProductList ()
@property (nonatomic) NSArray* products;          // array of Product*
@end
@implementation ProductList
- (void) viewDidLoad 
{
   [super viewDidLoad];
   self.title= @"Products";
   
   RestIO* rest_io= [RestIO sharedRestIO];
   [rest_io getResourceAtURI:@"http://red:12345/inventory"
                  completion:^(NSURLResponse* response, NSData* data) {
      if ([response.MIMEType isEqualToString:@"application/json"])
      {
         NSError* error;
         NSDictionary* json_data= [NSJSONSerialization JSONObjectWithData:data
                                                                  options:0
                                                                    error:&amp;error];
         NSMutableArray* products= [NSMutableArray new];
         for (NSDictionary* json_product in json_data)
         {            
            Product* product=    [Product new];
            product.name=        json_product[@"name"];
            product.description= json_product[@"description"];
            product.image_uri=   json_product[@"image_uri"];
            product.price=       json_product[@"price"];
            {
               NSInteger quantity= [(NSString*)json_product[@"quantity_on_hand"]
                                            integerValue];
               product.quantity_on_hand= quantity &gt; 0? quantity : 0;
            }
            [products addObject:(NSString*)product];
         }
         _products= products.copy;
         dispatch_async(dispatch_get_main_queue(), ^{
            [(UITableView*)self.view reloadData];
         });
      }
   }];
}
...
@end</pre></div><p>An important<a id="id58" class="indexterm"/> thing to note is that a product's price is stored as a string, not a number. This is because performing financial computations with<a id="id59" class="indexterm"/> numeric types does not produce accurate results. When performing financial computations, especially those having to do with Apple Pay transactions, you must use instances of the <code class="literal">NSDecimalNumber</code> class, which facilitate the accurate computation of arithmetic operations on base-10 numbers. The <code class="literal">NSDecimalNumber</code> class also has methods that convert numeric strings to decimal numbers.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Getting shipping information</h2></div></div></div><p>To provide available <a id="id60" class="indexterm"/>shipping methods to customers on the payment sheet, the app needs to get the list from the server. In the sample code, the app's <code class="literal">AppDelegate</code> object gets this list in its <code class="literal">application:didFinishLaunchingWithOptions:</code> method.</p><p>This listing shows the<a id="id61" class="indexterm"/> Node.js and Objective-C model classes of instances of the <code class="literal">ShippingService</code> class, and the<a id="id62" class="indexterm"/> code that gets the shipping services from the server:</p><div><pre class="programlisting">// Web service JavaScript
var ShippingService_schema= new Schema({
   name:         String,
   description:  String,
   transit_days: Number,
   price:        String
});

// ShippingMethod.h
@interface ShippingService : NSObject
@property NSString*  name;
@property NSString*  detail;
@property NSNumber*  transit_days;
@property NSString*  price;
@end

// AppDelegate.m
#import "AppDelegate.h"
#import "Stripe.h"
#import "RestIO.h"
#import "ShippingMethod.h"

@interface AppDelegate ()
@property (readwrite) NSArray&lt;ShippingMethod*&gt;* shipping_methods;
@end

@implementation AppDelegate
- (BOOL)           application:(UIApplication*) app
 didFinishLaunchingWithOptions:(NSDictionary*)  options
{
   _ApplePay_merchant_identifier= ApplePay_merchant_identifier;
   _ApplePay_supported_networks=  @[PKPaymentNetworkVisa, PKPaymentNetworkAmex, PKPaymentNetworkDiscover, PKPaymentNetworkPrivateLabel];
   
   [Stripe setDefaultPublishableKey:StripePublishableKey];
   
   _rest_io_host= @"http://red:12345";
   
   // get shipping methods from server
   {
      NSString* shipping_methods_uri= [NSString stringWithFormat:@"%@%@",_rest_io_host, @"/shipping_methods"];
      
      RestIO* rest_io= [RestIO sharedRestIO];
      [rest_io getResourceAtURI:shipping_methods_uri completion:^(NSURLResponse* response, NSData* data) {
         if ([response.MIMEType isEqualToString:@"application/json"])
         {
            NSError* error;
            NSDictionary*   json_data=        [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error];
            NSMutableArray* shipping_methods= [NSMutableArray array];
            for (NSDictionary* json_shipping_method in json_data)
            {
               ShippingMethod* shipping_method=    [ShippingMethod new];
               {
                  shipping_method.name=         json_shipping_method[@"name"];
                  shipping_method.detail=       json_shipping_method[@"description"];
                  shipping_method.transit_days= [NSNumber numberWithShort:[(NSString*)json_shipping_method[@"transit_days"]
                                                                           integerValue]];
                  shipping_method.price=        json_shipping_method[@"price"];
               }
               
               [shipping_methods addObject:(NSString*)shipping_method];
            }
            _shipping_methods= shipping_methods.copy;
         }
      }];
   }
   return YES;
}
...
@end</pre></div><p>Similar to the <code class="literal">Product</code> class that was introduced earlier, the <code class="literal">ShippingMethod</code> class uses a string to store<a id="id63" class="indexterm"/> the price of each shipping method. This is because shipping-method prices are added to the price of other items in the payment request, and all these additions must be done using decimal numbers (the <code class="literal">NSDecimalNumber</code> instances).</p><p>Now that the app has<a id="id64" class="indexterm"/> the inventory of available <a id="id65" class="indexterm"/>products and the shipping methods available to its users, it can show a <em>product information card</em> when the user selects a product from the product list and a payment sheet when the user taps the <strong>Apple</strong> <strong>Pay</strong> button.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Displaying the product card</h1></div></div></div><p>The Apple Pay user experience starts with the appearance of the <strong>Apple</strong> <strong>Pay</strong> button. When your customer sees this button, they know that the product pictured on their device's screen can be at their doorstep<a id="id66" class="indexterm"/> with as few as two taps. There really is no <em>step 3</em>.</p><p>The <em>product card</em> is a screen that displays product information, such as the product's name, description, and price, and the <strong>Apple</strong> <strong>Pay</strong> button when Apple Pay is available on the user's device. When Apple Pay is not available (either because the customer's device does not support it or because the customer has not set up Apple Pay on that device), your app should not display the <strong>Apple</strong> <strong>Pay</strong> button. Instead, it should display either an <strong>Add to Cart</strong> button or a regular <strong>Buy</strong> button, and process the payment using traditional means.</p><p>The following sections describe how to design a product-card screen and how to lay out an <strong>Apple</strong> <strong>Pay</strong> button at runtime when Apple Pay is available.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Presenting product information</h2></div></div></div><p>The product-card <a id="id67" class="indexterm"/>definition starts in the app's main<a id="id68" class="indexterm"/> storyboard file, as in the following screenshot:</p><div><img src="img/B05093_02_02.png.jpg" alt="Presenting product information"/></div><p>The product scene lays out the elements that make up the product card. This is mainly an image view that <a id="id69" class="indexterm"/>displays the product's image and three labels that display the product description, the <strong>Price</strong>: legend, and the product<a id="id70" class="indexterm"/> price using a currency formatter.</p><p>This listing shows the <code class="literal">viewDidLoad</code> method of the <code class="literal">ProductCard</code> object:</p><div><pre class="programlisting">// ProductCard.m
- (void) viewDidLoad 
{
   [super viewDidLoad];
   
   _currency_formatter=             [NSNumberFormatter new];
   _currency_formatter.numberStyle= NSNumberFormatterCurrencyStyle;
   
   // get last-used shipping method
   _shipping_method_name= [[NSUserDefaults standardUserDefaults] objectForKey:Default_shipping_method_name];

   // define table sections
   {
      short   i= 0;
      sections[  i].cell_row_height=   44; sections[i].cell_type= ProductDescription;
      sections[++i].cell_row_height=  400; sections[i].cell_type= ProductImage;
      sections[++i].cell_row_height=   44; sections[i].cell_type= ProductBuy;
      _section_count= ++i;
   }
   
   // download product image
   RestIO* rest_io= [RestIO sharedRestIO];
   [rest_io downloadResourceWithURI: _product.image_uri 
                         completion: ^
       (NSURL* destination_url)
       {
          dispatch_async(dispatch_get_main_queue(), ^
             {
                UIImage *image= [UIImage imageWithContentsOfFile:[destination_url path]];
                [((ProductCard_TableView*)self.view) setProductImage:image];
             }
          );
       }
    ];
   
   // get shipping methods
   {
      AppDelegate*    app_delegate=     [UIApplication sharedApplication].delegate;
      NSMutableArray&lt;PKShippingMethod*&gt;* pk_shipping_methods= [NSMutableArray new];
      for (ShippingMethod* shipping_method in app_delegate.shipping_methods)
      {
         PKShippingMethod* pk_shipping_method=
         [PKShippingMethod 
          summaryItemWithLabel:[@"Shipping " stringByAppendingString:shipping_method.name]
          amount:[NSDecimalNumber decimalNumberWithString:shipping_method.price]];
         pk_shipping_method.identifier= shipping_method.name;
         pk_shipping_method.detail=     shipping_method.detail;
         [pk_shipping_methods addObject:pk_shipping_method];
      }
      _pk_shipping_methods= pk_shipping_methods.copy;
   }
}</pre></div><p>The <code class="literal">viewDidLoad</code> method<a id="id71" class="indexterm"/> instantiates the currency formatter that is used by the <em>buy</em> table cell, which displays the product's price and the <strong>Apple</strong> <strong>Pay</strong> button. However, the <strong>Apple</strong> <strong>Pay</strong> button is not laid out at design time; it is laid out at run time when the product table displays the buy cell. This setup is explained in the next section.</p><p>The <code class="literal">viewDidLoad</code> <a id="id72" class="indexterm"/>method also gets the product's image by getting the resources identified by the product's <code class="literal">image_uri</code> property. This method uses the REST API to download the image data from the server. When the image is downloaded, the method creates a <code class="literal">UIImage</code> object, which it assigns to the <code class="literal">view</code> property of the product table.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Presenting the Apple Pay button</h2></div></div></div><p>As stated earlier, it is very important that your app does not display the <strong>Apple</strong> <strong>Pay</strong> button if the user is unable to<a id="id73" class="indexterm"/> use Apple Pay on their device. Your app determines whether Apple Pay is available using two methods of the <code class="literal">PKPaymentAuthorizationViewController</code> class: <code class="literal">canMakePayments</code>, and <code class="literal">canMakePaymentsUsingNetworks</code>:.</p><p>This listing shows how an <a id="id74" class="indexterm"/>example iOS app uses these methods to determine which purchase button to add to the buy cell: the <strong>Apple</strong> <strong>Pay</strong> button, an instance of the <code class="literal">PKPaymentButton</code> class, or a <strong>Buy</strong> button implemented as a <code class="literal">UIButton</code> instance:</p><div><pre class="programlisting">// ProductCard.m
(ProductCard_BuyCell*) buy_cell
{
   ProductCard_BuyCell* cell= 
      (ProductCard_BuyCell*)[(ProductCard_TableView*)self.view dequeueReusableCellWithIdentifier:@"buy"];
   
   NSNumber* price_number= [NSNumber numberWithDouble:[_product.price doubleValue]];      
   cell.price_label.text=  [_currency_formatter stringFromNumber:price_number];

   // determine whether ApplePay is available on this device and is configured with the accepted payment networks
   BOOL can_use_ApplePay;
   {
      AppDelegate* app_delegate= [UIApplication sharedApplication].delegate;
      if ((can_use_ApplePay= [PKPaymentAuthorizationViewController canMakePayments]))
         can_use_ApplePay= [PKPaymentAuthorizationViewController
                               canMakePaymentsUsingNetworks:app_delegate.ApplePay_supported_networks];
   }

   // instantiate the purchase button
   UIButton* purchase_button;
   if (can_use_ApplePay)
   // configure a PKPaymentButton (Apple Pay button)
   {
      // create payment button
      purchase_button= [PKPaymentButton buttonWithType:PKPaymentButtonTypePlain 
                                                 style:PKPaymentButtonStyleWhiteOutline];
      purchase_button.tag= ApplePay_button_tag;
   }
   else
   // configure a UIButton
   {
      purchase_button= [UIButton buttonWithType:UIButtonTypeSystem];
      [purchase_button setTitle:@"Buy" forState:UIControlStateNormal];
      purchase_button.tag= Buy_button_tag;
   }
   
   // define the layout of the purchase button
   ...

   return cell;
}</pre></div><p>The result of this process is a product card that displays the <strong>Apple</strong> <strong>Pay</strong> button (if Apple Pay is available on the device), allowing the user to quickly satisfy their impulse to purchase a beautiful product. It is <a id="id75" class="indexterm"/>your job to facilitate the satisfaction of<a id="id76" class="indexterm"/> this impulse with as few barriers as possible.</p><div><img src="img/B05093_02_03.png.jpg" alt="Presenting the Apple Pay button"/></div><p>When the user taps the <strong>Apple</strong> <strong>Pay</strong> button, your app starts the Apple Pay transaction by creating a payment request.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Creating the payment request</h1></div></div></div><p>Now that the user has decided to purchase your product, we are on a mission to help them authorize the <a id="id77" class="indexterm"/>payment request with as few distractions and interruptions as possible. A user's attention, especially on a device such as an iPhone, can be fleeting; in the extra second that it takes for them to confirm a billing address (even though they always use the same address), a phone call can come in and, pouf, the sale goes away. Anything you can not show the user helps speed up the authorization. Apple Pay makes this very convenient.</p><div><img src="img/B05093_02_04.png.jpg" alt="Creating the payment request"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Specifying payment details</h2></div></div></div><p>The essential<a id="id78" class="indexterm"/> components of a payment request (an instance of <code class="literal">PKPaymentRequest</code>) are: country and currency code, your merchant identifier and capabilities, and the payment networks that you support. You must specify all<a id="id79" class="indexterm"/> these properties on each payment request you create.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Country and currency code</h2></div></div></div><p>You specify these items <a id="id80" class="indexterm"/>with the <code class="literal">countryCode</code> and <code class="literal">currencyCode</code> properties of the payment request. Specifying<a id="id81" class="indexterm"/> these items is important because they identify where and how the payment is processed. The country code is the two-letter code for the country where the payment will be <a id="id82" class="indexterm"/>processed (refer to ISO 3166 at <a class="ulink" href="http://www.iso.org/iso/country_codes">http://www.iso.org/iso/country_codes</a>). The currency code is the three-letter  code that<a id="id83" class="indexterm"/> identifies the currency that is used to fund the transaction (refer to ISO 4217 at <a class="ulink" href="http://www.iso.org/iso/home/standards/currency_codes">http://www.iso.org/iso/home/standards/currency_codes</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Merchant identifier and capabilities</h2></div></div></div><p>The Apple merchant identifier is the<a id="id84" class="indexterm"/> identifier that you obtained (or will get right now!) from the <em>Certificates, Identifiers &amp; Profiles</em> section of the Apple Member Center website. They are reverse-DNS identifiers that start with <code class="literal">merchant.com</code>. The merchant <a id="id85" class="indexterm"/>capabilities identify the<a id="id86" class="indexterm"/> payment protocols, 3-D Secure, and EMV (Europay, MasterCard, and Visa). 3-D Secure support is required; EMV support is<a id="id87" class="indexterm"/> optional. You specify these components with the <code class="literal">merchantIdentifier</code> and <code class="literal">merchantCapabilities</code> properties of the payment request.</p><p>This listing shows the code that specifies the payment details of a payment request:</p><div><pre class="programlisting">// create payment request
PKPaymentRequest *request= [Stripe paymentRequestWithMerchantIdentifier:ApplePay_merchant_identifier];
request.merchantIdentifier=            ApplePay_merchant_identifier;
request.countryCode=                   @"US";
request.currencyCode=                  @"USD";
request.supportedNetworks=             ApplePay_supported_networks;
request.merchantCapabilities=          PKMerchantCapability3DS;</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Requiring shipping and billing information</h1></div></div></div><p>Apple Pay<a id="id88" class="indexterm"/> provides all the information that you need to complete a transaction. However, there may be situations in which you need information stored in Apple Pay that is not available to you before the user authorizes the payment request. For example, even though Apple Pay provides shipping and billing information, you may still require that the user enter or confirm the shipping destination before they authorize the payment request to calculate the shipping costs to present in the payment sheet. Keep in mind though that as your customer's billing and shipping details are most likely up to date in Apple Pay, relying on Apple Pay for this information is<a id="id89" class="indexterm"/> generally the best approach. Not to mention that by not requiring users to confirm such details, you would be putting them on the fast lane to that magical <em>authorization touch</em>.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Requiring shipping or billing addresses</h2></div></div></div><p>If you need the user to <a id="id90" class="indexterm"/>enter shipping or billing information (because your systems interface with other systems that need this information readily), you can specify these requirements with the <code class="literal">requiredBillingAddressFields</code> and <code class="literal">requiredShippingAddressFields</code> properties of the payment request. For example, to make the billing address a required field, set this property to <code class="literal">PKAddressFieldPostalAddress</code>. If you need an e-mail, set it to <code class="literal">PKAddressFieldEmail</code>. Finally, to request a name, set the property to <code class="literal">PKAddressFieldName</code>. As the values that these properties accept are bitfield constants, you can aggregate them to require multiple items. This listing shows how to require a shipping address and email, and a billing email:</p><div><pre class="programlisting">// client_app/merchantapp/ProductCard.m
@interface ProductCard()
@property PKPaymentRequest* payment_request;
...
@end

- (void) process_ApplePay_payment_request
{
   // create payment request
   _payment_request=
      [Stripe paymentRequestWithMerchantIdentifier:...];
   {            
      // require shipping address and email, and billing email
      _payment_request.requiredShippingAddressFields=
         PKAddressFieldPostalAddress | PKAddressFieldEmail;
      _payment_request.requiredBillingAddressFields=
         PKAddressFieldEmail;
   }
   ...
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Specifying shipping or billing addresses</h2></div></div></div><p>If your customer <a id="id91" class="indexterm"/>has purchased items from your business before, and you have their billing and shipping address, you can prepopulate this information on the payment sheet using the <code class="literal">billingAddress</code> and <code class="literal">shippingAddress</code> properties of the payment request.</p><p>This listing shows how to make shipping and billing information required fields:</p><div><pre class="programlisting">client_app/merchantapp/ProductCard.m
@interface ProductCard()
@property PKPaymentRequest* payment_request;
...
@end

- (void) process_ApplePay_payment_request
{
   ...
   // specify a particular shipping address
   PKContact*              contact= [PKContact new];
   CNMutablePostalAddress* address= [CNMutablePostalAddress new];
   address.street=          @"123 Fern Road";
   address.city=            @"San Jose";
   address.postalCode=      @"95123";
   address.country=         @"USA";
   address.ISOCountryCode=  @"US";
   contact.postalAddress=   [address copy];
      
   _payment_request.shippingContact= contact;
   ...
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Specifying shipping methods</h2></div></div></div><p>If you ship<a id="id92" class="indexterm"/> products to your customers, you may offer one or more shipping methods. The example iOS app and web service described earlier shows a basic implementation of such a system. Depending on the size of your enterprise, you may offer shipping methods for particular products or destinations. Regardless of the complexity of the setup, in the payment sheet that you present should be a simple list of shipping methods from which users choose the one that is most convenient to them. The next chapter discusses how to react when the user changes the shipping method in the payment sheet. For now, your focus is on creating an array of shipping methods (the <code class="literal">PKShippingMethod</code> instances) to assign to the <code class="literal">shippingMethods</code> payment-request property. This listing shows how to create such an array and how to<a id="id93" class="indexterm"/> incorporate it on the payment request:</p><div><pre class="programlisting">// client_app/merchantapp/ProductCard.m
#import "ShippingMethod.h"
...
@property PKPaymentRequest* payment_request;
...
- (void) viewDidLoad 
{
   ...
   // get the ShippingMethod objects in the app delegate,
   // and convert them to PKShippingMethod objects
   AppDelegate* app_delegate=
      [UIApplication sharedApplication].delegate;
   NSMutableArray&lt;PKShippingMethod*&gt;* pk_shipping_methods=
      [NSMutableArray new];
   for (ShippingMethod* shipping_method in
      app_delegate.shipping_methods)
   {
      PKShippingMethod* pk_shipping_method=
         [PKShippingMethod 
             summaryItemWithLabel:
                [@"Shipping " stringByAppendingString:
                   shipping_method.name]
             amount:
                [NSDecimalNumber
                   decimalNumberWithString:
                      shipping_method.price]];
      pk_shipping_method.identifier= shipping_method.name;
      pk_shipping_method.detail=     shipping_method.detail;
      
      [pk_shipping_methods addObject: pk_shipping_method];
   }
   _pk_shipping_methods= pk_shipping_methods.copy;
}

- (void) process_ApplePay_payment_request
{
   // create payment request
   AppDelegate* app_delegate=
      [UIApplication sharedApplication].delegate;
   _payment_request=
      [Stripe paymentRequestWithMerchantIdentifier:
         app_delegate.ApplePay_merchant_identifier];
  ...      
   // set the shipping methods
   _payment_request.shippingMethods= _pk_shipping_methods;
  ...   
}</pre></div><p>If, in addition to shipping goods using shipping services, you support in-store pickup of items or special delivery methods, such as for pizza or furniture, then you can specify a list of alternative delivery methods. To specify these shipping types, use the <code class="literal">shippingType</code> property of the payment request.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Specifying summary items</h1></div></div></div><p>The summary items <a id="id94" class="indexterm"/>are the elements of the payment sheet that specify the price of the item the user is purchasing, the shipping cost, taxes, discounts, and the total price. Each summary item has a label, such as <code class="literal">SHIPPING</code> or <code class="literal">TAX</code>. The last item represents the total price with a label, such as <code class="literal">PAY ACME</code>. The label of this item must identify your company so that the customer can match the purchase to their payment-card statement. You specify the summary items of a payment request by assigning an array of <code class="literal">PKPaymentSummaryItem</code> instances to the <code class="literal">paymentSummaryItems</code> property of the payment request. Each summary item has an <code class="literal">amount</code> property that represents the cost of the item.</p><p>This listing shows how to define the summary items of a payment request:</p><div><pre class="programlisting">// client_app/merchantapp/ProductCard.m
@property Product*           product;
@property PKPaymentRequest*  payment_request;
@property PKShippingMethod*  selected_shipping_method;
...
// tally the summary items' cost and the grand total
- (NSArray&lt;PKPaymentSummaryItem*&gt;*) computeSummaryItems
{
   NSDecimalNumber* product_price=
      [NSDecimalNumber decimalNumberWithString:_product.price];
      
   NSDecimalNumber* shipping=
      _selected_shipping_method?
         _selected_shipping_method.amount :
         [NSDecimalNumber zero];
         
   NSDecimalNumber* tax=
      [product_price decimalNumberByMultiplyingBy:
         [NSDecimalNumber decimalNumberWithString:@"0.08"]];
         
   NSDecimalNumber* total=
      decimal_number_sum(@[product_price, shipping, tax]);

   // specify summary items
   NSMutableArray&lt;PKPaymentSummaryItem*&gt;* summary_items=
   [NSMutableArray arrayWithArray: 
    @[
      [PKPaymentSummaryItem
         summaryItemWithLabel:_product.name amount:product_price],
      [PKPaymentSummaryItem
         summaryItemWithLabel:@"Shipping"   amount:shipping],
      [PKPaymentSummaryItem
         summaryItemWithLabel:@"Tax"        amount:tax],
      [PKPaymentSummaryItem
         summaryItemWithLabel:@"Acme"       amount:total]
      ]];
   
   return summary_items.copy;
}

- (void) process_ApplePay_payment_request
{
   // create payment request
   _payment_request=
      [Stripe paymentRequestWithMerchantIdentifier:...];

   // compute summary items and assign them to the payment request
   _payment_request.paymentSummaryItems= [self computeSummaryItems];
   ...
}</pre></div><p>To specify a summary<a id="id95" class="indexterm"/> item representing a discount from the product price, use a negative value for the summary item's amount. When you do not know the value for the amount because the value is generated as part of processing the order, you can indicate this fact to the user by setting the <code class="literal">type</code> property of the summary item to <code class="literal">PKPaymentSummaryItemTypePending</code>. This adds an appropriate legend to the item's label.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Specifying custom information tied to the order</h1></div></div></div><p>If your ordering system needs additional information after the payment has been approved by the issuing bank, you can specify it in the <code class="literal">applicationData</code> property of the payment request. However, Apple Pay does not deliver this information to you. Your app has to send this<a id="id96" class="indexterm"/> information to your system separately.</p><p>As part of processing payment, your payment processor gets a hash of the value that you set in the <code class="literal">applicationData</code> property of the payment request. You can use this hash to verify that the value the app sent separately is the same as the initial value.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>This chapter has shown how your app may obtain data to perform its functions using the REST API, which provides flexible functionality using the standard HTTP idioms (with HTTP verbs such as <code class="literal">PUT</code>, <code class="literal">GET</code>, <code class="literal">UPDATE</code>, and <code class="literal">DELETE</code>). It also showed you how to convert this data into information the user can act on, such as product names, descriptions, and images. In particular, this chapter discussed when to present the <strong>Apple</strong> <strong>Pay</strong> button to the user (only when Apple Pay is available on the user's device). Finally, this chapter walked you through the process of creating a payment request, which includes specifying payment information, such as the Apple merchant identifier and merchant capabilities, shipping and billing information, and the summary items that include the total price of the order labeled with your company name for easy verification with payment-card statements.</p><p>Now that the user is looking at the payment sheet, your app needs to respond effectively to changes in the shipping methods or billing and shipping addresses. The ultimate user action though is authorizing the payment request. This is the topic of the next chapter.</p></div></body></html>