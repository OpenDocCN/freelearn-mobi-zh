- en: Chapter 10. The Best of Both Worlds – Combining FP Paradigms with OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Objects are closures with multiple methods, closures are objects with
    a single method. So yes [OOP and FP can be used together.]"* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Erik Meijer* |'
  prefs: []
  type: TYPE_TB
- en: In previous chapters, we talked about **functional programming** (**FP**) most
    of the time. You learned various techniques and paradigms of FP. In contrast,
    we barely touched on **object-oriented programming** (**OOP**). Mostly, we talked
    about the disadvantages of imperative programming. In practice, most of us have
    to work on applications that are designed by OOP principles. The reality is that
    even if we do not like OOP, we are stuck with it. For instance, in iOS and macOS
    development, we have to deal with Cocoa and **Cocoa Touch** frameworks that are
    designed by OOP principles.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we are familiar with OOP because most of us learned it at
    some point and some of us find it natural to model real-world problems with it.
  prefs: []
  type: TYPE_NORMAL
- en: There is a huge discussion about benefits of one paradigm over the other. Some
    claim that they can be unified; some claim that they are exclusive and we should
    choose one paradigm over the other. Also, different programming languages and
    their communities follow different approaches. For instance, Haskell is a purely
    functional programming language and it is almost impossible to do OOP with it.
    In fact, it is absurd to do OOP with it. On the other hand, languages such as
    Java, Ruby, Python, and C# are OOP languages with limited FP capabilities. There
    are also languages such as Scala that mix OOP with FP and embrace both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: How would we picture Swift in these settings? We know that Swift is not a pure
    FP language and has FP capabilities but we need to further evaluate it in this
    regard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these, the Swift programming community has been introduced to
    another paradigm: **protocol-oriented programming** (**POP**). Furthermore, **Functional
    Reactive Programming** (**FRP**) became very popular and is loved by lots of developers.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages and disadvantages of a paradigm over the others? How
    would we design our applications to benefit from all these paradigms? These are
    the questions that we will try to answer in this chapter. Hence, we will start
    by introducing OOP, POP, and FRP, and then we will mix OOP paradigms with FP.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to OOP paradigms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP design patterns/principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to POP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Reactive Programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing OOP and FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine general paradigms in OOP. We start with objects
    because they are the most fundamental artifacts in OOP. Next, we will look into
    classes that are blueprints to create objects. Then we will continue with paradigms
    such as inheritance, polymorphism, and dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an OOP application, objects are the runtime entities or instances that take
    space in memory, more specifically, in the heap. Objects have an associated/allocated
    memory address to store their state and a set of functions or methods that define
    the suitable operations on the object state. In short, in OOP, an object encapsulates
    state and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an object, a blueprint or recipe is required, which is called class
    in OOP. The following section will explore the class concept in more detail. For
    now, we will define a very simple class in order to be able to talk about objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `name` and `age` are constants and variables that can be used
    to store the state of the object. The `incrementUserAgeByOne` method is a behavior
    definition that changes the state of the object. We have to create an instance/object
    of this class to be able to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of our preceding example, we created an object with our `User`
    recipe. At the same time, we allocated a memory address to our object and initialized
    it. The object, which is an instance of `User`, can be used; we can change its
    state and use its methods to do operations or change its state.
  prefs: []
  type: TYPE_NORMAL
- en: From a design perspective, objects model the entities in the application domain.
    In our example, object represents `User`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand the following about classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes encapsulate states that are mutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that we create a new instance of class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This assignment is not going to copy `object1` and will make `object2` refer
    to the same instance. Let''s examine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, when we print `object2.age`, it will produce the same result with `object1.age`
    and when we call `incrementUserAgeByOne`, it will change the instance's age; therefore,
    it will be changed for the `object1` as well as `object2`.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior can be helpful in some circumstances, for instance, if we need
    to share an instance between different objects. Examples can be database or file
    management system operations and `AppDelegate` in iOS and macOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it can complicate the reasoning about the code. For instance,
    if we had lots of references to the same instance and changing one of them would
    change all the instances, we would need to react to those changes for all the
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not need to share instances, then we can create a new object and use
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, as we allocate and initialize a new memory space for
    our `object3`, it does not refer to the same instance with `object1` and `object2`.
    Any changes on `object3` are not going to affect `object1` and `object2`.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class defines a set of properties and suitable operations. From a type-safe
    programming language point of view, a class is a structure to implement a user-defined
    type such as our `User` class in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Preferably, a class should be an implementation of an **Abstract Data Type**
    (**ADT**) that hides the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of an ADT as a class can be composed of two kinds of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods that return meaningful abstractions about the state of an instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformational methods to move from a valid instance state to another valid
    state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to hide implementation details and for the sake of abstraction, all
    the data within a class should be private to the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve the abstraction in our `User` class example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We made our properties `private` so that no other object can access/change
    them unless it is inside the same Swift file. Also, we added an `init` method
    to initialize the object from our `User` class. Class clients will use the `init`
    method to initialize the object with the initial `name` and `age` information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we left the access level of `incrementUserAgeByOne` as internal (by
    default it is internal); therefore, any other object in the same module will be
    able to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `incrementUserAgeByOne` method changes the state of our object and this
    change will affect all objects that refer to the same instance. We can change
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `incrementUserAge` method returns the new `age` and does not modify the
    state of the object. We will need to initialize a new object and use this `age`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as we do not need to modify `age`, we can make it immutable. Our `User`
    class has two immutable properties with a method that does not modify its properties.
    Therefore, despite the fact that it is a very simple class, it is functional.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is a relation between classes that makes it possible to define and
    implement a class based on other existing classes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, inheritance helps code reusability and allows independent extensions of
    the original class (the `super` class) through public classes and interfaces.
    The relationship between classes through inheritance causes a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance inevitably minimizes the amount of rework when we need to add additional
    information and functionalities to an existing class as we can use the class as
    the `super` class and subclass it to add new state information and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, when it is coupled with polymorphisms and dynamic binding, inheritance
    minimizes the amount of existing code that should be changed when extending a
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In programming languages such as C++, it is possible to inherit from more than
    one class, but in Swift, a class can only subclass one other class. The following
    example presents a `UIViewController` subclassing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our `BaseViewController` will inherit all behaviors and properties of the `UIViewController`
    class and we will be able to add new properties and behaviors to it. This way,
    we do not need to rewrite everything from scratch and can reuse properties and
    behaviors in `UIViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift permits a class or object to replace the implementation of a behavior/property
    that it has inherited. This process is called overriding. The `override` keyword
    is used to specify overridden methods in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: We can override an inherited instance or class property to provide our own custom/computed
    getters and setters or add property observers to enable the overriding property
    to observe when the underlying property value changes.
  prefs: []
  type: TYPE_NORMAL
- en: We can mark a property or behavior as `final` to prevent overriding it in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding brings a complication that needs to be handled. We need to ensure
    which version of the behavior/property should an instance of the subclass use:
    the one that is part of its own class (`self`) or the one from the parent (`super`)
    class?'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, `self` and `super` keywords can be used as prefixes to specify the
    version of the required behavior/property.
  prefs: []
  type: TYPE_NORMAL
- en: Design constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using inheritance extensively in designing applications imposes certain constraints.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, suppose we define a subclass of `User` called `WebAppUser` that
    contains the extra acceptable behaviors and another subclass of `User` called
    `MobileAppUser` that contains the mobile app modules of `User`.
  prefs: []
  type: TYPE_NORMAL
- en: In defining this inheritance hierarchy, we have already defined certain restrictions,
    not all of them desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Singleness
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Swift, a subclass can inherit from only one superclass. From the preceding
    example, `User` can be either `WebAppUser` or `MobileAppUser`, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: Static
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The inheritance hierarchy of an object is fixed at initiation while the object's
    type is selected and does not change with time. For example, the inheritance graph
    does not allow a `MobileAppUser` object to become a `WebAppUser` object while
    retaining the state of its `User` superclass (this can be achieved with the decorator
    pattern).
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever client code has access to an object, it generally has access to all
    the object's superclass data. Even if the superclass has not been declared public,
    the client can still cast the object to its superclass type.
  prefs: []
  type: TYPE_NORMAL
- en: Composite reuse
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The composite reuse principle is an alternative to inheritance. This technique
    supports polymorphism and code reuse by separating behaviors from the primary
    class hierarchy and including specific behavior classes as required in any class.
    This approach avoids the static nature of a class hierarchy by allowing behavior
    changes at runtime and permitting a subclass to implement behaviors selectively,
    instead of being restricted to the behaviors of its super classes.
  prefs: []
  type: TYPE_NORMAL
- en: Issues and alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implementation inheritance is controversial among OOP programmers and theoreticians.
    For instance, the authors, *Erich Gamma, John Vlissides, Ralph Johnson, and Richard
    Helm*, of the book, *Design Patterns: Elements of Reusable Object-Oriented Software*,
    advocate interface inheritance instead of implementation inheritance and recommend
    to prefer composition over inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the decorator pattern (as stated earlier) has been proposed to
    overcome the static nature of inheritance between classes.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the OOP community agrees that inheritance introduces unnecessary
    coupling and breaks encapsulation so modifications to the super classes can cause
    undesirable behavioral changes in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the usage of protocols and extensions is encouraged. Using protocols
    avoids the coupling problem because no implementation is shared. We will talk
    more about protocols and protocol extensions in the *POP* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When to inherit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are circumstances where we do not have any other choice but subclassing.
    Here are some of the examples where subclassing is required:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it is required by the APIs: For instance, many of Cocoa APIs require the
    use of classes and being controversial is not recommended. For instance, `UIViewController`
    has to be subclassed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we need to manage and communicate our value types between instances of
    other classes: For example, when we need to draw a custom view in a Cocoa class
    provided by another drawing class, we will need to communicate it between them.
    Using a value type in this case is not beneficial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we need to share an instance between multiple owners: Core Data persistence
    is an example. It can be very useful to have a synchronization mechanism across
    multiple owners while using Core Data. This will cause concurrency issues but
    we have to deal with them as we require mutable data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the lifetime of an instance is connected to external effects or we require
    a stable identity: Singletons and AppDelegate are some of the examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymorphism means many forms. In general, the ability to take more than one
    form is called polymorphism. In an object-oriented language such as Swift, a polymorphic
    reference is one that can, over time, refer to instances of more than one class.
    Let''s examine an example of the iOS SDK, `UIView`. There are lots of `UIView`
    subclasses including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UILabel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UITextField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can declare a view that can take many forms such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Polymorphism allows us to write a more generic code that works with families
    of objects rather than writing code for a specific class. In this example, regardless
    of which class we initiate, we can access all the properties and methods declared
    in the `UIView` class that are inherited by all the subclasses. For instance,
    we will be able to check the bounds and origins of any of them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are able to refer to more than one type of objects; therefore, a polymorphic
    reference has both a static and dynamic type associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: The static type is determined from the declaration of the object in the code.
    It is known at compile time and determines the set of valid types that the object
    can accept at runtime. This determination is made from an analysis of the inheritance
    graphs in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic type of the reference may change over time during the application
    execution. In Swift, the runtime system keeps all polymorphic references automatically
    tagged with their dynamic type.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Associating a method call to the code to be executed is called binding. As opposed
    to static binding where the code associated with the method call is bound during
    the compile time, dynamic binding means that the code associated with a given
    method call is not known and will be determined during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic binding is associated with polymorphism and inheritance because a method
    call associated with a polymorphic reference may depend on the dynamic type of
    that reference.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, our view's static type is `UIView` and its dynamic type may be
    `UILabel`, `UITextField`, or `UIButton`. Let's suppose that some of the methods
    in `UIView` are overridden for `UIButton`. When we call those methods, runtime
    will dynamically bind the method that needs to be called.
  prefs: []
  type: TYPE_NORMAL
- en: OOP design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some of the problems with the OOP approach
    and OOP solutions and FP solutions to these problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, OOP is being criticized in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: Binding a data structure to behavior is a mechanism of state encapsulation that
    hides the underlying problem instead of solving it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A great deal of effort goes into making inheritance possible. Ironically, object-orientated
    patterns themselves favor composition over inheritance. Ultimately, in handling two
    responsibilities—subtyping and reusing—inheritance is not good with either subtyping
    or reusing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OOP solutions to these problems include SOLID and DDD principles. The following
    are the SOLID principles:'
  prefs: []
  type: TYPE_NORMAL
- en: The **single responsibility principle** (**SRP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **open/closed principle** (**OCP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Liskov substitution principle** (**LSP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **interface segregation principle** (**ISP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **dependency inversion principle** (**DIP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-driven Design** (**DDD**) principles are proposed to solve OOP problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, FP addresses these problems by the following distinguishing characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit management of state is avoided through **immutability**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit return values** are favored over implicit side-effects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful **composition** facilities promote reuse without compromising encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The culmination of these characteristics is a more **declarative** paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SRP states that every class should have a single responsibility where a
    responsibility is defined as a reason to change.
  prefs: []
  type: TYPE_NORMAL
- en: This principle supports the anti-pattern where large classes play multiple roles.
    Classes can be large for a few reasons. A core principle of OOP is the binding
    of the data structure to behavior. The problem is that optimizing for data structure
    encapsulation not only weakens composition characteristics, but also hides the
    underlying problem of explicit state. As a result, OOP code typically contains
    many data structures with relatively few functions per data structure. Adding
    methods to a class brings pressure on the SRP and reducing the number of methods
    can either make the data structure difficult to compose or altogether useless.
    Furthermore, the simple syntactical cost of declaring a class often compels programmers
    to marginalize.
  prefs: []
  type: TYPE_NORMAL
- en: The FP counterpart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In FP, the fundamental unit of abstraction is the function. Given that a function
    has a single output, functions naturally have a single responsibility. One could
    certainly define an arbitrarily generic function, though this would not be intuitive.
    Moreover, functions are syntactically less resource-hungry.
  prefs: []
  type: TYPE_NORMAL
- en: OCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OCP states that software entities should be open for extension but closed
    for modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ambiguity of this statement can be resolved through two variations of the
    principle:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing classes should be modified only in order to correct bugs. This restriction
    delivers the closed aspect of the principle. The open aspect is delivered through
    implementation inheritance or, in other words, inheritance with the goal of reusing
    rather than subtyping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Openness through polymorphism, which by definition also provides for closure,
    as extensibility is supported through substitution rather than modification. Unfortunately,
    substitution often leads to accidental complexity, which must be addressed by
    yet another principle—the LSP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary utility of the OCP is the confinement of cascading changes while
    providing extensibility. This is achieved by designing for extensibility and prohibiting
    changes to existing entities. Extensibility is attained by fancy tricks with abstract
    classes and virtual functions. Closure is achieved by encapsulation or rather
    by the hiding of moving parts.
  prefs: []
  type: TYPE_NORMAL
- en: The FP counterpart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In FP, functions can be substituted at will and as such, there is no need to
    design for extensibility. Functionality requiring parameterization is naturally
    declared as such. Instead of inventing a concept of a virtual method and inheritance,
    one can rely on an existing, elementary concept—the higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: LSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LSP states that objects in a program should be replaceable with instances
    of their subtypes without altering the correctness of that program.
  prefs: []
  type: TYPE_NORMAL
- en: The LSP is essentially a restricted instance of subtyping, which aims to guarantee
    semantic portability across class hierarchies. Portability is achieved by ensuring
    that whatever is true of a base type is also true of all subtypes. Subclasses
    must not strengthen preconditions. They must accept all input and initial states
    that the base class accepts and subclasses must not weaken post-conditions. Behavioral
    expectations declared by the super class must be met by the subclass. These characteristics
    cannot be enforced by the type system alone.
  prefs: []
  type: TYPE_NORMAL
- en: The LSP as a relation of inheritance is thus deceptive, hence the need for a
    compensating principle. As such, the need for this principle demonstrates a pitfall
    in subtype (inclusion-based) polymorphism. Implicit factoring by class hierarchy
    imposes the needless inclusion of restrictions and requires complex principles
    to place a boundary on accidental complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The FP counterpart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional languages favor parametric polymorphism with bounded quantification,
    thereby avoiding some of the pitfalls of inheritance. Informally, functional languages
    emphasize substitutability and de-emphasize implementation reuse as reuse is better
    achieved through composition. Most ambitions of the LSP are effectively trivial
    in FP languages.
  prefs: []
  type: TYPE_NORMAL
- en: ISP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ISP states that many client-specific interfaces are better than one general-purpose
    interface. In other words, no client should be forced to depend on methods that
    it does not use.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, ISP is a restatement of the SRP for interfaces and reflects the
    same underlying problem—the difficulty of balancing responsibility assignment,
    composition, and encapsulation in object-oriented design. On the one hand, it
    is desirable to encapsulate; on the other hand, it is desirable to compose. Furthermore,
    the problem with employing the ISP alone is that it doesn't directly protect against
    large classes and in some ways hides the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The FP counterpart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming reduces the need for encapsulation by eschewing state
    and breeds composition at the core. There is no augmented concept of role-based
    interfaces because function roles are explicit at the onset. Functions are segregated
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: DIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DIP states that one should depend upon abstractions. Do not depend upon
    concretions. In other words, high-level modules should be decoupled from low-level
    modules through abstractions. This principle states that code should be structured
    around the problem domain, and the domain should declare dependencies on required
    infrastructure as protocols. Dependencies thus point inward to the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that this principle is an inversion is because typical architectures
    promoted by OOP (via layer architecture) exhibit dependency graphs where high-level
    modules consume low-level modules directly. Initially, this dependency graph seems
    natural as, in expressing domain models in code, one inevitably depends upon the
    constructs of the language. Procedural programming allows dependencies to be encapsulated
    by procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Subtype polymorphism defers procedure implementation. Unfortunately, the use
    of protocols is often overlooked to express domain dependencies in OOP implementations.
    Given that infrastructure code is typically more voluminous, the focus of the
    code drifts away from the domain. DDD was devised in part to balance this drift.
  prefs: []
  type: TYPE_NORMAL
- en: The FP counterpart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The declarative and side-effect-free nature of FP provides dependency inversion.
    In OOP, high-level modules depend on infrastructure modules primarily to invoke
    side-effects. In FP, side-effects are more naturally triggered in response to
    domain behavior as opposed to being directly invoked by domain behavior. Thus,
    dependencies become not merely inverted, but pushed to outer layers altogether.
  prefs: []
  type: TYPE_NORMAL
- en: DDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDD is an approach to software development for complex needs by connecting the
    implementation to an evolving model.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concepts of the model include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**: The setting in which a word or statement appears that determines
    its meaning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain**: An ontology, influence, or activity. The subject area to which
    the user applies a program is the domain of the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: A system of abstractions that describes selected aspects of a domain
    and can be used to solve problems related to that domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ubiquitous language**: A language structured around the domain model and
    used by all team members to connect all the activities of the team with the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Premise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The premise of DDD is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the project's primary focus on the core domain and domain logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basing complex designs on a model of the domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiating a creative collaboration between technical and domain experts to
    iteratively refine a conceptual model that addresses particular domain problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In DDD, there are artifacts to express, create, and retrieve domain models that
    are explored from an FP perspective in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A collection of objects that are bound together by a root entity, otherwise
    known as an aggregate root. The aggregate root guarantees the consistency of changes
    being made within the aggregate by forbidding external objects from holding references
    to its members.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of the aggregate remains in FP; however, it is not represented in
    terms of a class. Instead, it can be expressed as a structure, including a set
    of aggregate states, initial state, set of commands, set of events, and function-mapping
    the set of commands to the set of events given a state. Cohesion is provided by
    a module mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable value objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Immutable value objects are objects that contain attributes but have no conceptual
    identity. They should be treated as immutable.
  prefs: []
  type: TYPE_NORMAL
- en: In a previous chapter, we saw that Swift provides immutable product and sum
    types with auto-implemented structural equality, which addresses this pattern
    trivially. Heavy reliance on state in OOP makes references first-class citizens
    rather than the structure of the data itself.
  prefs: []
  type: TYPE_NORMAL
- en: Domain events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A domain event is a domain object that defines an event.
  prefs: []
  type: TYPE_NORMAL
- en: Domain events are powerful mechanisms to keep domain models encapsulated. This
    can be accomplished by allowing various observers from outer layers to register
    for a domain event (`signal`).
  prefs: []
  type: TYPE_NORMAL
- en: The problem with domain events in OOP is that the typical implementation is
    complex and relies on side-effects. Event observations are typically declared
    in the composition root and thus, it is not immediately obvious from the perspective
    of the producer which observers will be invoked. In FP, a domain event is simply
    a value returned by a function in an aggregate. Observers can be explicitly registered
    as filters.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, FRP can handle domain events very effectively. On the other hand,
    returning domain events from aggregate methods in OOP is prohibitive due to the
    lack of union types and pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Intention-revealing interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In imperative OOP code, intent leaks through side-effects and focuses on the
    how rather than the what. Always having to bind behavior to the data structure
    can also be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: As FP is more declarative, function names and interfaces tend to be more focused
    on intent rather than the the underlying mechanics. In addition, the interfaces
    of side-effect-free functions are by nature more revealing because behavior is
    made explicit through the return value. As a result, in addition to the purely
    linguistic benefit of naming with intent, intent is also encoded by the type system.
    This is not to say that expressing intent is effortless in FP—only that it is
    better supported by the FP paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Side-effect-free functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Side-effects are in direct opposition to encapsulation, yet all too often they
    are the most useful tools.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike imperative programming, FP avoids side-effects. This pattern is yet another
    example of how a well-crafted object-oriented design converges upon a functional
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like many patterns rooted in imperative object-oriented design, assertions claim
    to use implicit side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: As with intention-revealing interfaces, assertions in FP languages are automatically
    encoded in the return type of a function in addition to the function name.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptual contours
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Conceptual contours emerge when domain knowledge is spread throughout the code
    to a sufficient degree. In OOP, this can be achieved by carefully following the
    principles of DDD.
  prefs: []
  type: TYPE_NORMAL
- en: In FP, conceptual contours emerge more readily, once again due to the declarative
    and side-effect-free nature of the paradigm. Specifically, clients of the domain
    model can rely on cohesive functionality attained with composition and yet still
    have access to constituents without breaking encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Closure of operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Closure of operations illustrates yet another example of coercing composition
    and structure upon object-oriented designs.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, closure simplifies reasoning about a problem by restricting the
    domain of the discourse. The example of a functional implementation of a domain
    exhibits this characteristic at a fundamental level. The operation of applying
    a domain event is closed under the set of domain states. In terms of persistence,
    this naturally translates to event-sourcing but also supports persistence in a
    key-value store or ORM with no required modification.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The overall intent of the aforementioned patterns is to cultivate a declarative
    design. As witnessed, FP is inherently more declarative and therefore more accommodating
    in this regard. Through declarative design, we can distill distinguishing characteristics
    of the domain better and reduce or eliminate coupling to orthogonal concerns of
    infrastructure. Consequently, re-usability, testability, correctness, maintainability,
    and productivity are tremendously enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol-oriented programming (POP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: POP encourages us to develop protocols and extend them instead of classes and
    inheritance. POP is new in the Objective-C and Swift development community, but
    what it provides is not very different from the concept of `Abstract` classes
    in languages such as Java and C# and `pure-virtual` functions in C++.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, classes, structs, and enumerations can conform to protocols. This
    makes protocols more usable because inheritance does not work for structs and
    enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: POP paradigms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will explore POP paradigms. To start with, we will look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This protocol defines two functions to be implemented by the struct, enumeration,
    or classes that need to conform to this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protocol composition allows types to conform to more than one protocol. This
    is one of the many advantages that POP has over OOP. With OOP, a class can have
    only one superclass, which can lead to very monolithic super classes. With POP,
    we are encouraged to create multiple smaller protocols with very specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protocol extensions are one of the most important parts of the POP paradigm.
    They allow us to add functionality to all types that conform to a given protocol.
    Without protocol extensions, if we had common functionality that was necessary
    for all types that conformed to a particular protocol, then we would need to add
    that functionality to each type. This would lead to large amounts of duplicated
    code. The following example extends our protocol by adding a `logout` method and
    its implementation; thus any struct, enum or class that conforms to `UserProtocol`
    will have the `logout` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Protocol inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protocol inheritance is where one protocol can inherit the requirements from
    one or more other protocols, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`MobileAppUserProtocol` inherits from `UserProtocol` so it will have all the
    defined and extended methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Associated types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Associated types can be used to make our protocols work with generic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Conforming to a protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code presents an example of protocol conformance with associated
    type usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can create a new mobile user as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: POP minimizes the inheritance and subclassing necessities by enabling us to
    conform to protocols and extend them with default implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Reactive Programming (FRP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming avoids immutability and side-effects. In some circumstances,
    the application should react to dynamic value/data changes. For instance, we may
    need to change the user interface of an iOS application to reflect received data
    from a backend or database system. How would we do this without states and mutable
    values?
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming captures these dynamic values only indirectly, through
    state and mutations. The complete history (past, present, and future) has no first-class
    representation. Moreover, only discretely-evolving values can be (indirectly)
    captured as the imperative paradigm is temporally discrete.
  prefs: []
  type: TYPE_NORMAL
- en: FRP provides a way to handle dynamic value changes while still retaining the
    FP style. FRP, as its name suggests, is a combination of FP and reactive programming.
    Reactive programming makes it possible to deal with certain data types that represent
    values over time. These data types are called time flow or event streams in different
    functional programming languages. Computations that involve these changing-over-time/evolving
    values will themselves have values that change over time. FRP captures these evolving
    values directly and has no difficulty with continuously evolving values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, FRP can be presented as the following set of principles/rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types or dynamic/evolving over time values should be first-class citizens.
    We should be able to define, combine, and pass them to functions and return them
    from functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types should be built from a few primitives such as constant/static values
    and time with sequential and parallel combinations. The n behaviors are combined
    by applying an n-ary function to static values continuously over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To account for discrete phenomena, we should have additional event types, each
    of which has a stream (finite or infinite) of occurrences. Each occurrence has
    an associated time and value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To come up with the compositional vocabulary out of which all behaviors and
    events can be built, play with some examples. Keep deconstructing into pieces
    that are more general/simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should be able to compose the whole model, using the technique of denotational
    semantics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type has a corresponding simple and precise mathematical type of meaning
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each primitive and operator has a simple and precise meaning as a function of
    the meanings of the constituents
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Building blocks of FRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to understand FRP building blocks to be able to understand FRP.
    The following sections explain these building blocks with one of the great FRP
    libraries for the Cocoa framework called ReactiveCocoa developed by GitHub. ReactiveCocoa
    was developed for Objective-C and, as of version 3.0, all major feature development
    is concentrated on the Swift API.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Signals are event streams that send values over time that are already in progress.
    We can imagine them as pipes that send values without knowing about the previous
    values that they sent or future values that they are going to send. Signals can
    be composed, combined, and chained declaratively. Signals can unify all Cocoa
    common patterns for asynchrony and event handling:'
  prefs: []
  type: TYPE_NORMAL
- en: Delegate methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control actions and responder chain events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future and Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key-value observing** (**KVO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As all of these mechanisms can be represented in the same way, it is easy to
    declaratively chain and combine them together.
  prefs: []
  type: TYPE_NORMAL
- en: ReactiveCocoa represents signals as `Signal`. Signals can be used to represent
    notifications, user input, and so on. As work is performed or data is received,
    events are sent on the signal, which pushes them out to any observers. All observers
    see the events at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Users must observe a signal in order to access its events. Observing a signal
    does not trigger any side-effects. In other words, signals are entirely producer-driven
    and push-based, and observers cannot have any effect on the signal's lifetime.
    While observing a signal, the user can only evaluate the events in the same order
    as they are sent on the signal. There is no random access to values of a signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals can be manipulated by applying the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map`, `filter`, and `reduce` to manipulate a single signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip` to manipulate multiple signals at once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations can be applied only on the next events of a signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifetime of a signal may consist of a various number of next events, followed
    by one terminating event, which may be any one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminating events are not included in the signal's values and they should be
    handled specially.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `signal` that can be manually controlled is called `pipe`. In ReactiveCocoa,
    we can create a `pipe` by calling `Signal.pipe()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `pipe` method returns `signal` and `observer`. The `signal` can be controlled
    by sending events to the observer.
  prefs: []
  type: TYPE_NORMAL
- en: Signal producers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A signal producer creates signals and performs side-effects. `SignalProducer`
    can be used to represent operations or tasks such as network requests, where each
    invocation of `start()` will create a new underlying operation and allow the caller
    to observe the result. Unlike a signal, no work is started (and thus no events
    are generated) until an observer is attached, and the work is restarted for each
    additional observer.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a signal producer returns a disposable that can be used to interrupt/cancel
    the work associated with the produced signal.
  prefs: []
  type: TYPE_NORMAL
- en: Signal producers can also be manipulated via operations such as map, filter,
    and reduce. Every signal operation can be *lifted* to operate upon signal producers
    instead, using the `lift` method.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A buffer is an optionally bounded queue for events. A buffer replays these events
    when new signals are created from `SignalProducer`. A `buffer` is created by calling `SignalProducer.buffer()`.
    Similar to `pipe`, the method returns `observer`. Events sent to this observer
    will be added to the queue. If the buffer is already at capacity when a new value
    arrives, the oldest value will be dropped to make room for it.
  prefs: []
  type: TYPE_NORMAL
- en: Observers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An observer is anything that observes or is capable of observing `events` from
    a `signal`. Observers can be implicitly created using the callback-based versions
    of the `Signal.observe()` or `SignalProducer.start()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An action will do some work when executed with an input. Actions are useful
    in performing side-effecting work upon user interaction, such as when a button
    is clicked. Actions can also be automatically disabled based on a property, and
    this disabled state can be represented in a user interface by disabling any controls
    associated with the action.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A property stores a value and notifies observers about future changes to that
    value. The current value of a property can be obtained from the value getter.
    The producer getter returns a signal producer that will send the property's current
    value, followed by all changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: Disposables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A disposable is a mechanism for memory management and cancellation. When starting
    a signal producer, a disposable will be returned. This disposable can be used
    by the caller to cancel the work that has been started, clean up all temporary
    resources, and then send a final Interrupted event with regard to the particular
    signal that was created.
  prefs: []
  type: TYPE_NORMAL
- en: Schedulers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A scheduler is a serial execution queue to perform work or deliver results upon.
    `Signals` and `signal producers` can be ordered to deliver events on a specific
    scheduler. `Signal producers` can additionally be ordered to start their work
    on a specific scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Schedulers are similar to the **Grand Central Dispatch** (**GCD**) queues, but
    schedulers support cancellation via disposables and always execute serially. With
    the exception of `ImmediateScheduler`, schedulers do not offer synchronous execution.
    This helps avoid deadlocks and encourages the use of `signal` and `signal producer`
    operations instead of blocking work.
  prefs: []
  type: TYPE_NORMAL
- en: Schedulers are also somewhat similar to `NSOperationQueue`, but schedulers do
    not allow tasks to be reordered or depend on one another.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s suppose that we have an outlet and we want to observe its changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create `SignalProducer` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `rac_textSignal` method is a ReactiveCocoa extension for `UITextField` that
    can be used to create the signal producer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can start our `SignalProducer` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will print any changes in our `textField` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can execute operations such as `map`, `flatMap`, `filter`, and `reduce`
    on this signal producer, which we covered in [Chapter 6](ch06.html "Chapter 6. Map,
    Filter, and Reduce"), *Map, Filter, and Reduce*.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing OOP and FP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that adding FP capabilities to an OOP language leads to
    benefits in the OOP design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, OOP fits perfectly with FP when our objects are as immutable as
    possible. To make our objects as immutable as possible, we can consider the following
    principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects should be types that encapsulate related pieces of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects can have methods; however, these methods shouldn't change the object
    and should instead return a new one of the appropriate type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the required state data should be injected into the class's initialization
    so that it will be ready to use immediately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods can be used freely and static variables should be avoided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols and generics should be used to avoid code duplicates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These principles not only empower us to employ functional design patterns, but
    also enrich our object-oriented code.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few problems in unifying and mixing OOP with FP, which we will cover
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Granularity mismatch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'FP and OOP operate on different design granularity levels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'FP: Function/method programming on small level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OOP: Classes / objects / modules programming on large level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To overcome this granularity mismatch, we need to find answers for the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Where do we locate the source of individual functions in an OOP architecture?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do we relate such individual functions to an OOP architecture?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Swift, we can place functions inside source files and outside of classes
    or we can place them as static or class methods.
  prefs: []
  type: TYPE_NORMAL
- en: FP paradigm availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we explored a lot of different FP paradigms in Swift. Here, we check
    conceptually whether Swift is a capable language for FP. We will explore the paradigms
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: First-class values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In an FP language, functions/methods should be first-class citizens. First-class
    citizen functions will enable us to use most FP paradigms if they satisfy the
    following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions/methods should be usable as function/method parameters and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions/methods can be returned as a result of a function/method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can take place in data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have seen an example implementation of all these rules.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First-class functions/methods should be implemented as closures. For instance,
    they should be associated with specific private environments.
  prefs: []
  type: TYPE_NORMAL
- en: Swift functions are implemented as closures.
  prefs: []
  type: TYPE_NORMAL
- en: FP-OOP interrelation tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Standalone functions/methods should be explicitly relatable to the class/object
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Swift extensions enable us to add methods to existing classes without creating
    new derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: FP support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FP paradigms should be reinforced by related constructs, predefined definitions,
    occurrences in standard libraries, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'They should satisfy the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading for generic function types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class multiple invocation and multicasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function marshalling and serialization (closures as data structures)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift supports the preceding FP paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Effects of having FP capabilities in OOP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having FP capabilities in the OOP language causes idiomatic and architectural
    effects, which are explored in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code factoring (abstraction) at a function/method granularity level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic iterator and loop operations (map)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation composition and sequence comprehensions (chained function calls)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function partial applications and currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reduction of the number of object/class definitions: Avoids cluttering the
    OOP architecture with new classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name abstraction at a function method level: Using first-class methods allows
    parameters to be instantiated by any method satisfying their declared type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation compositions (and sequence comprehensions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function partial applications and currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP design patterns - an FP perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Design patterns describe recurring solutions to common problems in object-oriented
    software design. Patterns are categorized into three types:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This section introduces some of OOP design patterns on a very high level and
    introduces the FP counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The strategy pattern is a behavioral pattern that lets an algorithm vary independently
    of clients that use it. In other words, it allows one of a family of algorithms
    to be selected on-the-fly at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: From an FP perspective, a strategy is just a case of abstracting code at a method
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Command pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The command pattern is a behavioral pattern that encapsulates requests (method
    calls) as objects so that they can be transmitted, stored, and applied easily.
  prefs: []
  type: TYPE_NORMAL
- en: FP provides closures and first-class functions.
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The observer pattern is a behavioral pattern that allows a one-to-many dependency
    between objects so that when one object changes state, all its dependents are
    notified and updated.
  prefs: []
  type: TYPE_NORMAL
- en: FRP handles this pattern very effectively and declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual proxy pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The virtual proxy pattern is a structural pattern that provides placeholders
    for other objects in such a way that their data is created/computed only when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: FP provides lazy instantiation and evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The visitor pattern is a behavioral pattern that allows us to define new operations
    without changing the classes of the elements on which they operate.
  prefs: []
  type: TYPE_NORMAL
- en: FP makes functions independent of object changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered object-oriented programming principles and paradigms.
    Then we discussed protocol-oriented programming. Next, we introduced FRP. Finally,
    we explored how to mix FP with OOP paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will develop a Todo backend and an iOS application
    employing the concepts that we have covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: We will use functional programming techniques to parse and map the data, and
    we will use FRP to reactively manage the events in the applications. Additionally,
    we will employ protocol-oriented programming and object-oriented programming techniques.
  prefs: []
  type: TYPE_NORMAL
