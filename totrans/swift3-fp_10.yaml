- en: Chapter 10. The Best of Both Worlds – Combining FP Paradigms with OOP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 两全其美 – 结合函数式编程范式与面向对象编程
- en: '|   | *"Objects are closures with multiple methods, closures are objects with
    a single method. So yes [OOP and FP can be used together.]"* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"对象是具有多个方法的闭包，闭包是具有单个方法的对象。所以是的[面向对象编程（OOP）和函数式编程（FP）可以一起使用。]"* |  
    |'
- en: '|   | --*Erik Meijer* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*埃里克·梅耶尔* |'
- en: In previous chapters, we talked about **functional programming** (**FP**) most
    of the time. You learned various techniques and paradigms of FP. In contrast,
    we barely touched on **object-oriented programming** (**OOP**). Mostly, we talked
    about the disadvantages of imperative programming. In practice, most of us have
    to work on applications that are designed by OOP principles. The reality is that
    even if we do not like OOP, we are stuck with it. For instance, in iOS and macOS
    development, we have to deal with Cocoa and **Cocoa Touch** frameworks that are
    designed by OOP principles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们大多数时候都在谈论**函数式编程（FP**）。你学习了FP的各种技术和范式。相比之下，我们几乎没有触及到**面向对象编程（OOP**）。我们主要讨论了命令式编程的缺点。在实践中，我们中的大多数人都必须处理由面向对象编程原则设计的应用程序。现实是，即使我们不喜欢面向对象编程，我们也必须接受它。例如，在iOS和macOS开发中，我们必须处理由面向对象编程原则设计的Cocoa和**Cocoa
    Touch**框架。
- en: On the other hand, we are familiar with OOP because most of us learned it at
    some point and some of us find it natural to model real-world problems with it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们熟悉面向对象编程（OOP），因为大多数人在某个时候都学过它，有些人发现用它来模拟现实世界问题是很自然的。
- en: There is a huge discussion about benefits of one paradigm over the other. Some
    claim that they can be unified; some claim that they are exclusive and we should
    choose one paradigm over the other. Also, different programming languages and
    their communities follow different approaches. For instance, Haskell is a purely
    functional programming language and it is almost impossible to do OOP with it.
    In fact, it is absurd to do OOP with it. On the other hand, languages such as
    Java, Ruby, Python, and C# are OOP languages with limited FP capabilities. There
    are also languages such as Scala that mix OOP with FP and embrace both worlds.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于一种范式相对于另一种范式的益处有着大量的讨论。有些人声称它们可以统一；有些人声称它们是互斥的，我们应该选择一种范式而不是另一种。此外，不同的编程语言及其社区遵循不同的方法。例如，Haskell是一种纯函数式编程语言，几乎不可能用它来做面向对象编程。事实上，用它来做面向对象编程是荒谬的。另一方面，像Java、Ruby、Python和C#这样的语言是具有有限FP能力的面向对象编程语言。还有像Scala这样的语言，它混合了面向对象编程和函数式编程，并拥抱了这两个世界。
- en: How would we picture Swift in these settings? We know that Swift is not a pure
    FP language and has FP capabilities but we need to further evaluate it in this
    regard.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何想象Swift在这些环境中呢？我们知道Swift不是一种纯函数式编程语言，但它具有FP能力，但我们需要进一步评估它在这一点上的表现。
- en: 'In addition to these, the Swift programming community has been introduced to
    another paradigm: **protocol-oriented programming** (**POP**). Furthermore, **Functional
    Reactive Programming** (**FRP**) became very popular and is loved by lots of developers.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Swift编程社区还介绍了一种新的范式：**协议导向编程（POP**）。此外，**函数式响应式编程（FRP**）变得非常流行，受到许多开发者的喜爱。
- en: What are the advantages and disadvantages of a paradigm over the others? How
    would we design our applications to benefit from all these paradigms? These are
    the questions that we will try to answer in this chapter. Hence, we will start
    by introducing OOP, POP, and FRP, and then we will mix OOP paradigms with FP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他范式相比，这种范式的优点和缺点是什么？我们如何设计我们的应用程序以利用所有这些范式？这些问题是我们将在本章中尝试回答的。因此，我们将首先介绍面向对象编程（OOP）、过程式编程（POP）和函数式响应式编程（FRP），然后我们将混合面向对象范式和函数式编程（FP）。
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题，并附上代码示例：
- en: A brief introduction to OOP paradigms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）范式的简要介绍
- en: OOP design patterns/principles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）设计模式/原则
- en: A brief introduction to POP
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程式编程（POP）的简要介绍
- en: Functional Reactive Programming
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式响应式编程（FRP）
- en: Mixing OOP and FP
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合面向对象编程（OOP）和函数式编程（FP）
- en: OOP paradigms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）范式
- en: In this section, we will examine general paradigms in OOP. We start with objects
    because they are the most fundamental artifacts in OOP. Next, we will look into
    classes that are blueprints to create objects. Then we will continue with paradigms
    such as inheritance, polymorphism, and dynamic binding.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查面向对象编程（OOP）中的通用范式。我们从对象开始，因为它们是面向对象编程中最基本的构件。接下来，我们将探讨类，它们是创建对象的蓝图。然后我们将继续讨论诸如继承、多态和动态绑定等范式。
- en: Objects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: In an OOP application, objects are the runtime entities or instances that take
    space in memory, more specifically, in the heap. Objects have an associated/allocated
    memory address to store their state and a set of functions or methods that define
    the suitable operations on the object state. In short, in OOP, an object encapsulates
    state and behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的应用程序中，对象是运行时实体或实例，它们在内存中（更具体地说，在堆中）占用空间。对象有一个关联的/分配的内存地址来存储其状态，以及一组定义在对象状态上的合适操作或方法。简而言之，在面向对象编程中，对象封装状态和行为。
- en: 'To create an object, a blueprint or recipe is required, which is called class
    in OOP. The following section will explore the class concept in more detail. For
    now, we will define a very simple class in order to be able to talk about objects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象需要一个蓝图或脚本，这在面向对象编程（OOP）中被称为类。下一节将更详细地探讨类概念。现在，我们将定义一个非常简单的类，以便能够讨论对象：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, `name` and `age` are constants and variables that can be used
    to store the state of the object. The `incrementUserAgeByOne` method is a behavior
    definition that changes the state of the object. We have to create an instance/object
    of this class to be able to use it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`name` 和 `age` 是可以用来存储对象状态的常量和变量。`incrementUserAgeByOne` 方法是一个行为定义，它改变对象的状态。我们必须创建这个类的实例/对象才能使用它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first line of our preceding example, we created an object with our `User`
    recipe. At the same time, we allocated a memory address to our object and initialized
    it. The object, which is an instance of `User`, can be used; we can change its
    state and use its methods to do operations or change its state.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的示例的第一行中，我们使用我们的 `User` 脚本创建了一个对象。同时，我们为我们的对象分配了一个内存地址并初始化了它。这个对象，作为 `User`
    的实例，可以被使用；我们可以改变其状态并使用其方法进行操作或改变其状态。
- en: From a design perspective, objects model the entities in the application domain.
    In our example, object represents `User`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，对象模型了应用域中的实体。在我们的示例中，对象代表 `User`。
- en: 'It is important to understand the following about classes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理解以下关于类的内容非常重要：
- en: Classes are reference types
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是引用类型
- en: Classes encapsulate states that are mutable
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类封装了可变的状态
- en: 'Suppose that we create a new instance of class as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们按照以下方式创建类的新实例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This assignment is not going to copy `object1` and will make `object2` refer
    to the same instance. Let''s examine the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个赋值不会复制 `object1`，而是会使 `object2` 指向同一个实例。让我们来检查以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, when we print `object2.age`, it will produce the same result with `object1.age`
    and when we call `incrementUserAgeByOne`, it will change the instance's age; therefore,
    it will be changed for the `object1` as well as `object2`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们打印 `object2.age` 时，它会产生与 `object1.age` 相同的结果；当我们调用 `incrementUserAgeByOne`
    时，它会改变实例的年龄；因此，它也会改变 `object1` 和 `object2`。
- en: This behavior can be helpful in some circumstances, for instance, if we need
    to share an instance between different objects. Examples can be database or file
    management system operations and `AppDelegate` in iOS and macOS applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在某些情况下可能很有用，例如，如果我们需要在不同的对象之间共享实例。例如，可以是数据库或文件管理系统操作，以及 iOS 和 macOS 应用程序中的
    `AppDelegate`。
- en: On the other hand, it can complicate the reasoning about the code. For instance,
    if we had lots of references to the same instance and changing one of them would
    change all the instances, we would need to react to those changes for all the
    instances.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它可能会使代码的推理变得复杂。例如，如果我们有很多对同一实例的引用，并且更改其中一个会更改所有实例，我们就需要对所有实例做出反应。
- en: 'If we do not need to share instances, then we can create a new object and use
    it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要共享实例，那么我们可以创建一个新的对象并使用它：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, as we allocate and initialize a new memory space for
    our `object3`, it does not refer to the same instance with `object1` and `object2`.
    Any changes on `object3` are not going to affect `object1` and `object2`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当我们为我们的 `object3` 分配和初始化新的内存空间时，它并不与 `object1` 和 `object2` 指向相同的实例。对
    `object3` 的任何更改都不会影响 `object1` 和 `object2`。
- en: Classes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A class defines a set of properties and suitable operations. From a type-safe
    programming language point of view, a class is a structure to implement a user-defined
    type such as our `User` class in the preceding example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义了一组属性和合适的操作。从类型安全的编程语言角度来看，类是实现用户定义类型（如前面示例中的 `User` 类）的结构。
- en: Preferably, a class should be an implementation of an **Abstract Data Type**
    (**ADT**) that hides the implementation details.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最好，一个类应该是一个 **抽象数据类型**（**ADT**）的实现，它隐藏了实现细节。
- en: 'An implementation of an ADT as a class can be composed of two kinds of methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ADT 的类实现可以由两种方法组成：
- en: Methods that return meaningful abstractions about the state of an instance
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回有关实例状态的有意义抽象的方法
- en: Transformational methods to move from a valid instance state to another valid
    state
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有效实例状态转换为另一个有效状态的方法转换
- en: To be able to hide implementation details and for the sake of abstraction, all
    the data within a class should be private to the class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏实现细节和抽象的目的，一个类中的所有数据都应该对该类是私有的。
- en: 'Let''s improve the abstraction in our `User` class example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进我们的 `User` 类示例中的抽象：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We made our properties `private` so that no other object can access/change
    them unless it is inside the same Swift file. Also, we added an `init` method
    to initialize the object from our `User` class. Class clients will use the `init`
    method to initialize the object with the initial `name` and `age` information:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性设置为 `private`，这样其他对象就无法访问/修改它们，除非它们位于同一个 Swift 文件中。此外，我们还添加了一个 `init` 方法，用于从我们的
    `User` 类初始化对象。类客户端将使用 `init` 方法来初始化对象，并带有初始的 `name` 和 `age` 信息：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, we left the access level of `incrementUserAgeByOne` as internal (by
    default it is internal); therefore, any other object in the same module will be
    able to use it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `incrementUserAgeByOne` 的访问级别留为内部（默认为内部）；因此，同一模块中的任何其他对象都将能够使用它。
- en: 'The `incrementUserAgeByOne` method changes the state of our object and this
    change will affect all objects that refer to the same instance. We can change
    it as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`incrementUserAgeByOne` 方法改变了我们对象的状态，这种变化将影响所有引用同一实例的对象。我们可以这样改变它：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `incrementUserAge` method returns the new `age` and does not modify the
    state of the object. We will need to initialize a new object and use this `age`
    instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `incrementUserAge` 方法返回新的 `age` 而不会修改对象的当前状态。我们需要初始化一个新的对象并使用这个 `age`。
- en: Finally, as we do not need to modify `age`, we can make it immutable. Our `User`
    class has two immutable properties with a method that does not modify its properties.
    Therefore, despite the fact that it is a very simple class, it is functional.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们不需要修改 `age`，我们可以将其设置为不可变。我们的 `User` 类有两个不可变属性和一个不修改其属性的方法。因此，尽管它是一个非常简单的类，但它是有功能的。
- en: Inheritance
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is a relation between classes that makes it possible to define and
    implement a class based on other existing classes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是类之间的一种关系，使得基于其他现有类定义和实现一个类成为可能。
- en: Also, inheritance helps code reusability and allows independent extensions of
    the original class (the `super` class) through public classes and interfaces.
    The relationship between classes through inheritance causes a hierarchy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，继承有助于代码重用，并允许通过公共类和接口独立扩展原始类（即 `super` 类）。通过继承建立起来的类之间的关系导致了一个层次结构。
- en: Inheritance inevitably minimizes the amount of rework when we need to add additional
    information and functionalities to an existing class as we can use the class as
    the `super` class and subclass it to add new state information and behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 继承在需要向现有类添加额外信息和功能时不可避免地会最小化重工作业量，因为我们可以使用该类作为 `super` 类，并从它派生出一个子类来添加新的状态信息和行为。
- en: Moreover, when it is coupled with polymorphisms and dynamic binding, inheritance
    minimizes the amount of existing code that should be changed when extending a
    class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当与多态和动态绑定结合使用时，继承最小化了在扩展类时需要更改的现有代码量。
- en: 'In programming languages such as C++, it is possible to inherit from more than
    one class, but in Swift, a class can only subclass one other class. The following
    example presents a `UIViewController` subclassing:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C++ 这样的编程语言中，可以从多个类中继承，但在 Swift 中，一个类只能从另一个类中派生。以下是一个 `UIViewController`
    派生的示例：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our `BaseViewController` will inherit all behaviors and properties of the `UIViewController`
    class and we will be able to add new properties and behaviors to it. This way,
    we do not need to rewrite everything from scratch and can reuse properties and
    behaviors in `UIViewController`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `BaseViewController` 将继承 `UIViewController` 类的所有行为和属性，我们还将能够向它添加新的属性和行为。这样，我们就不需要从头开始重写一切，可以在
    `UIViewController` 中重用属性和行为。
- en: Overriding
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖
- en: Swift permits a class or object to replace the implementation of a behavior/property
    that it has inherited. This process is called overriding. The `override` keyword
    is used to specify overridden methods in subclasses.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许一个类或对象替换它继承的行为/属性的实现。这个过程称为重写。`override`关键字用于在子类中指定重写的方法。
- en: We can override an inherited instance or class property to provide our own custom/computed
    getters and setters or add property observers to enable the overriding property
    to observe when the underlying property value changes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写继承的实例或类属性，以提供我们自己的自定义/计算属性获取器和设置器，或者添加属性观察器，以便当底层属性值发生变化时，重写的属性可以观察。
- en: We can mark a property or behavior as `final` to prevent overriding it in subclasses.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将属性或行为标记为`final`以防止在子类中重写它。
- en: 'Overriding brings a complication that needs to be handled. We need to ensure
    which version of the behavior/property should an instance of the subclass use:
    the one that is part of its own class (`self`) or the one from the parent (`super`)
    class?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重写带来了需要处理的复杂性。我们需要确保子类实例应该使用哪个版本的行为/属性：它自己类的一部分（`self`）还是父类（`super`）的一部分？
- en: In Swift, `self` and `super` keywords can be used as prefixes to specify the
    version of the required behavior/property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，可以使用`self`和`super`关键字作为前缀来指定所需行为/属性的版本。
- en: Design constraints
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计约束
- en: Using inheritance extensively in designing applications imposes certain constraints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时广泛使用继承会施加某些约束。
- en: For instance, suppose we define a subclass of `User` called `WebAppUser` that
    contains the extra acceptable behaviors and another subclass of `User` called
    `MobileAppUser` that contains the mobile app modules of `User`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们定义了一个名为`WebAppUser`的`User`子类，它包含额外的可接受行为，以及另一个名为`MobileAppUser`的`User`子类，它包含`User`的移动应用模块。
- en: In defining this inheritance hierarchy, we have already defined certain restrictions,
    not all of them desirable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义这个继承层次结构时，我们已经定义了某些限制，并非所有这些限制都是可取的。
- en: Singleness
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单一性
- en: In Swift, a subclass can inherit from only one superclass. From the preceding
    example, `User` can be either `WebAppUser` or `MobileAppUser`, but not both.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，子类只能从单个超类继承。从前面的例子中，`User`可以是`WebAppUser`或`MobileAppUser`，但不能同时是两者。
- en: Static
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态
- en: The inheritance hierarchy of an object is fixed at initiation while the object's
    type is selected and does not change with time. For example, the inheritance graph
    does not allow a `MobileAppUser` object to become a `WebAppUser` object while
    retaining the state of its `User` superclass (this can be achieved with the decorator
    pattern).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的继承层次结构在初始化时是固定的，而对象类型的选择不会随时间改变。例如，继承图不允许一个`MobileAppUser`对象在保留其`User`超类状态的同时成为`WebAppUser`对象（这可以通过装饰器模式实现）。
- en: Visibility
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可见性
- en: Whenever client code has access to an object, it generally has access to all
    the object's superclass data. Even if the superclass has not been declared public,
    the client can still cast the object to its superclass type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端代码可以访问一个对象时，它通常也可以访问该对象的所有父类数据。即使父类没有被声明为public，客户端仍然可以将对象转换为它的父类类型。
- en: Composite reuse
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组合复用
- en: The composite reuse principle is an alternative to inheritance. This technique
    supports polymorphism and code reuse by separating behaviors from the primary
    class hierarchy and including specific behavior classes as required in any class.
    This approach avoids the static nature of a class hierarchy by allowing behavior
    changes at runtime and permitting a subclass to implement behaviors selectively,
    instead of being restricted to the behaviors of its super classes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 组合复用原则是继承的替代方案。这种技术通过将行为从主要类层次结构中分离出来，并在任何类中按需包含特定的行为类，支持多态和代码复用。这种方法通过允许在运行时改变行为并允许子类有选择地实现行为，而不是仅限于其超类的行为，避免了类层次结构的静态性质。
- en: Issues and alternatives
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题与替代方案
- en: 'Implementation inheritance is controversial among OOP programmers and theoreticians.
    For instance, the authors, *Erich Gamma, John Vlissides, Ralph Johnson, and Richard
    Helm*, of the book, *Design Patterns: Elements of Reusable Object-Oriented Software*,
    advocate interface inheritance instead of implementation inheritance and recommend
    to prefer composition over inheritance.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承在面向对象程序设计和理论家中是有争议的。例如，《设计模式：可复用面向对象软件元素》一书的作者，*Erich Gamma, John Vlissides,
    Ralph Johnson, 和 Richard Helm*，提倡接口继承而不是实现继承，并建议优先考虑组合而不是继承。
- en: For example, the decorator pattern (as stated earlier) has been proposed to
    overcome the static nature of inheritance between classes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，装饰器模式（如前所述）已被提出以克服类之间继承的静态性质。
- en: Furthermore, the OOP community agrees that inheritance introduces unnecessary
    coupling and breaks encapsulation so modifications to the super classes can cause
    undesirable behavioral changes in subclasses.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，面向对象编程社区普遍认为继承引入了不必要的耦合并破坏了封装，因此对超类的修改可能导致子类中出现不希望的行为变化。
- en: In Swift, the usage of protocols and extensions is encouraged. Using protocols
    avoids the coupling problem because no implementation is shared. We will talk
    more about protocols and protocol extensions in the *POP* section of this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，鼓励使用协议和扩展。使用协议可以避免耦合问题，因为没有任何实现被共享。我们将在本章的 *POP* 部分中更多地讨论协议和协议扩展。
- en: When to inherit
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时继承
- en: 'There are circumstances where we do not have any other choice but subclassing.
    Here are some of the examples where subclassing is required:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们没有其他选择，只能进行子类化。以下是一些需要子类化的例子：
- en: 'When it is required by the APIs: For instance, many of Cocoa APIs require the
    use of classes and being controversial is not recommended. For instance, `UIViewController`
    has to be subclassed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 API 需要时：例如，许多 Cocoa API 需要使用类，并且不建议有争议。例如，`UIViewController` 必须被子类化。
- en: 'When we need to manage and communicate our value types between instances of
    other classes: For example, when we need to draw a custom view in a Cocoa class
    provided by another drawing class, we will need to communicate it between them.
    Using a value type in this case is not beneficial.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要在其它类的实例之间管理和传递我们的值类型时：例如，当我们需要在另一个绘图类提供的 Cocoa 类中绘制自定义视图时，我们将在它们之间进行通信。在这种情况下使用值类型是不利的。
- en: 'When we need to share an instance between multiple owners: Core Data persistence
    is an example. It can be very useful to have a synchronization mechanism across
    multiple owners while using Core Data. This will cause concurrency issues but
    we have to deal with them as we require mutable data.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要在多个所有者之间共享一个实例时：Core Data 持久化是一个例子。在使用 Core Data 时，拥有一个跨多个所有者的同步机制非常有用。这可能会引起并发问题，但我们必须处理它们，因为我们需要可变数据。
- en: 'When the lifetime of an instance is connected to external effects or we require
    a stable identity: Singletons and AppDelegate are some of the examples.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当实例的生命周期与外部效应相关联或我们需要一个稳定的身份时：单例和 AppDelegate 是一些例子。
- en: Polymorphism
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: 'Polymorphism means many forms. In general, the ability to take more than one
    form is called polymorphism. In an object-oriented language such as Swift, a polymorphic
    reference is one that can, over time, refer to instances of more than one class.
    Let''s examine an example of the iOS SDK, `UIView`. There are lots of `UIView`
    subclasses including the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 多态意味着多种形式。一般来说，能够采取多种形式的能力被称为多态。在面向对象的编程语言如 Swift 中，多态引用是指随着时间的推移，可以引用多个类的实例。让我们考察一个
    iOS SDK 的例子，`UIView`。有大量的 `UIView` 子类，包括以下内容：
- en: '`UILabel`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UILabel`'
- en: '`UITextField`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UITextField`'
- en: '`UIButton`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIButton`'
- en: 'We can declare a view that can take many forms such as the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明一个可以采取多种形式的视图，如下所示：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Polymorphism allows us to write a more generic code that works with families
    of objects rather than writing code for a specific class. In this example, regardless
    of which class we initiate, we can access all the properties and methods declared
    in the `UIView` class that are inherited by all the subclasses. For instance,
    we will be able to check the bounds and origins of any of them as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 多态允许我们编写更通用的代码，这些代码可以与对象家族一起工作，而不是为特定类编写代码。在这个例子中，无论我们启动哪个类，我们都可以访问所有继承自 `UIView`
    类的所有子类中声明的属性和方法。例如，我们可以检查任何一个的边界和原点，如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are able to refer to more than one type of objects; therefore, a polymorphic
    reference has both a static and dynamic type associated with it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够引用多种类型的对象；因此，多态引用既有静态类型，也有动态类型相关联。
- en: The static type is determined from the declaration of the object in the code.
    It is known at compile time and determines the set of valid types that the object
    can accept at runtime. This determination is made from an analysis of the inheritance
    graphs in the system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型是由代码中对对象的声明确定的。它在编译时已知，并决定了对象在运行时可以接受的有效类型集合。这种确定是通过分析系统中的继承图来进行的。
- en: The dynamic type of the reference may change over time during the application
    execution. In Swift, the runtime system keeps all polymorphic references automatically
    tagged with their dynamic type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序执行过程中，引用的动态类型可能会随时间改变。在Swift中，运行时系统自动将所有多态引用标记为它们的动态类型。
- en: Dynamic binding
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态绑定
- en: Associating a method call to the code to be executed is called binding. As opposed
    to static binding where the code associated with the method call is bound during
    the compile time, dynamic binding means that the code associated with a given
    method call is not known and will be determined during runtime.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法调用与要执行的代码关联起来称为绑定。与在编译时绑定与方法调用相关联的代码的静态绑定相反，动态绑定意味着与给定方法调用相关联的代码在编译时是未知的，将在运行时确定。
- en: Dynamic binding is associated with polymorphism and inheritance because a method
    call associated with a polymorphic reference may depend on the dynamic type of
    that reference.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 动态绑定与多态和继承相关联，因为与多态引用相关联的方法调用可能依赖于该引用的动态类型。
- en: For instance, our view's static type is `UIView` and its dynamic type may be
    `UILabel`, `UITextField`, or `UIButton`. Let's suppose that some of the methods
    in `UIView` are overridden for `UIButton`. When we call those methods, runtime
    will dynamically bind the method that needs to be called.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们视图的静态类型是`UIView`，其动态类型可能是`UILabel`、`UITextField`或`UIButton`。假设`UIView`中的一些方法被`UIButton`重写。当我们调用这些方法时，运行时会动态绑定需要调用的方法。
- en: OOP design principles
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计原则
- en: In this section, we will look at some of the problems with the OOP approach
    and OOP solutions and FP solutions to these problems.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨面向对象（OOP）方法及其解决方案以及针对这些问题的函数式编程（FP）解决方案中的一些问题。
- en: 'In general, OOP is being criticized in the following manner:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，面向对象（OOP）被以下方式批评：
- en: Binding a data structure to behavior is a mechanism of state encapsulation that
    hides the underlying problem instead of solving it.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据结构绑定到行为是状态封装的一种机制，它隐藏了底层问题而不是解决问题。
- en: A great deal of effort goes into making inheritance possible. Ironically, object-orientated
    patterns themselves favor composition over inheritance. Ultimately, in handling two
    responsibilities—subtyping and reusing—inheritance is not good with either subtyping
    or reusing.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使继承成为可能，投入了大量的努力。讽刺的是，面向对象的模式本身更倾向于组合而不是继承。最终，在处理两个职责——子类型化和重用——时，继承在子类型化或重用方面都不是很好。
- en: 'OOP solutions to these problems include SOLID and DDD principles. The following
    are the SOLID principles:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的面向对象解决方案包括SOLID原则和领域驱动设计（DDD）原则。以下为SOLID原则：
- en: The **single responsibility principle** (**SRP**)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（SRP）'
- en: The **open/closed principle** (**OCP**)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**（OCP）'
- en: The **Liskov substitution principle** (**LSP**)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**（LSP）'
- en: The **interface segregation principle** (**ISP**)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（ISP）'
- en: The **dependency inversion principle** (**DIP**)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（DIP）'
- en: '**Domain-driven Design** (**DDD**) principles are proposed to solve OOP problems.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（DDD）原则被提出以解决面向对象（OOP）问题。'
- en: 'Also, FP addresses these problems by the following distinguishing characteristics:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，函数式编程（FP）通过以下区分特征来解决这些问题：
- en: Explicit management of state is avoided through **immutability**
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**不可变性**避免显式管理状态。
- en: '**Explicit return values** are favored over implicit side-effects'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更倾向于**显式返回值**而不是隐式副作用。
- en: Powerful **composition** facilities promote reuse without compromising encapsulation
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的**组合**功能在不损害封装性的情况下促进重用。
- en: The culmination of these characteristics is a more **declarative** paradigm
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些特征的最终结果是更**声明式**的范式。
- en: SRP
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SRP
- en: The SRP states that every class should have a single responsibility where a
    responsibility is defined as a reason to change.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SRP指出，每个类都应该有一个单一职责，其中职责被定义为改变的理由。
- en: This principle supports the anti-pattern where large classes play multiple roles.
    Classes can be large for a few reasons. A core principle of OOP is the binding
    of the data structure to behavior. The problem is that optimizing for data structure
    encapsulation not only weakens composition characteristics, but also hides the
    underlying problem of explicit state. As a result, OOP code typically contains
    many data structures with relatively few functions per data structure. Adding
    methods to a class brings pressure on the SRP and reducing the number of methods
    can either make the data structure difficult to compose or altogether useless.
    Furthermore, the simple syntactical cost of declaring a class often compels programmers
    to marginalize.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则支持反模式，其中大型类扮演多个角色。类可以因为几个原因而变得很大。面向对象编程（OOP）的一个核心原则是将数据结构绑定到行为上。问题是，优化数据结构封装不仅会削弱组合特性，还会隐藏显式状态的根本问题。因此，OOP代码通常包含许多数据结构，每个数据结构中的函数相对较少。向类中添加方法会给SRP（单一职责原则）带来压力，而减少方法数量可能会使数据结构难以组合，或者完全无用。此外，声明类的简单语法成本经常迫使程序员将其边缘化。
- en: The FP counterpart
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程的对应原则
- en: In FP, the fundamental unit of abstraction is the function. Given that a function
    has a single output, functions naturally have a single responsibility. One could
    certainly define an arbitrarily generic function, though this would not be intuitive.
    Moreover, functions are syntactically less resource-hungry.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，抽象的基本单位是函数。鉴于函数只有一个输出，函数自然只有一个职责。当然可以定义一个任意通用的函数，但这并不直观。此外，函数在语法上更节省资源。
- en: OCP
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OCP（开闭原则）
- en: The OCP states that software entities should be open for extension but closed
    for modification.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: OCP指出，软件实体应该对扩展开放，但对修改封闭。
- en: 'The ambiguity of this statement can be resolved through two variations of the
    principle:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陈述的不确定性可以通过该原则的两个变体来解决：
- en: Existing classes should be modified only in order to correct bugs. This restriction
    delivers the closed aspect of the principle. The open aspect is delivered through
    implementation inheritance or, in other words, inheritance with the goal of reusing
    rather than subtyping.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应仅修改现有类以纠正错误。这种限制提供了原则的封闭方面。开放方面是通过实现继承或换句话说，通过重用而不是子类型化的目标来实现的。
- en: Openness through polymorphism, which by definition also provides for closure,
    as extensibility is supported through substitution rather than modification. Unfortunately,
    substitution often leads to accidental complexity, which must be addressed by
    yet another principle—the LSP.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多态实现开放性，这根据定义也提供了封闭性，因为可扩展性是通过替换而不是修改来支持的。不幸的是，替换往往会导致意外的复杂性，这必须通过另一个原则——LSP来解决。
- en: The primary utility of the OCP is the confinement of cascading changes while
    providing extensibility. This is achieved by designing for extensibility and prohibiting
    changes to existing entities. Extensibility is attained by fancy tricks with abstract
    classes and virtual functions. Closure is achieved by encapsulation or rather
    by the hiding of moving parts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: OCP的主要效用是在提供可扩展性的同时限制级联变化。这是通过为可扩展性进行设计和禁止对现有实体进行更改来实现的。通过使用抽象类和虚拟函数的巧妙技巧来实现可扩展性。通过封装或更确切地说，通过隐藏移动部分来实现封闭性。
- en: The FP counterpart
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程的对应原则
- en: In FP, functions can be substituted at will and as such, there is no need to
    design for extensibility. Functionality requiring parameterization is naturally
    declared as such. Instead of inventing a concept of a virtual method and inheritance,
    one can rely on an existing, elementary concept—the higher-order function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，函数可以随意替换，因此无需为可扩展性进行设计。需要参数化的功能自然地被声明为这样的功能。而不是发明一个虚拟方法和继承的概念，可以依赖一个现有的、基本的概念——高阶函数。
- en: LSP
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LSP（里氏替换原则）
- en: The LSP states that objects in a program should be replaceable with instances
    of their subtypes without altering the correctness of that program.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: LSP指出，程序中的对象应该可以用其子类型实例替换，而不会改变该程序的正确性。
- en: The LSP is essentially a restricted instance of subtyping, which aims to guarantee
    semantic portability across class hierarchies. Portability is achieved by ensuring
    that whatever is true of a base type is also true of all subtypes. Subclasses
    must not strengthen preconditions. They must accept all input and initial states
    that the base class accepts and subclasses must not weaken post-conditions. Behavioral
    expectations declared by the super class must be met by the subclass. These characteristics
    cannot be enforced by the type system alone.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: LSP本质上是一种受限的子类型实例，旨在保证跨类层次结构的语义可移植性。可移植性是通过确保对基类型的所有断言对所有子类型都成立来实现的。子类不得加强前置条件。它们必须接受基类接受的所有输入和初始状态，并且子类不得弱化后置条件。超类声明的行为期望必须由子类满足。这些特性不能仅通过类型系统强制执行。
- en: The LSP as a relation of inheritance is thus deceptive, hence the need for a
    compensating principle. As such, the need for this principle demonstrates a pitfall
    in subtype (inclusion-based) polymorphism. Implicit factoring by class hierarchy
    imposes the needless inclusion of restrictions and requires complex principles
    to place a boundary on accidental complexity.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为继承关系的一部分，LSP因此具有误导性，因此需要补偿原则。因此，这一原则的需要证明了子类型（基于包含的）多态的一个陷阱。通过类层次结构隐式分解强加不必要的限制，并需要复杂的原则来对偶然复杂性设置边界。
- en: The FP counterpart
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FP对应原则
- en: Functional languages favor parametric polymorphism with bounded quantification,
    thereby avoiding some of the pitfalls of inheritance. Informally, functional languages
    emphasize substitutability and de-emphasize implementation reuse as reuse is better
    achieved through composition. Most ambitions of the LSP are effectively trivial
    in FP languages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言倾向于使用有界量词的参数多态，从而避免了继承的一些陷阱。非正式地说，函数式语言强调可替换性，并淡化实现重用，因为重用通过组合实现得更好。在函数式语言中，LSP的大多数雄心壮志实际上都是微不足道的。
- en: ISP
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ISP
- en: The ISP states that many client-specific interfaces are better than one general-purpose
    interface. In other words, no client should be forced to depend on methods that
    it does not use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ISP原则指出，许多针对特定客户端的接口比一个通用接口更好。换句话说，不应该强迫任何客户端依赖它不使用的功能。
- en: In essence, ISP is a restatement of the SRP for interfaces and reflects the
    same underlying problem—the difficulty of balancing responsibility assignment,
    composition, and encapsulation in object-oriented design. On the one hand, it
    is desirable to encapsulate; on the other hand, it is desirable to compose. Furthermore,
    the problem with employing the ISP alone is that it doesn't directly protect against
    large classes and in some ways hides the problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，ISP是对SRP（单一职责原则）在接口上的重申，反映了相同的潜在问题——在面向对象设计中平衡职责分配、组合和封装的困难。一方面，封装是可取的；另一方面，组合也是可取的。此外，仅采用ISP的问题在于它并不能直接保护大型类，并且在某些方面掩盖了问题。
- en: The FP counterpart
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FP对应原则
- en: Functional programming reduces the need for encapsulation by eschewing state
    and breeds composition at the core. There is no augmented concept of role-based
    interfaces because function roles are explicit at the onset. Functions are segregated
    by default.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程通过摒弃状态来减少封装的需求，并在核心处培育组合。没有基于角色的接口增强概念，因为函数角色从一开始就是明确的。函数默认是隔离的。
- en: DIP
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DIP
- en: The DIP states that one should depend upon abstractions. Do not depend upon
    concretions. In other words, high-level modules should be decoupled from low-level
    modules through abstractions. This principle states that code should be structured
    around the problem domain, and the domain should declare dependencies on required
    infrastructure as protocols. Dependencies thus point inward to the domain model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: DIP原则指出，应该依赖于抽象，而不是具体实现。换句话说，高级模块应该通过抽象与低级模块解耦。这一原则表明代码应该围绕问题域进行结构化，而领域应该通过协议声明对所需基础设施的依赖。因此，依赖指向领域模型。
- en: The reason that this principle is an inversion is because typical architectures
    promoted by OOP (via layer architecture) exhibit dependency graphs where high-level
    modules consume low-level modules directly. Initially, this dependency graph seems
    natural as, in expressing domain models in code, one inevitably depends upon the
    constructs of the language. Procedural programming allows dependencies to be encapsulated
    by procedures.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则之所以是倒置的，是因为典型的OOP（通过分层架构）推广的架构表现出依赖图，其中高级模块直接消耗低级模块。最初，这个依赖图看起来很自然，因为在用代码表达领域模型时，不可避免地依赖于语言的构造。过程式编程允许通过过程封装依赖关系。
- en: Subtype polymorphism defers procedure implementation. Unfortunately, the use
    of protocols is often overlooked to express domain dependencies in OOP implementations.
    Given that infrastructure code is typically more voluminous, the focus of the
    code drifts away from the domain. DDD was devised in part to balance this drift.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型多态推迟了过程实现。不幸的是，在OOP实现中，经常忽视使用协议来表示领域依赖。鉴于基础设施代码通常更为庞大，代码的关注点会偏离领域。DDD部分是为了平衡这种偏离而设计的。
- en: The FP counterpart
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FP的对应物
- en: The declarative and side-effect-free nature of FP provides dependency inversion.
    In OOP, high-level modules depend on infrastructure modules primarily to invoke
    side-effects. In FP, side-effects are more naturally triggered in response to
    domain behavior as opposed to being directly invoked by domain behavior. Thus,
    dependencies become not merely inverted, but pushed to outer layers altogether.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）的声明性和无副作用特性提供了依赖倒置。在面向对象编程（OOP）中，高级模块主要依赖于基础设施模块来调用副作用。在FP中，副作用更自然地是在响应领域行为时触发的，而不是直接由领域行为触发的。因此，依赖关系不仅被倒置，而且完全推到了外部层。
- en: DDD
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DDD
- en: DDD is an approach to software development for complex needs by connecting the
    implementation to an evolving model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是一种通过将实现与不断发展的模型连接起来，针对复杂需求进行软件开发的方法。
- en: Concepts
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概念
- en: 'Concepts of the model include the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的概念包括以下内容：
- en: '**Context**: The setting in which a word or statement appears that determines
    its meaning.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：一个词或陈述出现的背景，决定了其含义。'
- en: '**Domain**: An ontology, influence, or activity. The subject area to which
    the user applies a program is the domain of the software.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域**：一个本体、影响或活动。用户将程序应用于的主题领域是软件的领域。'
- en: '**Model**: A system of abstractions that describes selected aspects of a domain
    and can be used to solve problems related to that domain.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：一个抽象系统，描述了领域的选定方面，并可用于解决与该领域相关的问题。'
- en: '**Ubiquitous language**: A language structured around the domain model and
    used by all team members to connect all the activities of the team with the software.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用语言**：一种围绕领域模型构建的语言，并由所有团队成员使用，以将团队的所有活动与软件联系起来。'
- en: Premise
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前提
- en: 'The premise of DDD is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的前提如下：
- en: Placing the project's primary focus on the core domain and domain logic
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目的重点放在核心领域和领域逻辑上
- en: Basing complex designs on a model of the domain
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在领域模型的基础上构建复杂设计
- en: Initiating a creative collaboration between technical and domain experts to
    iteratively refine a conceptual model that addresses particular domain problems
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在技术专家和领域专家之间启动创造性合作，以迭代地完善一个解决特定领域问题的概念模型。
- en: Building blocks
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建模块
- en: In DDD, there are artifacts to express, create, and retrieve domain models that
    are explored from an FP perspective in the following sections.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在DDD中，有一些用于表达、创建和检索领域模型的工件，以下几节将从FP的角度进行探讨。
- en: Aggregate
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚合
- en: A collection of objects that are bound together by a root entity, otherwise
    known as an aggregate root. The aggregate root guarantees the consistency of changes
    being made within the aggregate by forbidding external objects from holding references
    to its members.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一组由根实体绑定在一起的对象，也称为聚合根。聚合根通过禁止外部对象持有其成员的引用，确保了在聚合内进行的更改的一致性。
- en: The concept of the aggregate remains in FP; however, it is not represented in
    terms of a class. Instead, it can be expressed as a structure, including a set
    of aggregate states, initial state, set of commands, set of events, and function-mapping
    the set of commands to the set of events given a state. Cohesion is provided by
    a module mechanism.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合的概念在FP中仍然存在；然而，它不是用类来表示的。相反，它可以表示为一个结构，包括一组聚合状态、初始状态、一组命令、一组事件以及将一组命令映射到给定状态的一组事件的功能。模块机制提供了内聚性。
- en: Immutable value objects
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不可变值对象
- en: Immutable value objects are objects that contain attributes but have no conceptual
    identity. They should be treated as immutable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变值对象是包含属性但没有概念身份的对象。它们应该被视为不可变的。
- en: In a previous chapter, we saw that Swift provides immutable product and sum
    types with auto-implemented structural equality, which addresses this pattern
    trivially. Heavy reliance on state in OOP makes references first-class citizens
    rather than the structure of the data itself.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了 Swift 提供了具有自动实现的结构相等性的不可变产品类型和求和类型，这可以简单地解决这个问题。在面向对象编程中，对状态的过度依赖使得引用成为一等公民，而不是数据结构本身的结构。
- en: Domain events
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 领域事件
- en: A domain event is a domain object that defines an event.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件是定义事件的领域对象。
- en: Domain events are powerful mechanisms to keep domain models encapsulated. This
    can be accomplished by allowing various observers from outer layers to register
    for a domain event (`signal`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件是保持领域模型封装的强大机制。这可以通过允许外部层中的各种观察者注册领域事件（“信号”）来实现。
- en: The problem with domain events in OOP is that the typical implementation is
    complex and relies on side-effects. Event observations are typically declared
    in the composition root and thus, it is not immediately obvious from the perspective
    of the producer which observers will be invoked. In FP, a domain event is simply
    a value returned by a function in an aggregate. Observers can be explicitly registered
    as filters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中领域事件的问题在于，典型的实现复杂且依赖于副作用。事件观察通常在组合根中声明，因此，从生产者的角度来看，并不立即明显哪些观察者将被调用。在函数式编程（FP）中，领域事件是聚合中函数返回的一个值。观察者可以显式注册为过滤器。
- en: Furthermore, FRP can handle domain events very effectively. On the other hand,
    returning domain events from aggregate methods in OOP is prohibitive due to the
    lack of union types and pattern matching.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，函数式响应编程（FRP）可以非常有效地处理领域事件。另一方面，由于缺乏联合类型和模式匹配，在面向对象编程（OOP）中从聚合方法返回领域事件是受限制的。
- en: Intention-revealing interface
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 意图揭示接口
- en: In imperative OOP code, intent leaks through side-effects and focuses on the
    how rather than the what. Always having to bind behavior to the data structure
    can also be problematic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式面向对象代码中，意图通过副作用泄露，并关注“如何”而不是“什么”。总是需要将行为绑定到数据结构也可能有问题。
- en: As FP is more declarative, function names and interfaces tend to be more focused
    on intent rather than the the underlying mechanics. In addition, the interfaces
    of side-effect-free functions are by nature more revealing because behavior is
    made explicit through the return value. As a result, in addition to the purely
    linguistic benefit of naming with intent, intent is also encoded by the type system.
    This is not to say that expressing intent is effortless in FP—only that it is
    better supported by the FP paradigm.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式编程更声明式，函数名称和接口往往更多地关注意图而不是底层机制。此外，无副作用函数的接口本质上更具有揭示性，因为行为通过返回值被明确表达。因此，除了命名具有意图的纯粹语言优势外，意图还通过类型系统进行编码。这并不是说在函数式编程中表达意图是不费力的——只是说它得到了函数式范式的更好支持。
- en: Side-effect-free functions
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无副作用函数
- en: Side-effects are in direct opposition to encapsulation, yet all too often they
    are the most useful tools.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用与封装直接对立，但它们往往是最有用的工具。
- en: Unlike imperative programming, FP avoids side-effects. This pattern is yet another
    example of how a well-crafted object-oriented design converges upon a functional
    style.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令式编程不同，函数式编程避免了副作用。这个模式又是另一个例子，说明了精心设计的面向对象设计如何收敛到函数式风格。
- en: Assertions
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断言
- en: Like many patterns rooted in imperative object-oriented design, assertions claim
    to use implicit side-effects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多根植于命令式面向对象设计的模式一样，断言声称使用隐式副作用。
- en: As with intention-revealing interfaces, assertions in FP languages are automatically
    encoded in the return type of a function in addition to the function name.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与意图揭示接口一样，函数式编程语言中的断言除了函数名称外，还自动编码在函数的返回类型中。
- en: Conceptual contours
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概念轮廓
- en: Conceptual contours emerge when domain knowledge is spread throughout the code
    to a sufficient degree. In OOP, this can be achieved by carefully following the
    principles of DDD.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当领域知识在代码中传播到一定程度时，概念轮廓就会出现。在面向对象编程中，这可以通过仔细遵循领域驱动设计（DDD）的原则来实现。
- en: In FP, conceptual contours emerge more readily, once again due to the declarative
    and side-effect-free nature of the paradigm. Specifically, clients of the domain
    model can rely on cohesive functionality attained with composition and yet still
    have access to constituents without breaking encapsulation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，概念轮廓更容易出现，这再次归因于范式声明性和无副作用的特点。具体来说，领域模型客户端可以依赖通过组合获得的内聚功能，同时仍然可以访问组成部分而不破坏封装。
- en: Closure of operations
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作的关闭
- en: Closure of operations illustrates yet another example of coercing composition
    and structure upon object-oriented designs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的关闭说明了将组合和结构强加于面向对象设计的另一个例子。
- en: Essentially, closure simplifies reasoning about a problem by restricting the
    domain of the discourse. The example of a functional implementation of a domain
    exhibits this characteristic at a fundamental level. The operation of applying
    a domain event is closed under the set of domain states. In terms of persistence,
    this naturally translates to event-sourcing but also supports persistence in a
    key-value store or ORM with no required modification.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，关闭操作通过限制讨论的范围来简化对问题的推理。一个领域实现的函数示例在基本层面上展示了这一特征。应用领域事件的操作在领域状态集合下是封闭的。在持久性的方面，这自然地转化为事件源，但也支持在无需修改的情况下使用键值存储或ORM进行持久化。
- en: Declarative design
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明式设计
- en: The overall intent of the aforementioned patterns is to cultivate a declarative
    design. As witnessed, FP is inherently more declarative and therefore more accommodating
    in this regard. Through declarative design, we can distill distinguishing characteristics
    of the domain better and reduce or eliminate coupling to orthogonal concerns of
    infrastructure. Consequently, re-usability, testability, correctness, maintainability,
    and productivity are tremendously enhanced.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提到的模式的整体意图是培养声明式设计。如所见，FP天生更具声明性，因此在这方面更具适应性。通过声明式设计，我们可以更好地提炼领域的区分特征，并减少或消除对基础设施正交关注点的耦合。因此，可重用性、可测试性、正确性、可维护性和生产力得到了极大的提升。
- en: Protocol-oriented programming (POP)
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向协议编程（POP）
- en: POP encourages us to develop protocols and extend them instead of classes and
    inheritance. POP is new in the Objective-C and Swift development community, but
    what it provides is not very different from the concept of `Abstract` classes
    in languages such as Java and C# and `pure-virtual` functions in C++.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: POP鼓励我们开发协议并扩展它们，而不是类和继承。在Objective-C和Swift开发社区中，POP是一个新的概念，但它提供的内容与Java和C#等语言中的`Abstract`类概念以及C++中的`pure-virtual`函数并没有太大的区别。
- en: In Swift, classes, structs, and enumerations can conform to protocols. This
    makes protocols more usable because inheritance does not work for structs and
    enumerations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，类、结构和枚举可以符合协议。这使得协议更加可用，因为继承对结构和枚举不起作用。
- en: POP paradigms
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POP范式
- en: 'In this section, we will explore POP paradigms. To start with, we will look
    at an example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨POP范式。首先，我们将查看一个示例：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This protocol defines two functions to be implemented by the struct, enumeration,
    or classes that need to conform to this protocol.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议定义了两个需要由符合此协议的结构、枚举或类实现的功能。
- en: Protocol composition
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议组合
- en: Protocol composition allows types to conform to more than one protocol. This
    is one of the many advantages that POP has over OOP. With OOP, a class can have
    only one superclass, which can lead to very monolithic super classes. With POP,
    we are encouraged to create multiple smaller protocols with very specific requirements.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 协议组合允许类型符合多个协议。这是POP相对于OOP的许多优点之一。在OOP中，一个类只能有一个超类，这可能导致非常单调的超类。在POP中，我们被鼓励创建多个具有非常具体要求的小型协议。
- en: Protocol extensions
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议扩展
- en: 'Protocol extensions are one of the most important parts of the POP paradigm.
    They allow us to add functionality to all types that conform to a given protocol.
    Without protocol extensions, if we had common functionality that was necessary
    for all types that conformed to a particular protocol, then we would need to add
    that functionality to each type. This would lead to large amounts of duplicated
    code. The following example extends our protocol by adding a `logout` method and
    its implementation; thus any struct, enum or class that conforms to `UserProtocol`
    will have the `logout` functionality:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Protocol inheritance
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Protocol inheritance is where one protocol can inherit the requirements from
    one or more other protocols, as shown in the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`MobileAppUserProtocol` inherits from `UserProtocol` so it will have all the
    defined and extended methods.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Associated types
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Associated types can be used to make our protocols work with generic types:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Conforming to a protocol
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code presents an example of protocol conformance with associated
    type usage:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can create a new mobile user as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: POP minimizes the inheritance and subclassing necessities by enabling us to
    conform to protocols and extend them with default implementations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Functional Reactive Programming (FRP)
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming avoids immutability and side-effects. In some circumstances,
    the application should react to dynamic value/data changes. For instance, we may
    need to change the user interface of an iOS application to reflect received data
    from a backend or database system. How would we do this without states and mutable
    values?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming captures these dynamic values only indirectly, through
    state and mutations. The complete history (past, present, and future) has no first-class
    representation. Moreover, only discretely-evolving values can be (indirectly)
    captured as the imperative paradigm is temporally discrete.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: FRP provides a way to handle dynamic value changes while still retaining the
    FP style. FRP, as its name suggests, is a combination of FP and reactive programming.
    Reactive programming makes it possible to deal with certain data types that represent
    values over time. These data types are called time flow or event streams in different
    functional programming languages. Computations that involve these changing-over-time/evolving
    values will themselves have values that change over time. FRP captures these evolving
    values directly and has no difficulty with continuously evolving values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, FRP can be presented as the following set of principles/rules:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Data types or dynamic/evolving over time values should be first-class citizens.
    We should be able to define, combine, and pass them to functions and return them
    from functions.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types should be built from a few primitives such as constant/static values
    and time with sequential and parallel combinations. The n behaviors are combined
    by applying an n-ary function to static values continuously over time.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型应该由一些原始类型如常量/静态值和时间通过顺序和并行组合构建。n个行为通过在时间上连续应用一个n元函数到静态值来组合。
- en: To account for discrete phenomena, we should have additional event types, each
    of which has a stream (finite or infinite) of occurrences. Each occurrence has
    an associated time and value.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了考虑离散现象，我们应该有额外的事件类型，每种类型都有一个（有限或无限）发生流。每个发生都与一个相关的时间和值相关联。
- en: To come up with the compositional vocabulary out of which all behaviors and
    events can be built, play with some examples. Keep deconstructing into pieces
    that are more general/simple.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了构建所有行为和事件都可以组成的组合词汇，可以通过一些示例进行尝试。持续将它们分解成更通用/简单的部分。
- en: 'We should be able to compose the whole model, using the technique of denotational
    semantics:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够使用指称语义技术来构建整个模型：
- en: Each type has a corresponding simple and precise mathematical type of meaning
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种类型都有一个对应简单且精确的数学类型意义
- en: Each primitive and operator has a simple and precise meaning as a function of
    the meanings of the constituents
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个原始类型和操作符作为构成元素意义的函数具有简单且精确的意义
- en: Building blocks of FRP
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FRP的构建块
- en: It is important to understand FRP building blocks to be able to understand FRP.
    The following sections explain these building blocks with one of the great FRP
    libraries for the Cocoa framework called ReactiveCocoa developed by GitHub. ReactiveCocoa
    was developed for Objective-C and, as of version 3.0, all major feature development
    is concentrated on the Swift API.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 理解FRP构建块对于理解FRP至关重要。以下章节将使用GitHub上为Cocoa框架开发的优秀FRP库ReactiveCocoa来解释这些构建块。ReactiveCocoa是为Objective-C开发的，截至版本3.0，所有主要功能开发都集中在Swift
    API上。
- en: Signals
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号
- en: 'Signals are event streams that send values over time that are already in progress.
    We can imagine them as pipes that send values without knowing about the previous
    values that they sent or future values that they are going to send. Signals can
    be composed, combined, and chained declaratively. Signals can unify all Cocoa
    common patterns for asynchrony and event handling:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是事件流，在时间上发送已经进行中的值。我们可以想象它们为发送值而不了解它们之前发送的值或将要发送的值的管道。信号可以声明性地组合、合并和链式连接。信号可以统一所有Cocoa的异步和事件处理常见模式：
- en: Delegate methods
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托方法
- en: Callback blocks
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调块
- en: Notifications
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知
- en: Control actions and responder chain events
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制动作和响应链事件
- en: Future and Promises
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来和承诺
- en: '**Key-value observing** (**KVO**)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值观察**（**KVO**）'
- en: As all of these mechanisms can be represented in the same way, it is easy to
    declaratively chain and combine them together.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些机制都可以以相同的方式表示，因此它们很容易声明性地链式连接和组合在一起。
- en: ReactiveCocoa represents signals as `Signal`. Signals can be used to represent
    notifications, user input, and so on. As work is performed or data is received,
    events are sent on the signal, which pushes them out to any observers. All observers
    see the events at the same time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveCocoa将信号表示为`Signal`。信号可以用来表示通知、用户输入等。随着工作的进行或数据的接收，事件被发送到信号上，并将它们推送到任何观察者。所有观察者同时看到这些事件。
- en: Users must observe a signal in order to access its events. Observing a signal
    does not trigger any side-effects. In other words, signals are entirely producer-driven
    and push-based, and observers cannot have any effect on the signal's lifetime.
    While observing a signal, the user can only evaluate the events in the same order
    as they are sent on the signal. There is no random access to values of a signal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须观察一个信号才能访问其事件。观察信号不会触发任何副作用。换句话说，信号完全是生产者驱动和基于推送的，观察者不能对信号的生命周期有任何影响。在观察信号时，用户只能以与信号上发送的顺序相同的顺序评估事件。信号值没有随机访问。
- en: 'Signals can be manipulated by applying the following operations:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下操作来操作信号：
- en: '`map`, `filter`, and `reduce` to manipulate a single signal'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`map`、`filter`和`reduce`来操作单个信号
- en: '`zip` to manipulate multiple signals at once'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`zip`同时操作多个信号
- en: These operations can be applied only on the next events of a signal.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作只能应用于信号的下一个事件。
- en: 'The lifetime of a signal may consist of a various number of next events, followed
    by one terminating event, which may be any one of the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 信号的生命周期可能由多个后续事件组成，之后跟随一个终止事件，该事件可能是以下之一：
- en: Failed
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败
- en: Completed
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成
- en: Interrupted
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断
- en: Terminating events are not included in the signal's values and they should be
    handled specially.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 终止事件不包括在信号的值中，并且应该特别处理。
- en: Pipes
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道
- en: A `signal` that can be manually controlled is called `pipe`. In ReactiveCocoa,
    we can create a `pipe` by calling `Signal.pipe()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以手动控制的`signal`称为`pipe`。在ReactiveCocoa中，我们可以通过调用`Signal.pipe()`来创建`pipe`。
- en: The `pipe` method returns `signal` and `observer`. The `signal` can be controlled
    by sending events to the observer.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe`方法返回`signal`和`observer`。`signal`可以通过向`observer`发送事件来控制。'
- en: Signal producers
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号生产者
- en: A signal producer creates signals and performs side-effects. `SignalProducer`
    can be used to represent operations or tasks such as network requests, where each
    invocation of `start()` will create a new underlying operation and allow the caller
    to observe the result. Unlike a signal, no work is started (and thus no events
    are generated) until an observer is attached, and the work is restarted for each
    additional observer.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 信号生产者创建信号并执行副作用。`SignalProducer`可用于表示操作或任务，例如网络请求，每次调用`start()`都会创建一个新的底层操作，并允许调用者观察结果。与信号不同，直到附加观察者，并且为每个额外的观察者重新启动工作之前，不会开始工作（因此不会生成事件）。
- en: Starting a signal producer returns a disposable that can be used to interrupt/cancel
    the work associated with the produced signal.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 启动信号生产者返回一个可丢弃的对象，可以用来中断/取消与产生的信号相关的工作。
- en: Signal producers can also be manipulated via operations such as map, filter,
    and reduce. Every signal operation can be *lifted* to operate upon signal producers
    instead, using the `lift` method.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 信号生产者也可以通过诸如map、filter和reduce之类的操作进行操作。每个信号操作都可以通过`lift`方法提升为操作信号生产者。
- en: Buffers
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区
- en: A buffer is an optionally bounded queue for events. A buffer replays these events
    when new signals are created from `SignalProducer`. A `buffer` is created by calling `SignalProducer.buffer()`.
    Similar to `pipe`, the method returns `observer`. Events sent to this observer
    will be added to the queue. If the buffer is already at capacity when a new value
    arrives, the oldest value will be dropped to make room for it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是一个可选有界的事件队列。当从`SignalProducer`创建新的信号时，缓冲区会回放这些事件。通过调用`SignalProducer.buffer()`创建`buffer`。类似于`pipe`，该方法返回`observer`。发送到此观察者的事件将被添加到队列中。如果缓冲区在新的值到达时已满，则最旧的价值将被丢弃以腾出空间。
- en: Observers
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者
- en: An observer is anything that observes or is capable of observing `events` from
    a `signal`. Observers can be implicitly created using the callback-based versions
    of the `Signal.observe()` or `SignalProducer.start()` methods.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者是指观察或能够从`signal`中观察`events`的任何东西。可以使用基于回调的`Signal.observe()`或`SignalProducer.start()`方法的版本隐式创建观察者。
- en: Actions
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作
- en: An action will do some work when executed with an input. Actions are useful
    in performing side-effecting work upon user interaction, such as when a button
    is clicked. Actions can also be automatically disabled based on a property, and
    this disabled state can be represented in a user interface by disabling any controls
    associated with the action.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当与输入执行时，动作将执行一些工作。动作在执行副作用工作方面很有用，例如当按钮被点击时。动作还可以根据属性自动禁用，并且这种禁用状态可以通过禁用与动作相关的任何控件在用户界面中表示。
- en: Properties
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: A property stores a value and notifies observers about future changes to that
    value. The current value of a property can be obtained from the value getter.
    The producer getter returns a signal producer that will send the property's current
    value, followed by all changes over time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 属性存储一个值，并通知观察者该值的未来更改。可以从值获取器中获取属性的当前值。生产者获取器返回一个信号生产者，该生产者将发送属性的当前值，然后是随时间的变化。
- en: Disposables
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可丢弃的
- en: A disposable is a mechanism for memory management and cancellation. When starting
    a signal producer, a disposable will be returned. This disposable can be used
    by the caller to cancel the work that has been started, clean up all temporary
    resources, and then send a final Interrupted event with regard to the particular
    signal that was created.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可丢弃的是一种内存管理和取消的机制。在启动信号生产者时，将返回一个可丢弃的对象。调用者可以使用此可丢弃对象来取消已启动的工作，清理所有临时资源，然后针对创建的特定信号发送一个最终的Interrupted事件。
- en: Schedulers
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度器
- en: A scheduler is a serial execution queue to perform work or deliver results upon.
    `Signals` and `signal producers` can be ordered to deliver events on a specific
    scheduler. `Signal producers` can additionally be ordered to start their work
    on a specific scheduler.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器是一个串行执行队列，用于执行工作或交付结果。`Signals`和`signal producers`可以按顺序在特定调度器上交付事件。`Signal
    producers`还可以按顺序在特定调度器上开始工作。
- en: Schedulers are similar to the **Grand Central Dispatch** (**GCD**) queues, but
    schedulers support cancellation via disposables and always execute serially. With
    the exception of `ImmediateScheduler`, schedulers do not offer synchronous execution.
    This helps avoid deadlocks and encourages the use of `signal` and `signal producer`
    operations instead of blocking work.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器与**Grand Central Dispatch**（**GCD**）队列类似，但调度器支持通过可处置对象进行取消，并且始终按顺序执行。除了`ImmediateScheduler`之外，调度器不提供同步执行。这有助于避免死锁，并鼓励使用`signal`和`signal
    producer`操作而不是阻塞工作。
- en: Schedulers are also somewhat similar to `NSOperationQueue`, but schedulers do
    not allow tasks to be reordered or depend on one another.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器也与`NSOperationQueue`有些类似，但调度器不允许任务重新排序或相互依赖。
- en: An example
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个例子
- en: 'Let''s suppose that we have an outlet and we want to observe its changes:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个输出端口，我们想观察其变化：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can create `SignalProducer` as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建`SignalProducer`如下：
- en: '[PRE18]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `rac_textSignal` method is a ReactiveCocoa extension for `UITextField` that
    can be used to create the signal producer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`rac_textSignal`方法是一个用于`UITextField`的ReactiveCocoa扩展，可以用来创建信号生产者。'
- en: 'Then, we can start our `SignalProducer` as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样开始我们的`SignalProducer`：
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will print any changes in our `textField` to the console.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将`textField`中的任何更改打印到控制台。
- en: Also, we can execute operations such as `map`, `flatMap`, `filter`, and `reduce`
    on this signal producer, which we covered in [Chapter 6](ch06.html "Chapter 6. Map,
    Filter, and Reduce"), *Map, Filter, and Reduce*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在这个信号生产者上执行诸如`map`、`flatMap`、`filter`和`reduce`等操作，这些我们在[第6章](ch06.html
    "第6章。Map、Filter和Reduce")中介绍过，即*Map、Filter和Reduce*。
- en: Mixing OOP and FP
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合面向对象编程与函数式编程
- en: So far, we have seen that adding FP capabilities to an OOP language leads to
    benefits in the OOP design.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，将函数式编程能力添加到面向对象语言中，会在面向对象设计中带来好处。
- en: 'In summary, OOP fits perfectly with FP when our objects are as immutable as
    possible. To make our objects as immutable as possible, we can consider the following
    principles:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当我们的对象尽可能不可变时，面向对象编程与函数式编程完美匹配。为了使我们的对象尽可能不可变，我们可以考虑以下原则：
- en: Objects should be types that encapsulate related pieces of data
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象应该是封装相关数据片段的类型
- en: Objects can have methods; however, these methods shouldn't change the object
    and should instead return a new one of the appropriate type
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以有方法；然而，这些方法不应该改变对象，而应该返回一个适当类型的新对象
- en: All the required state data should be injected into the class's initialization
    so that it will be ready to use immediately
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有必需的状态数据都应该在类的初始化中注入，以便它可以立即使用
- en: Static methods can be used freely and static variables should be avoided
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法可以自由使用，而静态变量应避免使用
- en: Protocols and generics should be used to avoid code duplicates
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用协议和泛型来避免代码重复
- en: These principles not only empower us to employ functional design patterns, but
    also enrich our object-oriented code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则不仅使我们能够使用函数式设计模式，还丰富了我们的面向对象代码。
- en: Problems
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: There are a few problems in unifying and mixing OOP with FP, which we will cover
    in the following sections.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在统一和混合面向对象编程与函数式编程时，存在一些问题，我们将在以下章节中介绍。
- en: Granularity mismatch
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒度不匹配
- en: 'FP and OOP operate on different design granularity levels:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程和面向对象编程在不同的设计粒度级别上操作：
- en: 'FP: Function/method programming on small level'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程：在小型级别上的函数/方法编程
- en: 'OOP: Classes / objects / modules programming on large level'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程：在大型级别上的类/对象/模块编程
- en: 'To overcome this granularity mismatch, we need to find answers for the following
    questions:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种粒度不匹配，我们需要找到以下问题的答案：
- en: Where do we locate the source of individual functions in an OOP architecture?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在面向对象架构中定位单个函数的来源？
- en: Where do we relate such individual functions to an OOP architecture?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在面向对象架构中将这样的单个函数与对象相关联？
- en: In Swift, we can place functions inside source files and outside of classes
    or we can place them as static or class methods.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，我们可以在源文件内部和外部放置函数，或者将它们作为静态或类方法放置。
- en: FP paradigm availability
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程范式可用性
- en: So far, we explored a lot of different FP paradigms in Swift. Here, we check
    conceptually whether Swift is a capable language for FP. We will explore the paradigms
    in the following sections.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在 Swift 中探索了许多不同的 FP 模式。在这里，我们概念上检查 Swift 是否是一个适合 FP 的语言。我们将在以下章节中探索这些模式。
- en: First-class values
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首类值
- en: 'In an FP language, functions/methods should be first-class citizens. First-class
    citizen functions will enable us to use most FP paradigms if they satisfy the
    following rules:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FP 语言中，函数/方法应该是首类公民。如果首类公民函数满足以下规则，它们将使我们能够使用大多数 FP 模式：
- en: Functions/methods should be usable as function/method parameters and arguments
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数/方法应可作为函数/方法参数和参数使用
- en: Functions/methods can be returned as a result of a function/method
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数/方法可以作为函数/方法的返回结果
- en: Functions can take place in data structures
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以存在于数据结构中
- en: So far, we have seen an example implementation of all these rules.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了所有这些规则的一个示例实现。
- en: Closures
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: First-class functions/methods should be implemented as closures. For instance,
    they should be associated with specific private environments.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首类函数/方法应作为闭包实现。例如，它们应与特定的私有环境相关联。
- en: Swift functions are implemented as closures.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 函数作为闭包实现。
- en: FP-OOP interrelation tools
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FP-OOP 交互工具
- en: Standalone functions/methods should be explicitly relatable to the class/object
    level.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 独立函数/方法应明确与类/对象级别相关联。
- en: Swift extensions enable us to add methods to existing classes without creating
    new derived classes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 扩展使我们能够在不创建新派生类的情况下向现有类添加方法。
- en: FP support
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP 支持
- en: FP paradigms should be reinforced by related constructs, predefined definitions,
    occurrences in standard libraries, and so on.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: FP 模式应由相关构造、预定义定义、标准库中的出现等加强。
- en: 'They should satisfy the following rules:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 它们应满足以下规则：
- en: Overloading for generic function types
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型函数类型的重载
- en: First-class multiple invocation and multicasting
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首类多次调用和多播
- en: Function marshalling and serialization (closures as data structures)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数打包和序列化（闭包作为数据结构）
- en: Swift supports the preceding FP paradigms.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 支持上述 FP 模式。
- en: Effects of having FP capabilities in OOP
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 OOP 中具有 FP 功能的影响
- en: Having FP capabilities in the OOP language causes idiomatic and architectural
    effects, which are explored in the following sections.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OOP 语言中具有 FP 功能会导致习惯性和架构效应，这些将在以下章节中探讨。
- en: Idiomatic effects
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习惯性效应
- en: Code factoring (abstraction) at a function/method granularity level
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数/方法粒度级别的代码重构（抽象）
- en: Generic iterator and loop operations (map)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型迭代器和循环操作（映射）
- en: Operation composition and sequence comprehensions (chained function calls)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作组合和序列理解（链式函数调用）
- en: Function partial applications and currying
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数部分应用和柯里化
- en: Architectural effects
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构效应
- en: 'Reduction of the number of object/class definitions: Avoids cluttering the
    OOP architecture with new classes'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少对象/类定义的数量：避免用新类弄乱 OOP 架构
- en: 'Name abstraction at a function method level: Using first-class methods allows
    parameters to be instantiated by any method satisfying their declared type'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数/方法级别的命名抽象：使用首类方法允许任何满足其声明类型的任何方法实例化参数
- en: Operation compositions (and sequence comprehensions)
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作组合（以及序列理解）
- en: Function partial applications and currying
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数部分应用和柯里化
- en: OOP design patterns - an FP perspective
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OOP 设计模式 - FP 视角
- en: 'Design patterns describe recurring solutions to common problems in object-oriented
    software design. Patterns are categorized into three types:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式描述了面向对象软件设计中常见问题的重复解决方案。模式分为三种类型：
- en: Creational
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型
- en: Structural
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: Behavioral
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为
- en: 'This section introduces some of OOP design patterns on a very high level and
    introduces the FP counterparts:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本节从非常高的层次介绍了 OOP 设计模式，并介绍了 FP 对应模式：
- en: Strategy
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Command
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Observer
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Proxy
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Visitor
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Strategy pattern
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern is a behavioral pattern that lets an algorithm vary independently
    of clients that use it. In other words, it allows one of a family of algorithms
    to be selected on-the-fly at runtime.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是一种行为模式，它允许算法独立于使用它的客户端变化。换句话说，它允许在运行时动态选择算法家族中的一个。
- en: From an FP perspective, a strategy is just a case of abstracting code at a method
    level.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 从 FP 视角来看，策略只是方法级别抽象代码的一个例子。
- en: Command pattern
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令模式
- en: The command pattern is a behavioral pattern that encapsulates requests (method
    calls) as objects so that they can be transmitted, stored, and applied easily.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是一种行为模式，它将请求（方法调用）封装为对象，以便它们可以轻松地传输、存储和应用。
- en: FP provides closures and first-class functions.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: FP 提供了闭包和一等函数。
- en: Observer pattern
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The observer pattern is a behavioral pattern that allows a one-to-many dependency
    between objects so that when one object changes state, all its dependents are
    notified and updated.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一种行为模式，它允许对象之间存在一对一的依赖关系，这样当一个对象的状态发生变化时，所有依赖它的对象都会收到通知并更新。
- en: FRP handles this pattern very effectively and declaratively.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: FRP 以非常有效和声明性的方式处理此模式。
- en: Virtual proxy pattern
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟代理模式
- en: The virtual proxy pattern is a structural pattern that provides placeholders
    for other objects in such a way that their data is created/computed only when
    needed.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟代理模式是一种结构模式，它以这种方式提供其他对象的占位符，即只有在需要时才创建/计算其数据。
- en: FP provides lazy instantiation and evaluation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: FP 提供了延迟实例化和评估。
- en: Visitor pattern
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问者模式
- en: The visitor pattern is a behavioral pattern that allows us to define new operations
    without changing the classes of the elements on which they operate.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是一种行为模式，它允许我们在不改变操作元素所属的类的情况下定义新的操作。
- en: FP makes functions independent of object changes.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: FP 使函数独立于对象变化。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered object-oriented programming principles and paradigms.
    Then we discussed protocol-oriented programming. Next, we introduced FRP. Finally,
    we explored how to mix FP with OOP paradigms.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了面向对象编程的原则和范式。然后我们讨论了协议导向编程。接下来，我们介绍了 FRP。最后，我们探讨了如何将 FP 与 OOP 范式混合。
- en: In the following chapter, we will develop a Todo backend and an iOS application
    employing the concepts that we have covered so far.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开发一个 Todo 后端和一个 iOS 应用，这些应用将采用我们迄今为止所涵盖的概念。
- en: We will use functional programming techniques to parse and map the data, and
    we will use FRP to reactively manage the events in the applications. Additionally,
    we will employ protocol-oriented programming and object-oriented programming techniques.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用函数式编程技术来解析和映射数据，并使用 FRP 来反应性地管理应用中的事件。此外，我们还将采用协议导向编程和面向对象编程技术。
