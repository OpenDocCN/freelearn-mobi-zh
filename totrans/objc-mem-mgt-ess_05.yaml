- en: Chapter 5. Managing Your Application Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will be introduced to the concept of managing your application
    data to ensure that your application will perform at an optimal level during runtime.
    The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk and memory caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different forms of data saving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros and cons of various data saving methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also cover some common pitfalls and assumptions that people commonly
    associate with the development of iOS applications. One example will be image
    loading, where if the developers are not careful in planning the proper architecture
    of their application, they will encounter situations where the application will
    lag or run out of memory and lead to an application crash.
  prefs: []
  type: TYPE_NORMAL
- en: Device memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all computing devices, iPads and iPhones have a finite amount of memory
    and you may be tempted to develop applications without any concern about the memory
    usage. Doing so is not ideal for development as memory optimizing and management
    should always be at the top of your mind when doing any type of development, regardless
    of whatever platform you will be developing on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the amount of memory that each of the iOS devices have,
    and we will start with iPhones:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | iPhone 4S | iPhone 5 | iPhone 5C | iPhone 5S |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **RAM** | 512 MB | 1 GB | 1 GB | 1 GB |'
  prefs: []
  type: TYPE_TB
- en: 'Here is the RAM for iPads:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | iPad Air | iPad Mini 2 | iPad Mini Wi-Fi + Cellular | iPad 2 Wi-Fi +
    3G | iPad Mini Wi-Fi | iPad 3 Wi-Fi | iPad 3 Wi-Fi + Cellular | iPad 4 Wi-Fi |
    iPad 2 Wi-Fi |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **RAM** | 1 GB | 1 GB | 512 MB | 512 MB | 512 MB | 1 GB | 1 GB | 1 GB | 512
    MB |'
  prefs: []
  type: TYPE_TB
- en: Now, the amount of memory does look impressive as you fondly remember the days
    of old, where your old desktop ran on 256 MB of RAM, but do remember that iOS
    does not let you play with the full 512 MB or 1 GB RAM. The OS will allocate some
    to system processes in your device, and you will only get a subset of the available
    RAM for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In your application, everything will occupy memory and storage space. Some of
    the biggest culprits are binary assets, such as videos and images, which can be
    total resource hogs to even your class objects that can take up precious space
    if you do not take note of them when doing your development. So, let's start with
    image optimization as almost every application will make use of images in one
    way or another.
  prefs: []
  type: TYPE_NORMAL
- en: Image optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any application will look boring and drab without the usage of `.png` and some
    nice images. However, one thing about images is that they take up much more memory
    than their file size implies. A single 1 MB `.png` file can occupy double or triple
    their memory size when loaded into the memory. The reason is because PNG is basically
    a compressed file format, such as a ZIP file. So, all the image data is compressed
    into a PNG file and when your application needs to display your PNG image. It
    needs to load the PNG file into memory, uncompress it, and then it will be able
    to get the image data to be used by your code and will consume more memory in
    the process. So, if your application has 20 MB of PNG files, you are easily looking
    at 40 MB or more of RAM allocation just for images. So, a few tips for image optimization
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Save your image as PNG-8 instead of PNG-24 as PNG-8 consumes less RAM than their
    equivalent PNG-24\. Only use PNG-24 if you need the alpha channel for transparency.
    The difference between PNG-8 and PNG-24 is the image quality and the number of
    colors that you can have. The 8 and 24 means 8-bits per pixel and 24-bits per
    pixel respectively. So, PNG-8 can only support up to 256 colors while PNG-24 can
    support up to 16 million colors, so PNG-24 is the best option if you need to display
    images with a lot of colors such as photographs, while logos and user interface
    elements such as icons can probably get by with PNG-8\. PNG-24 also supports alpha
    transparency, which is good for images that need to have a transparent background.
    So, knowing which format to use in which situation will help you in reducing the
    memory consumption of your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can use JPG files, then use them as they are a lossy format, and it means
    that you will get a bit of image degradation, but generally the image degradation
    is almost invisible to the naked eye. However, note that JPG files do not support
    alpha transparency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PNG is a lossless format, which means that there is no image degradation when
    you use PNG files, but it comes at a price that it consumes more RAM when loaded
    into your device compared to a JPG, which is a lossy format.
  prefs: []
  type: TYPE_NORMAL
- en: So, keep PNG files and JPG files to an absolute minimum if you can and only
    use them if you have to.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is lazy loading? It is a design pattern or a way of doing things in software
    design where you load a resource such as a PNG, MP3 file, and so on only at the
    time when it is needed. This helps to mitigate the problem of insufficient memory
    instead of loading all your resources at once. You only load it when you need
    it in a "lazy" manner. There is also one more advantage, that is, it minimizes
    the start up time of your application since you only load the resources on demand
    and this takes less time to load. So, you gain a speed boost in terms of time.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have multiple UIViews where each view has 10 UIImages, but only
    one view can be seen at any one time. Without proper thought, you will be tempted
    to write code to load all 10 UIImages for all the UIViews at once. However, upon
    further reflection, the question arises as to whether there is a need to do so.
    It would be better if you refactor your code to load the 10 UIImages only when
    that UIView is visible to the user and then clean it up once the user is not viewing
    it and load the next batch of UIImages from the next UIView, which will be visible
    to the user. This will add a bit more of coding for you, but the trade-off in
    terms of efficient memory usage will be worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the simplest implementations where we just override the getter
    method of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can put the preceding code in place of the normal getter method of your
    class. The preceding code checks whether the object does or does not exists, and
    if it does not exist, then it will create the object. However, if the object already
    exists, then it will not create it again.
  prefs: []
  type: TYPE_NORMAL
- en: Control creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controls are part and parcel of every iOS application and they also consume
    memory on your device and every instance will consume bytes and bits of memory.
    When you are creating a lot of `UITableViewCell` class, for example, you will
    be looking at a control that is consuming a lot of memory sooner or later.
  prefs: []
  type: TYPE_NORMAL
- en: Also, tasks such as loading images and getting data from a remote server are
    considered as slow processes and will slow down your application. I am sure that
    you have used iOS apps where when you scroll down a `UITableView` view object
    you will see a noticeable lag as new images are loaded into the newly revealed
    cells. In this world, where people are used to images loading quickly on their
    desktop and mobile phones, such slowness and laggy UI are not acceptable and can
    mean the difference between a user staying engaged with your application or uninstalling
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental mantra is that you must not let your users wait for 1 second
    or even 1 millisecond more than what is absolutely necessary. One tip to compensate
    for the perceived slowness of an application is to have a simple animation such
    as fading in an image after showing a spinner in order to give the user the perception
    that the application is not actually very slow since there is an animation playing.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing your controls is a must if you are experiencing huge memory usage, which
    is impacting the usability of your iOS application. Later on, we will cover how
    to use the tool called **Instrument** in Xcode to monitor the memory usage. Creating
    objects is an expensive process and has a performance cost.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to create an object on the fly over a short period of time, such
    as scrolling quickly through a `UITableView` view object, you will experience
    some lag as your code will be creating new `UITableViewCell` class instead of
    reusing old ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reusing `UITableViewCell` is a lot faster and will enhance the performance
    of your application. Luckily, Apple has already created code for us to reuse a
    cell, which can be implemented easily with a few lines of code. So, let''s look
    at the `dequeueReusableCellWithIdentifier` method as a good example with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the preceding code, you can see that we attempt to assign a cell
    using the `dequeueReusableCellWithIdentifier` method, then it will return a pointer
    to that cell if it already exists. Next, our code (`!cell`) will check whether
    that pointer is not nil, then it will create the cell. This is the exact same
    technique we used in the previous section *Lazy loading*, except that we apply
    this technique to an iOS control, which in this case, is a `UITableViewCell` object.
    These few lines of code serve three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: This helps to prevent a situation where your app is lagging when you are scrolling
    up as it eliminates the need to create new instances of `UITableViewCell`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have 1,000 rows of data and only 4 rows are visible on screen at any
    given time, then it makes no sense to create 1,000 `UITableViewCell` when you
    only need to create five. A few other cells can be partially visible and hence
    need to be created too. So, the five cells will only be created as it needs to
    be visible to the user while the remaining cells are not loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While a single `UITableViewCell` class occupies a lot of memory, storing 1,000
    of them is not easy, and through a few extra lines of code, you can avoid unnecessary
    memory usage and use the memory you save for other parts of your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Caching is a concept where you store resources on disk or memory for faster
    access. Caching will occupy more space, but in situations where you need to worry
    more about loading speed than memory, caching can be a very good technique to
    use. Consider this common scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading a large file such as an image or even a movie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the file to a disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the files from the disk and display them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you follow the normal method as mentioned earlier, a bottleneck that you
    will face is slow loading of the file from disk. Disk access can be as slow as
    10,000 or even 1,000,000 slower than memory access and it won't make a good user
    experience as the user will be kept waiting while your app is loading the files
    from disk. Caching will help slow this problem as your file is saved to memory
    where read access is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good from a user point of view as they do not need to wait a long time
    for the file to be loaded and can help to optimize the user experience of your
    application since every second wasted can lead to the user moving away from your
    application. Caching on disk or memory has its pros and cons as illustrated in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Disk | Memory |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Storage** | Persistent, as data is not lost when device is switched off
    | Ephemeral, as data is lost when device is switched off |'
  prefs: []
  type: TYPE_TB
- en: '| **Speed** | Slow | Fast |'
  prefs: []
  type: TYPE_TB
- en: '| **Storage size** | Large | Small, as memory is generally lesser than disk
    storage |'
  prefs: []
  type: TYPE_TB
- en: So as a rule of thumb, it will be best to do all caching on memory first and
    then move to caching on disk only when your application is running low on memory
    or you experience memory warning errors. If you are downloading large files such
    as movies, you will need to store the movie file on disk since the file normally
    will not be able to fit into memory.
  prefs: []
  type: TYPE_NORMAL
- en: As a sidenote, caching uses a few algorithms for implementation, such as **Most
    Recently Used** (**MRU**) or **Least Recently Used** (**LRU**). MRU means the
    cache will discard the most recently used items first when the cache is full,
    while LRU is the reverse opposite where the least recently used items will be
    discarded instead. The implementation strategy is out of the scope of this book
    and it is up to the manufacturer to decide.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we do not need to write a lot of code to implement efficient caching.
    There are a few iOS caching libraries that we can use and they are available for
    us to use. So, in this section, we will look at one of the most popular caching
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: SDWebImage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first library we will be looking at is called SDWebImage. The source code
    can be downloaded via a Git clone from [https://github.com/rs/SDWebImage](https://github.com/rs/SDWebImage),
    and it comes with a demo project too. So, let''s look at the important parts of
    this demo project. I have summarized the steps for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Xcode project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up `masterviewcontroller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `UIImageView`+`WebCache.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for the `cellforrowatindexpath` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call this method `setImageWithURL:placeholderImage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s look into each of these steps in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `SDWebImage Demo.xcodeproj` project and run it. You should see the
    following screen, which is a list of table view cells with images and text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SDWebImage](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you tap on a table view cell, it will show this screen, which shows the
    larger size of the image that you tapped on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SDWebImage](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, open up `MasterViewController` and look for the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is where the code will get the image from the server and then cache it
    on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this in your own code, you need to import `UIImageView`+`WebCache.h`
    and then call the `setImageWithURL:placeholderImage`: method, where you can add
    in your own placeholder PNG and JPG image to replace `@"placeholder"`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when you run the app again you will notice that images are not pulled from
    server again, but are instead served from the cache on the device, so you will
    see that the images load faster as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Object serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is serialization? This is a question that a lot of people find hard to
    explain or understand. Serialization is the method or concept where we convert
    data structures or objects into a format for it to be stored in memory or disk
    for storage, or to be transmitted across a network link. It can also assist in
    memory management as it provides an alternative mechanism where we save some files
    to disk instead of memory, which is usually the case for big files, such as movie
    files. Serialization formats include JSON, XML, YAML, and so on. And luckily for
    iOS developers, Apple provides us with a robust framework that helps us take away
    the low-level code when we want to do serialization. So, when we want to store
    our data structures or objects in memory or disk, we can use Apple's frameworks
    such as Core Data or NSCoding, which provides an abstraction layer and hides away
    the lower-level coding for us.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to data saving or serialization, we tend to stick with the one
    method that we are most familiar with. However, this is not a good way of doing
    things as various methods have their pros and cons, and we should consider our
    use case before we decide on the best method. To this extent, Apple has provided
    us with a few different methods for data serialization and it is up to us, the
    developers, to decide which method suits us best. One of the simplest ways is
    to use NSCoding. What is NSCoding? NSCoding is basically a protocol provided by
    Apple for you to encode and decode your data into a buffer, which can then be
    persisted to disk for persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the `NSCoding` protocol also involves the `NSKeyedArchiver` and `NSKeyedUnarchiver`
    methods as `NSCoding` is a protocol with delegate methods for serializing our
    data structure and custom object into a format that can be stored in memory or
    disk. `NSKeyedArchiver` and `NSKeyedUnarchiver` are the methods that will actually
    do the work of storing our serialized data into disk for persistent storage. So
    to kick things off, we will use an example to help us understand how serializing
    and archiving works for iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the listed steps for the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `NSCoding` protocol to your custom object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `encodeWithCoder` and `initWithCoder` and assign the values you wish
    to store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `archiveRootObject` and `unarchiveObjectWithFile` methods to save your
    serialized data to disk and load it from the disk respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, we create a custom object called `OurCustomObject`, and then to
    use the `NSCoding` protocol, we need to add it to our interface declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to write the `encodeWithCoder` method to save the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the code to encode and decode the data into a serialized format,
    we need to put in the actual code to save it to disk on our device, so we can
    use `NSKeyedArchiver` to do the actual writing to disk, while we use `NSKeyedUnarchiver`
    to get the data from the disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then to load our object from disk, we just use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no need to call `initWithCoder` and `encodeWithCoder` anywhere in our
    code as those method calls are called when you call `unarchiveObjectWithFile`
    and `archiveRootObject`. However, you need to implement `initWithCoder` and `encodeWithCoder`
    as these two methods need to contain the necessary code to encode and decode the
    `isReset`, `userName`, and `score` variables that form `OurCustomObject`. As you
    can see, `NSCoding` is a relatively powerful way to store data to disk compared
    to `NSUserDefaults`, and the code is quite easy to understand and write. However,
    if you need more power features for data storage, NSCoding will not be the best
    choice and Core Data will be the better option as it has more features such as
    being able to perform queries, being optimized for speed, support for different
    serialization formats such as XML, SQLite, or NSDate, among other benefits.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQLite, for those familiar with **Relational DataBase Management System** (**RDBMS**),
    is a database based on the relational model. A SQLiteis, a RDBMS that is available
    for us in iOS, has a lot of the features and functions of RDBMS that many people
    are familiar with, such as ACID properties, queries, and so on. Core Data is Apple''s
    framework for data storage and you can use Core Data to store data into a SQLite
    database. However, there are some cases when you need to use SQLite instead of
    Core Data. So, I will elaborate further on this:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite as a database is available on multiple platforms besides iOS. So this
    means that if you are developing an application that runs on multiple platforms
    or has the possibility to run on other non-iOS platforms, SQLite will be the option
    for you to seriously consider since you will avoid framework lock-in using Core
    Data. SQLite also is faster than NSCoding, plus it adds querying functionality,
    which is not possible if you use `NSUserDefaults`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, if you have experience with SQLite and your use case for data storage
    is very straightforward along with no experience with Core Data, then you should
    choose SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not require a **Model-View-Controller** (**MVC**) conceptual model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, this does not mean that SQLite should be the default data storage solution
    for you when you need to store data to disk. This is because there are other options
    such as Core Data and various other factors such as speed and ease of coding,
    which will play a big part in your decision-making as we will see later in this
    chapter and the chapter on Core Data later on.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite versus Core Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Core Data is a rich and sophisticated object graph management framework with
    a lot of bells and whistles that you require for complex use cases. In the *Introduction
    to Core Data Programming Guide*, Apple mentions that the Core Data framework provides
    generalized and automated solutions to common tasks associated with object life
    cycle and object graph management, including persistence, which means it prevents
    you from writing a lot of code to do your everyday data storage tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data uses models that are your objects and these are the model in the commonly
    used MVC architecture. These enable you to store whole objects and it ties in
    very closely with the controller and view classes of your iOS application. So,
    developers who are using MVC architectures will have no problem absorbing the
    Core Data concepts and models.
  prefs: []
  type: TYPE_NORMAL
- en: The tools for development using the Core Data framework is tied in deeply into
    Xcode and it enables developers to quickly write code and lay out their data models
    in a fast and efficient manner, and thus, save you time, which allows you to spend
    it on other parts of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data framework is also available for the Mac OS, and this enables reusability
    of your code if you intend to create a Mac version of your application.
  prefs: []
  type: TYPE_NORMAL
- en: With Apple's iCloud storage and computing platform, you can use Core Data to
    take advantage of iCloud to sync your application and user data across multiple
    devices such as iPads and so on. iOS 8 has tighter integration with iCloud with
    the introduction of the CloudKit framework, which has new functionality such as
    allowing partial download of datasets and all this is only possible using Core
    Data.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is a pure RDBMS and many people confuse Core Data with SQLite. SQLite
    is a RDBMS, pure and simple. So, it has a lot of the features that you will associate
    with RDBMSes, such as ACID properties, queries, and so on. However, that is where
    it ends. Core Data is an abstraction layer on top of a data store, which can be
    SQLite or other forms of data persistence, such as XML files. So, using Core Data
    will still enable you to store data in SQLite, but there will be some occasions
    when you prefer to use SQLite over Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: If data portability is an important feature for you, then using SQLite should
    be your preferred choice as SQLite is platform-independent, while Core Data is
    for Apple platforms only. So, if you use SQLite, you can be assured that your
    data files can be moved and accessed on almost any platform that supports SQLite,
    not only Apple-supported platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data ultimately is an abstraction layer between your code and the database.
    However, sometimes you want to get down to the lower levels of your code and avoid
    abstraction layers to understand how the code works. So, using SQLite will allow
    you to do that, as it allows you to do low level optimization if you are working
    with large datasets. Core Data can also be used to abstract the Sqlite access
    to save on development time and make your code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, there are no hard and fast rules on when and where to use Core Data
    or SQLite. On every engineering project, there are questions and decisions to
    be made, which encompass factors such as amount of resources and platform scalability
    since Core Data only supports Apple platforms and if you intend to support non-Apple
    platforms. Core Data might not be a good choice. So, using the Core Data framework
    allows you to have a rapid solution for simple applications, but it also ties
    you into Apple's framework, which impedes data portability as if you create an
    application where a user's data such as game data needs to be present on another
    non-Apple device. You will encounter a technical lock-in if you use Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, SQLite allows ease of tweaking and optimization for various
    reasons. In the end, the complexity of your use case, data model, and requirements
    of your platform will be the factors that will help you make a good decision on
    the right option to choose.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In summary, this chapter covered the management of your application data with
    regards to caching data to memory and data storage on to disk. We also covered
    the pros and cons of using the various storage frameworks for various situations
    and did a few code examples on using the NSCoding protocol and the SDWebImage
    open source caching framework.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a bit of Core Data, which will help us in the next chapter
    as we deep dive into Core Data along with some code examples. The next chapter
    will be all about Core Data and its uses.
  prefs: []
  type: TYPE_NORMAL
