<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Learning about Variables, Constants, Strings, and Operators"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Learning about Variables, Constants, Strings, and Operators</h1></div></div></div><p>The first program I ever wrote was written in the BASIC programming language, and was the typical Hello World application. This application was pretty exciting at first, but the excitement of printing static text wore off pretty quickly. For my second application, I used BASIC's input command to prompt the user for a name and then printed out a custom hello message to the user with their name in it. At the age of 12, it was pretty cool to display Hello Han Solo. This application led me to create numerous Mad Lib style applications that prompted the user for various words and then put those words into a story that was displayed after the user had entered all the required words. These applications introduced me to, and taught me, the importance of variables. Every useful application I created since then has used variables.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What variables and constants are</li><li class="listitem" style="list-style-type: disc">The difference between explicit and inferred typing</li><li class="listitem" style="list-style-type: disc">Explaining numeric, string, and Boolean types</li><li class="listitem" style="list-style-type: disc">Defining what optional types are</li><li class="listitem" style="list-style-type: disc">Explaining how enumerations work in Swift</li><li class="listitem" style="list-style-type: disc">Explaining how Swift's operators work</li></ul></div><div class="section" title="Constants and variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Constants and variables</h1></div></div></div><p>Constants and variables <a class="indexterm" id="id49"/>associate an identifier (such as <code class="literal">myName</code> or <code class="literal">currentTemperature</code>) with a value of a particular type (such as <code class="literal">String</code> or <code class="literal">Int</code>), where the identifier can be used to retrieve the value. The difference between a constant and a variable is that a variable can be updated or changed, while a constant cannot be changed once a value is assigned to it.</p><p>Constants are good <a class="indexterm" id="id50"/>for defining the values that you know will never change, such as the freezing temperature of water or the speed of light. Constants are also good for defining a value that we use many times throughout our application, such as a standard font size or maximum characters in a buffer. There will be numerous examples of constants throughout this book.</p><p>Variables tend to be more common in software development than constants, however. This is mainly because developers tend to prefer variables to constants. In Swift 2 and Xcode 7, we are warned if we declare a variable that is never changed. This should increase the use of constants. We can make useful applications without using constants (although it is a good practice to use them); however, it is almost impossible to create a useful application without variables.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The use of constants is encouraged in Swift. If we do not expect or want the value to change, we should declare it as a constant. This adds a very important safety constraint to our code that ensures that the value never changes.</p></div></div><p>You can use almost any character in the identifier of a variable or constant (even Unicode characters); however, there are a few rules that you must follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An identifier must not contain any whitespace</li><li class="listitem" style="list-style-type: disc">An identifier must not contain any mathematical symbols</li><li class="listitem" style="list-style-type: disc">An identifier must not contain any arrows</li><li class="listitem" style="list-style-type: disc">An identifier must not contain private use or invalid Unicode characters</li><li class="listitem" style="list-style-type: disc">An identifier must not contain line- or box-drawing characters</li><li class="listitem" style="list-style-type: disc">An identifier must not start with a number, but they can contain numbers</li><li class="listitem" style="list-style-type: disc">If you use a Swift keyword as an identifier, surround it with back ticks</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Keywords are words that are used by the Swift programming language. Some examples of keywords that you will see in this chapter are <code class="literal">var</code> and <code class="literal">let</code>. You should avoid using Swift keywords as identifiers to avoid confusion when reading your code.</p></div></div><div class="section" title="Defining constants and variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Defining constants and variables</h2></div></div></div><p>Constants <a class="indexterm" id="id51"/>and variables must be defined prior to using them. To define a constant, you use the keyword, <code class="literal">let</code>, and to define a variable, you use the keyword, <code class="literal">var</code>. The following are some examples of constants and variables:</p><div class="informalexample"><pre class="programlisting">// Constants
let freezingTemperatureOfWaterCelsius = 0
let speedOfLightKmSec = 300000

// Variables
var currentTemperature = 22
var currentSpeed = 55</pre></div><p>We can declare <a class="indexterm" id="id52"/>multiple constants or variables in a single line by separating them with a comma. For example, we could shrink the preceding four lines of code down to two lines, as shown here:</p><div class="informalexample"><pre class="programlisting">// Constants
let freezingTempertureOfWaterCelsius = 0, speedOfLightKmSec = 300000

// Variables
var currentTemperture = 22, currentSpeed = 55</pre></div><p>We can change the value of a variable to another value of a compatible type; however, as we noted earlier, we cannot change the value of a constant. Let's look at the following Playground. Can you tell what is wrong with the code from the error message that is shown in the following screenshot:</p><div class="mediaobject"><img alt="Defining constants and variables" src="graphics/B05115_02_01.jpg"/></div><p>Did you figure out what was wrong with the code? Any physicist can tell you that we cannot change the speed of light, and in our code, the <code class="literal">speedOfLightKmSec</code> variable is a constant, so we cannot change it either. Therefore, when we try to change the <code class="literal">speedOfLightKmSec</code> constant, an error is reported. We are able to change the value of the <code class="literal">highTemperture</code> variable without an error because it is a variable. We mentioned the difference between variables and constants a couple of times because it is a very important concept to grasp, especially when we define mutable and immutable collection types later in <a class="link" href="ch03.html" title="Chapter 3. Using Collections and Cocoa Data Types">Chapter 3</a>, <span class="emphasis"><em>Using Collections and Cocoa Data Types</em></span>.</p></div><div class="section" title="Type safety"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Type safety</h2></div></div></div><p>Swift is <a class="indexterm" id="id53"/>a type-safe language. In a type-safe language, we <a class="indexterm" id="id54"/>are required to be clear on the types of values we store in a variable. We will get an error if we attempt to assign a value to a variable that is of a wrong type. The following Playground shows what happens if we attempt to put a string value into a variable that expects integer values; note that we will go over the most popular types a little later in the chapter:</p><div class="mediaobject"><img alt="Type safety" src="graphics/B05115_02_02.jpg"/></div><p>Swift performs a type check when it compiles code; therefore, it will flag any mismatched types with an error. The error message in this Playground explains pretty clearly that we are trying to insert a string literal into an integer variable.</p><p>So the question is, how does Swift know that <code class="literal">integerVar</code> is of the Int type? Swift uses type inference to figure out the appropriate type. Let's take a look at what type inference is.</p></div><div class="section" title="Type inference"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Type inference</h2></div></div></div><p>Type inference <a class="indexterm" id="id55"/>allows us to omit the variable <a class="indexterm" id="id56"/>type when we define it. The compiler will infer the type, based on the initial value. For example, in Objective-C, we would define an integer like this:</p><div class="informalexample"><pre class="programlisting">int myInt = 1</pre></div><p>This tells the compiler that the <code class="literal">myInt</code> variable is of the Int type, and the initial value is the number <code class="literal">1</code>. In Swift, we would define the same integer like this:</p><div class="informalexample"><pre class="programlisting">var myInt = 1</pre></div><p>Swift infers that the variable type is an integer because the initial value is an integer. Let's take a look at a couple of more examples:</p><div class="informalexample"><pre class="programlisting">var x = 3.14      // Double type
var y = "Hello"   // String type
var z = true      // Boolean type</pre></div><p>In the<a class="indexterm" id="id57"/> preceding <a class="indexterm" id="id58"/>example, the compiler will correctly infer that variable <code class="literal">x</code> is Double, variable <code class="literal">y</code> is String, and variable <code class="literal">z</code> is Boolean, based on the initial values.</p></div><div class="section" title="Explicit types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Explicit types</h2></div></div></div><p>Type <a class="indexterm" id="id59"/>inference is a very nice feature in Swift and is one that you will probably get used to very quickly; however, there are times when we <a class="indexterm" id="id60"/>would like to explicitly define a variable's type. For example, in the preceding example, the variable, <code class="literal">x</code>, is inferred to be <code class="literal">Double</code>, but what if we wanted the variable type to be <code class="literal">Float</code>? We can explicitly define a variable type like this:</p><div class="informalexample"><pre class="programlisting">var x : Float = 3.14</pre></div><p>Notice the<code class="literal">: Float</code>(colon and the word <code class="literal">Float</code>) after the variable identifier; this tells the compiler to define the variable to be of the <code class="literal">Float</code> type and gives it an initial value of <code class="literal">3.14</code>. When we define a variable in this manner, we need to make sure that the initial value is of the same type we are defining the variable to be. If we try to give a variable an initial value, that is, a different type than we are defining it as, we will receive an error.</p><p>We would also explicitly define the variable type if we were not setting an initial value. For example, the following line of code is invalid because the compiler does not know what type to set the variable, <code class="literal">x</code>, to:</p><div class="informalexample"><pre class="programlisting">var x</pre></div><p>If we use this code in our application, we will receive a <code class="literal">Type annotation missing in pattern</code> error. If we are not setting an initial value for a variable, we are required to define the type like this:</p><div class="informalexample"><pre class="programlisting">var x: Int</pre></div><p>Now that we have seen how to explicitly define a variable type, let's take a look at some of the most commonly used types.</p></div><div class="section" title="Numeric types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Numeric types</h2></div></div></div><p>Swift <a class="indexterm" id="id61"/>contains many of the standard numeric types that are<a class="indexterm" id="id62"/> suitable for storing various integer and floating-point values.</p><div class="section" title="Integers"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Integers</h3></div></div></div><p>An<a class="indexterm" id="id63"/> integer is a whole number. Integers can be either signed (positive, negative, or zero) or unsigned (positive or zero). Swift provides several integer types of different sizes. The following chart shows the value ranges for the different integer types:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Minimum</p>
</th><th style="text-align: left" valign="bottom">
<p>Maximum</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Int8</p>
</td><td style="text-align: left" valign="top">
<p>-128</p>
</td><td style="text-align: left" valign="top">
<p>127</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Int16</p>
</td><td style="text-align: left" valign="top">
<p>-32,768</p>
</td><td style="text-align: left" valign="top">
<p>32,767</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Int32</p>
</td><td style="text-align: left" valign="top">
<p>-2,147,483,648</p>
</td><td style="text-align: left" valign="top">
<p>2,147,483,647</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Int64</p>
</td><td style="text-align: left" valign="top">
<p>- 9,223,372,036,854,775,808 </p>
</td><td style="text-align: left" valign="top">
<p>9,223,372,036,854,775,807</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Int</p>
</td><td style="text-align: left" valign="top">
<p>- 9,223,372,036,854,775,808 </p>
</td><td style="text-align: left" valign="top">
<p>9,223,372,036,854,775,807</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>UInt8</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>255</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>UInt16</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>65,535</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>UInt32</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>4,294,967,295</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>UInt64</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>18,446,744,073,709,551,615</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>UInt</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>18,446,744,073,709,551,615</p>
</td></tr></tbody></table></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>Unless there is a specific reason to define the size of an integer, I would recommend using the standard <code class="literal">Int</code> or <code class="literal">UInt</code> type. This will save you from needing to convert between different types of integers.</p></div></div><p>In Swift, Int (as well as other numerical types) are actually named types, implemented in the Swift standard library using structures. This gives us a consistent mechanism for memory <a class="indexterm" id="id64"/>management for all the data types as well as properties that we can access. For the preceding chart, I retrieved the minimum and maximum values of each integer type using the <code class="literal">min</code> and <code class="literal">max</code> properties. Take a look at the following Playground to see how I retrieved the values:</p><div class="mediaobject"><img alt="Integers" src="graphics/B05115_02_03.jpg"/></div><p>Integers can also be represented as binary, octal, and hexadecimal numbers. We just need to add a prefix to the number to tell the compiler which base the number should be in. The following chart shows the prefix for each numerical base:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Base</p>
</th><th style="text-align: left" valign="bottom">
<p>Prefix</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Decimal </p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Binary</p>
</td><td style="text-align: left" valign="top">
<p>0b</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Octal</p>
</td><td style="text-align: left" valign="top">
<p>0o</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Hexadecimal</p>
</td><td style="text-align: left" valign="top">
<p>0x</p>
</td></tr></tbody></table></div><p>The following Playground <a class="indexterm" id="id65"/>shows how the number, <code class="literal">95</code>, is represented in each of the numerical bases:</p><div class="mediaobject"><img alt="Integers" src="graphics/B05115_02_04.jpg"/></div><p>Swift also allows us to insert arbitrary underscores in our numeric literals. This can improve the readability of our code. As an example, if we were defining the speed of light, which is constant, we can define it like this:</p><div class="informalexample"><pre class="programlisting">let speedOfLightKmSec = 300_000</pre></div><p>Swift will ignore these underscores; therefore, they do not affect the value of the numeric literals in any way.</p></div><div class="section" title="Floating-point"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Floating-point</h3></div></div></div><p>A floating-point<a class="indexterm" id="id66"/> number is a number with a decimal component. There are two standard floating-point types in Swift Float and Double. Float represents a 32-bit floating-point number, while Double represents a 64-bit floating-point number. Swift also supports an extended floating-point type, that is, <span class="strong"><strong>Float80</strong></span>. The Float80 type is an 80-bit floating-point number.</p><p>It is recommended <a class="indexterm" id="id67"/>that we use the Double type over the Float type unless there is a specific reason to use the latter. The Double type has a precision of at least 15 decimal digits, while the Float type can be as little as six decimal digits. Lets look at an example of how this can effect our application without us knowing it. The following screenshot shows the results if we add two decimal numbers together and put the results in both a Float type and Double type:</p><div class="mediaobject"><img alt="Floating-point" src="graphics/B05115_02_05.jpg"/></div><p>As we can see from the screenshots, the two decimal numbers that we are adding together contain nine digits post the decimal point; however, the results in the Float type only contains seven digits, while the results in the Double type contains the full nine digits.</p><p>The loss of precision can cause issues if we are working with currency or other numbers that need accurate calculations. The floating-point accuracy problem is not an issue confined to Swift; all the languages that implement the IEEE 754 floating-point standard have similar issues. The best practice is to use Double for floating-point numbers unless there is a specific reason not to.</p><p>What if we have two variables, one is an Int and the other is a Double? Do you think we can add them together as the following code depicts:</p><div class="informalexample"><pre class="programlisting">var a : Int = 3
var b : Double = 0.14
var c = a + b</pre></div><p>If we put the preceding code into a Playground, we would receive the following error: <code class="literal">binary operator '+' cannot be applied to operands of type 'Int' and 'String</code>'</p><p>This error lets us know that we are trying to add two different types of numbers, which is not allowed. To<a class="indexterm" id="id68"/> add an Int and a Double together, we need to convert the Int value into a Double value. The following code shows how to convert an Int value into a Double value so that we can add them together:</p><div class="informalexample"><pre class="programlisting">var a : Int = 3
var b : Double = 0.14
var c = Double(a) + b</pre></div><p>Notice how we use the <code class="literal">Double()</code> function to convert the Int value to a Double value. All the numeric types in Swift have a conversion convenience initializer, similar to the <code class="literal">Double()</code> function shown in the preceding code sample. For example, the following code shows how you can convert an <code class="literal">Int</code> variable to <code class="literal">Float</code> and <code class="literal">UInt16</code> variables:</p><div class="informalexample"><pre class="programlisting">var intVar = 32
var floatVar = Float(intVar)
var uint16Var = UInt16(intVar)</pre></div></div></div><div class="section" title="The Boolean type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>The Boolean type</h2></div></div></div><p>Boolean values<a class="indexterm" id="id69"/> are often referred to as logical values <a class="indexterm" id="id70"/>because they can be either <code class="literal">true</code> or <code class="literal">false</code>. Swift has a built-in Boolean type called Bool that accepts one of the two built-in Boolean constants. These constants are <code class="literal">true</code> and <code class="literal">false</code>.</p><p>Boolean constants and variables can be defined like this:</p><div class="informalexample"><pre class="programlisting">let swiftIsCool = true
let swiftIsHard = false

var itIsWarm = false
var itIsRaining = true</pre></div><p>Boolean values are especially useful when working with conditional statements, such as <code class="literal">if</code> and <code class="literal">while</code>. For example, what do you think this code would do:</p><div class="informalexample"><pre class="programlisting">let isSwiftCool = true
let isItRaining = false
if (isSwiftCool) {
    print("YEA, I cannot wait to learn it")
}
if (isItRaining) {
    print("Get a rain coat")
}</pre></div><p>If you answered that this code would print out <code class="literal">YEA, I cannot wait to learn it</code>, then you would be correct. Since <code class="literal">isSwiftCool</code> is set to true, the <code class="literal">YEA, I cannot wait to learn it</code> message is printed out, but <code class="literal">isItRaining</code> is false; therefore, the <code class="literal">Get a rain coat</code> message is not.</p><p>You can also <a class="indexterm" id="id71"/>assign a Boolean value from a comparison operator like this:</p><div class="informalexample"><pre class="programlisting">var x = 2, y = 1
var z = x &gt; y</pre></div><p>In the <a class="indexterm" id="id72"/>preceding code, <code class="literal">z</code> is a Boolean variable containing a Boolean <code class="literal">true</code> value since <code class="literal">2</code> is greater than <code class="literal">1</code>.</p></div><div class="section" title="The string type"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>The string type</h2></div></div></div><p>A<a class="indexterm" id="id73"/> string <a class="indexterm" id="id74"/>is an ordered collection of characters, such as <code class="literal">Hello</code> or <code class="literal">Swift</code>. In Swift, the string type represents a string. We have seen several examples of strings already in this book, so the following code should look familiar. This code shows how to define two strings:</p><div class="informalexample"><pre class="programlisting">var stringOne = "Hello"
var stringTwo = " World"</pre></div><p>Since a string is an ordered collection of characters, we can iterate through each character of a string. The following code shows how to do this:</p><div class="informalexample"><pre class="programlisting">varstringOne = "Hello"
for char in stringOne.characters {
    print(char)
}</pre></div><p>The preceding code will display the results shown in the following screenshot:</p><div class="mediaobject"><img alt="The string type" src="graphics/B05115_02_06.jpg"/></div><p>There are two ways to add one string to another string. We can concatenate them or include them inline. To<a class="indexterm" id="id75"/> concatenate two strings, we use the <code class="literal">+</code> or <code class="literal">+=</code> operator. The following code shows how to concatenate two strings. The first example appends <code class="literal">stringB</code> to the end of <code class="literal">stringA</code> and the results are put into a new <code class="literal">stringC</code> variable. The second example appends <code class="literal">stringB</code> directly to the end of <code class="literal">stringA</code> without creating a new string:</p><div class="informalexample"><pre class="programlisting">var stringC = stringA + stringB
stringA += stringB</pre></div><p>To include a<a class="indexterm" id="id76"/> string inline, with another string, we use a special sequence of characters <code class="literal">\( )</code>. The following code shows how to include a string inline with another string:</p><div class="informalexample"><pre class="programlisting">var stringA = "Jon"
var stringB = "Hello \(stringA)"</pre></div><p>In the previous example, <code class="literal">stringB</code> will contain the message, <code class="literal">Hello Jon</code>, because Swift will replace the <code class="literal">\(stringA)</code> sequence of characters with the value of <code class="literal">stringA</code>.</p><p>In Swift, we define the mutability of variables and collections by using the <code class="literal">var</code> and <code class="literal">let</code> keywords. If we define a string as a variable using <code class="literal">var</code>, the string is mutable; this means that we can change and edit the value of the string. If we define a string as a constant using <code class="literal">let</code>, the string is immutable, meaning that we cannot change or edit the value once it is set. The following code shows the difference between a mutable and an immutable string:</p><div class="informalexample"><pre class="programlisting">var x = "Hello"
let y = "HI"
var z = " World"

//This is valid, x is mutable
x += z

//This is invalid, y is not mutable.
y += z</pre></div><p>Strings in Swift have three computed properties that can convert the case of the string. These properties are <code class="literal">capitalizedString</code>, <code class="literal">lowercaseString</code>, and <code class="literal">uppercaseString</code>. The following example demonstrates these properties:</p><div class="informalexample"><pre class="programlisting">var stringOne = "hElLo"
print("capitalizedString:  " + stringOne.capitalizedString)
print("lowercaseString:  " + stringOne.lowercaseString)
print("uppercaseString:  " + stringOne.uppercaseString)</pre></div><p>If we run this code, the results will be as follows:</p><div class="informalexample"><pre class="programlisting">capitalizedString:  Hello
lowercaseString:  hello
uppercaseString:  HELLO</pre></div><p>Swift provides four ways to compare a string; these are <code class="literal">string equality</code>, <code class="literal">prefix equality</code>, <code class="literal">suffix equality</code>, and <code class="literal">isEmpty</code>. The following example demonstrates these ways:</p><div class="informalexample"><pre class="programlisting">var stringOne = "Hello Swift"
var stringTwo = ""
stringOne.isEmpty  //false
stringTwo.isEmpty  //true
stringOne == "hello swift"  //false
stringOne == "Hello Swift"  //true
stringOne.hasPrefix("Hello")  //true
stringOne.hasSuffix("Hello")  //false</pre></div><p>We can replace <a class="indexterm" id="id77"/>all the occurrences of a target string with another string. This is done with the <code class="literal">stringByReplacingOccurrencesOfString()</code>method. The following code demonstrates this:</p><div class="informalexample"><pre class="programlisting">var stringOne = "one,to,three,four"
print(stringOne.stringByReplacingOccurrencesOfString("to", withString: "two"))</pre></div><p>The preceding example will print <code class="literal">one</code>,<code class="literal">two</code>,<code class="literal">three</code>,<code class="literal">four</code> to the screen because we are replacing all the occurrences of <code class="literal">to</code> with <code class="literal">two</code>.</p><p>We can also retrieve substrings and individual characters from our strings. The following examples show various ways to do this:</p><div class="informalexample"><pre class="programlisting">var path = "/one/two/three/four"
//Create start and end indexes
var startIndex = path.startIndex.advancedBy(4)
var endIndex = path.startIndex.advancedBy(14)
path.substringWithRange(Range(start:startIndex, end:endIndex))   //returns the String /two/three

path.substringToIndex(startIndex)  //returns the String /one
path.substringFromIndex(endIndex)  //returns the String /four
path.characters.last  //returns the last character in the String which is r
path.characters.first  //returns the first character in the String which is /</pre></div><p>In the preceding example, we use the <code class="literal">substringWithRange()</code> function to retrieve the substring between a start and end index. The indexes are created with the <code class="literal">startIndex.advanceBy()</code> function. The <code class="literal">startIndex</code> property return the index of the first character in the string and then we use the <code class="literal">advancedBy()</code> method to advance the index to the desired number of positions.</p><p>The <code class="literal">substringToIndex()</code> function create a substring from the beginning of the string to the index. The <code class="literal">substringFromIndex()</code> function create a substring from the index to the end of the string. We<a class="indexterm" id="id78"/> then used the <code class="literal">last</code> property to get the last character of the string and the <code class="literal">first</code> property to get the first character.</p><p>We can retrieve the number of characters in a string by using the count property. The following example shows how you can use this function:</p><div class="informalexample"><pre class="programlisting">var path = "/one/two/three/four"
var length = path.characters.count</pre></div><p>This completes our <a class="indexterm" id="id79"/>whirlwind tour of strings. I know we went through these properties and functions very quickly, but we will be using strings extensively throughout this book, so we will have a lot of time to get used to them.</p></div><div class="section" title="Optional variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Optional variables</h2></div></div></div><p>All of the<a class="indexterm" id="id80"/> variables, which we have looked at so far, are considered to be non-optional variables. This means that the variables are required to have a non-nil value; however, there are times when we want or need our variables to contain <code class="literal">nil</code> values. This can occur if we return a <code class="literal">nil</code> from a function whose operation failed or if a value is not found.</p><p>In Swift, an optional variable<a class="indexterm" id="id81"/> is a variable that we are able to assign <code class="literal">nil</code> (no value) to. Optional variables and constants are defined using <code class="literal">?</code> (question mark). Let's look at the following Playground; it shows us how to define <code class="literal">Optional</code> and shows what happens if we assign a <code class="literal">nil</code> value to a <code class="literal">Non-Optional</code> variable:</p><div class="mediaobject"><img alt="Optional variables" src="graphics/B05115_02_07.jpg"/></div><p>Notice the error <a class="indexterm" id="id82"/>we receive when we try to assign a <code class="literal">nil</code> value <a class="indexterm" id="id83"/>to the non-optional variable. This error message tells us that the <code class="literal">stringTwo</code> variable does not conform to the <code class="literal">NilLiteralConvertible</code> protocol. When we see this error, remember that it means that we are assigning a <code class="literal">nil</code> value to a variable or constant that is not defined as an optional type.</p><p>Optional variables were added to the Swift language as a safety feature. They provide a compile time check of our variables to verify that they contain a valid value. Unless our code specifically defines a variable as optional, we can assume that the variable contains a valid value, and we do not have to check for <code class="literal">nil</code> values. Since we are able to define a variable prior to initiating it, this could give us a <code class="literal">nil</code> value in a non-optional variable; however, the compiler checks for this. The following Playground shows the error that we receive if we attempt to use a non-optional variable prior to initiating it:</p><div class="mediaobject"><img alt="Optional variables" src="graphics/B05115_02_08.jpg"/></div><p>To verify that an <a class="indexterm" id="id84"/>optional variable or constant contains a valid (non-nil) value, our first thought may be to use the <code class="literal">!=</code> (not equals to) operator to verify that the variable is not equal to <code class="literal">nil</code>, but there are also other ways. These other <a class="indexterm" id="id85"/>ways are <code class="literal">Optional Binding</code> and <code class="literal">Optional Chaining</code>. Before we cover optional binding and optional chaining, let's see how to use the <code class="literal">!=</code> (not equals to) operator and what force unwrapping is.</p><p>To use force unwrapping, we must first make sure that the optional has a non-nil value and then we can use the explanation point to access that value. The following example shows how we can do this:</p><div class="informalexample"><pre class="programlisting">var name: String?
Name = "Jon"

if name != nil {
    var newString = "Hello " + name!
}</pre></div><p>In this example, we create an optional variable named <code class="literal">name</code> and we assign it a value of <code class="literal">Jon</code>. We then use the <code class="literal">!=</code> operator to verify that the optional is not equal to <code class="literal">nil</code>. If it is not equal to <code class="literal">nil</code>, we are then able to use the explanation point to access its value. While this is a perfectly viable option, it is recommended that we use the optional binding method discussed next instead of force unwrapping.</p><p>We use optional binding to check whether an optional variable or constant has a non-nil value, and, if so, assign that value to a temporary variable. For optional binding, we use the <code class="literal">if-let</code> or <code class="literal">if-var</code> keywords together. If we use <code class="literal">if-let</code>, the temporary value is a constant and cannot be changed, while the <code class="literal">if-var</code> keywords puts the temporary value into a variable that allows us to change the value. The following code illustrates how optional binding is used:</p><div class="informalexample"><pre class="programlisting">if let temp = myOptional {
    print(temp)
    print("Can not use temp outside of the if bracket")
} else {
    print("myOptional was nil")
}</pre></div><p>In the preceding <a class="indexterm" id="id86"/>example, we use the <code class="literal">if let</code> keywords to check whether the <code class="literal">myOptional</code> variable is <code class="literal">nil</code>. If it is not <code class="literal">nil</code>, we assign the value to the <code class="literal">temp</code> variable and execute the code between the brackets. If the <code class="literal">myOptional</code> variable is <code class="literal">nil</code>, we execute the code in the <code class="literal">else</code> bracket, which prints out the message, <code class="literal">myOptional was nil</code>. One thing to note is that the <code class="literal">temp</code> variable is scoped only for the conditional block and cannot be used outside of the conditional block.</p><p>It is perfectly <a class="indexterm" id="id87"/>acceptable with optional binding to assign the value to a variable of the same name. The following code illustrates this:</p><div class="informalexample"><pre class="programlisting">if let myOptional = myOptional {
    print(myOptional)
    print("Can not use temp outside of the if bracket")
} else {
    print("myOptional was nil")
}</pre></div><p>To illustrate the scope of the temporary variable, let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">var myOptional: String?

myOptional = "Jon"
print("Outside: \(myOptional)")

if var myOptional = myOptional {
    myOptional = "test"
    print("Inside:  \(myOptional)")
}

print("Outside: \(myOptional)")</pre></div><p>In this example, the first line that is printed to the console is <code class="literal">Inside: Optional</code>(<code class="literal"> test</code>) because we are within the scope of the <code class="literal">if-var</code> statement where we assign the value of <code class="literal">test</code> to the <code class="literal">myOptional</code> variable. The second line that is printed to the console would be <code class="literal">Outside:  Optional</code>(<code class="literal">Jon</code>) because we are outside of the scope of the <code class="literal">if-var</code> statement where the <code class="literal">myOptional</code> variable is set to <code class="literal">Jon</code>.</p><p>We can also test multiple optional variables in one line. We do this by separating each optional check with a comma. The following example shows how to do this:</p><div class="informalexample"><pre class="programlisting">if let myOptional = myOptional, myOptional2 = myOptional2, myOptional3 = myOptional3 {
  // only reach this if all three optionals
  // have non-nil values
}</pre></div><p>Optional<a class="indexterm" id="id88"/> chaining allows us to call properties, methods, and <a class="indexterm" id="id89"/>subscripts on an optional that might be <code class="literal">nil</code>. If any of the chained values return <code class="literal">nil</code>, the return value will be <code class="literal">nil</code>. The following code gives an example of optional chaining using a fictitious <code class="literal">car</code> object. In this example, if either <code class="literal">car</code> or <code class="literal">tires</code> are <code class="literal">nil</code>, the variable <code class="literal">s</code> will be <code class="literal">nil</code>; otherwise, <code class="literal">s</code> will be equal to the <code class="literal">tireSize</code> property:</p><div class="informalexample"><pre class="programlisting">var s = car?.tires?.tireSize</pre></div><p>The following Playground illustrates the three ways to verify whether the optionals contain a valid value prior to using them:</p><div class="mediaobject"><img alt="Optional variables" src="graphics/B05115_02_09.jpg"/></div><p>In the preceding Playground, we begin by defining the optional string variable, <code class="literal">stringOne</code>. We then explicitly check for <code class="literal">nil</code> by using the <code class="literal">!=</code> operator. If <code class="literal">stringOne</code> is not equal to <code class="literal">nil</code>, we <a class="indexterm" id="id90"/>print the value of <code class="literal">stringOne</code> to the console. If <code class="literal">stringOne</code> is <code class="literal">nil</code>, we print the <code class="literal">Explicit Check: stringOne is nil</code> message to the console. As we can see in the results console, <code class="literal">Explicit Check: stringOne is nil is</code> printed to the console because we have not assigned a value to <code class="literal">stringOne</code> yet.</p><p>We then use <a class="indexterm" id="id91"/>optional binding to verify that <code class="literal">stringOne</code> is not <code class="literal">nil</code>. If <code class="literal">stringOne</code> is not <code class="literal">nil</code>, the value of <code class="literal">stringOne</code> is put into the <code class="literal">tmp</code> temporary variable, and we print the value of <code class="literal">tmp</code> to the console. If <code class="literal">stringOne</code> is <code class="literal">nil</code>, we print the <code class="literal">Optional Binding</code>: <code class="literal">stringOne</code> is <code class="literal">nil</code> message to the console. As we can see in the results console, <code class="literal">Optional Binding</code>: <code class="literal">stringOne is nil</code> is printed to the console because we have not assigned a value to <code class="literal">stringOne</code> yet.</p><p>We use optional chaining to assign the value of the <code class="literal">characters.count</code> property of the <code class="literal">stringOne</code> variable to the <code class="literal">charCount1</code> variable if <code class="literal">stringOne</code> is not <code class="literal">nil</code>. As we can see, the <code class="literal">charCount1</code> variable is <code class="literal">nil</code> because we have not assigned a value to <code class="literal">stringOne</code> yet.</p><p>We then assign a value of <a class="ulink" href="http://www.packtpub.com/all">http://www.packtpub.com/all</a> to the <code class="literal">stringOne</code> variable and rerun all the three tests again. This time <code class="literal">stringOne</code> has a non-nil value; therefore, the value of <code class="literal">charCount2</code> is printed to the console.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>It would be tempting to say that I may need to set this variable to <code class="literal">nil</code>, so let me define it as optional, but that would be a mistake. The mindset for optionals should be to only use them if there is a specific reason for the variable to have <code class="literal">nil</code> value.</p></div></div></div><div class="section" title="Enumerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Enumerations</h2></div></div></div><p>Enumerations (otherwise known as enums) are <a class="indexterm" id="id92"/>a special data type that enables us to group related types<a class="indexterm" id="id93"/> together and use them in a type safe manner. For those of us who are familiar with enums from other languages, such as C or Java, enums in Swift are not tied to integer values. We can define an enum with a type (string, character, integer, or floating-point) and then it's actual value (known as the raw value) will be the assigned value. Enums also support features that are traditionally supported only by classes such as computed properties and instance methods. We will discuss these advanced features in depth in <a class="link" href="ch05.html" title="Chapter 5. Classes and Structures">Chapter 5</a>, <span class="emphasis"><em>Classes and Structures</em></span>. In this section, we will look at the traditional enum features.</p><p>We will define an enum that contains the list of <code class="literal">Planets</code> like this:</p><div class="informalexample"><pre class="programlisting">enum Planets {
    case Mercury
    case Venus
    case Earth
    case Mars
    case Jupiter
    case Saturn
    case Uranus
    case Neptune
}</pre></div><p>The values <a class="indexterm" id="id94"/>defined in an enum are considered to be the member values (or simply the members) of the enum. In most cases, you will see the <a class="indexterm" id="id95"/>member values defined like the preceding example because it is easy to read; however, there is a shorter version. This shorter version lets us define multiple members in a single line, separated by commas, as the following example shows:</p><div class="informalexample"><pre class="programlisting">enum Planets {
    case Mercury, Venus, Earth, Mars, Jupiter
    case Saturn, Uranus, Neptune
}</pre></div><p>We can then use the <code class="literal">Planets</code> enum like this:</p><div class="informalexample"><pre class="programlisting">var planetWeLiveOn = Planets.Earth
var furthestPlanet = Planets.Neptune</pre></div><p>The type for the <code class="literal">planetWeLiveOn</code> and <code class="literal">furthestPlanet</code> variables is inferred when we initialize the variable with one of the member values of <code class="literal">Planets</code>. Once the variable type is inferred, we can then assign a new value without the <code class="literal">Planets</code> prefix, as shown here:</p><div class="informalexample"><pre class="programlisting">planetWeLiveOn = .Mars</pre></div><p>We can match an enum value using the traditional equals (<code class="literal">==</code>) operator or use a <code class="literal">switch</code> statement. The following example shows how to use the <code class="literal">equals</code> operator and the <code class="literal">switch</code> statement with an enum:</p><div class="informalexample"><pre class="programlisting">// Using the traditional == operator
if planetWeLiveOn == .Earth {
    print("Earth it is")
}
// Using the switch statement
switch planetWeLiveOn {
case .Mercury:
    print("We live on Mercury, it is very hot!")
case .Venus:
    print("We live on Venus, it is very hot!")
case .Earth:
    print("We live on Earth, just right")
case .Mars:
    print("We live on Mars, a little cold")
default:
    print("Where do we live?")
}</pre></div><p>Enums can <a class="indexterm" id="id96"/>come prepopulated with raw values, which <a class="indexterm" id="id97"/>are required to be of the same type. This means that we can define our enum to contain string, character, integer, or floating-point values, but all of the members must be defined as the same type. The following example shows how to define an enum with string values:</p><div class="informalexample"><pre class="programlisting">enum Devices: String {
    case iPod = "iPod"
    case iPhone = "iPhone"
    case iPad = "iPad"
}
print("We are using an " + Devices.iPad.rawValue)</pre></div><p>The preceding example creates an enum with three Apple devices. We then use the <code class="literal">rawValue</code> property to retrieve the raw value for the iPad member of the <code class="literal">Devices</code> enum. This example will print a message, saying <code class="literal">We are using an iPad</code>.</p><p>Let's create another <code class="literal">Planets</code> enum, but this time, assign numbers to the members, as follows:</p><div class="informalexample"><pre class="programlisting">enum Planets: Int  {
    case Mercury = 1
    case Venus
    case Earth
    case Mars
    case Jupiter
    case Saturn
    case Uranus
    case Neptune
}
print("Earth is planet number \(Planets.Earth.rawValue)")</pre></div><p>The big difference between the two enum examples is that in the second example, we only assign a value to the first member (<code class="literal">Mercury</code>). If integers are used for the raw values of an enum, we do not have to assign a value to each member. If no value is present, the raw values will be auto-incremented.</p><p>In Swift, enums can also have associated values. Associate values allow us to store additional information along with member values. This additional information can vary each time we use the member. It can also be of any type, and the types can be different for each member. Let's take a look at how we might use associate types by defining a <code class="literal">Product</code> enum, which <a class="indexterm" id="id98"/>contains two types of products:</p><div class="informalexample"><pre class="programlisting">enum Product {
    case Book(Double, Int, Int)
    case Puzzle(Double, Int)
}
var masterSwift = Product.Book(49.99, 2015, 310)
var worldPuzzle = Product.Puzzle(9.99, 200)

switchmasterSwift {
case .Book(let price, let year, let pages):
    print("Mastering Swift was published in \(year) for the price of \(price) and has \(pages) pages")
case .Puzzle(let price, let pieces):
    print("Master Swift is a puzze with \(pieces) and sells for \(price)")
}

switchworldPuzzle {
case .Book(let price, let year, let pages):
    print("World Puzzle was published in \(year) for the price of \(price) and has \(pages) pages")
case .Puzzle(let price, let pieces):
    print("World Puzzle is a puzze with \(pieces) and sells for \(price)")
}</pre></div><p>In the preceding <a class="indexterm" id="id99"/>example, we begin by defining a <code class="literal">Product</code> enum with two members—<code class="literal">Book</code> and <code class="literal">Puzzle</code>. The <code class="literal">Book</code> member has an associated value of <code class="literal">Double</code>, <code class="literal">Int</code>, <code class="literal">Int</code>, and the <code class="literal">Puzzle</code> member has an associated value of <code class="literal">Double, Int</code>. We then create two products <code class="literal">masterSwift</code> and <code class="literal">worldPuzzle</code>. We assign the <code class="literal">masterSwift</code> variable a value of <code class="literal">Product.Book</code> with the associated values of <code class="literal">49.99, 2015, 310</code>. We then assign the <code class="literal">worldPuzzle</code> variable a value of <code class="literal">Product.Puzzle</code> with the associated values of <code class="literal">9.99, 200</code>.</p><p>We can then check the <code class="literal">Products</code> enum using a <code class="literal">switch</code> statement, as we did in some of the preceding enum examples. We also extract the associated values within the <code class="literal">switch</code> statement. In the previous example, we extracted the associated values as constants with the <code class="literal">let</code> keyword, but you can also extract the associated values as variables with the <code class="literal">var</code> keyword.</p><p>If you put the previous code into a Playground, the following results will be displayed:</p><div class="informalexample"><pre class="programlisting">"Master Swift was published in 2015 for the price of 49.99 and has 310 pages"
"World Puzzle is a puzzle with 200 and sells for 9.99"</pre></div></div></div></div>
<div class="section" title="Operators"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Operators</h1></div></div></div><p>An operator <a class="indexterm" id="id100"/>is a symbol or combination of symbols that we can use to check, change, or combine values. We have used operators in most of the examples so far in this book; however, we did not specifically call them operators. In this section, we will show how to use most of the basic operators that Swift supports.</p><p>Swift supports most standard C operators and also improves them to eliminate several common coding errors. For example, the assignment operator does not return a value to prevent it from being used when the equality operator (<code class="literal">==</code>) was meant to be used.</p><p>Let's look at the operators in Swift.</p><div class="section" title="The assignment operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>The assignment operator</h2></div></div></div><p>The<a class="indexterm" id="id101"/> assignment operator<a class="indexterm" id="id102"/> initializes or updates a variable.</p><p>Prototype:</p><div class="informalexample"><pre class="programlisting">varA = varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">let x = 1
var y = "Hello"
a = b</pre></div></div><div class="section" title="Comparison operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Comparison operators</h2></div></div></div><p>The<a class="indexterm" id="id103"/> comparison operator <a class="indexterm" id="id104"/>returns a Boolean <code class="literal">true</code> if the statement is true or a Boolean <code class="literal">false</code> if the statement is not true.</p><p>Prototypes:</p><div class="informalexample"><pre class="programlisting">Equality:  varA == varB
Not equal:  varA != varB
Greater than:  varA &gt; varB
Less than:  varA &lt; varB
Greater than or equal to:  varA &gt;= varB
Less than or equal to:  varA &lt;= varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">2 == 1 //false, 2 does not equal 1
2 != 1 //true, 2 does not equal 1
2 &gt; 1  //true, 2 is greater than 1
2 &lt; 1  //false, 2 is not less than 1
2 &gt;= 1 //true, 2 is greater or equal to 1
2 &lt;= 1 //false, 2 is not less or equal to 1</pre></div></div><div class="section" title="Arithmetic operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Arithmetic operators</h2></div></div></div><p>The <a class="indexterm" id="id105"/>arithmetic operators<a class="indexterm" id="id106"/> perform the four basic mathematical operations.</p><p>Prototypes:</p><div class="informalexample"><pre class="programlisting">Addition:  varA + varB
Subtraction:  varA – varB
Multiplication:  varA * varB
Division:  varA / varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = 4 + 2  //x will equal 6
var x = 4 – 2  //x will equal 2
var x = 4 * 2  //x will equal 8
var x = 4 / 2  //x will equal 2
var x = "Hello " + "world"  //x will equal "Hello World"</pre></div></div><div class="section" title="The remainder operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>The remainder operator</h2></div></div></div><p>The <a class="indexterm" id="id107"/>remainder operator<a class="indexterm" id="id108"/> calculates the remainder if the first operand is divided by the second operand.</p><p>Prototype:</p><div class="informalexample"><pre class="programlisting">varA % varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = 10 % 3  //x will equal 1
var x = 10 % 2.6  //x will equal 2.2</pre></div></div><div class="section" title="Increment and decrement operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Increment and decrement operators</h2></div></div></div><p>The <a class="indexterm" id="id109"/>increment and decrement operators<a class="indexterm" id="id110"/> are shortcuts to increment or decrement a variable by <code class="literal">1</code>.</p><p>Prototypes:</p><div class="informalexample"><pre class="programlisting">++varA - Increments the value of varA and then returns the value
varA++ - Returns the values of varA and then increments varA
--varA – Decrements the value of varA and then returns the value
varA-- - Returns the value of varA and then decrements varA</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = 5
var y = ++x  //Both x and y equals 6
var y = x++  //x equals 6 but y equals 5
var y = --x  //Both x and y equals 4
var y = x--  //x equals 4 but y equals 5</pre></div></div><div class="section" title="Compound assignment operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Compound assignment operators</h2></div></div></div><p>The <a class="indexterm" id="id111"/>compound assignment operators<a class="indexterm" id="id112"/> combine an arithmetic operator with an assignment operator.</p><p>Prototypes:</p><div class="informalexample"><pre class="programlisting">varA += varB
varA -= varB
varA *= varB
varA /= varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = 6
x += 2  //x is equal to 8
x -= 2  //x is equal to 4
x *= 2  //x is equal to 12
x /= 2  //x is equal to 3</pre></div></div><div class="section" title="The ternary conditional operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>The ternary conditional operator</h2></div></div></div><p>The <a class="indexterm" id="id113"/>ternary conditional operator<a class="indexterm" id="id114"/> assigns a value to a variable, based on the evaluation of a comparison operator or Boolean value.</p><p>Prototype:</p><div class="informalexample"><pre class="programlisting">(boolValue ? valueA : valueB)</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = 2
var y = 3
var z = (y &gt; x ? "Y is greater" : "X is greater")  //z equals "Y is greater"</pre></div></div><div class="section" title="The logical NOT operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>The logical NOT operator</h2></div></div></div><p>The<a class="indexterm" id="id115"/> logical NOT operator<a class="indexterm" id="id116"/> inverts a Boolean value.</p><p>Prototype:</p><div class="informalexample"><pre class="programlisting">varA = !varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = true
var y = !x  //y equals false</pre></div></div><div class="section" title="The logical AND operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>The logical AND operator</h2></div></div></div><p>The<a class="indexterm" id="id117"/> logical AND operator<a class="indexterm" id="id118"/> returns <code class="literal">true</code> if both operands are true, otherwise it returns <code class="literal">false</code>.</p><p>Prototype:</p><div class="informalexample"><pre class="programlisting">varA &amp;&amp; varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = true
var y = false
var z = x &amp;&amp; y  //z equals false</pre></div></div><div class="section" title="The logical OR operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>The logical OR operator</h2></div></div></div><p>The<a class="indexterm" id="id119"/> logical OR operator <a class="indexterm" id="id120"/>returns <code class="literal">true</code> if either of the operands is true.</p><p>Prototype:</p><div class="informalexample"><pre class="programlisting">varA || varB</pre></div><p>Example:</p><div class="informalexample"><pre class="programlisting">var x = true
var y = false
var z = x || y  //z equals true</pre></div><p>For those who are familiar with C and languages that have a similar syntax to C, these operators should look pretty familiar. For those who aren't that familiar with the C operators, rest assured that you will use them enough and they will become second nature.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we covered a lot of different topics. These topics ranged from variables and constants to data types and operators. The items in this chapter will be the foundation of every application that you write; therefore, it is important to understand the concepts discussed here.</p><p>In the next chapter, we will look at how we can use the Swift collection types to store related data. These collection types are the dictionary and array types. We will also look at how we can use the Cocoa and Foundation data types in Swift.</p></div></body></html>