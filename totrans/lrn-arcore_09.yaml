- en: Blending Light for Architectural Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建筑设计的灯光融合
- en: 'This is the first of two chapters where we will build real-world AR apps that
    you can learn from and show off to friends and family. Unlike in the previous
    chapters, this time we will build our AR app from nothing. That way, we can learn
    the specific details needed for incorporating ARCore into a Unity project. We
    have a lot to cover in this chapter, so let''s get started. Listed here is a quick
    summary of the main topics we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个章节中的第一个，我们将构建现实世界的AR应用，您可以从中学习并向朋友和家人展示。与前面的章节不同，这次我们将从零开始构建我们的AR应用。这样，我们可以学习将ARCore集成到Unity项目中所需的具体细节。在本章中，我们将有很多内容要介绍，所以让我们开始吧。以下是我们将涵盖的主要主题的快速总结：
- en: Setting up the project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Placing content
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置内容
- en: Building the UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建UI
- en: Interacting with the virtual
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与虚拟交互
- en: Lighting and shadows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光和阴影
- en: The premise for our app will be an AR tool for architecture and design. The
    designing apps are very popular in AR right now and fit very well with the toolkit
    ARCore provides.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的前提是一个用于建筑和设计的AR工具。目前，设计应用在AR领域非常受欢迎，并且非常适合ARCore提供的工具集。
- en: Being able to virtually place objects in or over a real-world object and instantly
    see how it looks has a tremendous benefit to designers and architects. Now a designer
    using an AR app can instantly transform a space with their vision. Imagine never
    having to move a couch 15 times to get it just right, ever again.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在或超过真实世界物体中虚拟放置对象，并立即看到它的样子，这对设计师和建筑师来说有巨大的好处。现在，使用AR应用的设计师可以立即用他们的愿景改变空间。想象一下，再也不用移动沙发15次才能把它放得恰到好处。
- en: Setting up the project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'We will use the sample project as a template for creating a new project. At
    the time of writing, doing an ARCore asset import with the beta version still
    requires considerable project setup. Ideally, we would like to create a project
    from scratch, but we will do the next best thing. The next best thing will be
    to clone the project from GitHub into a new folder of our choice. You can start
    by opening up Command Prompt and following these steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用示例项目作为创建新项目的模板。在撰写本文时，使用beta版本进行ARCore资产导入仍然需要相当的项目设置。理想情况下，我们希望从头开始创建项目，但我们将做下一件最好的事情。下一件最好的事情是将项目从GitHub克隆到我们选择的新的文件夹中。你可以通过打开命令提示符并按照以下步骤开始：
- en: 'Create a new folder off your root or working folder and download the ARCore
    template by executing the following commands:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的根文件夹或工作文件夹中创建一个新的文件夹，并执行以下命令来下载ARCore模板：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a new folder. Switch to it and download the project template
    from GitHub.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个新的文件夹。切换到它，并从GitHub下载项目模板。
- en: Open up Unity to the project dialog and click on **Open**.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Unity到项目对话框，并点击**打开**。
- en: 'Use the folder dialog to find and select the `ARCoreDesign` folder we just
    downloaded the code to, as shown in the following excerpt:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件夹对话框找到并选择我们刚刚将代码下载到的`ARCoreDesign`文件夹，如下所示：
- en: '![](img/03d52c88-72fb-43a3-932b-7903453ced1b.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03d52c88-72fb-43a3-932b-7903453ced1b.png)'
- en: Opening the ARCoreDesign project
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 打开ARCoreDesign项目
- en: Wait for Unity to load. Ensure that you watch for any compiler errors at the
    bottom of the editor status bar. If you see them, it means you may have a version
    conflict or that something's changed. Check your version and try to upgrade or
    downgrade, as needed.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Unity加载。确保注意编辑器状态栏底部的任何编译器错误。如果您看到它们，这意味着您可能有一个版本冲突，或者某些东西已经改变。检查您的版本，并根据需要尝试升级或降级。
- en: The first thing we will do is organize our folder structure. Create a new folder
    called `ARCore_Design`in the Project window by right-clicking (*Ctrl* + Click
    on Mac) on the `Assets` folder and selecting Create | Folder from the context
    menu.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是组织我们的文件夹结构。在项目窗口中，通过右键单击（*Ctrl* + 点击Mac）`Assets`文件夹，并从上下文菜单中选择创建 | 文件夹来创建一个名为`ARCore_Design`的新文件夹。
- en: 'Directly underneath the new folder, add folders for `Scripts`, `Prefabs`, `Scenes`,
    `Materials`, and `Models`, as illustrated:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹下方，添加`Scripts`、`Prefabs`、`Scenes`、`Materials`和`Models`文件夹，如图所示：
- en: '![](img/ed9bedf2-bf49-4779-b1d0-121514a3d820.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed9bedf2-bf49-4779-b1d0-121514a3d820.png)'
- en: Setting up the folder structure
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文件夹结构
- en: The technique we just used for setting up the project is useful when you are
    dealing with other sample projects you want to make your own. Unity manages a
    project by the folder and the name corresponds to the folder name. We won't worry
    about setting up source control as you can do this on your own, as you see fit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才用于设置项目的技术，当您处理其他您想要自己定制的样本项目时非常有用。Unity 通过文件夹来管理项目，名称与文件夹名称相对应。我们不会担心设置源代码控制，因为您可以根据自己的需要自行完成。
- en: If you are setting up this project for anything other than learning, you should
    definitely consider a source code solution at this point. Dropbox or other file
    sharing solutions will work in a pinch, but it's not something that will work
    for more than one developer. There are plenty of free and fairly simple solutions
    that work with Unity, so take some time and pick one that works for you.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在设置这个项目不是为了学习，那么您现在应该考虑一个源代码解决方案。Dropbox 或其他文件共享解决方案在紧急情况下可以工作，但这不是适合多个开发者的解决方案。有很多免费且相对简单的解决方案与
    Unity 一起工作，所以花些时间选择一个适合您的方案。
- en: Building the scene
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建场景
- en: 'In order for us to save some time, we will load the `HelloAR` scene and modify
    it to meet our needs. Follow along the given steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省我们一些时间，我们将加载 `HelloAR` 场景并将其修改以满足我们的需求。按照以下步骤操作：
- en: Open the `HelloAR` scene in the `Assets/GoogleARCore/HelloARExample/Scenes`
    folder by double-clicking on it.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击它来打开 `Assets/GoogleARCore/HelloARExample/Scenes` 文件夹中的 `HelloAR` 场景。
- en: From the menu, select File | Save Scene as, save the scene in the new `Assets/ARCore_Design/Scenes`
    folder, and name it as `Main`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择文件 | 保存场景为，将场景保存在新的 `Assets/ARCore_Design/Scenes` 文件夹中，并将其命名为 `Main`。
- en: Apart from the samples we worked with earlier, from now on, if we need to modify
    a file, we will copy it to a new appropriate folder, and rename it. This is a
    good practice to follow when modifying external assets. That way, when you update
    the asset with a new version, your changes will not be overwritten.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前使用的样本之外，从现在开始，如果我们需要修改一个文件，我们将将其复制到一个新的适当文件夹中，并重命名它。在修改外部资产时，这是一个很好的实践。这样，当你用新版本更新资产时，你的更改不会被覆盖。
- en: From the menu, select **Edit** | **Project Settings** | **Player**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择 **编辑** | **项目设置** | **播放器**。
- en: 'At the Inspector window, click on the Android tab and edit the Package Name
    to `com.Packt.ARCoreDesign`, as shown in the following screen excerpt:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中，点击 Android 选项卡，并将包名修改为 `com.Packt.ARCoreDesign`，如以下屏幕截图所示：
- en: '![](img/490bff9b-fa75-4704-b508-4a05bd59a6db.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/490bff9b-fa75-4704-b508-4a05bd59a6db.png)'
- en: Editing the package name in the Player settings
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放器设置中编辑包名
- en: From the menu, select File | Build Settings.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择文件 | 构建设置。
- en: 'Click on the checkbox on the `HelloAR` scene to turn it off. Then, click on Add
    Open Scenes to add the new `Main` scene to the build. Ensure that the Android
    option is selected for the Platform, and confirm that everything is set, as shown
    in the following excerpt:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `HelloAR` 场景上的复选框以将其关闭。然后，点击 **添加打开的场景** 以将新的 `Main` 场景添加到构建中。确保平台选项为 Android，并确认一切设置正确，如以下摘录所示：
- en: '![](img/5ee94210-c52d-48bf-92cd-c6fa1f99826f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ee94210-c52d-48bf-92cd-c6fa1f99826f.png)'
- en: Setting the Build Settings
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 设置构建设置
- en: Connect your device and then click on Build And Run. You will be prompted to
    save the APK. Enter the same name you used for the package (`com.Packt.ARCoreDesign`)
    and click on Save. This will kick off the build. A first build can take a while,
    so grab a beverage or take a quick break.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备，然后点击 **构建并运行**。您将提示保存 APK。输入您用于包的相同名称（`com.Packt.ARCoreDesign`）并点击 **保存**。这将启动构建。第一次构建可能需要一些时间，所以拿一杯饮料或稍作休息。
- en: Run the app on your device and confirm that everything runs as you expect it
    to. If anything fails, refer to [Chapter 11](e7c0bdd1-e380-4498-af5a-fe9e627eb6cb.xhtml),
    *Performance Tips and Troubleshooting*, for help.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备上运行应用程序，并确认一切按预期运行。如果出现任何问题，请参考第 11 章，*性能提示和故障排除*，以获取帮助。
- en: As you work through the exercises in this chapter, try and build as often as
    possible. A build can quickly tell you if you have any major issues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成本章的练习时，尽可能经常构建。构建可以快速告诉您是否有任何重大问题。
- en: Modifying the base scene
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改基础场景
- en: 'The next thing we will do is just modify the base scene for our needs. Open
    up Unity and follow along:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的就是修改基础场景以满足我们的需求。打开 Unity 并按照以下步骤操作：
- en: 'Select and drag the PointCloud object in the Hierarchy window and drop it into
    the `Assets/ARCoreDesign/Prefabs` folder in the Project window, as shown in the
    following excerpt:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择并拖动PointCloud对象，并将其拖放到项目窗口中的`Assets/ARCoreDesign/Prefabs`文件夹中，如下所示：
- en: '![](img/f7a5e0a3-93eb-400f-9296-ca231e812b88.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7a5e0a3-93eb-400f-9296-ca231e812b88.png)'
- en: Creating a prefab with the PointCloud object
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PointCloud对象创建预制件
- en: This will create a Prefab of the PointCloud object. Think of a Prefab as a template
    or almost like a class. Anytime we want to reuse the PointCloud object, we can
    drag it into a scene or instantiate it.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建PointCloud对象的预制件。将预制件想象成一个模板或几乎就像一个类。任何时候我们想要重复使用PointCloud对象，我们都可以将其拖入场景或实例化它。
- en: Select the PointCloud object in the Hierarchy window and type the Delete key.
    Find it, and click on it. This will delete the object; we don't need it right
    now.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择PointCloud对象，并按Delete键。找到它，并点击它。这将删除该对象；我们现在不需要它。
- en: Rename the `ExampleController` object in the Hierarchy window to `SceneController`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中将`ExampleController`对象重命名为`SceneController`。
- en: Select the `Assets/ARCoreDesign/Scripts` folder and from the menu, select Assets
    | Create | C# Script. Name the script `SceneController`. Then, double-click on
    it to open the script in your favorite code editor.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/ARCoreDesign/Scripts`文件夹中选择，从菜单中选择Assets | Create | C# Script。将脚本命名为`SceneController`。然后双击它以在最喜欢的代码编辑器中打开脚本。
- en: Now, get back to Unity. Enter `helloarcontroller` in the Project search pane
    to filter the window to the script. Double-click on the script to open it in your
    code editor.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到Unity。在项目搜索面板中输入`helloarcontroller`以过滤窗口到脚本。双击脚本以在代码编辑器中打开它。
- en: 'Copy the entire `HelloARController.cs` script and paste it over the contents
    of the `SceneController.cs` file; yes, all of it. We are essentially making a
    copy. Rename your class and change the namespace, like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个`HelloARController.cs`脚本复制并粘贴到`SceneController.cs`文件的内容上；是的，全部。我们实际上是在制作一个副本。重命名你的类并更改命名空间，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We wrap all our new code files with a `namespace` in order to avoid naming conflicts.
    Naming conflicts happen more frequently in Unity if you use a lot of assets. Generally,
    if you are new to Unity, you will use a lot of third-party assets.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用`namespace`包装所有新的代码文件，以避免命名冲突。如果你使用了大量资产，Unity中命名冲突发生的频率更高。一般来说，如果你是Unity的新手，你将使用很多第三方资产。
- en: 'Make sure that all the following new `using` statements are identified, as
    follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以下所有新的`using`语句都已识别，如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the file and return to Unity. Be sure to watch for any compiler errors.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回Unity。务必注意查看任何编译错误。
- en: Select the `SceneController` object in the Hierarchy window and click on the
    Add Component button in the Inspector window.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择`SceneController`对象，并在检查器窗口中点击添加组件按钮。
- en: 'Enter `scene` in the search pane and then select the Scene Controller script,
    as shown in the following excerpt:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索面板中输入`scene`，然后选择以下摘录中的场景控制器脚本：
- en: '![](img/ffd8a509-28f9-48b4-ac52-62c33f3f2854.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffd8a509-28f9-48b4-ac52-62c33f3f2854.png)'
- en: Adding the Scene Controller script as a component
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 添加场景控制器脚本作为组件
- en: Click on the bullseye icon to set the properties for the Scene Controller. Ensure
    that they match Hello AR Controller (Script). When all the properties match, click
    on the **Gear** icon beside the Hello AR Controller (Script) and select Remove
    Component from the context menu. You should now be left with just the Scene Controller
    (Scene) component with the same properties set.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击靶心图标以设置场景控制器的属性。确保它们与Hello AR控制器（脚本）匹配。当所有属性匹配时，点击Hello AR控制器（脚本）旁边的**齿轮**图标，并在上下文菜单中选择移除组件。你现在应该只剩下具有相同属性设置的场景控制器（场景）组件。
- en: Connect, build, and run the app on your device. If you encounter any issues,
    check for compiler errors and ensure that you set up the components correctly.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的设备上连接、构建并运行应用。如果你遇到任何问题，检查编译错误并确保你正确设置了组件。
- en: We can, of course, create duplicates for all the main scripts, but this will
    work for now. Obviously, we have a lot more work to do, but this is a good place
    to start. Ensure that you save the `scene` and your project. In the next section,
    we will look to change the content which we allow our user to place and choose
    where to place.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以为所有主要脚本创建副本，但暂时这样就可以了。显然，我们还有很多工作要做，但这是一个良好的开始。确保保存`场景`和你的项目。在下一节中，我们将查看允许用户放置的内容，并选择放置的位置。
- en: The environment and placing content
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境和放置内容
- en: 'We have already covered the basics of how to interact with the environment
    in order to place content. What we want to do now is swap out and add new content
    (sorry Andy). After all, the whole premise of our design app is visualizing in
    AR how new furniture or other items look in a space. Let''s get to it by opening
    up your favorite web browser and follow along:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何与环境交互以放置内容的基本知识。我们现在想做的交换和添加新内容（对不起，安迪）。毕竟，我们设计应用程序的整个前提是在AR中可视化新家具或其他物品在空间中的样子。让我们通过打开您最喜欢的网络浏览器并跟随操作来开始吧：
- en: Browse to [turbosquid.com](https://www.turbosquid.com/). **TurboSquid** is an
    excellent resource for 3D models, both free and paid.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到[turbosquid.com](https://www.turbosquid.com/)。**TurboSquid**是一个优秀的3D模型资源网站，提供免费和付费模型。
- en: For AR / VR and mixed apps, you will generally want your models to be less detailed.
    Mobile devices such as Android don't render fine detailed models well. Before
    you purchase any models, ensure that you understand what your device's rendering
    limitations are.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AR / VR和混合应用程序，您通常希望模型细节较少。例如，Android等移动设备无法很好地渲染精细的模型。在购买任何模型之前，请确保您了解设备的渲染限制。
- en: Search for `ligne roset`on the site.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站上搜索`ligne roset`。
- en: You can, of course, use any FBX model you like, but try using the one suggested
    the first time. Working with 3D models can be frustrating if you are unsure what
    you are doing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用任何喜欢的FBX模型，但第一次尝试使用建议的模型。如果您不确定自己在做什么，与3D模型一起工作可能会很令人沮丧。
- en: 'Filter your search to free models and select Ligne Roset Citta sofa and armchair,
    as shown:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将搜索过滤为免费模型，并选择Ligne Roset Citta沙发和扶手椅，如下所示：
- en: '![](img/52fa1323-fec8-4b47-a223-294ab57aa1a5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52fa1323-fec8-4b47-a223-294ab57aa1a5.png)'
- en: Downloading models from TurboSquid
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从TurboSquid下载模型
- en: Click on the Download button. You may have to create an account and then sign
    in first.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下载按钮。您可能需要先创建账户并登录。
- en: Click on the link marked `Ligne_Roset_Citta_FBX.zip`. This will download the
    zip file.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标记为`Ligne_Roset_Citta_FBX.zip`的链接。这将下载zip文件。
- en: 'Unzip the file into a new folder and then open the folder. Select and drag
    the `mpm_vol.07_p24.FBX` file into Unity and drop it into the `Assets/ARCore/Models`
    folder, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件解压到新文件夹中，然后打开该文件夹。选择并拖动`mpm_vol.07_p24.FBX`文件到Unity中，并将其拖放到`Assets/ARCore/Models`文件夹中，如下所示：
- en: '![](img/74e3bbae-0624-42ec-a21c-05817927c500.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74e3bbae-0624-42ec-a21c-05817927c500.png)'
- en: Dragging the model into the Models folder
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将模型拖入模型文件夹
- en: 'Select the model and then, in the Inspector window, confirm that Model | Scale Factor
    is set correctly, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模型，然后在检查器窗口中确认Model | 比例因子设置正确，如下所示：
- en: '![](img/33d9f6d9-8305-458a-ba11-3370267db246.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33d9f6d9-8305-458a-ba11-3370267db246.png)'
- en: Checking the model scale after import
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入模型后检查模型比例
- en: In this example, the model is using File Scale, which is set at `0.001`. You
    may need to adjust this depending on what scale your model uses. Right now, this
    scale works.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本例中，模型使用的是文件比例，设置为`0.001`。您可能需要根据模型使用的比例进行调整。目前，这个比例是合适的。
- en: Our model comes complete with `chair` and `sofa`. Fortunately, we can break
    these apart relatively easily. Drag and drop the model into an open area of the
    Hierarchy window. You should see the `chair` and `sofa` get added to the scene.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供的模型包含`chair`和`sofa`。幸运的是，我们可以相对容易地将它们分开。将模型拖放到层次结构窗口的开放区域。您应该会看到`chair`和`sofa`被添加到场景中。
- en: Click on an empty area in the Hierarchy window again to disable the model selection.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在层次结构窗口的空白区域单击以禁用模型选择。
- en: From the menu, select GameObject | Create Empty; rename the object as `sofa`.
    Do this again to create another new object and name it `armchair`. Ensure that
    the `armchair` and `sofa` game objects are set on an origin pose with a position
    of (`0`, `0`, `0`) and rotation of (`0`, `0`, `0`). If you need help, select the
    object and check the Inspector window.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择GameObject | 创建空对象；将对象重命名为`sofa`。再次执行此操作以创建另一个新对象，并将其命名为`armchair`。确保`armchair`和`sofa`游戏对象设置在原点姿态，位置为(`0`,
    `0`, `0`)，旋转为(`0`, `0`, `0`)。如有需要，选择对象并检查检查器窗口。
- en: 'Expand the mpm_vol.07_p24 model, and drag the child `armchair` object and drop
    it on the new `armchair` game object. Repeat this process for the sofa piece,
    and your Hierarchy window should resemble the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开mpm_vol.07_p24模型，将子对象`armchair`拖动到新的`armchair`游戏对象上。为沙发部件重复此过程，您的层次结构窗口应类似于以下内容：
- en: '![](img/d8c1f431-29bb-41e2-8e3b-9731981b6790.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8c1f431-29bb-41e2-8e3b-9731981b6790.png)'
- en: Creating two new models
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个新模型
- en: What we just did is create new anchor points and then break apart our model.
    Anchor points allow us to adjust a model with respect to the fixed anchor. You
    will often need to do this in cases where the modeling software used a different
    reference. This is the case with our model. Select the 24 Ligne Roset Citta armchair
    child object and check the Inspector window.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚才所做的就是创建新的锚点，然后分解我们的模型。锚点允许我们根据固定的锚点调整模型。在建模软件使用不同参考的情况下，您通常需要这样做。我们的模型就是这样。选择24
    Ligne Roset Citta扶手椅子对象，并检查检查器窗口。
- en: 'Change the position of the `armchair` Transform to (`0`, `0.25`, `0`), as illustrated
    here:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“扶手椅”变换的位置更改为（`0`，`0.25`，`0`），如图所示：
- en: '![](img/1485b522-a1b1-437d-af67-a510529269e0.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1485b522-a1b1-437d-af67-a510529269e0.png)'
- en: Setting the position transform of the armchair
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 设置扶手椅的位置变换
- en: Ensure that the position is set to X=`0` and Y=`-.25` and leave the Rotation
    as it is. We are offsetting the position of the `armchair` from where it was and
    down a little. This is because ARCore currently tends to track planes too high;
    hopefully, this will be fixed by the time of release. In any case, you can adjust
    the offset of the position of the `chair` anytime and anyway you want later.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保位置设置为X=`0`和Y=`-.25`，并保持旋转不变。我们正在将“扶手椅”的位置从原位置向下偏移一点。这是因为ARCore目前倾向于跟踪过高的平面；希望到发布时这个问题能够得到解决。无论如何，你可以在以后任何时候以任何方式调整“椅子”的位置偏移。
- en: Drag the `armchair` object from the Hierarchy window and drop it into the `Assets/ARCoreDesign/Prefabs`
    folder. Repeat this process for the `sofa` object as well. This will create a
    prefab of the `armchair` and `sofa`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“层次”窗口拖动“扶手椅”对象并将其放入“Assets/ARCoreDesign/Prefabs”文件夹。同样，对“沙发”对象重复此过程。这将创建“扶手椅”和“沙发”的预制件。
- en: Delete the `armchair`, `sofa`, and original mpm_vol.07_p24 objects from the
    Hierarchy window.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“层次”窗口删除“扶手椅”、“沙发”和原始mpm_vol.07_p24对象。
- en: 'Select the `SceneController` object in the Hierarchy window and then in the
    Inspector window, set Andy Android Prefab to the `armchair` prefab, as shown in
    the following excerpt:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“层次”窗口中选择“SceneController”对象，然后在检查器窗口中，将Andy Android Prefab设置为“扶手椅”预制件，如下所示：
- en: '![](img/ef1b9b10-5956-454d-a4b5-e4d0f87c60b9.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef1b9b10-5956-454d-a4b5-e4d0f87c60b9.png)'
- en: Setting the prefab slot on SceneController
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设置SceneController的预制件槽
- en: Save the project, connect, and run the app on your device. Let some surfaces
    appear and then place a chair or two. Feel free to go back and swap for the sofa.
    Note that you may want to adjust the `sofa` model's position as well.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目，连接，并在您的设备上运行应用程序。让一些表面出现，然后放置一把或两把椅子。您可以随时返回并交换沙发。请注意，您可能还需要调整“沙发”模型的定位。
- en: Good, now we can place some furniture, except that you will soon realize that
    the planes are more in the way now. Let's see how we can turn the planes in the
    next section on and off when we start adding in some UI.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以放置一些家具了，但您很快就会意识到，现在平面更碍事了。让我们看看在下一节中如何通过添加一些UI来开启和关闭平面。
- en: Building the UI
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建UI
- en: 'At this point, we want to give the user the ability to clear a scene and turn
    off the planes. The planes are helpful to identify surfaces we can drop objects
    onto, but they really distract from the experience. We will do this by building
    a dead simple UI with a couple of buttons. Fortunately, Unity has a very powerful
    UI system called **uGUI**, which will allow us to quickly do this. Open up the
    Unity editor to the `Main` scene and follow along:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们希望用户能够清除场景并关闭平面。平面有助于识别我们可以放置对象的表面，但它们实际上会分散用户的注意力。我们将通过构建一个非常简单的UI并添加几个按钮来实现这一点。幸运的是，Unity有一个非常强大的UI系统，称为**uGUI**，它将允许我们快速完成这项工作。打开Unity编辑器的“Main”场景并按照以下步骤操作：
- en: Click on an open area of the Hierarchy window to ensure that your selection
    is cleared. We do this to avoid attaching objects to other objects mistakenly.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“层次”窗口的空白区域以确保您的选择已清除。我们这样做是为了避免错误地将对象附加到其他对象上。
- en: 'From the menu, select GameObject | **UI** | **Canvas**. Name the new object
    as `UI` and ensure that the properties for this object match the Inspector window
    in the following excerpt:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择GameObject | **UI** | **Canvas**。将新对象命名为“UI”，并确保此对象的属性与以下摘录中的检查器窗口相匹配：
- en: '![](img/cb5a0093-6165-4801-996d-3ad07905c8f3.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb5a0093-6165-4801-996d-3ad07905c8f3.png)'
- en: Setting the properties of a new UI canvas
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 设置新UI画布的属性
- en: The settings we use on this Canvas allow our child `UI` objects to scale automatically
    with screen size based on a specific resolution. If we didn't do this, our `UI`
    controls would scale differently on each device. This allows us to keep a consistent
    look, which is a good thing.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个画布上使用的设置允许我们的子`UI`对象根据特定分辨率自动与屏幕大小缩放。如果我们不这样做，我们的`UI`控件在每台设备上的缩放方式都会不同。这使我们能够保持一致的外观，这是一个好事。
- en: Select the UI canvas and from the menu, select GameObject | UI | Panel to add
    a new child panel to the canvas.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择UI画布，从菜单中选择GameObject | UI | Panel以向画布添加一个新的子面板。
- en: 'Select the new Panel object. In the Inspector window, click on Add Component
    and then search for and add a Grid Layout Group component. Then, set the properties
    of this component to match the following screen excerpt:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的面板对象。在检查器窗口中，点击“添加组件”，然后搜索并添加一个网格布局组组件。然后，设置此组件的属性以匹配以下屏幕摘录：
- en: '![](img/05e70b16-7363-49bc-9b48-7255e8c6593c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05e70b16-7363-49bc-9b48-7255e8c6593c.png)'
- en: Setting the Group Layout Grid (Script) properties
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 设置组布局网格（脚本）属性
- en: Grid Layout Group is a useful tool for automatically laying out objects. The
    layout will automatically resize itself and adjust its child grid components.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格布局组是一个用于自动布局对象的实用工具。布局将自动调整大小并调整其子网格组件。
- en: With the Panel still selected, change the Image component's Color property to
    transparent. Do this by clicking on Color Selector Area next to the Color property
    and set the color to `#FFFFFF00` or `Alpha 0`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择面板的情况下，将图像组件的颜色属性更改为透明。通过点击颜色属性旁边的颜色选择区域，并将颜色设置为`#FFFFFF00`或`Alpha 0`来完成此操作。
- en: Select the Panel object in the Hierarchy window and from the menu, select GameObject
    | UI | Button. Rename the button as Clear.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次窗口中选择面板对象，从菜单中选择GameObject | UI | Button。将按钮重命名为“清除”。
- en: Expand the Clear button and select the child object. Change the Text components
    **Text** property to Clear.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开清除按钮并选择子对象。将文本组件的**文本**属性更改为清除。
- en: 'Repeat the sixth and seventh steps for a new button called Planes. When you
    are done, your Hierarchy window and Game window should resemble the following
    excerpt:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复第六步和第七步，为一个新的按钮“平面”操作。完成之后，你的层次窗口和游戏窗口应该类似于以下摘录：
- en: '![](img/a8a4f994-564a-4029-8867-831b58c20050.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8a4f994-564a-4029-8867-831b58c20050.png)'
- en: The finished buttons and panel in 2D view
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 2D视图中的完成按钮和面板
- en: You can view your scene in 2D view by clicking on the 2D button at the top of
    the Scene window. This is useful for previewing the UI elements you are building.
    You can use your mouse and keyboard to adjust the view on your own after that.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击场景窗口顶部的2D按钮，你可以以2D视图查看你的场景。这对于预览你正在构建的UI元素非常有用。之后，你可以使用鼠标和键盘自行调整视图。
- en: Connect, build, and run. The buttons don't work yet, but change the orientation
    and see how the buttons scale.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建和运行。按钮目前还不能工作，但改变方向看看按钮如何缩放。
- en: Feel free to style these buttons as you wish; after all, this is your app too.
    You can also add a slide in menu if you wanted. There are plenty of excellent
    resources and good books available on Unity uGUI development that can guide you
    on how to extend the UI for your look and feel.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 随意设计这些按钮，因为毕竟这也是你的应用。你也可以添加一个滑动菜单。关于Unity uGUI开发，有许多优秀的资源和好书可以指导你如何扩展UI以符合你的外观和感觉。
- en: Scripting the buttons
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写按钮脚本
- en: 'The obvious next step is to get those buttons working. Of course, we need to
    add a little bit of scripting, shown as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 显然下一步是让这些按钮工作。当然，我们需要添加一些脚本，如下所示：
- en: 'Open the `SceneController` script we created earlier in your code editor. Just
    before the `Update` method, insert the following section of code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器中打开我们之前创建的`SceneController`脚本。在`Update`方法之前，插入以下代码段：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code, we first create some lists to store scene objects (`m_sceneObjects`)
    and planes (`m_scenePlanes`), with a new `boolean` to track the state of the planes
    `m_planeOnState` (visible or not). Next, we add two new methods (`ClearScene`
    and `Planes`). `ClearScene` iterates over `m_sceneObjects` using `foreach` and
    removes the object from the scene with the `Destroy` method. `Destroy` is the
    method used to remove and clean up game objects from a scene. The `Planes` method
    flips the state of `m_planeOnState` and then loops through the planes and sets
    their state with `SetActive`. If an object is active, it means that it is visible
    and being updated in a scene. An inactive object is disabled and does not render.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建一些列表来存储场景中的物体（`m_sceneObjects`）和平面（`m_scenePlanes`），并添加一个新的布尔值来跟踪平面的状态`m_planeOnState`（可见或不可见）。接下来，我们添加两个新的方法（`ClearScene`和`Planes`）。`ClearScene`使用`foreach`遍历`m_sceneObjects`，并使用`Destroy`方法从场景中删除对象。`Destroy`是用于从场景中删除和清理游戏对象的方法。`Planes`方法翻转`m_planeOnState`的状态，然后遍历平面并使用`SetActive`设置它们的状态。如果一个对象是活动的，这意味着它在场景中是可见的并且正在更新。一个非活动的对象是被禁用的，并且不会渲染。
- en: We are staying consistent with the same naming conventions in this example in
    order to match the code style. If using `m_` to denote a private member variable
    is not your style, don't use it. You may also want to refactor this code and replace
    names such as `andyObject` with something more appropriate. Visual Studio has
    a great set of refactoring tools that make tasks like this easy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们保持与相同的命名约定一致，以匹配代码风格。如果你不习惯使用`m_`来表示私有成员变量，请不要使用它。你可能还想要重构此代码，并将`andyObject`等名称替换为更合适的名称。Visual
    Studio有一套出色的重构工具，可以轻松完成此类任务。
- en: 'Scroll down in the `Update` method and add the line after the line identified:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`方法中向下滚动，并在指定的行之后添加一行：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This line of code just adds the `andyObject` (poorly named now) to our list
    of scene objects. The `andyObject` is first instantiated with the `Instantiate`
    method. Think of `Instantiate` as the opposite of `Destroy`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码只是将`andyObject`（现在命名不佳）添加到我们的场景对象列表中。`andyObject`首先使用`Instantiate`方法实例化。将`Instantiate`视为`Destroy`的相反操作。
- en: 'Scroll back up and add the line after the line identified:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向上滚动并添加到指定的行之后的一行：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The same thing here, we are adding the newly instantiated `planeObject` to our
    list of scene planes.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里也是一样，我们正在将新实例化的`planeObject`添加到场景平面的列表中。
- en: Save the file and return to Unity. We now need to hook up the buttons. As always,
    wait for the compiler to finish in order to ensure that you didn't create a syntax
    error.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回Unity。我们现在需要连接按钮。像往常一样，等待编译器完成以确保你没有创建语法错误。
- en: 'Select the Clear button and in the **Inspector** window, scroll to the **Button**
    component. Click on the + button at the bottom to add a new event handler, and
    then set the properties of the handler to those shown here:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择清除按钮，并在**检查器**窗口中滚动到**按钮**组件。点击底部的+按钮添加一个新的事件处理程序，然后设置处理程序的属性如下：
- en: '![](img/c82a669e-ecb8-4d41-85ac-9ee0a49fe484.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c82a669e-ecb8-4d41-85ac-9ee0a49fe484.png)'
- en: Adding the button event handler
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 添加按钮事件处理程序
- en: Repeat the process for the Planes button. This time though, connect the `Planes`
    method.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为平面按钮重复此过程。这次，连接`Planes`方法。
- en: Connect, build, and run. Try to place an object and then use the buttons to
    clear it.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建并运行。尝试放置一个对象，然后使用按钮清除它。
- en: Now, you should be able turn on and off the plane visibility and clear any objects
    you created. In the next section, we will extend our UI to allow the user to interact
    with the objects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够打开和关闭平面的可见性，并清除你创建的任何对象。在下一节中，我们将扩展我们的UI，以便用户可以与对象交互。
- en: Interacting with the virtual
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与虚拟交互
- en: 'We want our users to be able to place and then move or adjust their object''s
    pose as they need to. If you recall, a pose represents the six degrees of freedom
    that an object can be represented in in 3D space. Before we start posing an object
    though, we need to be able to select an object. After we select an object, we
    want to be able to outline it in order to identify it to the user as selected.
    Since outlining the object sounds like an essential first step, let''s tackle
    that first. Follow along the given steps to create the object outlining:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够根据需要放置、移动或调整他们的对象姿态。如果你还记得，姿态代表了一个物体在3D空间中可以表示的六个自由度。在我们开始设置物体之前，我们需要能够选择一个物体。选择物体后，我们希望能够勾勒出它，以便向用户标识为已选择。由于勾勒物体听起来像是一个基本的第一步，让我们先解决这个问题。按照以下步骤创建物体勾勒：
- en: Go back to Unity. Create a new folder in the `Assets/ARCoreDesign/Materials`
    folder and name it `Shaders`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity。在`Assets/ARCoreDesign/Materials`文件夹中创建一个新的文件夹，并将其命名为`Shaders`。
- en: Right-click (*Ctrl* + Click on Mac) inside the new folder within the Project
    window and from the Context menu, select Create | Shader | Standard Surface Shader.
    Name the new shader `ARMobileSpecularOutline`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，在新的文件夹内右键单击（*Ctrl* + 点击Mac），从上下文菜单中选择创建 | 着色器 | 标准表面着色器。将新着色器的名称命名为`ARMobileSpecularOutline`。
- en: Double-click on the `ARMobileSpecularOutline` shader to open it in your code
    editor.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`ARMobileSpecularOutline`着色器，在您的代码编辑器中打开它。
- en: Delete the contents of the file. We will replace it with the ARCore mobile specular
    shader we used earlier.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除文件的内容。我们将用之前使用的ARCore移动高光着色器来替换它。
- en: Open the `MobileSpecularWithLightEstimation.shader` file in your text editor
    and copy the entire contents to your clipboard. The file is in the `Assets/GoogleARCore/HelloARExample/Materials/Shaders`
    folder.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的文本编辑器中打开`MobileSpecularWithLightEstimation.shader`文件，并将整个内容复制到剪贴板。该文件位于`Assets/GoogleARCore/HelloARExample/Materials/Shaders`文件夹中。
- en: Paste the contents of your clipboard to the new `ARMobileSpecularOutline.shader`
    file we just created. Again, we are copying the sample source and converting it
    to our own.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剪贴板的内容粘贴到我们刚刚创建的`ARMobileSpecularOutline.shader`文件中。再次，我们正在复制示例源并将其转换为我们的代码。
- en: While this shader is a copy of our light estimation shader and will use light
    estimation, we want to try and keep our variable names as succinct as possible.
    Normally, we will add light estimation to the name of the shader. However, in
    this, we will use an AR prefix to remind us that this shader uses light estimation
    and is optimized for AR.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个着色器是我们光估计着色器的副本，并将使用光估计，但我们希望尽可能保持变量名称简洁。通常，我们将光估计添加到着色器的名称中。然而，在这个例子中，我们将使用AR前缀来提醒我们这个着色器使用光估计，并且针对AR进行了优化。
- en: 'Edit the name of the shader, top line, to the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将着色器的名称（顶部行）更改为以下内容：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we have several edits to do at the top of the file. Change the Properties
    section to the following by adding the new lines not highlighted:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在文件顶部进行几个编辑。将属性部分更改为以下内容，并添加未高亮的新的行：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This adds three new properties: `_Albedo`, **`_Outline`**, and **`_OutlineColor`**.
    We added `_Albedo` in order to set a color on our materials without using a texture.
    `_Outline` defines the size of the outline, and `_OutlineColor` refers to the
    color.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这添加了三个新的属性：`_Albedo`、**`_Outline`**和**`_OutlineColor`**。我们添加`_Albedo`是为了在我们的材质上设置颜色而不使用纹理。`_Outline`定义了轮廓的大小，而`_OutlineColor`则指的是颜色。
- en: 'After the identified lines, inject the following block of code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标识的行之后，注入以下代码块：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This block of code is the part that creates the outline and does this by rendering
    a second time. It does this using the `Pass` keyword. Inside `Pass`, we can see
    more tags being defined and another start to a shader program with `CGPROGRAM`.
    The second block is a **`vertex`**/`fragment` shader and if you look inside the
    `vert` function, you can see where the outline is calculated. It does this by
    projecting the models vertex `normal` a distance determined by `_Outline`. Then,
    in the `frag` function, we just return the outline color. Again, don't panic if
    this looks intimidating, it is.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码块是创建轮廓的部分，它通过第二次渲染来实现这一点。它使用`Pass`关键字来完成这项工作。在`Pass`内部，我们可以看到更多标签的定义，以及一个使用`CGPROGRAM`开始的着色器程序的新开始。第二个块是一个**`vertex`**/`fragment`着色器，如果你查看`vert`函数，可以看到轮廓是如何计算的。它是通过将模型的顶点`normal`投影到一个由`_Outline`确定的距离来做到这一点的。然后，在`frag`函数中，我们只返回轮廓颜色。再次强调，如果这看起来令人生畏，那么它确实是。
- en: 'The last thing we need to do is add the new `_Albedo` property to our surface
    shader and add code to use it. Scroll down and add the following line after the
    identified line:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将新的`_Albedo`属性添加到我们的表面着色器中，并添加代码来使用它。向下滚动，并在标识的行之后添加以下行：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Scroll down further to the `surf` function and modify the following line:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动到`surf`函数并修改以下行：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All this is done to apply the `Albedo` color to the texture. If there is no
    texture, a value of `1.0` is used, which means just the `Albedo` color is shown.
    We needed to add this bit because our imported models didn't come with textures,
    and we didn't want to have to use a texture.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些操作都是为了将`Albedo`颜色应用到纹理上。如果没有纹理，则使用`1.0`的值，这意味着只显示`Albedo`颜色。我们需要添加这部分代码，因为我们的导入模型没有纹理，我们不想不得不使用纹理。
- en: Save the file and return to Unity. Ensure that you see no compiler errors.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回Unity。确保您没有看到任何编译错误。
- en: 'That completes the outline shader, but, of course, we want to test how it works.
    Let''s create a new material and set it on our model to see how this looks:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了轮廓着色器的构建，但当然，我们还想测试它的工作效果。让我们创建一个新的材质并将其设置在我们的模型上，看看效果如何：
- en: Create a new material called `ARMobileSpecularOutline_Green`in the `Assets/ARCoreDesign/Materials`
    folder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/ARCoreDesign/Materials`文件夹中创建一个名为`ARMobileSpecularOutline_Green`的新材质。
- en: Change the new material's shader to use the newly created shader **ARCoreDesign**
    | **ARMobileSpecularOutline**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新材质的着色器更改为使用新创建的着色器**ARCoreDesign** | **ARMobileSpecularOutline**。
- en: Set the `Albedo` color to a pleasant green, perhaps `#09D488FF`. Set the Shininess
    to about `0.5` or so, you decide.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Albedo`颜色设置为一种愉快的绿色，例如`#09D488FF`。将光泽度设置为大约`0.5`左右，您自己决定。
- en: The actual color of the fabric material is `#8F8E2A`; use that color if you
    don't want such an obvious difference.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的布料材质颜色是`#8F8E2A`；如果您不想有如此明显的差异，请使用该颜色。
- en: Set `_Outline` to `0.02`, which is still quite thick, but obvious. Use this
    value for now, and you can change it later.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`_Outline`设置为`0.02`，这仍然相当厚，但很明显。现在使用这个值，以后您可以更改它。
- en: 'Select the `sofa` prefab in the `Assets/ARCoreDesign/Prefabs` folder and replace
    the **fabric** material with the new **ARMobileSpecularOutline_Green**, as shown:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/ARCoreDesign/Prefabs`文件夹中选择`sofa`预制件，并将其**fabric**材质替换为新的**ARMobileSpecularOutline_Green**，如图所示：
- en: '![](img/bb4b80c1-43fc-4c9a-95db-39150bbbc0e5.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb4b80c1-43fc-4c9a-95db-39150bbbc0e5.png)'
- en: Changing the sofa prefab to use the new material
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将沙发预制件更改为使用新材质
- en: Save your project. Connect, build, and then run. Place a `chair` and see how
    it looks.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目。连接、构建然后运行。放置一个`chair`并看看效果。
- en: We have our outline shader in place, but now we need to programmatically turn
    the outline on when a user selects an object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了轮廓着色器，但现在我们需要在用户选择对象时以编程方式打开轮廓。
- en: Building the object outliner
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建对象轮廓
- en: 'We will build an `ObjectOutliner` class to handle the outlining for us. Follow
    along as we build the pieces to turn the outline on and off as the user selects
    an object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个`ObjectOutliner`类来为我们处理轮廓。跟随我们的步骤，构建以下部分以在用户选择对象时打开和关闭轮廓：
- en: Create a new C# script called `ObjectOutliner` in the `Assets/ARCoreDesign/Scripts`
    folder.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/ARCoreDesign/Scripts`文件夹中创建一个名为`ObjectOutliner`的新C#脚本。
- en: 'Replace all of the pregenerated script with the following:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换所有预生成的脚本：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This class basically just swaps the material of an object with its outlined
    or default material every time `Outline` is called.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类基本上每次调用`Outline`时都会交换对象的材质与其轮廓或默认材质。
- en: 'Next, open the `SceneController.cs` script in your code editor. We have to
    wrap the `Session Raycast` call in the `Update` method with our own `Physics Raycast`.
    Add the following code around the highlighted code section, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的代码编辑器中打开`SceneController.cs`脚本。我们必须在`Update`方法中用我们自己的`Physics Raycast`包装`Session
    Raycast`调用。按照以下方式在突出显示的代码部分周围添加以下代码：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This section of code uses the `Raycast` method of the `Physics` object. `Physics`
    is the object that encapsulates the Unity physics engine. `Raycast` is a method
    we use, just like `Frame.Raycast` we saw earlier, to cast a ray and check for
    any collisions. Normally, you filter out objects to test before you run a ray
    cast operation, because it is so expensive. You can see how this is done with
    `Session` in the setup of the `raycastFilter`, where the filter is set to test
    for planes, but you can also set this point as well. This will allow you to easily
    apply wall coverings, for instance. In our case, since we are using `Physics`
    to do the `Raycast`, we can ensure that you only get physics objects. The ARCore
    planes don't have physics objects attached to them.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码使用了`Physics`对象的`Raycast`方法。`Physics`是封装Unity物理引擎的对象。`Raycast`是我们使用的方法，就像我们之前看到的`Frame.Raycast`一样，用来发射射线并检查是否有碰撞。通常，在运行射线投射操作之前，您会过滤出要测试的对象，因为这非常昂贵。您可以通过`Session`在`raycastFilter`的设置中看到这是如何完成的，其中过滤器设置为测试平面，但您也可以设置这个点。这将允许您轻松地应用墙纸等。在我们的案例中，因为我们使用`Physics`进行`Raycast`，我们可以确保您只能得到物理对象。ARCore平面没有附加物理对象。
- en: Save the file and return to Unity.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回Unity。
- en: Locate the `armchair` prefab in the `Assets/ARCoreDesign/Prefabs` folder and
    expand it to see the inner model.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/ARCoreDesign/Prefabs`文件夹中找到`armchair`预制件并将其展开以查看内部模型。
- en: Select the armchair model and then, in the Inspector window, click on Add Component.
    Add a Box Collider to the object; the Box Collider will automatically adjust its
    size to surround the model. The `Physics` engine just tests for collisions against
    a collider and not the object. This is why we don't have to worry about our ARCore
    planes and points. If you add other models and want them selectable, then always
    use the simplest collider that best fits your shape. By simple, we mean less polygons.
    For instance, don't use a sphere collider when a Box Collider will do.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择扶手椅模型，然后在检查器窗口中单击添加组件。将盒式碰撞器添加到对象中；盒式碰撞器将自动调整其大小以包围模型。`Physics`引擎仅测试碰撞器与对象的碰撞，而不是对象本身。这就是为什么我们不必担心我们的ARCore平面和点。如果您添加其他模型并希望它们可选中，那么始终使用最适合您形状的最简单碰撞器。简单意味着多边形更少。例如，当盒式碰撞器可以做到时，不要使用球体碰撞器。
- en: 'Click on the Add Component button again and this time, add our new Object Outliner Script
    to the object and set its properties to what is shown in the following excerpt:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击添加组件按钮，这次将我们的新对象大纲脚本添加到对象中，并将其属性设置为以下摘录中所示：
- en: '![](img/9423d466-4b01-4cc8-a94a-0f5419b18a80.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9423d466-4b01-4cc8-a94a-0f5419b18a80.png)'
- en: Setting up the Object Outliner properties
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 设置对象大纲属性
- en: Default Material represents the base look of the model. Then, we set the Outline
    Material to our outline material we created earlier. Lastly, we set the slot we
    want to replace. The element we want to replace is Element 1, so we put `1` in
    the Material Slot property.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认材质代表模型的基色。然后，我们将轮廓材质设置为之前创建的轮廓材质。最后，我们设置要替换的槽位。我们想要替换的元素是元素1，所以我们在材质槽位属性中输入`1`。
- en: Save the project, build, and run. Place a chair and then select it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目，构建并运行。放置一把椅子，然后选择它。
- en: Now you can place a chair, select it, and then deselect it. If you note that
    it is difficult to select an object, ensure that you check that the collider is
    sufficiently large to engulf the object. In our example, the automatically created
    collider for the armchair is slightly off; perhaps we can fix that issue with
    one of the exercise questions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以放置一把椅子，选择它，然后取消选择。如果您发现选择对象很困难，请确保检查碰撞器是否足够大以包围该对象。在我们的例子中，自动创建的扶手椅碰撞器略有偏差；也许我们可以通过其中一个练习问题来解决这个问题。
- en: Positioning the chair
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放置椅子
- en: 'The last step is to allow the user to move the chair after they select it.
    Fortunately, we can do all that in code. Open up your code editor to the `SceneController.cs`
    file and follow along:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是允许用户在选择椅子后移动它。幸运的是，我们可以在代码中完成所有这些操作。打开您的代码编辑器到`SceneController.cs`文件，并按照以下步骤进行：
- en: 'Add a new `public` variable to the top of the class after the line identified:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定的行之后，在类顶部添加一个新的`public`变量：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This new `float MoveSpeed` sets the speed at which the user can move an object.
    You can also think of it as the move sensitivity. We set it to the default value
    of `.1f` here, but feel free to change it in the Inspector later when testing.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个新的`float MoveSpeed`设置了用户移动对象的速度。您也可以将其视为移动灵敏度。我们在这里将其设置为默认值`.1f`，但您可以在测试时在检查器中自由更改它。
- en: 'Locate the following highlighted section of code and replace it with this:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位以下突出显示的代码部分，并将其替换为以下内容：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous code made sure to only test the for starting touches. Instead,
    we now want to check when a `touch` starts and then as the user moves their finger.
    Since our previous `Physics` raycast code wrapped the `Session` raycast code,
    we now need to wrap it again with code that tests for a first touch and move events,
    which is what our second `if` statement does.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的代码确保只测试起始触摸。现在，我们想要检查触摸开始时以及用户移动手指时。由于我们之前的`Physics`射线投射代码包装了`Session`射线投射代码，我们现在需要再次用测试第一次触摸和移动事件的代码包装它，这正是我们的第二个`if`语句所做的事情。
- en: 'Scroll to the line identified and add the following code before the end of
    the `Update` method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到指定的行，并在`Update`方法末尾之前添加以下代码：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code we are adding here handles when the user is moving their finger. We
    then calculate a `change` vector relative to the camera's position. This transforms
    the `forward` or *z* axis relative to the camera by a delta position of the *y*
    axis in 2D, which more or less means that as the user moves their finger up and
    down on the screen, the object will move in and out on the `forward` axis, relative
    to the camera. To the `change` vector, we then add the `right` or *x* axis vector
    relative to the camera and modified by the delta of the user's finger along the
    x axis in 2D. Thus, when a user moves their finger left or right across the screen,
    the model will move left-right along the `right` axis relative to the camera.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里添加的代码处理用户移动手指的情况。然后我们计算相对于相机位置的 `change` 向量。通过在 2D 中沿 *y* 轴的增量位置变换相机相对于的
    `forward` 或 *z* 轴，这大致意味着当用户在屏幕上上下移动手指时，对象将在相对于相机的 `forward` 轴上移动进退。然后，我们将相对于相机的
    `right` 或 *x* 轴向量添加到 `change` 向量中，并修改用户在 2D 中沿 x 轴的增量。因此，当用户在屏幕上左右移动手指时，模型将相对于相机沿
    `right` 轴左右移动。
- en: 'Scroll up and change the **if** statement to add the new highlighted code starting
    with **&&**:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向上滚动并更改 `**if**` 语句，添加以 `**&&**` 开头的新突出显示代码：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This change just ensures that if the object is highlighted and selected again,
    the `Outline` method is not called. We no longer want to toggle the selection,
    but we will leave the `Outline` method this way for ease of use. Next, we want
    to handle when a user touches away from an object. In that case, we want to disable
    all the outlined objects.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个更改只是确保如果对象被突出显示并再次选中，不会调用 `Outline` 方法。我们不再想要切换选择，但为了方便使用，我们将保持 `Outline`
    方法不变。接下来，我们想要处理用户触摸到对象之外的情况。在这种情况下，我们想要禁用所有突出显示的对象。
- en: If, at any point, you lose track or get frustrated, take a look at the finished
    project available as part of the code.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在任何时候你失去了方向或感到沮丧，请查看作为代码一部分提供的完成项目。
- en: 'Scroll down to the code identified and insert the new code to clear the outlines
    on the selected objects:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动到指定的代码，并插入以下新代码以清除选中对象上的轮廓：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code loops through the game `m_scene_Objects`, finds the `ObjectOutliner`
    component, and then uses that to test whether the outline is on. If the outline
    is on, it turns it off with a call to `Outline`, perhaps poorly named now.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码遍历游戏 `m_scene_Objects`，找到 `ObjectOutliner` 组件，然后使用它来测试轮廓是否开启。如果轮廓开启，它将通过调用
    `Outline` 来将其关闭，现在可能这个名字起得不太合适。
- en: Connect, build, and run. Wait for the surfaces to track and then place a `chair`.
    Touch to select and then use your finger to move the `chair` around. You can also
    adjust your position relative to the `chair` and watch how the object responds,
    all in real time.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建并运行。等待表面跟踪完成，然后放置一个 `chair`。触摸以选择，然后使用手指移动 `chair`。你还可以调整相对于 `chair` 的位置，并观察对象如何实时响应。
- en: 'Press the volume down and power button at the same time to take a screenshot.
    Compare your picture to the following one:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时按下音量下键和电源按钮来截取屏幕截图。将你的图片与以下图片进行比较：
- en: '![](img/724d754d-478e-499c-a004-37c97823b829.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/724d754d-478e-499c-a004-37c97823b829.png)'
- en: A virtual armchair placed and moved
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 放置并移动的虚拟扶手椅
- en: Not bad, but we can probably do a bit better. In the next section, we will get
    back into lighting and work on the lighting and shadows of our objects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，但我们可能做得更好。在下一节中，我们将回到光照，并处理对象的光照和阴影。
- en: Lighting and shadows
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照和阴影
- en: 'Lighting is an essential element in our scenes, but as we have already seen,
    it takes some work to get it right. In this section, we will revisit lighting
    and also tackle adding shadows. Adding shadows to our objects will make them look
    like they are really there. We will start with adding shadows, so open up Unity
    and follow along:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 光照是我们场景中的基本元素，但正如我们已经看到的，要正确设置它需要一些工作。在本节中，我们将重新审视光照，并解决添加阴影的问题。给我们的对象添加阴影将使它们看起来真的在那里。我们将从添加阴影开始，所以打开
    Unity 并跟随操作：
- en: Create a new shader called `UnlitShadowReceiver` in the `Assets/ARCoreDesign/Materials/Shaders`
    folder.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/ARCoreDesign/Materials/Shaders` 文件夹中创建一个新的着色器，名为 `UnlitShadowReceiver`。
- en: Double-click on the new shader to open it in your code editor.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新的着色器，在代码编辑器中打开它。
- en: 'Select all the autogenerated code and delete it. Then, add the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有自动生成的代码并将其删除。然后，添加以下代码：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This shader is an example of a transparent shadow receiver. The shader works
    in two passes. In the first pass, we essentially clear the texture based on a
    cutoff alpha value. This allows us to turn an object transparent and still receive
    a shadow. The second pass draws the shadow using a vertex and fragment shader.
    Feel free to spend time studying this shader further.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个着色器是一个透明阴影接收器的例子。着色器分为两个阶段。在第一阶段，我们基于截止alpha值清除纹理。这允许我们将对象变为透明，同时仍然接收阴影。在第二阶段，使用顶点和片段着色器绘制阴影。请随意花时间进一步研究这个着色器。
- en: As ARCore matures, there will likely be more versions of transparent shadow
    receivers available. Plan to search for other options or other ways to improve
    this form of shader in the future.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 随着ARCore的成熟，可能会提供更多版本的透明阴影接收器。计划在将来搜索其他选项或改进这种着色器形式的其他方法。
- en: Save the file and return to Unity.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回Unity。
- en: 'Create a new material in the `Assets/ARCoreDesign/Materials` folder and name
    it as `UnlitShadowReceiver`. Set the properties of the material, as shown in the
    following excerpt:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/ARCoreDesign/Materials`文件夹中创建一个新的材质，并将其命名为`UnlitShadowReceiver`。设置材质的属性，如下面的摘录所示：
- en: '![](img/27221d4d-4f02-48c3-9210-28747142050f.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27221d4d-4f02-48c3-9210-28747142050f.png)'
- en: Setting the properties on the UnlitShadowReceiver material
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在UnlitShadowReceiver材质上设置属性
- en: Select and drag the `armchair` prefab from the `Assets/ARCoreDesign/Materials`
    folder in the **Project** window and drop it in an open area of the **Hierarchy**
    window. We want to adjust our prefab a bit, and this is the easiest way.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，从`Assets/ARCoreDesign/Materials`文件夹中选择并拖动`armchair`预制件到**层次结构**窗口的空白区域。我们想要稍微调整预制件，这是最简单的方法。
- en: From the menu, select **GameObject** | **3D** | **Plane**. Expand the `armchair`
    object and drag the Plane onto the 24 Ligne Roset Citta armchair child object.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**GameObject** | **3D** | **Plane**。展开`armchair`对象，并将平面拖动到24 Ligne Roset
    Citta扶手椅子对象上。
- en: 'Select Plane and reset the position to (`0`, `0`, `0`) and scale to (`0.1`,
    `1`, `0.1`) on the Transform.Set the material to new UnlitShadowReceiver, as shown
    in the following excerpt:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择平面，并将位置重置为(`0`, `0`, `0`)，比例设置为(`0.1`, `1`, `0.1`)在Transform.Set。将材质设置为新的UnlitShadowReceiver，如图所示：
- en: '![](img/f94766c1-8af9-4b1e-8508-eb753131fd2c.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f94766c1-8af9-4b1e-8508-eb753131fd2c.png)'
- en: Setting the Plane material to UnlitShadowReceiver
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将平面材质设置为UnlitShadowReceiver
- en: Select the armchair object in the **Hierarchy** window and then in the `Inspector`
    window, click on the Apply button beside the Prefab properties to save the prefab.
    Leave the prefab in the scene for now, but we will want to delete it later.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择扶手椅对象，然后在**检查器**窗口中，点击Prefab属性旁边的应用按钮以保存预制件。现在将预制件留在场景中，但稍后我们将想要删除它。
- en: We just created our transparent shadow receiver shader and then set it on a
    plane that we added to our prefab. We need to do this in order for our object,
    the `armchair`, to correctly cast a shadow on our new transparent receiver. Next,
    we need to turn on shadows, as the ARCore example has them disabled by default.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个透明的阴影接收器着色器，并将其设置在我们添加到预制件中的平面上。我们需要这样做，以便我们的对象`armchair`能够正确地在我们新的透明接收器上投射阴影。接下来，我们需要打开阴影，因为ARCore示例默认禁用了阴影。
- en: Turning the shadows on
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开阴影
- en: 'Follow along to turn shadows back on:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤重新打开阴影：
- en: 'Select the Directional Light in the Hierarchy window and set the lights properties
    as shown:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择方向光，并设置灯光属性，如图所示：
- en: '![](img/c51bcbed-9280-44c7-94b0-ffa9adef9e32.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c51bcbed-9280-44c7-94b0-ffa9adef9e32.png)'
- en: Turning on shadows for the Directional Light
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 打开方向光的阴影
- en: As soon as you change the Shadow Type, you should see an immediate change in
    the Scene window with the armchair now showing a shadow underneath. If you are
    unable to see a shadow yet, don't panic, we likely need to just adjust the quality
    settings.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你更改了阴影类型，你应该立即在场景窗口中看到变化，扶手椅现在在下面显示阴影。如果你还没有看到阴影，不要慌张，我们可能只需要调整质量设置。
- en: The ARCore example uses a blob texture for a shadow on the Andy model. By updating
    this to use a shader, we now have automatic support for any object you want to
    add. Just remember to adjust the plane to the object. If you wanted to add a painting
    or other wall hanging, you would set the plane vertical with the object.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ARCore示例使用Blob纹理为Andy模型添加阴影。通过更新以使用着色器，我们现在可以自动支持任何你想要添加的对象。只需记住调整平面以适应对象。如果你想添加一幅画或其他挂在墙上的物品，你需要将平面设置为垂直，并与对象对齐。
- en: 'From the menu, select Edit | Project Settings | Quality. Set the Android build
    to use the highest quality settings by Default by clicking on the arrow icon underneath
    the Levels for Android. This is shown in the following excerpt:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择编辑 | 项目设置 | 质量。通过点击Android级别下的箭头图标，将Android构建设置为默认使用最高质量设置。这在上面的摘录中显示：
- en: '![](img/986bfe82-8c1d-4414-a08c-74ab1c6cacf4.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/986bfe82-8c1d-4414-a08c-74ab1c6cacf4.png)'
- en: Setting the Quality setting for the build
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 设置构建的质量设置
- en: Make sure and apply the changes to the prefab again. This just assures us that
    are changes are saved before we delete the prefab from the scene.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保再次将更改应用到预制件上。这只是为了确保在我们从场景中删除预制件之前，我们的更改已经保存。
- en: Select and delete the `armchair` object from the scene.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中选取并删除`扶手椅`对象。
- en: We are using the highest quality settings in this example. For the most part,
    ARCore apps will run on relatively new devices, which means we can attempt to
    push the limits. If you find that the quality settings are crashing your device
    or not rendering correctly, then try dropping the quality on the build a level.
    You may want to do this anyway to improve your app's performance.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了最高的质量设置。对于大多数情况，ARCore应用将在相对较新的设备上运行，这意味着我们可以尝试推动极限。如果你发现质量设置会导致设备崩溃或无法正确渲染，那么尝试在构建中降低一个级别的质量。你可能无论如何都想要这样做，以改善你的应用性能。
- en: 'Connect, build, and run. Place a chair and see the difference, as shown:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建和运行。放置一把椅子，看看差异，如图所示：
- en: '![](img/835e551e-9c60-4d57-8aad-6396c0a51f67.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/835e551e-9c60-4d57-8aad-6396c0a51f67.png)'
- en: Example of the complete app with lighting and shadows
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 带有光照和阴影的完整应用的示例
- en: This is as far as we will go with the app in this chapter. Feel free to enhance
    the app on your own and take time to complete some of the optional exercises on
    your own. If the shadow doesn't show up correctly go back and edit the shadow
    settings on the light and the quality settings.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将到此为止。请随意增强应用，并花时间独立完成一些可选练习。如果阴影没有正确显示，请返回并编辑灯光和质量的阴影设置。
- en: Exercises
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '*Answer the following questions on your own*:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*独立回答以下问题*：'
- en: Change the model in the app to the `sofa` or even another object.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用中的模型更改为`沙发`或另一个对象。
- en: Add the changes we made to the `Environmental Light` script in order to track
    the light direction.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们对`环境光照`脚本所做的更改添加到应用中，以便跟踪光照方向。
- en: Add other objects to the app and allow the user a choice on which to place.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他对象添加到应用中，并允许用户选择放置哪个对象。
- en: Allow the user to place vertical objects. Hint—you will need to render vertical
    planes now, yes ARCore does recognize vertical planes.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户放置垂直对象。提示——你现在需要渲染垂直平面，是的，ARCore确实可以识别垂直平面。
- en: Allow the user to rotate the model. Hint—you may have to add some control handles.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户旋转模型。提示——你可能需要添加一些控制手柄。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we have completed our simple example of a design app. We were able
    to complete all the major technical items we wanted to accomplish. We started
    with setting up a new Unity project using the ARCore example as a template. This
    saved us some time in what would have otherwise become a very long chapter. Next,
    we learned how to import new models from sites such as [TurboSquid](https://www.turbosquid.com/)
    and how to set them up as prefabs for later use. Then, we built a simple UI to
    allow us to clear the tracking planes from the view and clear any models. After
    that, we added the ability for a user to select and move an object in the AR scene.
    This required us to enhance one of the ARCore example shaders and heavily modify
    the `SceneController` script. Finally, we tackled shadows by turning on lights
    and adding a transparent shadow receiver to our object prefab.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了我们简单的设计应用示例。我们能够完成我们想要完成的所有主要技术项目。我们从使用ARCore示例作为模板设置一个新的Unity项目开始。这为我们节省了一些时间，否则这将变成一个非常长的章节。接下来，我们学习了如何从像[TurboSquid](https://www.turbosquid.com/)这样的网站导入新模型，以及如何将它们设置为预制件以供以后使用。然后，我们构建了一个简单的用户界面，使我们能够从视图中清除跟踪平面和清除任何模型。之后，我们添加了用户在AR场景中选择和移动对象的能力。这要求我们增强ARCore示例中的着色器，并对`SceneController`脚本进行了大量修改。最后，我们通过打开灯光并添加透明阴影接收器到我们的对象预制件来解决阴影问题。
- en: ARCore is well suited for the next wave of HoloLens or mixed reality low-cost
    headsets. In the next chapter, we take a bit of a break from AR and dive into
    mixed reality, where we will build a multiplayer app called `HoloCore`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ARCore非常适合下一波HoloLens或低成本混合现实头戴式设备。在下一章中，我们将从AR中稍作休息，深入混合现实，我们将构建一个名为`HoloCore`的多玩家应用。
