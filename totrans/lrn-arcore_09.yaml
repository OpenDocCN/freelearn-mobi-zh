- en: Blending Light for Architectural Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the first of two chapters where we will build real-world AR apps that
    you can learn from and show off to friends and family. Unlike in the previous
    chapters, this time we will build our AR app from nothing. That way, we can learn
    the specific details needed for incorporating ARCore into a Unity project. We
    have a lot to cover in this chapter, so let''s get started. Listed here is a quick
    summary of the main topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the virtual
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting and shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The premise for our app will be an AR tool for architecture and design. The
    designing apps are very popular in AR right now and fit very well with the toolkit
    ARCore provides.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to virtually place objects in or over a real-world object and instantly
    see how it looks has a tremendous benefit to designers and architects. Now a designer
    using an AR app can instantly transform a space with their vision. Imagine never
    having to move a couch 15 times to get it just right, ever again.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the sample project as a template for creating a new project. At
    the time of writing, doing an ARCore asset import with the beta version still
    requires considerable project setup. Ideally, we would like to create a project
    from scratch, but we will do the next best thing. The next best thing will be
    to clone the project from GitHub into a new folder of our choice. You can start
    by opening up Command Prompt and following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder off your root or working folder and download the ARCore
    template by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new folder. Switch to it and download the project template
    from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up Unity to the project dialog and click on **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the folder dialog to find and select the `ARCoreDesign` folder we just
    downloaded the code to, as shown in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/03d52c88-72fb-43a3-932b-7903453ced1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Opening the ARCoreDesign project
  prefs: []
  type: TYPE_NORMAL
- en: Wait for Unity to load. Ensure that you watch for any compiler errors at the
    bottom of the editor status bar. If you see them, it means you may have a version
    conflict or that something's changed. Check your version and try to upgrade or
    downgrade, as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we will do is organize our folder structure. Create a new folder
    called `ARCore_Design`in the Project window by right-clicking (*Ctrl* + Click
    on Mac) on the `Assets` folder and selecting Create | Folder from the context
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Directly underneath the new folder, add folders for `Scripts`, `Prefabs`, `Scenes`,
    `Materials`, and `Models`, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ed9bedf2-bf49-4779-b1d0-121514a3d820.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the folder structure
  prefs: []
  type: TYPE_NORMAL
- en: The technique we just used for setting up the project is useful when you are
    dealing with other sample projects you want to make your own. Unity manages a
    project by the folder and the name corresponds to the folder name. We won't worry
    about setting up source control as you can do this on your own, as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: If you are setting up this project for anything other than learning, you should
    definitely consider a source code solution at this point. Dropbox or other file
    sharing solutions will work in a pinch, but it's not something that will work
    for more than one developer. There are plenty of free and fairly simple solutions
    that work with Unity, so take some time and pick one that works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Building the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for us to save some time, we will load the `HelloAR` scene and modify
    it to meet our needs. Follow along the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `HelloAR` scene in the `Assets/GoogleARCore/HelloARExample/Scenes`
    folder by double-clicking on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, select File | Save Scene as, save the scene in the new `Assets/ARCore_Design/Scenes`
    folder, and name it as `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apart from the samples we worked with earlier, from now on, if we need to modify
    a file, we will copy it to a new appropriate folder, and rename it. This is a
    good practice to follow when modifying external assets. That way, when you update
    the asset with a new version, your changes will not be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, select **Edit** | **Project Settings** | **Player**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the Inspector window, click on the Android tab and edit the Package Name
    to `com.Packt.ARCoreDesign`, as shown in the following screen excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/490bff9b-fa75-4704-b508-4a05bd59a6db.png)'
  prefs: []
  type: TYPE_IMG
- en: Editing the package name in the Player settings
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, select File | Build Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the checkbox on the `HelloAR` scene to turn it off. Then, click on Add
    Open Scenes to add the new `Main` scene to the build. Ensure that the Android
    option is selected for the Platform, and confirm that everything is set, as shown
    in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ee94210-c52d-48bf-92cd-c6fa1f99826f.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Build Settings
  prefs: []
  type: TYPE_NORMAL
- en: Connect your device and then click on Build And Run. You will be prompted to
    save the APK. Enter the same name you used for the package (`com.Packt.ARCoreDesign`)
    and click on Save. This will kick off the build. A first build can take a while,
    so grab a beverage or take a quick break.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app on your device and confirm that everything runs as you expect it
    to. If anything fails, refer to [Chapter 11](e7c0bdd1-e380-4498-af5a-fe9e627eb6cb.xhtml),
    *Performance Tips and Troubleshooting*, for help.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you work through the exercises in this chapter, try and build as often as
    possible. A build can quickly tell you if you have any major issues.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the base scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we will do is just modify the base scene for our needs. Open
    up Unity and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select and drag the PointCloud object in the Hierarchy window and drop it into
    the `Assets/ARCoreDesign/Prefabs` folder in the Project window, as shown in the
    following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7a5e0a3-93eb-400f-9296-ca231e812b88.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a prefab with the PointCloud object
  prefs: []
  type: TYPE_NORMAL
- en: This will create a Prefab of the PointCloud object. Think of a Prefab as a template
    or almost like a class. Anytime we want to reuse the PointCloud object, we can
    drag it into a scene or instantiate it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the PointCloud object in the Hierarchy window and type the Delete key.
    Find it, and click on it. This will delete the object; we don't need it right
    now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `ExampleController` object in the Hierarchy window to `SceneController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Assets/ARCoreDesign/Scripts` folder and from the menu, select Assets
    | Create | C# Script. Name the script `SceneController`. Then, double-click on
    it to open the script in your favorite code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, get back to Unity. Enter `helloarcontroller` in the Project search pane
    to filter the window to the script. Double-click on the script to open it in your
    code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the entire `HelloARController.cs` script and paste it over the contents
    of the `SceneController.cs` file; yes, all of it. We are essentially making a
    copy. Rename your class and change the namespace, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We wrap all our new code files with a `namespace` in order to avoid naming conflicts.
    Naming conflicts happen more frequently in Unity if you use a lot of assets. Generally,
    if you are new to Unity, you will use a lot of third-party assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that all the following new `using` statements are identified, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and return to Unity. Be sure to watch for any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `SceneController` object in the Hierarchy window and click on the
    Add Component button in the Inspector window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `scene` in the search pane and then select the Scene Controller script,
    as shown in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ffd8a509-28f9-48b4-ac52-62c33f3f2854.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the Scene Controller script as a component
  prefs: []
  type: TYPE_NORMAL
- en: Click on the bullseye icon to set the properties for the Scene Controller. Ensure
    that they match Hello AR Controller (Script). When all the properties match, click
    on the **Gear** icon beside the Hello AR Controller (Script) and select Remove
    Component from the context menu. You should now be left with just the Scene Controller
    (Scene) component with the same properties set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run the app on your device. If you encounter any issues,
    check for compiler errors and ensure that you set up the components correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can, of course, create duplicates for all the main scripts, but this will
    work for now. Obviously, we have a lot more work to do, but this is a good place
    to start. Ensure that you save the `scene` and your project. In the next section,
    we will look to change the content which we allow our user to place and choose
    where to place.
  prefs: []
  type: TYPE_NORMAL
- en: The environment and placing content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already covered the basics of how to interact with the environment
    in order to place content. What we want to do now is swap out and add new content
    (sorry Andy). After all, the whole premise of our design app is visualizing in
    AR how new furniture or other items look in a space. Let''s get to it by opening
    up your favorite web browser and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [turbosquid.com](https://www.turbosquid.com/). **TurboSquid** is an
    excellent resource for 3D models, both free and paid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For AR / VR and mixed apps, you will generally want your models to be less detailed.
    Mobile devices such as Android don't render fine detailed models well. Before
    you purchase any models, ensure that you understand what your device's rendering
    limitations are.
  prefs: []
  type: TYPE_NORMAL
- en: Search for `ligne roset`on the site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can, of course, use any FBX model you like, but try using the one suggested
    the first time. Working with 3D models can be frustrating if you are unsure what
    you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter your search to free models and select Ligne Roset Citta sofa and armchair,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52fa1323-fec8-4b47-a223-294ab57aa1a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Downloading models from TurboSquid
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Download button. You may have to create an account and then sign
    in first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the link marked `Ligne_Roset_Citta_FBX.zip`. This will download the
    zip file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unzip the file into a new folder and then open the folder. Select and drag
    the `mpm_vol.07_p24.FBX` file into Unity and drop it into the `Assets/ARCore/Models`
    folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74e3bbae-0624-42ec-a21c-05817927c500.png)'
  prefs: []
  type: TYPE_IMG
- en: Dragging the model into the Models folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the model and then, in the Inspector window, confirm that Model | Scale Factor
    is set correctly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33d9f6d9-8305-458a-ba11-3370267db246.png)'
  prefs: []
  type: TYPE_IMG
- en: Checking the model scale after import
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the model is using File Scale, which is set at `0.001`. You
    may need to adjust this depending on what scale your model uses. Right now, this
    scale works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our model comes complete with `chair` and `sofa`. Fortunately, we can break
    these apart relatively easily. Drag and drop the model into an open area of the
    Hierarchy window. You should see the `chair` and `sofa` get added to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on an empty area in the Hierarchy window again to disable the model selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, select GameObject | Create Empty; rename the object as `sofa`.
    Do this again to create another new object and name it `armchair`. Ensure that
    the `armchair` and `sofa` game objects are set on an origin pose with a position
    of (`0`, `0`, `0`) and rotation of (`0`, `0`, `0`). If you need help, select the
    object and check the Inspector window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expand the mpm_vol.07_p24 model, and drag the child `armchair` object and drop
    it on the new `armchair` game object. Repeat this process for the sofa piece,
    and your Hierarchy window should resemble the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d8c1f431-29bb-41e2-8e3b-9731981b6790.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating two new models
  prefs: []
  type: TYPE_NORMAL
- en: What we just did is create new anchor points and then break apart our model.
    Anchor points allow us to adjust a model with respect to the fixed anchor. You
    will often need to do this in cases where the modeling software used a different
    reference. This is the case with our model. Select the 24 Ligne Roset Citta armchair
    child object and check the Inspector window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the position of the `armchair` Transform to (`0`, `0.25`, `0`), as illustrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1485b522-a1b1-437d-af67-a510529269e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the position transform of the armchair
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the position is set to X=`0` and Y=`-.25` and leave the Rotation
    as it is. We are offsetting the position of the `armchair` from where it was and
    down a little. This is because ARCore currently tends to track planes too high;
    hopefully, this will be fixed by the time of release. In any case, you can adjust
    the offset of the position of the `chair` anytime and anyway you want later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `armchair` object from the Hierarchy window and drop it into the `Assets/ARCoreDesign/Prefabs`
    folder. Repeat this process for the `sofa` object as well. This will create a
    prefab of the `armchair` and `sofa`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `armchair`, `sofa`, and original mpm_vol.07_p24 objects from the
    Hierarchy window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `SceneController` object in the Hierarchy window and then in the
    Inspector window, set Andy Android Prefab to the `armchair` prefab, as shown in
    the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef1b9b10-5956-454d-a4b5-e4d0f87c60b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the prefab slot on SceneController
  prefs: []
  type: TYPE_NORMAL
- en: Save the project, connect, and run the app on your device. Let some surfaces
    appear and then place a chair or two. Feel free to go back and swap for the sofa.
    Note that you may want to adjust the `sofa` model's position as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good, now we can place some furniture, except that you will soon realize that
    the planes are more in the way now. Let's see how we can turn the planes in the
    next section on and off when we start adding in some UI.
  prefs: []
  type: TYPE_NORMAL
- en: Building the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we want to give the user the ability to clear a scene and turn
    off the planes. The planes are helpful to identify surfaces we can drop objects
    onto, but they really distract from the experience. We will do this by building
    a dead simple UI with a couple of buttons. Fortunately, Unity has a very powerful
    UI system called **uGUI**, which will allow us to quickly do this. Open up the
    Unity editor to the `Main` scene and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on an open area of the Hierarchy window to ensure that your selection
    is cleared. We do this to avoid attaching objects to other objects mistakenly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the menu, select GameObject | **UI** | **Canvas**. Name the new object
    as `UI` and ensure that the properties for this object match the Inspector window
    in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb5a0093-6165-4801-996d-3ad07905c8f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the properties of a new UI canvas
  prefs: []
  type: TYPE_NORMAL
- en: The settings we use on this Canvas allow our child `UI` objects to scale automatically
    with screen size based on a specific resolution. If we didn't do this, our `UI`
    controls would scale differently on each device. This allows us to keep a consistent
    look, which is a good thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the UI canvas and from the menu, select GameObject | UI | Panel to add
    a new child panel to the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the new Panel object. In the Inspector window, click on Add Component
    and then search for and add a Grid Layout Group component. Then, set the properties
    of this component to match the following screen excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05e70b16-7363-49bc-9b48-7255e8c6593c.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Group Layout Grid (Script) properties
  prefs: []
  type: TYPE_NORMAL
- en: Grid Layout Group is a useful tool for automatically laying out objects. The
    layout will automatically resize itself and adjust its child grid components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Panel still selected, change the Image component's Color property to
    transparent. Do this by clicking on Color Selector Area next to the Color property
    and set the color to `#FFFFFF00` or `Alpha 0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Panel object in the Hierarchy window and from the menu, select GameObject
    | UI | Button. Rename the button as Clear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the Clear button and select the child object. Change the Text components
    **Text** property to Clear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat the sixth and seventh steps for a new button called Planes. When you
    are done, your Hierarchy window and Game window should resemble the following
    excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8a4f994-564a-4029-8867-831b58c20050.png)'
  prefs: []
  type: TYPE_IMG
- en: The finished buttons and panel in 2D view
  prefs: []
  type: TYPE_NORMAL
- en: You can view your scene in 2D view by clicking on the 2D button at the top of
    the Scene window. This is useful for previewing the UI elements you are building.
    You can use your mouse and keyboard to adjust the view on your own after that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run. The buttons don't work yet, but change the orientation
    and see how the buttons scale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feel free to style these buttons as you wish; after all, this is your app too.
    You can also add a slide in menu if you wanted. There are plenty of excellent
    resources and good books available on Unity uGUI development that can guide you
    on how to extend the UI for your look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The obvious next step is to get those buttons working. Of course, we need to
    add a little bit of scripting, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `SceneController` script we created earlier in your code editor. Just
    before the `Update` method, insert the following section of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first create some lists to store scene objects (`m_sceneObjects`)
    and planes (`m_scenePlanes`), with a new `boolean` to track the state of the planes
    `m_planeOnState` (visible or not). Next, we add two new methods (`ClearScene`
    and `Planes`). `ClearScene` iterates over `m_sceneObjects` using `foreach` and
    removes the object from the scene with the `Destroy` method. `Destroy` is the
    method used to remove and clean up game objects from a scene. The `Planes` method
    flips the state of `m_planeOnState` and then loops through the planes and sets
    their state with `SetActive`. If an object is active, it means that it is visible
    and being updated in a scene. An inactive object is disabled and does not render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are staying consistent with the same naming conventions in this example in
    order to match the code style. If using `m_` to denote a private member variable
    is not your style, don't use it. You may also want to refactor this code and replace
    names such as `andyObject` with something more appropriate. Visual Studio has
    a great set of refactoring tools that make tasks like this easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down in the `Update` method and add the line after the line identified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This line of code just adds the `andyObject` (poorly named now) to our list
    of scene objects. The `andyObject` is first instantiated with the `Instantiate`
    method. Think of `Instantiate` as the opposite of `Destroy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll back up and add the line after the line identified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The same thing here, we are adding the newly instantiated `planeObject` to our
    list of scene planes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file and return to Unity. We now need to hook up the buttons. As always,
    wait for the compiler to finish in order to ensure that you didn't create a syntax
    error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the Clear button and in the **Inspector** window, scroll to the **Button**
    component. Click on the + button at the bottom to add a new event handler, and
    then set the properties of the handler to those shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c82a669e-ecb8-4d41-85ac-9ee0a49fe484.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the button event handler
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the process for the Planes button. This time though, connect the `Planes`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run. Try to place an object and then use the buttons to
    clear it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you should be able turn on and off the plane visibility and clear any objects
    you created. In the next section, we will extend our UI to allow the user to interact
    with the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the virtual
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want our users to be able to place and then move or adjust their object''s
    pose as they need to. If you recall, a pose represents the six degrees of freedom
    that an object can be represented in in 3D space. Before we start posing an object
    though, we need to be able to select an object. After we select an object, we
    want to be able to outline it in order to identify it to the user as selected.
    Since outlining the object sounds like an essential first step, let''s tackle
    that first. Follow along the given steps to create the object outlining:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to Unity. Create a new folder in the `Assets/ARCoreDesign/Materials`
    folder and name it `Shaders`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click (*Ctrl* + Click on Mac) inside the new folder within the Project
    window and from the Context menu, select Create | Shader | Standard Surface Shader.
    Name the new shader `ARMobileSpecularOutline`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `ARMobileSpecularOutline` shader to open it in your code
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the contents of the file. We will replace it with the ARCore mobile specular
    shader we used earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MobileSpecularWithLightEstimation.shader` file in your text editor
    and copy the entire contents to your clipboard. The file is in the `Assets/GoogleARCore/HelloARExample/Materials/Shaders`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the contents of your clipboard to the new `ARMobileSpecularOutline.shader`
    file we just created. Again, we are copying the sample source and converting it
    to our own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While this shader is a copy of our light estimation shader and will use light
    estimation, we want to try and keep our variable names as succinct as possible.
    Normally, we will add light estimation to the name of the shader. However, in
    this, we will use an AR prefix to remind us that this shader uses light estimation
    and is optimized for AR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the name of the shader, top line, to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have several edits to do at the top of the file. Change the Properties
    section to the following by adding the new lines not highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This adds three new properties: `_Albedo`, **`_Outline`**, and **`_OutlineColor`**.
    We added `_Albedo` in order to set a color on our materials without using a texture.
    `_Outline` defines the size of the outline, and `_OutlineColor` refers to the
    color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the identified lines, inject the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This block of code is the part that creates the outline and does this by rendering
    a second time. It does this using the `Pass` keyword. Inside `Pass`, we can see
    more tags being defined and another start to a shader program with `CGPROGRAM`.
    The second block is a **`vertex`**/`fragment` shader and if you look inside the
    `vert` function, you can see where the outline is calculated. It does this by
    projecting the models vertex `normal` a distance determined by `_Outline`. Then,
    in the `frag` function, we just return the outline color. Again, don't panic if
    this looks intimidating, it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last thing we need to do is add the new `_Albedo` property to our surface
    shader and add code to use it. Scroll down and add the following line after the
    identified line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down further to the `surf` function and modify the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All this is done to apply the `Albedo` color to the texture. If there is no
    texture, a value of `1.0` is used, which means just the `Albedo` color is shown.
    We needed to add this bit because our imported models didn't come with textures,
    and we didn't want to have to use a texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file and return to Unity. Ensure that you see no compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That completes the outline shader, but, of course, we want to test how it works.
    Let''s create a new material and set it on our model to see how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material called `ARMobileSpecularOutline_Green`in the `Assets/ARCoreDesign/Materials`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the new material's shader to use the newly created shader **ARCoreDesign**
    | **ARMobileSpecularOutline**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Albedo` color to a pleasant green, perhaps `#09D488FF`. Set the Shininess
    to about `0.5` or so, you decide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual color of the fabric material is `#8F8E2A`; use that color if you
    don't want such an obvious difference.
  prefs: []
  type: TYPE_NORMAL
- en: Set `_Outline` to `0.02`, which is still quite thick, but obvious. Use this
    value for now, and you can change it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `sofa` prefab in the `Assets/ARCoreDesign/Prefabs` folder and replace
    the **fabric** material with the new **ARMobileSpecularOutline_Green**, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb4b80c1-43fc-4c9a-95db-39150bbbc0e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Changing the sofa prefab to use the new material
  prefs: []
  type: TYPE_NORMAL
- en: Save your project. Connect, build, and then run. Place a `chair` and see how
    it looks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have our outline shader in place, but now we need to programmatically turn
    the outline on when a user selects an object.
  prefs: []
  type: TYPE_NORMAL
- en: Building the object outliner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build an `ObjectOutliner` class to handle the outlining for us. Follow
    along as we build the pieces to turn the outline on and off as the user selects
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script called `ObjectOutliner` in the `Assets/ARCoreDesign/Scripts`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace all of the pregenerated script with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This class basically just swaps the material of an object with its outlined
    or default material every time `Outline` is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the `SceneController.cs` script in your code editor. We have to
    wrap the `Session Raycast` call in the `Update` method with our own `Physics Raycast`.
    Add the following code around the highlighted code section, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This section of code uses the `Raycast` method of the `Physics` object. `Physics`
    is the object that encapsulates the Unity physics engine. `Raycast` is a method
    we use, just like `Frame.Raycast` we saw earlier, to cast a ray and check for
    any collisions. Normally, you filter out objects to test before you run a ray
    cast operation, because it is so expensive. You can see how this is done with
    `Session` in the setup of the `raycastFilter`, where the filter is set to test
    for planes, but you can also set this point as well. This will allow you to easily
    apply wall coverings, for instance. In our case, since we are using `Physics`
    to do the `Raycast`, we can ensure that you only get physics objects. The ARCore
    planes don't have physics objects attached to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `armchair` prefab in the `Assets/ARCoreDesign/Prefabs` folder and
    expand it to see the inner model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the armchair model and then, in the Inspector window, click on Add Component.
    Add a Box Collider to the object; the Box Collider will automatically adjust its
    size to surround the model. The `Physics` engine just tests for collisions against
    a collider and not the object. This is why we don't have to worry about our ARCore
    planes and points. If you add other models and want them selectable, then always
    use the simplest collider that best fits your shape. By simple, we mean less polygons.
    For instance, don't use a sphere collider when a Box Collider will do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Add Component button again and this time, add our new Object Outliner Script
    to the object and set its properties to what is shown in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9423d466-4b01-4cc8-a94a-0f5419b18a80.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the Object Outliner properties
  prefs: []
  type: TYPE_NORMAL
- en: Default Material represents the base look of the model. Then, we set the Outline
    Material to our outline material we created earlier. Lastly, we set the slot we
    want to replace. The element we want to replace is Element 1, so we put `1` in
    the Material Slot property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project, build, and run. Place a chair and then select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can place a chair, select it, and then deselect it. If you note that
    it is difficult to select an object, ensure that you check that the collider is
    sufficiently large to engulf the object. In our example, the automatically created
    collider for the armchair is slightly off; perhaps we can fix that issue with
    one of the exercise questions.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning the chair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step is to allow the user to move the chair after they select it.
    Fortunately, we can do all that in code. Open up your code editor to the `SceneController.cs`
    file and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `public` variable to the top of the class after the line identified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This new `float MoveSpeed` sets the speed at which the user can move an object.
    You can also think of it as the move sensitivity. We set it to the default value
    of `.1f` here, but feel free to change it in the Inspector later when testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the following highlighted section of code and replace it with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous code made sure to only test the for starting touches. Instead,
    we now want to check when a `touch` starts and then as the user moves their finger.
    Since our previous `Physics` raycast code wrapped the `Session` raycast code,
    we now need to wrap it again with code that tests for a first touch and move events,
    which is what our second `if` statement does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll to the line identified and add the following code before the end of
    the `Update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code we are adding here handles when the user is moving their finger. We
    then calculate a `change` vector relative to the camera's position. This transforms
    the `forward` or *z* axis relative to the camera by a delta position of the *y*
    axis in 2D, which more or less means that as the user moves their finger up and
    down on the screen, the object will move in and out on the `forward` axis, relative
    to the camera. To the `change` vector, we then add the `right` or *x* axis vector
    relative to the camera and modified by the delta of the user's finger along the
    x axis in 2D. Thus, when a user moves their finger left or right across the screen,
    the model will move left-right along the `right` axis relative to the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll up and change the **if** statement to add the new highlighted code starting
    with **&&**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This change just ensures that if the object is highlighted and selected again,
    the `Outline` method is not called. We no longer want to toggle the selection,
    but we will leave the `Outline` method this way for ease of use. Next, we want
    to handle when a user touches away from an object. In that case, we want to disable
    all the outlined objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, at any point, you lose track or get frustrated, take a look at the finished
    project available as part of the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Scroll down to the code identified and insert the new code to clear the outlines
    on the selected objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through the game `m_scene_Objects`, finds the `ObjectOutliner`
    component, and then uses that to test whether the outline is on. If the outline
    is on, it turns it off with a call to `Outline`, perhaps poorly named now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run. Wait for the surfaces to track and then place a `chair`.
    Touch to select and then use your finger to move the `chair` around. You can also
    adjust your position relative to the `chair` and watch how the object responds,
    all in real time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the volume down and power button at the same time to take a screenshot.
    Compare your picture to the following one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/724d754d-478e-499c-a004-37c97823b829.png)'
  prefs: []
  type: TYPE_IMG
- en: A virtual armchair placed and moved
  prefs: []
  type: TYPE_NORMAL
- en: Not bad, but we can probably do a bit better. In the next section, we will get
    back into lighting and work on the lighting and shadows of our objects.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting and shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lighting is an essential element in our scenes, but as we have already seen,
    it takes some work to get it right. In this section, we will revisit lighting
    and also tackle adding shadows. Adding shadows to our objects will make them look
    like they are really there. We will start with adding shadows, so open up Unity
    and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader called `UnlitShadowReceiver` in the `Assets/ARCoreDesign/Materials/Shaders`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the new shader to open it in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the autogenerated code and delete it. Then, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This shader is an example of a transparent shadow receiver. The shader works
    in two passes. In the first pass, we essentially clear the texture based on a
    cutoff alpha value. This allows us to turn an object transparent and still receive
    a shadow. The second pass draws the shadow using a vertex and fragment shader.
    Feel free to spend time studying this shader further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As ARCore matures, there will likely be more versions of transparent shadow
    receivers available. Plan to search for other options or other ways to improve
    this form of shader in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new material in the `Assets/ARCoreDesign/Materials` folder and name
    it as `UnlitShadowReceiver`. Set the properties of the material, as shown in the
    following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/27221d4d-4f02-48c3-9210-28747142050f.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the properties on the UnlitShadowReceiver material
  prefs: []
  type: TYPE_NORMAL
- en: Select and drag the `armchair` prefab from the `Assets/ARCoreDesign/Materials`
    folder in the **Project** window and drop it in an open area of the **Hierarchy**
    window. We want to adjust our prefab a bit, and this is the easiest way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, select **GameObject** | **3D** | **Plane**. Expand the `armchair`
    object and drag the Plane onto the 24 Ligne Roset Citta armchair child object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Plane and reset the position to (`0`, `0`, `0`) and scale to (`0.1`,
    `1`, `0.1`) on the Transform.Set the material to new UnlitShadowReceiver, as shown
    in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f94766c1-8af9-4b1e-8508-eb753131fd2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Plane material to UnlitShadowReceiver
  prefs: []
  type: TYPE_NORMAL
- en: Select the armchair object in the **Hierarchy** window and then in the `Inspector`
    window, click on the Apply button beside the Prefab properties to save the prefab.
    Leave the prefab in the scene for now, but we will want to delete it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We just created our transparent shadow receiver shader and then set it on a
    plane that we added to our prefab. We need to do this in order for our object,
    the `armchair`, to correctly cast a shadow on our new transparent receiver. Next,
    we need to turn on shadows, as the ARCore example has them disabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the shadows on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow along to turn shadows back on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Directional Light in the Hierarchy window and set the lights properties
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c51bcbed-9280-44c7-94b0-ffa9adef9e32.png)'
  prefs: []
  type: TYPE_IMG
- en: Turning on shadows for the Directional Light
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you change the Shadow Type, you should see an immediate change in
    the Scene window with the armchair now showing a shadow underneath. If you are
    unable to see a shadow yet, don't panic, we likely need to just adjust the quality
    settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ARCore example uses a blob texture for a shadow on the Andy model. By updating
    this to use a shader, we now have automatic support for any object you want to
    add. Just remember to adjust the plane to the object. If you wanted to add a painting
    or other wall hanging, you would set the plane vertical with the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the menu, select Edit | Project Settings | Quality. Set the Android build
    to use the highest quality settings by Default by clicking on the arrow icon underneath
    the Levels for Android. This is shown in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/986bfe82-8c1d-4414-a08c-74ab1c6cacf4.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Quality setting for the build
  prefs: []
  type: TYPE_NORMAL
- en: Make sure and apply the changes to the prefab again. This just assures us that
    are changes are saved before we delete the prefab from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select and delete the `armchair` object from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the highest quality settings in this example. For the most part,
    ARCore apps will run on relatively new devices, which means we can attempt to
    push the limits. If you find that the quality settings are crashing your device
    or not rendering correctly, then try dropping the quality on the build a level.
    You may want to do this anyway to improve your app's performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect, build, and run. Place a chair and see the difference, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/835e551e-9c60-4d57-8aad-6396c0a51f67.png)'
  prefs: []
  type: TYPE_IMG
- en: Example of the complete app with lighting and shadows
  prefs: []
  type: TYPE_NORMAL
- en: This is as far as we will go with the app in this chapter. Feel free to enhance
    the app on your own and take time to complete some of the optional exercises on
    your own. If the shadow doesn't show up correctly go back and edit the shadow
    settings on the light and the quality settings.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Answer the following questions on your own*:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the model in the app to the `sofa` or even another object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the changes we made to the `Environmental Light` script in order to track
    the light direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add other objects to the app and allow the user a choice on which to place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow the user to place vertical objects. Hint—you will need to render vertical
    planes now, yes ARCore does recognize vertical planes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow the user to rotate the model. Hint—you may have to add some control handles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, we have completed our simple example of a design app. We were able
    to complete all the major technical items we wanted to accomplish. We started
    with setting up a new Unity project using the ARCore example as a template. This
    saved us some time in what would have otherwise become a very long chapter. Next,
    we learned how to import new models from sites such as [TurboSquid](https://www.turbosquid.com/)
    and how to set them up as prefabs for later use. Then, we built a simple UI to
    allow us to clear the tracking planes from the view and clear any models. After
    that, we added the ability for a user to select and move an object in the AR scene.
    This required us to enhance one of the ARCore example shaders and heavily modify
    the `SceneController` script. Finally, we tackled shadows by turning on lights
    and adding a transparent shadow receiver to our object prefab.
  prefs: []
  type: TYPE_NORMAL
- en: ARCore is well suited for the next wave of HoloLens or mixed reality low-cost
    headsets. In the next chapter, we take a bit of a break from AR and dive into
    mixed reality, where we will build a multiplayer app called `HoloCore`.
  prefs: []
  type: TYPE_NORMAL
