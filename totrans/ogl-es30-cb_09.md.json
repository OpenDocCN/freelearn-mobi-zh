["```java\n       void EdgeDetection::GenerateFBO(){\n       glGetRenderbufferParameteriv(GL_RENDERBUFFER,GL_RENDERBUFFER_WIDTH, &TEXTURE_WIDTH);\n\n       glGetRenderbufferParameteriv(GL_RENDERBUFFER,\n       GL_RENDERBUFFER_HEIGHT, &TEXTURE_HEIGHT);\n\n       glGenFramebuffers(1, &FboId); // Create FBO\n       glBindFramebuffer(GL_FRAMEBUFFER, FboId);\n\n       // Create color and depth buffer textureobject\n        textureId = generateTexture(\n        TEXTURE_WIDTH,TEXTURE_HEIGHT);\n        depthTextureId = generateTexture(TEXTURE_WIDTH,TEXTURE_HEIGHT,true);\n\n        // attach the texture to FBO color \n        // attachment point\n        glFramebufferTexture2D(GL_FRAMEBUFFER,\n        GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureId, 0);\n\n       // attach the texture to FBO color \n       // attachment point\n       glFramebufferTexture2D(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D,depthTextureId, 0);\n\n       // check FBO status\n       GLenum status = glCheckFramebufferStatus(\n       GL_FRAMEBUFFER);\n       if(status != GL_FRAMEBUFFER_COMPLETE){\n       printf(\"Framebuffer creation fails: %d\", status);\n                    }\n       glBindFramebuffer(GL_FRAMEBUFFER, 0);\n             }\n    ```", "```java\n    void EdgeDetection::RenderObj(){\n        // Get the default Framebuffer\n        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &DefaultFBO);\n\n        // Bind Framebuffer object\n        glBindFramebuffer(GL_FRAMEBUFFER,FboId);\n        glViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n        glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0, \n        GL_TEXTURE_2D, textureId,0);\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,\n        GL_TEXTURE_2D, depthTextureId, 0);\n\n        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n        objModel->Render();\n\n        glBindFramebuffer(GL_FRAMEBUFFER, DefaultFBO);\n    }\n    ```", "```java\n      TransformObj->TransformSetMatrixMode( PROJECTION_MATRIX );\n      TransformObj->TransformLoadIdentity();\n      float span = 1.0;\n      TransformObj->TransformOrtho(-span,span,-span,span,-span,span);\n    ```", "```java\n    void EdgeDetection::EdgeDetect(){\n        glDisable(GL_DEPTH_TEST);\n        glBindFramebuffer(GL_FRAMEBUFFER, DefaultFBO);\n        glViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n        glActiveTexture (GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D,textureId);\n\n        program = ProgramManagerObj->Program\n    ((char*)\"EdgeDetection\" );\n        glUseProgram( program->ProgramID );\n        GLint PIXELSIZE = ProgramManagerObj->ProgramGetUniformLocation\n    (program, (char*) \"pixelSize\");\n        glUniform2f(PIXELSIZE, 1.0/TEXTURE_HEIGHT,\n    1.0/TEXTURE_WIDTH);\n        textureQuad->Render();\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    in vec2 TexCoord;\n    uniform vec2 pixelSize;\n    uniform sampler2D Tex1;\n    layout(location = 0) out vec4 outColor;\n    uniform float GradientThreshold;\n    float p00,p10,p20,p01,p21,p02,p12,p22,x,y,px,py,distance;\n    vec3 lum = vec3(0.2126, 0.7152, 0.0722);\n    void main(){\n        x = pixelSize.x; y = pixelSize.y;\n        p00 = dot(texture(Tex1, TexCoord+vec2(-x, y)).rgb, lum);\n        p10 = dot(texture(Tex1, TexCoord+vec2(-x,0.)).rgb, lum);\n        p20 = dot(texture(Tex1, TexCoord+vec2(-x,-y)).rgb, lum);\n        p01 = dot(texture(Tex1, TexCoord+vec2(0., y)).rgb, lum);\n        p21 = dot(texture(Tex1, TexCoord+vec2(0.,-y)).rgb, lum);\n        p02 = dot(texture(Tex1, TexCoord+vec2( x, y)).rgb, lum);\n        p12 = dot(texture(Tex1, TexCoord+vec2( x,0.)).rgb, lum);\n        p22 = dot(texture(Tex1, TexCoord+vec2( x,-y)).rgb, lum);\n\n    // Apply Sobel Operator\n\n        px = p00 + 1.0*p10 + p20 - (p02 + 1.0*p12 + p22);\n        py = p00 + 1.0*p01 + p02 - (p20 + 1.0*p21 + p22);\n        // Check frequency change with given threshold\n        if ((distance = px*px+py*py) > GradientThreshold ){\n            outColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }else{ outColor = vec4(1.0); }\n    }\n    ```", "```java\n    #version 300 es\n    // Vertex information\n    layout(location = 0) in vec3  VertexPosition;\n    layout(location = 1) in vec2  VertexTexCoord;\n\n    out vec2 TexCoord;\n    uniform mat4 ModelViewProjectionMatrix;\n    void main( void ) {\n        TexCoord = VertexTexCoord;\n        vec4 glPos = ModelViewProjectionMatrix *\n        vec4(VertexPosition,1.0);\n        vec2 Pos = sign(glPos.xy);\n        gl_Position = ModelViewProjectionMatrix *\n        vec4(VertexPosition,1.0);\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    in vec2 TexCoord; \n    uniform vec2 pixelSize; \n    uniform sampler2D Tex1;\n\n    layout(location = 0) out vec4 outColor;\n\n    uniform float PixOffset[5];   // Texel distance\n    uniform float Weight[5];      // Gaussian weights\n\n    void main(){\n        vec4 sum = texture(Tex1, TexCoord) * Weight[0];\n        for( int i = 1; i < 5; i++ ){ // Loop 4 times\n           sum+=texture( Tex1, TexCoord + vec2(PixOffset[i],0.0)\n           * pixelSize.x) * Weight[i];\n           sum += texture( Tex1, TexCoord - vec2(PixOffset[i],0.0) \n           * pixelSize.x) * Weight[i];\n        }\n        outColor = sum;\n    }\n    ```", "```java\n    // Use same code from BlurHorizontal.glsl\n    void main(){\n        vec4 sum = texture(Tex1, TexCoord) * Weight[0];\n        for( int i = 1; i < 5; i++ ){ // Loop 4 times\n          sum+=texture( Tex1, TexCoord + vec2(0.0, PixOffset[i])\n          * pixelSize.y) * Weight[i];\n          sum += texture( Tex1, TexCoord - vec2(0.0, PixOffset[i])\n          * pixelSize.y) * Weight[i];}\n          outColor = sum;\n    }\n    ```", "```java\n    float GaussianBlur::GaussianEquation(float value, float sigma){\n    return 1./(2.*PI*sigma)*exp(-(value*value)/(2*sigma));\n    }\n    ```", "```java\n       gWeight[0]  = GaussianBlur::GaussianEquation(0, sigma);\n        sum         = gWeight[0]; // Weight for centered texel\n\n        for(int i = 1; i<FILTER_SIZE; i++){\n            gWeight[i] = GaussianBlur::GaussianEquation(i, sigma);\n\n           // Why multiplied by 2.0? because each weight\n           // is applied in +ve and â€“ve direction from the \n           // centered texel in the fragment shader.\n            sum += 2.0 * gWeight[i];\n        }\n\n        for(int i = 0; i<FILTER_SIZE; i++){\n            gWeight[i] = gWeight[i] / sum;\n        }\n\n        if (GAUSSIAN_WEIGHT_HOR >= 0){\n            glUniform1fv(GAUSSIAN_WEIGHT_HOR, \n            sizeof(gWeight)/sizeof(float), gWeight);\n        }\n\n        // Similarly, pass the weight to vertical Gaussian \n        // blur fragment shader corresponding weight \n        // variable GAUSSIAN_WEIGHT_VERT\n\n        float pixOffset[FILTER_SIZE];\n        // Calculate pixel offset \n        for(int i=0; i<FILTER_SIZE; i++){ pixOffset[i] = float(i); }\n        if (PIXEL_OFFSET_HOR >= 0){\n            glUniform1fv(PIXEL_OFFSET_HOR, sizeof(pixOffset)/\n            sizeof(float), pixOffset);\n        }\n    ```", "```java\n    void GaussianBlur::Render(){\n       // Set up perspective projection\n        SetUpPerspectiveProjection();\n\n        RenderObj();\n        // Set up orthographic project for HUD display\n        SetUpOrthoProjection();\n        RenderHorizontalBlur();\n        RenderVerticalBlur();\n    }\n\n    void GaussianBlur::RenderObj(){\n        // Get the current framebuffer handle\n        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &CurrentFbo);\n\n        // Bind Framebuffer 1\n        glBindFramebuffer(GL_FRAMEBUFFER,blurFboId1);\n        glViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_-ATTACHMENT0, GL_TEXTURE_2D, textureId,0);\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_-ATTACHMENT, GL_TEXTURE_2D, depthTextureId, 0);\n\n        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n        objModel->Render();\n\n        glBindFramebuffer(GL_FRAMEBUFFER, CurrentFbo);\n    }\n    ```", "```java\n    void GaussianBlur::RenderHorizontalBlur(){\n        glDisable(GL_DEPTH_TEST);\n\n        // Bind Framebuffer 2\n        glBindFramebuffer(GL_FRAMEBUFFER,blurFboId2);\n        glViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n        glFramebufferTexture2D(GL_FRAMEBUFFER, \n         GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureId2, 0);\n        glActiveTexture (GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, textureId);\n\n        // Apply the shader for horizontal blur pass\n        program = textureQuad->ApplyShader(HorizontalBlurShader);\n        textureQuad->Render();\n        TransformObj->TransformError();\n    }\n    ```", "```java\n     void GaussianBlur::RenderVerticalBlur() {\n        glDisable(GL_DEPTH_TEST);\n\n     // Restore to old framebuffer \n        glBindFramebuffer(GL_FRAMEBUFFER, CurrentFbo);\n        glViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n        glActiveTexture (GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_2D,textureId2);\n\n        // Apply the shader for horizontal blur pass\n        program = textureQuad->ApplyShader(VerticalBlurShader);\n        GLint PIXELSIZE = ProgramManagerObj->ProgramGetUniform-Location( program, (char *) \"pixelSize\" );\n        glUniform2f(PIXELSIZE, 1.0/TEXTURE_HEIGHT,1.0/TEXTURE_WIDTH);\n\n        textureQuad->Render();\n    }\n    ```", "```java\n       in vec2 TexCoord;\n       uniform sampler2D Tex1;\n       layout(location = 0) out vec4 outColor;\n       void main() {\n       vec4 val = texture(Tex1, TexCoord);\n       float brightness = 0.212*val.r + 0.715*val.g + 0.072*val.b;\n       brightness>0.6 ? outColor=vec4(1.) : outColor=vec4(0.); \n    }\n    ```", "```java\n    void main(){\n         vec4 scene = texture(RenderTex, TexCoord);\n         vec4 sum = texture(Tex1, TexCoord) * Weight[0];\n         for( int i = 1; i < 5; i++ ){\n         sum+=texture(Tex1,TexCoord+vec2(0.0,PixOffset[i]) \n        *pixelSize.y)*Weight[i];\n        sum+=texture(Tex1,TexCoord-vec2(0.0,PixOffset[i]) \n        *pixelSize.y)*Weight[i];\n     }\n         outColor = sum + scene;\n    }\n    ```", "```java\n    void Bloom::Render(){\n       // Perspective projection\n       SetUpPerspectiveProjection(); \n       glGetIntegerv(GL_FRAMEBUFFER_BINDING, &DefaultFrameBuffer);\n\n       // Render scene in first FBO called SceneFBO\n       RenderObj(NULL, SceneFbo, SceneTexture, DepthTexture); \n\n       // Orthographic projection\n       SetUpOrthoProjection(); \n\n       // Render Bloom pass  \n       RenderBloom(SceneTexture, BloomFbo, BloomTexture, NULL);\n\n       // Render Horizontal pass\n       RenderHorizontalBlur(BloomTexture,\n       BlurFbo, BlurTexture, NULL);\n       // Render Vertical pass\n       RenderVerticalBlur(BlurTexture,\n       DefaultFrameBuffer,NULL,NULL);\n    }\n    ```", "```java\nuniform float quantizationFactor;\nvoid main(){\n    // Reuse Edge detection recipe fragment shader and\n    // Calculate p00, p10, p20,p01, p21, p02, p12, p22 \n    px = p00 + 2.0*p10 + p20 - (p02 + 2.0*p12 + p22);\n    py = p00 + 2.0*p01 + p02 - (p20 + 2.0*p21 + p22);\n    // Check frequency change with given threshold\n    if ((distance = px*px+py*py) > GradientThreshold ){\n        outColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }else{ // Apply the Cartoon shading\n    rgb = texture(Tex1,TexCoord).rgb*quantizationFactor;\n    rgb += vec3(0.5, 0.5, 0.5);\n    ivec3 intrgb = ivec3(rgb);\n    rgb = vec3(intrgb)/ quantizationFactor;\n    outColor = vec4(rgb,1.0); \n   }\n}\n```", "```java\nin vec2 TexCoord;\nuniform vec2 pixelSize;\nuniform sampler2D Tex1;\nlayout(location = 0) out vec4 outColor;\nuniform float EmbossBrightness, ScreenCoordX;\n\nvoid main(){\n   // Apply Emboss shading\n   vec3 p00 = texture(Tex1, TexCoord).rgb;\n   vec3 p01 = texture(Tex1, TexCoord + vec2(0.0,\n pixelSize.y)).rgb;\n\n// Consecutive texel difference\n   vec3 diff = p00 - p01;\n\n// Find the max value among RGB\n   float maximum = diff.r;\n   if( abs(diff.g) > abs(maximum) ){ \n   maximum = diff.g;\n}\n\nif( abs(diff.b) > abs(maximum) ){\n    maximum = diff.b;\n}\n\n// Choose White, Black, or Emboss color\n   float gray = clamp(maximum+EmbossBrightness, 0.0, 1.0);\n   outColor = vec4(gray,gray,gray, 1.0);\n\n}\n```", "```java\nvoid clamp(genType x, genType minVal, genType maxVal);\n```", "```java\nin vec2 TexCoord;\nuniform sampler2D Tex1;\n  layout(location = 0) out vec4 outColor;\n  // Luminance weight as per ITU-R BT.709 standard\n  const vec3 luminanceWeight = vec3(0.2125, 0.7154, 0.0721);\n  void main() {\n  vec4 rgb = texture(Tex1, TexCoord); // Take the color sample\n  // Multiply RGB with luminance weight\n  float luminace = dot(rgb.rgb, luminanceWeight);\n  outColor = vec4(luminace, luminace, luminace, rgb.a); \n}\n```", "```java\n   in vec2 TexCoord;\n   uniform sampler2D Tex1;\n   uniform float ScreenCoordX;\n   uniform int caseCYMK;\n   layout(location = 0) out vec4 outColor;\n   void main() { // Main Entrance\n   vec4 rgb  = texture(Tex1, TexCoord);\n   vec3 cmy  = vec3(1.0)-rgb.rbg;\n   float k   = min(cmy.r, min(cmy.g, cmy.b));\n\n   // fucr (K)= SK*K, SK = 0.1 \n   vec3 target  = cmy - 0.1 * k;\n\n   // fbg (K) = 0, when K<K0, K0 =0.3, Kmax =0.9\n   // fbg (K) = Kmax*(K-K0)/(1-K0), when K>=K0\n   k<0.3 ? k=0.0 : k=0.9*(k-0.3)/0.7; \n   vec4 cmyk = vec4(target, k);\n// Since we are interested in the separation of each component\n// we subtracted gray scale of each color component from white\n   if(caseCYMK == 0){              // CYAN conversion\n      outColor = vec4(vec3(1.0 - cmyk.x),rgb.a);\n   }else if(caseCYMK == 1){     // MAGENTA conversion\n       outColor = vec4(vec3(1.0 - cmyk.y),rgb.a);}\n   else if(caseCYMK == 2){     // YELLOW conversion\n       outColor = vec4(vec3(1.0 - cmyk.z),rgb.a);}\n   else if(caseCYMK == 3){     // BLACK conversion\n       outColor = vec4(vec3(1.0 - cmyk.w),rgb.a);}\n   else{ outColor = rgb;}      // RGB\n}\n```", "```java\nprecision mediump float;\nin vec2 TexCoord;\nuniform sampler2D Tex1;\nlayout(location = 0) out vec4 outColor;\n\nuniform float BarrelPower;\nuniform float ScreenCoordX;\n\nvec2 BarrelDistortion(vec2 p){\n    float theta  = atan(p.y, p.x);\n    float radius = sqrt(p.x*p.x + p.y*p.y); \n    radius = pow(radius, BarrelPower);\n    p.x = radius * cos(theta);\n    p.y = radius * sin(theta);\n    return (p + 0.5);\n}\n\nvec2 xy, uv;\nfloat distance;\nvoid main(){\n      if(gl_FragCoord.x > ScreenCoordX){\n          // The range of text coordinate is from (0,0)\n          // to (1,1). Assuming center of the Texture\n          // coordinate system middle of the screen.\n          // Shift all coordinate wrt to the new \n          // center. This will be the new position \n          // vector of the displaced coordinate.\n          xy = TexCoord - vec2(0.5);\n\n         // Calculate the distance from the center point.\n         distance = sqrt(xy.x*xy.x+xy.y*xy.y); \n\n         float radius = 0.35;\n         // Apply the Barrel Distortion if the distance\n         // is within the radius. Our radius is half of \n         // the ST dimension.\n         uv = (distance < radius?BarrelDistortion(xy):TexCoord);\n\n         if( distance > radius-0.01 && distance < radius+0.01 ){\n             outColor = vec4(1.0, 0.0, 0.0,1.0);\n         }\n         else{\n             // Fetch the UV from Texture Sample\n             outColor = texture(Tex1, uv);\n         }\n     }\n     else{\n        outColor = texture(Tex1, TexCoord);\n     }\n}\n```", "```java\nlayout(location = 0) in vec4  VertexPosition;\nlayout(location = 1) in vec3  Normal;\nuniform mat4   ModelViewProjectionMatrix, ModelViewMatrix;\nuniform mat3    NormalMatrix;\nout vec3         normalCoord, eyeCoord, ObjectCoord;\nuniform float   BarrelPower;\n\nvec4 BarrelDistortion(vec4 p){\n    vec2 v = p.xy / p.w;\n    float radius = length(v);\n   // Convert to polar coords\n    if (radius > 0.0){ \n        float theta = atan(v.y,v.x);\n        radius = pow(radius, BarrelPower);\n    // Apply distortion\n        // Convert back to Cartesian\n        v.x = radius * cos(theta); \n        v.y = radius * sin(theta);\n        p.xy = v.xy * p.w;\n    }\n    return p;\n}\n\nvoid main(){\n    normalCoord = NormalMatrix * Normal;\n    eyeCoord    = vec3 ( ModelViewMatrix * VertexPosition );\n    ObjectCoord = VertexPosition.xyz;\n    gl_Position = BarrelDistortion(ModelViewProjectionMatrix*\n    VertexPosition);\n} \n```", "```java\n#version 300 es\nprecision mediump float;\nin vec2 TexCoord; \nuniform sampler2D Tex1;\nuniform vec2 center;\nuniform float horizontalAspectRatio, verticalAspectRatio;\nuniform float LensInnerRadius,LensOuterRadius;\nuniform vec4 BorderColor;\n\nlayout(location = 0) out vec4 outColor;\nvoid main() {\noutColor = texture(Tex1, TexCoord);\n   float dx = TexCoord.x-center.x; \nfloat dy = TexCoord.y-center.y;\n\ndx *= horizontalAspectRatio; \ndy *= verticalAspectRatio;\n   float distance = sqrt(dx * dx + dy * dy);\n   outColor = mix( outColor, BorderColor,\n       smoothstep(LensInnerRadius, LensOuterRadius, distance));\n  return;\n}\n```", "```java\nin vec2 TexCoord;\nuniform sampler2D Tex1;\nuniform float ScreenCoordX,twirlRadius,angle,imageHeight, imageWidth;\nuniform vec2 center;\nfloat radiusFactor = 3.0;\nlayout(location = 0) out vec4 outColor;\n// Note: the angle is assumed to be in radians to \n// work with trigonometric functions.  \nvec4 Twirl(sampler2D tex, vec2 uv, float angle){\n    // Get the current texture size of the image\n    vec2 texSize = vec2(imageWidth, imageHeight);\n\n    // Change the texCoordinate w.r.t. to the image dimensions\n    vec2 tc = (uv * texSize) - center;\n\n    // Calculate the distance of the current transformed\n // texture coordinate from the center.\n    float distance = sqrt(tc.x*tc.x + tc.y*tc.y);\n    if (distance < twirlRadius+angle*radiusFactor){\n        float percent   = (twirlRadius - distance)/twirlRadius;\n        float theta     = percent * percent * angle;\n        float sinus     = sin(theta);\n        float cosine    = cos(theta);\n        tc = vec2(dot(tc, vec2(cosine, -sinus)), dot(tc,\n vec2(sinus, cosine)));\n    }\n return texture(tex, (tc+center) / texSize);\n}\n\nvoid main() {\nif(gl_FragCoord.x > ScreenCoordX)\noutColor = Twirl(Tex1, TexCoord, angle); \nelse\noutColor = texture(Tex1, TexCoord);\n}\n```", "```java\n    float vertexColors[12] = { 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0 };\n    float texCoords[8]   = { 0.f, 0.f, 1.f, 0.f, 0.f, 1.f, 1.f, 1.f };\n    float quad[8]       = { -1.f,-1.f,1.f,-1.f,-1.f, 1.f, 1.f,1.f};\n    ```", "```java\n    #version 300 es\n    uniform mat4 ModelViewProjectMatrix;\n    layout(location = 0) in vec3  VertexPosition;\n    layout(location = 1) in vec2  VertexTexCoord;\n    layout(location = 2) in vec4  VertexColor;\n    out vec4 TriangleColor; out vec2 TexCoord;\n\n    void main() {\n     gl_Position = ModelViewProjectMatrix*vec4(VertexPosition,1.0);\n     TriangleColor = VertexColor;\n     TexCoord = VertexTexCoord;\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    in vec4 TriangleColor; \n    in vec2 TexCoord;\n    uniform float ScreenWidth; \n    uniform float ScreenHeight;\n    uniform float ScreenCoordX; \n    uniform float ScreenCoordY;\n    out vec4 FragColor;\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));\n\n    void main() {\n    vec2 resolution = vec2(ScreenWidth, ScreenHeight);\n       vec2 center     = vec2(resolution.x/2.0, resolution.y/2.0);\n        lightDir = normalize(vec3((ScreenCoordX - center.x)\n    /(ScreenWidth*0.5), (ScreenCoordY - center.y)\n    /(ScreenHeight*0.5), 1.0));\n\n        float radius   = 0.5; // Calculate the sphere radius\n     vec2 position  = TexCoord.xy - vec2(0.5, 0.5);\n        float z       = sqrt(radius*radius â€“ \n    position.x*position.x - position.y*position.y);\n        vec3 normal=normalize(vec3(position.x,position.y,abs(z)));\n        if (length(position) > radius) { // Outside\n            FragColor = vec4(vec3(0.0,0.0,0.0), 0.0);\n        } else { // Inside\n            float diffuse = max(0.0, dot(normal, lightDir));\n            FragColor = vec4(vec3(diffuse), 1.0);\n        }\n    }\n    ```"]