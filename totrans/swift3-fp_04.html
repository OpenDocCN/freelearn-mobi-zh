<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Enumerations and Pattern Matching</h1></div></div></div><p>In 
<a class="link" href="ch01.html" title="Chapter 1. Getting Started with Functional Programming in Swift">Chapter 1</a>
, <em>Getting Started with Functional Programming in Swift</em>, we were introduced to enumerations briefly. In this chapter, we will cover enumerations and algebraic data types in detail. Also, we will explore patterns and pattern matching in Swift.</p><p>This chapter will cover the following topics with coding examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining enumerations</li><li class="listitem" style="list-style-type: disc">Associated values</li><li class="listitem" style="list-style-type: disc">Raw values</li><li class="listitem" style="list-style-type: disc">Using enumerations</li><li class="listitem" style="list-style-type: disc">Algebraic data types</li><li class="listitem" style="list-style-type: disc">Patterns and pattern matching</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Defining enumerations</h1></div></div></div><p>In Swift, an enumeration defines a common type for related values and enables us to work with those values in a type-safe way. Values provided for each enumeration member can be a <code class="literal">String</code>, <code class="literal">Character</code>, <code class="literal">Integer</code>, or any <code class="literal">floating-point</code> type. The following example presents a simple definition of an enumeration:</p><pre class="programlisting">enum MLSTeam {&#13;
    case montreal&#13;
    case toronto&#13;
    case newYork&#13;
    case columbus&#13;
    case losAngeles&#13;
    case seattle&#13;
}&#13;
&#13;
let theTeam = MLSTeam.montreal&#13;
</pre><p>
<code class="literal">MLSTeam</code>
<code class="literal">enum</code> provides us options for MLS teams. We can choose only one of the options each time; in our example, <code class="literal">Montreal</code> is chosen.</p><p>Multiple cases can be defined, separated by a comma on a single line:</p><pre class="programlisting">enum MLSTeam {&#13;
    case montreal, toronto, newYork, columbus, losAngeles, Seattle&#13;
}&#13;
&#13;
var theTeam = MLSTeam.montreal&#13;
</pre><p>The type of <code class="literal">theTeam</code> is inferred when it is initialized with <code class="literal">MLSTeam.montreal</code>. As <code class="literal">theTeam</code> is already defined, we can change it with a shorter syntax as follows:</p><pre class="programlisting">theTeam = .newYork&#13;
</pre><p>We were able to change <code class="literal">theTeam</code> with a short syntax because <code class="literal">theTeam</code> was already inferred and was not a constant.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Associated values</h1></div></div></div><p>Enumerations can store associated values of any given type, and the value types can be different for each member of the enumeration if required. Enumerations similar to these are known as discriminated unions, tagged unions, or variants in other programming languages. The following example presents a simple usage of associated values:</p><pre class="programlisting">enum Length {&#13;
    case us(Double)&#13;
    case metric(Double)&#13;
}&#13;
&#13;
let lengthMetric = Length.metric(1.6)&#13;
</pre><p>The enumeration type, <code class="literal">Length</code>, can either take a value of <code class="literal">US</code> with an associated value of the <code class="literal">Double</code> type or a value of <code class="literal">metric</code> with an associated value of the <code class="literal">Double</code> type.</p><p>The <code class="literal">lengthMetric</code> is a variable that gets assigned as a value of <code class="literal">Length.metric</code> with an associated value of <code class="literal">1.6</code>.</p><p>As seen in the preceding example, associated values are set when we create a new constant or variable based on one of the enumeration's cases and can be different each time we do so.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Raw values</h1></div></div></div><p>Enumeration members can come prepopulated with default values (called <strong>raw values</strong>), which are all of the same type. The following example presents an incomplete <code class="literal">HttpError enum</code> with raw values:</p><pre class="programlisting">enum HttpError: Int {&#13;
    case badRequest = 400&#13;
    case unauthorized = 401&#13;
    case forbidden = 403&#13;
}&#13;
</pre><p>In the preceding example, the raw values for <code class="literal">enum</code> called <code class="literal">HttpError</code> are defined to be of the <code class="literal">Int</code> type and are set to some of their integer code.</p><p>Raw values can be of <code class="literal">String</code>, <code class="literal">Character</code>, <code class="literal">Int</code>, or any floating number types. Each raw value must be unique within its enumeration declaration.</p><p>Raw values are set to prepopulated values when we first define the enumeration such as <code class="literal">HttpError</code> in the preceding example; therefore, the raw value for an enumeration case is always the same and it is not going to change, unlike associated values.</p><p>If we define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value's type and returns either an enumeration <code class="literal">case</code> or <code class="literal">nil</code>. We can use this initializer to try to create a new instance of the enumeration. The following example presents the initialization of an <code class="literal">HttpError</code> instance:</p><pre class="programlisting">let possibleError = HttpError(rawValue: 400)&#13;
print(possibleError)&#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Algebraic data types</h1></div></div></div><p>Enumerations in Swift are actually algebraic data types that are types created by combining other types. Algebraic data types are essential to many functional programming languages such as Haskell.</p><p>An algebraic data type is based on the idea of algebraic structures, which are a set of possible values and one or more operators to combine a finite number of these values into a single one. A well-known structure, for example, is (<code class="literal">ℤ</code>, <code class="literal">+</code>, <code class="literal">-</code>), a set of all integers with the plus and minus operations on them.</p><p>So an algebraic data type is a data type that is created by algebraic operations, specifically, with sum and product as our operations.</p><p>Additionally, algebraic data types are composite data types that may contain multiple values such as a data type with multiple fields, or they may consist of variants or multiple finite different values.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Simple types</h2></div></div></div><p>The <code class="literal">Boolean</code> type is a simple algebraic data type as it may take one of two values: <code class="literal">true</code> or <code class="literal">false</code>. An instance of a <code class="literal">Boolean</code> type should be either <code class="literal">true</code> or <code class="literal">false</code>, but the instance cannot be both at once; it has to be one or the other unlike the <code class="literal">struct</code>/<code class="literal">class</code> properties and variables.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Composite types</h2></div></div></div><p>Algebraic data types can also be composite types. For instance, a tuple of two <code class="literal">Double</code> values is a simple algebraic data type. Such a tuple could be expressed as having the <code class="literal">(Double, Double)</code> type, and an example value for this type could be <code class="literal">(1.5, 3.2)</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Composite type with variants</h2></div></div></div><p>Algebraic data types can be composite types with variants as well. We could create an <code class="literal">enum</code> named <code class="literal">Dimension</code> to hold the length and width. We can express this <code class="literal">enum</code> in both <code class="literal">us</code> feet and <code class="literal">metric</code> meters. In Swift, we can define such an <code class="literal">enum</code> as follows:</p><pre class="programlisting">enum Dimension {&#13;
    case us(Double, Double)&#13;
    case metric(Double, Double)&#13;
}&#13;
</pre><p>Then we can use the <code class="literal">Dimension</code> enumeration to create a variable as follows:</p><pre class="programlisting">let sizeMetric = Dimension.metric(5.0, 4.0)&#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>The algebra of data types</h2></div></div></div><p>We have seen that enums in Swift are actually algebraic data types. Let's explore some examples to get more familiar with the topic.</p><p>The following example presents a simple <code class="literal">enum</code>
<code class="literal">NHLTeam</code> with different options. The <code class="literal">enum</code>
<code class="literal">Team</code> uses <code class="literal">NHLTeam</code> along with <code class="literal">MLSTeam</code> that we have defined before to combine <code class="literal">Hockey</code> and <code class="literal">Soccer</code> teams. <code class="literal">Team</code> can be either a <code class="literal">Hockey NHL</code> team or a <code class="literal">Soccer MLS</code> team:</p><pre class="programlisting">enum NHLTeam {&#13;
    case canadiens&#13;
    case senators&#13;
    case rangers&#13;
    case penguins&#13;
    case blackHawks&#13;
    case capitals&#13;
}&#13;
&#13;
enum MLSTeam {&#13;
    case montreal&#13;
    case toronto&#13;
    case newYork&#13;
    case columbus&#13;
    case losAngeles&#13;
    case seattle&#13;
}&#13;
&#13;
struct HockeyAndSoccerTeams {&#13;
    var hockey: NHLTeam&#13;
    var soccer: MLSTeam&#13;
}&#13;
</pre><p>
<code class="literal">MLSTeam</code> and <code class="literal">NHLTeam</code> each have six potential values. If we combine them, we will have two new types. <code class="literal">Team</code> can be either <code class="literal">NHLTeam</code> or <code class="literal">MLSTeam</code>, so it has 12 potential values that is the sum of <code class="literal">NHLTeam</code> and <code class="literal">MLSTeam</code> potential values. Therefore, the <code class="literal">Team</code>
<code class="literal">enum</code> is a sum type.</p><p>To have a <code class="literal">HockeyAndSoccerTeams</code> structure, we need to choose one value for <code class="literal">NHLTeam</code> and one for <code class="literal">MLSTeam</code> so it has 36 potential values that are the product of <code class="literal">NHLTeam</code> and <code class="literal">MLSTeam</code> values. Therefore, <code class="literal">HockeyAndSoccerTeams</code> is a product type.</p><p>In Swift, an enumeration's option can have multiple values. If it happens to be the only option, then this enumeration becomes a product type. The following example presents an <code class="literal">enum</code> as a product type:</p><pre class="programlisting">enum HockeyAndSoccerTeams {&#13;
    case Value(hockey: NHLTeam, soccer: MLSTeam)&#13;
}&#13;
</pre><p>Recursion types are another class of algebraic data types.</p><p>A recursive data type is a data type for values that may contain other values of the same type. An important application of recursion in computer science is in defining dynamic data structures such as arrays. Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements.</p><p>Operations used to do simple integer arithmetic can be modeled with <code class="literal">enums</code>. These operations let us combine simple arithmetic expressions. <em>The Swift Programming Language(3.0)</em> by <em>Apple Inc.</em> provides an example of simple integer arithmetic.</p><p>Another example of recursive data structures is a Tree that is implemented as a recursive data type:</p><pre class="programlisting">enum Tree {&#13;
    case empty&#13;
    case leaf(Int)&#13;
    indirect case node(Tree, Tree)&#13;
}&#13;
&#13;
let ourTree = Tree.node(Tree.leaf(1), Tree.node(Tree.leaf(2),&#13;
  Tree.leaf(3)))&#13;
print(ourTree)&#13;
</pre><p>
<code class="literal">Tree</code> can be empty; it can have a leaf or another <code class="literal">Tree</code> as <code class="literal">node</code>.</p><p>As the data is nested, the enumeration used to store the data also needs to support nesting, which means that the enumeration needs to be recursive.</p><p>The compiler has to insert a layer of indirection when it works with recursive enumerations. We indicate that an enumeration case is recursive by writing <code class="literal">indirect</code> before it.</p><p>The following example presents the search function on <code class="literal">Tree</code>:</p><pre class="programlisting">func searchInTree(_ search: Int, tree: Tree) -&gt; Bool {&#13;
    switch tree {&#13;
    case .leaf(let x):&#13;
        return x == search&#13;
    case .node(let l as Tree, let r as Tree):&#13;
        return searchInTree(search, tree:l) || searchInTree(search, tree:r)&#13;
    default:&#13;
        return false&#13;
    }&#13;
}&#13;
&#13;
let isFound = searchInTree(3, tree: ourTree) // will return true&#13;
print(isFound)&#13;
</pre><p>As we can create <code class="literal">sum</code>, <code class="literal">product</code>, or <code class="literal">recursion</code> types in Swift, we can say that Swift has first-class support for algebraic data types.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Pattern matching</h1></div></div></div><p>Programming languages that support algebraic data types often support a set of features to work with fields of composite types or variants of a type. These features are essential in defining functions to operate on different fields or variants in a type-safe manner.</p><p>One such feature is called <strong>pattern matching</strong> that enables us to define functions that operate differently on each of a type's variants and extract individual fields from a composite type while maintaining the language's type safety guarantees.</p><p>In fact, the compilers of many languages with pattern matching will issue warnings or errors if we do not handle all of a type's fields or variants properly. These warnings help us write safer and more robust code.</p><p>The following example presents simple pattern matching with a switch statement:</p><pre class="programlisting">let theTeam = MLSTeam.montreal&#13;
&#13;
switch theTeam {&#13;
case .montreal:&#13;
    print("Montreal Impact")&#13;
case .toronto:&#13;
    print("Toronto FC")&#13;
case .newYork:&#13;
    print("Newyork Redbulls")&#13;
case .columbus:&#13;
    print("Columbus Crew")&#13;
case .losAngeles:&#13;
    print("LA Galaxy")&#13;
case .seattle:&#13;
    print("Seattle Sounders")&#13;
}&#13;
</pre><p>In this example, the Swift compiler infers <code class="literal">theTeam</code> as <code class="literal">MLSTeam</code>; therefore, we do not need to write <code class="literal">MLSTeam</code> for each case.</p><p>We use the switch case to match the pattern as it is a basic way of pattern matching for enumerations in Swift. This code block will print <code class="literal">Montreal Impact</code> as it matches the <code class="literal">.montreal</code> case.</p><p>To further explore pattern matching, we can look at the other example, the <code class="literal">Dimension</code> enumeration. Using pattern matching, it is easy to write a function, <code class="literal">convertDimension</code>, that will take <code class="literal">Dimension</code> as a parameter and convert it to the other variant (<code class="literal">US</code> measurements to <code class="literal">Metric</code> and vice versa):</p><pre class="programlisting">func convertDimension(dimension: Dimension) -&gt; Dimension {&#13;
    switch dimension {&#13;
    case let .us(length, width):&#13;
        return .metric(length * 0.304, width * 0.304)&#13;
    case let .metric(length, width):&#13;
        return .us(length * 3.280, width * 3.280)&#13;
    }&#13;
}&#13;
&#13;
let convertedDimension = convertDimension(dimension:&#13;
  Dimension.metric(5.0, 4.0))&#13;
</pre><p>In this function, we check for the dimension type with a <code class="literal">switch</code>
<code class="literal">case</code> code block. We extract the associated values with our <code class="literal">let</code> statement and use <code class="literal">length</code> and <code class="literal">width</code> in our <code class="literal">return</code> statement.</p><p>To test our function, we provide a <code class="literal">metric</code> dimension of <code class="literal">5.0</code> and <code class="literal">4.0</code> so that the resulting <code class="literal">us length</code> will be <code class="literal">16.4</code> and the <code class="literal">us width</code> will be <code class="literal">13.12</code>.</p><p>Swift requires us to handle all of the cases of an enumerated type; if we do not cover all the cases, the Swift compiler will warn us and prevent us from introducing runtime errors. For instance, if we remove the second case, the compiler will warn us, as shown in the following image:</p><p>
</p><div><img alt="Pattern matching" src="img/B05092_04_01_new.jpg"/></div><p>
</p><p>In case we have a lot of cases that we want to handle generically, we can use the default keyword. As an example, let's add a default case to our <code class="literal">convertDimension</code> function:</p><pre class="programlisting">func convertDimension(dimension: Dimension) -&gt; Dimension {&#13;
    switch dimension {&#13;
    case let .us(length, width):&#13;
        return .metric(length * 0.304, width * 0.304)&#13;
    default:&#13;
        return .us(0.0, 0.0)&#13;
    }&#13;
}&#13;
</pre><p>The preceding example serves only as a default usage example and we should avoid a <code class="literal">default</code> case as much as possible.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Patterns and pattern matching</h1></div></div></div><p>In the previous section, we looked at simple pattern matching examples for enumerations. In this section, we will examine patterns and pattern matching in detail.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>The wildcard pattern</h2></div></div></div><p>The wildcard pattern matches and ignores any value. It consists of an underscore, <code class="literal">_</code>. We use a wildcard pattern when we do not care about the values being matched against.</p><p>For instance, the following code example ignores the matched values:</p><pre class="programlisting">for _ in 1...5 {&#13;
    print("The value in range is ignored")&#13;
}&#13;
</pre><p>We use <code class="literal">_</code> to ignore the value in the iteration.</p><p>The wildcard pattern can be used with <code class="literal">optionals</code> as follows:</p><pre class="programlisting">let anOptionalString: String? = nil&#13;
&#13;
switch anOptionalString {&#13;
    case _?: print ("Some")&#13;
    case nil: print ("None")&#13;
}&#13;
</pre><p>As seen from the preceding example, we matched an optional by <code class="literal">_?</code>.</p><p>The wildcard pattern can be used to ignore data that we do not need and values that we do not want to match against. The following code example presents the way in which we use the wildcard pattern to ignore the data:</p><pre class="programlisting">let twoNumbers = (3.14, 1.618)&#13;
&#13;
switch twoNumbers {&#13;
    case (_, let phi): print("pi: \(phi)")&#13;
}&#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>The value-binding pattern</h2></div></div></div><p>A value-binding pattern binds matched values to variable or constant names. The following example presents the value binding pattern by binding <code class="literal">x</code> to <code class="literal">5</code> and <code class="literal">y</code> to <code class="literal">7</code>:</p><pre class="programlisting">let position = (5, 7)&#13;
&#13;
switch position {&#13;
    case let (x, y):&#13;
        print("x:\(x), y:\(y)")&#13;
}&#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>The identifier pattern</h2></div></div></div><p>An identifier pattern matches any value and binds the matched value to a variable or constant name. For instance, in the following example, <code class="literal">ourConstant</code> is an identifier pattern that matches the value of <code class="literal">7</code>:</p><pre class="programlisting">let ourConstant = 7&#13;
&#13;
switch ourConstant {&#13;
    case 7: print("7")&#13;
    default: print("a value")&#13;
}&#13;
</pre><p>The identifier pattern is a subpattern of the value-binding pattern.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>The tuple pattern</h2></div></div></div><p>A tuple pattern is a comma-separated list of zero or more patterns, enclosed in parentheses. Tuple patterns match values of corresponding tuple types.</p><p>We can constrain a tuple pattern to match certain kinds of tuple types using type annotations. For instance, the tuple pattern <code class="literal">(x, y): (Double, Double)</code> in the declaration, <code class="literal">let (x, y): (Double, Double) = (3, 7)</code>, matches only tuple types in which both elements are of the <code class="literal">Double</code> type.</p><p>In the following example, we match the pattern by binding the name, checking whether age has a value, and finally, if the address is of the <code class="literal">String</code> type. We use only the <code class="literal">name</code> that we need and, for <code class="literal">age</code> and <code class="literal">address</code>, we use the wildcard pattern to ignore the values:</p><pre class="programlisting">let name = "John"&#13;
let age: Int? = 27&#13;
let address: String? = "New York, New York, US"&#13;
&#13;
switch (name, age, address) {&#13;
    case (let name, _?, _ as String):&#13;
        print(name)&#13;
    default: ()&#13;
}&#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>The enumeration case pattern</h2></div></div></div><p>An enumeration case pattern matches a <code class="literal">case</code> of an existing enumeration type. Enumeration case patterns appear in a <code class="literal">switch</code> statement's <code class="literal">case</code> labels and case conditions of <code class="literal">if</code>, <code class="literal">while</code>, <code class="literal">guard</code>, and <code class="literal">for-in</code> statements.</p><p>If the enumeration <code class="literal">case</code> that we are trying to match has any associated values, the corresponding enumeration case pattern must specify a tuple pattern that contains one element for each associated value. The following example presents the enumeration case pattern:</p><pre class="programlisting">let dimension = Dimension.metric(9.0, 6.0)&#13;
&#13;
func convertDimensions(dimension: Dimension) -&gt; Dimension {&#13;
    switch dimension {&#13;
    case let .us(length, width):&#13;
        return .metric(length * 0.304, width * 0.304)&#13;
    case let .metric(length, width):&#13;
        return .us(length * 3.280, width * 3.280)&#13;
    }&#13;
}&#13;
&#13;
print(convertDimensions(dimension: dimension))&#13;
</pre><p>In the preceding example, we use tuple pattern for each associated value (<code class="literal">length</code> and <code class="literal">width</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>The optional pattern</h2></div></div></div><p>An optional pattern matches values wrapped in a <code class="literal">Some(Wrapped)</code> case of an <code class="literal">Optional&lt;Wrapped&gt;</code> or <code class="literal">ImplicitlyUnwrappedOptional&lt;Wrapped&gt;</code> enumeration. Optional patterns consist of an identifier pattern followed immediately by a question mark and appear in the same places as enumeration case patterns. The following example presents optional pattern matching:</p><pre class="programlisting">let anOptionalString: String? = nil&#13;
&#13;
switch anOptionalString {&#13;
    case let something?: print("\(something)")&#13;
    case nil: print ("None")&#13;
}&#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Type casting patterns</h2></div></div></div><p>There are two type casting patterns as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">is</code>: This matches the type against the right-hand side of the expression</li><li class="listitem" style="list-style-type: disc"><code class="literal">as</code>: This casts the type to the left-hand side of the expression</li></ul></div><p>The following example presents the <code class="literal">is</code> and <code class="literal">as</code> type casting patterns:</p><pre class="programlisting">let anyValue: Any = 7&#13;
&#13;
switch anyValue {&#13;
    case is Int: print(anyValue + 3)&#13;
    case let ourValue as Int: print(ourValue + 3)&#13;
    default: ()&#13;
}&#13;
</pre><p>The <code class="literal">anyValue</code> variable is type of <code class="literal">Any</code> storing, an <code class="literal">Int</code> value, then the first case is going to be matched but the compiler will complain, as shown in the following image:</p><p>
</p><div><img alt="Type casting patterns" src="img/image_04_002.jpg"/></div><p>
</p><p>We could cast <code class="literal">anyValue</code> to <code class="literal">Int</code> with <code class="literal">as!</code> to resolve the issue.</p><p>The first case is already matched. The second case will not be reached. Suppose that we had a non-matching case as the first case, as shown in the following example:</p><pre class="programlisting">let anyValue: Any = 7 &#13;
 &#13;
switch anyValue { &#13;
     case is Double: print(anyValue) &#13;
     case let ourValue as Int: print(ourValue + 3) &#13;
     default: () &#13;
} &#13;
</pre><p>In this scenario, the second case would be matched and cast <code class="literal">anyValue</code> to <code class="literal">Int</code> and bind it to <code class="literal">ourValue</code>, then we will be able to use <code class="literal">ourValue</code> in our statement.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>The expression pattern</h2></div></div></div><p>An expression pattern represents the value of an expression. Expression patterns appear only in a <code class="literal">switch</code> statement's <code class="literal">case</code> labels. The expression represented by the expression pattern is compared with the value of an input expression using the <code class="literal">~=</code> operator.</p><p>The matching succeeds if the <code class="literal">~=</code> operator returns <code class="literal">true</code>. By default, the <code class="literal">~=</code> operator compares two values of the same type using the <code class="literal">==</code> operator. The following example presents an example of the expression pattern:</p><pre class="programlisting">let position = (3, 5)&#13;
&#13;
switch position {&#13;
    case (0, 0):&#13;
        print("(0, 0) is at the origin.")&#13;
    case (-4...4, -6...6):&#13;
        print("(\(position.0), \(position.1)) is near the origin.")&#13;
    default:&#13;
        print("The position is:(\(position.0), \(position.1)).")&#13;
}&#13;
</pre><p>We can overload the <code class="literal">~=</code> operator to provide custom expression matching behavior.</p><p>For instance, we can rewrite the preceding example to compare the position expression with a <code class="literal">String</code> representation of positions:</p><pre class="programlisting">func ~=(pattern: String, value: Int) -&gt; Bool {&#13;
    return pattern == "\(value)"&#13;
}&#13;
&#13;
switch position {&#13;
    case ("0", "0"):&#13;
        print("(0, 0) is at the origin.")&#13;
    default:&#13;
        print("The position is: (\(position.0), \(position.1)).")&#13;
}&#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Summary</h1></div></div></div><p>This chapter explained the enumeration definition and usage. We covered associated and raw values and an introduction to the concept of algebraic data types. We explored some examples to cover the sum, product, and recursion types. We will use the concept of algebraic data types in 
Chapter 8
, <em>Functional Data Structures</em> when we talk about functional data structures. In this chapter, we explored patterns such as wildcard, value-binding, identifier, tuple, enumeration case, optional, type casting, and expression along with related pattern matching examples.</p><p>The next chapter will cover generics and associated type protocols that are very useful tools in functional programming, generic programming, and protocol-oriented programming.</p></div></body></html>