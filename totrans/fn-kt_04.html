<html><head></head><body>
        

                            
                    <h1 class="header-title">Functions, Function Types, and Side Effects</h1>
                
            
            
                
<p>Functional programming revolves around the concepts of immutability and functions. We learned about immutability in the last chapter; we also got a glimpse of pure functions while discussing immutability. Pure functions are basically one of the many types (but probably the most important one) that functional programming has to offer.</p>
<p>This chapter will revolve around functions. To go into depth on functional programming, you need a strong base in functions. To get your concepts clear, we will start with ordinary Kotlin functions and then gradually move on to discuss abstract concepts on functions that functional programming defines. We will also see their implementation in Kotlin.</p>
<p>In this chapter, we are going to cover the following topics:</p>
<ul>
<li>Functions in Kotlin</li>
<li>Function types</li>
<li>Lambda</li>
<li>High order functions</li>
<li>Understanding side effects and pure functions</li>
</ul>
<p>So, let's get started by defining functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions in Kotlin</h1>
                
            
            
                
<p>Functions are one of the most important parts of programming. We write tons of functions every week for our projects. Functions are also a part of the fundamentals of programming. To learn functional programming, we must have our concepts clear with regard to functions. In this section, we will cover the basics of functions, in order to get you brushed up and ready for the next sections in this chapter, where we will be discussing abstract functional concepts and their implementation in Kotlin.</p>
<p>So, let's start by defining functions.</p>
<p>A <strong>function</strong> is a block of organized, reusable code that is used to perform a single, related action.</p>
<p>Not very clear? We will explain, but first, let's learn why we should write functions. In short, what is the functionality of a function? Have a look:</p>
<ul>
<li>Functions allow us to break the program into a bunch of steps and substeps</li>
<li>Functions encourages code reuse</li>
<li>Functions, if used properly, help us keep the code clean, organized, and easy to understand</li>
<li>Functions make testing (unit testing) easy, testing each small part of the program is easier than the complete program in a single go</li>
</ul>
<p>In Kotlin, a function generally looks like the following:</p>
<pre>fun appropriateFunctionName(parameter1:DataType1, parameter2:DataType2,...): ReturnType { 
    //do your stuff here 
    return returnTypeObject 
} </pre>
<p>In Kotlin, a function declaration starts with the <kbd>fun</kbd> keyword, followed by the function name, then braces. Inside the braces, we can specify function arguments (optional). After the braces, there would be a colon (<kbd>:</kbd>) and return type, which specifies the datatype of the value/object to be returned (you can skip return type if you don't plan to return anything from the function; in that case, the default return type <kbd>Unit</kbd> will be assigned to the function). After those, there would be the function body, covered in curly braces (curly braces are also optional for Single-Expression functions, covered next in<a href="f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml" target="_blank"> Chapter 5</a>, <em>More on Functions</em>).</p>
<div><kbd>Unit</kbd> is a datatype in Kotlin. <kbd>Unit</kbd> is a singleton instance of itself and holds a value that is <kbd>Unit</kbd> itself. <kbd>Unit</kbd> corresponds to <kbd>void</kbd> in Java, but it's quite different than <kbd>void</kbd>. While <kbd>void</kbd> means nothing in Java and <kbd>void</kbd> cannot contain anything, we have <kbd>Nothing</kbd> in Kotlin for that purpose, which indicates that a function would never complete successfully (due to an exception or an infinite loop).</div>
<p>Now, what are those return types, parameters (arguments), and function bodies? Let's explore them.</p>
<p>The following is a more realistic function example than the abstract one previously shown:</p>
<pre>fun add(a:int, b:Int):Int { 
   val result = a+b 
   return result 
} </pre>
<p>Now, have a look at the following explanations for each parts of a function:</p>
<ul>
<li><strong>Function arguments/parameters</strong>: These are the data (unless lambda) for the function to work on. In our example, <kbd>a</kbd> and <kbd>b</kbd> are the function parameters.</li>
<li><strong>Function body</strong>: Everything we write inside the curly braces of a function is called the <strong>function body</strong>. It is the part of a function, where we write the logic or set of instructions to accomplish a particular task. In the preceding example, two lines inside the curly braces is the function body.</li>
<li><strong>Return statement, datatype</strong>: If we are willing to return some value from the function, we have to declare the datatype of the value we are willing to return; that datatype is called the <kbd>return</kbd> type—in this case, <kbd>Int</kbd> is the <kbd>return</kbd> type and <kbd>return result</kbd> is the return statement, it enables you to return a value to the calling function.</li>
</ul>
<p>We can make the previous example shorter by removing <kbd>val result = a+b</kbd> and replacing the return statement with <kbd>return a+b</kbd>. In Kotlin, we can further shorten this example, as we will see in <a href="f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml" target="_blank">Chapter 5</a>, <em>More on Functions</em>.</p>
<p>While writing functions is easy, Kotlin makes it easier for you.</p>
<p>Kotlin has bundled various features with functions that make a developer's life easier. The following is a brief list of the features bundled with Kotlin:</p>
<ul>
<li>Single-expression functions</li>
<li>Extension functions</li>
<li>Inline functions</li>
<li>Infix notation and more</li>
</ul>
<p>We will cover them in detail in the <em>Lambda, Generics, Recursions, Corecursion</em> section of <a href="f02ee496-7175-40de-be3f-b96eb746f0a4.xhtml" target="_blank">Chapter 5</a>, <em>More on Functions</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning two values from a function</h1>
                
            
            
                
<p>While, generally, a function can return only a single value, in Kotlin, by leveraging the benefits of the <kbd>Pair</kbd> type and destructuring declarations, we can return two variables from a function. Consider the following example:</p>
<pre>fun getUser():Pair&lt;Int,String&gt; {//(1) 
    return Pair(1,"Rivu") 
} 
fun main(args: Array&lt;String&gt;) { 
    val (userID,userName) = getUser()//(2) 
     println("User ID: $userID t User Name: $userName") 
} </pre>
<p>In the preceding program, on comment <kbd>(1)</kbd>, we created a function that would return a <kbd>Pair&lt;Int,String&gt;</kbd> value.</p>
<p>On comment <kbd>(2)</kbd>, we used that function in a way that seems like it returns two variables. Actually, destructuring declarations allows you to destructure a <kbd>data class</kbd>/<kbd>Pair</kbd> and get its underlying values in standalone variables. When this feature is used with functions, it seems like the function is returning multiple values, though it returns only one value that is a <kbd>Pair</kbd> value or another <kbd>data class</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extension functions</h1>
                
            
            
                
<p>Kotlin provides us with extension functions. What are they? They are like an ad hoc function on top of an existing datatype/class.</p>
<p>For example, if we want to count the number of words in a string, the following would be a traditional function to do it:</p>
<pre>fun countWords(text:String):Int { 
    return text.trim() 
            .split(Pattern.compile("\s+")) 
            .size 
} </pre>
<p>We would pass a <kbd>String</kbd> to a function, have our logic count the words, and then we would return the value.</p>
<p>But don't you feel like it would always be better if there was a way that this function could be called on the <kbd>String</kbd> instance itself? Kotlin allows us to perform such an action.</p>
<p>Have a look at the following program:</p>
<pre>fun String.countWords():Int { 
    return trim() 
            .split(Pattern.compile("\s+")) 
            .size 
} </pre>
<p>Have a careful look at the function declaration. We declared the function as <kbd>String.countWords()</kbd>, not just <kbd>countWords</kbd> as it was previously; that means it should be called on a <kbd>String</kbd> instance now, just like the member functions of <kbd>String</kbd> class. Just like the following code:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val counts = "This is an example StringnWith multiple words".countWords() 
    println("Count Words: $counts") 
} </pre>
<p>You can check out the following output:</p>
<div><img height="79" width="381" src="img/f9e6f9a3-0d06-4c1e-8b44-51ac459c9c36.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Default arguments</h1>
                
            
            
                
<p>We may have a requirement where we want to have an optional parameter for a function. Consider the following example:</p>
<pre>fun Int.isGreaterThan(anotherNumber:Int):Boolean { 
    return this&gt;anotherNumber 
} </pre>
<p>We want to make <kbd>anotherNumber</kbd> parameter optional; we want it to be <kbd>0</kbd>, if it is not passed as an argument. The traditional way is to have another overloaded function without any parameters, which would call this function with <kbd>0</kbd>, like the following:</p>
<pre>fun Int.isGreaterThan(anotherNumber:Int):Boolean { 
    return this&gt;anotherNumber 
} 
fun Int.isGreaterThan():Boolean { 
    return this.isGreaterThan(0) 
} </pre>
<p>However, in Kotlin, things are quite easy and straightforward and they don't require us to define the function again just to make an argument optional. For making arguments optional, Kotlin provides us with default arguments, by which we can specify a default value of a function right away at the time of declaration.</p>
<p>The following is the modified function:</p>
<pre>fun Int.isGreaterThan(anotherNumber:Int=0):Boolean { 
    return this&gt;anotherNumber 
} </pre>
<p>We would use the <kbd>main</kbd> function as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    println("5&gt;0: ${5.isGreaterThan()}") 
    println("5&gt;6: ${5.isGreaterThan(6)}") 
} </pre>
<p>For the first one, we skipped the argument and for the second one, we provided <kbd>6</kbd>. So, for the first one, the output should be true (as <kbd>5</kbd> is really greater than <kbd>0</kbd>), while for the second one, it should be false (as <kbd>5</kbd> isn't greater than <kbd>6</kbd>).</p>
<p>The following screenshot output confirms the same:</p>
<div><img height="100" width="375" src="img/ae55b51d-74ec-41b4-963e-629fa7f51823.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Nested functions</h1>
                
            
            
                
<p>Kotlin allows you to nest functions, one within another. We can declare and use a function within another function.</p>
<p>When you declare a function within another function, the nested functions, visibility will stay exclusively within the parent function and cannot be accessed from outside.</p>
<p>So, let's have an example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    fun nested():String { 
        return "String from nested function" 
    } 
    println("Nested Output: ${nested()}") 
} </pre>
<p>In the preceding program, we declared and used a function—<kbd>nested()</kbd>—inside the <kbd>main</kbd> function.</p>
<p>The following is the output, if you're curious:</p>
<div><img height="76" width="353" src="img/e86a63ad-5bd7-4a67-88f2-9fc3e1427bdb.png"/></div>
<p>So, as we've got our basics brushed up in functions, let's move forward in functional programming. In the following section, we will learn about function types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function types in functional programming</h1>
                
            
            
                
<p>One of the main objectives of functional programming is to implement modular programming. Side effects (a functional term, defined later in this chapter) are often sources of bugs; functional programming wants you to avoid side effects totally.</p>
<p>To achieve that, functional programming has defined the following types of functions:</p>
<ul>
<li>Lambda functions as property</li>
<li>High order functions</li>
<li>Pure functions</li>
<li>Partial functions</li>
</ul>
<p>In this section, we will discuss each of these concepts in order to get a solid grip on functional programming paradigms.</p>
<p>So, let's get started with lambda.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lambda</h1>
                
            
            
                
<p>Lambda, which can also be called <strong>anonymous functions</strong>, has a first-class citizen support in Kotlin. While, in Java, lambda is only supported starting with Java 8, in Kotlin, you can use Kotlin with JVM 6 onwards, so there's really no barrier for lambda in Kotlin.</p>
<p>Now, we were talking about lambda, anonymous classes (or objects) and anonymous functions, but what are they? Let us explore.</p>
<p>To be generic, lambda or lambda expressions generally means <strong>anonymous functions</strong>, that is, functions without names, which can be assigned to variables, passed as arguments, or returned from another function. It is a kind of nested function, but is more versatile and more flexible. You can also say all the lambda expressions are functions, but not every function is a lambda expression. Being anonymous and unnamed brings a lot of benefits to lambda expressions, which we will discuss soon.</p>
<p>As I mentioned earlier, not all languages support lambda and Kotlin is one of rarest languages, and it provides extensive support for lambda.</p>
<p>So, why is it called lambda? Let us dig up a bit of history now.</p>
<p>Lambda, Λ, <strong>λ</strong> (uppercase Λ, lowercase λ) is the 11<sup>th</sup> letter of the Greek alphabet. Pronunciation: lám(b)da.<br/>
Source: <a href="https://en.wikipedia.org/wiki/Lambda">https://en.wikipedia.org/wiki/Lambda</a></p>
<p>During the 1930s, Alonzo Church, who was at that time studying mathematics at Princeton University, used the Greek alphabet, specifically lambda, to denote what he called <strong>functions</strong>. The thing to note is that, at that time, there were only anonymous functions in computing; the concept of modern-day named functions were yet to come.</p>
<p>So, with this practice of Alonzo Church, the word lambda got attached to anonymous functions (then the only type of function) which is, to date, referred to in the same way.</p>
<p>Alonzo Church (June 14, 1903-August 11, 1995), was an American mathematician and logician who made major contributions to mathematical logic and the foundations of theoretical computer science. He is best known for the lambda calculus, <em>Church-Turing</em> thesis, proving the undecidability of the <em>Entscheidungsproblem</em>, <em>Frege-Church</em> ontology, and the <em>Church-Rosser</em> theorem. He also worked on philosophy of language (for example, Church, 1970).<br/>
Source: <a href="https://en.wikipedia.org/wiki/Alonzo_Church">https://en.wikipedia.org/wiki/Alonzo_Church</a></p>
<p>Don't you think we have had enough of theories? Shouldn't we now focus on learning what lambda actually is, or what, exactly, it looks like? We will have a look at how lambdas look in Kotlin, but we would prefer to introduce you to lambda in Java first, and later in Kotlin, to make you fully understand how much power lambdas possess in Kotlin and what exactly is meant by first-class citizen support. You'll also learn the difference between lambda in Java and Kotlin.</p>
<p>Consider the following Java example. It's a simple example, where we are passing an instance of an interface to a method and, in that method, we are calling a method from the instance:</p>
<pre>public class LambdaIntroClass { 
    interface SomeInterface { 
        void doSomeStuff(); 
    } 
    private static void invokeSomeStuff(SomeInterface someInterface) { 
        someInterface.doSomeStuff(); 
    } 
    public static void main(String[] args) { 
        invokeSomeStuff(new SomeInterface() { 
            @Override 
            public void doSomeStuff() { 
                System.out.println("doSomeStuff invoked"); 
            } 
        }); 
    } 
} </pre>
<p>So, in this program, <kbd>SomeInterface</kbd> is an interface (the inner interface of <kbd>LambdaIntroClass</kbd>) with a single method—<kbd>doSomeStuff()</kbd>. The static method (it's static to make it easily accessible by the <kbd>main</kbd> method) <kbd>invokeSomeStuff</kbd> takes an instance of <kbd>SomeInterface</kbd> and calls its method <kbd>doSomeStuff()</kbd>.</p>
<p>It was a simple example; now, let's make it simpler: let's add lambda to it. Have a look at the following updated code:</p>
<pre>public class LambdaIntroClass { 
    interface SomeInterface { 
        void doSomeStuff(); 
    } 
    private static void invokeSomeStuff(SomeInterface someInterface) { 
        someInterface.doSomeStuff(); 
    }   
    public static void main(String[] args) { 
        invokeSomeStuff(()-&gt;{ 
                System.out.println("doSomeStuff called"); 
        }); 
    } 
} </pre>
<p>So, here, the definition of <kbd>SomeInterface</kbd> and <kbd>invokeSomeStuff()</kbd> stays the same. The only difference is on passing the instance of <kbd>SomeInterface</kbd>. Instead of creating an instance of <kbd>SomeInstance</kbd> with a new <kbd>SomeInstance</kbd>, what we wrote is an expression (in bold) that looks pretty much like mathematical function expressions (except obviously the <kbd>System.out.println()</kbd>). That expression is called a <strong>lambda expression</strong>.</p>
<p>Wasn't that fantastic? You didn't need to create an instance of the interface, then override the method and all that stuff. What you did is a simple expression. That expression would be used as the method body of the <kbd>doSomeStuff()</kbd> method inside the interface.</p>
<p>The output for both the programs is identical; it is as shown in the following screenshot:</p>
<div><img height="80" width="376" src="img/8b2507fe-ff5a-4106-8227-846e71d7eb23.png"/></div>
<p>Java doesn't have any types for lambda; you can only use lambda to create instances of classes and interfaces on the go. The only benefit of lambda in Java is that it makes Java programs easier to read (by humans) and reduces line counts.</p>
<p>We cannot actually blame Java for that. After all, Java is basically a purely object-oriented language. Kotlin, on the other hand, is a perfect blend of object-oriented and functional programming paradigms; it brings both the worlds closer together. In our words, Kotlin is the best language if you want to get started with functional programming with previous knowledge of object-oriented programming.</p>
<p>So, no more lectures, let us move on to the code. Let us now have a look how the same program would look in Kotlin:</p>
<pre>fun invokeSomeStuff(doSomeStuff:()-&gt;Unit) { 
    doSomeStuff() 
} 
fun main(args: Array&lt;String&gt;) { 
    invokeSomeStuff({ 
        println("doSomeStuff called"); 
    }) 
} </pre>
<p>Yes, that's the complete program (well, except the <kbd>import</kbd> statements and package name). I know you're a bit confused; you're asking if it is really the same program? Where is the interface definition then? Well, in Kotlin that is not actually required.</p>
<p>The <kbd>invokeSomeStuff()</kbd> function is actually a high-order function (covered next); we pass our lambda there and it directly calls the function.</p>
<p>Brilliant, isn't it? Kotlin has a bunch of features with lambda. Let us have a look at them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function as property</h1>
                
            
            
                
<p>Kotlin also allows us to have functions as properties. Functions as properties means that a function can be used as a property.</p>
<p>For instance, take the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val sum = { x: Int, y: Int -&gt; x + y }  
    println("Sum ${sum(10,13)}") 
    println("Sum ${sum(50,68)}") 
} </pre>
<p>In the preceding program, we created a property, <kbd>sum</kbd>, which will actually hold a function to add two numbers passed to it.</p>
<p>While <kbd>sum</kbd> is a <kbd>val</kbd> property, what it holds is a function (or lambda) and we can call that function just like the usual function we call; there are no differences there at all.</p>
<p>If you're curious, the following is the output:</p>
<div><img height="95" width="363" src="img/19f84162-6dd6-4c54-9bb2-87a1876a3a39.png"/></div>
<p>Now, let us discuss the syntax of lambda.</p>
<p>In Kotlin, a lambda always stays embraced by the curly braces. This makes a lambda easy to identify, unlike in Java, where parameters/arguments reside outside the curly braces. In Kotlin, parameters/arguments reside inside curly braces separated by (<kbd>-&gt;</kbd>) from the logic of the function. The last statement in a lambda (which may just be a variable/property name or another function call) is considered as the return statement. So, whatever is the evaluation of the last statement of a lambda is the return value of a lambda.</p>
<p>Also, if your function is a single parameter function, you can also skip the property name. So, how can you use that parameter if you don't specify the name? Kotlin provides you with a default <kbd>it</kbd> property for single parameter lambdas where you don't specify the property name.</p>
<p>So, let's modify the previous lambda to add it. Have a look at the following code:</p>
<pre>reverse = { 
        var n = it 
        var revNumber = 0 
        while (n&gt;0) { 
            val digit = n%10 
            revNumber=revNumber*10+digit 
            n/=10 
        } 
        revNumber 
} </pre>
<p>We skipped the complete program and output, as they remain the same.</p>
<p>You must have noticed that we assigned the function parameters value to another <kbd>var</kbd> property (both when the parameter was named and when we denoted with <kbd>it</kbd>). The reason is that, in Kotlin, function parameters are immutable, but with the reverse number program, we needed a way to change the value; so, we assigned the value to a <kbd>var</kbd> property, which is mutable.</p>
<p>Now, you have lambda as properties, but what about their datatypes? Every property/variable has a datatype (even if the type is inferred), so what about lambdas? Let's have a look at the following example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val reverse:(Int)-&gt;Int//(1) 
    reverse = {number -&gt; 
        var n = number 
        var revNumber = 0 
        while (n&gt;0) { 
            val digit = n%10 
            revNumber=revNumber*10+digit 
            n/=10 
        } 
        revNumber 
    }// (2) 
    println("reverse 123 ${reverse(123)}") 
    println("reverse 456 ${reverse(456)}") 
    println("reverse 789 ${reverse(789)}") 
} </pre>
<p>In the preceding program, we declared a <kbd>reverse</kbd> property as a function. In Kotlin, when you're declaring a property as a function, you should mention the datatypes of parameters/arguments inside braces, followed by an arrow and then the return type of the function; if the function is not planned to return something, you should mention <kbd>Unit</kbd>. While declaring a function as a property, you need not specify the parameter/argument name and while defining/assigning the function to the property, you can skip providing datatypes of the property.</p>
<p>The following is the output:</p>
<div><img height="128" width="386" src="img/643690f0-41fa-4752-88a9-e5b67d54c8a6.png"/></div>
<p>So, we have a good concept of lambda and functions as properties in Kotlin. Now, let us move ahead with high order functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">High order functions</h1>
                
            
            
                
<p>A high order function is a function which accepts another function as a parameter or returns another function. We just saw how we can use a function as a property, so it's quite easy to see that we can accept another function as a parameter or that we can return another function from a function. As stated previously, technically the function that receives or returns another function (it may be more than one) or does both is called a <strong>high-order</strong> <strong>function</strong>.</p>
<p>In our first lambda example in Kotlin, the <kbd>invokeSomeStuff</kbd> function was a high-order function.</p>
<p>The following is another example of high-order function:</p>
<pre>fun performOperationOnEven(number:Int,operation:(Int)-&gt;Int):Int { 
    if(number%2==0) { 
        return operation(number) 
    } else { 
        return number 
    } 
} 
fun main(args: Array&lt;String&gt;) { 
    println("Called with 4,(it*2): ${performOperationOnEven(4, 
            {it*2})}") 
    println("Called with 5,(it*2): ${performOperationOnEven(5, 
            {it*2})}") 
} </pre>
<p>In the preceding program, we created a high order function—<kbd>performOperationOnEven</kbd> which would take an <kbd>Int</kbd> and a lambda operation to execute on that <kbd>Int</kbd>. The only catch is that the function would only perform that operation on the provided <kbd>Int</kbd>, if that <kbd>Int</kbd> is an even number.</p>
<p>Isn't that easy enough? Let's have a look at the following output:</p>
<div><img height="98" width="368" src="img/18a5c28e-0a67-4090-a06f-645f1a80e160.png"/></div>
<p>In all our previous examples, we saw how to pass a function (lambda) to another function. However, that's not the only feature of high order functions. A high order function also allows you to return a function from it.</p>
<p>So, let us explore it. Have a look at the following example:</p>
<pre>fun getAnotherFunction(n:Int):(String)-&gt;Unit { 
    return { 
        println("n:$n it:$it") 
    } 
} 
fun main(args: Array&lt;String&gt;) { 
    getAnotherFunction(0)("abc") 
    getAnotherFunction(2)("def") 
    getAnotherFunction(3)("ghi") 
} </pre>
<p>In the preceding program, we created a function, <kbd>getAnotherFunction</kbd>, that would take an <kbd>Int</kbd> parameter and would return a function that takes a <kbd>String</kbd> value and returns <kbd>Unit</kbd>. That <kbd>return</kbd> function prints both its parameter (a <kbd>String</kbd>) and its parents parameter (an <kbd>Int</kbd>).</p>
<p>See the following output:</p>
<div><img height="130" width="412" src="img/59428ba1-f83a-4a58-b5d3-6d2c79225672.png"/></div>
<p>In Kotlin, technically you can have nested high order functions to any depth. However, that would do more harm than help, and would even destroy the readability. So, you should avoid them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pure functions and side effects</h1>
                
            
            
                
<p>So, we have learned about lambda and high order functions. They are two of the most interesting and important topics of functional programming. In this section, we will be discussing side effects and pure functions.</p>
<p>So, let's start by defining side effects. We will then gradually move towards pure functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Side effects</h1>
                
            
            
                
<p>In a computer program, when a function modifies any object/data outside its own scope, that is called a <strong>side effect</strong>. For instance, we often write functions that modify a global or static property, modify one of its arguments, raise an exception, write data to display or file, or even call another function which has a side effect.</p>
<p>For example, have a look at the following program:</p>
<pre>class Calc { 
    var a:Int=0 
    var b:Int=0 
    fun addNumbers(a:Int = this.a,b:Int = this.b):Int {  
        this.a = a 
        this.b = b 
        return a+b 
    } 
} 
fun main(args: Array&lt;String&gt;) { 
    val calc = Calc() 
    println("Result is ${calc.addNumbers(10,15)}") 
} </pre>
<p>The preceding program is a simple object-oriented program. However, it contains side effects. The <kbd>addNumbers()</kbd> function modifies the state of the <kbd>Calc</kbd> class, which is bad practice in functional programming.</p>
<p>While we cannot avoid side effects in a few functions, especially where we are accessing IO and/or a database and so on, side effects should be avoided wherever possible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pure functions</h1>
                
            
            
                
<p>The definition of a pure function says that, if the return value of a function is completely dependent on its arguments/parameters, then this function may be referred to as a <strong>pure function</strong>. So, if we declare a function as <kbd>fun func1(x:Int):Int</kbd>, then its return value will be strictly dependent on its argument, <kbd>x</kbd>; say, if you call <kbd>func1</kbd> with a value of <em>3 N</em> times, then, for every call, its return value will be the same.</p>
<p>The definition also says that a pure function should not actively or passively cause side effects, that is, it should not directly cause side effects, nor should it call any other function that causes side effects.</p>
<p>A pure function can be either a lambda or a named function.</p>
<p>So, why are they called pure functions? The reason is quite simple. Programming functions originated from mathematical functions. Programming functions, over time, evolved to contain multiple tasks and perform anonymous actions that are not directly related to the processing of passed arguments. So, those functions that still resemble mathematical functions are called pure functions.</p>
<p>So, let's modify our previous program to make it into a pure function:</p>
<pre>fun addNumbers(a:Int = 0,b:Int = 0):Int { 
    return a+b 
} 
 
fun main(args: Array&lt;String&gt;) { 
    println() 
} </pre>
<p>Quite easy, isn't it? We are skipping the output, as the program is really easy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned about functions, how to use them, and their classifications. We also got introduced to lambda and high order functions. We learned about pure functions and side effects.</p>
<p>The next chapter will take you deeper into functions. As I already stated, you need to master functions in order to learn functional programming properly. So, what are you waiting for? Turn the page right now.</p>


            

            
        
    </body></html>