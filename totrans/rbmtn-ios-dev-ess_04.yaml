- en: Chapter 4. Mastering MVC Paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Model-View-Controller is not an inescapable law of purity, but a pragmatic
    principle of effectiveness."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*—Anonymous*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn about Model-View-Controller, popularly abbreviated
    as MVC, which is a design principle based on the ideas of code reusability and
    **separation of concerns** (**SoC**). This architecture imposes serious constraints
    on the structure of an application, however, surprisingly these restrictions make
    it considerably easier to design and maintain the application. In this chapter
    we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Model-View-Controller paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RubyMotion application using MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to an external API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the application with search and images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The do-it-yourself exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-View-Controller (MVC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model-View-Controller** (**MVC**) is a design principle that separates the
    representation of information from the user''s interaction. The main purpose of
    MVC is to make the code more modular and reusable, which increases the product
    quality.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the popular commercial and noncommercial application frameworks are
    created to enforce the MVC design pattern. However, RubyMotion does not force
    you to use MVC style, but this way of programming is central to a good design
    for application development. If we make use of MVC while developing our application,
    it will be beneficial for us later on, as we will be able to add new features
    more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple's Cocoa framework is also based on Model-View-Controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name implies, the application is divided into three distinct parts:
    model, view, and controller, where model encapsulates application data, view displays
    and allows editing the data, and controller is the place where logic of the interaction
    between the two (model and view) resides. Let''s understand each of them individually.'
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model contains the application data and business rules. The model could
    just be the actual data store, either in-memory (maybe as an `NSArray` or `NSDictionary`
    class) or to-and-from disk. In a more complex app, you may choose to use a SQLite
    database or Core Data, and your model would be a simple instance or one piece
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A view is that part of an application that outputs information from the model
    via the controller. The logic should never be written in the view; the sole purpose
    of the view is only to present information. In iOS, and also in RubyMotion, most
    views are subclasses of the `UIView` class that provide the capability for handling
    touch events and drawings. The `UIKit` framework contains classes to draw typical
    interface elements such as tables (lists), buttons, text fields, and sliders.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A controller is a link between the model and view. A controller acts as an intermediary
    between one or more application views, and one or more of its models. In iOS,
    the controller is generally a subclass of `UIViewController` that also manages
    a view; this class is also responsible for responding to delegation messages and
    target-action messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Model-View-Controller layers are very closely coupled, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controller](img/5220OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **View** and **Controller** layers interact through **User Action** and
    **Update** as shown in the diagram. Whenever the **View** layer creates or modifies
    data, it is communicated to **Controller** through **User Action**. Similarly,
    whenever **Model** updates any change it will first **Notify** the **Controller**
    and will then be reflected on the **View** by an **Update** .
  prefs: []
  type: TYPE_NORMAL
- en: The restaurant application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now to better understand MVC we will create a `restro` application. This application
    will search restaurants in a city. Does the world need another restaurant application?
    No, but that won't stop us from writing one. On a serious note, it will help us
    to explore many features of RubyMotion and will also help us learn and master
    MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand what we are going to do in this application. A restaurant application
    will list out the eat outs, which we can search based on the city. The list of
    places will have a thumbnail image along with information related to the restaurant.
  prefs: []
  type: TYPE_NORMAL
- en: It's good practice to imagine views of your application in the form of a mockup.
    The best way to do this is by using a white board with illustrations that you
    envision for your application.
  prefs: []
  type: TYPE_NORMAL
- en: '![The restaurant application](img/5220OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You must be wondering where all this data will come from. Do I need to hardcode
    it right into my application? That does not make sense! To begin with, we will
    hardcode the values; but later on, as we proceed and evolve, we will learn how
    to use an external API to fetch information, which is something often done in
    real-world applications. We have created a backend API exclusively for this book,
    having all the data available for practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a `restro` project with RubyMotion, using the magical `motion`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in earlier chapters, the `motion` command will create the basic
    structure for a RubyMotion project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feel free to choose your IDE. If you are using RubyMine, you can also create
    and run the application from the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our `restro` application, let''s brainstorm what entities and attributes
    will be required. The first thing that comes to mind is a restaurant entity having
    the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This will contain the name of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thumb_url_image`: This will contain the image URL for the restaurant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`food_type`: This will contain the type of food the restaurant serves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`desc`: This will contain a small description about the restaurant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looks good! Let's create a model, `Restaurant`, that will store all the information
    related to restaurants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a ruby (`.rb`) file, which will be our model inside the `app` folder,
    and name it `restaurant.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have created a class called `Restaurant`. Generally we need to first create
    getter and setter methods for the variables. However, in Ruby we don't need to
    separately create getters and setters, instead we use a single method called `attr_accessor`
    to do that; this idea of syntactic sugar is commonly used in various trivial jobs
    in Ruby, which indeed saves a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Syntactic sugar** is a syntax within a programming language that is designed
    to make things easier to read or express. An example of syntactic sugar is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After setting up `attr_accessor`, in order to assign values while creating an
    object of the `Restaurant` class, we have created an `initialize` method. This
    gives us a chance to write code that sets up our object's state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we create an object of the `Restaurant` class, it will call the `name`
    method, and initialize and execute it. We have to pass a hash of restaurants while
    creating the object. To test the model, let''s fire up our terminal in the `application`
    directory and run `rake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Great! Our `Restaurant` class is created and we can now create objects of this
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing more code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of iOS applications use table structure to represent their information.
    This method of design is best for information-based applications, like the one
    we have in our example. So let's create a table view for our landing page, which
    will populate a list of restaurants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now update the `app_delegate.rb` file inside the `app` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UIWindow` class defines an object known as `window`, which manages and
    coordinates different views of your application, and displays them on the device
    screen. A `UIScreen` object contains the bounding rectangle of the device''s entire
    screen. So `UIScreen.mainScreen.applicationFrame` returns the rectangle size according
    to the screen size and orientation of the device. Also we need to tell the `UIWindow`
    object which controller to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have assigned the `RestroController` class as the root controller for our
    application in `AppDelegate`. So let''s create `restro_controller.rb` in the `app`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s fire up our terminal again and see what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Writing more code](img/5220OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot shows a table structure with a list of restaurants.
    Now that''s some impressive work. Let''s now understand what we did in the previous
    section. Our code has three parts—model, view, and controller. We have already
    explained about the restaurant model. We first created an object for the model
    and assigned some value to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have created two objects and passed a hash to them, as we have explained
    in the previous section. The remaining code has two parts, a controller and a
    view; let's understand them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Restaurant controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, the `Restaurant` controller inherits from `UITableViewController`,
    which is a subclass of `UIViewController`. The `UIViewController` class provides
    the fundamental view-management model for your apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We rarely instantiate the `UIViewController` objects directly. Instead, it
    is generally instantiated via a class that is a subclass of the `UIViewController`
    class, as we did in the previous example. It manages a set of views that make
    up a portion of your app''s user interface. The most important thing in an iOS
    controller is its lifecycle. There are various actions that are called at different
    phases of the application. The lifecycle includes actions such as `Initialize`,
    `ViewDidLoad`, `ViewWillAppear`, `ViewDidAppear`, `ViewWillDisappear`, `ViewDidDisappear`,
    `ViewDidUnload`, and `Dispose`. So these events are called automatically and dynamically.
    Whenever we create an object of the controller it calls `Initialize`, before loading
    the view for the controller, `ViewDidLoad` will be called. The complete lifecycle
    of a controller can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restaurant controller](img/5220OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`viewDidUnload` and `viewWillUnload` are deprecated in iOS 6.0.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see in our restro controller that we have written a lot of logic in
    `ViewDidLoad`, so all the code written in this block will execute before the loading
    of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that these methods are attached to `UIViewController`
    and not to `UIViews`.
  prefs: []
  type: TYPE_NORMAL
- en: Restaurant view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UITableView` class is used to create one of the most common types of views
    used in iOS applications, that is, the table view. We can see only one column
    in our application. This is because the `UITableView` instance is limited to a
    single column as it is designed for a device with a small screen. `UITableView`
    is a subclass of `UIScrollView`, which allows users to scroll through the table,
    although `UITableView` allows vertical scrolling only.
  prefs: []
  type: TYPE_NORMAL
- en: Table views can have one of two styles, `UITableViewStylePlain` (for example,
    iOS contacts) or `UITableViewStyleGrouped` (for example, iOS settings). When you
    create a `UITableView` instance, you must specify the table style; this style
    cannot be changed. For our application, since we do not require to group the restaurants
    we will use `UITableViewStylePlain`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A view is bound to return `CGRect` with an empty origin point. The `CGRect`
    class is very commonly used in iOS apps. Its data structure represents the location
    and dimensions of a rectangle, which is used to set the size of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UITableView` class provides a lot of options, but it needs to know what
    data we are trying to show and what to do when the user interacts with that data.
    This is where the `datasource` and `delegate` properties come in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to return the number of rows to be created using `numberOfRowsInSection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `tableView:numberOfRowsInSection` property tells the `UITableview` datasource
    to return the number of rows in a given section of a table view. So in our example,
    the number of rows will be equal to the total restaurant count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, let''s understand `UITableViewCell`, which is the subclass
    of `UIView`; using this class our rows are displayed in table form. To access
    the contents of the cell, we have properties, such as `textLabel` and `imageView`,
    to use them for setting their attributes such as text color, font, image, and
    highlighted image. You can also easily give a custom look to tables by using different
    iOS methods. Another property `cellForRowAtIndexPath` either creates a new cell
    or recycles an offscreen one and populates it with the data corresponding to `indexPath`,
    and returns the cell. The following code snippet shows how a more complete implementation
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UITableView` class only displays enough data to fill the iPhone screen—it
    does not really matter how much data you might have in total. The `UITableView`
    class does this by reusing cells that scrolled off the screen. When cells scroll
    off the screen (either the top or the bottom) the table view will queue up cells
    that are no longer needed. When it asks the datasource for the cell of a particular
    row, you can check that queue of cells to see if there are any available for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restaurant view](img/5220OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The whole point of `dequeueReusableCell` is that the process of creating a new
    view hierarchy for `UITableViewCell` is rather expensive. If you recreated the
    cell each time you needed it, the scrolling behavior wouldn't be as nice as it
    is.
  prefs: []
  type: TYPE_NORMAL
- en: With `dequeueReusableCellWithIdentifier` for `tableView`, you can greatly speed
    things up. Instead of instantiating a lot of cells, you can just instantiate the
    ones that are needed, which means only those cells that are visible (this is handled
    automatically). When scrolling to an area in the list for which the cells are
    not yet visually represented, instead of instantiating new ones, you can reuse
    the already existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have assigned a display value for each row in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Ruby, *a ||= b* means if *a* is nil/false, assign it the value of *b*.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to an external API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now we have hardcoded the object values, which usually never happens in
    a real-world application; let's get these values from an external API. For practicing
    purposes we have created an external API to get the data in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: If you visit [http://restro.nalwaya.com/restaurants/search.json?city=Chicago](http://
    http://restro.nalwaya.com/restaurants/search.json?city=Chicago) or use the `curl`
    command instead, it will return the restaurants we have seeded for Chicago in
    JSON format (note that this is fictitious data, you might not actually find them
    in Chicago city).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the following `curl` command to get the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`curl` is a command-line tool for transferring data using various protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we will show the list of restaurants in Chicago city, which we are getting
    from our source in our `restro` application. Since we are getting data in JSON
    format, we need to convert this JSON object to a Ruby object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file by the name `json_parser.rb` in the `app` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `NSJSONSerialization` class converts JSON to Foundation objects and converts
    Foundation objects to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RubyMotion has the `Pointer` class in order to create and manipulate pointers.
    The type of pointer to create must be provided in the new constructor. So `Pointer.new(:object)`
    will create a new pointer with the object class.
  prefs: []
  type: TYPE_NORMAL
- en: We need to fetch the JSON object by sending a request to the server; for that
    we will create a `DataParser` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file by the name `data_parser.rb` in the `app` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will fetch data using the `NSUrl` class that will pass this data to `NSData`.
    `NSData` and its mutable subclass `NSMutableData` provides the data objects with
    an object-oriented wrapping for byte buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's refactor the logic in `restro_controller.rb`, which will fetch data
    from the API instead of the hardcoded `Restaurant` object we had created in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `viewDidLoad` section of `restro_controller.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of an error, let''s face it gracefully by displaying the error message
    using a pop-up. So let''s create a `presentError` method in `restaurant_controller.rb`,
    and print the error on pop-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Go to the terminal and start the application with the `rake` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to an external API](img/5220OT_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the list of restaurants is shown dynamically from the JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: Search restaurant by city
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we were only showing restaurants in Chicago. If you
    noticed, it was hardcoded in the URL itself and was not generic. In this section
    we will make the application more generic and allow the user to search data based
    on a parameter city.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `restro_controller.rb` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Search restaurant by city](img/5220OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Start the simulator by the `rake` command, and you can see that your toolbar
    is replaced with a search box with the default value **Chicago**.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UISearchBar` class implements a text field control for text-based searches.
    The `UISearchBar` object does not actually perform any search; it is just a view,
    which we can see on the device. To make the search work, we use a delegate, which
    is an object conforming to the `UISearchBarDelegate` protocol, to implement the
    actions when text is entered and buttons are clicked. The `UISearchBarDelegate`
    protocol defines the optional methods you implement to make a `UISearchBar` control
    functional.
  prefs: []
  type: TYPE_NORMAL
- en: The `UISearchBar` object provides the user interface for a search field on a
    bar, but it's the application's responsibility to implement the actions when buttons
    are tapped. We can implement this using various methods available, which are explained
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods used for editing text are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`searchBar:textDidChange`: This tells the delegate that the user changed the
    search text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBar:shouldChangeTextInRange:replacementText`: This asks the delegate
    if text in a specified range should be replaced with the given text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBarShouldBeginEditing`: This asks the delegate if editing should begin
    in the specified search bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBarTextDidBeginEditing`: This tells the delegate when the user begins
    editing the search text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBarShouldEndEditing`: This asks the delegate if editing should stop
    in the specified search bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBarTextDidEndEditing`: This tells the delegate that the user finished
    editing the search text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The methods used for different click events on various buttons in the search
    bar are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`searchBarBookmarkButtonClicked`: This tells the delegate that the bookmark
    button was tapped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBarCancelButtonClicked`: This tells the delegate that the cancel button
    was tapped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBarSearchButtonClicked`: This tells the delegate that the search results
    list button was tapped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchBarResultsListButtonClicked`: This tells the delegate that the search
    button was tapped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method used for the scope button is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`searchBar:selectedScopeButtonIndexDidChange`: This tells the delegate that
    the scope button selection changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a minimum, the delegate needs to perform the actual search when the text
    is entered in the text field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have implemented `searchBarSearchButtonClicked(searchBar)`, and whenever
    the search button is clicked this action will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, all the results that we have fetched from our web service are stored in
    the `json` variable. We will loop through this object and store the information
    in our restaurant model, which we have created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We have to reload the view once we complete the entire task, and this can be
    done by using the `view.reloadData` class.
  prefs: []
  type: TYPE_NORMAL
- en: Picture speaks louder than words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now show a thumbnail image of a restaurant next to its name. In the JSON
    API call, we also see that we are getting the link for the restaurant image. So,
    we use this URL to display the image with the restaurant name in the table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `restaurant_controller.rb` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`UIImage.alloc.initWithData` initializes and returns the image object with
    the specified data, and `NSData.alloc.initWithContentsOfURL` initializes a newly
    allocated data object initialized with the data from the location specified by
    a URL.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again let's fire up our simulator to see the progress. Run `rake` from
    the `app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture speaks louder than words](img/5220OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Isn't that simple! We can now see an image displayed next to the restaurant
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Play time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time for a small do-it-yourself exercise. In the same application put some
    description about the restaurant in each row of the table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Play time](img/5220OT_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We get the description in our API and it is already stored in the `Restaurant`
    object. To display this in the view you can use `detailTextLabel` on the cell
    object, as we have used in `textLabel`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recap what we have learned in this iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Controller architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an MVC design with RubyMotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting our application with an external API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmenting our app with search and images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will turn our attention to user interface (UI) for mobile
    applications. UI is a key area in mobile application development, and we will
    learn about various Objective-C classes, which make user interface more interactive,
    and how they can be used in our RubyMotion application.
  prefs: []
  type: TYPE_NORMAL
