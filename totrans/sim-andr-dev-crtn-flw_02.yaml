- en: '*Chapter 1*: Introduction to Asynchronous Programming in Android'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are Android applications that work on their own. But most apps retrieve
    data from or send data to a local database or a backend server. Examples of these
    include fetching posts from a social network, saving your favorites from a list,
    uploading an image, or updating your profile information. These tasks and other
    resource-intensive computations may happen instantly or take a while to finish.
    Factors such as internet connection, device specifications, and server settings
    affect how long these operations take.
  prefs: []
  type: TYPE_NORMAL
- en: Long-running operations must not be performed on the main UI thread as the application
    will be blocked until they are completed. The application might become unresponsive
    to the users. Users may not be aware of what’s happening, and this might prompt
    them to close the app and reopen it (canceling the original task or doing it again).
    The app can also suddenly crash. Some users might even stop using your app if
    this happens frequently.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this from happening, you need to use asynchronous programming. Tasks
    that can take an indefinite amount of time must be done asynchronously. They must
    run in the background, parallel to other tasks. For example, while posting information
    to your backend server, the app displays the UI, which the users can interact
    with. When the operation finishes, you can then update the UI or notify the users
    (with a dialog or a snackbar message).
  prefs: []
  type: TYPE_NORMAL
- en: With this book, you will learn how to simplify asynchronous programming in Android
    using Kotlin coroutines and flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will first start by revisiting the concept of asynchronous
    programming. After that, you will look into the various ways it is being done
    now in Android and how they may no longer be the best way moving forward. Then,
    you will be introduced to the new, recommended way of performing asynchronous
    programming in Android: coroutines and flows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers three main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads, AsyncTasks, and `Executors`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new way to do it – coroutines and flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a basic understanding of asynchronous
    programming, and know how to do it in Android using threads, AsyncTasks, and `Executors`.
    Finally, you will discover Kotlin coroutines and flows as these are the recommended
    ways of doing asynchronous programming in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to download and install the latest version of Android Studio.
    You can find the latest version at [https://developer.android.com/studio](https://developer.android.com/studio).
    For an optimal learning experience, a computer with the following specifications
    is recommended: Intel Core i5 or equivalent or higher, 4 GB RAM minimum, and 4
    GB available space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code examples for this book can be found on GitHub at https: [github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows](http://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start by looking at asynchronous programming. Asynchronous
    programming is a programming method that allows work to be done independently
    of the main application thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'A normal program will run sequentially. It will perform one task and move to
    the next task after the previous one has finished. For simple operations, this
    is fine. However, there are some tasks that might take a long time to finish,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data from or saving data to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting, adding, or updating data to a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing text, images, videos, or other files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complicated computations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app will look frozen and unresponsive to the users while it is performing
    these tasks. They won’t be able to do anything else in the app until the tasks
    are finished.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming solves this problem. You can run a task that may be
    processed indefinitely on a background thread (in parallel to the main thread)
    without freezing the app. This will allow the users to still interact with the
    app or the UI while the original task is running. When the task has finished or
    if an error was encountered, you can then inform the user using the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'A visual representation of asynchronous programming is shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Asynchronous programming'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.01_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Asynchronous programming
  prefs: []
  type: TYPE_NORMAL
- en: '**Task 1** and **Task 2** are running on the main thread. **Task 2** starts
    **Task 3** on the background thread. While **Task 3** is running, the main thread
    can continue to perform other tasks, such as **Task 4**. After **Task 3** is done,
    it will return to the main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming is an important skill for developers to have, especially
    for mobile app development. Mobile devices have limited capabilities and not all
    locations have a stable network connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, if you run a task on the main thread and it takes too long, the
    app can become unresponsive or look frozen. The app can also crash unexpectedly.
    You will likely get an **Application Not Responding** (**ANR**) error, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – An ANR dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.02_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – An ANR dialog
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Android 3.0 (Honeycomb), running a network operation on the main
    thread will cause `android.os.NetworkOnMainThreadException`, which will crash
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: ANR dialogs and crashes can annoy your users. If they happen all the time, they
    might stop using your app altogether and choose another app. To prevent them in
    your app, you must run tasks that can take a long period of time on the background
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you revisited the concept of asynchronous programming and how
    you can use it to run long-running tasks without freezing the app. You will explore
    various approaches for using asynchronous programming in Android in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring threads, AsyncTasks, and Executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways you can run tasks on the background thread in Android. In
    this section, you are going to explore various ways of doing asynchronous programming
    in Android, including using threads, AsyncTask, and `Executors`. You will learn
    how to start a task on the background thread and then update the main thread with
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A thread is a unit of execution that runs code concurrently. In Android, the
    UI thread is the main thread. You can perform a task on another thread by using
    the `java.lang.Thread` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To run the thread, call `Thread.start()`. Everything that is inside the braces
    will be performed on another thread. You can do any operation here, except updating
    the UI, as you will encounter `NetworkOnMainThreadException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the UI, such as displaying the text fetched in a `TextView` from
    the network, you would need to use `Activity.runOnUiThread()`. The code inside
    `runOnUIThread` will be executed in the main thread, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`runOnUIThread` will perform the `displayText(text)` function on the main UI
    thread.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not starting the thread from an activity, you can use handlers instead
    of `runOnUiThread` to update the UI, as seen in *Figure 1.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 1.3 – Threads and a handler'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.03_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Threads and a handler
  prefs: []
  type: TYPE_NORMAL
- en: A handler (`android.os.Handler`) allows you to communicate between threads,
    such as from the background thread to the main thread, as shown in the preceding
    figure. You can pass a looper into the Handler constructor to specify the thread
    where the task will be run. A looper is an object that runs the messages in the
    thread’s queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach the handler to the main thread, you should use `Looper.getMainLooper()`,
    like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`Handler(Looper.getMainLooper())` creates a handler tied to the main thread
    and posts the `displayText()` runnable function on the main thread.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Handler.post (Runnable)` function enqueues the runnable function to be
    executed on the specified thread. Other variants of the post function include
    `postAtTime(Runnable)` and `postDelayed (Runnable, uptimeMillis)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can also send an `android.os.Message` object with your handler,
    as shown in *Figure 1.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Threads, handlers, and messages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.04_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Threads, handlers, and messages
  prefs: []
  type: TYPE_NORMAL
- en: A thread’s handler allows you to send a message to the thread’s message queue.
    The handler’s looper will execute the messages in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: To include the actual messages you want to send in your Message object, you
    can use `setData(Bundle)` to pass a single bundle of data. You can also use the
    public fields of the message `class` (`arg1, arg2, and` `what` for integer values,
    and `obj` for an object value).
  prefs: []
  type: TYPE_NORMAL
- en: You must then create a subclass of Handler and override the `handleMessage(Message)`
    function. There, you can then get the data from the message and process it in
    the handler’s thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following functions to send a message: `sendMessage(Message)`,
    `sendMessageAtTime(Message, uptimeMillis)`, and `sendMessageDelayed(Message, delayMillis)`.
    The following code shows the use of the `sendMessage` function to send a message
    with a data bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fetchTextWithHandlerMessage()` gets the text from the network in a background
    thread. It then creates a message with a bundle object containing a string with
    a key of `key` to send that text. The handler can then, through the `handleMessage()`
    function, get the message’s bundle and get the string from the bundle using the
    same key.
  prefs: []
  type: TYPE_NORMAL
- en: You can also send empty messages with an integer value (the what) that you can
    use in your `handleMessage` function to identify what message was received. These
    send empty functions are `sendEmptyMessage(int)`, `sendEmptyMessageAtTime(int,
    long)`, and `sendEmptyMessageDelayed(int, long)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses `0` and `1` as values for what (“what” is a field of the
    `Message` class that is a user-defined message code so that the recipient can
    identify what this message is about): `1` for the case when the background task
    succeeded and `0` for the failure case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the background thread fetches the text from the
    network. It then sends an empty message of `1` if the operation succeeded and
    `0` if not. The handler, through the `handleMessage()` function, gets the `what`
    integer value of the message, which corresponds to the `0` or `1` empty message.
    Depending on this value, it can either update the UI or show an error to the main
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using threads and handlers works for background processing, but they have the
    following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time you need to run a task in the background, you should create a new
    thread and use `runOnUiThread` or a new handler to post back to the main thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating threads can consume a lot of memory and resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also slow down your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple threads make your code harder to debug and test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code can become complicated to read and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using threads makes it difficult to handle exceptions, which can lead to crashes.
  prefs: []
  type: TYPE_NORMAL
- en: As a thread is a low-level API for asynchronous programming, it is better to
    use the ones that are built on top of threads, such as executors and, until it
    was deprecated, `AsyncTask`. You can avoid it altogether by using Kotlin coroutines,
    which you will learn more about later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will explore callbacks, another approach to asynchronous
    Android programming.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common approach to asynchronous programming in Android is using callbacks.
    A callback is a function that will be run when the asynchronous code has finished
    executing. Some libraries offer callback functions that developers can use in
    their projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example of a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, after fetching the text in the background, the `onSuccess`
    callback will be called and will display the text on the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks work fine for simple asynchronous tasks. They can, however, become
    complicated easily, especially when nesting callback functions and handling errors.
    This makes it hard to read and test. You can avoid this by avoiding nesting callbacks
    and splitting functions into subfunctions. It is better to use coroutines, which
    you will learn more about shortly in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncTask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AsyncTask`, you don’t have to manually handle threads.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `AsyncTask`, you have to create a subclass of it with three generic
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'These types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Params`: This is the type of input for `AsyncTask` or is void if there’s no
    input needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Progress`: This argument is used to specify the progress of the background
    operation or Void if there’s no need to track the progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Result`: This is the type of output of `AsyncTask` or is void if there’s no
    output to be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you are going to create `AsyncTask` to download text from a
    specific endpoint, your `Params` will be the URL (`String`) and `Result` will
    be the text output (`String`). If you want to track the percentage of time remaining
    to download the text, you can use `Integer` for `Progress`. Your class declaration
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then start `AsyncTask` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`AsyncTask` has four events that you can override for your background processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doInBackground`: This event specifies the actual task that will be run in
    the background, such as fetching/saving data to a remote server. This is the only
    event that you are required to override.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPostExecute`: This event specifies the tasks that will be run in the UI
    thread after the background operation finishes, such as displaying the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPreExecute`: This event runs on the UI thread before doing the actual task,
    usually displaying a progress loading indicator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onProgressUpdate`: This event runs in the UI thread to denote progress on
    the background process, such as displaying the amount of time remaining to finish
    the task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 1.5* visualizes these `AsyncTask` events and in what
    threads they are run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – AsyncTask events in main and background threads'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.05_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – AsyncTask events in main and background threads
  prefs: []
  type: TYPE_NORMAL
- en: The `onPreExecute`, `onProgressUpdate`, and `onPostExecute` functions will run
    on the main thread, while `doInBackground` executes on the background thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our example, your `DownloadTextAsync` class could look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: In `DownloadTextAsync`, `doInBackground` fetches the text from the network and
    returns it as a string. `onPostExecute` will then be called with that string that
    can be displayed in the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncTask` can cause context leaks, missed callbacks, or crashes on configuration
    changes. For example, if you rotate the screen, the activity will be recreated
    and another `AsyncTask` instance can be created. The original instance won’t be
    automatically canceled and when it finishes and returns to `onPostExecute()`,
    the original activity is already gone.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `AsyncTask` also makes your code more complicated and less readable. As
    of Android 11, `AsyncTask` has been deprecated. It is recommended to use `java.util.concurrent`
    or Kotlin coroutines instead.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will explore one of the `java.util.concurrent` classes
    for asynchronous programming, `Executors`.
  prefs: []
  type: TYPE_NORMAL
- en: Executors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the classes in the `java.util.concurrent` package that you can use for
    asynchronous programming is `java.util.concurrent.Executor`. An executor is a
    high-level Java API for managing threads. It is an interface that has a single
    function, `execute(Runnable)`, for performing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To create an executor, you can use the utility methods from the `java.util.concurrent.Executors`
    class. `Executors.newSingleThreadExecutor()` creates an executor with a single
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your asynchronous code with `Executor` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The handler with `Looper.getMainLooper()` allows you to communicate back to
    the main thread so you can update the UI after your background task has been done.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutorService` is an executor that can do more than just `execute(Runnable)`.
    One of its subclasses is `ThreadPoolExecutor`, an `ExecutorService` class that
    implements a thread pool that you can customize.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutorService` has `submit(Runnable)` and `submit(Callable)` functions,
    which can execute a background task. They both return a `Future` object that represents
    the result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Future` object has two functions you can use, `Future.isDone()` to check
    whether the executor has finished the task and `Future.get()` to get the results
    of the task, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the executor created with a new single thread executor
    was used to submit the runnable function to get and display text from the network.
    The `submit` function returns a `Future` object, which you can later use to fetch
    the result with `Future.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned some of the methods that you can use for asynchronous
    programming in Android. While they do work and you can still use them (except
    for the now-deprecated `AsyncTask`), nowadays, they are not the best method to
    use moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, you will learn the new, recommended way of asynchronous
    programming in Android: using Kotlin coroutines and flows.'
  prefs: []
  type: TYPE_NORMAL
- en: The new way to do it – coroutines and flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn about the recommended approach for Android
    asynchronous programming: using coroutines and flows. Coroutines is a Kotlin library
    you can use in Android to perform asynchronous tasks. Coroutines is a library
    for managing background tasks that return a single value. Flows are built on top
    of coroutines that can return multiple values.'
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coroutines is a Kotlin library for managing background tasks, such as making
    network calls and accessing files or databases, or performing long-running background
    tasks. Using Kotlin coroutines is Google’s official recommendation for asynchronous
    programming on Android. Their Android Jetpack libraries, such as Lifecycle, WorkManager,
    and Room-KTX, now include support for coroutines. Other Android libraries, such
    as Retrofit, Ktor, and Coil, provide first-class support for Kotlin coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: With Kotlin coroutines, you can write your code in a sequential way. A long-running
    task can be made into a `suspend` function. A `suspend` function is a function
    that can perform its task by suspending the thread without blocking it, so the
    thread can still run other tasks. When the suspending function is done, the current
    thread will resume execution. This makes the code easier to read, debug, and test.
    Coroutines follow a principle of structured concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add coroutines to your Android project by adding the following lines
    to your `app/build.gradle` file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '`kotlinx-coroutines-core` is the main library for Kotlin coroutines, while
    `kotlinx-coroutines-android` adds support for the main Android thread (`Dispatchers.Main`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark a function as a suspending function, you can add the `suspend` keyword
    to it; for example, here we have a function that calls the `fetchText()` function,
    which retrieves text from an endpoint and then displays it in the UI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make the `fetchText()` function a suspending function by prefixing
    the `suspend` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can create a coroutine that will call the `fetchText()` suspending
    function and display the list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '`lifecycleScope` is the scope with which the coroutine will run. `launch` creates
    a coroutine to run in `Dispatchers.IO`, which is a thread for I/O or network operations.'
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchText()` function will suspend the coroutine before it starts the network
    request. While the coroutine is suspended, the main thread can do other work.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the text, it will resume the coroutine. `withContext(Dispatchers.Main)`
    will switch the coroutine context to the main thread, where the `displayText(text)`
    function will be executed (`Dispatchers.Main`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android Studio, the `suspend` function calls in your code with a gutter
    icon next to the line number. As shown in lines `fetchText()` and `withContext()`
    lines have the `suspend` function call gutter icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Android Studio suspend function call gutter icon'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.06_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – Android Studio suspend function call gutter icon
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Kotlin coroutines in [*Chapter 2*](B17773_02_Epub.xhtml#_idTextAnchor029),
    *Understanding Kotlin Coroutines*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about Kotlin Flows, built on top of coroutines,
    which can return multiple sequences of values.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flow is a new Kotlin asynchronous stream library that is built on top of Kotlin
    coroutines. A flow can emit multiple values instead of a single value and over
    a period of time. Kotlin Flow is ideal to use when you need to return multiple
    values asynchronously, such as automatic updates from your data source.
  prefs: []
  type: TYPE_NORMAL
- en: Flow is now used in Jetpack libraries such as Room-KTX and Android developers
    are already using Flow in their applications.
  prefs: []
  type: TYPE_NORMAL
- en: To use Kotlin Flows in your Android project, you have to add coroutines. An
    easy way to create a flow of objects is to use the `flow{}` builder. With the
    `flow{}` builder function, you can add values to the stream by calling emit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say in your Android app you have a `getTextFromNetwork` function that
    fetches text from a network endpoint and returns it as a `String` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to create a flow of each word of the text, we can do it with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Flow does not run or emit values until the flow is collected with any terminal
    operators, such as `collect`, `launchIn`, or `single`. You can use the `collect()`
    function to start the flow and process each value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'A visual representation of this flow is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Kotlin Flow visual representation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.07_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Kotlin Flow visual representation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 1.7*, as soon as the `getWords()` flow emits a string,
    the `displayWords` function collects the string and displays it immediately on
    the logs.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about Kotlin Flows in [*Chapter 5*](B17773_05_Epub.xhtml#_idTextAnchor062),
    *Using Kotlin Flows*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about Kotlin coroutines and flows, the recommended
    way to carry out asynchronous programming in Android. Coroutines is a Kotlin library
    for managing long-running tasks in the background. Flow is a new Kotlin asynchronous
    stream library, built on top of coroutines, that can emit multiple values over
    a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you revisited the concept of asynchronous programming. We learned
    that asynchronous programming helps you execute long-running tasks in the background
    without freezing the app and annoying your users.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned about various ways you can do asynchronous programming in Android,
    including with threads, AsyncTask, and `Executors`. We also learned that they
    allow you to perform tasks in the background and update the main thread. AsyncTask
    is already deprecated, and threads and `Executors` are not the best ways to carry
    out asynchronous programming in Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you were introduced to the new, recommended way to carry out asynchronous
    programming in Android: with Kotlin’s Coroutines and Flow. We learned that Coroutines
    is a Kotlin library that you can use to easily perform asynchronous, non-blocking,
    and long-running tasks in the background. Flow, built on top of Coroutines, allows
    you to handle functions that return multiple values over time.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will dive deeper into Kotlin coroutines and learn how
    to use them in your Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book assumes that you have experience and skills in Android development
    with Kotlin. If you would like to learn more about this, you can read the book
    *How to Build Android Apps with Kotlin* (*Packt Publishing, 2021, ISBN 9781838984113*).
  prefs: []
  type: TYPE_NORMAL
