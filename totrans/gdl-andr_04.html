<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating Build Variants</h1></div></div></div><p>When you are developing an app, you usually have a few different versions. The most common scenario is that you have a staging version that is used to manually test the app and assure its quality, and a production version. These versions usually have different settings. For example, the URL of the staging API can be different from the production API. In addition, you may have a free basic version of your app, and a paid version that has some extra features. In that case, you are already dealing with four different versions: staging free, staging paid, production free, and production paid. Having different configurations for every version can easily get very complicated.</p><p>Gradle has some convenient and extensible concepts to address this common issue. We already mentioned the <code class="literal">debug</code> and <code class="literal">release</code> build types that are created by Android Studio for every new project. There is another concept called product flavors, which adds even more possibilities for managing several versions of an app or library. Build types and product flavors are always combined, and make it easy to handle the scenario with free and paid versions of staging and production apps. The result of combining a build type and a product flavor is called a build variant.</p><p>We will start this chapter by looking at build types, what they can do to make a developer's life easier, and how to make the most of them. Then, we will discuss the difference between build types and product flavors and how both are used. We will also take a look at signing configurations, which is a necessity to publish apps, and how we can set a different signing configuration for every build variant.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build types</li><li class="listitem" style="list-style-type: disc">Product flavors</li><li class="listitem" style="list-style-type: disc">Build variants</li><li class="listitem" style="list-style-type: disc">Signing configurations</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Build types</h1></div></div></div><p>In the Android plugin<a id="id150" class="indexterm"/> for Gradle, a build type is used to define how an app or library should be built. Every build type can specify whether the debug symbols should be included, what the application ID has to be, whether unused resources should be removed, and so on. You can define build types within a <code class="literal">buildTypes</code> block. This is what a standard <code class="literal">buildTypes</code> block looks like in a build file created by Android Studio:</p><div><pre class="programlisting">android {
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}</pre></div><p>The default <code class="literal">build.gradle</code> file for a new module configures a build type called <code class="literal">release</code>. This build type does nothing more than disabling removal of unused resources (by setting <code class="literal">minifyEnabled</code> to <code class="literal">false</code>) and defining the location of the default ProGuard configuration file. This is to make it straightforward for developers to start using ProGuard for their production build, whenever they are ready for it.</p><p>The <code class="literal">release</code> build type<a id="id151" class="indexterm"/> is not the only build type that is already created for your project, though. By default, every module has a <code class="literal">debug</code> build type. It is set to sensible defaults, but you can change its configuration by including it in the <code class="literal">buildTypes</code> block, and overriding the properties you want to change.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The <code class="literal">debug</code> build type has<a id="id152" class="indexterm"/> its own default settings to make it easy to debug. When you create your own build type, different defaults apply. For example, the <code class="literal">debuggable</code> property is set to <code class="literal">true</code> for the <code class="literal">debug</code> build type, but is set to <code class="literal">false</code> in any other build type you create.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Creating build types</h2></div></div></div><p>When the default<a id="id153" class="indexterm"/> settings are not enough, it is easy to create your own custom build types. All that is required for a new build type is a new object within the <code class="literal">buildTypes</code> block. Here is an example of a custom build type called <code class="literal">staging</code>:</p><div><pre class="programlisting">android {
    buildTypes {
        staging {
            applicationIdSuffix ".staging"
            versionNameSuffix "-staging"
            buildConfigField "String", "API_URL", "\"http://staging.example.com/api\""
        }
    }
}</pre></div><p>The <code class="literal">staging</code> build type<a id="id154" class="indexterm"/> defines a new suffix for the application ID, making it different from the application ID of the debug and release versions. Assuming you have the default build configuration, plus the staging build type, the application IDs for the build types look like this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Debug: <code class="literal">com.package</code></li><li class="listitem" style="list-style-type: disc">Release: <code class="literal">com.package</code></li><li class="listitem" style="list-style-type: disc">Staging: <code class="literal">com.package.staging</code></li></ul></div><p>This means <a id="id155" class="indexterm"/>that you will be able to install both the staging version and the release version on the same device without causing any conflicts. The <code class="literal">staging</code> build type also has a version name suffix, which is useful to differentiate several versions of the app on the same device. The <code class="literal">buildConfigField</code> property defines a custom URL for the API, using a build configuration field, as we saw in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <em>Basic Build Customization</em>.</p><p>You do not always have to start from scratch when creating a new build type. It is possible to initialize a build type that copies the properties of another build type:</p><div><pre class="programlisting">android {
    buildTypes {
        staging.initWith(buildTypes.debug)
        staging {
            applicationIdSuffix ".staging"
            versionNameSuffix "-staging"
            debuggable = false
        }
    }
}</pre></div><p>The <code class="literal">initWith()</code> method creates a new build type and copies all properties from an existing build type to the newly created one. It is possible to override properties or define extra properties by simply defining them in the new build type object.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Source sets</h2></div></div></div><p>When you create a new<a id="id156" class="indexterm"/> build type, Gradle also creates a new source set. By default, the<a id="id157" class="indexterm"/> source set directory is assumed to have the same name as the build type. The directory is not automatically created when you define a new build type, though. You have to create the source set directory yourself before you can use custom source code and resources for a build type.</p><p>This is what the directory structure can look like with the standard <code class="literal">debug</code> and <code class="literal">release</code> build type, plus an extra staging build type:</p><div><pre class="programlisting">app
└── src
    ├── debug
    │   ├── java
    │   │   └── com.package
    │   │       └── Constants.java
    │   ├── res
    │   │   └── layout
    │   │       └── activity_main.xml
    │   └── AndroidManifest.xml
    ├── main
    │   ├── java
    │   │   └── com.package
    │   │       └── MainActivity.java
    │   ├── res
    │   │   ├── drawable
    │   │   └── layout
    │   │       └── activity_main.xml
    │   └── AndroidManifest.xml
    ├── staging
    │   ├── java
    │   │   └── com.package
    │   │       └── Constants.java
    │   ├── res
    │   │   └── layout
    │   │       └── activity_main.xml
    │   └── AndroidManifest.xml
    └── release
        ├── java
        │   └── com.package
        │       └── Constants.java
        └── AndroidManifest.xml</pre></div><p>These source sets open up a world of possibilities. For example, you can override certain properties for specific build types, add custom code to certain build types, and add customized layouts or strings to different build types.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>When adding Java classes to build types, it is important to keep in mind that this process is mutually exclusive. This means that if you add class <code class="literal">CustomLogic.java</code> to the staging source set, you will be able to add the same class to the debug and release source sets, but not to the main source set. The class would then be defined twice, throwing an exception when you try to build.</p></div></div><p>Resources are<a id="id158" class="indexterm"/> handled in a special way when using different source<a id="id159" class="indexterm"/> sets. Drawables and layout files will completely override the resources with the same name in the main source set, but files in the <code class="literal">values</code> directory (such as <code class="literal">strings.xml</code>) will not. Gradle will instead merge the content of the build type resources with the main resources.</p><p>For example, if you have a <code class="literal">strings.xml</code> file in the main source set that looks like this:</p><div><pre class="programlisting">&lt;resources&gt;
    &lt;string name="app_name"&gt;TypesAndFlavors&lt;/string&gt;
    &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;
&lt;/resources&gt;</pre></div><p>And if you have a <code class="literal">strings.xml</code> file in the <code class="literal">staging</code> build type source set like this:</p><div><pre class="programlisting">&lt;resources&gt;
    &lt;string name="app_name"&gt;TypesAndFlavors STAGING&lt;/string&gt;
&lt;/resources&gt;</pre></div><p>Then, the merged <code class="literal">strings.xml</code> file will look like this:</p><div><pre class="programlisting">&lt;resources&gt;
    &lt;string name="app_name"&gt;TypesAndFlavors STAGING&lt;/string&gt;
    &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt;
&lt;/resources&gt;</pre></div><p>When you build a build type that is not staging, the final <code class="literal">strings.xml</code> file will just be the <code class="literal">strings.xml</code> file from the main source set.</p><p>The same is true for manifest files. If you create a manifest file for a build type, you do not need to copy the entire manifest file from the main source set; you can just add the tags you need. The Android plugin will merge the manifests together.</p><p>We will talk about merging in more detail later in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Dependencies</h2></div></div></div><p>Every build <a id="id160" class="indexterm"/>type can have its own dependencies. Gradle automatically <a id="id161" class="indexterm"/>creates new dependency configurations for every build type. If you want to add a logging framework only for <code class="literal">debug</code> builds, for example, you can do it like this:</p><div><pre class="programlisting">dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.2.0'
    debugCompile 'de.mindpipe.android:android-logging-log4j:1.0.3'
}</pre></div><p>You can combine any build type with any dependency configuration in this manner. This gives you the possibility to get very specific with dependencies.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Product flavors</h1></div></div></div><p>As opposed to build types, which <a id="id162" class="indexterm"/>are used to configure several different builds of the same app or library, product flavors are used to create different versions of the same app. The typical example is an app that has a free and a paid version. Another common scenario is an agency that builds apps that have the same functionality for several clients, where only the branding changes. This is very common in the taxi industry or with banking apps, where one company creates an app that can be reused for all clients in the same category. The only things that change are the main colors, the logo, and the URL of the backend. Product flavors greatly simplify the process of having different versions of an app based on the same code.</p><p>If you are unsure whether you need a new build type, or a new product flavor, you should ask yourself if you want to create a new build of the same app for internal use, or a new APK to publish to Google Play. If you need an entirely new app that needs to be published separately from what you already have, then product flavors are the way to go. Otherwise, you should stick to using build types.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Creating product flavors</h2></div></div></div><p>Creating product flavors<a id="id163" class="indexterm"/> is very similar to creating build types. You can create a new product flavor by adding it to the <code class="literal">productFlavor</code> block, like this:</p><div><pre class="programlisting">android {
    productFlavors {
        red {
            applicationId 'com.gradleforandroid.red'
            versionCode 3
        }
        blue {
            applicationId 'com.gradleforandroid.blue'
            minSdkVersion 14
            versionCode 4
        }
    }
}</pre></div><p>Product flavors have <a id="id164" class="indexterm"/>different properties than build types. That is because product flavors are objects of the <code class="literal">ProductFlavor</code> class, just like the <code class="literal">defaultConfig</code> object that is present in all build scripts. This means that <code class="literal">defaultConfig</code> and all your product flavors share the same properties.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Source sets</h2></div></div></div><p>Just like with build types, product<a id="id165" class="indexterm"/> flavors can have their own source set directories. Creating <a id="id166" class="indexterm"/>a folder for a specific flavor is as easy as creating a folder with the flavor name. You can even go one step further and create a folder specifically for a combination of a certain build type and flavor. The name of the folder would then be the flavor name followed by the build type name. For example, if you want to have a different app icon specifically for the release version of the blue flavor, the folder would have to be called <code class="literal">blueRelease</code>. The components of the combined folder will have a higher priority than the components from both the build type folder and the product flavor folder.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Multiflavor variants</h2></div></div></div><p>In some cases, you might want <a id="id167" class="indexterm"/>to take it further and <a id="id168" class="indexterm"/>create combinations of product flavors. For example, client A and client B might each want free and paid versions of their app, which is based on the same code base, but has different branding. Creating four different flavors would mean having several duplicate settings, so that is not the way to go. Combining flavors in an efficient way is possible using flavor dimensions, like this:</p><div><pre class="programlisting">android {
    flavorDimensions "color", "price"

    productFlavors {
        red {
            flavorDimension "color"
        }

        blue {
            flavorDimension "color"
        }
        free {
            flavorDimension "price"
        }

        paid {
            flavorDimension "price"
        }
    }
}</pre></div><p>As soon as you add the flavor dimensions, Gradle expects you to specify a dimension for each flavor. If you forget, you will get a build error with a message explaining the issue. The <code class="literal">flavorDimensions</code> array defines the dimensions, and the order of the dimensions is very important. When combining two flavors, they might have defined the same properties or resources. In that case, the order of the flavor dimensions array determines which flavor configuration overrides the other. In the earlier example, the color dimension overrides the price dimension. The order also determines the name of the build variant.</p><p>Assuming the default <a id="id169" class="indexterm"/>build configuration with the debug and <a id="id170" class="indexterm"/>release build types, defining the flavors as shown in the previous example will generate all of these build variants:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">blueFreeDebug</code> and <code class="literal">blueFreeRelease</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">bluePaidDebug</code> and <code class="literal">bluePaidRelease</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">redFreeDebug</code> and <code class="literal">redFreeRelease</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">redPaidDebug</code> and <code class="literal">redPaidRelease</code></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Build variants</h1></div></div></div><p>Build variants<a id="id171" class="indexterm"/> are simply the result of combining build types and product flavors. Whenever you create a build type or product flavor, new variants are created as well. For example, if you have the standard <code class="literal">debug</code> and <code class="literal">release</code> build types, and you create a red and blue product flavor, the following build variants will be generated:</p><div><img src="img/B01061_04_01.jpg" alt="Build variants"/></div><p>This is a screenshot <a id="id172" class="indexterm"/>of the <strong>Build Variants</strong> tool window in Android Studio. You can find the tool window in the bottom-left corner of the editor, or open it from <strong>View</strong> | <strong>Tool Windows</strong> | <strong>Build Variants</strong>. This tool window lists all the build variants, but also allows you to switch between them. Changing the selected build variant here will affect which variant runs when the <strong>Run</strong> button is clicked.</p><p>If you have no product flavors, variants will simply consist of build types. It is impossible to not have any build types. Even if you do not define any build types yourself, the Android plugin for Gradle always creates a debug build type for your app or library.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Tasks</h2></div></div></div><p>The Android plugin<a id="id173" class="indexterm"/> for Gradle will create tasks for every build variant you configure. A new Android app has <code class="literal">debug</code> and <code class="literal">release</code> build types by default, so you already have <code class="literal">assembleDebug</code> and <code class="literal">assembleRelease</code> to build both APKs separately, and <code class="literal">assemble</code> to create both with a single command. When you add a new build type, a new task will be created as well. As soon as you start adding flavors into the mix, a whole new range of tasks is created, because the tasks for every build type are combined with tasks for every product flavor. This means that for a simple setup with one build type and one flavor, you already have three tasks to build all the variants:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assembleBlue</code> uses <a id="id174" class="indexterm"/>the blue flavor configuration and assembles both <code class="literal">BlueRelease</code> and <code class="literal">BlueDebug</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assembleDebug</code> <a id="id175" class="indexterm"/>uses the debug build type configuration and assembles a debug version for every product flavor.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assembleBlueDebug</code> <a id="id176" class="indexterm"/>combines the flavor configuration with the build type configuration, and the flavor settings override the build type settings.</li></ul></div><p>New tasks are created for every build type, for every product flavor, and for every combination of build type and product flavor.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Source sets</h2></div></div></div><p>Build variants that <a id="id177" class="indexterm"/>are a combination of a build type and one or more product flavors <a id="id178" class="indexterm"/>can also have their own source set directories. For example, the variant created from the <code class="literal">debug</code> build type, the blue flavor and the free flavor, can have its own source set in <code class="literal">src/blueFreeDebug/java/</code>. It is possible to override the location for the directory using the <code class="literal">sourceSets</code> block, which we saw in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Gradle and Android Studio">Chapter 1</a>, <em>Getting Started with Gradle and Android Studio</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Resource and manifest merging</h2></div></div></div><p>The introduction of source <a id="id179" class="indexterm"/>sets adds extra complexity to the <a id="id180" class="indexterm"/>build process. The Android plugin for Gradle needs to merge the main source set and the build type source sets together before packaging the app. In addition, library projects can also provide extra resources, and those need to be merged in as well. The same goes for manifest files. You may need extra Android permissions in the debug variant of your app to store log files, for example. You do not want to declare this permission on the main source set because that might scare potential users. Instead, you would add an extra manifest file in the <code class="literal">debug</code> build type source set to declare the extra permission.</p><p>The priority order for resources and manifests looks like this:</p><div><img src="img/B01061_04_05.jpg" alt="Resource and manifest merging"/></div><p>If a resource is declared in a flavor and in the main source set, the one from the flavor will be given a higher priority. In this case, the resource in the flavor source set will be packaged, and not the one in the main source set. Resources declared in library projects always have the lowest priority.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>There is a lot more to learn about resource and manifest merging. It is an incredibly complicated subject, and if we were to explain its details, we would need to dedicate an entire chapter to it. Instead, if you want to learn more, it is a good idea to read the official <a id="id181" class="indexterm"/>documentation on the topic at <a class="ulink" href="http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger">http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Creating build variants</h2></div></div></div><p>Gradle makes it <a id="id182" class="indexterm"/>easy to handle the complexity of build variants. Even when creating and configuring two build types and two product flavors, the build file is still concise:</p><div><pre class="programlisting">android {
    buildTypes {
        debug {
            buildConfigField "String", "API_URL", "\"http://test.example.com/api\""
        }

        staging.initWith(android.buildTypes.debug)
        staging {
            buildConfigField "String", "API_URL", "\"http://staging.example.com/api\""
            applicationIdSuffix ".staging"
        }
    }

    productFlavors {
        red {
            applicationId "com.gradleforandroid.red"
            resValue "color", "flavor_color", "#ff0000"
        }

        blue {
            applicationId "com.gradleforandroid.blue"
            resValue "color", "flavor_color", "#0000ff"
        }
    }
}</pre></div><p>In this example, we have created four different build variants: <code class="literal">blueDebug</code>, <code class="literal">blueStaging</code>, <code class="literal">redDebug</code>, and <code class="literal">redStaging</code>. Each variant has its own combination of API URL and flavor color. This is what <code class="literal">blueDebug</code> looks like on a phone:</p><div><img src="img/B01061_04_02.jpg" alt="Creating build variants"/></div><p>And this is the <code class="literal">redStaging</code> variant of the same app:</p><div><img src="img/B01061_04_03.jpg" alt="Creating build variants"/></div><p>The first screenshot <a id="id183" class="indexterm"/>shows the <code class="literal">blueDebug</code> variant, which uses the URL defined in the <code class="literal">debug</code> build type, and makes its text blue, based on <code class="literal">flavor_color</code> defined for the blue product flavor. The second screenshot shows <code class="literal">redStaging</code>, with the staging URL and red text. The red staging version also has a different app icon, because the drawable folders in the source set for the <code class="literal">staging</code> build type have their own app icon images.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Variant filters</h2></div></div></div><p>It is possible to entirely ignore certain <a id="id184" class="indexterm"/>variants in your build. This way, you can speed up the<a id="id185" class="indexterm"/> process of building all variants with the general <code class="literal">assemble</code> command, and your list of tasks will not be polluted with tasks that should not be executed. This also ensures that the build variant does not show up in the Android Studio build variants switcher.</p><p>You can filter out variants, using this code in the root level of the <code class="literal">build.gradle</code> file of your app or library:</p><div><pre class="programlisting">android.variantFilter { variant -&gt;
    if(variant.buildType.name.equals('release')) {
        variant.getFlavors().each() { flavor -&gt;
            if (flavor.name.equals('blue')) {
                variant.setIgnore(true);
            }
        }
    }
}</pre></div><p>In this example, we first check if the variant's build type has the name <code class="literal">release</code>. Then, we extract the names of all the product flavors. When using flavors without dimensions, there is only one product flavor in the flavors array. As soon as you start applying flavor dimensions, the flavor array will hold as many flavors as there are dimensions. In the example script, we check for the blue product flavor, and tell the build script to ignore this particular variant.</p><p>This is the result of the variant<a id="id186" class="indexterm"/> filter in the build variant switcher in <a id="id187" class="indexterm"/>Android Studio:</p><div><img src="img/B01061_04_04.jpg" alt="Variant filters"/></div><p>You can see that the two blue release variants (<code class="literal">blueFreeRelease</code> and <code class="literal">bluePaidRelease</code>) are filtered out of the list of build variants. If you were to run <code class="literal">gradlew tasks</code> now, you would notice that all the tasks related to those variants do not exist anymore.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Signing configurations</h1></div></div></div><p>Before you can publish an app on <a id="id188" class="indexterm"/>Google Play or any other app store, you need to sign it with a private key. If you have a paid and free version or different apps for different clients, you need to sign every flavor with a different key. This is where signing configurations come in handy.</p><p>Signing configurations can be defined like this:</p><div><pre class="programlisting">android {
    signingConfigs {
        staging.initWith(signingConfigs.debug)

        release {
            storeFile file("release.keystore")
            storePassword"secretpassword"
            keyAlias "gradleforandroid"
            keyPassword "secretpassword"
        }
    }
}</pre></div><p>In this example, we create two different signing configurations.</p><p>The debug configuration is<a id="id189" class="indexterm"/> automatically set up by the Android plugin and makes use of a general keystore with a known password, so it is not necessary to create a signing configuration for this build type.</p><p>The staging configuration in the example uses <code class="literal">initWith()</code>, which copies all properties from another signing configuration. This means that the staging builds are signed with the debug key, instead of defining its own.</p><p>The release configuration uses <code class="literal">storeFile</code> to specify the path of the keystore file and then defines the key alias and both passwords.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>As mentioned earlier, it is not a good idea to store credentials in the build configuration file. A better idea would be to use a Gradle properties file. In <a class="link" href="ch07.html" title="Chapter 7. Creating Tasks and Plugins">Chapter 7</a>, <em>Creating Tasks and Plugins</em>, there is an entire section dedicated to a task to deal with signing configuration passwords.</p></div></div><p>After you define the signing configurations, you need to apply them to your build types or flavors. Build types and flavors both have a property called <code class="literal">signingConfig</code>, which can be used like this:</p><div><pre class="programlisting">android {
    buildTypes {
        release {
            signingConfig signingConfigs.release
        }
    }
}</pre></div><p>This example uses build types, but if you want to use different certificates for every flavor you create, you need to create different signing configurations. You can define those in the exact same way:</p><div><pre class="programlisting">android {
    productFlavors {
        blue {
            signingConfig signingConfigs.release
        }
    }
}</pre></div><p>Using signing configurations<a id="id190" class="indexterm"/> this way leads to problems though. When assigning a configuration to a flavor, you are actually overriding the signing configurations for the build types. What you want to do instead, when using flavors, is to have a different key per build type per flavor:</p><div><pre class="programlisting">android {
    buildTypes {
        release {
            productFlavors.red.signingConfig signingConfigs.red
            productFlavors.blue.signingConfig signingConfigs.blue
        }
    }
}</pre></div><p>The example shows how to use different signing configurations for the red and blue flavors that use the release build type, without influencing the debug and staging build types.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we talked about build types, product flavors, and all their possible combinations. These are very powerful tools that can be used in any application. From a simple setup with different URLs and keys to more complicated apps that share the same source code and resources but have different branding and several versions; build types and product flavors can make your life considerably easier.</p><p>We also talked about signing configurations and applying them, and mentioned a common pitfall when signing product flavors.</p><p>Next, you will be introduced to multimodule builds. These are useful when you want to extract code into a library or a library project, or when you want to include, for example, an Android Wear module into your app.</p></div></body></html>