- en: Lambdas and Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Click listeners using lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lazy delegate in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the observable delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using vetoable delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the lateinit modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with SharedPreferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a chain of multiple lets in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the functional aspects of Kotlin language.
    Kotlin has functional programming built in using lambdas. Java was lacking this
    modern language feature up until now, but it has included lambdas in Java 8\.
    However, since most of the Android devices don't support Java 8, Android developers
    were not able to use this feature. In this chapter, we will go through them and
    will also learn about delegates. Delegates are a powerful language feature of
    Kotlin. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Click listeners using lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An onclick listener in Android are one of those things that used to take up
    a lot of lines, even if the important portion of the code was only one line. Kotlin
    simplifies Android framework a lot, and one of the best improvements is `onClickListener`.
    In this recipe, we will see how we can simplify the traditional lengthy click
    listeners with the help of lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the given steps to understand how to use click listener using
    lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with creating an activity with some view, such as a button on
    which we can attach an `onClickListener`. Check out the following XML layout for
    one possible activity layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is how our layout looks, with three buttons on which we need
    to attach `onClickListener`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dccf397f-96e8-434c-baf3-37c3b3f64ad8.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see the code when we attach `onClickListener` to the three buttons
    in Java:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you note the amount of code we had to write just for attaching click listeners
    that show toasts? All this code for just three onclick listeners; now, let''s
    see the difference it makes to write the same code in Kotlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is certainly lesser and cleaner, thanks to Kotlin **synthetic properties**
    and **Anko** for toast helper function.  Now, let''s try to use **lambda** and
    see what difference it makes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Whoa! All hail to the power of lambdas. Note how much code has been reduced,
    and it looks clean and more readable. This a large amount of boilerplate code
    reduction, which saves us both time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda functions are functions that are not declared but passed as an expression.
    In Kotlin, if a function receives an interface, we can replace it with a lambda.
    For example, the `setOnClickListener` function receives `View.OnClickListener`,
    so we can use a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if there are no parameters to be passed to the lambda function, we can
    omit the arrow, and if the last parameter being passed is a function, we can move
    it outside the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if the lambda function being passed is actually the only parameter, you
    can omit the parentheses completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use **Anko**, a library by Kotlin to reduce the code even further. Anko
    provides an `onClick()` method that accepts a lambda that gets executed `onClick`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using lazy delegate in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lazy construct is basically used for lazy initialization of properties,
    which is especially helpful when the object being initialized is a heavy object
    (takes time to initialize). Instantiating heavy objects at startup can cause visible
    performance drop in mobile user experience. Lazy initialization can solve our
    problem. In this recipe, we will learn how to use Kotlin's lazy delegate, so let's
    get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Android Studio 3.0 for coding, ensure that you have the latest
    version downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn how to use the lazy delegate in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how to create a property through lazy initialization. The
    syntax is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While creating a lazy delegate, we use `by lazy`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The lazy delegate initializes the object on its first access and stores the
    value, which is then returned for subsequent accesses.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The delegation of a property looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The read operation calls the `getValue` method, and the write operation calls
    `setValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three modes of evaluation of lazy properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.SYNCHRONIZED`: Initialization occurs only on one thread.
    The rest of the threads see the cached value. It is also the default mode of initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.PUBLICATION`: Used when synchronization of initialization
    delegate is not required. It can then be called from multiple threads at a time,
    and initialization can be performed on every thread. However, if initialization
    is done by one thread, it will be returned without performing initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LazyThreadSafetyMode.NONE`: No locks are used to synchronize initialization
    and hence less overhead costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the observable delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we saw how to work with delegated properties. In this recipe, we
    will learn how to work with the observable delegate. This delegate helps us observe
    any changes to the property. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA for writing code. You can use any IDE where you
    are able to execute Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The observable delegates take in a default value and a construct where we have
    old and new values. Let''s take a look at the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have provided the initial value as an empty string.
    The construct will be executed every time we try to update the value of the `a`
    property. We have changed the value of `a` two times and hence we are seeing two
    print statements.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observable delegate can be especially useful in the case of `RecyclerView`,
    because we can use `DiffUtils` to update just the items that are updated, rather
    than replacing the whole list with a new one. For more information, refer to the
    recipe in [Chapter 4](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e79a66d5-bec1-4560-b363-2489175de44b.xhtml), *Creating
    RecyclerView Adapter in Kotlin*.
  prefs: []
  type: TYPE_NORMAL
- en: Using vetoable delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vetoable delegate** is quite similar to the observable delegate, with the
    only difference of vetoing the change. In the observable delegate, we could get
    hold of new and old values whenever the observable property was changed. Let''s
    take a look at the definition provided in Kotlin''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Returns a property delegate for a read/write property that calls a specified
    callback function when changed, allowing the callback to veto the modification."'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for coding purposes. You can use any IDE capable
    of executing Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now look at the given steps to understand the `vetoable` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at an implementation of the `vetoable` delegated property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the modification is "vetoed" by the `vetoable` delegate since
    the age can't be greater than `25`. The new object will only be assigned if the
    age is less than `25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the vetoable delegated property declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `vetoable()` takes an initial value, which could be an empty list, and also
    an `onChange` callback, which is called before the change to a property is made.
    The callback returns true if the change is successful and false if it is vetoed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vetoable can be especially useful if you use it in the `Recyclerview` adapter.
    Generally, you would assign data to the list directly and may call `notifyDatasetChanged`,
    but this is highly inefficient, as it will result in loading all the data again.
    We can use vetoable to check whether the content is the same by matching the old
    value and new value and can veto modification if it is the same. Also, we can
    use `DiffUtils` to just update the data that is changed. `DiffUtils` was introduced
    in Android support library 26.01 and later versions, and makes `RecyclerView`
    much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegated properties are one of the best features of Kotlin language. We have
    already seen observable and vetoable delegates. In this recipe, we will learn
    how to create our own custom delegate. As a demo example, we will create a delegate
    property that can only be initialized once; if done again, it should throw an
    exception. So let's dive into it and see how we can achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA for coding purposes. You can use any IDE capable
    of executing Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s dive in and learn how to create our own delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a custom delegate named as  `SingleInitializationProperty`. This
    custom delegate property will throw an exception if the variable isn''t initialized,
    and it can only be initialized once. Doing it a second time will throw an exception.
    Let''s take a look at our custom delegate class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, that we have created a custom delegate, let''s try to use it without initializing
    it in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see another example; this time, we will first initialize it, then access
    it, and then again try to initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, we have implemented the `ReadWriteProperty` interface in the
    delegated property, which basically means our variable will be of the `var` type.
    If you want it to be immutable, you can implement the `ReadOnlyProperty` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `getValue` function takes a reference to a class and a property's metadata.
    The `setValue` function, in turn, receives a set value. In case of immutable property
    (`val`), there will be only one `getValue` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the lateinit modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lateinit** is an important initialization property, because if you don''t
    want to initialize your variable in constructor, `lazy` and `lateinit` can be
    employed to do so. In this recipe, we will see how to use the `lateinit` modifier
    and how it is different from the `lazy` modifier.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for the coding purpose; you can use any IDE that
    can execute Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the given steps to understand how the `lateinit` modifier works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we could just declare a variable beforehand and initialize it later,
    but Kotlin requires you to initialize it as soon as you declare it (unless you
    are using special modifiers). So you can do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Both ways have their drawbacks. The first way will require you to check nullability
    whenever you use it, and the second way of initializing will make it immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome limitations, we can use a `lateinit` modifier, with which we can
    declare it beforehand and initialize anywhere we want (but before we first access
    it). This is especially needed when you use dependency injection. Let''s see an
    example from Kotlin documentation that uses the `lateinit` modifier to declare
    the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to access the variable before initializing it, you will get `UninitializedPropertyAccessException`.
    If you are using dependency injection, here''s how you would use `lateinit` with
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of initializing properties is with the `lazy` modifier; `lazy()`
    is basically a function that takes a lambda and returns an instance of lazy, which
    serves as a delegate for implementing a lazy property. Let''s take a look at the
    next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By `lazy` initialization, we postpone initialization until we first use it.
    The property is initialized only when we first access it, and the same value is
    returned for subsequent accesses. That's why it is mandatory to mark the variable
    immutable. This can really help us with initialization of heavy objects, which
    takes a lot of time. Initializing them `lazily` can improve our startup time.
    The only con is that you won't be able to modify it later since it is a `val`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SharedPreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SharedPreferences** is a persistent way of data storage in Android devices
    and is mostly used to save data in key-value pairs, such as the settings of an
    app. Kotlin makes it easier to work with shared preference using its unique language
    construct. In this recipe, we will see how Kotlin can help us deal with SharedPreferences
    easily. So let''s get started.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Android Studio 3.0 for this recipe. If you have an older version
    of Android Studio, either update it to 3.0 or configure Kotlin in it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to define and use SharedPreferences, we follow particular steps.
    We will go through each step and implement this together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a `Prefs` class that will act as a single entry to read/write
    from our app''s SharedPreferences. This will make it easier to handle all SharedPreferences
    since they all will be in one place. As we know, shared preference requires context
    to be present, so we will pass context in the primary constructor. We will also
    create a single SharedPreferences object that we will use throughout the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we have defined a `PREF_USERNAME` SharedPreferences; here, we
    will store the username of the user. Now the fun part begins; remember that Kotlin
    has a property where we can explicitly define how to get and set the property.
    We will use the same thing here. Let''s take a look at the given code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the setter, we are editing the shared preference and in the
    getter, we are extracting the value of the shared preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `Prefs` class ready, we can use it in our activities,
    fragments, and so on. The best way to do it will be by defining it in the `Application`
    class and accessing is from many activities or fragments, because then we will
    not need to create multiple objects of the `Prefs` class. So let''s create an
    `Application` class and a singleton instance of the `Prefs` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have added and placed our `prefs` variable inside the companion object to
    be able to use it statically. Also, now that we have placed it inside the `Application`
    class, we will be dealing only with a single instance of the `prefs` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `lazy` construct to ensure that we create an object only
    at its first access. Doing so will also help us avoid null checks. Here''s how
    our `App` class will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look at an example to add a value to our SharedPreferences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks so simple to work with shared preferences now, as if we are assigning
    values to a variable. Accessing them is also very easy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, we have used the `apply()` method to save preferences, which
    commits the changes in the in-memory SharedPreferences immediately, but also starts
    an asynchronous commit to the disk; `commit()`, on the other hand, writes to persistent
    storage synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chain of multiple lets in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`let` is a pretty useful function provided by Kotlin''s `Standard.kt` library.
    It is basically a scoping function that allows you declare the variable in its
    scope. Let''s take a look at the given code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the best thing is that it can be used to avoid null checks. Earlier,
    you might have used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding code is good, it's not very suited for mutating properties.
    The alternative is to use `?.let` (`someVariable.?let{}`), which ensures that
    the code block runs when the variable is not null. However, what if we have multiple
    if-not-null chains? Let's see how to deal with those cases in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write code. You can use any IDE that is capable
    of executing the Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the mentioned steps to understand how to create a chain of multiple
    lets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have to do multiple null-checks, you can obviously use nested `if-else`,
    checking null conditions, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we know that the `let` function guarantees that the block will run only
    when the object is not-null, we need to create a function that will perform the
    function of `let` but on three variable scenarios. Let''s take a look at our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use it as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, it can be employed for two variable scenarios. You might
    be thinking how to do it in a multi-object scenario, like in the case of a list.
    Let''s create a `whenAllNotNull` function, which will run the block of code only
    when all the elements of the list are not null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Creating global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, we could create a global variable just by defining the variable at
    the beginning of class declaration and initializing it afterward. By just declaring
    it, we could use it as a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create and use a global variable in Kotin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ for coding purposes. You can use any IDE where you can
    write and execute Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to create global variables in Kotlin. There are two
    ways to do it. Let''s look at them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do it is by declaring it under the class declaration. We can use
    `var` declaration, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this approach will result in testing for nullability whenever you
    use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To prevent this, you can declare and initialize it using `val`, but that will
    result in an immutable variable, which might not be the desired behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to declare a global variable is by using the `lateinit` modifier.
    Here''s how the preceding code will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `lateinit` modifier is used to first declare the variable, without needing
    it to be defined either null or immutable. However, we need to initialize it before
    we use it; otherwise, it will throw an `UninitializedPropertyAccessException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `lateinit` modifier doesn't work with primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: '`lateinit` can also be useful when you try to initialize the variables using
    dependency injection. This way, you avoid null checks when referencing the property
    inside the body of a class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
