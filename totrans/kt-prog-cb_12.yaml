- en: Lambdas and Delegates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda和委托
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Click listeners using lambdas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda的点击监听器
- en: Using lazy delegate in Kotlin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中使用懒委托
- en: Using the observable delegate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可观察的委托
- en: Using vetoable delegate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可撤销的委托
- en: Writing your own delegates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的委托
- en: Using the lateinit modifier
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lateinit修饰符
- en: Working with SharedPreferences
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与SharedPreferences一起工作
- en: Creating a chain of multiple lets in Kotlin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中创建多个let的链
- en: Creating global variables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建全局变量
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will explore the functional aspects of Kotlin language.
    Kotlin has functional programming built in using lambdas. Java was lacking this
    modern language feature up until now, but it has included lambdas in Java 8\.
    However, since most of the Android devices don't support Java 8, Android developers
    were not able to use this feature. In this chapter, we will go through them and
    will also learn about delegates. Delegates are a powerful language feature of
    Kotlin. So let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Kotlin语言的函数式特性。Kotlin通过lambda表达式内置了函数式编程。Java直到现在都缺少这种现代语言特性，但Java
    8已经包含了lambda表达式。然而，由于大多数Android设备不支持Java 8，Android开发者无法使用这个特性。在本章中，我们将介绍这些内容，并学习关于委托的知识。委托是Kotlin的一个强大语言特性。那么，让我们开始吧！
- en: Click listeners using lambdas
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda的点击监听器
- en: An onclick listener in Android are one of those things that used to take up
    a lot of lines, even if the important portion of the code was only one line. Kotlin
    simplifies Android framework a lot, and one of the best improvements is `onClickListener`.
    In this recipe, we will see how we can simplify the traditional lengthy click
    listeners with the help of lambdas.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，onclick监听器是那些曾经占用大量行数的东西之一，即使代码的重要部分只有一行。Kotlin极大地简化了Android框架，其中最好的改进之一就是`onClickListener`。在本菜谱中，我们将看到如何通过lambda的帮助简化传统的长点击监听器。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by creating
    a new project in Kotlin with a blank activity in Android Studio 3+, as we won't
    be using any code from other recipes. You also need an intermediate understanding
    of Android development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。您可以在Android Studio 3+中创建一个新的Kotlin项目，并包含一个空白活动，因为我们不会使用其他菜谱中的任何代码。您还需要对Android开发有一个中级理解。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s follow the given steps to understand how to use click listener using
    lambdas:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照给定的步骤来了解如何使用lambda表达式来使用点击监听器：
- en: 'Let''s start with creating an activity with some view, such as a button on
    which we can attach an `onClickListener`. Check out the following XML layout for
    one possible activity layout:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个包含一些视图的活动开始，例如一个可以附加`onClickListener`的按钮。查看以下XML布局，这是一个可能的活动布局：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is how our layout looks, with three buttons on which we need
    to attach `onClickListener`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们布局的外观，其中包含三个需要附加`onClickListener`的按钮：
- en: '![](img/dccf397f-96e8-434c-baf3-37c3b3f64ad8.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dccf397f-96e8-434c-baf3-37c3b3f64ad8.jpeg)'
- en: 'Now, let''s see the code when we attach `onClickListener` to the three buttons
    in Java:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们在Java中为三个按钮附加`onClickListener`时的代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Did you note the amount of code we had to write just for attaching click listeners
    that show toasts? All this code for just three onclick listeners; now, let''s
    see the difference it makes to write the same code in Kotlin:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你注意到我们为了仅仅附加显示toast的点击监听器而必须编写的代码量吗？所有这些代码只是为了三个onclick监听器；现在，让我们看看在Kotlin中编写相同代码的差异：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code is certainly lesser and cleaner, thanks to Kotlin **synthetic properties**
    and **Anko** for toast helper function.  Now, let''s try to use **lambda** and
    see what difference it makes:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码确实更少、更整洁，这要归功于Kotlin的**合成属性**和**Anko**的toast辅助函数。现在，让我们尝试使用**lambda**并看看它带来的差异：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Whoa! All hail to the power of lambdas. Note how much code has been reduced,
    and it looks clean and more readable. This a large amount of boilerplate code
    reduction, which saves us both time and effort.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！向lambda的强大力量致敬。注意代码量减少了多少，看起来更整洁、更易读。这是一次大量的样板代码减少，这为我们节省了时间和精力。
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Lambda functions are functions that are not declared but passed as an expression.
    In Kotlin, if a function receives an interface, we can replace it with a lambda.
    For example, the `setOnClickListener` function receives `View.OnClickListener`,
    so we can use a lambda:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数是未声明但作为表达式传递的函数。在Kotlin中，如果一个函数接收一个接口，我们可以用lambda来替换它。例如，`setOnClickListener`函数接收`View.OnClickListener`，因此我们可以使用lambda：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, if there are no parameters to be passed to the lambda function, we can
    omit the arrow, and if the last parameter being passed is a function, we can move
    it outside the parentheses:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果没有参数要传递给 lambda 函数，我们可以省略箭头，如果最后一个传递的参数是函数，我们可以将其移出括号：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, if the lambda function being passed is actually the only parameter, you
    can omit the parentheses completely:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果传递给 lambda 函数的实际上是唯一参数，您可以完全省略括号：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more…
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can use **Anko**, a library by Kotlin to reduce the code even further. Anko
    provides an `onClick()` method that accepts a lambda that gets executed `onClick`
    event:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Kotlin 的库 **Anko** 进一步减少代码。Anko 提供了一个接受 lambda 表达式的方法，该表达式在 `onClick`
    事件发生时执行：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using lazy delegate in Kotlin
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中使用懒代理
- en: The lazy construct is basically used for lazy initialization of properties,
    which is especially helpful when the object being initialized is a heavy object
    (takes time to initialize). Instantiating heavy objects at startup can cause visible
    performance drop in mobile user experience. Lazy initialization can solve our
    problem. In this recipe, we will learn how to use Kotlin's lazy delegate, so let's
    get started!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载结构主要用于属性的懒初始化，这在初始化的对象是重对象（需要时间初始化）时尤其有用。在启动时实例化重对象可能会导致移动用户体验中的性能下降。懒初始化可以解决我们的问题。在这个菜谱中，我们将学习如何使用
    Kotlin 的懒代理，让我们开始吧！
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Android Studio 3.0 for coding, ensure that you have the latest
    version downloaded.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 3.0 进行编码，请确保您已下载最新版本。
- en: How to do it…
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we will learn how to use the lazy delegate in Kotlin:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何在 Kotlin 中使用懒代理：
- en: 'First, let''s see how to create a property through lazy initialization. The
    syntax is as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何通过懒初始化创建属性。语法如下：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While creating a lazy delegate, we use `by lazy`, as shown:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建懒代理时，我们使用 `by lazy`，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The lazy delegate initializes the object on its first access and stores the
    value, which is then returned for subsequent accesses.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 懒代理在第一次访问时初始化对象并存储值，然后对于后续访问返回该值。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The delegation of a property looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的委托看起来像这样：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The read operation calls the `getValue` method, and the write operation calls
    `setValue`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 读取操作调用 `getValue` 方法，而写入操作调用 `setValue`。
- en: 'There are three modes of evaluation of lazy properties:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 懒属性有三个评估模式：
- en: '`LazyThreadSafetyMode.SYNCHRONIZED`: Initialization occurs only on one thread.
    The rest of the threads see the cached value. It is also the default mode of initialization.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyThreadSafetyMode.SYNCHRONIZED`：初始化仅在单个线程上发生。其余线程看到缓存的值。这也是初始化的默认模式。'
- en: '`LazyThreadSafetyMode.PUBLICATION`: Used when synchronization of initialization
    delegate is not required. It can then be called from multiple threads at a time,
    and initialization can be performed on every thread. However, if initialization
    is done by one thread, it will be returned without performing initialization.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyThreadSafetyMode.PUBLICATION`：当不需要初始化代理的同步时使用。它可以从多个线程同时调用，并且可以在每个线程上执行初始化。然而，如果初始化由一个线程执行，它将返回而不执行初始化。'
- en: '`LazyThreadSafetyMode.NONE`: No locks are used to synchronize initialization
    and hence less overhead costs.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyThreadSafetyMode.NONE`：不使用锁来同步初始化，因此开销较小。'
- en: Using the observable delegate
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可观察的代理
- en: Previously, we saw how to work with delegated properties. In this recipe, we
    will learn how to work with the observable delegate. This delegate helps us observe
    any changes to the property. So let's get started.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何处理委托属性。在这个菜谱中，我们将学习如何处理可观察的代理。这个代理帮助我们观察属性中的任何变化。那么，让我们开始吧。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA for writing code. You can use any IDE where you
    are able to execute Kotlin code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 编写代码。您可以使用任何能够执行 Kotlin 代码的 IDE。
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The observable delegates take in a default value and a construct where we have
    old and new values. Let''s take a look at the next example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察的代理接受一个默认值和一个包含旧值和新值的结构。让我们看看下一个示例：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we have provided the initial value as an empty string.
    The construct will be executed every time we try to update the value of the `a`
    property. We have changed the value of `a` two times and hence we are seeing two
    print statements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将初始值提供为空字符串。每次我们尝试更新`a`属性的值时，都会执行该结构。我们已经更改了`a`的值两次，因此我们看到了两条打印语句。
- en: There's more…
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The observable delegate can be especially useful in the case of `RecyclerView`,
    because we can use `DiffUtils` to update just the items that are updated, rather
    than replacing the whole list with a new one. For more information, refer to the
    recipe in [Chapter 4](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e79a66d5-bec1-4560-b363-2489175de44b.xhtml), *Creating
    RecyclerView Adapter in Kotlin*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察的委托在`RecyclerView`的情况下特别有用，因为我们可以使用`DiffUtils`来更新仅更改的项目，而不是用新的列表替换整个列表。有关更多信息，请参阅[第4章](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e79a66d5-bec1-4560-b363-2489175de44b.xhtml)中的配方，*在Kotlin中创建RecyclerView适配器*。
- en: Using vetoable delegate
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可撤销委托
- en: '**Vetoable delegate** is quite similar to the observable delegate, with the
    only difference of vetoing the change. In the observable delegate, we could get
    hold of new and old values whenever the observable property was changed. Let''s
    take a look at the definition provided in Kotlin''s documentation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**可撤销委托**与可观察委托非常相似，唯一的区别是它拒绝更改。在可观察委托中，每当可观察属性更改时，我们都可以获取新值和旧值。让我们看看Kotlin文档中提供的定义：'
- en: '"Returns a property delegate for a read/write property that calls a specified
    callback function when changed, allowing the callback to veto the modification."'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '"返回一个读写属性委托，当属性更改时调用指定的回调函数，允许回调拒绝修改。"'
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for coding purposes. You can use any IDE capable
    of executing Kotlin code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用IntelliJ IDEA进行编码。您可以使用任何能够执行Kotlin代码的IDE。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s now look at the given steps to understand the `vetoable` modifier:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看给定的步骤来理解`vetoable`修饰符：
- en: 'Let''s take a quick look at an implementation of the `vetoable` delegated property:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速看一下`vetoable`委托属性的实现：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the modification is "vetoed" by the `vetoable` delegate since
    the age can't be greater than `25`. The new object will only be assigned if the
    age is less than `25`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，由于年龄不能大于`25`，修改被`vetoable`委托“拒绝”。只有当年龄小于`25`时，才会分配新对象。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s take a look at the vetoable delegated property declaration:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可撤销委托属性的声明：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `vetoable()` takes an initial value, which could be an empty list, and also
    an `onChange` callback, which is called before the change to a property is made.
    The callback returns true if the change is successful and false if it is vetoed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`vetoable()`接受一个初始值，这可以是一个空列表，还有一个`onChange`回调，它在更改属性之前被调用。如果更改成功，回调返回true；如果被拒绝，则返回false。'
- en: There's more…
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Vetoable can be especially useful if you use it in the `Recyclerview` adapter.
    Generally, you would assign data to the list directly and may call `notifyDatasetChanged`,
    but this is highly inefficient, as it will result in loading all the data again.
    We can use vetoable to check whether the content is the same by matching the old
    value and new value and can veto modification if it is the same. Also, we can
    use `DiffUtils` to just update the data that is changed. `DiffUtils` was introduced
    in Android support library 26.01 and later versions, and makes `RecyclerView`
    much more efficient.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`RecyclerView`适配器中使用可撤销委托，它特别有用。通常，你会直接将数据分配给列表，并可能调用`notifyDatasetChanged`，但这非常低效，因为它会导致重新加载所有数据。我们可以使用可撤销委托通过匹配旧值和新值来检查内容是否相同，并在内容相同的情况下拒绝修改。此外，我们可以使用`DiffUtils`仅更新更改的数据。`DiffUtils`是在Android支持库26.01及以后的版本中引入的，使`RecyclerView`更加高效。
- en: Writing your own delegates
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的委托
- en: Delegated properties are one of the best features of Kotlin language. We have
    already seen observable and vetoable delegates. In this recipe, we will learn
    how to create our own custom delegate. As a demo example, we will create a delegate
    property that can only be initialized once; if done again, it should throw an
    exception. So let's dive into it and see how we can achieve it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 委托属性是 Kotlin 语言中最好的特性之一。我们已经看到了可观察的和可撤销的委托。在这个菜谱中，我们将学习如何创建我们自己的自定义委托。作为一个演示示例，我们将创建一个只能初始化一次的委托属性；如果再次初始化，它应该抛出异常。那么让我们深入探讨一下，看看我们如何实现它。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA for coding purposes. You can use any IDE capable
    of executing Kotlin code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 进行编码。你可以使用任何能够执行 Kotlin 代码的 IDE。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Now, let''s dive in and learn how to create our own delegates:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨如何创建我们自己的委托：
- en: 'Let''s create a custom delegate named as  `SingleInitializationProperty`. This
    custom delegate property will throw an exception if the variable isn''t initialized,
    and it can only be initialized once. Doing it a second time will throw an exception.
    Let''s take a look at our custom delegate class:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `SingleInitializationProperty` 的自定义委托。这个自定义委托属性如果变量没有被初始化，将抛出异常，并且它只能初始化一次。如果再次初始化，它将抛出异常。让我们看看我们的自定义委托类：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, that we have created a custom delegate, let''s try to use it without initializing
    it in the following way:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个自定义委托，让我们尝试以下方式使用它而不进行初始化：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是输出结果：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s see another example; this time, we will first initialize it, then access
    it, and then again try to initialize it:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子；这次，我们将首先初始化它，然后访问它，然后再次尝试初始化它：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s the output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see, we have implemented the `ReadWriteProperty` interface in the
    delegated property, which basically means our variable will be of the `var` type.
    If you want it to be immutable, you can implement the `ReadOnlyProperty` interface.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在委托属性中实现了 `ReadWriteProperty` 接口，这意味着我们的变量将是 `var` 类型。如果你想使其不可变，你可以实现
    `ReadOnlyProperty` 接口。
- en: The `getValue` function takes a reference to a class and a property's metadata.
    The `setValue` function, in turn, receives a set value. In case of immutable property
    (`val`), there will be only one `getValue` function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValue` 函数接收一个类的引用和属性元数据。`setValue` 函数反过来接收一个设置的值。在不可变属性（`val`）的情况下，将只有一个
    `getValue` 函数。'
- en: Using the lateinit modifier
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `lateinit` 修饰符
- en: '**Lateinit** is an important initialization property, because if you don''t
    want to initialize your variable in constructor, `lazy` and `lateinit` can be
    employed to do so. In this recipe, we will see how to use the `lateinit` modifier
    and how it is different from the `lazy` modifier.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟初始化（Lateinit**）是一个重要的初始化属性，因为如果你不想在构造函数中初始化你的变量，可以使用 `lazy` 和 `lateinit`
    来实现。在这个菜谱中，我们将看到如何使用 `lateinit` 修饰符以及它与 `lazy` 修饰符的不同之处。'
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for the coding purpose; you can use any IDE that
    can execute Kotlin code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ IDEA 进行编码；你可以使用任何能够执行 Kotlin 代码的 IDE。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s follow the given steps to understand how the `lateinit` modifier works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照给定的步骤来理解 `lateinit` 修饰符是如何工作的：
- en: 'In Java, we could just declare a variable beforehand and initialize it later,
    but Kotlin requires you to initialize it as soon as you declare it (unless you
    are using special modifiers). So you can do the following:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 中，我们可以在声明变量后稍后初始化它，但 Kotlin 要求你在声明时立即初始化它（除非你使用特殊修饰符）。所以你可以这样做：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, you can do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以这样做：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Both ways have their drawbacks. The first way will require you to check nullability
    whenever you use it, and the second way of initializing will make it immutable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有它们的缺点。第一种方法要求你在使用时检查可空性，而第二种初始化方法将使其不可变。
- en: 'To overcome limitations, we can use a `lateinit` modifier, with which we can
    declare it beforehand and initialize anywhere we want (but before we first access
    it). This is especially needed when you use dependency injection. Let''s see an
    example from Kotlin documentation that uses the `lateinit` modifier to declare
    the variable:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了克服限制，我们可以使用 `lateinit` 修饰符，通过它可以先声明后在我们想要的地方（但在第一次访问之前）初始化。这在使用依赖注入时尤其需要。让我们看看
    Kotlin 文档中使用的 `lateinit` 修饰符来声明变量的例子：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you try to access the variable before initializing it, you will get `UninitializedPropertyAccessException`.
    If you are using dependency injection, here''s how you would use `lateinit` with
    it:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试在初始化之前访问变量，你会得到 `UninitializedPropertyAccessException`。如果你使用依赖注入，以下是使用
    `lateinit` 的方法：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's more…
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Another way of initializing properties is with the `lazy` modifier; `lazy()`
    is basically a function that takes a lambda and returns an instance of lazy, which
    serves as a delegate for implementing a lazy property. Let''s take a look at the
    next example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化属性的另一种方式是使用 `lazy` 修饰符；`lazy()` 基本上是一个接受 lambda 表达式并返回一个 lazy 实例的函数，该实例作为实现懒加载属性的代理。让我们看看下一个示例：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By `lazy` initialization, we postpone initialization until we first use it.
    The property is initialized only when we first access it, and the same value is
    returned for subsequent accesses. That's why it is mandatory to mark the variable
    immutable. This can really help us with initialization of heavy objects, which
    takes a lot of time. Initializing them `lazily` can improve our startup time.
    The only con is that you won't be able to modify it later since it is a `val`
    property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `lazy` 初始化，我们将初始化推迟到我们第一次使用它的时候。属性仅在第一次访问时初始化，并且对于后续的访问返回相同的值。这就是为什么必须标记变量为不可变的原因。这真的可以帮助我们初始化耗时较多的对象，这些对象需要花费很多时间。懒加载初始化可以提高我们的启动时间。唯一的缺点是，由于它是一个
    `val` 属性，你将无法稍后修改它。
- en: Working with SharedPreferences
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SharedPreferences
- en: '**SharedPreferences** is a persistent way of data storage in Android devices
    and is mostly used to save data in key-value pairs, such as the settings of an
    app. Kotlin makes it easier to work with shared preference using its unique language
    construct. In this recipe, we will see how Kotlin can help us deal with SharedPreferences
    easily. So let''s get started.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**SharedPreferences** 是 Android 设备上持久化数据存储的一种方式，通常用于以键值对的形式保存数据，例如应用程序的设置。Kotlin
    通过其独特的语言结构使与共享偏好设置一起工作变得更加容易。在这个菜谱中，我们将看到 Kotlin 如何帮助我们轻松地处理 SharedPreferences。所以让我们开始吧。'
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Android Studio 3.0 for this recipe. If you have an older version
    of Android Studio, either update it to 3.0 or configure Kotlin in it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个菜谱中使用 Android Studio 3.0。如果你有更早版本的 Android Studio，要么将其更新到 3.0，要么在其中配置
    Kotlin。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To be able to define and use SharedPreferences, we follow particular steps.
    We will go through each step and implement this together:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够定义和使用 SharedPreferences，我们需要遵循特定的步骤。我们将逐一介绍每个步骤，并一起实现：
- en: 'First, we will create a `Prefs` class that will act as a single entry to read/write
    from our app''s SharedPreferences. This will make it easier to handle all SharedPreferences
    since they all will be in one place. As we know, shared preference requires context
    to be present, so we will pass context in the primary constructor. We will also
    create a single SharedPreferences object that we will use throughout the class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `Prefs` 类，它将作为读取/写入我们应用程序 SharedPreferences 的单一入口。这将使处理所有 SharedPreferences
    变得更容易，因为它们都将在一个地方。正如我们所知，共享偏好设置需要上下文存在，所以我们将上下文传递给主构造函数。我们还将创建一个单一的 SharedPreferences
    对象，我们将在整个类中使用它：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For example, we have defined a `PREF_USERNAME` SharedPreferences; here, we
    will store the username of the user. Now the fun part begins; remember that Kotlin
    has a property where we can explicitly define how to get and set the property.
    We will use the same thing here. Let''s take a look at the given code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我们定义了一个 `PREF_USERNAME` SharedPreferences；在这里，我们将存储用户的用户名。现在有趣的部分开始了；记住 Kotlin
    有一个属性，我们可以显式地定义如何获取和设置该属性。我们在这里也会使用同样的方法。让我们看看给出的代码：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, in the setter, we are editing the shared preference and in the
    getter, we are extracting the value of the shared preference.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在设置器中，我们正在编辑共享偏好设置，在获取器中，我们正在提取共享偏好设置的值。
- en: 'Now that we have our `Prefs` class ready, we can use it in our activities,
    fragments, and so on. The best way to do it will be by defining it in the `Application`
    class and accessing is from many activities or fragments, because then we will
    not need to create multiple objects of the `Prefs` class. So let''s create an
    `Application` class and a singleton instance of the `Prefs` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了 `Prefs` 类，我们可以在我们的活动、片段等中使用它。最好的方法是在 `Application` 类中定义它，并从许多活动或片段中访问它，因为这样我们就不需要创建多个
    `Prefs` 类的对象。所以让我们创建一个 `Application` 类和一个 `Prefs` 类的单例实例：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have added and placed our `prefs` variable inside the companion object to
    be able to use it statically. Also, now that we have placed it inside the `Application`
    class, we will be dealing only with a single instance of the `prefs` object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `prefs` 变量添加到伴生对象中，以便能够静态地使用它。现在，由于我们将它放置在 `Application` 类中，我们只处理 `prefs`
    对象的单个实例。
- en: 'We can also use the `lazy` construct to ensure that we create an object only
    at its first access. Doing so will also help us avoid null checks. Here''s how
    our `App` class will look:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用 `lazy` 构造来确保我们只在第一次访问时创建对象。这样做也有助于我们避免空检查。下面是我们的 `App` 类将如何看起来：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s now look at an example to add a value to our SharedPreferences:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来看一个例子，向我们的 SharedPreferences 添加一个值：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It looks so simple to work with shared preferences now, as if we are assigning
    values to a variable. Accessing them is also very easy:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用共享偏好设置看起来非常简单，就像我们正在给变量赋值一样。访问它们也非常容易：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's more…
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, we have used the `apply()` method to save preferences, which
    commits the changes in the in-memory SharedPreferences immediately, but also starts
    an asynchronous commit to the disk; `commit()`, on the other hand, writes to persistent
    storage synchronously.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了 `apply()` 方法来保存偏好设置，这立即提交了内存中 SharedPreferences 的更改，同时也启动了对磁盘的异步提交；另一方面，`commit()`
    方法则是同步写入持久存储。
- en: Creating a chain of multiple lets in Kotlin
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中创建多个 `let` 的链
- en: '`let` is a pretty useful function provided by Kotlin''s `Standard.kt` library.
    It is basically a scoping function that allows you declare the variable in its
    scope. Let''s take a look at the given code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 是 Kotlin 的 `Standard.kt` 库提供的一个非常有用的函数。它基本上是一个作用域函数，允许你在其作用域内声明变量。让我们看看下面的代码：'
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, the best thing is that it can be used to avoid null checks. Earlier,
    you might have used the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好的是它可以用来避免空检查。之前，你可能使用以下方法：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While the preceding code is good, it's not very suited for mutating properties.
    The alternative is to use `?.let` (`someVariable.?let{}`), which ensures that
    the code block runs when the variable is not null. However, what if we have multiple
    if-not-null chains? Let's see how to deal with those cases in this recipe.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的代码是好的，但它并不非常适合用于修改属性。另一种选择是使用 `?.let` (`someVariable.?let{}`)，这确保了当变量不为
    null 时代码块会运行。然而，如果我们有多个非空链，我们应该如何处理这些情况呢？让我们看看在这个菜谱中如何处理这些情况。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write code. You can use any IDE that is capable
    of executing the Kotlin code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 来编写代码。你可以使用任何能够执行 Kotlin 代码的 IDE。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the mentioned steps to understand how to create a chain of multiple
    lets:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按照提到的步骤了解如何创建多个 `let` 的链：
- en: 'When you have to do multiple null-checks, you can obviously use nested `if-else`,
    checking null conditions, as in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要进行多次空检查时，你可以显然使用嵌套的 `if-else`，检查空条件，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we know that the `let` function guarantees that the block will run only
    when the object is not-null, we need to create a function that will perform the
    function of `let` but on three variable scenarios. Let''s take a look at our function:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道 `let` 函数保证只有在对象不为 null 时才会运行代码块，我们需要创建一个函数来执行 `let` 的功能，但适用于三个变量场景。让我们看看我们的函数：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can use it as illustrated:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像下面这样使用它：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In a similar way, it can be employed for two variable scenarios. You might
    be thinking how to do it in a multi-object scenario, like in the case of a list.
    Let''s create a `whenAllNotNull` function, which will run the block of code only
    when all the elements of the list are not null:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，它也可以用于两个变量场景。你可能想知道如何在多对象场景中实现，比如在列表的情况下。让我们创建一个 `whenAllNotNull` 函数，它只会在列表的所有元素都不为
    null 时运行代码块：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating global variables
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建全局变量
- en: In Java, we could create a global variable just by defining the variable at
    the beginning of class declaration and initializing it afterward. By just declaring
    it, we could use it as a global variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，我们只需在类声明的开头定义变量并在之后初始化它，就可以创建一个全局变量。通过仅仅声明它，我们就可以将其用作全局变量。
- en: In this recipe, we will learn how to create and use a global variable in Kotin.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在 Kotlin 中创建和使用全局变量。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ for coding purposes. You can use any IDE where you can
    write and execute Kotlin code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 IntelliJ 进行编码。你可以使用任何可以编写和执行 Kotlin 代码的 IDE。
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now, let''s look at how to create global variables in Kotlin. There are two
    ways to do it. Let''s look at them one by one:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 Kotlin 中创建全局变量。有两种方法可以实现，让我们逐一来看：
- en: 'One way to do it is by declaring it under the class declaration. We can use
    `var` declaration, like this:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种实现方式是在类声明下声明它。我们可以使用 `var` 声明，如下所示：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, this approach will result in testing for nullability whenever you
    use it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法会在每次使用时都进行空值检查：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To prevent this, you can declare and initialize it using `val`, but that will
    result in an immutable variable, which might not be the desired behavior.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止这种情况，你可以使用 `val` 声明并初始化它，但这将导致变量不可变，这可能不是期望的行为。
- en: 'Another way to declare a global variable is by using the `lateinit` modifier.
    Here''s how the preceding code will look:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种声明全局变量的方式是使用 `lateinit` 修饰符。以下是前面代码的修改方式：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `lateinit` modifier is used to first declare the variable, without needing
    it to be defined either null or immutable. However, we need to initialize it before
    we use it; otherwise, it will throw an `UninitializedPropertyAccessException`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lateinit` 修饰符用于首先声明变量，无需将其定义为 null 或不可变。然而，在使用它之前我们需要对其进行初始化；否则，它将抛出 `UninitializedPropertyAccessException`
    异常。'
- en: The `lateinit` modifier doesn't work with primitive types.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`lateinit` 修饰符不适用于原始类型。'
- en: '`lateinit` can also be useful when you try to initialize the variables using
    dependency injection. This way, you avoid null checks when referencing the property
    inside the body of a class.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你尝试使用依赖注入初始化变量时，`lateinit` 也可以很有用。这样，你可以在类体内部引用属性时避免进行空值检查。
