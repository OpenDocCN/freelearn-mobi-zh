<html><head></head><body>
        

                            
                    <h1 class="header-title">Location and Using Geofencing</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to get the device location</li>
<li>Resolving problems reported with the <kbd>GoogleApiClient</kbd> <kbd>OnConnectionFailedListener</kbd></li>
<li>Creating and monitoring a Geofence</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Location awareness offers many benefits to an app, so many in fact that even desktop apps now attempt to get the user's location. Location uses ranges from turn-by-turn directions, "find the nearest" applications, alerts based on location, and there are now even location-based games that get you out exploring with your device.</p>
<p>The Google APIs offer many rich features for creating location-aware applications and mapping features. Our first recipe will look at obtaining the last known location on the device along with receiving updates as the location changes. If you are requesting location updates for a proximity location, take a look at using the Geofence option instead in the <em>Create and monitor a Geofence</em> recipe.</p>
<p>All the recipes in this chapter use the Google Libraries. If you have not already downloaded the SDK Packages, follow the instructions from Google.</p>
<p>Add SDK Packages from <a href="http://developer.android.com/sdk/installing/adding-packages.html">http://developer.android.com/sdk/installing/adding-packages.html</a>.</p>
<p>Now that you have the location, there's a good chance you'll want to map it as well. This is another area where Google makes this very easy on Android using the Google Maps API. When working with Google Maps, take a look at the Google Maps Activity option when creating a new project in Android Studio. Instead of selecting Empty Activity, as we normally do for these recipes, choose Google Maps Activity, as shown in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b640cd9c-d765-4293-b587-5bea1f5c7110.png" style="width:39.50em;height:49.33em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to get the device location</h1>
                
            
            
                
<p>This first recipe will show you how to get the last known location. If you've worked with the Google Location APIs in the past, then you may notice things have changed. This recipe shows you the latest API for getting both the last location and updates as the location changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>GetLocation</kbd>. Use the default Phone &amp; Tablet options, and select Empty Activity when prompted for Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we'll add the necessary permissions to the Android Manifest, then we'll modify the <kbd>TextView</kbd> element to include an ID. Finally, we'll add a method to receive the last known location callback. Open the Android Manifest and follow these steps:</p>
<ol>
<li>Add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;</pre>
<ol start="2">
<li>Under the Gradle Scripts section, open the build.gradle (Module: app) file, as shown in this screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0007bab5-d893-4324-9909-477d610f6440.png" style="width:28.58em;height:22.33em;"/></p>
<ol start="3">
<li>Add the following statement to the <kbd>dependencies</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">implementation 'com.google.android.gms:play-services:12.0.1'</pre>
<ol start="4">
<li>Open <kbd>activity_main.xml</kbd> and update the existing <kbd>TextView</kbd> with the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextView<br/>    android:id="@+id/textView"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintEnd_toEndOf="parent"<br/>    app:layout_constraintStart_toStartOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="5">
<li>Add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">if (ActivityCompat.checkSelfPermission(this, ACCESS_COARSE_LOCATION)<br/>        == PackageManager.PERMISSION_GRANTED) {<br/>    getLocation();<br/>} else {<br/>    ActivityCompat.requestPermissions(this, new String[] {ACCESS_COARSE_LOCATION},1);<br/>}</pre>
<p style="padding-left: 60px">6. Create the <kbd>getLocation()</kbd> method as follows:</p>
<pre style="padding-left: 60px">private void getLocation() throws SecurityException {<br/>    LocationServices.getFusedLocationProviderClient(this).getLastLocation()<br/>            .addOnSuccessListener(this, new OnSuccessListener&lt;Location&gt;() {<br/>                @Override<br/>                public void onSuccess(Location location) {<br/>                    final TextView textView = findViewById(R.id.textView);<br/>                    if (location != null) {<br/>                        textView.setText(DateFormat.getTimeInstance()<br/>                                .format(location.getTime()) + "\n"<br/>                                + "Latitude=" + location.getLatitude() + "\n"<br/>                                + "Longitude=" + location.getLongitude());<br/>                    } else {<br/>                        Toast.makeText(MainActivity.this, "Location null", Toast.LENGTH_LONG)<br/>                                .show();<br/>                    }<br/>                }<br/>            });<br/>}</pre>
<p style="padding-left: 60px">7. You're ready to run the application on a device or emulator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This code example uses the latest version (12.0.1, as of this writing) of the Google Play service's <kbd>getLastLocation()</kbd> method. If you've ever used it in the past, you may notice significant changes in how this API works. It's actually much simpler now as all we have to do is call the <kbd>getFusedLocationProviderClient()</kbd> and pass our listener. Make sure we check the location in the callback to make sure it's not null. (There are several scenarios that can result in a null location, such as the device not having a location yet, the user disabled the location feature, and factory reset.)</p>
<p>The accuracy of the location object we receive is based on our permission setting. We used <kbd>ACCESS_COARSE_LOCATION</kbd>, but if we want higher accuracy, we can request <kbd>ACCESS_FINE_LOCATION</kbd> instead, with the following permission:</p>
<pre>&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;</pre>
<p>Make sure to check for the appropriate permission in the <kbd>checkSelfPermission()</kbd> call.</p>
<p>Lastly, to keep the code focused on the Location feature, we just do a simple permission check. In a production application, you should check and request permission as shown in <em>The Android 6.0 Runtime Permission Model</em> recipe in <a href="98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml">Chapter 15</a>, <em>Getting Your App Ready for the Play Store.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Testing the location can be a challenge since it's difficult to actually move the device when testing and debugging. Fortunately, we have the ability to simulate GPS data with the emulator. (It is possible to create mock locations on a physical device as well, but that's not as easy.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mock locations</h1>
                
            
            
                
<p>There are several ways to simulate locations with the emulator:</p>
<ul>
<li>Location setting through the emulator</li>
<li>The <kbd>Geo</kbd> command through the ADB shell</li>
</ul>
<p>To set a mock location in the emulator, follow these steps:</p>
<ol>
<li>Click the more options button (the one with ... at the bottom of the emulator control options)</li>
<li>Select the Location tab in the device window</li>
<li>Enter the GPS coordinates in the Longitude and Latitude boxes</li>
</ol>
<p>Here's a screenshot showing the Location tab:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f876152f-a34e-4e64-9d68-84f1bb91267f.png"/></p>
<p>Note that simulating the location works by sending GPS data. Therefore, for your app to receive the mock location, it will need to be receiving GPS data. Testing <kbd>lastLocation()</kbd> may not send the mock GPS data since it doesn't rely solely on the GPS for determining the device location. Try the mock location with the <em>How to get the device location</em> recipe where we can request the priority. (We can't force the system to use any specific location sensor, we can only make a request. The system will choose the optimum solution to deliver the results.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><em>The new Android 6.0 run-time permission model</em> recipe in <a href="98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml">Chapter 15</a>, <em>Getting Your App Ready for the Play Store</em></li>
<li>Setting up Google Play Services: <a href="https://developers.google.com/android/guides/setup">https://developers.google.com/android/guides/setup</a></li>
<li>The FusedLocationProviderClient interface: <a href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient">https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Resolving problems reported with the GoogleApiClient OnConnectionFailedListener</h1>
                
            
            
                
<p>With the constantly changing nature of Google APIs, your users are likely to attempt to use your application, but not be able to because their files are out of date. We can use the <kbd>GoogleApiAvailability</kbd> library to display a dialog to help the user resolve the problem.</p>
<p>We'll continue with the previous recipe and add code to the <kbd>onConnectionFailed()</kbd> callback. We'll use the error result to display additional information to the user to resolve their problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>HandleGoogleAPIError</kbd>. Use the default Phone &amp; Tablet options, and select Empty Activity when prompted for Activity Type. Once you've created the project, add the Google Play library reference to the project dependencies. (See the previous recipe steps.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The first step for this recipe is to add the Google Play Services library to the project. From there, we'll create the classes to handle the Google Client callbacks and use toasts to give feedback. To start, open the build.gradle (Module: app) file and follow these steps (if you're not sure which file to open, see the screenshot in the previous recipe steps):</p>
<ol>
<li>Add the following statement to the <kbd>dependencies</kbd> section:</li>
</ol>
<ol start="3"/>
<pre style="padding-left: 60px">implementation 'com.google.android.gms:play-services:12.0.1'</pre>
<ol start="2">
<li>Open <kbd>ActivityMain.java</kbd> and add the following lines to the global class variables:</li>
</ol>
<pre style="padding-left: 60px">private final int REQUEST_RESOLVE_GOOGLE_CLIENT_ERROR=1;<br/>boolean mResolvingError;<br/>GoogleApiClient mGoogleApiClient;</pre>
<p class="mce-root"/>
<ol start="3">
<li>Add the following two classes to handle the callbacks:</li>
</ol>
<pre style="padding-left: 60px">GoogleApiClient.ConnectionCallbacks mConnectionCallbacks =<br/>        new GoogleApiClient.ConnectionCallbacks() {<br/>    @Override<br/>    public void onConnected(Bundle bundle) {<br/>        Toast.makeText(MainActivity.this, "onConnected()", Toast.LENGTH_LONG).show();<br/>    }<br/>    @Override<br/>    public void onConnectionSuspended(int i) {}<br/>};<br/><br/>GoogleApiClient.OnConnectionFailedListener mOnConnectionFailedListener = <br/>        new GoogleApiClient.OnConnectionFailedListener() {<br/>    @Override<br/>    public void onConnectionFailed(ConnectionResult connectionResult) {<br/>        Toast.makeText(MainActivity.this, connectionResult.toString(), Toast.LENGTH_LONG).show();<br/>        if (mResolvingError) {<br/>            return;<br/>        } else if (connectionResult.hasResolution()) {<br/>            mResolvingError = true;<br/>            try {<br/>                connectionResult.startResolutionForResult(MainActivity.this, <br/>                        REQUEST_RESOLVE_GOOGLE_CLIENT_ERROR);<br/>            } catch (IntentSender.SendIntentException e) {<br/>                mGoogleApiClient.connect();<br/>            }<br/>        } else {<br/>            showGoogleAPIErrorDialog(connectionResult.getErrorCode());<br/>        }<br/>    }<br/>};</pre>
<ol start="4">
<li class="mce-root">Add the following method to the MainActivity class to show the Google API error dialog:</li>
</ol>
<pre style="padding-left: 60px">private void showGoogleAPIErrorDialog(int errorCode) {<br/>    GoogleApiAvailability googleApiAvailability = GoogleApiAvailability.getInstance();<br/>    Dialog errorDialog = googleApiAvailability.getErrorDialog(<br/>            this, errorCode, REQUEST_RESOLVE_GOOGLE_CLIENT_ERROR);<br/>    errorDialog.show();<br/>}</pre>
<ol start="5">
<li>Add the following code to override <kbd>onActivityResult()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onActivityResult(int requestCode, int resultCode, Intent data) {<br/>    if (requestCode == REQUEST_RESOLVE_GOOGLE_CLIENT_ERROR) {<br/>        mResolvingError = false;<br/>        if (resultCode == RESULT_OK<br/>                &amp;&amp; !mGoogleApiClient.isConnecting()<br/>                &amp;&amp; !mGoogleApiClient.isConnected()) {<br/>            mGoogleApiClient.connect();<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>Add the following method to set up the <kbd>GoogleApiClient</kbd>: </li>
</ol>
<pre style="padding-left: 60px">protected void setupGoogleApiClient() {<br/>    mGoogleApiClient = new GoogleApiClient.Builder(this)<br/>            .addConnectionCallbacks(mConnectionCallbacks)<br/>            .addOnConnectionFailedListener(mOnConnectionFailedListener)<br/>            .addApi(LocationServices.API)<br/>            .build();<br/>    mGoogleApiClient.connect();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="7">
<li>Finally, add this line of code to the end of the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">setupGoogleApiClient();</pre>
<ol start="8">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Most of the code here is standard setup for the <kbd>GoogleApiClient</kbd> with the main addition of setting up the <kbd>OnConnectionFailedListener</kbd> callback. This is where the app goes from simply failing, to actually helping the end user get it working. Fortunately for us, Google does most of the work for us by checking the conditions that are causing it to fail, as well as presenting the UI to the user. We just have to make sure to check the status Google reports back to us.</p>
<p>The <kbd>GoogleAPIClient</kbd> uses the <kbd>connectionResult</kbd> to indicate possible courses of action. We can call the <kbd>hasResolution()</kbd> method, as follows:</p>
<pre>connectionResult.hasResolution() </pre>
<p>If the response is <kbd>true</kbd>, then it's something the user can resolve, such as enabling the location service. If the response is <kbd>false</kbd>, we get an instance of the <kbd>GoogleApiAvailability</kbd> and call the <kbd>getErrorDialog()</kbd> method. When finished, our <kbd>onActivityResult()</kbd> callback is called, where we reset <kbd>mResolvingError</kbd> and, if successful, attempt to reconnect.</p>
<p>If you do not have a device with an older Google API for testing, you can try testing on an emulator with an older Google API version.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If your application is using fragments, you can get a dialog fragment instead, using this code:</p>
<pre>ErrorDialogFragment errorFragment = new ErrorDialogFragment(); 
Bundle args = new Bundle(); 
args.putInt("dialog_error", errorCode); 
errorFragment.setArguments(args); 
errorFragment.show(getSupportFragmentManager(), "errordialog"); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Accessing Google APIs: <a href="https://developers.google.com/android/guides/api-client">https://developers.google.com/android/guides/api-client</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and monitoring a Geofence</h1>
                
            
            
                
<p>If your application needs to know when the user enters or exits a certain location, there's an alternative to continuously checking the user location: Geofencing. A Geofence is a location (latitude and longitude) along with a radius. You can create a Geofence and let the system notify you when the user enters the location proximity you specified. (Android currently allows up to 100 Geofences per user.)</p>
<p>Geofence properties include:</p>
<ul>
<li><strong>Location</strong>: The longitude and latitude</li>
<li><strong>Radius</strong>: The size of the circle (in meters)</li>
<li>Loitering delay: How long the user may remain within the radius before sending notifications</li>
<li><strong>Expiration</strong>: How long until the Geofence automatically expires</li>
<li><strong>Transition</strong> <strong>type</strong>:
<ul>
<li><kbd>GEOFENCE_TRANSITION_ENTER</kbd></li>
<li><kbd>GEOFENCE_TRANSITION_EXIT</kbd></li>
<li><kbd>INITIAL_TRIGGER_DWELL</kbd></li>
</ul>
</li>
</ul>
<p>This recipe will show you how to create a Geofence object and use it to create an instance of <kbd>GeofencingRequest</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>Geofence</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We won't need a layout for this recipe as we'll use Toasts and Notifications for the user interaction. We will need to create an additional Java class for <kbd>IntentService</kbd>, which handles the Geofence alerts. Open the Android Manifest and follow these steps:</p>
<ol>
<li>Add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;</pre>
<ol start="2">
<li>Open the <kbd>build.gradle (Module: app)</kbd> file and add the following statement to the <kbd>dependencies</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">implementation 'com.google.android.gms:play-services:12.0.1'</pre>
<ol start="3">
<li>Create a new Java class called <kbd>GeofenceIntentService</kbd> and extend the <kbd>IntentService</kbd> class. The declaration will look as follows:</li>
</ol>
<pre style="padding-left: 60px">public class GeofenceIntentService extends IntentService { </pre>
<ol start="4">
<li>Add the following constructor:</li>
</ol>
<pre style="padding-left: 60px">public GeofenceIntentService() { 
    super("GeofenceIntentService"); 
} </pre>
<ol start="5">
<li>Add <kbd>onHandleIntent()</kbd> to receive the Geofence alert:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onHandleIntent(Intent intent) {<br/>    GeofencingEvent geofencingEvent = GeofencingEvent.fromIntent(intent);<br/>    if (geofencingEvent.hasError()) {<br/>        Toast.makeText(getApplicationContext(), "Geofence error code= "<br/>                        + geofencingEvent.getErrorCode(), Toast.LENGTH_SHORT).show();<br/>        return;<br/>    }<br/>    int geofenceTransition = geofencingEvent.getGeofenceTransition();<br/>    if (geofenceTransition == Geofence.GEOFENCE_TRANSITION_DWELL) {<br/>        Toast.makeText(getApplicationContext(), "GEOFENCE_TRANSITION_DWELL",<br/>                Toast.LENGTH_SHORT).show();<br/>    }<br/>}</pre>
<ol start="6">
<li>Open the Android manifest and add the following within the <kbd>&lt;application&gt;</kbd> element, at the same level as the <kbd>&lt;activity&gt;</kbd> element:</li>
</ol>
<pre style="padding-left: 60px">&lt;service android:name=".GeofenceIntentService"/&gt; </pre>
<ol start="7">
<li> Open <kbd>MainActivity.java</kbd> and add the following global variable:</li>
</ol>
<pre style="padding-left: 60px">private final int MINIMUM_RECOMENDED_RADIUS=100;</pre>
<ol start="8">
<li>Create a <kbd>PendingIntent</kbd> with the following method:</li>
</ol>
<pre style="padding-left: 60px">private PendingIntent createGeofencePendingIntent() {<br/>    Intent intent = new Intent(this, GeofenceIntentService.class);<br/>    return PendingIntent.getService(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);<br/>}</pre>
<ol start="9">
<li>Create the Geofence item with the following method:</li>
</ol>
<pre style="padding-left: 60px">private List createGeofenceList() {<br/>    List&lt;Geofence&gt; geofenceList = new ArrayList&lt;&gt;();<br/>    geofenceList.add(new Geofence.Builder()<br/>            .setRequestId("GeofenceLocation")<br/>            .setCircularRegion(<br/>                    47.6062,  //Latitude<br/>                    122.3321, //Longitude<br/>                    MINIMUM_RECOMENDED_RADIUS)<br/>            .setLoiteringDelay(30000)<br/>            .setExpirationDuration(Geofence.NEVER_EXPIRE)<br/>            .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_DWELL)<br/>            .build());<br/>    return geofenceList;<br/>}</pre>
<ol start="10">
<li>Create the Geofence Request with the following method:</li>
</ol>
<pre style="padding-left: 60px">private GeofencingRequest createGeofencingRequest() {<br/>    GeofencingRequest.Builder builder = new GeofencingRequest.Builder();<br/>    builder.setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_DWELL);<br/>    builder.addGeofences(createGeofenceList());<br/>    return builder.build();<br/>}</pre>
<ol start="11">
<li> Add the following code to the existing <kbd>onCreate()</kbd> callback:</li>
</ol>
<pre style="padding-left: 60px">if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {<br/>    GeofencingClient geofencingClient = LocationServices.getGeofencingClient(this);<br/>    geofencingClient.addGeofences(createGeofencingRequest(), createGeofencePendingIntent())<br/>            .addOnSuccessListener(this, new OnSuccessListener&lt;Void&gt;() {<br/>                @Override<br/>                public void onSuccess(Void aVoid) {<br/>                    Toast.makeText(MainActivity.this, "onSuccess()", Toast.LENGTH_SHORT).show();<br/>                }<br/>            })<br/>            .addOnFailureListener(this, new OnFailureListener() {<br/>                @Override<br/>                public void onFailure(@NonNull Exception e) {<br/>                    Toast.makeText(MainActivity.this,<br/>                            "onFailure(): " + e.getMessage(), Toast.LENGTH_SHORT).show();<br/>                }<br/>            });<br/>} else {<br/>    ActivityCompat.requestPermissions(this, <br/>            new String[] {android.Manifest.permission.ACCESS_FINE_LOCATION},1);<br/>}</pre>
<ol start="12">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, we add <kbd>ACCESS_FINE_LOCATION</kbd> permission as this is required for Geofencing.</p>
<p>Before we can call the <kbd>GeofencingApi.addGeofences()</kbd> method, we have to prepare two objects:</p>
<ul>
<li>Geofence Request</li>
<li>Geofence Pending Intent</li>
</ul>
<p>To create the Geofence Request, we use the <kbd>GeofencingRequest.Builder</kbd>. The builder requires the list of Geofence objects, which are created in the <kbd>createGeofenceList()</kbd> method. (Even though we are only creating a single Geofence object, the builder requires a list, so we just add our single Geofence to an <kbd>ArrayList</kbd>.) Here is where we set the Geofence properties:</p>
<pre>.setRequestId("GeofenceLocation")<br/>.setCircularRegion(<br/>        47.6062,  //Latitude<br/>        122.3321, //Longitude<br/>        MINIMUM_RECOMENDED_RADIUS)<br/>.setLoiteringDelay(30000)<br/>.setExpirationDuration(Geofence.NEVER_EXPIRE)<br/>.setTransitionTypes(Geofence.GEOFENCE_TRANSITION_DWELL)</pre>
<p>Only the Loitering delay is optional, but we need it since we are using the <kbd>DWELL</kbd> transition. When calling <kbd>setTransitionTypes()</kbd>, we can combine multiple transition types using the <kbd>OR</kbd> operator (using the pipe character). Here's an example using <kbd>ENTER</kbd> and <kbd>EXIT</kbd> instead:</p>
<pre>.setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER | Geofence.GEOFENCE_TRANSITION_EXIT)</pre>
<p>For this example, we used the same default latitude and longitude as the emulator. Change these values as needed.</p>
<p>Our call to <kbd>Geofence.Builder()</kbd> creates the Geofence object. With the Geofence list ready, we call the <kbd>GeofencingRequest.Builder</kbd> and set our initial trigger to <kbd>INITIAL_TRIGGER_DWELL</kbd>. (If you change the preceding transition types, you may want to change the initial trigger as well or the creation of our Geofence may fail.)</p>
<p>The second object we need is a Pending Intent, which is how the system will notify our app when the Geofence criteria are met. (Strictly speaking, the Intent service is not required and if your app will only be monitoring Geofence responses while in the foreground, you may not even need it.) Our example displays a toast in response to the Geofence trigger, but this is where you would customize the response for your app.</p>
<p>With both objects created, we get a reference to <kbd>GeofencingClient</kbd> after checking for the proper permission. Our example only checks for the necessary permission so you need to manually enable location permission through the app settings. A production app should prompt the user as needed. (See <em>The Android 6.0 Runtime Permission Model</em> recipe in <a href="98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml" target="_blank">Chapter 15</a>, <em>Getting Your App Ready for the Play Store</em> for a complete example.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>To stop receiving Geofence notifications, you can call the <kbd>removeGeofences()</kbd> method with either the <kbd>RequestID</kbd> parameter or <kbd>PendingIntent</kbd>. The following example uses the same <kbd>PendingIntent</kbd> method we used for the notification:</p>
<pre>geofencingClient.removeGeofences(createGeofencePendingIntent())<br/>        .addOnSuccessListener(this, new OnSuccessListener&lt;Void&gt;() {<br/>            @Override<br/>            public void onSuccess(Void aVoid) {<br/>                //Success<br/>            }<br/>        })<br/>        .addOnFailureListener(this, new OnFailureListener() {<br/>            @Override<br/>            public void onFailure(@NonNull Exception e) {<br/>                //Failuare<br/>            }<br/>        });</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <kbd>GeofencingClient</kbd> class at: <a href="https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingClient">https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingClient</a></li>
<li>The <kbd>Geofence.Builder</kbd> class at: <a href="https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html">https://developers.google.com/android/reference/com/google/android/gms/location/Geofence.Builder.html</a></li>
<li>The <kbd>GeofencingRequest.Builder</kbd> class at: <a href="https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder">https://developers.google.com/android/reference/com/google/android/gms/location/GeofencingRequest.Builder</a></li>
</ul>


            

            
        
    </body></html>