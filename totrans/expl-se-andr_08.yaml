- en: Chapter 8. Applying Contexts to Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：将上下文应用于文件
- en: 'In the last chapter, we upgraded our system, collected the audit logs, and
    started to analyze the audit records. We discovered that some objects on the filesystem
    were unlabeled. In this chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们升级了系统，收集了审计日志，并开始分析审计记录。我们发现文件系统上的一些对象未标记。在本章中，我们将：
- en: Learn how filesystems and filesystem objects get their labels
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习文件系统和文件系统对象如何获得标签
- en: Demonstrate techniques to change labels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示更改标签的技术
- en: Introduce extended attributes for labeling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍用于标记的扩展属性
- en: Investigate file contexts and dynamic type transitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查文件上下文和动态类型转换
- en: Labeling filesystems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记文件系统
- en: Filesystems on Linux originate from mount, with the exception of `ramdisk rootfs`
    on Android. Filesystems on Linux vary drastically. In general, in order to support
    all the features of SELinux, you need a filesystem with the support for `xattr`
    and the `security` namespace. We saw this requirement when we were setting up
    the kernel configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的文件系统起源于挂载，除了Android上的 `ramdisk rootfs`。Linux上的文件系统差异很大。一般来说，为了支持SELinux的所有功能，你需要一个支持
    `xattr` 和 `security` 命名空间的文件系统。我们在设置内核配置时看到了这个需求。
- en: Filesystem objects, as they are created, all start with an initial context,
    just like all other kernel objects. Contexts on files simply inherit from their
    parent, so if the parent is unlabeled, then the child is unlabeled, with the exception
    of a type transition rule. Typically, if the context is unlabeled, it infers that
    the data was created on a filesystem prior to enabling SELinux support, or the
    type label in the `xattr` does not exist in the currently loaded policy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统对象在创建时，都从一个初始上下文开始，就像所有其他内核对象一样。文件上下文简单地从其父对象继承，所以如果父对象未标记，则子对象未标记，除非有类型转换规则。通常，如果上下文未标记，则推断数据是在启用SELinux支持之前在文件系统上创建的，或者
    `xattr` 中的类型标签在当前加载的策略中不存在。
- en: 'The initial label or initial **security id** (**sid**), is in the `sepolicy`
    file `initial_sid_contexts`. Each object class has its associated initial `sid`
    present. For example, let''s take a look at the following code snippet:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 初始标签或初始**安全ID**（**sid**），位于 `sepolicy` 文件中的 `initial_sid_contexts`。每个对象类都有一个关联的初始
    `sid`。例如，让我们看一下以下代码片段：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: fs_use
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs_use
- en: 'Filesystems can be labeled in a variety of ways. The best case scenario is
    when the filesystem supports `xattrs`. In that case, an `fs_use_xattr` statement
    should appear in the policy. These statements appear in the `fs_use` file in the
    `sepolicy` directory. The syntax for `fs_use_xattr` is:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统可以通过多种方式进行标记。最佳情况是当文件系统支持 `xattrs`。在这种情况下，策略中应该出现一个 `fs_use_xattr` 语句。这些语句出现在
    `sepolicy` 目录下的 `fs_use` 文件中。`fs_use_xattr` 的语法如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To look at `fs_use` from `sepolicy`, we can refer to an example for the `ext4`
    filesystems:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `sepolicy` 视角来看 `fs_use`，我们可以参考 `ext4` 文件系统的示例：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This tells SELinux that when it encounters an `ext4` `fs` object; look in the
    extended attributes for the label or file context.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉SELinux，当它遇到 `ext4` `fs` 对象时，在扩展属性中查找标签或文件上下文。
- en: fs_task_use
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs_task_use
- en: 'The other way a filesystem can be labeled is by using the process'' context
    while creating objects. This makes sense for pseudo filesystems where the objects
    are really process contexts, such as `pipefs` and `sockfs`. These pseudo filesystems
    manage the pipe and socket syscalls and are not really mounted to userspace. They
    exist internally to the kernel, for the kernels use. However, they do have objects,
    and like any other object, they need to be labeled. This is the context in which
    the `fs_task_use` policy statement makes sense. These internal filesystems can
    only be accessed by processes directly, and provide services to those processes.
    Hence, labeling them with the creator makes sense. The syntax is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统还可以通过在创建对象时使用进程的上下文来进行标记。这对于伪文件系统来说是有意义的，其中对象实际上是进程上下文，例如 `pipefs` 和 `sockfs`。这些伪文件系统管理管道和套接字系统调用，实际上并没有挂载到用户空间。它们存在于内核内部，为内核使用。然而，它们确实有对象，就像任何其他对象一样，它们需要被标记。这就是
    `fs_task_use` 策略语句有意义的上下文。这些内部文件系统只能由直接访问它们的进程访问，并为这些进程提供服务。因此，用创建者来标记它们是有意义的。语法如下：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Examples from the `sepolicy` file `fs_use` are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy` 文件中的 `fs_use` 示例如下：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: fs_use_trans
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs_use_trans
- en: 'The next way you might wish to set labels on pseudo filesystems that are actually
    mounted, is by using `fs_use_trans`. This sets a filesystem wide label on the
    pseudo filesystem. The syntax for this is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望设置伪文件系统（实际上已挂载）的标签的另一种方式是使用`fs_use_trans`。这将在伪文件系统上设置整个文件系统的标签。此语法的格式如下：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Example from the `sepolicy` file `fs_use` is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy`文件中的`fs_use`示例如下：'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: genfscon
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: genfscon
- en: If none of the `fs_use_*` statements meet your use cases, which would be the
    case for `vfat` filesystems and `procfs`, then you would use the `genfscon` statement.
    The label specified for `genfscon` applies to *all* instances of that filesystem
    mount. For instance, you might wish to use `genfscon` with the `vfat` filesystems.
    If you have two `vfat` mounts, they will use the same `genfscon` statement for
    each mount. However, `genfscon` behaves differently with `procfs`, and lets you
    label each file or directory within the filesystem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`fs_use_*`语句满足您的使用案例，例如对于`vfat`文件系统和`procfs`，那么您将使用`genfscon`语句。为`genfscon`指定的标签适用于该文件系统挂载的所有实例。例如，您可能希望使用`genfscon`与`vfat`文件系统一起。如果您有两个`vfat`挂载，它们将使用每个挂载相同的`genfscon`语句。然而，`genfscon`与`procfs`的行为不同，允许您对文件系统中的每个文件或目录进行标签化。
- en: 'The syntax of `genfscon` is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`genfscon`的语法如下：'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Examples from `sepolicy genfs_contexts` are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepolicy genfs_contexts`中的示例如下：'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the `rootfs` partial path is `/`. It's not `procfs`, so it doesn't
    support any fine granularity to its labeling; so `/` is the only thing you can
    use. However, you can get wild with `procfs` and set to any granularity you desire.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rootfs`的部分路径是`/`。它不是`procfs`，因此不支持对其标签的任何细粒度支持；所以`/`是唯一可以使用的。然而，您可以对`procfs`进行广泛的设置，并设置为所需的任何粒度。
- en: Mount options
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载选项
- en: Another option, if none of those fit your needs, is to pass the `context` option
    via the `mount` command line. This sets a filesystem wide mount context, such
    as `genfscon`, but is useful in the case of multiple filesystems that need to
    have separate labels. For instance, if you have two `vfat` filesystems mounted,
    you might wish to separate accesses to them. With `genfscon` statements, both
    filesystems would use the same label provided by `genfscon`. By specifying the
    label at mount time, you can have two `vfat` filesystems mounted with different
    labels.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述选项都不符合您的需求，您可以通过`mount`命令行传递`context`选项。这将设置整个文件系统的挂载上下文，例如`genfscon`，但在需要具有单独标签的多个文件系统中很有用。例如，如果您有两个挂载的`vfat`文件系统，您可能希望将它们的使用分开。使用`genfscon`语句，这两个文件系统将使用`genfscon`提供的相同标签。通过在挂载时指定标签，您可以将两个`vfat`文件系统挂载为具有不同标签。
- en: 'Take the following command as an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下命令为例：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Additional to the context as a mount option are: `fscontext` and `defcontext`.
    These options are mutually exclusive from context. The `fscontext` option sets
    the meta filesystem type that is used for certain operations, such as mount, but
    does not change the per file labels. The `defcontext` sets the default context
    for unlabeled files overriding the `initial_sid` statements. Lastly, another option,
    `rootcontext` allows you to set the root inode context in the filesystem, but
    only for that object. According to the man page mount (`man 8 mount`), it was
    found useful in stateless Linux.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为挂载选项的上下文之外，还有：`fscontext`和`defcontext`。这些选项与上下文互斥。`fscontext`选项设置用于某些操作（如挂载）的元文件系统类型，但不会更改每个文件的标签。`defcontext`设置未标记文件的默认上下文，覆盖`initial_sid`语句。最后，另一个选项`rootcontext`允许您在文件系统中设置根inode上下文，但仅针对该对象。根据`mount`手册页（`man
    8 mount`），在无状态Linux中这被发现是有用的。
- en: Labeling with extended attributes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展属性进行标签化
- en: Lastly, and probably the most frequently used way of labeling, is by using the
    extended attributes support also known as `xattr` or EA support. Even with `xattr`
    support, new objects inherit the context of their parent directory; however, these
    labels have the granularity of being per filesystem object-based or inode-based.
    If you remember, we had to turn on or verify that `XATTR(CONFIG_EXT4_FS_XATTR)`
    support was enabled for our filesystems on Android as well as configuring SELinux
    to use it via the config option `CONFIG_EXT4_FS_SECURITY`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并且可能是最常用的标签化方式，是通过使用扩展属性支持，也称为`xattr`或EA支持。即使有`xattr`支持，新对象也会继承其父目录的上下文；然而，这些标签的粒度是基于文件系统对象或inode的。如果您还记得，我们不得不在Android文件系统中启用或验证`XATTR(CONFIG_EXT4_FS_XATTR)`支持，并配置SELinux通过配置选项`CONFIG_EXT4_FS_SECURITY`来使用它。
- en: Extended attributes are a key-value metadata stores for files. SELinux security
    contexts use the `security.selinux` key, and the value is a string that is the
    security context or label.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性是文件的关键字-值元数据存储。SELinux 安全上下文使用 `security.selinux` 键，其值是一个字符串，表示安全上下文或标签。
- en: The file_contexts file
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`file_contexts` 文件'
- en: 'Within the `sepolicy` directory, you will find the `file_contexts` file. This
    file is consulted to set the attributes on filesystems that support per file security
    labels. Note that a couple of pseudo filesystems support this as well, such as
    `tmpfs`, `sysfs`, and recently `rootfs`. The `file_context` file has a regular
    expression-based syntax as follows, where `regexp` is the regular expression for
    the path:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sepolicy` 目录中，你可以找到 `file_contexts` 文件。此文件用于设置支持按文件安全标签的文件系统的属性。请注意，一些伪文件系统也支持此功能，例如
    `tmpfs`、`sysfs` 和最近添加的 `rootfs`。`file_context` 文件具有基于正则表达式的语法，如下所示，其中 `regexp`
    是路径的正则表达式：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If multiple regular expressions are defined for a file, the last match is used,
    so order is important.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为文件定义了多个正则表达式，则使用最后一个匹配项，因此顺序很重要。
- en: 'The following list shows each type field value for the type of filesystem object,
    their meanings, and syscall interface:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了文件系统对象类型的每个类型字段值、它们的含义和 syscall 接口：
- en: '`--`: This denotes a regular file.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--`: 这表示一个普通文件。'
- en: '`-d`: This denotes a directory.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`: 这表示一个目录。'
- en: '`-b`: This denotes a block file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`: 这表示一个块文件。'
- en: '`-s`: This denotes a socket file.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`: 这表示一个套接字文件。'
- en: '`-c`: This denotes a character file.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`: 这表示一个字符文件。'
- en: '`-l`: This denotes a link file.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`: 这表示一个链接文件。'
- en: '`-p`: This denotes a named pipe file.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`: 这表示一个命名管道文件。'
- en: As you can see, the type is essentially the mode as output by `ls -la` command.
    If it's not specified, it matches everything.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类型基本上是 `ls -la` 命令输出的模式。如果没有指定，则匹配所有内容。
- en: The next field is the file label or the special identifier `<<none>>`. Either
    one would supply a context or the identifier `<<none>>`. If you specify the context,
    the SELinux tools that consult `file_contexts` use the last match to the specified
    context. If the context specified is `<<none>>`, it means that no context is assigned.
    So, leave the one that we have found. The keyword `<<none>>` is not used in the
    AOSP reference, `sepolicy`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段是文件标签或特殊标识符 `<<none>>`。两者都可以提供上下文或标识符 `<<none>>`。如果你指定了上下文，则咨询 `file_contexts`
    的 SELinux 工具使用指定上下文的最后一个匹配项。如果指定的上下文是 `<<none>>`，则表示没有分配上下文。因此，保留我们找到的那个。关键字 `<<none>>`
    在 AOSP 参考 `sepolicy` 中没有使用。
- en: It's important to note that the preceding paragraph explicitly states that SELinux
    tools use the `file_contexts` policy. The kernel is not aware that this file exists.
    SELinux labels all its objects by explicitly setting them from userspace with
    tools that look up the context in `file_context` or via the `fs_use_*` and `genfs`
    policy statements. In other words, `file_contexts` is not built in the core policy
    file, and it is not loaded or used directly by the kernel. At build time, the
    `file_contexts` file is built in the ramdisk rootfs and can be found at `/file_contexts`.
    Also, during build time, the system image is labeled, freeing the device itself
    from this burden.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，前面的段落明确指出 SELinux 工具使用 `file_contexts` 策略。内核不知道这个文件的存在。SELinux 通过从用户空间使用查找
    `file_context` 的工具或通过 `fs_use_*` 和 `genfs` 策略语句显式设置来为所有对象设置标签。换句话说，`file_contexts`
    不是内置于核心策略文件中，也不是由内核直接加载或使用的。在构建时，`file_contexts` 文件在 ramdisk rootfs 中构建，可以在 `/file_contexts`
    中找到。此外，在构建时，系统镜像被标记，从而减轻了设备本身的负担。
- en: In Android, `init`, `ueventd`, and `installd` have all been modified to look
    up the contexts of objects they are creating; so that they can label them properly.
    Thus, all the init built ins that create filesystem objects, such as `mkdir`,
    have been modified to make use of the `file_contexts` file if it exists, and the
    same goes for `installd` and `ueventd`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，`init`、`ueventd` 和 `installd` 都已被修改以查找它们创建的对象的上下文；这样它们就可以正确地标记它们。因此，所有创建文件系统对象的
    init 内置命令，如 `mkdir`，都已修改为使用 `file_contexts` 文件（如果存在），同样适用于 `installd` 和 `ueventd`。
- en: 'Let''s take a look at some snippets from the `file_context` file located in
    `sepolicy`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位于 `sepolicy` 中的 `file_context` 文件的一些片段：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are setting up the contexts for files in `/dev`. Note how the entries
    are in order from most generic to more specific `dev` files. Thus, any files not
    covered by the more specific entries will end up with the context `u:object_r:device:s0`,
    and the files that match further down, end up with a more specific label. For
    instance, the accelerometer at `/dev/accelerometer` will get the context `u:object_r:sensors_device:s0`.
    Note that the type field was omitted, which means that it matches on *all* filesystem
    objects, such as directories (`type -d`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在为 `/dev` 目录下的文件设置上下文。注意条目是如何从最通用的 `dev` 文件开始，逐渐变得更为具体的。因此，任何未被更具体条目覆盖的文件将最终带有上下文
    `u:object_r:device:s0`，而与更下面条目匹配的文件将带有更具体的标签。例如，位于 `/dev/accelerometer` 的加速度计将获得上下文
    `u:object_r:sensors_device:s0`。请注意，省略了类型字段，这意味着它匹配所有文件系统对象，例如目录（`type -d`）。
- en: 'You might be wondering how `/dev`, the directory itself, gets a file context.
    Looking at some of the snippets, we say the `/` or root, got labeled via the statement
    `genfscon rootfs / u:object_r:rootfs:s0` in the `genfs_context` file. This chapter
    stated earlier that, "new objects inherit the context of their parent directory."
    Hence, we can reason that `/dev` is of context `u:object_r:rootfs:s0` since that
    is the label `/` has. We can test this by passing the `-Z` flag to `ls` to show
    us the label of `/dev`. On the UDOO serial connection, execute the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道 `/dev` 目录本身是如何获得文件上下文的。查看一些片段，我们说 `/` 或根是通过 `genfs_context` 文件中的 `genfscon
    rootfs / u:object_r:rootfs:s0` 语句进行标签化的。本章之前提到，“新对象继承其父目录的上下文。”因此，我们可以推断 `/dev`
    的上下文是 `u:object_r:rootfs:s0`，因为这是 `/` 的标签。我们可以通过传递 `-Z` 标志给 `ls` 来测试这一点，以显示 `/dev`
    的标签。在 UDOO 串行连接上，执行以下命令：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It seems that the hypothesis is incorrect, but note that it is true that everything
    has a label, and if it's not specified, then it inherits from the parent. Looking
    back at `sepolicy`, we can see that the `dev` filesystem was initially set with
    a `fs_use_trans devtmpfs u:object_r:device:s0;` policy statement. So when the
    filesystem is mounted, it is set filesystem wide. Later, when entries are added
    by `init` or `ueventd`, they use `file_contexts` entries to set the context of
    the newly created filesystem object to what is specified in the `file_contexts`
    file. The filesystem at `/dev`, which is a `devtmps` pseudo filesystem, is an
    example of a filesystem that has both a filesystem-wide label via the `fs_use_trans`
    statement, but can also support fine grained labeling via `file_contexts;`. Filesystems
    are not very consistent in capabilities on Linux.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来假设是不正确的，但请注意，确实一切都是有一个标签的，如果没有指定，则从父级继承。回顾 `sepolicy`，我们可以看到 `dev` 文件系统最初是通过
    `fs_use_trans devtmpfs u:object_r:device:s0;` 策略语句设置的。因此，当文件系统挂载时，它被设置为整个文件系统。后来，当
    `init` 或 `ueventd` 添加条目时，它们使用 `file_contexts` 条目来设置新创建的文件系统对象的上下文，使其与 `file_contexts`
    文件中指定的上下文相匹配。位于 `/dev` 的文件系统，这是一个 `devtmps` 伪文件系统，是一个既有通过 `fs_use_trans` 语句设置的文件系统范围标签，也可以通过
    `file_contexts;` 支持细粒度标签的文件系统的例子。在 Linux 上，文件系统在功能上并不非常一致。
- en: Dynamic type transitions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型转换
- en: 'Dynamic type transitions indicated by the SELinux policy statement `type_transition`
    are a way to allow files to dynamically determine their types. Because these are
    compiled into the policy, these do not have any relation to the `file_contexts`
    file. These policy statements allow the policy author to dynamically dictate the
    context of a file based on the context in which the file is created. These are
    useful in situations where you don''t control source code, or do not wish to couple
    SELinux in any way. For instance, the `wpa` supplicant, which is a service that
    runs for Wi-Fi support and creates a socket file in its data directory. Its data
    directory is labeled with the type `wifi_data_file` and as expected, the socket
    ends up with that label. However, this socket is shared by the system server.
    Now, we can allow just the system server to access the type and object class,
    however, `hostapd` and other things are creating sockets and other objects in
    that directory and thus the objects also have this type. We really want to ensure
    that the two sockets in question, the one used by `hostapd` and the other by system
    server, are kept exclusive from each other. To do this, we need to be able to
    label one of the sockets at a finer granularity, and to do so, we can either modify
    the code or use a dynamic type transition. Rather than mucking with the code,
    let''s use a type transition, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux策略声明`type_transition`指示的动态类型转换是一种允许文件动态确定其类型的方法。因为这些是编译到策略中的，所以它们与`file_contexts`文件没有任何关系。这些策略声明允许策略作者根据文件创建的上下文动态指定文件上下文。这在您不控制源代码或不想以任何方式耦合SELinux的情况下很有用。例如，`wpa`客户端，这是一个为Wi-Fi支持而运行的服务，并在其数据目录中创建一个套接字文件。其数据目录被标记为类型`wifi_data_file`，正如预期的那样，套接字最终也带有这个标签。然而，这个套接字是由系统服务器共享的。现在，我们可以只允许系统服务器访问类型和对象类，然而，`hostapd`和其他一些东西在这个目录中创建套接字和其他对象，因此这些对象也具有这种类型。我们真正想要确保的是，两个相关的套接字，即`hostapd`使用的套接字和系统服务器使用的套接字，彼此之间是独立的。为了做到这一点，我们需要能够以更细的粒度标记其中一个套接字，为此，我们可以修改代码或使用动态类型转换。与其修改代码，不如使用类型转换，如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is an actual statement from the `sepolicy` file, `wpa_supplicant.te`.
    It says that, when a process of the type `wpa` creates a file of the type `wifi_data_file`
    and the object class is `sock_file` to label it as `wpa_socket` on creation. The
    statement syntax is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`sepolicy`文件`wpa_supplicant.te`中的一个实际声明。它表示，当类型为`wpa`的进程创建类型为`wifi_data_file`的文件，并且对象类是`sock_file`时，在创建时将其标记为`wpa_socket`。该语句的语法如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As of SELinux policy version 25, the `type_transition` statement can support
    named type transitions where a fourth argument exists and is the name of the file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到SELinux策略版本25为止，`type_transition`语句可以支持命名类型转换，其中存在第四个参数，并且是该文件的名字：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will see an example use of this filename in the `sepolicy` file, `system_server.te`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`sepolicy`文件中看到一个使用此文件名的示例，`system_server.te`：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the filename or basename and not the path, and it must match exactly. Regex
    is not supported. It's also interesting to note that the dynamic transitions are
    not limited to file objects, but any object class event processes. We will see
    how dynamic process transitions are used in [Chapter 9](ch09.html "Chapter 9. Adding
    Services to Domains"), *Adding Services to Domains*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件名或基本名，而不是路径，并且它必须完全匹配。不支持正则表达式。还有一点值得注意的是，动态转换不仅限于文件对象，还包括任何对象类事件进程。我们将在[第9章](ch09.html
    "第9章。向域添加服务")中看到如何使用动态进程转换，*向域添加服务*。
- en: Examples and tools
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例和工具
- en: 'With the theory behind us, let''s look at the tools and techniques to label
    files in the system. Let''s start by mounting a `ramfs` filesystem. We will start
    by remounting `/` since it is read only and create a mount point for the filesystem.
    Via the UDOO serial console, execute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握理论之后，让我们来看看在系统中标记文件的工具和技术。让我们先挂载一个`ramfs`文件系统。我们将从重新挂载`/`开始，因为它只读，并为文件系统创建一个挂载点。通过UDOO串行控制台执行以下命令：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we want to see which label the filesystem has:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想看看文件系统具有哪个标签：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can recall, the `initial_sid_context` file had this initial `sid` set
    for the filesystem:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的，`initial_sid_context`文件为文件系统设置了以下初始`sid`：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we want to get this ramdisk in a new label, we need to create the type in
    the policy, and set a new `genfscon` statement to use it. We will declare the
    new type in the sepolicy file `file.te`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将这个ramdisk转换成一个新的标签，我们需要在策略中创建类型，并设置一个新的`genfscon`语句来使用它。我们将在`file.te`策略文件中声明新的类型：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The type policy statement syntax is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型策略语句的语法如下：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Attributes in SELinux are statements that let you define common groups. They
    are defined via the `attribute` statement. In Android SELinux policy, we have
    `file_type` and `fs_type` defined for us already. We will use them here because
    this new type, which we're creating, has the attributes `file_type` and `fs_type`.
    The `file_type` attribute is associated with a type for a file, and the `fs_type`
    attribute means that this type is also associated with filesystems. Attributes,
    right now, are not of great importance; so don't get caught up in the detail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux中的属性是允许你定义常见组的语句。它们通过`attribute`语句定义。在Android SELinux策略中，我们已经为我们定义了`file_type`和`fs_type`。我们将在这里使用它们，因为我们要创建的新类型具有`file_type`和`fs_type`属性。`file_type`属性与文件的类型相关联，而`fs_type`属性表示此类型也与文件系统相关联。目前，属性并不十分重要；所以不要陷入细节。
- en: 'The next thing to modify is the `sepolicy` file, `genfs_context` by adding
    the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要修改的是`sepolicy`文件，`genfs_context`，通过添加以下内容：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we will compile the boot image and flash it to the device, or better yet,
    let's use the dynamic policy reload support like the following.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编译引导映像并将其闪存到设备上，或者更好的是，让我们使用以下动态策略重新加载支持。
- en: 'From the root of the UDOO project tree build just the `sepolicy` project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从UDOO项目树的根目录构建`sepolicy`项目：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Push the new policy over `adb`, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式通过`adb`推送新的策略：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Trigger a reload by using the `setprop` command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setprop`命令触发重新加载：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you have the serial console connected, you should see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你连接了串行控制台，你应该会看到：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you don''t, and just have `adb`, check `dmesg`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有，只有`adb`，检查`dmesg`：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A successful load should use our policy at the path, `/data/security/current/sepolicy`.
    Let''s unmount the ramdisk and remount it to check out its type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的加载应该使用我们的策略在路径上，`/data/security/current/sepolicy`。让我们卸载ramdisk并重新挂载它以检查其类型：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We were able to modify the policy and use `genfscon` to change the filesystem
    type, and now to show inheritance, let''s go ahead and create a file on the filesystem
    with `touch`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够修改策略并使用`genfscon`来更改文件系统类型，现在为了显示继承，让我们继续在文件系统上使用`touch`创建一个文件：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we expected, the new file is labeled with the type ramdisk. Now, suppose
    when we do touch from the shell, we want the file to be of a different type, such
    as `ramdisk_newfile`; how can we do this? We can do this by modifying touch itself
    to consult `file_contexts`, or we can define a dynamic type transition; let us
    try the dynamic type transition approach. The first argument to the `type_transition`
    statement is the creating type; so what type is our shell in? You can get this
    by performing:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，新文件被标记为ramdisk类型。现在，假设我们从shell执行`touch`时，我们希望文件具有不同的类型，例如`ramdisk_newfile`；我们如何做到这一点？我们可以通过修改`touch`本身来咨询`file_contexts`，或者我们可以定义动态类型转换；让我们尝试动态类型转换方法。`type_transition`语句的第一个参数是创建类型；那么我们的shell在什么类型？你可以通过执行以下操作来获取：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A simpler way is to run the `id -Z` command, which uses the aforementioned
    `proc` file. For a serial console, execute:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的方法是运行`id -Z`命令，它使用上述`proc`文件。对于串行控制台，执行：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And to run the same command for the `adb` shell:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 并且运行相同的命令用于`adb` shell：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note the discrepancy between our serial console shell and the `adb` shell, in
    [Chapter 9](ch09.html "Chapter 9. Adding Services to Domains"), *Adding Services
    to Domains*; we will fix this. Because of this, the policy we author now will
    address both cases.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的串行控制台shell和`adb` shell之间的差异，在[第9章](ch09.html "第9章。向域添加服务")，*向域添加服务*；我们将修复这个问题。因此，我们现在编写的策略将解决这两种情况。
- en: 'Start by opening the `sepolicy` file, `init_shell.te` and append the following
    to the end of the file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开`sepolicy`文件，`init_shell.te`，并将以下内容附加到文件末尾：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Do this for the `sepolicy` file, `shell.te`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对`sepolicy`文件，`shell.te`也这样做：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we need to declare the new type; so open up the `sepolicy` file, `file.te`
    and append the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要声明新的类型；因此打开`sepolicy`文件，`file.te`，并附加以下内容：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that we have only used the `file_type` attribute. This is because a filesystem
    should never have the type `ramdisk_newfile`, only a file residing within that
    file system should.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只使用了`file_type`属性。这是因为文件系统永远不应该有`ramdisk_newfile`类型，只有位于该文件系统内的文件应该有。
- en: 'Now, build the `adb` policy, push it to the device, and trigger a reload. With
    that done, create the file and check the results:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建`adb`策略，将其推送到设备，并触发重新加载。完成此操作后，创建文件并检查结果：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So it didn''t work. Let''s investigate the reason by trying on an example of
    an `ext4` filesystem. Let''s use the following commands:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它没有成功。让我们通过一个 `ext4` 文件系统的例子来调查原因。让我们使用以下命令：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, check its context:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查它的上下文：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The label is `system_data_file`. This is not helpful, as it doesn''t apply
    to our type transition rule; to fix this, we can use the `chcon` command to explicitly
    change the files context:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是 `system_data_file`。这没有帮助，因为它不适用于我们的类型转换规则；为了修复这个问题，我们可以使用 `chcon` 命令显式地更改文件上下文：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now with the context changed to match what we were trying earlier with the
    ramdisk, let''s try to create a file within this directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将上下文更改为我们之前尝试的 ramdisk 的上下文，让我们尝试在这个目录中创建一个文件：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see, the type transition has occurred. This was meant to illustrate
    the issues you may find while working with SELinux and Android. Now that we have
    shown that our `type_transition` statement is valid, there are only two possibilities
    why this is failing: the filesystem doesn''t support it or we''re missing something
    somewhere to "turn it on". It turns out that the latter is the case; we were missing
    our `fs_use_trans` statements. So go ahead and open up the `sepolicy` file, `fs_use`
    and add the following line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，类型转换已经发生。这旨在说明你在使用 SELinux 和 Android 时可能遇到的问题。既然我们已经证明我们的 `type_transition`
    语句是有效的，那么这个失败只有两种可能性：文件系统不支持它，或者我们在某处遗漏了“开启”它的东西。结果证明，后者是正确的；我们遗漏了我们的 `fs_use_trans`
    语句。所以，请打开 `sepolicy` 文件，在 `fs_use` 中添加以下行：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This statement enables SELinux dynamic transitions on this filesystem. Now,
    rebuild the `sepolicy` project, `adb push` the policy file, and enable a dynamic
    reload via `setprop`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句启用了此文件系统上的 SELinux 动态转换。现在，重新构建 `sepolicy` 项目，使用 `adb push` 推送策略文件，并通过 `setprop`
    命令启用动态重新加载：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There you have it, the object has the right value determined by a dynamic type
    transition. We were missing `fs_use_trans`, which enabled type transitions on
    filesystems that don't support `xattrs`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，对象有了由动态类型转换确定的正确值。我们遗漏了 `fs_use_trans`，它启用了不支持 `xattrs` 的文件系统上的类型转换。
- en: 'Now, suppose we want to mount another ramdisk, what would happen? Well since
    it was labeled with the `genfscon` statement, all filesystems mounted with that
    type should get the context, `u:object_r:ramdisk:s0`. We will mount this filesystem
    at `/ramdisk2`, and verify this behavior:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要挂载另一个 ramdisk，会发生什么？嗯，因为它被标记为 `genfscon` 语句，所以所有使用该类型的挂载文件系统都应该获得上下文，`u:object_r:ramdisk:s0`。我们将在这个文件系统上挂载
    `/ramdisk2`，并验证这种行为：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, check the contexts:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也要检查上下文：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we want to write allow rules to separate accesses to these file systems,
    we will need to have their target files in separate types. To do this, we can
    mount the new ramdisk with the context option. But first, we need to create the
    new type; lets go to the `sepolicy` file, `file.te` and add a new type called
    `ramdisk2`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为这些文件系统的单独访问编写允许规则，我们需要将它们的目标文件放在不同的类型中。为此，我们可以使用上下文选项挂载新的 ramdisk。但首先，我们需要创建新的类型；让我们转到
    `sepolicy` 文件，`file.te` 中并添加一个名为 `ramdisk2` 的新类型：
- en: '[PRE45]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, build the `sepolicy` with the command `mmm`, followed be using the command
    `abd push` to push the policy, and trigger a reload with the `setprop` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `mmm` 命令构建 `sepolicy`，然后使用 `adb push` 命令推送策略，并通过 `setprop` 命令触发重新加载：
- en: '[PRE46]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, let''s umount `/ramdisk2` and remount it with the `context=`
    option:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，让我们卸载 `/ramdisk2` 并使用 `context=` 选项重新挂载它：
- en: '[PRE47]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, verify the contexts:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证上下文：
- en: '[PRE48]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can override the `genfscon` context with the `mount` option, `context=<context>`.
    In fact, if we look at `dmesg`, we can see some great messages. When we mounted
    `ramfs` without the context option, we got:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `mount` 选项 `context=<context>` 覆盖 `genfscon` 上下文。实际上，如果我们查看 `dmesg`，我们可以看到一些很好的信息。当我们没有上下文选项挂载
    `ramfs` 时，我们得到了：
- en: '[PRE49]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we mounted it with the `context=<context>` option, we got:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `context=<context>` 选项挂载时，我们得到了：
- en: '[PRE50]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can see that SELinux gives us some helpful messages while trying to figure
    out from where it sources its labels.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在尝试确定其标签来源时，SELinux 给出了一些有用的信息。
- en: Now, let's go onto labeling filesystems with the `xattr` support, such as `ext4`.
    We will start with the toolbox command, `chcon`. The `chcon` command allows you
    to set the context of a file system object explicitly, it does not consult `file_contexts`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用具有 `xattr` 支持的文件系统进行标签化，例如 `ext4`。我们将从工具箱命令 `chcon` 开始。`chcon` 命令允许你显式地设置文件系统对象的上下文，它不会咨询
    `file_contexts`。
- en: 'Let''s take a look at `/system/bin` and in it, at the first 10 files:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `/system/bin` 目录，以及其中的前 10 个文件：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can see that many of them have the `system_file` label, which is the default
    label for that filesystem; let''s change the `am` type to `am_exec`. Again, we
    need to create a new type by adding the following to `sepolicy` file, `file.te`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，其中许多都带有`system_file`标签，这是该文件系统的默认标签；让我们将`am`类型更改为`am_exec`。同样，我们需要通过向`sepolicy`文件中的`file.te`添加以下内容来创建一个新的类型：
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, rebuild the policy file, push it to the UDOO, and trigger a reload. After
    that, let''s start remounting the system, since it is read only:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重建策略文件，将其推送到UDOO，并触发重新加载。之后，让我们开始重新挂载系统，因为它现在是只读的：
- en: '[PRE53]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now perform `chcon`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行`chcon`：
- en: '[PRE54]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Verify the result:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 验证结果：
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Additionally, the `restorecon` command will use `file_contexts`, and restore
    that file to what is set in the `file_contexts` file, which should be `system_file`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`restorecon`命令将使用`file_contexts`，并将该文件恢复到`file_contexts`文件中设置的状态，应该是`system_file`：
- en: '[PRE56]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, `restorecon` was able to consult `file_contexts` and restore
    the specified context on that object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`restorecon`能够咨询`file_contexts`并在该对象上恢复指定的上下文。
- en: 'The Android system''s filesystem gets constructed during the build time, and
    consequently, all its file objects are labeled during that process. We can also
    change this at build time by changing `file_contexts`. With this changed, the
    system partition rebuilt, and after reflashing the system, we should see the `am`
    file with the `am_exec` type. We can test this by amending the `sepolicy` file,
    `file_contexts` by adding this line at the end of the `system/bin` section:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统的文件系统在构建时构建，因此，所有文件对象在构建过程中都会被标记。我们也可以通过更改`file_contexts`在构建时更改这一点。更改后，系统分区将被重建，系统刷新后，我们应该看到带有`am_exec`类型的`am`文件。我们可以通过在`system/bin`部分的末尾添加此行来测试`sepolicy`文件，`file_contexts`：
- en: '[PRE57]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Rebuild the whole system with:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重建整个系统：
- en: '[PRE58]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now flash and reboot, and let''s take a look at the `/system/bin/am` context
    as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新并重启，让我们看一下以下`/system/bin/am`上下文：
- en: '[PRE59]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This shows that the system partition respects the file contexts for build-time
    labeling, and how we can control these labels.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明系统分区尊重构建时标签的文件上下文，以及我们如何控制这些标签。
- en: Fixing up /data
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复/data
- en: 'Additionally in the audit logs, we have seen a bunch of unlabeled files, for
    instance, the following denial:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在审计日志中，我们看到了许多未标记的文件，例如以下拒绝：
- en: '[PRE60]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can see that the device is `mmcblk0p4`, which mount commands and will tell
    us what filesystem this is mounted to, in its output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到设备是`mmcblk0p4`，挂载命令将在其输出中告诉我们它挂载到了哪个文件系统：
- en: '[PRE61]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'So why does the `/data` filesystem have so many unlabeled files? The reason
    is that SELinux is meant to be turned on from an empty device, that is, from first
    boot. Android builds the data directory structures on demand. Thus, all the labels
    for the `/data` are handled by the `file_contexts` file since it is `ext4`. Also,
    it is handled by the systems that create the `/data` files and directories. These
    systems have been modified to label the data partition based on the `file_contexts`
    specifications. So this presents two options: wipe `/data` and reboot, or `restorecon
    -R /data`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么`/data`文件系统有这么多未标记的文件呢？原因是SELinux旨在从空设备开启，也就是说，从第一次启动开始。Android按需构建数据目录结构。因此，`/data`的所有标签都由`file_contexts`文件处理，因为它使用的是`ext4`。此外，它由创建`/data`文件和目录的系统处理。这些系统已被修改，根据`file_contexts`规范标记数据分区。因此，这提供了两种选择：擦除`/data`并重启，或`restorecon
    -R /data`。
- en: Option one is a bit harsh, but if you eject the SD card and remove all the files
    on the data partition, `partition 4`, Android will rebuild and you won't see any
    more unlabeled issues. However, this is not recommended for deployed devices when
    you upgrade; you will destroy all of the users' data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项有点严厉，但如果您拔出SD卡并删除数据分区（分区4）上的所有文件，Android将重新构建，您将不再看到任何未标记的问题。然而，当您升级部署设备时，这并不推荐；您将破坏所有用户的数据。
- en: 'Option two is more palatable in deployed scenarios, but has its limitations.
    Notably, executing `restorecon -R /data` will take a long time and must be done
    early in boot, right after the mount. However, this is really the only option
    at this point. Google, however, has done a lot of work in this area, and created
    a system that intelligently relabels `/data` on policy updates. For our use, we
    will choose a variant of option two, especially after considering how sparsely
    populated the `/data` filesystem is; we really haven''t installed or generated
    a lot of user data yet. With that stated, execute:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择在部署场景中更为可接受，但有其局限性。值得注意的是，执行`restorecon -R /data`将花费很长时间，并且必须在引导早期、挂载之后立即完成。然而，这真的是目前唯一的选项。然而，谷歌在这一领域做了很多工作，并创建了一个系统，该系统能够在策略更新时智能地重新标记`/data`。对于我们的使用，我们将选择第二种选择的变体，特别是在考虑到`/data`文件系统稀疏度很高的情况下；我们实际上还没有安装或生成很多用户数据。据此，执行：
- en: '[PRE62]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We don''t have to execute `restorecon` early in boot since our system is in
    permissive mode, and we''re not in a deployed scenario. Now, let''s pull the `audit.log`
    file and compare it to the already pulled `audit.log`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的系统处于宽容模式，并且我们不在部署场景中，所以我们不需要在引导早期执行`restorecon`。现在，让我们拉取`audit.log`文件，并将其与已经拉取的`audit.log`进行比较：
- en: '[PRE63]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s use `grep` to count the number of occurrences in each file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`grep`来计算每个文件中出现的次数：
- en: '[PRE64]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Great, we fixed up all of our unlabeled issues on `/data`!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们解决了`/data`上的所有未标记问题！
- en: A side note on security
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于安全性的一个侧记
- en: 'Note that even though we are running all these commands and changing all these
    things, this is not a security vulnerability within SELinux. Being able to change
    type labels, mounting filesystems, and associating filesystems with a type, all
    require allow rules. If you look through the audit logs, you''ll see a slew of
    denials; a sample is provided:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，尽管我们正在运行所有这些命令并更改所有这些设置，但这并不是SELinux中的安全漏洞。能够更改类型标签、挂载文件系统以及将文件系统与类型关联，所有这些都要求允许规则。如果你查看审计日志，你会看到一系列拒绝；以下是一个示例： '
- en: '[PRE65]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If we were in an enforcing mode, we wouldn't have been able to perform any of
    the experiments shown here.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于强制模式，我们就无法执行这里展示的任何实验。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to get files into contexts by relabeling them. We
    used a variety of techniques to accomplish this task, from toolbox commands such
    as `chcon` and `restorecon`, to mount options and dynamic transitions. With these
    tools, we can ensure that all filesystem objects are labeled correctly. This way,
    we end up with the right target contexts so that the policies we author are effective.
    In the next chapter, we will focus on the processes, making sure that they are
    in the right domain or context.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过重新标记文件将文件放入上下文中。我们使用了各种技术来完成这项任务，从工具箱命令如`chcon`和`restorecon`，到挂载选项和动态转换。有了这些工具，我们可以确保所有文件系统对象都被正确标记。这样，我们最终得到正确的目标上下文，从而确保我们编写的策略是有效的。在下一章中，我们将关注进程，确保它们位于正确的域或上下文中。
