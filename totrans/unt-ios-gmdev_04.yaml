- en: Chapter 4. Unity Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：Unity概念
- en: Now that we have built our first application and have a taste for what Unity
    is capable of, it's time to learn the core concepts of Unity so that we can build
    much more complex and compelling games. We have briefly discussed some of the
    core concepts already, but to build compelling content it is necessary to have
    a more in-depth understanding of how Unity uses these concepts.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的第一个应用程序，并且对Unity的能力有了初步的了解，是时候学习Unity的核心概念了，这样我们才能构建更加复杂和引人入胜的游戏。我们已经简要讨论了一些核心概念，但为了构建引人入胜的内容，有必要更深入地理解Unity如何使用这些概念。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn the core concepts of Unity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Unity的核心概念
- en: Create the core components within the tool
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工具内创建核心组件
- en: Basic concepts of Unity development
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity开发的基本概念
- en: When studying a foreign language you will spend some time immersing yourself
    in its nouns and verbs so that you can understand the concepts and begin creating
    sentences.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习一门外语时，您将花一些时间沉浸在其名词和动词中，以便理解概念并开始构建句子。
- en: Asset
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产
- en: An asset represents the atomic unity through which you can construct a scene
    in Unity. Anything that you bring into the environment is considered an asset
    including sound files, textures, models, scripts, and so on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 资产代表通过它可以构建Unity场景的原子Unity。您将带入环境中的任何东西都被视为资产，包括声音文件、纹理、模型、脚本等等。
- en: You can import assets into a Unity project by either dragging and dropping them
    from the desktop into the **Project** view, or by using the **Import New Asset**
    menu **(Assets | Import New Asset)**. Once in the **Project** view the asset is
    something that can be used in your game. Think of the **Project** view as your
    palette from which you will paint your world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从桌面拖放它们到**项目**视图，或者使用**导入新资产**菜单（**资产 | 导入新资产**）将资产导入Unity项目。一旦在**项目**视图中，资产就是可以在您的游戏中使用的资源。将**项目**视图想象成您的调色板，您将从其中绘制您的世界。
- en: Assets are managed on the file system by Unity. If you go into your project
    folder and look at the `Assets` directory you will find all of the assets that
    are in your project. When Unity imports your assets, it will store the imported
    asset and all of its metadata here.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Unity通过文件系统管理资产。如果您进入您的项目文件夹并查看`Assets`目录，您将找到项目中所有的资产。当Unity导入您的资产时，它将在这里存储导入的资产及其所有元数据。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that you should never try to manage assets in this folder
    directly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：您绝对不应该尝试直接管理此文件夹中的资产。
- en: While you can make changes to textures, audio, models, and so on, in this location
    with your various tools you should never move them as this will break the link
    between the asset and the Unity metadata for the asset. In effect, Unity will
    behave as if you just brought this asset into Unity for the first time and any
    relationships, settings, and so on will have to be newly created.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用各种工具更改纹理、音频、模型等，但您绝对不应该移动它们，因为这会破坏资产与Unity元数据之间的链接。实际上，Unity将表现得好像您刚刚第一次将此资产带入Unity，任何关系、设置等等都需要重新创建。
- en: Time for action — Exporting asset packages
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 导出资产包
- en: There will be times when you want to share a collection of assets with other
    users on your team or within the community. Unity makes this easier by providing
    a simple mechanism called Packages. A **package** is just a collection of assets
    bundled together in a single file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能希望与团队中的其他用户或社区中的其他用户共享一组资产。Unity通过提供一个简单的机制，称为包，来简化这一过程。**包**只是将资产捆绑在一起的单个文件。
- en: 'In this exercise we''re going to explore how one would share assets from an
    existing project with other developers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探讨如何从现有项目中与其他开发者共享资产：
- en: Open the project for this chapter named **HelloWorld2**. In it you will find
    a version of our original Hello World demo with some additional assets.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章的项目**HelloWorld2**。在其中，您将找到一个包含一些额外资产的原始Hello World演示版本。
- en: Select the assets that you want to export as part of the package:![Time for
    action — Exporting asset packages](img/978-1-84969-040-9_4_5 2.jpg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要作为包一部分导出的资产：![行动时间 — 导出资产包](img/978-1-84969-040-9_4_5 2.jpg)
- en: In the above illustration the **Materials** element within the **Project** has
    been selected. There are **Puppy** and **Grass** materials that are a child of
    the **Materials** element and they will be bundled in the package as well. If
    you only wanted to share the **Puppy** materials you would simply select the **Puppy**
    element and only those materials would be packaged.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的图中，**项目**中的**材质**元素已被选中。有**小狗**和**草地**材质，它们是**材质**元素的子元素，并将被捆绑在包中。如果您只想共享**小狗**材质，您只需选择**小狗**元素，只有那些材质会被打包。
- en: Next let's create a package using the **Export Package** menu **(Assets | Export
    Package)**. When selected, this will create a package starting with the selected
    item in the **Project** view and anything that is a child of this element.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用**导出包**菜单**（资源 | 导出包）**创建一个包。当选择时，这将创建一个从**项目**视图中选定的项目开始的包，以及任何是该元素子元素的内容。
- en: Unity will then display a dialog with all of the assets that will be exported.
    If there are assets that you want to remove, uncheck its checkbox:![Time for action
    — Exporting asset packages](img/978-1-84969-040-9_4_3.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity将显示一个对话框，其中包含所有将要导出的资源。如果您想删除某些资源，取消选中其复选框：![操作时间 — 导出资源包](img/978-1-84969-040-9_4_3.jpg)
- en: In addition, there is a checkbox labeled **Include dependencies**. If your assets
    have other assets, such as scripts, that they depend on, keeping this box checked
    tells Unity to include those assets in the package.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个标记为**包含依赖项**的复选框。如果您的资源依赖于其他资源，例如脚本，保持此复选框选中状态将告诉Unity将这些资源包含在包中。
- en: Select the **Export** button and, in the subsequent file dialog, provide a name
    for the Unity package file. Unity will create and compress the assets into a file
    with the extension `.unitypackage:`![Time for action — Exporting asset packages](img/978-1-84969-040-9_4_5.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**导出**按钮，然后在随后的文件对话框中为Unity包文件提供名称。Unity将创建并压缩资源到一个扩展名为`.unitypackage`的文件中：![操作时间
    — 导出资源包](img/978-1-84969-040-9_4_5.jpg)
- en: What just happened?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have created a Unity package that contains all of the assets we selected.
    This is the ideal way to share assets with your team as any settings, hierarchies,
    and so on will be preserved when those assets are imported.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个Unity包，其中包含了我们选定的所有资源。这是与您的团队共享资源的理想方式，因为当这些资源被导入时，任何设置、层次结构等都将被保留。
- en: Time for action — Importing asset packages
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 — 导入资源包
- en: There are a growing number of third party companies who are providing assets
    specifically packaged for Unity developers, including the Unity Asset Store which
    can be accessed from within the Unity product. All of these solutions provide
    content through the same `.unitypackage` format described in the section Time
    for action — — Exporting asset packages. With assets from the Unity Asset store,
    the process of including the assets in your project is automatic. However, there
    may be times when you have received assets from others and need to import them
    into your project yourself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的第三方公司正在为Unity开发者提供专门为Unity打包的资源，包括可以从Unity产品内部访问的Unity资源商店。所有这些解决方案都通过在“操作时间
    — 导出资源包”部分描述的相同`.unitypackage`格式提供内容。使用Unity资源商店的资源，将资源包含到您的项目中的过程是自动的。然而，有时您可能从其他人那里收到了资源，需要自己将它们导入到项目中。
- en: Create a new Project in Unity called **Project Import**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中创建一个新的项目，命名为**项目导入**。
- en: Using the `.unitypackage` file you built from the Exporting Assets Time for
    action — , import into your project by dragging the `.unitypackage` file into
    the **Project** view at the location in your project hierarchy where you'd like
    them to be stored, or by using the **Import Assets** menu **(Assets | Import Asset):**![Time
    for action — Importing asset packages](img/978-1-84969-040-9_4_6.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从“操作时间 — 导出资源”构建的`.unitypackage`文件，通过将`.unitypackage`文件拖放到您项目层次结构中希望它们存储的位置的**项目**视图中，或者通过使用**导入资源**菜单**（资源
    | 导入资源）：**![操作时间 — 导入资源包](img/978-1-84969-040-9_4_6.jpg)
- en: Once performed you will find that Unity has imported in the `.unitypackage`
    file in the **Project** view, but it has not expanded the assets into the familiar
    hierarchy that we had before. Unity doesn't know if you want all of the assets
    in the package and it is giving you the option to decide, rather than pollute
    your project with an unknown list of assets.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行，你会发现Unity已经将`.unitypackage`文件导入到**项目**视图中，但它并没有将资产展开成我们之前熟悉的层次结构。Unity不知道你是否想要包中的所有资产，它给你提供了选择的机会，而不是用一个未知的资产列表污染你的项目。
- en: Double-click on the `.unitypackage` file to have Unity expand the package into
    its component parts.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`.unitypackage`文件，让Unity将其展开成其组成部分。
- en: You will be presented with a dialog that lists everything that is in the package,
    as well as a note letting you know whether or not the assets are new. This is
    useful when sharing assets across projects, especially when the assets might have
    the same name.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到一个对话框，列出了包中的所有内容，以及一条注释，告诉你资产是否为新资产。这在跨项目共享资产时很有用，特别是当资产可能具有相同名称时。
- en: Select the **All** button to have Unity include all of the assets in the package:![Time
    for action — Importing asset packages](img/978-1-84969-040-9_4_7.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**全部**按钮，让Unity包含包中的所有资产：![执行动作 — 导入资产包](img/978-1-84969-040-9_4_7.jpg)
- en: Observe the **Project** view and you will find that all of the assets that you
    selected have been included in the Project and that the hierarchy for the assets
    has been preserved:![Time for action — Importing asset packages](img/978-1-84969-040-9_4_8.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察**项目**视图，你会发现你选择的全部资产都已包含在项目中，并且资产的层次结构已被保留：![执行动作 — 导入资产包](img/978-1-84969-040-9_4_8.jpg)
- en: Note
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although we didn't have a Library element in our package, or one in our Puppy
    Test project, Unity created this hierarchy and imported in the assets accordingly.
    It is this sort of information, and the settings associated with it, that would
    be lost if you managed the `Assets` folder manually.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们的包中没有库元素，或者在我们的Puppy Test项目中没有，Unity还是创建了这种层次结构，并相应地导入了资产。这种信息以及与之相关的设置，如果手动管理`Assets`文件夹，将会丢失。
- en: Delete the `unityproject` file from the Project Hierarchy since we have extracted
    the assets we're interested in.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经提取了我们感兴趣的资产，所以从项目层次结构中删除`unityproject`文件。
- en: What just happened?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just imported assets into a new project preserving the original hierarchy
    of the assets from the original project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将资产导入到一个新项目中，保留了从原始项目中资产的原有层次结构。
- en: While we have chosen to import all of the assets from the `unityproject` it
    is not necessary to do so. You can preview the assets that you want to import
    and uncheck those you'd rather not be included in your project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们选择了从`unityproject`导入所有资产，但这并不是必须的。你可以预览你想要导入的资产，并取消选中那些你不想包含在项目中的资产。
- en: Game Objects
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏对象
- en: Normally when you think of a Game Object you think of an animated soldier, a
    particle system, or a Sprite within a game. However, a Game Object is more of
    an abstract concept, a base object with no behaviors or functionality. Game Objects
    gain the ability to perform functions by having behaviors added to them. The approach
    through which this is done is the **Decorator** design pattern, which allows some
    arbitrary number of behaviors to be added to some base class. These behaviors,
    known as **Components** in the Unity vernacular, are what give a Game Object true
    meaning and definition. It is through Components that Game Objects have the ability
    to exist in a scene and have a position, rotation and scale.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当你想到游戏对象时，你会想到一个动画士兵、粒子系统或游戏中的精灵。然而，游戏对象更是一个抽象的概念，是一个没有行为或功能的基础对象。游戏对象通过添加行为来获得执行功能的能力。实现这一点的途径是**装饰器**设计模式，它允许向某个基础类添加任意数量的行为。这些行为，在Unity术语中被称为**组件**，是赋予游戏对象真正意义和定义的东西。正是通过组件，游戏对象才能够在场景中存在，并具有位置、旋转和缩放。
- en: Components
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: Components are decorators for Game Objects that provide additional behaviors
    and configuration to assets. Many of the core tenets of rendering, physics, audio,
    lighting, and so on are all accomplished by adding Components to objects. As such,
    many of the Unity concepts that we will cover have a computer graphics definition
    and a component which when attached to that Game Object provides the behavior.
    The best way to illustrate this concept is through some examples.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Game Object的装饰器，为资产提供额外的行为和配置。渲染、物理、音频、照明等许多核心原则都是通过向对象添加组件来实现的。因此，我们将涵盖的许多Unity概念都有计算机图形学定义和组件，当它们附加到Game
    Object上时提供行为。通过一些示例来展示这个概念是最好的方法。
- en: You might think that the easiest way to have a light is to have some concrete
    Light type that is defined in the system. However, suppose that you want a regular
    object such as a starship engine to have the ability to emit light? Certainly
    you can create a Light object and associate it with the engine model, but suppose
    that you also want it to emit smoke and be affected by physics, and play a sound?
    Immediately you would notice that your scene would be polluted with objects that
    aren't really relevant to the game — nevertheless they would show up in your hierarchy
    and you'd have to manage them. The more elegant way to accomplish this is to say
    that you have a starship engine and it has certain behaviors. These behaviors
    are the components that we'd associate with the object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为拥有光的最简单方法就是有一个在系统中定义的具体光类型。然而，假设你想要一个普通对象，比如一艘星际飞船的引擎，具有发光的能力？当然，你可以创建一个光对象并将其与引擎模型关联，但假设你还想让它冒烟并受到物理影响，以及播放声音？你立刻就会注意到你的场景会被一些与游戏无关的对象污染——尽管它们会出现在你的层次结构中，你还得管理它们。更优雅的方法是说明你有一个星际飞船引擎，并且它具有某些行为。这些行为是我们将与对象关联的组件。
- en: Even our standard Game Object gets its ability to have position, scale, and
    rotation from a Transform Component. In Unity's Inspector view what you are really
    looking at is the stack of components that are applied to this Game Object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是我们的标准Game Object，也是通过变换组件获得位置、缩放和旋转的能力。在Unity的检查器视图中，你实际上看到的是应用在这个Game Object上的组件堆栈。
- en: Let's take another example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子。
- en: Time for action — Adding components to Game Objects
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 向游戏对象添加组件
- en: In Unity, create an empty Game Object:![Time for action — Adding components
    to Game Objects](img/978-1-84969-040-9_4_9.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中创建一个空的游戏对象：![行动时间 — 向游戏对象添加组件](img/978-1-84969-040-9_4_9.jpg)
- en: Now let's add some components to this Game Object.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们给这个Game Object添加一些组件。
- en: 'In the **Component** menu you will find all of the components that you can
    add to this Game Object. In the **Rendering Submenu**, select the **Light** option:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**菜单中，你可以找到可以添加到这个Game Object的所有组件。在**渲染子菜单**中，选择**光**选项：
- en: '![Time for action — Adding components to Game Objects](img/978-1-84969-040-9_4_10.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 向游戏对象添加组件](img/978-1-84969-040-9_4_10.jpg)'
- en: What just happened?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'In Unity you will note that your Game Object now has a light behavior associated
    with it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，你会注意到你的Game Object现在有一个与之关联的光行为：
- en: '![What just happened?](img/978-1-84969-040-9_4_11.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/978-1-84969-040-9_4_11.jpg)'
- en: If you were to create a regular Light object from the **Hierarchy** menu you'd
    find that both objects are the same. This is because the **Light** Game Object
    is simply an empty Game Object with a **Light** component — simply configured
    appropriately for the type of light that you wanted to create. If you explore,
    you'd find that you could configure your light exactly the same as the stock light
    object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从**层次结构**菜单创建一个常规光对象，你会发现这两个对象是相同的。这是因为**光**Game Object只是一个带有**光**组件的空Game
    Object——简单地根据你想要创建的光的类型进行了适当的配置。如果你探索一下，你会发现你可以像库存光对象一样配置你的光。
- en: All of this should show you the possibilities that you have. You are not constrained
    by an arbitrary construction of objects by the Unity developers. In fact, you
    can create your own custom components as well and add those components to any
    Game Object that you desire.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都应该向你展示出你所拥有的可能性。你并不受限于Unity开发者任意构建的对象。实际上，你也可以创建自己的自定义组件，并将这些组件添加到任何你想要的Game
    Object中。
- en: Transform
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换
- en: 'A transform is the base concept of something in 3-dimensional space. It represents
    the position, rotation, and scale of an object and can contain links to child
    objects in a hierarchy. Every object in a scene has one of these, even if nothing
    is rendered. The **Transform Component** is the base component that every Game
    Object has and it is also the one that you cannot remove as it is necessary for
    your object to exist in 3D space:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 变换是三维空间中某物的基概念。它表示对象的定位、旋转和比例尺，并且可以包含对层次结构中子对象的链接。场景中的每个对象都有一个这样的变换，即使没有任何内容被渲染。**变换组件**是每个游戏对象都具有的基本组件，也是您不能移除的，因为它是对象存在于三维空间中所需的：
- en: '![Transform](img/978-1-84969-040-9_4_12.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/978-1-84969-040-9_4_12.jpg)'
- en: Time for action — Positioning, Rotating, and Scaling a Game Object
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 定位、旋转和缩放游戏对象
- en: Create a Cube Game Object.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体游戏对象。
- en: Change the position of the cube by changing the X value of the **Transform Component**
    to **10**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将**变换组件**的X值更改为**10**来更改立方体的位置。
- en: You will notice that the cube's position in the scene reflects this new location.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会注意到场景中立方体的位置反映了这个新位置。
- en: Change the rotation of the cube along the X-axis to **45**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立方体沿X轴的旋转更改为**45**。
- en: You have now rotated the cube 45 degrees along the X axis.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在已将立方体绕X轴旋转了45度。
- en: Change the scale of the cube's **Transform Component** to **10** on the X-axis.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立方体的**变换组件**的X轴比例尺更改为**10**。
- en: You have not scaled the object along its X-axis.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您尚未沿X轴缩放对象。
- en: What just happened?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'You can refine the location of an object within the scene by changing its **Position**
    attributes. These attributes represent where this object is in world space coordinates
    — the coordinate system of the scene itself. In addition, you can change the orientation
    of an object by adjusting its **Rotation** attributes. Finally, you can define
    an arbitrary scale for an object by updating the **Scale** attributes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改对象的**位置**属性来细化场景中对象的位置。这些属性表示该对象在世界空间坐标中的位置 — 场景本身的坐标系。此外，您可以通过调整对象的**旋转**属性来改变对象的朝向。最后，您可以通过更新**缩放**属性来为对象定义一个任意比例尺：
- en: '![What just happened?](img/978-1-84969-040-9_4_13.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/978-1-84969-040-9_4_13.jpg)'
- en: Camera
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相机
- en: 'The **Camera** provides the viewport through which the user can view the content
    within your scene. The camera will capture everything that is within its frustum
    and project that content onto the frame buffer for rasterization onto the 2D display.
    The frustum defines a geometric shape, which is used to clip Game Objects in the
    scene. If a Game Object isn''t within the frustum, the **Camera** assumes that
    it is not visible to the user and doesn''t waste cycles trying to draw it. This
    concept is important and will become even more important, when we discuss occlusion
    culling later in the book. For now, just note that the Near Clip plane, the Far
    Clip plane, and the **Field of View** define the shape of this object and all
    of these settings can be configured easily in the **Camera** Component:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**相机**提供了用户可以通过它查看场景内内容的视口。相机将捕获其视锥体内的所有内容，并将这些内容投影到帧缓冲区，以便在2D显示上进行光栅化。视锥体定义了一个几何形状，用于在场景中裁剪游戏对象。如果一个游戏对象不在视锥体内，**相机**会假设它对用户不可见，并且不会浪费周期去尝试绘制它。这个概念很重要，在我们稍后讨论遮挡剔除时将变得更加重要。现在，只需注意，近裁剪面、远裁剪面和**视野**定义了这个对象的形状，并且所有这些设置都可以在**相机**组件中轻松配置：'
- en: '![Camera](img/978-1-84969-040-9_4_14.jpg)![Camera](img/978-1-84969-040-9_4_15.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![相机](img/978-1-84969-040-9_4_14.jpg)![相机](img/978-1-84969-040-9_4_15.jpg)'
- en: Camera properties
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相机属性
- en: The Camera Component has several properties that define how much of the world
    the user will be able to see when the scene is rendered.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相机组件有几个属性定义了当场景渲染时用户将能看到多少世界。
- en: Near Clip
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 近裁剪面
- en: The near clip plane defines a plane such that objects closer to the camera are
    no longer displayed. This setting normally places the near clip fairly close to
    the camera so that objects can get close to the 'viewer' and not get clipped.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 近裁剪面定义了一个平面，使得靠近相机的对象不再显示。此设置通常将近裁剪面放置得相当靠近相机，以便对象可以靠近'观众'而不会被裁剪。
- en: Far Clip
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 远裁剪面
- en: The far clip plane defines a plane such that objects beyond this distance are
    too far away and should not be drawn. The setting you choose for this will have
    a fairly substantial impact on your game's performance. While you may be able
    to increase this setting very far in the distance, realize that those objects
    far off in the distance are being rendered and consuming resources as if they
    were closer. So if you raise the far clip out to your virtual horizon and there
    is a city out there, but it's only a few pixels in size, you're still drawing
    that city in all its splendor and taking the performance hit to do so, even though
    it's scarcely visible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 远裁剪平面定义了一个平面，使得距离这个平面以外的物体太远，不应该被绘制。你为这个设置的选择将对游戏性能产生相当大的影响。虽然你可能能够将这个设置延伸到很远的距离，但请意识到那些远处的物体正在被渲染并消耗资源，就像它们更近一样。所以如果你将远裁剪延伸到你的虚拟地平线，那里有一个城市，但城市的大小只有几个像素，你仍然会绘制出这个城市的全部辉煌，并为此付出性能上的代价，尽管它几乎看不见。
- en: Field of View (FOV)
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视野（FOV）
- en: 'The field of view defines how wide the viewport is along its Y-axis. This will
    impact how perspective of objects is computed and result in the object being taller/fatter
    based upon this setting:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 视野定义了视口沿Y轴的宽度。这将影响物体透视的计算，并导致物体根据此设置变得更高/更胖：
- en: '![Field of View (FOV)](img/978-1-84969-040-9_4_21.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![视野（FOV）](img/978-1-84969-040-9_4_21.jpg)'
- en: Camera projection types
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相机投影类型
- en: 'You can set any Unity camera to one of two projection types: orthographic projection
    and perspective projection. These projections determine how the world seen by
    the camera is rendered.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何Unity相机设置为两种投影类型之一：正交投影和透视投影。这些投影决定了相机所看到的世界的渲染方式。
- en: Orthographic projection
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正交投影
- en: A camera with orthographic projection removes the perspective correction from
    the camera's view and ensures that no matter how far an object is from the camera
    its distance will remain the same. The orthographic camera will be important when
    we build traditional 2-dimensional user interfaces and particularly important
    for 2D games.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正交投影的相机从相机视图中移除了透视校正，并确保无论物体距离相机有多远，其距离都保持不变。当我们构建传统的二维用户界面时，正交相机将非常重要，对于二维游戏尤其重要。
- en: Perspective projection
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 透视投影
- en: The perspective camera takes into account the distance of a Game Object from
    the viewer, and based upon this applies a perspective correction such that objects
    further away appear smaller than they really are. For most games this is the primary
    mechanism used to draw content.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 透视相机考虑了游戏对象与观察者之间的距离，并据此应用透视校正，使得远离观察者的物体看起来比实际更小。对于大多数游戏来说，这是绘制内容的主要机制。
- en: It is important to note that there are no constraints in Unity that require
    you to use one camera projection type or other in a scene. In fact, it is quite
    common to use multiple cameras for different purposes. You could, for example,
    have an orthographic camera that is responsible for drawing your user interface
    elements and a perspective camera that is responsible for your regular scene elements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在Unity中没有限制要求你在场景中使用一种相机投影类型而不是另一种。实际上，使用多个相机用于不同目的相当常见。例如，你可以有一个负责绘制用户界面元素的正交相机和一个负责常规场景元素的透视相机。
- en: Lights
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灯光
- en: 'Lights are straightforward in concept. They illuminate objects in the scene
    so that they can be seen. Without lights, objects will appear to be dark and lifeless.
    With lights you can add mood to a scene and, through the shadows that they cast,
    add depth to the world. There are three primary types of light in Unity: Directional
    lights, Point lights, and Spot lights.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光在概念上很简单。它们照亮场景中的物体，以便它们可以被看到。没有灯光，物体看起来会显得黑暗和没有生机。有了灯光，你可以为场景增添氛围，并通过它们投射的阴影为世界增加深度。Unity中有三种主要类型的灯光：方向光、点光源和聚光灯。
- en: Directional light
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方向光
- en: A Directional light is one that has an infinite distance from the scene. While
    you can position it in Unity, only the direction of the light is used in determining
    how the objects in the scene are lit. Directional lights are the cheapest lights
    that you can use in your scene. This is the fastest way to do global scene illumination
    as the position of the light doesn't impact how 'lit' something is within the
    scene, only the direction of the light.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 方向光是一种与场景距离无限远的灯光。虽然你可以在Unity中定位它，但场景中物体的照明仅使用光的方向来确定。方向光是你可以在场景中使用的最便宜的灯光。这是进行全局场景照明的最快方式，因为灯光的位置不会影响场景中某个物体的照明程度，只有光的方向。
- en: Point light
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点光源
- en: In contrast to the directional light, the Point Light is a light source that
    has a position in the scene, but no direction — emitting light equally in all
    directions. This light is of average computational complexity and generally used
    for most effects in a game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与方向光不同，点光源是一种在场景中具有位置但没有方向的光源——在所有方向上均匀地发射光线。这种光具有平均的计算复杂度，通常用于游戏中大多数效果。
- en: Spot light
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚光灯
- en: The most expensive light type, spot lights simulate the same effect that you
    would get from flashlights — a cone of light. This cone also has a fallout, such
    that light in the center of the cone is brighter than that at the edges of the
    cone. While there may be some situations where you might want to use a spot light,
    the expense of doing so on iOS devices makes this highly prohibitive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最昂贵的灯光类型，聚光灯模拟了你从手电筒中得到的效果——一个光锥。这个锥形也有衰减，使得锥形中心的灯光比锥形边缘的灯光更亮。虽然可能有一些情况下你可能想使用聚光灯，但在iOS设备上这样做的高成本使得这变得非常具有威慑力。
- en: Lightmapping
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光照贴图
- en: While you can accomplish tremendous things with lights that approach realistic
    lighting, to do so requires an exceptional amount of computing power. When considering
    the computational and graphical capabilities of mobile devices, computing lights
    in real time is a sure way to ensure that our games and applications will have
    poor performance. This can be remedied by using light maps.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以通过接近真实照明的灯光完成许多事情，但要这样做需要非凡的计算能力。在考虑移动设备的计算和图形能力时，实时计算灯光是确保我们的游戏和应用性能不佳的可靠方法。这可以通过使用光照贴图来纠正。
- en: Light maps are best described as lighting a scene and baking the effect of those
    lights on the scene. Since it is computationally cheaper to blend light maps with
    material textures, we can accomplish through light maps what would normal have
    required more expensive lights. As luck would have it, Unity has built in support
    for light maps through the industry-leading Beast light mapping system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 光照贴图最好描述为照亮场景并烘焙这些灯光对场景的影响。由于与材质纹理混合光照贴图在计算上更便宜，我们可以通过光照贴图实现通常需要更昂贵灯光的功能。幸运的是，Unity通过行业领先野兽光照贴图系统内置了对光照贴图的支持。
- en: With Beast you will be able to place lights in a scene, as you normally would,
    and Beast will compute the impact of those lights on the textures in the scene
    and create light maps for us. We can get exceptional results quickly and cheaply
    doing this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用野兽，你将能够像通常一样在场景中放置灯光，野兽将计算这些灯光对场景中纹理的影响，并为我们创建光照贴图。我们可以快速且低成本地获得卓越的结果。
- en: Lights and Beast light mapping will be covered in more detail in the chapter
    on lighting.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光和野兽光照贴图将在光照章节中更详细地介绍。
- en: Sound
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音
- en: Sound is an often-overlooked part of a good game and helps set the mood for
    the player. Watch your favorite movie (not a silent movie) with the sound turned
    off. You will notice that the experience is not as compelling as it was when the
    sound was on, and if this movie is something you know very well — you will find
    that your brain tries to fill in the blanks by recovering the dialogue and music
    from the movie in your memory. Sound is crucial for engagement and Unity has an
    arsenal of audio capabilities that cover the spectrum.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是游戏中经常被忽视的部分，有助于为玩家设定氛围。观看你最喜欢的电影（不是无声电影），关闭声音。你会发现，当声音打开时，体验并不像声音关闭时那么吸引人，如果你非常了解这部电影——你会发现你的大脑试图通过从记忆中恢复电影中的对话和音乐来填补空白。声音对于参与度至关重要，Unity拥有一系列音频功能，涵盖了整个频谱。
- en: Audio listener
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频监听器
- en: In the real-world, sound must be heard and if you are too far away from the
    emitter of the sound, you won't hear anything. Unity handles this concept of hearing
    through the audio listener. This Game Object is normally attached to the player's
    avatar, character, or other representation in the scene. The audio listener then
    acts as a microphone within your game world and anything that it hears — the player
    hears through the speakers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，声音必须被听到，如果你离声音的发射源太远，你就听不到任何声音。Unity通过音频监听器处理这种听到声音的概念。这个游戏对象通常附着在玩家的头像、角色或其他场景中的表示上。音频监听器在游戏世界中充当麦克风，它所听到的任何声音——玩家通过扬声器听到。
- en: By default, the audio listener is placed on the Main Camera in the scene. If
    you want the user to hear from the perspective of some other object, simply remove
    the audio listener from the Main Camera and attach it to the Game Object that
    you wish to represent the users center of hearing. In Unity, you cannot have multiple
    audio listeners active at the same time. While the audio listener is a component,
    it doesn't have any configurable properties.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，音频监听器放置在场景中的主摄像机上。如果你想用户从其他对象的视角听到声音，只需将音频监听器从主摄像机移除，并将其附加到你希望代表用户听觉中心的游戏对象上。在Unity中，你不能同时激活多个音频监听器。虽然音频监听器是一个组件，但它没有任何可配置的属性。
- en: Audio sources
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频源
- en: 'Audio sources represent things that make noise in the game world. You can add
    an audio source to a Game Object by selecting the Game Object and choosing **Component
    | Audio | Audio Source**. This will add the **Audio Source** component to your
    Game Object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 音频源代表游戏世界中制造噪音的事物。你可以通过选择游戏对象并选择**组件 | 音频 | 音频源**来向游戏对象添加音频源。这将向你的游戏对象添加**音频源**组件：
- en: '![Audio sources](img/978-1-84969-040-9_4_16.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![音频源](img/978-1-84969-040-9_4_16.jpg)'
- en: 'You will also see that in the **Scene** view your Game Object has a speaker
    icon on it. This denotes that this Game Object has an audio source component on
    it and generates sound:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到在**场景**视图中，你的游戏对象上有一个扬声器图标。这表示这个游戏对象上有一个音频源组件，并生成声音：
- en: '![Audio sources](img/978-1-84969-040-9_4_17.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![音频源](img/978-1-84969-040-9_4_17.jpg)'
- en: Audio clips
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频剪辑
- en: While we have created an audio source, we have not associated an actual sound
    with it. This sound is what Unity refers to as an audio clip. Unity supports audio
    clips in pretty much every format you can encode sound to including `.aif, .wav,
    .mp3, .ogg` and even the tracker formats of `.xm, .mod, .it` and `.s3m`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经创建了一个音频源，但我们还没有将其与实际的声音关联起来。这个声音就是Unity所说的音频剪辑。Unity支持几乎所有可以编码声音的格式，包括`.aif,
    .wav, .mp3, .ogg`，甚至还有`.xm, .mod, .it`和`.s3m`这样的跟踪器格式。
- en: Time for action — Adding audio clips
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音频剪辑的时间
- en: From the project folder for `Chapter 4` select the `dog_1.mp3` file and drag
    it into the **Project** view.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`第4章`的项目文件夹中选择`dog_1.mp3`文件，并将其拖动到**项目**视图中。
- en: The audio clip will be imported into Unity and will appear in the **Project**
    view designated by a speaker icon:![Time for action — Adding audio clips](img/978-1-84969-040-9_4_18.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 音频剪辑将被导入Unity，并出现在带有扬声器图标的**项目**视图中：![添加音频剪辑的时间](img/978-1-84969-040-9_4_18.jpg)
- en: Select the **Audio Clip** in the **Project** view. The **Inspector** will fill
    with all of the settings for the **Audio Clip:**![Time for action — Adding audio
    clips](img/978-1-84969-040-9_4_20.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中选择**音频剪辑**。**检查器**将填充所有**音频剪辑**的设置：![添加音频剪辑的时间](img/978-1-84969-040-9_4_20.jpg)
- en: Create a Cube Game Object.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体游戏对象。
- en: Add an **Audio Source** to the Cube Game Object.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**音频源**添加到立方体游戏对象上。
- en: In the Audio Source Game Object select the **Loop** checkbox to designate that
    we'd like this sound to play indefinitely.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在音频源游戏对象中，选择**循环**复选框以指定我们希望这个声音无限期地播放。
- en: To the right of the **Audio Source** property is a small round button. Press
    it to bring up the **Asset Browser**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**音频源**属性右侧有一个小圆按钮。按下它以打开**资产浏览器**。
- en: 'Select the **dog_1** asset from the browser:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从浏览器中选择**dog_1**资产：
- en: '![Time for action — Adding audio clips](img/978-1-84969-040-9_4_19.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![添加音频剪辑的时间](img/978-1-84969-040-9_4_19.jpg)'
- en: What just happened?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: You have just added sound to an object. Now when you play your scene, if you
    are close enough to that Game Object you will hear the sound. If you are having
    trouble, make sure that **Play on Awake** is checked in the **Audio Source**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚给一个对象添加了声音。现在当你播放场景时，如果你足够接近那个游戏对象，你将听到声音。如果你遇到麻烦，请确保在**音频源**中勾选了**唤醒时播放**。
- en: Scripts
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本
- en: When you create a script in Unity you are creating a new behavior that will
    be attached to a Game Object and that behavior will be invoked as Unity communicates
    with the Game Object during the rendering pipeline stages. Unity ships with a
    number of pre-defined scripts to do basic things such as FPS Control, iOS Joypad
    controls, and so on. However, you will find that for most things that you want
    to do you will be creating a script yourself.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Unity 中创建一个脚本时，你正在创建一个新的行为，该行为将被附加到一个游戏对象上，并且当 Unity 在渲染管线阶段与游戏对象通信时，该行为将被调用。Unity
    随带了一些预定义的脚本，用于执行基本操作，如 FPS 控制、iOS 游戏手柄控制等。然而，你会发现，对于你想要做的许多事情，你将需要自己创建脚本。
- en: Unity supports scripting using Javascript, C#, and Boo as the primary scripting
    languages, but given that Mono will work with any .Net language it is entirely
    possible to write your scripts using F# or even Java. However, you may find that
    since these paths are not officially supported, the cost to self-support your
    custom path may not be worth the effort.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 支持使用 Javascript、C# 和 Boo 作为主要脚本语言进行脚本编写，但鉴于 Mono 可以与任何 .Net 语言一起工作，你完全可以使用
    F# 或甚至 Java 来编写脚本。然而，你可能发现，由于这些路径没有得到官方支持，自支持自定义路径的成本可能不值得付出努力。
- en: Internally, Unity utilizes the Mono/.Net compilation path for all of the scripts
    that you have in your project. The underlying language implementation for C# and
    Javascript scripting within the Unity frameworks are all extending functionality
    from Boo. You will find that it is very easy to create new scripts, import functionality
    from .Net assemblies, or even extend the language by interfacing directly with
    the **abstract syntax tree (AST)** generated during the build phase. During the
    build phase, Unity will cause all scripts to be compiled statically, embedded
    with your application, and deployed to the device.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Unity 使用 Mono/.Net 编译路径来编译你项目中的所有脚本。Unity 框架中 C# 和 Javascript 脚本的基础语言实现都是扩展了
    Boo 的功能。你会发现创建新的脚本、从 .Net 程序集导入功能，甚至通过直接与构建阶段生成的 **抽象语法树 (AST)** 接口来扩展语言都非常容易。在构建阶段，Unity
    将导致所有脚本被静态编译，嵌入到你的应用程序中，并部署到设备上。
- en: Editors
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑器
- en: 'There are two editors available for scripting with Unity: Unitron and MonoDevelop.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 Unity 进行脚本编写，有两个可用的编辑器：Unitron 和 MonoDevelop。
- en: '**Unitron** is the original script editor that ships with Unity and will be
    active by default. It is lightweight and fast, but lacks all of the modern conveniences
    of a traditional IDE. As your projects get more complex, you will find that having
    a robust IDE is essential and may want to move to a more professional editor:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unitron** 是随 Unity 一起提供的原始脚本编辑器，默认情况下会处于激活状态。它轻量且快速，但缺乏传统 IDE 的所有现代便利功能。随着你的项目变得越来越复杂，你会发现拥有一个强大的
    IDE 是必不可少的，并且可能想要迁移到一个更专业的编辑器：'
- en: '![Editors](img/978-1-84969-040-9_4_22.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器](img/978-1-84969-040-9_4_22.jpg)'
- en: '**MonoDevelop** was introduced in Unity3 as a higher productivity option for
    developers that needed something that had support for functions such as code completion,
    better key binding support, add-Ins, refactoring, metrics, and so on. **MonoDevelop**
    is a solution that has been around nearly as long as Mono, and since it is open
    source and supported on all the platforms that Unity utilizes it makes an ideal
    choice for development:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**MonoDevelop** 在 Unity3 中被引入，作为开发者所需的一种更高生产力的选项，它支持诸如代码补全、更好的键绑定支持、插件、重构、度量等功能。**MonoDevelop**
    是一个与 Mono 一样历史悠久且开源的解决方案，由于它在 Unity 所使用的所有平台上都得到支持，因此它成为开发的一个理想选择：'
- en: '![Editors](img/978-1-84969-040-9_4_23.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器](img/978-1-84969-040-9_4_23.jpg)'
- en: 'To change which editor you use, enter the **Unity Preferences** ( **Unity |
    Preferences** ) and in the **General** tab change the **External Script Editor**
    to your editor of choice. If you want to use **MonoDevelop**, you will find it
    in the `/Applications/Unity` folder. After selecting it, when you double-click
    on a script from any of Unity''s languages the editor will launch and allow you
    to update the script. Changes you make to a script and save will be available
    immediately to Unity, and any errors in the script will immediately show up in
    the **Unity Console** view:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改你使用的编辑器，进入 **Unity 首选项**（**Unity | 首选项**），然后在 **常规** 选项卡中将 **外部脚本编辑器**更改为你选择的编辑器。如果你想使用
    **MonoDevelop**，你可以在 `/Applications/Unity` 文件夹中找到它。选择它后，当你双击 Unity 任何语言中的一个脚本时，编辑器将启动并允许你更新脚本。你对脚本所做的更改和保存将立即对
    Unity 可用，并且脚本中的任何错误将立即在 **Unity 控制台**视图中显示：
- en: '![Editors](img/978-1-84969-040-9_4_24.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器](img/978-1-84969-040-9_4_24.jpg)'
- en: We will cover scripting in more detail in the next chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更详细地介绍脚本。
- en: Prefabs
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预制体
- en: A Prefab is a reusable collection of meshes, scripts, animations, and so on
    that you want to use in a scene. Prefabs are a core component of any Unity project,
    but when starting out it may not be immediately clear why you want to adopt them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 预制体是一组可重复使用的网格、脚本、动画等，你希望在场景中使用。预制体是任何Unity项目的核心组件，但在开始时，可能并不立即清楚为什么你想采用它们。
- en: Let's pretend that this is our enemy in our hot seller "Red Cubes must Die"
    and we need to add more red cubes. We don't want to go through all the steps to
    try to create this cube again. Your first thought might be to copy/paste the cube,
    and that will work. But now you've decided that instead of a red color you want
    a red flame texture. Do you go back to all of the cubes in the scene and change
    the texture? This may work for a small number of objects, but imagine doing this
    in a complex scene.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假装这是我们热门卖家“红色方块必须死”中的敌人，我们需要添加更多的红色方块。我们不想走所有步骤来尝试再次创建这个方块。你的第一个想法可能是复制/粘贴方块，这会起作用。但现在你决定，与其是红色，你想要红色火焰纹理。你会回到场景中的所有方块并更改纹理吗？这可能适用于少量对象，但想象一下在一个复杂的场景中这样做。
- en: Worse still suppose you've just imported a lot of mesh data and set up the textures
    for a zombie in your hack and slash game. You scaled him to fit your scene and
    made sure all the animations work properly. However, this is just one of the many
    zombies you plan on putting into this level. Certainly you don't want to have
    to do this for every zombie that is going to be in the game.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，假设你刚刚导入了大量网格数据，并在你的横版游戏中为僵尸设置了纹理。你将其缩放到适合你的场景，并确保所有动画都能正常工作。然而，这只是你计划放入这个关卡中的许多僵尸之一。当然，你不想为游戏中每个将要出现的僵尸都这样做。
- en: Time for action — Creating prefabs
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 — 创建预制体
- en: Create a new scene in the project by selecting **File | New Scene.**
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**文件 | 新场景**在项目中创建一个新的场景。
- en: Save the scene.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: Create a Cube Prefab.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方块预制体。
- en: Create a new **Material** from the **Assets** menu by selecting **Assets | Create
    | Material**.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**资产**菜单中选择**资产 | 创建 | 材质**创建一个新的**材质**。
- en: Select the **Material** in the **Project** view.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目视图**中选择**材质**。
- en: In the **Inspector**, select the **Main Color** selector and set the color of
    the material to **red**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，选择**主颜色**选择器，并将材料的颜色设置为**红色**。
- en: Assign the Material to the Cube by dragging the Material onto the Cube in the
    **Hierarchy** view:![Time for action — Creating prefabs](img/978-1-84969-040-9_4_25.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将材料拖动到**层次结构**视图中的方块上，将材料分配给方块：![动手实践 — 创建预制体](img/978-1-84969-040-9_4_25.jpg)
- en: Create a new **Prefab** in the **Project View** by selecting **Create | Prefab:**![Time
    for action — Creating prefabs](img/978-1-84969-040-9_4_26.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**创建 | 预制体**在**项目视图**中创建一个新的**预制体**：![动手实践 — 创建预制体](img/978-1-84969-040-9_4_26.jpg)
- en: Let's rename it to **EvilBox** so that we know that when we use this **Prefab**
    we are creating the Red Cubes that have to die:![Time for action — Creating prefabs](img/978-1-84969-040-9_4_27.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将其重命名为**EvilBox**，这样我们就可以知道当我们使用这个**预制体**时，我们正在创建必须死的红色方块：![动手实践 — 创建预制体](img/978-1-84969-040-9_4_27.jpg)
- en: Next we will take the Red Cube that we created earlier and drag it onto the
    **EvilBox** prefab. When you do this you will notice that the Cube and the **EvilBox**
    prefab are both highlighted in blue. This notes that the prefab now has all of
    the settings of the original object:![Time for action — Creating prefabs](img/978-1-84969-040-9_4_28.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把之前创建的红色方块拖动到**EvilBox**预制体上。当你这样做时，你会注意到方块和**EvilBox**预制体都高亮显示为蓝色。这表示预制体现在具有原始对象的全部设置：![动手实践
    — 创建预制体](img/978-1-84969-040-9_4_28.jpg)
- en: Delete the original Cube from the **Hierarchy view**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构视图**中删除原始方块。
- en: 'Drag the **EvilBox** prefab into the scene several times and you will notice
    that new objects are created in the **Hierarchy** view. These new **GameObjects**
    are Instances of the original prefab template:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**EvilBox**预制体拖入场景几次，你会在**层次结构**视图中注意到创建了新的对象。这些新的**游戏对象**是原始预制体模板的实例：
- en: '![Time for action — Creating prefabs](img/978-1-84969-040-9_4_29.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践 — 创建预制体](img/978-1-84969-040-9_4_29.jpg)'
- en: What just happened?
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just created a reusable prefab object for our game. This Prefab object
    has a well defined appearance and behavior which can be duplicated over and over.
    More important still, if you need to change the **EvilBox** because someone told
    you that it's really blue boxes that are evil, you can select the **Prefab** and
    change its settings and all of the instances will change accordingly as every
    instance of a prefab is tied to its template's properties.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的游戏创建了一个可重复使用的预制对象。这个预制对象具有定义良好的外观和行为，可以重复使用。更重要的是，如果您需要更改**EvilBox**，因为有人告诉您真正邪恶的是蓝色的盒子，您可以选择**预制件**并更改其设置，所有实例都将相应地更改，因为预制件的每个实例都与其模板属性相关联。
- en: If, for some reason, you change one of the instances of a Prefab Instances in
    a material way, the Instance will change from being blue back to the default gray
    color. This denotes that the Prefab no longer represents the Instance. But suppose
    that you wanted to take the settings of the Instance and make it the new default?
    To accomplish this, drag the child instance that you changed from the Hierarchy
    over to the Prefab and you will see that the settings of the Prefab are updated
    with those of the instance and that the instance itself is now linked with the
    prefab again.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，您以某种方式更改了预制实例的一个实例，该实例将从蓝色变为默认的灰色颜色。这表示预制件不再代表实例。但假设您想将实例的设置用作新的默认设置？要完成此操作，将您更改的子实例从层次结构拖动到预制件上，您将看到预制件的设置已更新为实例的设置，并且实例本身现在再次与预制件链接。
- en: Scene
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景
- en: 'The Scene is the place where all of your action takes place. From a Unity perspective
    the words Scene and Level are synonymous and there are times when the tool uses
    the terms interchangeably. You can create new scenes from the **File** menu:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 场景是所有动作发生的地方。从Unity的角度来看，场景和级别这两个词是同义的，有时工具会交替使用这两个术语。您可以从**文件**菜单创建新的场景：
- en: '![Scene](img/978-1-84969-040-9_4_30.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![场景](img/978-1-84969-040-9_4_30.jpg)'
- en: Once created and saved, a Scene will show up in the **Project** view and have
    a Unity icon next to it. If you're ever looking for your scene you can find it
    in the `Assets` folder of your project with a `.unity` extension.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并保存后，场景将在**项目**视图中显示，并在其旁边有一个Unity图标。如果您在寻找场景，可以在项目的`Assets`文件夹中找到它，文件扩展名为`.unity`。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned to speak in the language of Unity. You now have knowledge
    of all the core concepts and how to use them so we can graduate from the newbie
    cube examples and take on more complex projects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了用Unity的语言说话。您现在掌握了所有核心概念及其使用方法，因此我们可以从新手立方体示例毕业，承担更复杂的项目。
- en: Now that we've learned about the core concepts, we're ready to build our first
    really complex application which will utilize all of the concepts that we have
    covered through scripting, which is the topic of the next chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了核心概念，我们准备构建我们的第一个真正复杂的应用程序，该应用程序将利用我们在脚本中涵盖的所有概念，这是下一章的主题。
