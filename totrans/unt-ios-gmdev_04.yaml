- en: Chapter 4. Unity Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built our first application and have a taste for what Unity
    is capable of, it's time to learn the core concepts of Unity so that we can build
    much more complex and compelling games. We have briefly discussed some of the
    core concepts already, but to build compelling content it is necessary to have
    a more in-depth understanding of how Unity uses these concepts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the core concepts of Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the core components within the tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts of Unity development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When studying a foreign language you will spend some time immersing yourself
    in its nouns and verbs so that you can understand the concepts and begin creating
    sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An asset represents the atomic unity through which you can construct a scene
    in Unity. Anything that you bring into the environment is considered an asset
    including sound files, textures, models, scripts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can import assets into a Unity project by either dragging and dropping them
    from the desktop into the **Project** view, or by using the **Import New Asset**
    menu **(Assets | Import New Asset)**. Once in the **Project** view the asset is
    something that can be used in your game. Think of the **Project** view as your
    palette from which you will paint your world.
  prefs: []
  type: TYPE_NORMAL
- en: Assets are managed on the file system by Unity. If you go into your project
    folder and look at the `Assets` directory you will find all of the assets that
    are in your project. When Unity imports your assets, it will store the imported
    asset and all of its metadata here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that you should never try to manage assets in this folder
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: While you can make changes to textures, audio, models, and so on, in this location
    with your various tools you should never move them as this will break the link
    between the asset and the Unity metadata for the asset. In effect, Unity will
    behave as if you just brought this asset into Unity for the first time and any
    relationships, settings, and so on will have to be newly created.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Exporting asset packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be times when you want to share a collection of assets with other
    users on your team or within the community. Unity makes this easier by providing
    a simple mechanism called Packages. A **package** is just a collection of assets
    bundled together in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise we''re going to explore how one would share assets from an
    existing project with other developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project for this chapter named **HelloWorld2**. In it you will find
    a version of our original Hello World demo with some additional assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the assets that you want to export as part of the package:![Time for
    action — Exporting asset packages](img/978-1-84969-040-9_4_5 2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the above illustration the **Materials** element within the **Project** has
    been selected. There are **Puppy** and **Grass** materials that are a child of
    the **Materials** element and they will be bundled in the package as well. If
    you only wanted to share the **Puppy** materials you would simply select the **Puppy**
    element and only those materials would be packaged.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next let's create a package using the **Export Package** menu **(Assets | Export
    Package)**. When selected, this will create a package starting with the selected
    item in the **Project** view and anything that is a child of this element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity will then display a dialog with all of the assets that will be exported.
    If there are assets that you want to remove, uncheck its checkbox:![Time for action
    — Exporting asset packages](img/978-1-84969-040-9_4_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, there is a checkbox labeled **Include dependencies**. If your assets
    have other assets, such as scripts, that they depend on, keeping this box checked
    tells Unity to include those assets in the package.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the **Export** button and, in the subsequent file dialog, provide a name
    for the Unity package file. Unity will create and compress the assets into a file
    with the extension `.unitypackage:`![Time for action — Exporting asset packages](img/978-1-84969-040-9_4_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a Unity package that contains all of the assets we selected.
    This is the ideal way to share assets with your team as any settings, hierarchies,
    and so on will be preserved when those assets are imported.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Importing asset packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a growing number of third party companies who are providing assets
    specifically packaged for Unity developers, including the Unity Asset Store which
    can be accessed from within the Unity product. All of these solutions provide
    content through the same `.unitypackage` format described in the section Time
    for action — — Exporting asset packages. With assets from the Unity Asset store,
    the process of including the assets in your project is automatic. However, there
    may be times when you have received assets from others and need to import them
    into your project yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Project in Unity called **Project Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `.unitypackage` file you built from the Exporting Assets Time for
    action — , import into your project by dragging the `.unitypackage` file into
    the **Project** view at the location in your project hierarchy where you'd like
    them to be stored, or by using the **Import Assets** menu **(Assets | Import Asset):**![Time
    for action — Importing asset packages](img/978-1-84969-040-9_4_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once performed you will find that Unity has imported in the `.unitypackage`
    file in the **Project** view, but it has not expanded the assets into the familiar
    hierarchy that we had before. Unity doesn't know if you want all of the assets
    in the package and it is giving you the option to decide, rather than pollute
    your project with an unknown list of assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `.unitypackage` file to have Unity expand the package into
    its component parts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be presented with a dialog that lists everything that is in the package,
    as well as a note letting you know whether or not the assets are new. This is
    useful when sharing assets across projects, especially when the assets might have
    the same name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **All** button to have Unity include all of the assets in the package:![Time
    for action — Importing asset packages](img/978-1-84969-040-9_4_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the **Project** view and you will find that all of the assets that you
    selected have been included in the Project and that the hierarchy for the assets
    has been preserved:![Time for action — Importing asset packages](img/978-1-84969-040-9_4_8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we didn't have a Library element in our package, or one in our Puppy
    Test project, Unity created this hierarchy and imported in the assets accordingly.
    It is this sort of information, and the settings associated with it, that would
    be lost if you managed the `Assets` folder manually.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete the `unityproject` file from the Project Hierarchy since we have extracted
    the assets we're interested in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just imported assets into a new project preserving the original hierarchy
    of the assets from the original project.
  prefs: []
  type: TYPE_NORMAL
- en: While we have chosen to import all of the assets from the `unityproject` it
    is not necessary to do so. You can preview the assets that you want to import
    and uncheck those you'd rather not be included in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Game Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally when you think of a Game Object you think of an animated soldier, a
    particle system, or a Sprite within a game. However, a Game Object is more of
    an abstract concept, a base object with no behaviors or functionality. Game Objects
    gain the ability to perform functions by having behaviors added to them. The approach
    through which this is done is the **Decorator** design pattern, which allows some
    arbitrary number of behaviors to be added to some base class. These behaviors,
    known as **Components** in the Unity vernacular, are what give a Game Object true
    meaning and definition. It is through Components that Game Objects have the ability
    to exist in a scene and have a position, rotation and scale.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components are decorators for Game Objects that provide additional behaviors
    and configuration to assets. Many of the core tenets of rendering, physics, audio,
    lighting, and so on are all accomplished by adding Components to objects. As such,
    many of the Unity concepts that we will cover have a computer graphics definition
    and a component which when attached to that Game Object provides the behavior.
    The best way to illustrate this concept is through some examples.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that the easiest way to have a light is to have some concrete
    Light type that is defined in the system. However, suppose that you want a regular
    object such as a starship engine to have the ability to emit light? Certainly
    you can create a Light object and associate it with the engine model, but suppose
    that you also want it to emit smoke and be affected by physics, and play a sound?
    Immediately you would notice that your scene would be polluted with objects that
    aren't really relevant to the game — nevertheless they would show up in your hierarchy
    and you'd have to manage them. The more elegant way to accomplish this is to say
    that you have a starship engine and it has certain behaviors. These behaviors
    are the components that we'd associate with the object.
  prefs: []
  type: TYPE_NORMAL
- en: Even our standard Game Object gets its ability to have position, scale, and
    rotation from a Transform Component. In Unity's Inspector view what you are really
    looking at is the stack of components that are applied to this Game Object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take another example.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Adding components to Game Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, create an empty Game Object:![Time for action — Adding components
    to Game Objects](img/978-1-84969-040-9_4_9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's add some components to this Game Object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the **Component** menu you will find all of the components that you can
    add to this Game Object. In the **Rendering Submenu**, select the **Light** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Adding components to Game Objects](img/978-1-84969-040-9_4_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Unity you will note that your Game Object now has a light behavior associated
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/978-1-84969-040-9_4_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you were to create a regular Light object from the **Hierarchy** menu you'd
    find that both objects are the same. This is because the **Light** Game Object
    is simply an empty Game Object with a **Light** component — simply configured
    appropriately for the type of light that you wanted to create. If you explore,
    you'd find that you could configure your light exactly the same as the stock light
    object.
  prefs: []
  type: TYPE_NORMAL
- en: All of this should show you the possibilities that you have. You are not constrained
    by an arbitrary construction of objects by the Unity developers. In fact, you
    can create your own custom components as well and add those components to any
    Game Object that you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A transform is the base concept of something in 3-dimensional space. It represents
    the position, rotation, and scale of an object and can contain links to child
    objects in a hierarchy. Every object in a scene has one of these, even if nothing
    is rendered. The **Transform Component** is the base component that every Game
    Object has and it is also the one that you cannot remove as it is necessary for
    your object to exist in 3D space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transform](img/978-1-84969-040-9_4_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action — Positioning, Rotating, and Scaling a Game Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Cube Game Object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the position of the cube by changing the X value of the **Transform Component**
    to **10**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that the cube's position in the scene reflects this new location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the rotation of the cube along the X-axis to **45**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now rotated the cube 45 degrees along the X axis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the scale of the cube's **Transform Component** to **10** on the X-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have not scaled the object along its X-axis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can refine the location of an object within the scene by changing its **Position**
    attributes. These attributes represent where this object is in world space coordinates
    — the coordinate system of the scene itself. In addition, you can change the orientation
    of an object by adjusting its **Rotation** attributes. Finally, you can define
    an arbitrary scale for an object by updating the **Scale** attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/978-1-84969-040-9_4_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Camera** provides the viewport through which the user can view the content
    within your scene. The camera will capture everything that is within its frustum
    and project that content onto the frame buffer for rasterization onto the 2D display.
    The frustum defines a geometric shape, which is used to clip Game Objects in the
    scene. If a Game Object isn''t within the frustum, the **Camera** assumes that
    it is not visible to the user and doesn''t waste cycles trying to draw it. This
    concept is important and will become even more important, when we discuss occlusion
    culling later in the book. For now, just note that the Near Clip plane, the Far
    Clip plane, and the **Field of View** define the shape of this object and all
    of these settings can be configured easily in the **Camera** Component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Camera](img/978-1-84969-040-9_4_14.jpg)![Camera](img/978-1-84969-040-9_4_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Camera properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Camera Component has several properties that define how much of the world
    the user will be able to see when the scene is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Near Clip
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The near clip plane defines a plane such that objects closer to the camera are
    no longer displayed. This setting normally places the near clip fairly close to
    the camera so that objects can get close to the 'viewer' and not get clipped.
  prefs: []
  type: TYPE_NORMAL
- en: Far Clip
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The far clip plane defines a plane such that objects beyond this distance are
    too far away and should not be drawn. The setting you choose for this will have
    a fairly substantial impact on your game's performance. While you may be able
    to increase this setting very far in the distance, realize that those objects
    far off in the distance are being rendered and consuming resources as if they
    were closer. So if you raise the far clip out to your virtual horizon and there
    is a city out there, but it's only a few pixels in size, you're still drawing
    that city in all its splendor and taking the performance hit to do so, even though
    it's scarcely visible.
  prefs: []
  type: TYPE_NORMAL
- en: Field of View (FOV)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The field of view defines how wide the viewport is along its Y-axis. This will
    impact how perspective of objects is computed and result in the object being taller/fatter
    based upon this setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Field of View (FOV)](img/978-1-84969-040-9_4_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Camera projection types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can set any Unity camera to one of two projection types: orthographic projection
    and perspective projection. These projections determine how the world seen by
    the camera is rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: Orthographic projection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A camera with orthographic projection removes the perspective correction from
    the camera's view and ensures that no matter how far an object is from the camera
    its distance will remain the same. The orthographic camera will be important when
    we build traditional 2-dimensional user interfaces and particularly important
    for 2D games.
  prefs: []
  type: TYPE_NORMAL
- en: Perspective projection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The perspective camera takes into account the distance of a Game Object from
    the viewer, and based upon this applies a perspective correction such that objects
    further away appear smaller than they really are. For most games this is the primary
    mechanism used to draw content.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there are no constraints in Unity that require
    you to use one camera projection type or other in a scene. In fact, it is quite
    common to use multiple cameras for different purposes. You could, for example,
    have an orthographic camera that is responsible for drawing your user interface
    elements and a perspective camera that is responsible for your regular scene elements.
  prefs: []
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lights are straightforward in concept. They illuminate objects in the scene
    so that they can be seen. Without lights, objects will appear to be dark and lifeless.
    With lights you can add mood to a scene and, through the shadows that they cast,
    add depth to the world. There are three primary types of light in Unity: Directional
    lights, Point lights, and Spot lights.'
  prefs: []
  type: TYPE_NORMAL
- en: Directional light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Directional light is one that has an infinite distance from the scene. While
    you can position it in Unity, only the direction of the light is used in determining
    how the objects in the scene are lit. Directional lights are the cheapest lights
    that you can use in your scene. This is the fastest way to do global scene illumination
    as the position of the light doesn't impact how 'lit' something is within the
    scene, only the direction of the light.
  prefs: []
  type: TYPE_NORMAL
- en: Point light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to the directional light, the Point Light is a light source that
    has a position in the scene, but no direction — emitting light equally in all
    directions. This light is of average computational complexity and generally used
    for most effects in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Spot light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most expensive light type, spot lights simulate the same effect that you
    would get from flashlights — a cone of light. This cone also has a fallout, such
    that light in the center of the cone is brighter than that at the edges of the
    cone. While there may be some situations where you might want to use a spot light,
    the expense of doing so on iOS devices makes this highly prohibitive.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While you can accomplish tremendous things with lights that approach realistic
    lighting, to do so requires an exceptional amount of computing power. When considering
    the computational and graphical capabilities of mobile devices, computing lights
    in real time is a sure way to ensure that our games and applications will have
    poor performance. This can be remedied by using light maps.
  prefs: []
  type: TYPE_NORMAL
- en: Light maps are best described as lighting a scene and baking the effect of those
    lights on the scene. Since it is computationally cheaper to blend light maps with
    material textures, we can accomplish through light maps what would normal have
    required more expensive lights. As luck would have it, Unity has built in support
    for light maps through the industry-leading Beast light mapping system.
  prefs: []
  type: TYPE_NORMAL
- en: With Beast you will be able to place lights in a scene, as you normally would,
    and Beast will compute the impact of those lights on the textures in the scene
    and create light maps for us. We can get exceptional results quickly and cheaply
    doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Lights and Beast light mapping will be covered in more detail in the chapter
    on lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sound is an often-overlooked part of a good game and helps set the mood for
    the player. Watch your favorite movie (not a silent movie) with the sound turned
    off. You will notice that the experience is not as compelling as it was when the
    sound was on, and if this movie is something you know very well — you will find
    that your brain tries to fill in the blanks by recovering the dialogue and music
    from the movie in your memory. Sound is crucial for engagement and Unity has an
    arsenal of audio capabilities that cover the spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: Audio listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the real-world, sound must be heard and if you are too far away from the
    emitter of the sound, you won't hear anything. Unity handles this concept of hearing
    through the audio listener. This Game Object is normally attached to the player's
    avatar, character, or other representation in the scene. The audio listener then
    acts as a microphone within your game world and anything that it hears — the player
    hears through the speakers.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the audio listener is placed on the Main Camera in the scene. If
    you want the user to hear from the perspective of some other object, simply remove
    the audio listener from the Main Camera and attach it to the Game Object that
    you wish to represent the users center of hearing. In Unity, you cannot have multiple
    audio listeners active at the same time. While the audio listener is a component,
    it doesn't have any configurable properties.
  prefs: []
  type: TYPE_NORMAL
- en: Audio sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Audio sources represent things that make noise in the game world. You can add
    an audio source to a Game Object by selecting the Game Object and choosing **Component
    | Audio | Audio Source**. This will add the **Audio Source** component to your
    Game Object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Audio sources](img/978-1-84969-040-9_4_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will also see that in the **Scene** view your Game Object has a speaker
    icon on it. This denotes that this Game Object has an audio source component on
    it and generates sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Audio sources](img/978-1-84969-040-9_4_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Audio clips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we have created an audio source, we have not associated an actual sound
    with it. This sound is what Unity refers to as an audio clip. Unity supports audio
    clips in pretty much every format you can encode sound to including `.aif, .wav,
    .mp3, .ogg` and even the tracker formats of `.xm, .mod, .it` and `.s3m`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Adding audio clips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the project folder for `Chapter 4` select the `dog_1.mp3` file and drag
    it into the **Project** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The audio clip will be imported into Unity and will appear in the **Project**
    view designated by a speaker icon:![Time for action — Adding audio clips](img/978-1-84969-040-9_4_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Audio Clip** in the **Project** view. The **Inspector** will fill
    with all of the settings for the **Audio Clip:**![Time for action — Adding audio
    clips](img/978-1-84969-040-9_4_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Cube Game Object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **Audio Source** to the Cube Game Object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Audio Source Game Object select the **Loop** checkbox to designate that
    we'd like this sound to play indefinitely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the right of the **Audio Source** property is a small round button. Press
    it to bring up the **Asset Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **dog_1** asset from the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Adding audio clips](img/978-1-84969-040-9_4_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have just added sound to an object. Now when you play your scene, if you
    are close enough to that Game Object you will hear the sound. If you are having
    trouble, make sure that **Play on Awake** is checked in the **Audio Source**.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a script in Unity you are creating a new behavior that will
    be attached to a Game Object and that behavior will be invoked as Unity communicates
    with the Game Object during the rendering pipeline stages. Unity ships with a
    number of pre-defined scripts to do basic things such as FPS Control, iOS Joypad
    controls, and so on. However, you will find that for most things that you want
    to do you will be creating a script yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Unity supports scripting using Javascript, C#, and Boo as the primary scripting
    languages, but given that Mono will work with any .Net language it is entirely
    possible to write your scripts using F# or even Java. However, you may find that
    since these paths are not officially supported, the cost to self-support your
    custom path may not be worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Unity utilizes the Mono/.Net compilation path for all of the scripts
    that you have in your project. The underlying language implementation for C# and
    Javascript scripting within the Unity frameworks are all extending functionality
    from Boo. You will find that it is very easy to create new scripts, import functionality
    from .Net assemblies, or even extend the language by interfacing directly with
    the **abstract syntax tree (AST)** generated during the build phase. During the
    build phase, Unity will cause all scripts to be compiled statically, embedded
    with your application, and deployed to the device.
  prefs: []
  type: TYPE_NORMAL
- en: Editors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two editors available for scripting with Unity: Unitron and MonoDevelop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unitron** is the original script editor that ships with Unity and will be
    active by default. It is lightweight and fast, but lacks all of the modern conveniences
    of a traditional IDE. As your projects get more complex, you will find that having
    a robust IDE is essential and may want to move to a more professional editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editors](img/978-1-84969-040-9_4_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**MonoDevelop** was introduced in Unity3 as a higher productivity option for
    developers that needed something that had support for functions such as code completion,
    better key binding support, add-Ins, refactoring, metrics, and so on. **MonoDevelop**
    is a solution that has been around nearly as long as Mono, and since it is open
    source and supported on all the platforms that Unity utilizes it makes an ideal
    choice for development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editors](img/978-1-84969-040-9_4_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To change which editor you use, enter the **Unity Preferences** ( **Unity |
    Preferences** ) and in the **General** tab change the **External Script Editor**
    to your editor of choice. If you want to use **MonoDevelop**, you will find it
    in the `/Applications/Unity` folder. After selecting it, when you double-click
    on a script from any of Unity''s languages the editor will launch and allow you
    to update the script. Changes you make to a script and save will be available
    immediately to Unity, and any errors in the script will immediately show up in
    the **Unity Console** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editors](img/978-1-84969-040-9_4_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will cover scripting in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Prefab is a reusable collection of meshes, scripts, animations, and so on
    that you want to use in a scene. Prefabs are a core component of any Unity project,
    but when starting out it may not be immediately clear why you want to adopt them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that this is our enemy in our hot seller "Red Cubes must Die"
    and we need to add more red cubes. We don't want to go through all the steps to
    try to create this cube again. Your first thought might be to copy/paste the cube,
    and that will work. But now you've decided that instead of a red color you want
    a red flame texture. Do you go back to all of the cubes in the scene and change
    the texture? This may work for a small number of objects, but imagine doing this
    in a complex scene.
  prefs: []
  type: TYPE_NORMAL
- en: Worse still suppose you've just imported a lot of mesh data and set up the textures
    for a zombie in your hack and slash game. You scaled him to fit your scene and
    made sure all the animations work properly. However, this is just one of the many
    zombies you plan on putting into this level. Certainly you don't want to have
    to do this for every zombie that is going to be in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Creating prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new scene in the project by selecting **File | New Scene.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Cube Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Material** from the **Assets** menu by selecting **Assets | Create
    | Material**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Material** in the **Project** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector**, select the **Main Color** selector and set the color of
    the material to **red**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the Material to the Cube by dragging the Material onto the Cube in the
    **Hierarchy** view:![Time for action — Creating prefabs](img/978-1-84969-040-9_4_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Prefab** in the **Project View** by selecting **Create | Prefab:**![Time
    for action — Creating prefabs](img/978-1-84969-040-9_4_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's rename it to **EvilBox** so that we know that when we use this **Prefab**
    we are creating the Red Cubes that have to die:![Time for action — Creating prefabs](img/978-1-84969-040-9_4_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we will take the Red Cube that we created earlier and drag it onto the
    **EvilBox** prefab. When you do this you will notice that the Cube and the **EvilBox**
    prefab are both highlighted in blue. This notes that the prefab now has all of
    the settings of the original object:![Time for action — Creating prefabs](img/978-1-84969-040-9_4_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original Cube from the **Hierarchy view**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the **EvilBox** prefab into the scene several times and you will notice
    that new objects are created in the **Hierarchy** view. These new **GameObjects**
    are Instances of the original prefab template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Creating prefabs](img/978-1-84969-040-9_4_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just created a reusable prefab object for our game. This Prefab object
    has a well defined appearance and behavior which can be duplicated over and over.
    More important still, if you need to change the **EvilBox** because someone told
    you that it's really blue boxes that are evil, you can select the **Prefab** and
    change its settings and all of the instances will change accordingly as every
    instance of a prefab is tied to its template's properties.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, you change one of the instances of a Prefab Instances in
    a material way, the Instance will change from being blue back to the default gray
    color. This denotes that the Prefab no longer represents the Instance. But suppose
    that you wanted to take the settings of the Instance and make it the new default?
    To accomplish this, drag the child instance that you changed from the Hierarchy
    over to the Prefab and you will see that the settings of the Prefab are updated
    with those of the instance and that the instance itself is now linked with the
    prefab again.
  prefs: []
  type: TYPE_NORMAL
- en: Scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Scene is the place where all of your action takes place. From a Unity perspective
    the words Scene and Level are synonymous and there are times when the tool uses
    the terms interchangeably. You can create new scenes from the **File** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scene](img/978-1-84969-040-9_4_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once created and saved, a Scene will show up in the **Project** view and have
    a Unity icon next to it. If you're ever looking for your scene you can find it
    in the `Assets` folder of your project with a `.unity` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned to speak in the language of Unity. You now have knowledge
    of all the core concepts and how to use them so we can graduate from the newbie
    cube examples and take on more complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about the core concepts, we're ready to build our first
    really complex application which will utilize all of the concepts that we have
    covered through scripting, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
