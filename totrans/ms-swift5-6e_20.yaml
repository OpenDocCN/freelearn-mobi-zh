- en: '20'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adopting Design Patterns in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the first publication of the *Gang of Four''s Design Patterns: Elements
    of Reusable Object-Oriented Software* was released in October 1994, I have only
    been paying attention to design patterns for the last 14 years. Like most experienced
    developers, when I first started reading about design patterns, I recognized a
    lot of the patterns because I had already been using them without realizing what
    they were. I would have to say that since I first read about design patterns,
    I have not written a serious application without using at least one of them. I
    will tell you that I am definitely not a design pattern zealot, and if I get into
    a conversation about design patterns, there are usually only a couple of them
    that I can name without having to look them up. But one thing that I do remember
    is the concepts behind the major patterns and the problems they are designed to
    solve. This way, when I encounter one of these problems, I can look up the appropriate
    pattern and apply it. So, remember, as you go through this chapter, to take the
    time to understand the major concepts behind design patterns rather than trying
    to memorize the patterns themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are design patterns?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What types of patterns make up the creational, structural, and behavioral categories
    of design patterns?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the singleton and builder creational patterns in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the bridge, facade, and proxy structural patterns in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the command and strategy behavioral patterns in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are design patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every experienced developer has a set of informal strategies that shape how
    they design and write applications. These strategies are shaped by their past
    experiences and the obstacles that they have had to overcome in previous projects.
    While these developers might swear by their own strategies, it does not mean that
    their strategies have been fully vetted. The use of these strategies can also
    introduce inconsistent implementations between different projects and developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the concept of design patterns dates back to the mid-1980s, they did
    not gain popularity until the Gang of Four released *Elements of Reusable Object-Oriented
    Software*, published in 1994\. The book''s authors, Erich Gamma, Richard Helm,
    Ralph Johnson, and John Vlissides (also known as the Gang of Four), discuss the
    pitfalls of object-oriented programming and describe 23 classic software design
    patterns. These patterns are broken up into three categories: *creational*, *structural*,
    and *behavioral*.'
  prefs: []
  type: TYPE_NORMAL
- en: A design pattern identifies common software development problems and provides
    a strategy to deal with them. These strategies have been proven, over the years,
    to be an effective solution for the problems they are intended to solve. Using
    these patterns can greatly speed up the development process because they provide
    us with solutions that have been proven to solve common software development problems.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage that we get when using design patterns is consistent code
    that is easy to maintain because months or years from now when we look at the
    code, we will recognize the patterns and understand what the code does. If we
    properly document the code and document the design pattern we are implementing,
    it will also help other developers to understand what the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: The two main philosophies behind design patterns are code reuse and flexibility.
    As a software architect, it is essential that we build reusability and flexibility
    into the code. This allows us to easily maintain the code in the future and also
    makes it easier for the applications to expand to meet future requirements, because
    we all know how quickly requirements change.
  prefs: []
  type: TYPE_NORMAL
- en: While there is a lot to like about design patterns, and they are extremely beneficial
    for developers and architects, they are not the solution to world hunger that
    some developers make them out to be. Sometime in your development career, you
    will probably meet a developer or an architect who thinks that design patterns
    are immutable laws. These developers usually try to force the use of design patterns
    even when they are not necessary. A good rule of thumb is to make sure that you
    have a problem that needs to be fixed before you try to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are starting points for avoiding and solving common programming
    problems. We can think of each design pattern as a recipe. Just like a good recipe,
    we can tinker and adjust it to meet particular tastes. But we usually do not want
    to stray too far from the original recipe because we may mess it up.
  prefs: []
  type: TYPE_NORMAL
- en: There are also times when we do not have a recipe for a certain dish that we
    want to make, just like there are times when there isn't a design pattern to solve
    the problem we face. In cases like this, we can use our knowledge of design patterns
    and their underlying philosophy to come up with an effective solution for the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Design patterns are generally split into three categories. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: Creational patterns support the creation of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: Structural patterns concern types and object compositions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral patterns**: Behavioral patterns communicate between types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the Gang of Four defined over 20 design patterns, we are only going to
    look at examples of some of the more popular patterns in this chapter. Let's start
    off by looking at creational patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns were originally defined for object-oriented programming. In
    this chapter, where possible, we will focus on implementing patterns in a more
    protocol-oriented way. Therefore, the examples in this chapter may look a little
    different from examples in other design pattern books, but the underlying philosophy
    of the solutions will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational patterns are design patterns that deal with how an object is created.
    These patterns create objects in a manner suitable for a particular situation.
  prefs: []
  type: TYPE_NORMAL
- en: There are two basic ideas behind creational patterns. The first is encapsulating
    the knowledge of *which* concrete types should be created and the second is hiding
    *how* the instances of these types are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five well-known patterns that are a part of the creational pattern
    category. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The abstract factory pattern**: This provides an interface for creating related
    objects without specifying the concrete type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The builder pattern**: This separates the construction of a complex object
    from its representation, so the same process can be used to create similar types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The factory method pattern**: This creates objects without exposing the underlying
    logic of how the object (or which type of object) is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The prototype pattern**: This creates an object by cloning an existing one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The singleton pattern**: This allows one (and only one) instance of a class
    for the lifetime of an application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to show examples of how to implement the singleton
    and builder patterns in Swift. Let's start off by looking at one of the most controversial
    and possibly overused design patterns, the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the **singleton pattern** is a fairly controversial subject among
    certain corners of the development community. One of the main reasons for this
    is that the singleton pattern is probably the most overused and misused pattern.
    Another reason this pattern is controversial is that it introduces a global state
    into an application, which provides the ability to change the object at any point
    within the application. The singleton pattern can also introduce hidden dependencies
    and tight compiling. My personal opinion is that, if the singleton pattern is
    used correctly, there is nothing wrong with using it. However, we do need to be
    careful not to misuse it.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern restricts the instantiation of a class to a single instance
    for the lifetime of an application. This pattern is very effective when we need
    exactly one object to coordinate actions within the application. An example of
    a good use of a singleton is if the application communicates with a remote device
    over Bluetooth and we also want to maintain that connection throughout the application.
    Some would say that we could pass the instance of the connection class from one
    page to the next, which is essentially what a singleton is. In my opinion, the
    singleton pattern, in this instance, is a much cleaner solution, because with
    the singleton pattern any page that needs the connection can get it without forcing
    every page to maintain the instance. This also allows us to maintain the connection
    without having to reconnect each time we go to another page.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem that the singleton pattern is designed to address is when we need
    one and only one instance of a type for the lifetime of the application. The singleton
    pattern is usually used when we need centralized management of an internal or
    external resource, and a single global point of access. Another popular use of
    the singleton pattern is when we want to consolidate a set of related activities
    needed throughout the application that do not maintain a state in one place.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Protocols and Protocol Extensions*, we used the singleton pattern
    in the text validation example. In that example, we used the singleton pattern
    because we wanted to create a single instance of the types that could then be
    used by all the components of the application without requiring us to create new
    instances of the types. These text validation types did not have a state that
    could be changed. They only had methods that performed the validation on the text
    and constants that defined how to validate the text. While some may disagree with
    me, I believe types like these are excellent candidates for the singleton pattern
    because there is no reason to create multiple instances of these types.
  prefs: []
  type: TYPE_NORMAL
- en: In that example, we implemented it using structures, which isn't a true singleton
    because a structure is a value type. A true singleton is implemented using a reference
    (class) type.
  prefs: []
  type: TYPE_NORMAL
- en: When using the singleton pattern, one of the biggest concerns is multi-threaded
    applications with race conditions. The issue occurs when one thread changes the
    state of the singleton while another thread is accessing it, producing unexpected
    results. As an example, if the `TextValidation` classes stored the text to be
    validated and then we called a method to do the validation, one thread could change
    the stored text before the original thread did the validation. It is advisable
    to understand how a singleton will be used in your application, before implementing
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways to implement the singleton pattern in Swift. In the method
    that we use here, a single instance of the class is created the first time the
    class constant is accessed. We will then use the class constant to gain access
    to this instance throughout the lifetime of the application. We will also create
    a private initializer that will prevent external code from creating additional
    instances of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use the word *class* in this description and not *type*. The reason
    for this is that the singleton pattern can only truly be implemented using a reference
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the singleton pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at how we implement the singleton pattern with Swift. The following
    code example shows how to create a singleton class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, within the `MySingleton` class, we created a static constant
    named `sharedInstance`, which contains an instance of the `MySingleton` class.
    A static constant can be called without having to instantiate the class. Since
    we declared the `sharedInstance` constant static, only one instance will exist
    throughout the lifecycle of the application, thereby creating the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We also created the private initiator, which cannot be accessed outside of the
    class, which will restrict other code from creating additional instances of the
    `MySingleton` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how this pattern works. The `MySingleton` pattern has another
    property, named `number`, which is an integer. We will monitor how this property
    changes as we use the `sharedInstance` property to create multiple variables of
    the `MySingleton` type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `sharedInstance` property to create three variables
    of the `MySingleton` type. We initially set the `number` property of the second
    `MySingleton` variable (`singleB`) to the number `2`. When we printed out the
    value of the `number` property for the `singleA`, `singleB`, and `singleC` instances,
    we saw that the `number` property for all three equaled `2`.
  prefs: []
  type: TYPE_NORMAL
- en: We then changed the value of the `number` property of the third `MySingleton`
    instance (`singleC`) to the number `3`. When we printed out the value of the `number`
    property again, we saw that all three now have a value of `3`. Therefore, when
    we change the value of the `number` property in any of the instances, the values
    of all three change because each variable is pointed to the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we implemented the singleton pattern using a reference (class)
    type because we wanted to ensure that only one instance of the type existed throughout
    the application. If we implemented this pattern with a value type, such as a structure
    or an enumeration, we would run the risk of there being multiple instances of
    the type.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, each time we pass an instance of a value type, we are actually
    passing a copy of that instance, which means that, if we implemented the singleton
    pattern with a value type, each time we called the `sharedInstance` property we
    would receive a new copy, which would effectively break the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern can be very useful when we need to maintain the state
    of an object throughout the application; however, be careful not to overuse it.
    The singleton pattern should not be used unless there is a specific requirement
    (*requirement* is the keyword here) for having one, and only one, instance of
    the class throughout the lifecycle of the application. If we are using the singleton
    pattern simply for convenience, then we are probably misusing it.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, while Apple generally recommends that we prefer value types
    to reference types, there are still plenty of examples, such as the singleton
    pattern, where we need to use reference types. When we continually tell ourselves
    to prefer value types to reference types, it can be very easy to forget that there
    are times when a reference type is needed. Don't forget to use reference types
    with this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the builder design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **builder pattern** helps us with the creation of complex objects and enforces
    the process of how these objects are created. With this pattern, we generally
    separate the creation logic from the complex type and put the creation logic into
    another type. This allows us to use the same construction process to create different
    representations of the type.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem that the builder pattern is designed to address is when an instance
    of a type requires a large number of configurable values. We could set the configuration
    options when we create instances of the class, but that can cause issues if the
    options are not set correctly or we do not know the proper values for all the
    options. Another issue is the amount of code that may be needed to set all the
    configurable options each time we create an instance of the types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The builder pattern solves this problem by introducing an intermediary known
    as a builder type. This builder type contains most, if not all, of the information
    necessary to create an instance of the original complex type.
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods that we can use to implement the builder pattern. The
    first method is to have multiple builder types where each of the types contains
    the information to configure the original complex object in a specific way. In
    the second method, we implement the builder pattern with a single builder type
    that sets all the configurable options to a default value, and then we would change
    the values as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at both ways to use the builder pattern, because
    it is important to understand how each works.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the builder pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we show how we would use the builder pattern, let's look at how to create
    a complex structure without the builder pattern and the problems we run into.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a structure named `BurgerOld`, and does not use
    the builder pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `BurgerOld` structure, we have several properties that define which
    condiments are on the burger and the name of the burger. Since we need to know
    which items are on the burgers and which items aren''t, when we create an instance
    of the `BurgerOld` structure, the initializer requires us to define each item.
    This can lead to some complex initializations throughout the application, not
    to mention that, if we had more than one standard burger (bacon cheeseburger,
    cheeseburger, hamburger, and so on), we would need to make sure that each is defined
    correctly. Let''s see how to create instances of the `BurgerOld` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, creating instances of the `BurgerOld` type requires a lot of
    code. Now, let''s look at a better way to do this. In this example, we will show
    how to use multiple builder types where each type will define what goes on each
    type of burger. We will begin by creating a `BurgerBuilder` protocol that will
    have the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This protocol simply defines the nine properties that will be required for
    any type that implements this protocol. Now, let''s create two structures that
    implement this protocol: the `HamburgerBuilder` and `CheeseBurgerBuilder` structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In both the `HamburgerBuilder` and the `CheeseBurgerBuilder` structures, all
    we are doing is defining the values for each of the required properties. In more
    complex types, we might need to initialize additional resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `Burger` structure, which will use instances of the
    `BurgerBuilder` protocol to create instances of itself. The following code shows
    this new `Burger` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between this `Burger` structure and the `BurgerOld` structure
    shown earlier is the initializer. In the previous `BurgerOld` structure, the initializer
    took nine arguments—one for each constant defined in the structure. In the new
    structure, the initializer takes one argument, which is an instance of a type
    that conforms to the `BurgerBuilder` protocol. This new initializer allows us
    to create instances of the `Burger` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we compare how we create instances of the new `Burger` structure to the earlier
    `BurgerOld` structure, we can see that it is much easier to create instances of
    the `Burger` structure. We also know that we are correctly setting the property
    values for each type of burger because the values are set directly in the builder
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, there is a second method that we can use to implement
    the builder pattern. Rather than having multiple builder types, we can have a
    single builder type that sets all the configurable options to a default value;
    then we change the values as needed. I use this implementation method a lot when
    I am updating older code because it is easy to integrate it with preexisting code.
  prefs: []
  type: TYPE_NORMAL
- en: For this implementation, we will create a single `BurgerBuilder` structure.
    This structure will be used to create instances of the `BurgerOld` structure and
    will, by default, set all the ingredients to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BurgerBuilder` structure also gives us the ability to change which ingredients
    will go on the burger prior to creating instances of the `BurgerOld` structure.
    We create the `BurgerBuilder` structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the `BurgerBuilder` structure, we define the nine properties (ingredients)
    for the burger and then create a setter method for each of the properties except
    for the `name` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also create one method named `buildBurgerOld()`, which will create an instance
    of the `BurgerOld` structure based on the values of the properties for the `BurgerBuilder`
    instance. We use the `BurgerBuilder` structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create an instance of the `BurgerBuilder` structure. We
    then use the `setCheese()` and `setBacon()` methods to add cheese and bacon to
    the burger. Finally, we call the `buildBurgerOld()` method to create the instance
    of the `burgerOld` structure.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, both methods that were used to implement the builder pattern
    greatly simplify the creation of the complex type. Both methods also ensured that
    the instances were properly configured with default values. If you find yourself
    creating instances of types with very long and complex initialization commands,
    I recommend that you look at the builder pattern to see if you can use it to simplify
    the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structural design patterns** describe how types can be combined to form larger
    structures. These larger structures can generally be easier to work with and hide
    a lot of the complexity of the individual types. Most patterns in the structural
    pattern category involve connections between objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are seven well-known patterns that are part of the structural design
    pattern type. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapter**: This allows types with incompatible interfaces to work together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge**: This is used to separate the abstract elements of a type from the
    implementation so the two can vary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: This allows us to treat a group of objects as a single object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: This lets us add or override behavior in an existing method
    of an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facade**: This provides a simplified interface for a larger and more complex
    body of code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flyweight**: This allows us to reduce the resources needed to create and
    use a large number of similar objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: This is a type acting as an interface for another class or classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to give examples of how to use the bridge, facade,
    and proxy patterns in Swift. Let's start off by looking at the bridge pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **bridge pattern** decouples the abstraction from the implementation so
    that they can both vary independently. The bridge pattern can also be thought
    of as a two-layer abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bridge pattern is designed to solve a couple of problems, but the one we
    are going to focus on here tends to arise over time as new requirements come in
    with new features. At some point, as these come in, we will need to change how
    the features interact. Eventually, this will require us to refactor the code.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, this is known as an exploding class hierarchy,
    but it can also happen in protocol-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bridge pattern solves this problem by taking the interacting features and
    separating the functionality that is specific to each feature from the functionality
    that is shared between them. A bridge type can then be created, which will encapsulate
    the shared functionality, bringing them together.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the bridge pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate how we would use the bridge pattern, we will create two features.
    The first feature is a message feature that will store and prepare a message that
    we wish to send out. The second feature is the sender feature that will send the
    message through a specific channel, such as email or SMS messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start off by creating two protocols named `Message` and `Sender`. The
    `Message` protocol will define the requirements for types that are used to create
    messages. The `Sender` protocol will be used to define the requirements for types
    that are used to send the messages through the specific channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we define these two protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Message` protocol defines a single property named `messageString` of the
    `String` type. This property will contain the text of the message and cannot be
    nil. We also define one initiator and a method named `prepareMessage()`. The initializer
    will be used to set the `messageString` property and anything else required by
    the message type. The `prepareMessage()` method will be used to prepare the message
    prior to sending it. This method can be used to encrypt the message or add formatting.
  prefs: []
  type: TYPE_NORMAL
- en: The `Sender` protocol defines a method named `sendMessage()`. This method will
    send the message through the channel defined by conforming types. In this function,
    we will need to ensure that the `prepareMessage()` method from the message type
    is called prior to sending the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we define two types that conform to the `Message` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each of these types contains the required functionality to conform to the `Message`
    protocol. The only real difference between these types is in the `prepareMessage()`
    methods. In the `PlainTextMessage` class, the `prepareMessage()` method is empty
    because we do not need to do anything to the message prior to sending it. The
    `prepareMessage()` method of the `DESEncryptionMessage` class would normally contain
    the logic to encrypt the message, but for this example we will just prepend a
    `DES` tag to the beginning of the message, letting us know that this method was
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create two types that will conform to the `Sender` protocol. These
    types would typically handle sending the message through a specific channel; however,
    in the example, we will simply print a message to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Both the `EmailSender` and the `SMSSender` types conform to the `Sender` protocol
    by implementing the `sendMessage()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use these two features, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will work well, and we could add code similar to this anywhere we need
    to create and send a message. Now let's say that, one day in the near future,
    we get a requirement to add a new functionality to verify the message prior to
    sending it, to make sure it meets the requirements of the channel we are sending
    the message through.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we would start off by changing the `Sender` protocol to add the
    `verify` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `Sender` protocol would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To the `Sender` protocol, we added a method named `verifyMessage()` and added
    a property named `Message`. We also changed the definition of the `sendMessage()`
    method. The original `Sender` protocol was designed to simply send the message,
    but now we need to verify the message prior to calling the `sendMessage()` function;
    therefore, we couldn't simply pass the message to it, as we did in the previous
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will need to change the types that conform to the `Sender` protocol
    to make them conform to this new protocol. The following code shows how we would
    make these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the changes that we made to the types that conform to the `Sender` protocol,
    we will need to change how the code uses these types. The following example shows
    how we can now use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These changes are not that hard to make; however, without the bridge pattern,
    we would need to refactor the entire code base and make the change everywhere
    that we are sending messages. The bridge pattern tells us that when we have two
    hierarchies that closely interact together like this, we should put this interaction
    logic into a bridge type that will encapsulate the logic in one spot. This way,
    when we receive new requirements or enhancements, we can make the change in one
    spot, thereby limiting the refactoring that we must do. We could make a bridge
    type for the message and sender hierarchies, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The logic of how the messaging and sender hierarchies interact is now encapsulated
    into the `MessagingBridge` structure. Now, when the logic needs to change, we
    only need to make the change to this one structure rather than having to refactor
    the entire code base.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge pattern is a very good pattern to remember and use. There have been
    (and still are) times that I have regretted not using the bridge pattern in my
    code because, as we all know, requirements change frequently, and being able to
    make the changes in one spot rather than throughout the code base can save us
    a lot of time in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the next pattern in the structural category: the facade
    pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **facade pattern** provides a simplified interface to a larger and more
    complex body of code. This allows us to make the libraries easier to use and understand
    by hiding some of the complexities. It also allows us to combine multiple APIs
    into a single, easier-to-use API, which is what we will see in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The facade pattern is often used when we have a complex system that has a large
    number of independent APIs that are designed to work together. Sometimes it is
    hard to tell where we should use the facade pattern during the initial application
    design. The reason for this is that we normally try to simplify the initial API
    design; however, over time, and as requirements change and new features are added,
    the APIs become more and more complex, and then it becomes evident where the facade pattern
    should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main idea of the facade pattern is to hide the complexity of the APIs behind
    a simple interface. This offers us several advantages, the most obvious being
    that it simplifies how we interact with the APIs. It also promotes loose coupling,
    which allows the APIs to change as requirements change, without the need to refactor
    all the code that uses them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the facade pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate the facade pattern, we will create three APIs: `HotelBooking`,
    `FlightBooking`, and `RentalCarBooking`. These APIs will be used to search for
    and book hotels, flights, and rental cars for trips. While we could very easily
    call each of the APIs individually in the code, we are going to create a `TravelFacade`
    structure that will allow us to access the functionality of the APIs in single
    calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by defining the three APIs. Each of the APIs will need a data
    storage class that will store the information about the hotel, flight, or rental
    car. We will start off by implementing the hotel API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The hotel API consists of the `Hotel` and `HotelBooking` structures. The `Hotel`
    structure will be used to store the information about a hotel room, and the `HotelBooking`
    structure will be used to search for a hotel room and to book the room for the
    trip. The flight and rental car APIs are very similar to the hotel API. The following
    code shows both of these APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In each of these APIs, we have a structure that is used to store information
    and a structure that is used to provide the search/booking functionality. In the
    initial design, it would be very easy to call these individual APIs within the
    application; however, as we all know, requirements tend to change, which causes
    the APIs to change over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the facade pattern here, we are able to hide how we implement the
    APIs; therefore, if we need to change how the APIs work in the future, we will
    only need to update the facade type rather than refactoring all of the code. This
    makes the code easier to maintain and update in the future. Now let''s look at
    how we will implement the facade pattern by creating a `TravelFacade` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `TravelFacade` class contains the functionality to search the three APIs
    and book a hotel, flight, and rental car. We can now use the `TravelFacade` class
    to search for hotels, flights, and rental cars without having to directly access
    the individual APIs.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the start of this chapter, it is not always obvious when
    we should use the facade pattern in the initial design.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good rule to follow is: if we have several APIs that are working together
    to perform a task, we should think about using the facade pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the last structural pattern, which is the proxy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the **proxy design pattern**, there is one type acting as an interface for
    another type or API. This wrapper class, which is the proxy, can then add functionality
    to the object, make the object available over a network, or restrict access to
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the proxy pattern to solve several problems, but I find that I mainly
    use this pattern to solve one of two problems.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem that I use this pattern to solve is when I want to create
    a layer of abstraction between a single API and my code. The API could be a local
    or remote API, but I usually use this pattern to put an abstraction layer between
    my code and a remote service. This will allow changes to the remote API without
    the need to refactor large portions of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem that I use the proxy pattern to solve is when I need to make
    changes to an API, but I do not have the code or there is already a dependency
    on the API elsewhere in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To solve these problems, the proxy pattern tells us that we should create a
    type that will act as an interface for interacting with the other type or API.
    In the example, we will show how to use the proxy pattern to add functionality
    to an existing type.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the proxy pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate the proxy pattern by creating a house
    class that we can add multiple floor plans to, where each floor plan represents
    a different story of the house. Let''s begin by creating a `FloorPlan` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `FloorPlan` protocol, we define five properties that will represent
    the number of rooms contained in each floor plan. Now, let''s create an implementation
    of the `FloorPlan` protocol named `HouseFloorPlan`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HouseFloorPlan` structure implements all five properties required from
    the `FloorPlan` protocol and assigns default values to them. Next, we will create
    the `House` type, which will represent a house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Within the `House` structure, we have an array of instances that conforms to
    the `FloorPlan` protocol where each floor plan will represent one story of the
    house. We also have a function named `addStory()`, which accepts an instance of
    a type that conforms to the `FloorPlan` protocol. This function will add the floor
    plan to the array of `FloorPlan` protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we think about the logic of this class, there is one problem that we might
    encounter: we are allowed to add as many floor plans as we want, which may lead
    to houses that are 60 or 70 stories high. This would be great if we were building
    skyscrapers, but we just want to build basic single-family houses. If we want
    to limit the number of floor plans without changing the `House` class (either
    we cannot change it, or we simply do not want to), we can implement the proxy
    pattern. The following example shows how to implement the `HouseProxy` class,
    where we limit the number of floor plans we can add to the house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin the `HouseProxy` class by creating an instance of the `House` class.
    We then create a method named `addStory()`, which lets us add a new floor plan
    to the house. In the `addStory()` method, we check to see if the number of stories
    in the house is fewer than three; if so, we add the floor plan to the house and
    return `true`. If the number of stories is equal to or greater than three, then
    we do not add the floor plan to the house and return `false`. Let''s see how we
    can use this proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the example code, we start off by creating an instance of the `HouseProxy`
    class named `ourHouse`. We then create four instances of the `HouseFloorPlan`
    type, each with a different number of rooms. Finally, we attempt to add each of
    the floor plans to the `ourHouse` instance. If we run this code, we will see that
    the first three instances of the `floorplans` class were added to the house successfully,
    but the last one wasn't because we are only allowed to add three floors.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern is very useful when we want to add some additional functionality
    or error checking to a type, but we do not want to change the actual type itself.
    We can also use it to add a layer of abstraction between a remote or local API.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at behavioral design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral design patterns explain how types interact with each other. These
    patterns describe how different instances of types send messages to each other
    to make things happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are nine well-known patterns that are part of the behavioral design pattern
    type. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain of responsibility**: This is used to process a variety of requests,
    each of which may be delegated to a different handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: This creates objects that can encapsulate actions or parameters
    so that they can be invoked later or by a different component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator**: This allows us to access the elements of an object sequentially
    without exposing the underlying structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mediator**: This is used to reduce coupling between types that communicate
    with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: This is used to capture the current state of an object and store
    it in a manner that can be restored later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: This allows an object to publish changes to an object''s state.
    Other objects can then subscribe so they can be notified of any changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: This is used to alter the behavior of an object when its internal
    state changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: This allows one out of a family of algorithms to be chosen at
    runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: This is a way of separating an algorithm from an object structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we are going to give examples of how to use strategy and command
    patterns in Swift. Let's start off by looking at the command pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command design pattern lets us define actions that we can execute later.
    This pattern generally encapsulates all the information needed to call or trigger
    the actions at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times in applications when we need to separate the execution of a
    command from its invoker. Typically, this is when we have a type that needs to
    perform one of several actions, but the choice of which action to use needs to
    be made at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The command pattern tells us that we should encapsulate the logic for the actions
    into a type that conforms to a command protocol. We can then provide instances
    of the command types for use by the invoker. The invoker will use the interface
    provided by the protocol to invoke the necessary actions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the command pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate how to use the command pattern by creating
    a `Light` type. In this type, we will define the `lightOnCommand` and `lightOffCommand`
    commands and will use the `turnOnLight()` and `turnOffLight()` methods to invoke
    these commands. We will begin by creating a protocol named `Command`, which all
    of the command types will conform to. Here is the `Command` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This protocol contains a method named `execute()`, which will be used to execute
    the command. Now, let''s look at the command types that the `Light` type will
    use to turn the light on and off. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RockerSwitchLightOffCommand`, `RockerSwitchLightOnCommand`, `PullSwitchLightOnCommand`,
    and `PullSwitchLightOffCommand` commands all conform to the `Command` protocol
    by implementing the `execute()` method; therefore, we will be able to use them
    in the `Light` type. Now, let''s look at how to implement the `Light` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the `Light` type, we start off by creating two variables, named `lightOnCommand`
    and `lightOffCommand`, which will contain instances of types that conform to the
    `Command` protocol. Then we create the `turnOnLight()` and `turnOffLight()` methods
    that we will use to turn the light on and off. In these methods, we call the appropriate
    command to turn the light on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would then use the `Light` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by creating an instance of the `PullSwitchLightOnCommand`
    type named `on` and an instance of the `PullSwitchLightOffCommand` type named
    `off`. We then create an instance of the `Light` type using the two commands that
    we just created and call the `turnOnLight()` and `turnOffLight()` methods of the
    `Light` instance to turn the light on and off. In the last two lines, we change
    the `lightOnCommand` method, which was originally set to an instance of the `PullSwitchLightOnCommand`
    class, to an instance of the `RockerSwitchLightOnCommand` type. The `Light` instance
    will now use the `RockerSwitchLightOnCommand` type whenever we turn the light
    on. This allows us to change the functionality of the `Light` type during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There are several benefits of using the command pattern. One of the main benefits
    is that we are able to set which command to invoke at runtime, which also lets
    us swap the commands out with different implementations that conform to the `Command`
    protocol as needed throughout the life of the application. Another advantage of
    the command pattern is that we encapsulate the details of command implementations
    within the command types themselves rather than in the container type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the last design pattern, the strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy pattern is pretty similar to the command pattern in that they both
    allow us to decouple implementation details from the calling type, and also allow
    us to switch the implementation out at runtime. The big difference is that the
    strategy pattern is intended to encapsulate algorithms. By swapping out an algorithm,
    we are expecting the object to perform the same functionality, but in a different
    way. In the command pattern, when we swap out the commands, we are expecting the
    object to change the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times in applications when we need to change the backend algorithm
    that is used to perform an operation. Typically, this is when we have a type that
    has several different algorithms that can be used to perform the same task, but
    the choice of which algorithm to use needs to be made at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The strategy pattern tells us that we should encapsulate the algorithm in a
    type that conforms to a strategy protocol. We can then provide instances of the
    strategy types for use by the invoker. The invoker will use the interface provided
    by the protocol to invoke the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the strategy pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate the strategy pattern by showing you how
    we could swap out compression algorithms at runtime. Let''s begin this example
    by creating a `CompressionStrategy` protocol that each one of the compression
    types will conform to. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This protocol defines a method named `compressFiles()` that accepts a single
    parameter, which is an array of strings that contains the paths to the files we
    want to compress. We will now create two structures that conform to this protocol.
    These are the `ZipCompressionStrategy` and `RarCompressionStrategy` structures,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Both of these structures implement the `CompressionStrategy` protocol by using
    a method named `compressFiles()`, which accepts an array of strings. Within these
    methods, we simply print out the name of the compression that we are using. Normally,
    we would implement the compression logic in these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `CompressContent` class, which will be used to compress
    the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we start off by defining a variable, named `strategy`, which
    will contain an instance of a type that conforms to the `CompressionStrategy`
    protocol. Then we create a method named `compressFiles()`, which accepts an array
    of strings that contains the paths to the list of files that we wish to compress.
    In this method, we compress the files using the compression strategy that is set
    in the `strategy` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `CompressContent` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating an array of strings that contains the files we wish to
    compress. We also create an instance of both the `ZipCompressionStrategy` and
    `RarCompressionStrategy` types. We then create an instance of the `CompressContent`
    class, setting the compression strategy to the `ZipCompressionStrategy` instance,
    and call the `compressFiles()` method, which will print the `Using zip compression`
    message to the console. We then set the compression strategy to the `RarCompressionStrategy`
    instance and call the `compressFiles()` method again, which will print the `Using
    rar compression` message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern is really good for setting the algorithms to use at runtime,
    which also lets us swap the algorithms out with different implementations as needed
    by the application. Another advantage of the strategy pattern is that we encapsulate
    the details of the algorithm within the strategy types themselves and not in the
    main implementation type.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the tour of design patterns in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are solutions to software design problems that we tend to see
    over and over again in real-world application design. These patterns are designed
    to help us create reusable and flexible code. Design patterns can also make code
    easier to read and understand for other developers and also for ourselves when
    we look back at the code months or years later.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the examples in this chapter carefully, we will notice that one
    of the backbones of design patterns is the protocol. Almost all design patterns
    (the singleton design pattern is an exception) use protocols to help us create
    very flexible and reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: If this was the first time that you really looked at design patterns, you probably
    noticed some strategies that you have used in the past in your own code. This
    is expected when experienced developers are first introduced to design patterns.
    I would also encourage you to read more about design patterns because they will
    definitely help you to create more flexible and reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: Swift is a language that is rapidly changing and it is important to keep up
    to date with it. Since Swift is an open source project, there are plenty of resources
    that will help you. I would definitely recommend bookmarking [http://swiftdoc.org](http://swiftdoc.org)
    in your favorite browser. It has auto-generated documentation for the Swift language
    and is a great resource.
  prefs: []
  type: TYPE_NORMAL
- en: Another site to bookmark is [https://swift.org](https://swift.org). This is
    the main open source Swift site. On this site, you will find links to the Swift
    source code, blog posts, getting started pages, and information on how to install
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: I would also recommend signing up for some of the mailing lists on the swift.org
    site. The lists are located in the community section. The `Swift-users` mailing
    list is an excellent place to ask questions and is the list that Apple monitors.
    If you want to stay up to date with changes to Swift, then I would recommend the
    `swift-evolution-announce` list.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have enjoyed reading this book as much as I have enjoyed writing
    it.
  prefs: []
  type: TYPE_NORMAL
