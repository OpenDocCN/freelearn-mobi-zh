- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Adopting Design Patterns in Swift
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Swift中采用设计模式
- en: 'Although the first publication of the *Gang of Four''s Design Patterns: Elements
    of Reusable Object-Oriented Software* was released in October 1994, I have only
    been paying attention to design patterns for the last 14 years. Like most experienced
    developers, when I first started reading about design patterns, I recognized a
    lot of the patterns because I had already been using them without realizing what
    they were. I would have to say that since I first read about design patterns,
    I have not written a serious application without using at least one of them. I
    will tell you that I am definitely not a design pattern zealot, and if I get into
    a conversation about design patterns, there are usually only a couple of them
    that I can name without having to look them up. But one thing that I do remember
    is the concepts behind the major patterns and the problems they are designed to
    solve. This way, when I encounter one of these problems, I can look up the appropriate
    pattern and apply it. So, remember, as you go through this chapter, to take the
    time to understand the major concepts behind design patterns rather than trying
    to memorize the patterns themselves.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管四巨头《设计模式：可复用面向对象软件元素》的第一版于1994年10月发布，但我对设计模式的研究只有14年的时间。像大多数经验丰富的开发者一样，当我最初开始阅读有关设计模式的内容时，我认识到了很多模式，因为我已经在不知不觉中使用了它们。我必须说，自从我开始阅读有关设计模式的内容以来，我没有编写过一个不使用至少一种设计模式的严肃应用程序。我会告诉你，我绝对不是一个设计模式狂热者，而且如果我陷入关于设计模式的对话中，通常只有一两个我能不查资料就能叫出名字的。但有一件事我记得很清楚，那就是主要设计模式背后的概念以及它们旨在解决的问题。这样，当我遇到这些问题之一时，我就可以查找适当的模式并应用它。所以，记住，当你阅读这一章时，花时间去理解设计模式背后的主要概念，而不是试图记住模式本身。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: What are design patterns?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: What types of patterns make up the creational, structural, and behavioral categories
    of design patterns?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些类型的设计模式构成了设计模式的创建、结构和行为类别？
- en: How to implement the singleton and builder creational patterns in Swift
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中实现单例和建造者创建模式
- en: How to implement the bridge, facade, and proxy structural patterns in Swift
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中实现桥接、外观和代理结构模式
- en: How to implement the command and strategy behavioral patterns in Swift
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中实现命令和策略行为模式
- en: What are design patterns?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: Every experienced developer has a set of informal strategies that shape how
    they design and write applications. These strategies are shaped by their past
    experiences and the obstacles that they have had to overcome in previous projects.
    While these developers might swear by their own strategies, it does not mean that
    their strategies have been fully vetted. The use of these strategies can also
    introduce inconsistent implementations between different projects and developers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个经验丰富的开发者都有一套非正式的策略，这些策略塑造了他们设计和编写应用程序的方式。这些策略是由他们的过去经验和他们在以前的项目中必须克服的障碍所塑造的。虽然这些开发者可能对自己的策略深信不疑，但这并不意味着他们的策略已经得到了充分的检验。使用这些策略也可能在不同项目和开发者之间引入不一致的实现。
- en: 'While the concept of design patterns dates back to the mid-1980s, they did
    not gain popularity until the Gang of Four released *Elements of Reusable Object-Oriented
    Software*, published in 1994\. The book''s authors, Erich Gamma, Richard Helm,
    Ralph Johnson, and John Vlissides (also known as the Gang of Four), discuss the
    pitfalls of object-oriented programming and describe 23 classic software design
    patterns. These patterns are broken up into three categories: *creational*, *structural*,
    and *behavioral*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设计模式的概念可以追溯到20世纪80年代中期，但直到四巨头在1994年发布了《设计模式：可复用面向对象软件》一书，它们才变得流行。这本书的作者Erich
    Gamma、Richard Helm、Ralph Johnson和John Vlissides（也被称为四巨头）讨论了面向对象编程的陷阱，并描述了23个经典的软件设计模式。这些模式被分为三个类别：*创建型*、*结构型*和*行为型*。
- en: A design pattern identifies common software development problems and provides
    a strategy to deal with them. These strategies have been proven, over the years,
    to be an effective solution for the problems they are intended to solve. Using
    these patterns can greatly speed up the development process because they provide
    us with solutions that have been proven to solve common software development problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式识别常见的软件开发问题，并提供解决这些问题的策略。这些策略在多年来的实践中已被证明是解决它们旨在解决的问题的有效方案。使用这些模式可以大大加快开发过程，因为它们为我们提供了已被证明可以解决常见软件开发问题的解决方案。
- en: Another advantage that we get when using design patterns is consistent code
    that is easy to maintain because months or years from now when we look at the
    code, we will recognize the patterns and understand what the code does. If we
    properly document the code and document the design pattern we are implementing,
    it will also help other developers to understand what the code is doing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用设计模式时，我们获得的另一个优点是易于维护的代码，因为几个月或几年后当我们查看代码时，我们将能够识别出模式并理解代码的功能。如果我们适当地记录代码并记录我们正在实施的设计模式，这也有助于其他开发者理解代码的功能。
- en: The two main philosophies behind design patterns are code reuse and flexibility.
    As a software architect, it is essential that we build reusability and flexibility
    into the code. This allows us to easily maintain the code in the future and also
    makes it easier for the applications to expand to meet future requirements, because
    we all know how quickly requirements change.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式背后的两种主要哲学是代码重用和灵活性。作为一名软件架构师，将可重用性和灵活性构建到代码中是至关重要的。这使我们能够轻松地维护代码，并在未来使应用程序更容易扩展以满足未来的需求，因为我们都知道需求变化有多快。
- en: While there is a lot to like about design patterns, and they are extremely beneficial
    for developers and architects, they are not the solution to world hunger that
    some developers make them out to be. Sometime in your development career, you
    will probably meet a developer or an architect who thinks that design patterns
    are immutable laws. These developers usually try to force the use of design patterns
    even when they are not necessary. A good rule of thumb is to make sure that you
    have a problem that needs to be fixed before you try to fix it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设计模式有很多优点，并且对开发者和架构师来说极为有益，但它们并不是解决世界饥饿问题的方案，就像一些开发者所宣称的那样。在你的开发生涯中，你可能会遇到一些认为设计模式是不可变法则的开发者或架构师。这些开发者通常试图在不需要的情况下强制使用设计模式。一个好的经验法则是，在尝试解决问题之前，确保你有一个需要解决的问题。
- en: Design patterns are starting points for avoiding and solving common programming
    problems. We can think of each design pattern as a recipe. Just like a good recipe,
    we can tinker and adjust it to meet particular tastes. But we usually do not want
    to stray too far from the original recipe because we may mess it up.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是避免和解决常见编程问题的起点。我们可以将每个设计模式视为一个食谱。就像一个好的食谱一样，我们可以对其进行调整以满足特定的口味。但我们通常不想偏离原始食谱太远，因为我们可能会把它搞砸。
- en: There are also times when we do not have a recipe for a certain dish that we
    want to make, just like there are times when there isn't a design pattern to solve
    the problem we face. In cases like this, we can use our knowledge of design patterns
    and their underlying philosophy to come up with an effective solution for the
    problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 也有时候我们没有一个想要制作的菜肴的食谱，就像有时候我们面对的问题没有现成的设计模式来解决。在这种情况下，我们可以利用我们对设计模式及其潜在哲学的知识来为问题提出一个有效的解决方案。
- en: 'Design patterns are generally split into three categories. These are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常分为三个类别。具体如下：
- en: '**Creational patterns**: Creational patterns support the creation of objects'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模式**：创建模式支持对象的创建'
- en: '**Structural patterns**: Structural patterns concern types and object compositions'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**：结构模式关注类型和对象组合'
- en: '**Behavioral patterns**: Behavioral patterns communicate between types'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：行为模式在类型之间进行通信'
- en: While the Gang of Four defined over 20 design patterns, we are only going to
    look at examples of some of the more popular patterns in this chapter. Let's start
    off by looking at creational patterns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“四人帮”定义了超过20种设计模式，但我们将在本章中只查看一些更受欢迎的模式的示例。让我们从查看创建模式开始。
- en: Design patterns were originally defined for object-oriented programming. In
    this chapter, where possible, we will focus on implementing patterns in a more
    protocol-oriented way. Therefore, the examples in this chapter may look a little
    different from examples in other design pattern books, but the underlying philosophy
    of the solutions will be the same.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式最初是为面向对象编程定义的。在本章中，尽可能的，我们将关注以更协议导向的方式实现模式。因此，本章中的示例可能与其他设计模式书籍中的示例略有不同，但解决方案的底层哲学将是相同的。
- en: Creational design patterns
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: Creational patterns are design patterns that deal with how an object is created.
    These patterns create objects in a manner suitable for a particular situation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式是处理对象创建的设计模式。这些模式以适合特定情况的方式创建对象。
- en: There are two basic ideas behind creational patterns. The first is encapsulating
    the knowledge of *which* concrete types should be created and the second is hiding
    *how* the instances of these types are created.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式背后有两个基本思想。第一个是封装关于“哪些”具体类型应该被创建的知识，第二个是隐藏这些类型实例的创建方式。
- en: 'There are five well-known patterns that are a part of the creational pattern
    category. They are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种著名的模式属于创建型模式类别。它们如下：
- en: '**The abstract factory pattern**: This provides an interface for creating related
    objects without specifying the concrete type'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂模式**：这种模式提供了一个创建相关对象的接口，而不指定具体的类型'
- en: '**The builder pattern**: This separates the construction of a complex object
    from its representation, so the same process can be used to create similar types'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者模式**：这种模式将复杂对象的构建与其表示分离，因此可以使用相同的流程创建类似类型的对象'
- en: '**The factory method pattern**: This creates objects without exposing the underlying
    logic of how the object (or which type of object) is created'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法模式**：这种模式创建对象，而不暴露对象（或对象类型）创建的底层逻辑'
- en: '**The prototype pattern**: This creates an object by cloning an existing one'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型模式**：这种模式通过克隆现有对象来创建对象'
- en: '**The singleton pattern**: This allows one (and only one) instance of a class
    for the lifetime of an application'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：这种模式允许一个（且仅一个）类的实例在整个应用程序的生命周期中存在'
- en: In this chapter, we are going to show examples of how to implement the singleton
    and builder patterns in Swift. Let's start off by looking at one of the most controversial
    and possibly overused design patterns, the singleton pattern.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何在 Swift 中实现单例模式和建造者模式。让我们从一个最具争议性且可能被过度使用的模式——单例模式——开始。
- en: The singleton pattern
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: The use of the **singleton pattern** is a fairly controversial subject among
    certain corners of the development community. One of the main reasons for this
    is that the singleton pattern is probably the most overused and misused pattern.
    Another reason this pattern is controversial is that it introduces a global state
    into an application, which provides the ability to change the object at any point
    within the application. The singleton pattern can also introduce hidden dependencies
    and tight compiling. My personal opinion is that, if the singleton pattern is
    used correctly, there is nothing wrong with using it. However, we do need to be
    careful not to misuse it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的使用在开发社区的一些角落中是一个相当有争议的话题。主要原因之一是单例模式可能是被过度使用和误用的模式之一。这个模式引起争议的另一个原因是它将全局状态引入应用程序中，这提供了在任何应用程序点更改对象的能力。单例模式还可能引入隐藏的依赖和紧耦合。我个人认为，如果单例模式被正确使用，使用它是没有问题的。然而，我们确实需要小心不要误用它。
- en: The singleton pattern restricts the instantiation of a class to a single instance
    for the lifetime of an application. This pattern is very effective when we need
    exactly one object to coordinate actions within the application. An example of
    a good use of a singleton is if the application communicates with a remote device
    over Bluetooth and we also want to maintain that connection throughout the application.
    Some would say that we could pass the instance of the connection class from one
    page to the next, which is essentially what a singleton is. In my opinion, the
    singleton pattern, in this instance, is a much cleaner solution, because with
    the singleton pattern any page that needs the connection can get it without forcing
    every page to maintain the instance. This also allows us to maintain the connection
    without having to reconnect each time we go to another page.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式限制了一个类在应用程序生命周期内的实例化只能有一个实例。当我们需要恰好一个对象来协调应用程序内的操作时，这种模式非常有效。单例的一个良好用途示例是，如果应用程序通过蓝牙与远程设备通信，并且我们还想在整个应用程序中保持该连接。有些人可能会说，我们可以从一页传递到另一页连接类的实例，这本质上就是单例。在我看来，在这个例子中，单例模式是一个更干净的解决方案，因为使用单例模式，任何需要连接的页面都可以获取它，而不必强迫每个页面都维护实例。这也允许我们在转到另一页时无需重新连接来维护连接。
- en: Understanding the problem
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: The problem that the singleton pattern is designed to address is when we need
    one and only one instance of a type for the lifetime of the application. The singleton
    pattern is usually used when we need centralized management of an internal or
    external resource, and a single global point of access. Another popular use of
    the singleton pattern is when we want to consolidate a set of related activities
    needed throughout the application that do not maintain a state in one place.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式旨在解决的问题是，在应用程序的生命周期中我们需要一个且仅有一个类型的实例。单例模式通常用于我们需要集中管理内部或外部资源，并且需要一个单一的全球访问点。单例模式的另一个流行用途是，当我们想要在整个应用程序中整合一组相关的活动，而这些活动在一个地方不维护状态时。
- en: In *Chapter 9*, *Protocols and Protocol Extensions*, we used the singleton pattern
    in the text validation example. In that example, we used the singleton pattern
    because we wanted to create a single instance of the types that could then be
    used by all the components of the application without requiring us to create new
    instances of the types. These text validation types did not have a state that
    could be changed. They only had methods that performed the validation on the text
    and constants that defined how to validate the text. While some may disagree with
    me, I believe types like these are excellent candidates for the singleton pattern
    because there is no reason to create multiple instances of these types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*协议与协议扩展*中，我们在文本验证示例中使用了单例模式。在那个例子中，我们使用单例模式是因为我们想要创建一个单一实例的类型，然后可以被应用程序的所有组件使用，而无需我们为这些类型创建新的实例。这些文本验证类型没有可以改变的状态。它们只有执行文本验证的方法和定义如何验证文本的常量。虽然有些人可能不同意我的观点，但我认为这类类型是单例模式的绝佳候选者，因为没有理由创建这些类型的多个实例。
- en: In that example, we implemented it using structures, which isn't a true singleton
    because a structure is a value type. A true singleton is implemented using a reference
    (class) type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个例子中，我们使用结构体来实现它，但这并不是真正的单例，因为结构体是一个值类型。真正的单例是通过引用（类）类型实现的。
- en: When using the singleton pattern, one of the biggest concerns is multi-threaded
    applications with race conditions. The issue occurs when one thread changes the
    state of the singleton while another thread is accessing it, producing unexpected
    results. As an example, if the `TextValidation` classes stored the text to be
    validated and then we called a method to do the validation, one thread could change
    the stored text before the original thread did the validation. It is advisable
    to understand how a singleton will be used in your application, before implementing
    this pattern.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用单例模式时，最大的担忧之一是多线程应用程序中的竞态条件。问题发生在当一个线程更改单例的状态时，另一个线程正在访问它，从而产生意外的结果。例如，如果`TextValidation`类存储要验证的文本，然后我们调用一个方法进行验证，一个线程可能在原始线程进行验证之前更改存储的文本。在实现此模式之前，了解单例将在您的应用程序中如何使用是明智的。
- en: Understanding the solution
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解决方案
- en: There are several ways to implement the singleton pattern in Swift. In the method
    that we use here, a single instance of the class is created the first time the
    class constant is accessed. We will then use the class constant to gain access
    to this instance throughout the lifetime of the application. We will also create
    a private initializer that will prevent external code from creating additional
    instances of the class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中实现单例模式有几种方法。在我们使用的方法中，当第一次访问类常量时创建了一个类的单个实例。然后我们将使用类常量来在整个应用程序的生命周期中访问这个实例。我们还将创建一个私有初始化器，这将防止外部代码创建类的额外实例。
- en: Note that we use the word *class* in this description and not *type*. The reason
    for this is that the singleton pattern can only truly be implemented using a reference
    type.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在描述中使用的是“类”这个词，而不是“类型”。这样做的原因是单例模式只能真正通过引用类型来实现。
- en: Implementing the singleton pattern
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现单例模式
- en: 'Let''s look at how we implement the singleton pattern with Swift. The following
    code example shows how to create a singleton class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何使用 Swift 实现单例模式的。下面的代码示例展示了如何创建一个单例类：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that, within the `MySingleton` class, we created a static constant
    named `sharedInstance`, which contains an instance of the `MySingleton` class.
    A static constant can be called without having to instantiate the class. Since
    we declared the `sharedInstance` constant static, only one instance will exist
    throughout the lifecycle of the application, thereby creating the singleton pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在 `MySingleton` 类中，我们创建了一个名为 `sharedInstance` 的静态常量，它包含了一个 `MySingleton`
    类的实例。静态常量可以在不实例化类的情况下被调用。由于我们声明了 `sharedInstance` 常量是静态的，因此在整个应用程序的生命周期中只存在一个实例，从而创建了单例模式。
- en: We also created the private initiator, which cannot be accessed outside of the
    class, which will restrict other code from creating additional instances of the
    `MySingleton` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个私有初始化器，它不能在类外部访问，这将限制其他代码创建 `MySingleton` 类的额外实例。
- en: 'Now, let''s see how this pattern works. The `MySingleton` pattern has another
    property, named `number`, which is an integer. We will monitor how this property
    changes as we use the `sharedInstance` property to create multiple variables of
    the `MySingleton` type, as shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个模式是如何工作的。`MySingleton` 模式还有一个名为 `number` 的属性，它是一个整数。我们将监控这个属性在我们使用
    `sharedInstance` 属性创建多个 `MySingleton` 类型的变量时的变化，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we used the `sharedInstance` property to create three variables
    of the `MySingleton` type. We initially set the `number` property of the second
    `MySingleton` variable (`singleB`) to the number `2`. When we printed out the
    value of the `number` property for the `singleA`, `singleB`, and `singleC` instances,
    we saw that the `number` property for all three equaled `2`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `sharedInstance` 属性创建了三个 `MySingleton` 类型的变量。我们最初将第二个 `MySingleton`
    变量（`singleB`）的 `number` 属性设置为数字 `2`。当我们打印出 `singleA`、`singleB` 和 `singleC` 实例的
    `number` 属性值时，我们看到所有三个的 `number` 属性值都等于 `2`。
- en: We then changed the value of the `number` property of the third `MySingleton`
    instance (`singleC`) to the number `3`. When we printed out the value of the `number`
    property again, we saw that all three now have a value of `3`. Therefore, when
    we change the value of the `number` property in any of the instances, the values
    of all three change because each variable is pointed to the same instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将第三个 `MySingleton` 实例（`singleC`）的 `number` 属性的值更改为数字 `3`。当我们再次打印出 `number`
    属性的值时，我们看到现在所有三个的值都是 `3`。因此，当我们更改任何实例中 `number` 属性的值时，所有三个的值都会改变，因为每个变量都指向同一个实例。
- en: In this example, we implemented the singleton pattern using a reference (class)
    type because we wanted to ensure that only one instance of the type existed throughout
    the application. If we implemented this pattern with a value type, such as a structure
    or an enumeration, we would run the risk of there being multiple instances of
    the type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用引用（类）类型实现了单例模式，因为我们想确保在整个应用程序中只存在该类型的一个实例。如果我们用结构体或枚举这样的值类型实现这个模式，我们就有可能出现该类型的多个实例。
- en: If you recall, each time we pass an instance of a value type, we are actually
    passing a copy of that instance, which means that, if we implemented the singleton
    pattern with a value type, each time we called the `sharedInstance` property we
    would receive a new copy, which would effectively break the singleton pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，每次我们传递一个值类型的实例时，我们实际上是在传递该实例的一个副本，这意味着如果我们用值类型实现单例模式，每次调用`sharedInstance`属性时，我们都会收到一个新的副本，这实际上会破坏单例模式。
- en: The singleton pattern can be very useful when we need to maintain the state
    of an object throughout the application; however, be careful not to overuse it.
    The singleton pattern should not be used unless there is a specific requirement
    (*requirement* is the keyword here) for having one, and only one, instance of
    the class throughout the lifecycle of the application. If we are using the singleton
    pattern simply for convenience, then we are probably misusing it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在整个应用程序中维护对象的状态时，单例模式非常有用；然而，请注意不要过度使用它。除非有特定的要求（*要求*是这里的关键词）在整个应用程序的生命周期中只有一个类的实例，否则不应使用单例模式。如果我们仅仅为了方便而使用单例模式，那么我们可能是在误用它。
- en: Keep in mind that, while Apple generally recommends that we prefer value types
    to reference types, there are still plenty of examples, such as the singleton
    pattern, where we need to use reference types. When we continually tell ourselves
    to prefer value types to reference types, it can be very easy to forget that there
    are times when a reference type is needed. Don't forget to use reference types
    with this pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然苹果公司通常建议我们优先使用值类型而不是引用类型，但仍然有许多例子，例如单例模式，我们需要使用引用类型。当我们不断告诉自己优先使用值类型而不是引用类型时，很容易忘记有时需要引用类型。不要忘记在使用此模式时使用引用类型。
- en: Now, let's look at the builder design pattern.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构建者设计模式。
- en: The builder pattern
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建者模式
- en: The **builder pattern** helps us with the creation of complex objects and enforces
    the process of how these objects are created. With this pattern, we generally
    separate the creation logic from the complex type and put the creation logic into
    another type. This allows us to use the same construction process to create different
    representations of the type.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建者模式**帮助我们创建复杂对象，并强制执行这些对象的创建过程。使用此模式，我们通常将创建逻辑从复杂类型中分离出来，并将创建逻辑放入另一个类型中。这允许我们使用相同的构建过程来创建类型的不同表示形式。'
- en: Understanding the problem
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: The problem that the builder pattern is designed to address is when an instance
    of a type requires a large number of configurable values. We could set the configuration
    options when we create instances of the class, but that can cause issues if the
    options are not set correctly or we do not know the proper values for all the
    options. Another issue is the amount of code that may be needed to set all the
    configurable options each time we create an instance of the types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式旨在解决当类型实例需要大量可配置值时的问题。我们可以在创建类的实例时设置配置选项，但如果选项设置不正确或我们不知道所有选项的正确值，这可能会引起问题。另一个问题是，每次创建类型实例时可能需要的代码量来设置所有可配置选项。
- en: Understanding the solution
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解决方案
- en: The builder pattern solves this problem by introducing an intermediary known
    as a builder type. This builder type contains most, if not all, of the information
    necessary to create an instance of the original complex type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式通过引入一个称为构建者类型的中间代理来解决此问题。这个构建者类型包含创建原始复杂类型实例所需的大部分，如果不是全部，信息。
- en: There are two methods that we can use to implement the builder pattern. The
    first method is to have multiple builder types where each of the types contains
    the information to configure the original complex object in a specific way. In
    the second method, we implement the builder pattern with a single builder type
    that sets all the configurable options to a default value, and then we would change
    the values as needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种方法来实现构建者模式。第一种方法是有多个构建者类型，其中每个类型都包含以特定方式配置原始复杂对象所需的信息。在第二种方法中，我们使用单个构建者类型来设置所有可配置选项的默认值，然后根据需要更改这些值。
- en: In this section, we will look at both ways to use the builder pattern, because
    it is important to understand how each works.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨使用构建者模式的两种方法，因为了解每种方法的工作方式非常重要。
- en: Implementing the builder pattern
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现构建者模式
- en: Before we show how we would use the builder pattern, let's look at how to create
    a complex structure without the builder pattern and the problems we run into.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示如何使用构建器模式之前，让我们看看如何在不使用构建器模式的情况下创建复杂结构以及我们遇到的问题。
- en: 'The following code creates a structure named `BurgerOld`, and does not use
    the builder pattern:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为 `BurgerOld` 的结构，并且没有使用构建器模式：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `BurgerOld` structure, we have several properties that define which
    condiments are on the burger and the name of the burger. Since we need to know
    which items are on the burgers and which items aren''t, when we create an instance
    of the `BurgerOld` structure, the initializer requires us to define each item.
    This can lead to some complex initializations throughout the application, not
    to mention that, if we had more than one standard burger (bacon cheeseburger,
    cheeseburger, hamburger, and so on), we would need to make sure that each is defined
    correctly. Let''s see how to create instances of the `BurgerOld` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BurgerOld` 结构中，我们有一些属性定义了汉堡上有哪些配料以及汉堡的名称。由于我们需要知道哪些项目在汉堡上，哪些不在，当我们创建 `BurgerOld`
    结构的实例时，初始化器要求我们定义每个项目。这可能导致应用程序中一些复杂的初始化，更不用说如果我们有多个标准汉堡（培根芝士汉堡、芝士汉堡、汉堡等），我们需要确保每个都定义正确。让我们看看如何创建
    `BurgerOld` 类的实例：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, creating instances of the `BurgerOld` type requires a lot of
    code. Now, let''s look at a better way to do this. In this example, we will show
    how to use multiple builder types where each type will define what goes on each
    type of burger. We will begin by creating a `BurgerBuilder` protocol that will
    have the following code in it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，创建 `BurgerOld` 类型的实例需要大量的代码。现在，让我们看看一种更好的方法。在这个例子中，我们将展示如何使用多个构建器类型，其中每种类型将定义每种汉堡上有什么。我们将首先创建一个
    `BurgerBuilder` 协议，其中将包含以下代码：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This protocol simply defines the nine properties that will be required for
    any type that implements this protocol. Now, let''s create two structures that
    implement this protocol: the `HamburgerBuilder` and `CheeseBurgerBuilder` structures:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议简单地定义了任何实现此协议的类型所需的九个属性。现在，让我们创建两个实现此协议的结构：`HamburgerBuilder` 和 `CheeseBurgerBuilder`
    结构：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In both the `HamburgerBuilder` and the `CheeseBurgerBuilder` structures, all
    we are doing is defining the values for each of the required properties. In more
    complex types, we might need to initialize additional resources.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HamburgerBuilder` 和 `CheeseBurgerBuilder` 结构中，我们所做的只是为每个所需的属性定义值。在更复杂类型中，我们可能需要初始化额外的资源。
- en: 'Now, let''s look at the `Burger` structure, which will use instances of the
    `BurgerBuilder` protocol to create instances of itself. The following code shows
    this new `Burger` type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Burger` 结构，它将使用 `BurgerBuilder` 协议的实例来创建自身的实例。以下代码展示了这种新的 `Burger`
    类型：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The difference between this `Burger` structure and the `BurgerOld` structure
    shown earlier is the initializer. In the previous `BurgerOld` structure, the initializer
    took nine arguments—one for each constant defined in the structure. In the new
    structure, the initializer takes one argument, which is an instance of a type
    that conforms to the `BurgerBuilder` protocol. This new initializer allows us
    to create instances of the `Burger` class as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面展示的 `BurgerOld` 结构相比，这个 `Burger` 结构的不同之处在于初始化器。在先前的 `BurgerOld` 结构中，初始化器接受九个参数——结构中定义的每个常量一个。在新结构中，初始化器接受一个参数，即符合
    `BurgerBuilder` 协议的类型的一个实例。这个新的初始化器允许我们按照以下方式创建 `Burger` 类的实例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we compare how we create instances of the new `Burger` structure to the earlier
    `BurgerOld` structure, we can see that it is much easier to create instances of
    the `Burger` structure. We also know that we are correctly setting the property
    values for each type of burger because the values are set directly in the builder
    classes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将创建新 `Burger` 结构实例的方法与先前的 `BurgerOld` 结构进行比较，我们可以看到创建 `Burger` 结构的实例要容易得多。我们还知道我们正确地设置了每种汉堡的类型属性值，因为这些值是在构建器类中直接设置的。
- en: As we mentioned earlier, there is a second method that we can use to implement
    the builder pattern. Rather than having multiple builder types, we can have a
    single builder type that sets all the configurable options to a default value;
    then we change the values as needed. I use this implementation method a lot when
    I am updating older code because it is easy to integrate it with preexisting code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们可以使用第二种方法来实现建造者模式。而不是有多个建造者类型，我们可以有一个单一的建造者类型，它将所有可配置选项设置为默认值；然后根据需要更改这些值。我在更新旧代码时经常使用这种方法，因为它很容易与现有代码集成。
- en: For this implementation, we will create a single `BurgerBuilder` structure.
    This structure will be used to create instances of the `BurgerOld` structure and
    will, by default, set all the ingredients to their default values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种实现，我们将创建一个单一的`BurgerBuilder`结构。这个结构将用于创建`BurgerOld`结构的实例，并且默认情况下将所有成分设置为它们的默认值。
- en: 'The `BurgerBuilder` structure also gives us the ability to change which ingredients
    will go on the burger prior to creating instances of the `BurgerOld` structure.
    We create the `BurgerBuilder` structure as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`BurgerBuilder`结构还使我们能够在创建`BurgerOld`结构的实例之前更改将放在汉堡上的成分。我们创建`BurgerBuilder`结构的方式如下：'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `BurgerBuilder` structure, we define the nine properties (ingredients)
    for the burger and then create a setter method for each of the properties except
    for the `name` property.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BurgerBuilder`结构中，我们定义了汉堡的九个属性（成分），然后为除了`name`属性之外的所有属性创建了一个setter方法。
- en: 'We also create one method named `buildBurgerOld()`, which will create an instance
    of the `BurgerOld` structure based on the values of the properties for the `BurgerBuilder`
    instance. We use the `BurgerBuilder` structure as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为`buildBurgerOld()`的方法，它将根据`BurgerBuilder`实例的属性值创建`BurgerOld`结构的实例。我们使用`BurgerBuilder`结构的方式如下：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we create an instance of the `BurgerBuilder` structure. We
    then use the `setCheese()` and `setBacon()` methods to add cheese and bacon to
    the burger. Finally, we call the `buildBurgerOld()` method to create the instance
    of the `burgerOld` structure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`BurgerBuilder`结构的实例。然后我们使用`setCheese()`和`setBacon()`方法向汉堡中添加奶酪和培根。最后，我们调用`buildBurgerOld()`方法来创建`burgerOld`结构的实例。
- en: As we can see, both methods that were used to implement the builder pattern
    greatly simplify the creation of the complex type. Both methods also ensured that
    the instances were properly configured with default values. If you find yourself
    creating instances of types with very long and complex initialization commands,
    I recommend that you look at the builder pattern to see if you can use it to simplify
    the initialization.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两种实现建造者模式的方法都极大地简化了复杂类型的创建。这两种方法还确保了实例被正确地配置为默认值。如果你发现自己正在创建具有非常长和复杂初始化命令的类型实例，我建议你查看建造者模式，看看你是否可以使用它来简化初始化。
- en: Now, let's look at structural design patterns.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看结构型设计模式。
- en: Structural design patterns
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构型设计模式
- en: '**Structural design patterns** describe how types can be combined to form larger
    structures. These larger structures can generally be easier to work with and hide
    a lot of the complexity of the individual types. Most patterns in the structural
    pattern category involve connections between objects.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构型设计模式**描述了类型如何组合成更大的结构。这些更大的结构通常更容易处理，并且可以隐藏许多单个类型的复杂性。结构型模式类别中的大多数模式都涉及对象之间的连接。'
- en: 'There are seven well-known patterns that are part of the structural design
    pattern type. These are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有七个广为人知的模式是结构型设计模式类型的一部分。具体如下：
- en: '**Adapter**: This allows types with incompatible interfaces to work together'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器（Adapter）**: 这允许具有不兼容接口的类型一起工作'
- en: '**Bridge**: This is used to separate the abstract elements of a type from the
    implementation so the two can vary'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接（Bridge）**: 这用于将类型的抽象元素与实现分离，以便两者可以独立变化'
- en: '**Composite**: This allows us to treat a group of objects as a single object'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合（Composite）**: 这允许我们将一组对象视为单个对象处理'
- en: '**Decorator**: This lets us add or override behavior in an existing method
    of an object'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器（Decorator）**: 这让我们能够在现有对象的方法中添加或覆盖行为'
- en: '**Facade**: This provides a simplified interface for a larger and more complex
    body of code'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观（Facade）**: 这为更大的、更复杂的代码库提供了一个简化的接口'
- en: '**Flyweight**: This allows us to reduce the resources needed to create and
    use a large number of similar objects'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元（Flyweight）**: 这允许我们减少创建和使用大量相似对象所需的资源'
- en: '**Proxy**: This is a type acting as an interface for another class or classes'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：这是一个充当其他类或类的接口的类型'
- en: In this chapter, we are going to give examples of how to use the bridge, facade,
    and proxy patterns in Swift. Let's start off by looking at the bridge pattern.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将给出如何在 Swift 中使用桥接、外观和代理模式的示例。让我们首先看看桥接模式。
- en: The bridge pattern
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接模式
- en: The **bridge pattern** decouples the abstraction from the implementation so
    that they can both vary independently. The bridge pattern can also be thought
    of as a two-layer abstraction.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**桥接模式**解耦了抽象和实现，以便它们可以独立地变化。桥接模式也可以被视为两层抽象。'
- en: Understanding the problem
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: The bridge pattern is designed to solve a couple of problems, but the one we
    are going to focus on here tends to arise over time as new requirements come in
    with new features. At some point, as these come in, we will need to change how
    the features interact. Eventually, this will require us to refactor the code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式旨在解决几个问题，但我们在这里将要关注的问题通常随着时间的推移，随着新功能和新需求的到来而出现。在某个时刻，当这些需求到来时，我们需要改变功能之间的交互方式。最终，这将需要我们重构代码。
- en: In object-oriented programming, this is known as an exploding class hierarchy,
    but it can also happen in protocol-oriented programming.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，这被称为爆炸性的类层次结构，但在协议导向编程中也可能发生。
- en: Understanding the solution
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解决方案
- en: The bridge pattern solves this problem by taking the interacting features and
    separating the functionality that is specific to each feature from the functionality
    that is shared between them. A bridge type can then be created, which will encapsulate
    the shared functionality, bringing them together.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式通过将交互功能分离，将每个功能特有的功能与它们之间共享的功能分离来解决此问题。然后可以创建一个桥接类型，它将封装共享功能，将它们组合在一起。
- en: Implementing the bridge pattern
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现桥接模式
- en: To demonstrate how we would use the bridge pattern, we will create two features.
    The first feature is a message feature that will store and prepare a message that
    we wish to send out. The second feature is the sender feature that will send the
    message through a specific channel, such as email or SMS messaging.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们如何使用桥接模式，我们将创建两个功能。第一个功能是一个消息功能，它将存储和准备我们希望发送的消息。第二个功能是发送者功能，它将通过特定的通道发送消息，例如电子邮件或短信。
- en: Let's start off by creating two protocols named `Message` and `Sender`. The
    `Message` protocol will define the requirements for types that are used to create
    messages. The `Sender` protocol will be used to define the requirements for types
    that are used to send the messages through the specific channels.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建两个名为 `Message` 和 `Sender` 的协议。`Message` 协议将定义用于创建消息的类型的要求。`Sender` 协议将用于定义用于通过特定通道发送消息的类型的要求。
- en: 'The following code shows how we define these two protocols:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何定义这两个协议：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Message` protocol defines a single property named `messageString` of the
    `String` type. This property will contain the text of the message and cannot be
    nil. We also define one initiator and a method named `prepareMessage()`. The initializer
    will be used to set the `messageString` property and anything else required by
    the message type. The `prepareMessage()` method will be used to prepare the message
    prior to sending it. This method can be used to encrypt the message or add formatting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 协议定义了一个名为 `messageString` 的单一属性，该属性的类型为 `String`。这个属性将包含消息的文本，并且不能为
    nil。我们还定义了一个初始化器和一个名为 `prepareMessage()` 的方法。初始化器将用于设置 `messageString` 属性以及消息类型所需的其他任何内容。`prepareMessage()`
    方法将用于在发送消息之前准备消息。此方法可以用于加密消息或添加格式。'
- en: The `Sender` protocol defines a method named `sendMessage()`. This method will
    send the message through the channel defined by conforming types. In this function,
    we will need to ensure that the `prepareMessage()` method from the message type
    is called prior to sending the message.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sender` 协议定义了一个名为 `sendMessage()` 的方法。此方法将通过符合类型定义的通道发送消息。在此函数中，我们需要确保在发送消息之前调用消息类型的
    `prepareMessage()` 方法。'
- en: 'Now let''s see how we define two types that conform to the `Message` protocol:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何定义两个符合 `Message` 协议的类型：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each of these types contains the required functionality to conform to the `Message`
    protocol. The only real difference between these types is in the `prepareMessage()`
    methods. In the `PlainTextMessage` class, the `prepareMessage()` method is empty
    because we do not need to do anything to the message prior to sending it. The
    `prepareMessage()` method of the `DESEncryptionMessage` class would normally contain
    the logic to encrypt the message, but for this example we will just prepend a
    `DES` tag to the beginning of the message, letting us know that this method was
    called.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型都包含符合 `Message` 协议所需的功能。这些类型之间唯一的真正区别在于 `prepareMessage()` 方法。在 `PlainTextMessage`
    类中，`prepareMessage()` 方法是空的，因为我们不需要在发送消息之前对消息进行任何操作。`DESEncryptionMessage` 类的
    `prepareMessage()` 方法通常会包含加密消息的逻辑，但在这个示例中，我们将在消息的开头添加一个 `DES` 标签，这样我们就可以知道这个方法被调用了。
- en: 'Now let''s create two types that will conform to the `Sender` protocol. These
    types would typically handle sending the message through a specific channel; however,
    in the example, we will simply print a message to the console:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个将符合 `Sender` 协议的类型。这些类型通常会处理通过特定通道发送消息；然而，在这个示例中，我们只是将消息打印到控制台：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both the `EmailSender` and the `SMSSender` types conform to the `Sender` protocol
    by implementing the `sendMessage()` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmailSender` 和 `SMSSender` 类型都通过实现 `sendMessage()` 函数符合 `Sender` 协议。'
- en: 'We can now use these two features, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这两个功能，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will work well, and we could add code similar to this anywhere we need
    to create and send a message. Now let's say that, one day in the near future,
    we get a requirement to add a new functionality to verify the message prior to
    sending it, to make sure it meets the requirements of the channel we are sending
    the message through.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将很好地工作，我们可以在需要创建和发送消息的任何地方添加类似的代码。现在，假设在不久的将来，我们收到一个需求，需要在发送消息之前验证消息，以确保它符合我们通过该通道发送消息的要求。
- en: To do this, we would start off by changing the `Sender` protocol to add the
    `verify` functionality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要将 `Sender` 协议修改为添加 `verify` 功能。
- en: 'The new `Sender` protocol would look as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Sender` 协议如下所示：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To the `Sender` protocol, we added a method named `verifyMessage()` and added
    a property named `Message`. We also changed the definition of the `sendMessage()`
    method. The original `Sender` protocol was designed to simply send the message,
    but now we need to verify the message prior to calling the `sendMessage()` function;
    therefore, we couldn't simply pass the message to it, as we did in the previous
    definition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `Sender` 协议添加了一个名为 `verifyMessage()` 的方法，并添加了一个名为 `Message` 的属性。我们还更改了 `sendMessage()`
    方法的定义。原始的 `Sender` 协议被设计为简单地发送消息，但现在我们需要在调用 `sendMessage()` 函数之前验证消息；因此，我们不能像上一个定义中那样简单地传递消息。
- en: 'Now we will need to change the types that conform to the `Sender` protocol
    to make them conform to this new protocol. The following code shows how we would
    make these changes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更改符合 `Sender` 协议的类型，使它们符合这个新协议。下面的代码展示了我们将如何进行这些更改：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the changes that we made to the types that conform to the `Sender` protocol,
    we will need to change how the code uses these types. The following example shows
    how we can now use them:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在对符合 `Sender` 协议的类型所做的更改之后，我们需要更改代码使用这些类型的方式。以下示例展示了我们现在如何使用它们：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These changes are not that hard to make; however, without the bridge pattern,
    we would need to refactor the entire code base and make the change everywhere
    that we are sending messages. The bridge pattern tells us that when we have two
    hierarchies that closely interact together like this, we should put this interaction
    logic into a bridge type that will encapsulate the logic in one spot. This way,
    when we receive new requirements or enhancements, we can make the change in one
    spot, thereby limiting the refactoring that we must do. We could make a bridge
    type for the message and sender hierarchies, as shown in the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改并不困难；然而，如果没有桥接模式，我们就需要重构整个代码库，并在发送消息的每个地方进行更改。桥接模式告诉我们，当我们有两个紧密交互的层次结构时，我们应该将这些交互逻辑放入一个桥接类型中，这样就可以将逻辑封装在一个地方。这样，当我们收到新的需求或增强时，我们可以在一个地方进行更改，从而限制必须进行的重构。我们可以为消息和发送者层次结构创建一个桥接类型，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The logic of how the messaging and sender hierarchies interact is now encapsulated
    into the `MessagingBridge` structure. Now, when the logic needs to change, we
    only need to make the change to this one structure rather than having to refactor
    the entire code base.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和发送者层次结构如何交互的逻辑现在被封装到`MessagingBridge`结构中。现在，当逻辑需要更改时，我们只需要更改这个结构，而无需重构整个代码库。
- en: The bridge pattern is a very good pattern to remember and use. There have been
    (and still are) times that I have regretted not using the bridge pattern in my
    code because, as we all know, requirements change frequently, and being able to
    make the changes in one spot rather than throughout the code base can save us
    a lot of time in the future.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式是一个非常值得记住和使用的模式。曾经（现在仍然）有几次我后悔没有在我的代码中使用桥接模式，因为众所周知，需求经常变化，能够在代码库的一个地方而不是整个代码库中做出更改可以节省我们未来大量的时间。
- en: 'Now, let''s look at the next pattern in the structural category: the facade
    pattern.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看结构类别中的下一个模式：外观模式。
- en: The facade pattern
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观模式
- en: The **facade pattern** provides a simplified interface to a larger and more
    complex body of code. This allows us to make the libraries easier to use and understand
    by hiding some of the complexities. It also allows us to combine multiple APIs
    into a single, easier-to-use API, which is what we will see in the example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**外观模式**提供了一个简化的接口来访问更大、更复杂的代码库。这使我们能够通过隐藏一些复杂性来使库更容易使用和理解。它还允许我们将多个API组合成一个单一、易于使用的API，这正是我们将在示例中看到的。'
- en: Understanding the problem
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: The facade pattern is often used when we have a complex system that has a large
    number of independent APIs that are designed to work together. Sometimes it is
    hard to tell where we should use the facade pattern during the initial application
    design. The reason for this is that we normally try to simplify the initial API
    design; however, over time, and as requirements change and new features are added,
    the APIs become more and more complex, and then it becomes evident where the facade pattern
    should be used.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式通常用于我们有一个复杂系统，该系统具有大量独立且旨在协同工作的API。有时在初始应用程序设计中很难确定我们应该在哪里使用外观模式。原因是我们通常试图简化初始API设计；然而，随着时间的推移，随着需求的变化和新功能的添加，API变得越来越复杂，然后就会明显地知道应该在何处使用外观模式。
- en: Understanding the solution
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解决方案
- en: The main idea of the facade pattern is to hide the complexity of the APIs behind
    a simple interface. This offers us several advantages, the most obvious being
    that it simplifies how we interact with the APIs. It also promotes loose coupling,
    which allows the APIs to change as requirements change, without the need to refactor
    all the code that uses them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式的主要思想是在一个简单的接口后面隐藏API的复杂性。这为我们提供了几个优点，最明显的是它简化了我们与API的交互方式。它还促进了松散耦合，这使得API可以根据需求的变化而变化，而无需重构使用它们的所有代码。
- en: Implementing the facade pattern
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现外观模式
- en: 'To demonstrate the facade pattern, we will create three APIs: `HotelBooking`,
    `FlightBooking`, and `RentalCarBooking`. These APIs will be used to search for
    and book hotels, flights, and rental cars for trips. While we could very easily
    call each of the APIs individually in the code, we are going to create a `TravelFacade`
    structure that will allow us to access the functionality of the APIs in single
    calls.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示外观模式，我们将创建三个API：`HotelBooking`、`FlightBooking`和`RentalCarBooking`。这些API将用于搜索和预订酒店、航班和租赁汽车。虽然我们可以在代码中非常容易地单独调用每个API，但我们将创建一个`TravelFacade`结构，这将允许我们通过单次调用访问API的功能。
- en: 'We will begin by defining the three APIs. Each of the APIs will need a data
    storage class that will store the information about the hotel, flight, or rental
    car. We will start off by implementing the hotel API:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义三个API。每个API都需要一个数据存储类来存储有关酒店、航班或租赁汽车的信息。我们将从实现酒店API开始：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The hotel API consists of the `Hotel` and `HotelBooking` structures. The `Hotel`
    structure will be used to store the information about a hotel room, and the `HotelBooking`
    structure will be used to search for a hotel room and to book the room for the
    trip. The flight and rental car APIs are very similar to the hotel API. The following
    code shows both of these APIs:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 酒店API由`Hotel`和`HotelBooking`结构组成。`Hotel`结构将用于存储酒店房间的信息，而`HotelBooking`结构将用于搜索酒店房间并为旅行预订房间。航班和租赁汽车API与酒店API非常相似。以下代码显示了这两个API：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In each of these APIs, we have a structure that is used to store information
    and a structure that is used to provide the search/booking functionality. In the
    initial design, it would be very easy to call these individual APIs within the
    application; however, as we all know, requirements tend to change, which causes
    the APIs to change over time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些API中，我们有一个用于存储信息的结构和一个用于提供搜索/预订功能的结构。在初始设计中，在应用程序中调用这些单个API会非常容易；然而，正如我们所知，需求往往会变化，这会导致API随着时间的推移而变化。
- en: 'By using the facade pattern here, we are able to hide how we implement the
    APIs; therefore, if we need to change how the APIs work in the future, we will
    only need to update the facade type rather than refactoring all of the code. This
    makes the code easier to maintain and update in the future. Now let''s look at
    how we will implement the facade pattern by creating a `TravelFacade` structure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这里使用外观模式，我们能够隐藏API的实现方式；因此，如果我们需要在未来更改API的工作方式，我们只需要更新外观类型，而不是重构所有代码。这使得代码在未来更容易维护和更新。现在让我们看看我们将如何通过创建一个`TravelFacade`结构来实现外观模式：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `TravelFacade` class contains the functionality to search the three APIs
    and book a hotel, flight, and rental car. We can now use the `TravelFacade` class
    to search for hotels, flights, and rental cars without having to directly access
    the individual APIs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`TravelFacade`类包含搜索三个API并预订酒店、航班和租赁车的功能。我们现在可以使用`TravelFacade`类来搜索酒店、航班和租赁车，而无需直接访问单个API。'
- en: As we mentioned at the start of this chapter, it is not always obvious when
    we should use the facade pattern in the initial design.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，在初始设计中何时使用外观模式并不总是显而易见的。
- en: 'A good rule to follow is: if we have several APIs that are working together
    to perform a task, we should think about using the facade pattern.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的规则是：如果我们有几个API协同工作以执行任务，我们应该考虑使用外观模式。
- en: Now, let's look at the last structural pattern, which is the proxy design pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看最后一个结构化模式，即代理设计模式。
- en: The proxy pattern
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式
- en: In the **proxy design pattern**, there is one type acting as an interface for
    another type or API. This wrapper class, which is the proxy, can then add functionality
    to the object, make the object available over a network, or restrict access to
    the object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在**代理设计模式**中，有一个类型充当另一个类型或API的接口。这个包装类，即代理，可以添加功能到对象中，使对象可以通过网络访问，或者限制对对象的访问。
- en: Understanding the problem
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: We can use the proxy pattern to solve several problems, but I find that I mainly
    use this pattern to solve one of two problems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用代理模式解决几个问题，但我发现我主要使用这个模式来解决两个问题之一。
- en: The first problem that I use this pattern to solve is when I want to create
    a layer of abstraction between a single API and my code. The API could be a local
    or remote API, but I usually use this pattern to put an abstraction layer between
    my code and a remote service. This will allow changes to the remote API without
    the need to refactor large portions of the application code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这个模式要解决的问题的第一个问题是，当我想在单个API和我的代码之间创建一层抽象时。API可以是本地或远程API，但我通常使用这个模式在代码和远程服务之间添加一个抽象层。这将允许在不需要重构大量应用程序代码的情况下更改远程API。
- en: The second problem that I use the proxy pattern to solve is when I need to make
    changes to an API, but I do not have the code or there is already a dependency
    on the API elsewhere in the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用代理模式要解决的第二个问题是我需要更改API，但没有代码或应用程序的其他地方已经对API有依赖。
- en: Understanding the solution
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解决方案
- en: To solve these problems, the proxy pattern tells us that we should create a
    type that will act as an interface for interacting with the other type or API.
    In the example, we will show how to use the proxy pattern to add functionality
    to an existing type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，代理模式告诉我们应该创建一个类型，该类型将充当与其他类型或API交互的接口。在示例中，我们将展示如何使用代理模式向现有类型添加功能。
- en: Implementing the proxy pattern
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现代理模式
- en: 'In this section, we will demonstrate the proxy pattern by creating a house
    class that we can add multiple floor plans to, where each floor plan represents
    a different story of the house. Let''s begin by creating a `FloorPlan` protocol:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个可以添加多个楼层平面图的房屋类来演示代理模式，其中每个楼层平面图代表房屋的不同楼层。让我们首先创建一个`FloorPlan`协议：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `FloorPlan` protocol, we define five properties that will represent
    the number of rooms contained in each floor plan. Now, let''s create an implementation
    of the `FloorPlan` protocol named `HouseFloorPlan`, which is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FloorPlan`协议中，我们定义了五个属性，将代表每个楼层平面包含的房间数量。现在，让我们创建一个名为`HouseFloorPlan`的`FloorPlan`协议的实现，如下所示：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `HouseFloorPlan` structure implements all five properties required from
    the `FloorPlan` protocol and assigns default values to them. Next, we will create
    the `House` type, which will represent a house:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`HouseFloorPlan`结构实现了`FloorPlan`协议所需的全部五个属性，并为它们分配了默认值。接下来，我们将创建`House`类型，它将代表一个房屋：'
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Within the `House` structure, we have an array of instances that conforms to
    the `FloorPlan` protocol where each floor plan will represent one story of the
    house. We also have a function named `addStory()`, which accepts an instance of
    a type that conforms to the `FloorPlan` protocol. This function will add the floor
    plan to the array of `FloorPlan` protocols.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`House`结构中，我们有一个符合`FloorPlan`协议的实例数组，其中每个楼层平面将代表房屋的一层。我们还有一个名为`addStory()`的函数，它接受一个符合`FloorPlan`协议的类型实例。此函数将楼层平面添加到`FloorPlan`协议的数组中。
- en: 'If we think about the logic of this class, there is one problem that we might
    encounter: we are allowed to add as many floor plans as we want, which may lead
    to houses that are 60 or 70 stories high. This would be great if we were building
    skyscrapers, but we just want to build basic single-family houses. If we want
    to limit the number of floor plans without changing the `House` class (either
    we cannot change it, or we simply do not want to), we can implement the proxy
    pattern. The following example shows how to implement the `HouseProxy` class,
    where we limit the number of floor plans we can add to the house:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑这个类的逻辑，可能会遇到一个问题：我们可以添加任意多的楼层平面，这可能会导致房屋高达60或70层。如果我们正在建造摩天大楼，那将很棒，但我们只想建造基本的单户住宅。如果我们想限制楼层平面的数量，而不改变`House`类（我们可能无法改变它，或者我们只是不想改变它），我们可以实现代理模式。以下示例展示了如何实现`HouseProxy`类，其中我们限制了可以向房屋添加的楼层平面数量：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We begin the `HouseProxy` class by creating an instance of the `House` class.
    We then create a method named `addStory()`, which lets us add a new floor plan
    to the house. In the `addStory()` method, we check to see if the number of stories
    in the house is fewer than three; if so, we add the floor plan to the house and
    return `true`. If the number of stories is equal to or greater than three, then
    we do not add the floor plan to the house and return `false`. Let''s see how we
    can use this proxy:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建`House`类的一个实例开始`HouseProxy`类。然后我们创建一个名为`addStory()`的方法，它允许我们向房屋添加新的楼层平面。在`addStory()`方法中，我们检查房屋的故事数量是否少于三个；如果是这样，我们将楼层平面添加到房屋中并返回`true`。如果故事数量等于或大于三个，则我们不向房屋添加楼层平面并返回`false`。让我们看看我们如何使用这个代理：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the example code, we start off by creating an instance of the `HouseProxy`
    class named `ourHouse`. We then create four instances of the `HouseFloorPlan`
    type, each with a different number of rooms. Finally, we attempt to add each of
    the floor plans to the `ourHouse` instance. If we run this code, we will see that
    the first three instances of the `floorplans` class were added to the house successfully,
    but the last one wasn't because we are only allowed to add three floors.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我们首先创建了一个名为`ourHouse`的`HouseProxy`类实例。然后我们创建了四个`HouseFloorPlan`类型的实例，每个实例的房间数量都不同。最后，我们尝试将每个楼层平面添加到`ourHouse`实例中。如果我们运行此代码，我们将看到前三个`floorplans`类的实例成功添加到房屋中，但最后一个没有添加，因为我们只能添加三层。
- en: The proxy pattern is very useful when we want to add some additional functionality
    or error checking to a type, but we do not want to change the actual type itself.
    We can also use it to add a layer of abstraction between a remote or local API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式在我们想要为一个类型添加一些额外的功能或错误检查时非常有用，但我们又不想改变该类型的实际实现。我们还可以用它来在远程或本地API之间添加一层抽象。
- en: Now, let's look at behavioral design patterns.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看行为设计模式。
- en: Behavioral design patterns
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: Behavioral design patterns explain how types interact with each other. These
    patterns describe how different instances of types send messages to each other
    to make things happen.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式解释了类型之间如何交互。这些模式描述了不同类型的实例如何相互发送消息以使事情发生。
- en: 'There are nine well-known patterns that are part of the behavioral design pattern
    type. They are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有九种著名的模式属于行为设计模式类型。它们如下所示：
- en: '**Chain of responsibility**: This is used to process a variety of requests,
    each of which may be delegated to a different handler.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任链**：用于处理各种请求，每个请求可能被委派给不同的处理者。'
- en: '**Command**: This creates objects that can encapsulate actions or parameters
    so that they can be invoked later or by a different component.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：创建可以封装操作或参数的对象，以便稍后或由不同的组件调用。'
- en: '**Iterator**: This allows us to access the elements of an object sequentially
    without exposing the underlying structure.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：允许我们按顺序访问对象中的元素，而不暴露底层结构。'
- en: '**Mediator**: This is used to reduce coupling between types that communicate
    with each other.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中介者**：用于减少相互通信的类型之间的耦合。'
- en: '**Memento**: This is used to capture the current state of an object and store
    it in a manner that can be restored later.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：用于捕获对象的当前状态，并以可以稍后恢复的方式存储它。'
- en: '**Observer**: This allows an object to publish changes to an object''s state.
    Other objects can then subscribe so they can be notified of any changes.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：允许一个对象发布对其状态的更改。其他对象可以订阅，以便在发生任何更改时得到通知。'
- en: '**State**: This is used to alter the behavior of an object when its internal
    state changes.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：当对象的内部状态发生变化时，用于改变对象的行为。'
- en: '**Strategy**: This allows one out of a family of algorithms to be chosen at
    runtime.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：这允许在运行时从算法家族中选择一个。'
- en: '**Visitor**: This is a way of separating an algorithm from an object structure.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者**：这是一种将算法与对象结构分离的方法。'
- en: In this section, we are going to give examples of how to use strategy and command
    patterns in Swift. Let's start off by looking at the command pattern.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将给出如何在Swift中使用策略和命令模式的示例。让我们先看看命令模式。
- en: The command pattern
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式
- en: The command design pattern lets us define actions that we can execute later.
    This pattern generally encapsulates all the information needed to call or trigger
    the actions at a later time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式让我们能够定义可以在以后执行的操作。这个模式通常封装了在以后时间调用或触发操作所需的所有信息。
- en: Understanding the problem
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: There are times in applications when we need to separate the execution of a
    command from its invoker. Typically, this is when we have a type that needs to
    perform one of several actions, but the choice of which action to use needs to
    be made at runtime.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，有时我们需要将命令的执行与其调用者分离。通常，这是当我们有一个需要执行多个操作之一的类型时，但需要运行时选择使用哪个操作。
- en: Understanding the solution
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解决方案
- en: The command pattern tells us that we should encapsulate the logic for the actions
    into a type that conforms to a command protocol. We can then provide instances
    of the command types for use by the invoker. The invoker will use the interface
    provided by the protocol to invoke the necessary actions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式告诉我们应该将操作逻辑封装到一个符合命令协议的类型中。然后我们可以为调用者提供命令类型的实例。调用者将使用协议提供的接口来调用必要的操作。
- en: Implementing the command pattern
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现命令模式
- en: 'In this section, we will demonstrate how to use the command pattern by creating
    a `Light` type. In this type, we will define the `lightOnCommand` and `lightOffCommand`
    commands and will use the `turnOnLight()` and `turnOffLight()` methods to invoke
    these commands. We will begin by creating a protocol named `Command`, which all
    of the command types will conform to. Here is the `Command` protocol:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个`Light`类型来演示如何使用命令模式。在这个类型中，我们将定义`lightOnCommand`和`lightOffCommand`命令，并使用`turnOnLight()`和`turnOffLight()`方法来调用这些命令。我们首先创建一个名为`Command`的协议，所有命令类型都将遵守。以下是`Command`协议：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This protocol contains a method named `execute()`, which will be used to execute
    the command. Now, let''s look at the command types that the `Light` type will
    use to turn the light on and off. They are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议包含一个名为`execute()`的方法，它将被用于执行命令。现在，让我们看看`Light`类型将使用哪些命令类型来打开和关闭灯光。它们如下所示：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `RockerSwitchLightOffCommand`, `RockerSwitchLightOnCommand`, `PullSwitchLightOnCommand`,
    and `PullSwitchLightOffCommand` commands all conform to the `Command` protocol
    by implementing the `execute()` method; therefore, we will be able to use them
    in the `Light` type. Now, let''s look at how to implement the `Light` type:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`RockerSwitchLightOffCommand`、`RockerSwitchLightOnCommand`、`PullSwitchLightOnCommand`
    和 `PullSwitchLightOffCommand` 命令都通过实现 `execute()` 方法符合 `Command` 协议；因此，我们将能够在
    `Light` 类型中使用它们。现在，让我们看看如何实现 `Light` 类型：'
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the `Light` type, we start off by creating two variables, named `lightOnCommand`
    and `lightOffCommand`, which will contain instances of types that conform to the
    `Command` protocol. Then we create the `turnOnLight()` and `turnOffLight()` methods
    that we will use to turn the light on and off. In these methods, we call the appropriate
    command to turn the light on or off.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Light` 类型中，我们首先创建两个变量，分别命名为 `lightOnCommand` 和 `lightOffCommand`，它们将包含符合
    `Command` 协议的类型实例。然后，我们创建 `turnOnLight()` 和 `turnOffLight()` 方法，我们将使用这些方法来打开和关闭灯光。在这些方法中，我们调用适当的命令来打开或关闭灯光。
- en: 'We would then use the `Light` type as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式使用 `Light` 类型：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we begin by creating an instance of the `PullSwitchLightOnCommand`
    type named `on` and an instance of the `PullSwitchLightOffCommand` type named
    `off`. We then create an instance of the `Light` type using the two commands that
    we just created and call the `turnOnLight()` and `turnOffLight()` methods of the
    `Light` instance to turn the light on and off. In the last two lines, we change
    the `lightOnCommand` method, which was originally set to an instance of the `PullSwitchLightOnCommand`
    class, to an instance of the `RockerSwitchLightOnCommand` type. The `Light` instance
    will now use the `RockerSwitchLightOnCommand` type whenever we turn the light
    on. This allows us to change the functionality of the `Light` type during runtime.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建了一个名为 `on` 的 `PullSwitchLightOnCommand` 类型的实例和一个名为 `off` 的 `PullSwitchLightOffCommand`
    类型的实例。然后，我们使用这两个刚刚创建的命令创建了一个 `Light` 类型的实例，并调用 `Light` 实例的 `turnOnLight()` 和 `turnOffLight()`
    方法来打开和关闭灯光。在最后两行中，我们将 `lightOnCommand` 方法，原本设置为 `PullSwitchLightOnCommand` 类型的实例，更改为
    `RockerSwitchLightOnCommand` 类型的实例。现在，每次我们打开灯光时，`Light` 实例将使用 `RockerSwitchLightOnCommand`
    类型的实例。这允许我们在运行时更改 `Light` 类型的功能。
- en: There are several benefits of using the command pattern. One of the main benefits
    is that we are able to set which command to invoke at runtime, which also lets
    us swap the commands out with different implementations that conform to the `Command`
    protocol as needed throughout the life of the application. Another advantage of
    the command pattern is that we encapsulate the details of command implementations
    within the command types themselves rather than in the container type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令模式有几个优点。其中一个主要优点是我们能够在运行时设置要调用的命令，这也让我们能够在整个应用程序的生命周期中根据需要替换符合 `Command`
    协议的不同实现。命令模式的另一个优点是将命令实现的细节封装在命令类型本身中，而不是在容器类型中。
- en: Now, let's look at the last design pattern, the strategy pattern.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看最后一个设计模式，即策略模式。
- en: The strategy pattern
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern is pretty similar to the command pattern in that they both
    allow us to decouple implementation details from the calling type, and also allow
    us to switch the implementation out at runtime. The big difference is that the
    strategy pattern is intended to encapsulate algorithms. By swapping out an algorithm,
    we are expecting the object to perform the same functionality, but in a different
    way. In the command pattern, when we swap out the commands, we are expecting the
    object to change the functionality.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式与命令模式非常相似，因为它们都允许我们将实现细节与调用类型解耦，并且允许我们在运行时切换实现。主要区别在于策略模式旨在封装算法。通过替换算法，我们期望对象执行相同的功能，但以不同的方式。在命令模式中，当我们替换命令时，我们期望对象改变功能。
- en: Understanding the problem
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: There are times in applications when we need to change the backend algorithm
    that is used to perform an operation. Typically, this is when we have a type that
    has several different algorithms that can be used to perform the same task, but
    the choice of which algorithm to use needs to be made at runtime.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，有时我们需要更改执行操作所使用的后端算法。通常，这是当我们有一个具有几种不同算法的类型，这些算法可以用来执行相同任务时，但需要根据运行时选择使用哪种算法。
- en: Understanding the solution
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解解决方案
- en: The strategy pattern tells us that we should encapsulate the algorithm in a
    type that conforms to a strategy protocol. We can then provide instances of the
    strategy types for use by the invoker. The invoker will use the interface provided
    by the protocol to invoke the algorithm.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式告诉我们应该将算法封装在一个符合策略协议的类型中。然后我们可以提供策略类型的实例供调用者使用。调用者将使用协议提供的接口来调用算法。
- en: Implementing the strategy pattern
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现策略模式
- en: 'In this section, we will demonstrate the strategy pattern by showing you how
    we could swap out compression algorithms at runtime. Let''s begin this example
    by creating a `CompressionStrategy` protocol that each one of the compression
    types will conform to. Let''s look at the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过展示如何在运行时替换压缩算法来演示策略模式。让我们从这个例子开始，创建一个 `CompressionStrategy` 协议，每个压缩类型都将符合此协议。让我们看看以下代码：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This protocol defines a method named `compressFiles()` that accepts a single
    parameter, which is an array of strings that contains the paths to the files we
    want to compress. We will now create two structures that conform to this protocol.
    These are the `ZipCompressionStrategy` and `RarCompressionStrategy` structures,
    which are as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议定义了一个名为 `compressFiles()` 的方法，该方法接受一个参数，即包含我们想要压缩的文件路径的字符串数组。我们现在将创建两个符合此协议的结构。这些是
    `ZipCompressionStrategy` 和 `RarCompressionStrategy` 结构，如下所示：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Both of these structures implement the `CompressionStrategy` protocol by using
    a method named `compressFiles()`, which accepts an array of strings. Within these
    methods, we simply print out the name of the compression that we are using. Normally,
    we would implement the compression logic in these methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种结构都通过使用名为 `compressFiles()` 的方法实现了 `CompressionStrategy` 协议，该方法接受一个字符串数组。在这些方法中，我们只是简单地打印出我们正在使用的压缩名称。通常，我们会将这些方法中的压缩逻辑实现出来。
- en: 'Now, let''s look at the `CompressContent` class, which will be used to compress
    the files:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `CompressContent` 类，它将被用来压缩文件：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this class, we start off by defining a variable, named `strategy`, which
    will contain an instance of a type that conforms to the `CompressionStrategy`
    protocol. Then we create a method named `compressFiles()`, which accepts an array
    of strings that contains the paths to the list of files that we wish to compress.
    In this method, we compress the files using the compression strategy that is set
    in the `strategy` variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们首先定义了一个名为 `strategy` 的变量，它将包含一个符合 `CompressionStrategy` 协议的类型实例。然后我们创建了一个名为
    `compressFiles()` 的方法，该方法接受一个字符串数组作为参数，该数组包含我们希望压缩的文件路径列表。在这个方法中，我们使用 `strategy`
    变量中设置的压缩策略来压缩文件。
- en: 'We will use the `CompressContent` class as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式使用 `CompressContent` 类：
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We begin by creating an array of strings that contains the files we wish to
    compress. We also create an instance of both the `ZipCompressionStrategy` and
    `RarCompressionStrategy` types. We then create an instance of the `CompressContent`
    class, setting the compression strategy to the `ZipCompressionStrategy` instance,
    and call the `compressFiles()` method, which will print the `Using zip compression`
    message to the console. We then set the compression strategy to the `RarCompressionStrategy`
    instance and call the `compressFiles()` method again, which will print the `Using
    rar compression` message to the console.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含我们希望压缩的文件的字符串数组。我们还创建了 `ZipCompressionStrategy` 和 `RarCompressionStrategy`
    类型的实例。然后我们创建了一个 `CompressContent` 类的实例，将压缩策略设置为 `ZipCompressionStrategy` 实例，并调用
    `compressFiles()` 方法，该方法将在控制台打印出 `Using zip compression` 消息。然后我们将压缩策略设置为 `RarCompressionStrategy`
    实例，并再次调用 `compressFiles()` 方法，这将打印出 `Using rar compression` 消息到控制台。
- en: The strategy pattern is really good for setting the algorithms to use at runtime,
    which also lets us swap the algorithms out with different implementations as needed
    by the application. Another advantage of the strategy pattern is that we encapsulate
    the details of the algorithm within the strategy types themselves and not in the
    main implementation type.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式非常适合在运行时设置要使用的算法，这也允许我们根据应用程序的需要用不同的实现来替换算法。策略模式的另一个优点是，我们将算法的细节封装在策略类型本身中，而不是在主实现类型中。
- en: This concludes the tour of design patterns in Swift.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇关于 Swift 中设计模式的游览就此结束。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Design patterns are solutions to software design problems that we tend to see
    over and over again in real-world application design. These patterns are designed
    to help us create reusable and flexible code. Design patterns can also make code
    easier to read and understand for other developers and also for ourselves when
    we look back at the code months or years later.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是针对我们在现实世界的应用程序设计中反复遇到的设计问题的解决方案。这些模式旨在帮助我们创建可重用和灵活的代码。设计模式还可以使代码对其他开发者以及我们在几个月或几年后回顾代码时更容易阅读和理解。
- en: If we look at the examples in this chapter carefully, we will notice that one
    of the backbones of design patterns is the protocol. Almost all design patterns
    (the singleton design pattern is an exception) use protocols to help us create
    very flexible and reusable code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察本章的示例，我们会注意到设计模式的一个关键组成部分是协议。几乎所有的设计模式（单例设计模式除外）都使用协议来帮助我们创建非常灵活和可重用的代码。
- en: If this was the first time that you really looked at design patterns, you probably
    noticed some strategies that you have used in the past in your own code. This
    is expected when experienced developers are first introduced to design patterns.
    I would also encourage you to read more about design patterns because they will
    definitely help you to create more flexible and reusable code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这是第一次真正地研究设计模式，你可能注意到了一些你在自己的代码中过去使用过的策略。当经验丰富的开发者第一次接触设计模式时，这是预料之中的。我也鼓励你阅读更多关于设计模式的内容，因为它们肯定会帮助你创建更灵活和可重用的代码。
- en: Swift is a language that is rapidly changing and it is important to keep up
    to date with it. Since Swift is an open source project, there are plenty of resources
    that will help you. I would definitely recommend bookmarking [http://swiftdoc.org](http://swiftdoc.org)
    in your favorite browser. It has auto-generated documentation for the Swift language
    and is a great resource.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种快速发展的语言，因此保持对其最新版本的跟进非常重要。由于 Swift 是一个开源项目，因此有大量的资源可以帮助你。我强烈建议你在你最喜欢的浏览器中收藏
    [http://swiftdoc.org](http://swiftdoc.org)。它为 Swift 语言自动生成了文档，是一个极好的资源。
- en: Another site to bookmark is [https://swift.org](https://swift.org). This is
    the main open source Swift site. On this site, you will find links to the Swift
    source code, blog posts, getting started pages, and information on how to install
    Swift.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要收藏的网站是 [https://swift.org](https://swift.org)。这是主要的开源 Swift 网站。在这个网站上，你可以找到
    Swift 源代码、博客文章、入门页面以及有关如何安装 Swift 的信息。
- en: I would also recommend signing up for some of the mailing lists on the swift.org
    site. The lists are located in the community section. The `Swift-users` mailing
    list is an excellent place to ask questions and is the list that Apple monitors.
    If you want to stay up to date with changes to Swift, then I would recommend the
    `swift-evolution-announce` list.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议你在 swift.org 网站上注册一些邮件列表。这些列表位于社区部分。`Swift-users` 邮件列表是一个询问问题的绝佳地方，也是苹果公司监控的列表。如果你想跟上
    Swift 的变化，那么我建议订阅 `swift-evolution-announce` 列表。
- en: I hope you have enjoyed reading this book as much as I have enjoyed writing
    it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢阅读这本书，就像我喜欢写这本书一样。
