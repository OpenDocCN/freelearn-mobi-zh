- en: Chapter 16. Network Development with Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I took several networking courses when I was in college, and I still recall
    setting up my first Novell NetWare network in one of those courses. I was absolutely
    fascinated to see and learn how computers communicated over the network. Then,
    in the early 90s, I bought my first modem and started dialing into bulletin board
    services that were local to me. This was really exciting because now I could connect
    to bulletin board services that were located in the city that I lived in. This
    allowed me to download and upload files from these bulletin board services, and
    I started downloading everything I could find that talked about how computers
    communicated. This led to my early career in network security and administration.
    Then, when my first daughter was born, I decided that I did not want to be on
    call all the time, so I went back to what got me into computers in the first place,
    which was programming. However, I still really enjoyed the field of networking
    and network security. My background in both networking and programming has given
    me a unique understanding of both. What constitutes networking today (the Internet
    and TCP/IP networks) is completely different to what constituted networking back
    when I was in college, but the good thing is how our applications communicate
    over the network has become much more standardized, which makes it easier to write
    applications that communicate over a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to make an HTTP GET request using the `NSURLSession` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make an HTTP POST request using the `NSURLSession` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the System Configuration API to check our network connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `RSNetworking2` library to easily add network functionality to
    your applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is network development?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network development is writing code that will allow our application to send
    and receive data from remote services or devices. In the introduction of this
    chapter, I mentioned buying my first modem and connecting with bulletin board
    services across the city that I lived in. The large majority of these bulletin
    board services used a single modem, which meant that only one user could connect
    to them at any one time. These bulletin boards would seem very strange and archaic
    for those that grew up with the Internet; however, back then, they were how computers
    shared information. At that time, being able to connect to a computer across town
    and upload/download files was amazing. Today, however, we communicate with services
    and devices all over the world without thinking twice about it.
  prefs: []
  type: TYPE_NORMAL
- en: Back then when I first started writing applications, it was rare to develop
    an application that communicated over a networked connection, and it was also
    hard to find developers with experience in network development. In today's world,
    just about every application has a requirement for some sort of network communication.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will show you how to connect to **Representational State
    Transfer** (**REST**)-based web services. Representational State Transfer is the
    software architectural style of the World Wide Web. Typically, these services
    communicate over HTTP using the same HTTP verbs (get, put, delete, and post) which
    web browsers use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the REST-based service that Apple supplies, which
    lets developers search the iTunes Store. We will be using Apple's service for
    several examples in this chapter. Apple has documented this service very well.
    The documentation can be found at [https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you would like a more detailed discussion on network development, I would
    recommend you to read my first book, titled *iOS and OS X Network Programming
    Cookbook*, by *Packt Publishing*. In this chapter, we will be focusing on how
    to connect to the standard REST-based services.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at how to connect to REST services, let's look at the classes
    in Apple's networking API that we will be using. These classes are part of Apple's
    powerful URL loading system.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the URL session classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apple''s URL loading system is a framework of classes available to interact
    with URLs. Using these classes together lets us communicate with services that
    use standard Internet protocols. The classes that we will be using in this chapter
    to connect to and retrieve information from REST services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSURLSession`: This is the main session object. It was written as a replacement
    for the older `NSURLConnection` API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSURLSessionConfiguration`: This is used to configure the behavior of the
    `NSURLSession` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSURLSessionTask`: This is a base class to handle the data being retrieved
    from the URL. Apple provides three concrete subclasses of the `NSURLSessionTask`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSURL`: This is an object that represents the URL to connect to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSMutableURLRequest`: This class contains information about the request that
    we are making and is used by the `NSURLSessionTask` service to make the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSHTTPURLResponse`: This class contains the response to our request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at each of these classes a little more in depth so that we have
    a basic understanding of what each does.
  prefs: []
  type: TYPE_NORMAL
- en: NSURLSession
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to iOS 7 and OS X 10.9, when a developer wanted to retrieve contents from
    a URL, he/she used the `NSURLConnection` API. Starting with iOS 7 and OS X 10.9,
    `NSURLSession` became the preferred API. The `NSURLSession` API can be thought
    of as an improvement to the older `NSURLConnection` API.
  prefs: []
  type: TYPE_NORMAL
- en: An `NSURLSession` object provides an API for interacting with various protocols
    such as HTTP and HTTPS. The session object, which is an instance of the `NSURLSession`,
    manages this interaction. These session objects are highly configurable, which
    allows us to control how our requests are made and how we handle the data that
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Like most networking API, `NSURLSession` is asynchronous. This means that we
    have to provide a way to return the response from the service back to the code
    that needs it. The most popular way to return the results from a session is to
    pass a completion handler block (closure) to the session. This completion handler
    is then called when the service successfully responds or we receive an error.
    All of the examples in this chapter use completion handlers to process the data
    that is returned from the services.
  prefs: []
  type: TYPE_NORMAL
- en: NSURLSessionConfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSURLSessionConfiguration` class defines the behavior and policies to use
    when using the `NSURLSession` object to connect to a URL. When using the `NSURLSession`
    object, we usually create an `NSURLSessionConfiguration` instance first because
    an instance of this class is required when we create an instance of the `NSURLSession`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSURLSessionConfiguration` class defines three session types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default session configuration**: This configuration behaves similar to the
    `NSURLConnection` API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ephemeral session configuration**: This configuration behaves similar to
    the default session configuration, except that it does not cache anything to disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background session configuration**: This session allows for uploads and downloads
    to be performed, even when the app is running in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that we should make sure that we configure the `NSURLSessionConfiguration`
    object appropriately before we use it to create an instance of the `NSURLSession`
    class. When the session object is created, it creates a copy of the configuration
    object that we provided it. Any changes made to the configuration object once
    the session object is created are ignored by the session. If we need to make changes
    to the configuration, we must create another instance of the `NSURLSession` class.
  prefs: []
  type: TYPE_NORMAL
- en: NSURLSessionTask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NSURLSession` service uses an instance of the `NSURLSessionTask` classes
    to make the call to the service that we are connecting to. The `NSURLSessionTask`
    class is a base class, and Apple has provided three concrete subclasses that we
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSURLSessionDataTask`: This returns the response, in memory, directly to the
    application as one or more `NSData` objects. This is the task that we generally
    use most often.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSURLSessionDownloadTask`: This writes the response directly to a temporary
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSURLSessionUploadTask`: This is used for making requests that require a request
    body such as a POST or PUT request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that a task will not send the request to the service
    until we call the `resume()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NSURL class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSURL` object represents the URL that we are going to connect to. The `NSURL`
    class is not limited to URLs that represent remote servers, but it can also be
    used to represent a local file on disk. In this chapter, we will be using the
    `NSURL` class exclusively to represent the URL of the remote service that we are
    connecting to.
  prefs: []
  type: TYPE_NORMAL
- en: NSMutableURLRequest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSMutableURLRequest` class is a mutable subclass of the `NSURLRequest`
    class, which represents a URL load request. We use the `NSMutableRequest` class
    to encapsulate our URL and the request properties.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that the `NSMutableURLRequest` class is used to
    encapsulate the necessary information to make our request, but it does not make
    the actual request. To make the request, we use instances of the `NSURLSession`
    and `NSURLSessionTask` classes.
  prefs: []
  type: TYPE_NORMAL
- en: NSURLHTTPResponse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSURLHTTPResponse` class is a subclass of the `NSURLResponse` class that
    encapsulates the metadata associated with the response to a URL request. The `NSURLHTTPResponse`
    class provides methods for accessing specific information associated with an HTTP
    response. Specifically, this class allows us to access the HTTP header fields
    and the response status codes.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly covered a number of classes in this section and it may not be clear
    how they all actually fit together; however, once you see the examples a little
    further in this chapter, it will become much clearer. Before we go into our examples,
    let's take a quick look at the type of service that we will be connecting to.
  prefs: []
  type: TYPE_NORMAL
- en: REST web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST has become one of the most important technologies for stateless communications
    between devices. Due to the lightweight and stateless nature of the REST-based
    services, its importance is likely to continue to grow as more devices are connected
    to the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: REST is an architecture style for designing networked applications. The idea
    behind REST is that instead of using complex mechanisms, such as SOAP or CORBA
    to communicate between devices, we use simple HTTP requests for the communication.
    While, in theory, REST is not dependent on the Internet protocols, it is almost
    always implemented using them. Therefore, when we are accessing REST services,
    we are almost always interacting with web servers in the same way that our web
    browsers interact with these servers.
  prefs: []
  type: TYPE_NORMAL
- en: REST web services use the HTTP POST, GET, PUT, or DELETE methods. If we think
    about a standard CRUD (create/read/update/delete) application, we would use a
    POST request to create or update data, a GET request to read data, and a DELETE
    request to delete data.
  prefs: []
  type: TYPE_NORMAL
- en: When we type a URL into our browser's address bar and hit *Enter*, we are generally
    making a GET request to the server and asking it to send us the web page associated
    with that URL. When we fill out a web form and click the submit button, we are
    generally making a POST request to the server. We then include the parameters
    from the web form in the body of our POST request.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how to make an HTTP GET request using Apple's networking
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Making an HTTP GET request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will make a GET request to Apple's iTunes search API to
    get a list of items related to the search term Jimmy Buffett. Since we are retrieving
    data from the service, by REST standards, we should use a GET request to retrieve
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: While the REST standard is to use GET requests to retrieve data from a service,
    there is nothing stopping a developer of a web service from using a GET request
    to create or update a data object. It is not recommended to use a GET request
    in this manner, but just be aware that there are services out there that do not
    adhere to the REST standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code makes a request to Apple''s iTunes search API and then prints
    the results to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We start off by creating a type alias named `DataFromURLCompletionClosure`.
    The `DataFromURLCompletionClosure` type will be used for both the GET and POST
    examples of this chapter. If you are not familiar with using a `typealias` object
    to define a closure type, please refer to [Chapter 12](ch12.html "Chapter 12. Working
    with Closures"), *Working with Closures*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a function named `sendGetRequest()` that will be used to make
    the GET request to Apple's iTunes API. This function accepts one argument named
    handler, which is a closure that conforms to the `DataFromURLCompletionClosure`
    type. The handler closure will be used to return the results from the request.
  prefs: []
  type: TYPE_NORMAL
- en: Within our `sendGetRequest()` method, we begin by creating an instance of the
    `NSURLSessionConfiguration` class using the `defaultSessionConfiguration()` method,
    which creates a default session configuration instance. If we need to, we can
    modify the session configuration properties after we create it, but in this example,
    the default configuration is what we want.
  prefs: []
  type: TYPE_NORMAL
- en: After we create our session configuration, we create the URL string. This is
    the URL of the service we are connecting to. With a GET request, we put our parameters
    in the URL itself. In this specific example, `https://itunes.apple.com/search`
    is the URL of the web service. We then follow the web service URL with a question
    mark (`?`), which indicates that the rest of the URL string consists of parameters
    for the web service.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters take the form of key/value pairs, which means that each parameter
    has a key and a value. The key and value of a parameter, in a URL, are separated
    by an equals sign (`=`). In our example, the key is `term` and the value is `jimmy+buffett`.
    Next, we run the URL string that we just created through the `stringByAddingPercentEncodingWithAllowedCharacters()`
    method to make sure our URL string is encoded properly. We use the `URLQueryAllowedCharacterSet`
    character set with this method to ensure we have a valid URL string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the URL string that we just built to create an `NSURL` instance
    named `url`. Since we are making a GET request, this `NSURL` instance will represent
    both the location of the web service and the parameters that we are sending to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of the `NSMutableURLRequest` class using the `NSURL` instance
    that we just created. We use the `NSMutableURLRequest` class, instead of the `NSURLRequest`
    class so that we can set the properties needed for our request. In this example,
    we set the `HTTPMethod` property; however, we can also set other properties such
    as the timeout interval or add items to our HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we use the `sessionConfiguration` variable (instance of the `NSURLSessionConfiguration
    class`) that we created at the beginning of the `sendGetRequest()` function to
    create an instance of the `NSURLSession` class. The `NSURLSession` class provides
    the API that we will use to connect to Apple's iTunes search API. In this example,
    we use the `dataTaskWithRequest()` method of the `NSURLSession` instance to return
    an instance of the `NSURLSessionDataTask` instance named `sessionTask`.
  prefs: []
  type: TYPE_NORMAL
- en: The `sessionTask` instance is what makes the request to the iTunes search API.
    When we receive the response from the service, we use the handler callback to
    return both the `NSURLResponse` object and the `NSData` object. The `NSURLResponse`
    contains information about the response, and the `NSData` instance contains the
    body of the response.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `resume()` method of the `NSURLSessionDataTask` instance
    to make the request to the web service. Remember, as we mentioned earlier, an
    `NSURLSessionTask` instance will not send the request to the service until we
    call the `resume()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how we would call the `sendGetRequest()` function. The
    first thing we need to do is to create a closure that will be passed to the `sendGetRequest()`
    function and called when the response from the web service is received. In this
    example, we will simply print the response to the console. Since the response
    is in the JSON format, we could use the `NSJSONSerialization` class, as describe
    in [Chapter 8](ch08.html "Chapter 8. Working with XML and JSON Data"), *Working
    with XML and JSON Data*, to parse the response; however, since this chapter is
    on networking, we will simply print the response to the console. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We define this closure, named `printResultsClosure`, to be an instance of the
    `DataFromURLCompletionClosure` type. Within the closure, we unwrap the first parameter
    and set the value to a constant named `data`. If the first parameter is not nil,
    we convert the data constant to an instance of the `NSString` class, which is
    then printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s call the `sendGetRequest()` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code creates an instance of the `HttpConnect` class and then calls the
    `sendGetRequest()` method, passing the `printResultsClosure` closure as the only
    parameter. If we run this code while we are connected to the Internet, we will
    receive a JSON response that contains a list of items related to Jimmy Buffett
    on iTunes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to make a simple HTTP GET request, let's look at how
    we would make an HTTP POST request to a web service.
  prefs: []
  type: TYPE_NORMAL
- en: Making an HTTP POST request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Apple's iTunes, APIs use GET requests to retrieve data. In this section,
    we will use the free [http://httpbin.org](http://httpbin.org) service to show
    you how to make a POST request. The POST service that [http://httpbin.org](http://httpbin.org)
    provides can be found at [http://httpbin.org/post](http://httpbin.org/post). This
    service will echo back the parameters that it receives so that we can verify that
    our request was made properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we make a POST request, we generally have some data that we want to send
    or post to the server. This data takes the form of key/value pairs. These pairs
    are separated by an ampersand (`&`) symbol, and each key is separated from its
    value by an equals sign (`=`). As an example, let''s say that we want to submit
    the following data to our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the POST request would take the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the data in the proper format, we will then use the `dataUsingEncoding()`
    method, as we did with the GET request to properly encode the POST data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the data going to the server is in the key/value format, the most appropriate
    way to store this data, prior to sending it to the service, is with a `Dictionary`
    object. With this in mind, we will need to create a method that will take a `Dictionary`
    object and return a string object that can be used for the POST request. The following
    code will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function loops through each key/value pair of the `Dictionary` object and
    creates a `String` object that contains the key and the value separated by the
    equals sign (`=`). We then use the `joinWithSeperator()` function to join each
    item in the array, separated by the specified sting. In our case, we want to separate
    each string with the ampersand symbol (`&`). We then return this newly created
    string to the code that called it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our `sendPostRequest()` function that will send the POST
    request to the [http://httpbin.org](http://httpbin.org) post service. We will
    see a lot of similarities between this `sendPostRequest()` function and the `sendGetRequest()`
    function, which we showed you in the *Making an HTTP GET request* section of this
    chapter. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's walk though this code. Notice that we are using the same type alias,
    named `DataFromURLCompletionClosure`, that we used with the `sendGetRequest()`
    function. If you are not familiar with using a `typealias` object to define a
    closure type, please refer to [Chapter 12](ch12.html "Chapter 12. Working with
    Closures"), *Working with Closures*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The `sendPostRequest()` function accepts one argument named `handler`, which
    is a closure that conforms to the `DataFromURLCompletionClosure` type. The handler
    closure will be used to process the data from the [http://httpbin.org](http://httpbin.org)
    service once the service responds to our request.
  prefs: []
  type: TYPE_NORMAL
- en: Within our `sendPostRequest()` method, we start off by creating an instance
    of the `NSURLSessionConfiguration` class using the `defaultSessionConfiguration()`
    method, which creates a default session configuration instance. We are able to
    modify the session configuration properties after we create it, but, in this example,
    the default configuration is what we want.
  prefs: []
  type: TYPE_NORMAL
- en: After we created our session configuration, we create our URL string. This is
    the URL of the service we are connecting to. In this example, the URL is [http://httpbin.org/post](http://httpbin.org/post).
    Next, we run the URL string that we just created through the `stringByAddingPercentEncodingWithAllowedCharacters()`
    method to make sure our URL string is encoded properly. We use the `URLQueryAllowedCharacterSet`
    character set with this method to ensure we have a valid URL string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the URL string that we just built to create an instance of the
    `NSURL` class named `url`. Since this is a POST request, this `NSURL` instance
    will represent the location of the web service that we are connecting to.
  prefs: []
  type: TYPE_NORMAL
- en: We now create an instance of the `NSMutableURLRequest` class using the `NSURL`
    instance that we just created. We use the `NSMutableURLRequest` class, instead
    of the `NSURLRequest` class so that we can set the properties needed for our request.
    In this example, we set the `HTTPMethod` property; however, we can also set other
    properties such as the timeout interval or add items to our HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we use our `dictionaryToQueryString()` function, which we showed you at
    the beginning of this section, to build the data that we are going to post to
    the server. We use the `dataUsingEncoding()` function to make sure that our data
    is properly encoded prior to sending it to the server, and finally, the data is
    added to the `HTTPBody` property of the `NSMutableURLRequest` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `sessionConfiguration` variable (instance of the `NSURLSessionConfiguration
    class`) that we created at the beginning of the function to create an instance
    of the `NSURLSession` class. The `NSURLSession` class provides the API that we
    will use to connect to the post on [http://httpbin.org](http://httpbin.org) post
    service. In this example, we use the `dataTaskWithRequest()` method of the `NSURLSession`
    instance to return an instance of the `NSURLSessionDataTask` class named `sessionTask`.
  prefs: []
  type: TYPE_NORMAL
- en: The `sessionTask` instance is what makes the request to the [http://httpbin.org](http://httpbin.org)
    POST service. When we receive the response from the service, we use the handler
    callback to return both the `NSURLResponse` object and the `NSData` object. The
    `NSURLResponse` contains information about the response, and the `NSData` instance
    contains the body of the response.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `resume()` method of the `NSURLSessionDataTask` instance
    to make the request to the web service. Remember, as we mentioned earlier, an
    `NSURLSessionTask` class will not send the request to the service until we call
    the `resume()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can then call the `sendPostRequest()` method in exactly the same way that
    we called the `sendGetRequest()` method.
  prefs: []
  type: TYPE_NORMAL
- en: When developing applications that communicate to other devices and services
    over the Internet, it is good practice to verify that we have a network connection.
    When developing mobile applications, it is also good practice to verify that we
    are not using a mobile connection (3G, 4G, and so on) to transfer large amounts
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to verify that we have a network connection and what type
    of connection we have.
  prefs: []
  type: TYPE_NORMAL
- en: Checking network connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we create applications that communicate with other devices and services over
    the Internet, eventually, we will want to verify that we have a network connection
    prior to making the network calls. Another thing to consider when we are writing
    mobile applications is the type of network connection that the user has. As mobile
    application developers, we need to keep in mind that our users probably have a
    mobile data plan that limits the amount of data they can send/receive in a month.
    If they exceed that limit, they may have to pay an extra fee. If our application
    sends large amounts of data, it might be appropriate to warn our user prior to
    sending this data if they are on a cellular network.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next example will show us how we can verify that we have a network connection
    and it also tells us what type of connection we have. We will begin by importing
    the system configuration API and also defining an enum that contains the different
    connection types. We will import the system configuration API like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `ConnectionType` enum. This enum will be used as the return type
    for `networkConnectionType()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the code to check the network connection type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `networkConnectionType()` function begins by creating a `SCNetworkReachability`
    reference. To create the `SCNetworkRechabilityRef` reference, we use the `SCNetworkReachabilityCreateWithName()`
    function, which creates a reachability reference to the host provided.
  prefs: []
  type: TYPE_NORMAL
- en: After we get our `SCNetworkReachabilityRef` reference, we need to retrieve the
    `SCNetworkReachabilityFlags` enum from the reference. This is done with the `SCNetworkReachabilityGetFlags()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the network reachability flags, we can begin testing our connection.
    We use the bitwise AND (`&`) operator to see whether the host is reachable and
    if we need to establish a connection before we can connect to the host (`needsConnection`).
    If the reachable flag is false (we cannot currently connect to the host), or if
    `needsConnection` is true (we need to establish a connection before we can connect),
    we return `NONETWORK`, which means the host is currently not reachable.
  prefs: []
  type: TYPE_NORMAL
- en: If we are able to connect to the host, we then check to see whether we have
    a cellular connection by checking the network reachability flags again. If we
    have a cellular connection, we return `MOBILE3GNETWORK`, otherwise, we assume
    we have a Wi-Fi connection and return `WIFINETWORK`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are writing applications that connect to other devices or services over
    the Internet, I would recommend putting this function in a standard library to
    use because you will want to check for networking connectivity, and also the type
    of connection that you have pretty regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to use Apple's networking APIs to connect to remote
    services, I would like to demonstrate a network library that you can use in your
    own applications. This network library makes it very easy and simple to connect
    to various types of services on the Internet. This is a library that I created
    and maintained, but I would definitely welcome anyone that would like to contribute
    to the code base. This library is called **RSNetworking**.
  prefs: []
  type: TYPE_NORMAL
- en: RSNetworking2 for Swift 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find `RSNetworking2` on GitHub with [https://github.com/hoffmanjon/RSNetworking2](https://github.com/hoffmanjon/RSNetworking2)
  prefs: []
  type: TYPE_NORMAL
- en: The `RSNetworking2` library is a network library written entirely in the Swift
    programming language. `RSNetworking2` is built using Apple's powerful URL loading
    system ([https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html)),
    which features the `NSURLSession` class that we used earlier in this chapter.
    The main design goal of `RSNetworking2` is to make it easy and quick for developers
    to add powerful asynchronous networking requests to their applications that are
    written in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the three ways in which we can use `RSNetworking2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RSURLRequest`: This API provides a very simple and easy interface to make
    single GET requests to a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RSTransaction` and `RSTransactionRequest`: These APIs provide a very powerful
    and flexible way to make both GET and POST requests to a service. This API also
    makes it very easy to make multiple requests to a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Extensions`: `RSNetworking2` provides extensions to both the `UIImageView`
    and `UIButton` classes to dynamically load images from a URL and insert them into
    the `UIImageView` or `UIButton` classes after they are loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these APIs in greater detail and then provide some examples
    of how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: RSURLRequest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `RSURLRequest` API, we can make a GET request to a service and the
    only thing we need to provide is the URL and the parameters we wish to send to
    the service. The `RSURLRequest` API exposes four functions. These functions are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dataFromURL(url: NSURL, completionHandler handler: RSNetworking.dataFromURLCompletionClosure)`:
    This retrieves an `NSData` object from a URL. This is the main function and is
    used by the other three functions to retrieve an `NSData` object prior to converting
    it to the requested format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringFromURL(url: NSURL, completionHandler handler: RSNetworking.stringFromURLCompletionClosure)`:
    This retrieves an `NSString` object from a URL. This function uses the `dataFromURL()`
    function to retrieve an `NSData` object and then converts it to an `NSString`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dictionaryFromJsonURL(url: NSURL, completionHandler handler: RSNetworking.dictionaryFromURLCompletionClosure)`:
    This retrieves an `NSDictionary` object from a URL. This function uses the `dataFromURL()`
    function to retrieve an `NSData` object and then converts it to an `NSDictionary`
    object. The data returned from the URL should be in the JSON format for this function
    to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageFromURL(url: NSURL, completionHandler handler: RSNetworking.imageFromURLCompletionClosure)`:
    This retrieves a `UIImage` object from a URL. This function uses the `dataFromURL()`
    function to retrieve an `NSData` object and then converts it to a `UIImage` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at an example on how to use the `RSURLRequest` API. In this
    example, we will make a request to Apple''s iTunes search API, as we did in the
    *Making an HTTP GET request* section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through this code. We begin by creating an instance of the `RSURLRequest`
    class and an instance of the `NSURL` class. The `NSURL` instance represents the
    URL of the service that we wish to connect to and since we are making a GET request,
    it also contains the parameters that we are sending to the service. If we recall
    from the previous *Making an HTTP GET Request* section, when we make a HTTP GET
    request, the parameters that we are sending to the service are contained within
    the URL itself.
  prefs: []
  type: TYPE_NORMAL
- en: Apple's iTunes search API returns the results of the search in the JSON format.
    We can see that in the API documentation and also by printing out the results
    of the search to the console; therefore, we will use the `dictionaryFromJsonURL()`
    method of the `RSURLRequest` class to make our request to the service. We could
    also use the `dataFromURL()` or `stringFromURL()` methods to retrieve the data
    if we wanted to, but this method is specifically written to handle JSON data that
    is returned form a REST-based web service.
  prefs: []
  type: TYPE_NORMAL
- en: The `dictionaryFromJsonURL()` method will take the data that is returned from
    the `NSURLSession` request and convert it to an `NSDictionary` object. We use
    the `NSDictionary` object here rather than Swift's `Dictionary` object because
    the web service could return multiple types (Strings, Arrays, Numbers, and so
    on), and if we recall, a Swift `Dictionary` object can have only a single type
    for the key and a single type for the value.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `dictionaryFromJsonURL()` method, we pass the URL that we want
    to connect to and also a completion handler that will be called once the information
    from the service is returned and converted to an `NSDicationary` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our completion handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our completion handler is of the `RSURLRequest.dictionaryFromURLCompletionClosure`
    type. This type is defined in the same way as the `RSTransactionRequest.dictionaryFromRSTransactionCompletionClosure
    type`, which allows us to use this same closure for the `RSURLRequests` and `RSTransactionRequest`
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: We begin the completion handler by retrieving the three parameters that were
    passed and assign them to the `response`, `responseDictionary`, and `error` variables.
    We then check the `error` variable to see whether it is `nil`. If it is `nil`,
    we received a valid response and can retrieve values for the `NSDictionary` object.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we retrieve the `NSArray` value that is associated with the
    `results` key in the `NSDictionary` object that was returned from the service.
    This `NSArray` value will contain a list of items in the iTunes store that are
    associated with our search term. Once we have the `NSArray` value, we print out
    the first element of the array to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The `RSURLRequest` API is very good for making single GET requests to a service.
    Now, let's look at the `RSTransaction` and `RSTransactionRequest` APIs, which
    can be used for both POST and GET requests and should be used when we need to
    make multiple requests to the same service.
  prefs: []
  type: TYPE_NORMAL
- en: RSTransaction and RSTransactionRequest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RSTransaction` and `RSTransactionRequest` classes allow us to configure
    a transaction (`RSTransaction`) and then use that transaction to make a request
    (`RSTransactionRequest`) to the service. One of the things that make, this API
    so powerful is how easy it is for us to make subsequent request by simply updating
    the transaction and resubmitting it. Let's look at the API that is exposed by
    these two classes.
  prefs: []
  type: TYPE_NORMAL
- en: RSTransaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `RSTransaction` class defines the transaction we wish to make. It exposes
    four properties and one initiator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TransactionType`: This defines the HTTP request method. Currently, there are
    three types defined—GET, POST, and UNKNOWN. Only the GET and POST actually send
    a request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseURL`: This is the base URL to use for the request. This will normally
    look something like [https://itunes.apple.com](https://itunes.apple.com). If we
    are using a nonstandard port, we would follow the server URL by a colon and the
    port number such as `http://mytestserver:8080`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: This is the path that will be added to the base URL. This will be something
    like `search`. It can also include a longer path string such as `path/to/my/service`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters`: This is a `Dictionary` object containing the parameters to send
    to the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The initiator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init(transactionType: RSTransactionType, baseURL: String, path: String, parameters:
    [String: String])`: This will initialize the `RSTransaction` class with all the
    required properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSTransactionRequest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `RSTransactionRequest` class builds and sends out the request that is defined
    by the four functions, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dataFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.dataFromRSTransactionCompletionCompletionClosure)`: This function
    retrieves an `NSData` object from the service defined by the `RSTransaction` class.
    This is the main function and is used by the other three functions to retrieve
    the `NSData` object prior to converting it to the requested format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.stringFromRSTransactionCompletionCompletionClosure)`: This functionfn-=
    retrieves an `NSString` object from the service defined by the `RSTransaction`
    class. This function uses the `dataFromRSTransaction()` function to retrieve the
    `NSData` object and then converts it to an `NSString` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dictionaryFromRSTransaction(transaction: RSTransaction, completionHandler
    handler: RSNetworking.dictionaryFromRSTransactionCompletionCompletionClosure)`:
    This function retrieves an `NSDictionary` object from the service defined by the
    `RSTransaction` class. This function uses the `dataFromRSTransaction()` function
    to retrieve the `NSData` object and then converts it to an `NSDictionary` object.
    The data returned from the URL should be in the JSON format for this function
    to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.imageFromRSTransactionCompletionCompletionClosure)`: This function
    retrieves a `UIImage` object from the service defined by the `RSTransaction` class.
    This function uses the `dataFromRSTransaction()` function to retrieve the `NSData`
    object and then converts it to a `UIImage` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at an example of how we would use the `RSTransaction` and
    `RSTransactionRequest` classes to make a GET request to Apple''s iTunes search
    API. In this example, we will use the same `resultsHandler` closure that we defined
    in the *RSURLRequest* section of this chapter. Let''s take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by creating an instance of the `RSTransactionRequest`
    class named `rsRequest`. This `RSTransactionRequest` instance will be used to
    send our request to the service defined in our `RSTransaction` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we create the `RSTransactionRequest` instance, we use the `RSTransaction`
    initiator to create an instance of the `RSTransction` class named `rsTransGet`.
    In this initiator, we define the following properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transactionType`: The `transactionType` is set to `RSTransactionType`.GET
    (this can also be `RSTransactionType`.POST or `RSTransactionType`. UNKNOWN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseURL`: The `baseURL` is set to [https://itunes.apple.com](https://itunes.apple.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The `path` is set to search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters`: The parameter is set to `["term":"jimmy+buffett","media":"music"]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use the `dictionaryFromRSTransaction()` method of the `RSTransactionRequest`
    instance. This method accepts two parameters; the first being the `RSTransaction`
    instance that defines the transaction to send and the second being the completion
    handler that will be called once the data is returned from the service.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, one of the things that makes the `RSTransaction` and
    `RSTransactionRequest` classes so nice to use is how easy it is to make subsequent
    requests to the same service. In our example, after we make the initial request,
    we then change the parameters and make a second request to the same service. One
    thing to watch out for is that since these are asynchronous requests, if we make
    two back-to-back requests like this, we cannot guarantee which request will be
    returned first.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the last part of the `RSNetworking2` library—the extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, extensions add new functionality to the existing classes. `RSNetworking2`
    has extensions for the `UIImageView` and `UIbutton` classes. These extensions
    allow us to load images from a URL and then add them to `UIImageView` or `UIButton`,
    once the image has finished downloading. We can also put a placeholder image that
    will be displayed in `UIImageView` or `UIButton` until the final image is downloaded.
    Once the image finishes downloading, the placeholder image will be replaced by
    the downloaded image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `UIImageView` and `UIButton` extensions expose four new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setImageForURL(url: NSString, placeHolder: UIImage)`: This method sets the
    image of the `UIImageView` or `UIButton` extensions to the placeholder image and
    then asynchronously downloads the image from the provided URL. Once the image
    downloads, it will replace the placeholder image with the downloaded image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setImageForURL(url: NSString)`: This asynchronously downloads the image from
    the URL. Once the image is downloaded, it sets the image of the `UIImageView`
    or `UIButton` extensions to the downloaded image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setImageForRSTransaction(transaction:RSTransaction, placeHolder: UIImage)`:
    This method sets the image in `UIImageView` or `UIButton` to the placeholder image
    and then asynchronously downloads the image from the provided `RSTransaction`
    object. Once the image downloads, it will replace the placeholder image with the
    downloaded image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setImageForRSTransaction(transaction:RSTransaction)`: This asynchronously
    downloads the image from the provided `RSTransaction` object. Once the image downloads,
    it sets the image of the `UIImageView` or `UIButton` extensions to the downloaded
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `UIButton` and `UIImageView` extensions are used in exactly the same way.
    To see how to use these extensions, let''s take a look at how we would use the
    `UIImageView` extension to view an image that we download from the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start off by defining the URL of our image. We then verify
    that the `imageView` variable contains an instance of a `UIImageView` class. Note
    that we normally would not define the constant type (the `UIImageView` type) in
    an `if-let` statement, but I defined the type in this example to show that the
    `imageView` constant should be an instance of the `UIImageView` class. Next, we
    create an instance of the `UIImage` class with the image named `loading`. This
    image will be used as the placeholder image and will be displayed while we are
    downloading the final image from the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the URL of the image and the placeholder image, we use the
    `setImageForURL()` extension method. This method accepts two parameters—the URL
    to download the image from and the placeholder image. Once we call this method,
    `RSNetworking2` will set the image of the `UIImageView` class to the placeholder
    image that is provided and then download the image from the URL provided. Once
    the image finishes downloading, `RSNetworking2` will replace the placeholder image
    with the downloaded image.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at a few brief examples of `RSNetworking2` in this chapter. There
    are additional examples on the `RSNetworking2` GitHub site at [https://github.com/hoffmanjon/RSNetworking2](https://github.com/hoffmanjon/RSNetworking2).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, it is essential that a developer have a good working knowledge
    of network development. In this chapter, we saw how to use Apple's `NSURLSession`
    API, with other classes, to connect to HTTP REST-based web services. The `NSURLSession`
    API was written as a replacement for the older `NSURLConnection` API and is now
    the recommended API to use when making network requests.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to use Apple's system configuration API to figure out what type
    of network connection we have. If we are developing applications for a mobile
    device (iPhone, iPod, or iPad), it is essential to know whether we have a network
    connection and what type of connection it is.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter discussing `RSNetworking2`, which is an open source network
    library, written entirely in Swift, that I maintain. `RSNetworking2` allows us
    to very quickly and easily add network functionality to our applications. It also
    adds an extension to both the `UIImageView` and `UIButton` classes to dynamically
    load images from the Internet and display them after the download is complete.
    I would encourage anyone who wishes to participate in the development of RSNetworking.
  prefs: []
  type: TYPE_NORMAL
