- en: Chapter 16. Network Development with Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章：使用Swift进行网络开发
- en: I took several networking courses when I was in college, and I still recall
    setting up my first Novell NetWare network in one of those courses. I was absolutely
    fascinated to see and learn how computers communicated over the network. Then,
    in the early 90s, I bought my first modem and started dialing into bulletin board
    services that were local to me. This was really exciting because now I could connect
    to bulletin board services that were located in the city that I lived in. This
    allowed me to download and upload files from these bulletin board services, and
    I started downloading everything I could find that talked about how computers
    communicated. This led to my early career in network security and administration.
    Then, when my first daughter was born, I decided that I did not want to be on
    call all the time, so I went back to what got me into computers in the first place,
    which was programming. However, I still really enjoyed the field of networking
    and network security. My background in both networking and programming has given
    me a unique understanding of both. What constitutes networking today (the Internet
    and TCP/IP networks) is completely different to what constituted networking back
    when I was in college, but the good thing is how our applications communicate
    over the network has become much more standardized, which makes it easier to write
    applications that communicate over a network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我在大学期间选修了几门网络课程，至今仍记得在那些课程中搭建我的第一个Novell NetWare网络。看到并学习计算机如何在网络上进行通信，我感到无比着迷。然后，在20世纪90年代初，我购买了第一台调制解调器，并开始拨打我所在地区的公告板服务。这真的很令人兴奋，因为现在我可以连接到我所在城市的公告板服务。这使我能够从这些公告板服务下载和上传文件，我开始下载我能找到的所有关于计算机通信的内容。这导致了我早期在网络安全和管理领域的职业生涯。然后，当我的第一个女儿出生时，我决定我不想总是处于待命状态，所以我回到了最初让我接触计算机的事情，那就是编程。然而，我仍然非常享受网络和网络安全的领域。我在网络和编程方面的背景使我能够对两者都有独特的理解。今天构成网络的东西（互联网和TCP/IP网络）与我在大学时构成网络的东西完全不同，但好事是，我们的应用程序通过网络进行通信的方式已经变得更加标准化，这使得编写通过网络进行通信的应用程序变得更加容易。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: How to make an HTTP GET request using the `NSURLSession` API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`NSURLSession` API进行HTTP GET请求
- en: How to make an HTTP POST request using the `NSURLSession` API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`NSURLSession` API进行HTTP POST请求
- en: How to use the System Configuration API to check our network connection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用系统配置API检查我们的网络连接
- en: How to use the `RSNetworking2` library to easily add network functionality to
    your applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`RSNetworking2`库轻松地将网络功能添加到你的应用程序中
- en: What is network development?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络开发是什么？
- en: Network development is writing code that will allow our application to send
    and receive data from remote services or devices. In the introduction of this
    chapter, I mentioned buying my first modem and connecting with bulletin board
    services across the city that I lived in. The large majority of these bulletin
    board services used a single modem, which meant that only one user could connect
    to them at any one time. These bulletin boards would seem very strange and archaic
    for those that grew up with the Internet; however, back then, they were how computers
    shared information. At that time, being able to connect to a computer across town
    and upload/download files was amazing. Today, however, we communicate with services
    and devices all over the world without thinking twice about it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发是编写代码，使我们的应用程序能够从远程服务或设备发送和接收数据。在本章的引言中，我提到了购买我的第一台调制解调器，并连接到我所在城市的公告板服务。这些公告板服务中的大多数使用单个调制解调器，这意味着在任何时候只有一个用户可以连接到它们。对于在互联网环境中长大的人来说，这些公告板看起来非常奇怪和过时；然而，在当时，它们是计算机共享信息的方式。当时，能够连接到镇上的计算机并上传/下载文件是非常令人惊叹的。然而，如今，我们与世界各地的服务和设备进行通信，却无需多想。
- en: Back then when I first started writing applications, it was rare to develop
    an application that communicated over a networked connection, and it was also
    hard to find developers with experience in network development. In today's world,
    just about every application has a requirement for some sort of network communication.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我刚开始编写应用程序的时候，开发一个通过网络连接进行通信的应用程序是很罕见的，而且也很难找到有网络开发经验的开发者。在当今世界，几乎每个应用程序都有某种网络通信的要求。
- en: In this chapter, we will show you how to connect to **Representational State
    Transfer** (**REST**)-based web services. Representational State Transfer is the
    software architectural style of the World Wide Web. Typically, these services
    communicate over HTTP using the same HTTP verbs (get, put, delete, and post) which
    web browsers use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何连接到基于 **表示状态转移** （**REST**） 的网络服务。表示状态转移是万维网的软件架构风格。通常，这些服务通过HTTP使用与网页浏览器相同的HTTP动词（get、put、delete和post）进行通信。
- en: In this chapter, we will use the REST-based service that Apple supplies, which
    lets developers search the iTunes Store. We will be using Apple's service for
    several examples in this chapter. Apple has documented this service very well.
    The documentation can be found at [https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用苹果提供的基于REST的服务，允许开发者搜索iTunes Store。在本章中，我们将使用苹果的服务进行几个示例。苹果对这个服务进行了很好的文档记录。文档可以在[https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html](https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html)找到。
- en: If you would like a more detailed discussion on network development, I would
    recommend you to read my first book, titled *iOS and OS X Network Programming
    Cookbook*, by *Packt Publishing*. In this chapter, we will be focusing on how
    to connect to the standard REST-based services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对网络开发进行更详细的讨论，我建议您阅读我的第一本书，书名为 *iOS和OS X网络编程食谱*，由 *Packt Publishing* 出版。在本章中，我们将专注于如何连接到基于标准的REST服务。
- en: Before we look at how to connect to REST services, let's look at the classes
    in Apple's networking API that we will be using. These classes are part of Apple's
    powerful URL loading system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何连接到REST服务之前，让我们看看我们将要使用的苹果网络API中的类。这些类是苹果强大的URL加载系统的一部分。
- en: An overview of the URL session classes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL会话类的概述
- en: 'Apple''s URL loading system is a framework of classes available to interact
    with URLs. Using these classes together lets us communicate with services that
    use standard Internet protocols. The classes that we will be using in this chapter
    to connect to and retrieve information from REST services are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的URL加载系统是一个框架，提供了一系列用于与URL交互的类。使用这些类一起，我们可以与使用标准互联网协议的服务进行通信。在本章中，我们将使用以下类来连接到并从REST服务检索信息：
- en: '`NSURLSession`: This is the main session object. It was written as a replacement
    for the older `NSURLConnection` API.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSURLSession`: 这是主要的会话对象。它被编写为旧 `NSURLConnection` API 的替代品。'
- en: '`NSURLSessionConfiguration`: This is used to configure the behavior of the
    `NSURLSession` object.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSURLSessionConfiguration`: 这用于配置 `NSURLSession` 对象的行为。'
- en: '`NSURLSessionTask`: This is a base class to handle the data being retrieved
    from the URL. Apple provides three concrete subclasses of the `NSURLSessionTask`
    class.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSURLSessionTask`: 这是一个处理从URL检索的数据的基类。苹果为 `NSURLSessionTask` 类提供了三个具体的子类。'
- en: '`NSURL`: This is an object that represents the URL to connect to.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSURL`: 这是一个表示要连接到的URL的对象。'
- en: '`NSMutableURLRequest`: This class contains information about the request that
    we are making and is used by the `NSURLSessionTask` service to make the request.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSMutableURLRequest`: 这个类包含我们正在发出的请求的信息，并由 `NSURLSessionTask` 服务用于发出请求。'
- en: '`NSHTTPURLResponse`: This class contains the response to our request.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSHTTPURLResponse`: 这个类包含对我们请求的响应。'
- en: Now, let's look at each of these classes a little more in depth so that we have
    a basic understanding of what each does.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地看看这些类中的每一个，以便我们对每个类的基本功能有一个基本的了解。
- en: NSURLSession
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSURLSession
- en: Prior to iOS 7 and OS X 10.9, when a developer wanted to retrieve contents from
    a URL, he/she used the `NSURLConnection` API. Starting with iOS 7 and OS X 10.9,
    `NSURLSession` became the preferred API. The `NSURLSession` API can be thought
    of as an improvement to the older `NSURLConnection` API.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 7和OS X 10.9之前，当开发者想要从URL检索内容时，他们使用 `NSURLConnection` API。从iOS 7和OS X 10.9开始，`NSURLSession`
    成为首选API。`NSURLSession` API可以被视为对较旧的 `NSURLConnection` API 的改进。
- en: An `NSURLSession` object provides an API for interacting with various protocols
    such as HTTP and HTTPS. The session object, which is an instance of the `NSURLSession`,
    manages this interaction. These session objects are highly configurable, which
    allows us to control how our requests are made and how we handle the data that
    is returned.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSession` 对象提供了一个与各种协议（如 HTTP 和 HTTPS）交互的 API。会话对象，即 `NSURLSession` 的实例，管理这种交互。这些会话对象高度可配置，这使我们能够控制我们的请求方式以及我们如何处理返回的数据。'
- en: Like most networking API, `NSURLSession` is asynchronous. This means that we
    have to provide a way to return the response from the service back to the code
    that needs it. The most popular way to return the results from a session is to
    pass a completion handler block (closure) to the session. This completion handler
    is then called when the service successfully responds or we receive an error.
    All of the examples in this chapter use completion handlers to process the data
    that is returned from the services.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数网络 API 一样，`NSURLSession` 是异步的。这意味着我们必须提供一种方式将服务的响应返回给需要它的代码。从会话返回结果的最流行方式是将完成处理程序块（闭包）传递给会话。然后，当服务成功响应或我们收到错误时，将调用此完成处理程序。本章中的所有示例都使用完成处理程序来处理从服务返回的数据。
- en: NSURLSessionConfiguration
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSURLSessionConfiguration
- en: The `NSURLSessionConfiguration` class defines the behavior and policies to use
    when using the `NSURLSession` object to connect to a URL. When using the `NSURLSession`
    object, we usually create an `NSURLSessionConfiguration` instance first because
    an instance of this class is required when we create an instance of the `NSURLSession`
    class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSessionConfiguration` 类定义了在使用 `NSURLSession` 对象连接到 URL 时使用的行为和策略。当使用
    `NSURLSession` 对象时，我们通常首先创建一个 `NSURLSessionConfiguration` 实例，因为创建 `NSURLSession`
    类的实例时需要这个类的实例。'
- en: 'The `NSURLSessionConfiguration` class defines three session types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSessionConfiguration` 类定义了三种会话类型：'
- en: '**Default session configuration**: This configuration behaves similar to the
    `NSURLConnection` API'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认会话配置**: 这种配置的行为类似于 `NSURLConnection` API'
- en: '**Ephemeral session configuration**: This configuration behaves similar to
    the default session configuration, except that it does not cache anything to disk'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临时会话配置**: 这种配置的行为类似于默认会话配置，不同之处在于它不会将任何内容缓存在磁盘上'
- en: '**Background session configuration**: This session allows for uploads and downloads
    to be performed, even when the app is running in the background'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台会话配置**: 这种会话允许在应用程序在后台运行时执行上传和下载操作'
- en: It is important to note that we should make sure that we configure the `NSURLSessionConfiguration`
    object appropriately before we use it to create an instance of the `NSURLSession`
    class. When the session object is created, it creates a copy of the configuration
    object that we provided it. Any changes made to the configuration object once
    the session object is created are ignored by the session. If we need to make changes
    to the configuration, we must create another instance of the `NSURLSession` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，在使用它来创建 `NSURLSession` 类的实例之前，我们应该确保适当地配置 `NSURLSessionConfiguration`
    对象。当会话对象被创建时，它会创建我们提供的配置对象的副本。一旦创建会话对象，对配置对象所做的任何更改都会被会话忽略。如果我们需要更改配置，我们必须创建 `NSURLSession`
    类的另一个实例。
- en: NSURLSessionTask
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSURLSessionTask
- en: 'The `NSURLSession` service uses an instance of the `NSURLSessionTask` classes
    to make the call to the service that we are connecting to. The `NSURLSessionTask`
    class is a base class, and Apple has provided three concrete subclasses that we
    can use:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSession` 服务使用 `NSURLSessionTask` 类的实例来调用我们正在连接的服务。`NSURLSessionTask`
    类是一个基类，苹果提供了三个具体的子类供我们使用：'
- en: '`NSURLSessionDataTask`: This returns the response, in memory, directly to the
    application as one or more `NSData` objects. This is the task that we generally
    use most often.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSURLSessionDataTask`: 这会将响应，以内存中的形式，直接作为一个或多个 `NSData` 对象返回给应用程序。这是我们通常最常使用的任务。'
- en: '`NSURLSessionDownloadTask`: This writes the response directly to a temporary
    file.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSURLSessionDownloadTask`: 这会将响应直接写入一个临时文件。'
- en: '`NSURLSessionUploadTask`: This is used for making requests that require a request
    body such as a POST or PUT request.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSURLSessionUploadTask`: 这用于制作需要请求体（如 POST 或 PUT 请求）的请求。'
- en: It is important to note that a task will not send the request to the service
    until we call the `resume()` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，任务不会向服务发送请求，直到我们调用 `resume()` 方法。
- en: Using the NSURL class
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NSURL 类
- en: The `NSURL` object represents the URL that we are going to connect to. The `NSURL`
    class is not limited to URLs that represent remote servers, but it can also be
    used to represent a local file on disk. In this chapter, we will be using the
    `NSURL` class exclusively to represent the URL of the remote service that we are
    connecting to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURL`对象代表我们将要连接到的URL。`NSURL`类不仅限于表示远程服务器的URL，它也可以用来表示磁盘上的本地文件。在本章中，我们将专门使用`NSURL`类来表示我们连接到的远程服务的URL。'
- en: NSMutableURLRequest
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSMutableURLRequest
- en: The `NSMutableURLRequest` class is a mutable subclass of the `NSURLRequest`
    class, which represents a URL load request. We use the `NSMutableRequest` class
    to encapsulate our URL and the request properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSMutableURLRequest`类是`NSURLRequest`类的可变子类，它表示一个URL加载请求。我们使用`NSMutableRequest`类来封装我们的URL和请求属性。'
- en: It is important to understand that the `NSMutableURLRequest` class is used to
    encapsulate the necessary information to make our request, but it does not make
    the actual request. To make the request, we use instances of the `NSURLSession`
    and `NSURLSessionTask` classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，`NSMutableURLRequest`类用于封装我们请求所需的信息，但它并不实际发出请求。为了发出请求，我们使用`NSURLSession`和`NSURLSessionTask`类的实例。
- en: NSURLHTTPResponse
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSURLHTTPResponse
- en: The `NSURLHTTPResponse` class is a subclass of the `NSURLResponse` class that
    encapsulates the metadata associated with the response to a URL request. The `NSURLHTTPResponse`
    class provides methods for accessing specific information associated with an HTTP
    response. Specifically, this class allows us to access the HTTP header fields
    and the response status codes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLHTTPResponse`类是`NSURLResponse`类的子类，它封装了与URL请求响应相关的元数据。`NSURLHTTPResponse`类提供了访问与HTTP响应相关特定信息的方法。具体来说，这个类允许我们访问HTTP头字段和响应状态码。'
- en: We briefly covered a number of classes in this section and it may not be clear
    how they all actually fit together; however, once you see the examples a little
    further in this chapter, it will become much clearer. Before we go into our examples,
    let's take a quick look at the type of service that we will be connecting to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中简要介绍了多个类，它们如何实际结合在一起可能并不清楚；然而，一旦你看到本章稍后的一些示例，就会变得非常清晰。在我们进入示例之前，让我们快速了解一下我们将要连接到的服务类型。
- en: REST web services
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST网络服务
- en: REST has become one of the most important technologies for stateless communications
    between devices. Due to the lightweight and stateless nature of the REST-based
    services, its importance is likely to continue to grow as more devices are connected
    to the Internet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: REST已成为设备之间无状态通信最重要的技术之一。由于基于REST的服务轻量级和无状态的特性，随着更多设备连接到互联网，其重要性可能会继续增长。
- en: REST is an architecture style for designing networked applications. The idea
    behind REST is that instead of using complex mechanisms, such as SOAP or CORBA
    to communicate between devices, we use simple HTTP requests for the communication.
    While, in theory, REST is not dependent on the Internet protocols, it is almost
    always implemented using them. Therefore, when we are accessing REST services,
    we are almost always interacting with web servers in the same way that our web
    browsers interact with these servers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种用于设计网络应用程序的架构风格。REST背后的理念是，我们不是使用复杂的机制，如SOAP或CORBA在设备之间进行通信，而是使用简单的HTTP请求进行通信。虽然从理论上讲，REST不依赖于互联网协议，但它几乎总是使用它们来实现。因此，当我们访问REST服务时，我们几乎总是以与我们的网络浏览器与这些服务器交互相同的方式与Web服务器进行交互。
- en: REST web services use the HTTP POST, GET, PUT, or DELETE methods. If we think
    about a standard CRUD (create/read/update/delete) application, we would use a
    POST request to create or update data, a GET request to read data, and a DELETE
    request to delete data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: REST网络服务使用HTTP POST、GET、PUT或DELETE方法。如果我们考虑一个标准的CRUD（创建/读取/更新/删除）应用程序，我们会使用POST请求来创建或更新数据，使用GET请求来读取数据，使用DELETE请求来删除数据。
- en: When we type a URL into our browser's address bar and hit *Enter*, we are generally
    making a GET request to the server and asking it to send us the web page associated
    with that URL. When we fill out a web form and click the submit button, we are
    generally making a POST request to the server. We then include the parameters
    from the web form in the body of our POST request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器的地址栏中输入一个URL并按*Enter*键时，我们通常是在向服务器发送一个GET请求，并要求它发送与该URL相关的网页。当我们填写一个网页表单并点击提交按钮时，我们通常是在向服务器发送一个POST请求。然后我们在POST请求的主体中包含网页表单的参数。
- en: Now, let's look at how to make an HTTP GET request using Apple's networking
    API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用苹果的网络API发起HTTP GET请求。
- en: Making an HTTP GET request
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发起HTTP GET请求
- en: In this example, we will make a GET request to Apple's iTunes search API to
    get a list of items related to the search term Jimmy Buffett. Since we are retrieving
    data from the service, by REST standards, we should use a GET request to retrieve
    the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将向苹果的iTunes搜索API发起一个GET请求，以获取与搜索词Jimmy Buffett相关的项目列表。由于我们从服务中检索数据，根据REST标准，我们应该使用GET请求来检索数据。
- en: While the REST standard is to use GET requests to retrieve data from a service,
    there is nothing stopping a developer of a web service from using a GET request
    to create or update a data object. It is not recommended to use a GET request
    in this manner, but just be aware that there are services out there that do not
    adhere to the REST standards.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然REST标准是使用GET请求从服务中检索数据，但没有任何阻止Web服务的开发者使用GET请求来创建或更新数据对象。不推荐以这种方式使用GET请求，但请记住，有些服务并不遵循REST标准。
- en: 'The following code makes a request to Apple''s iTunes search API and then prints
    the results to the console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向苹果的iTunes搜索API发起请求，并将结果打印到控制台：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We start off by creating a type alias named `DataFromURLCompletionClosure`.
    The `DataFromURLCompletionClosure` type will be used for both the GET and POST
    examples of this chapter. If you are not familiar with using a `typealias` object
    to define a closure type, please refer to [Chapter 12](ch12.html "Chapter 12. Working
    with Closures"), *Working with Closures*, for more information.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`DataFromURLCompletionClosure`的类型别名。`DataFromURLCompletionClosure`类型将用于本章的GET和POST示例。如果您不熟悉使用`typealias`对象来定义闭包类型，请参阅[第12章](ch12.html
    "第12章。使用闭包")，*使用闭包*，以获取更多信息。
- en: We then create a function named `sendGetRequest()` that will be used to make
    the GET request to Apple's iTunes API. This function accepts one argument named
    handler, which is a closure that conforms to the `DataFromURLCompletionClosure`
    type. The handler closure will be used to return the results from the request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个名为`sendGetRequest()`的函数，该函数将用于向苹果的iTunes API发起GET请求。这个函数接受一个名为handler的参数，它是一个符合`DataFromURLCompletionClosure`类型的闭包。handler闭包将用于返回请求的结果。
- en: Within our `sendGetRequest()` method, we begin by creating an instance of the
    `NSURLSessionConfiguration` class using the `defaultSessionConfiguration()` method,
    which creates a default session configuration instance. If we need to, we can
    modify the session configuration properties after we create it, but in this example,
    the default configuration is what we want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`sendGetRequest()`方法中，我们首先使用`defaultSessionConfiguration()`方法创建一个`NSURLSessionConfiguration`类的实例，这会创建一个默认会话配置实例。如果我们需要，我们可以在创建后修改会话配置属性，但在这个例子中，我们想要的是默认配置。
- en: After we create our session configuration, we create the URL string. This is
    the URL of the service we are connecting to. With a GET request, we put our parameters
    in the URL itself. In this specific example, `https://itunes.apple.com/search`
    is the URL of the web service. We then follow the web service URL with a question
    mark (`?`), which indicates that the rest of the URL string consists of parameters
    for the web service.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的会话配置之后，我们创建URL字符串。这是我们要连接到的服务的URL。在GET请求中，我们将参数放在URL本身中。在这个特定的例子中，`https://itunes.apple.com/search`是Web服务的URL。然后我们用问号（`?`）跟随Web服务URL，这表示URL字符串的其余部分由Web服务的参数组成。
- en: The parameters take the form of key/value pairs, which means that each parameter
    has a key and a value. The key and value of a parameter, in a URL, are separated
    by an equals sign (`=`). In our example, the key is `term` and the value is `jimmy+buffett`.
    Next, we run the URL string that we just created through the `stringByAddingPercentEncodingWithAllowedCharacters()`
    method to make sure our URL string is encoded properly. We use the `URLQueryAllowedCharacterSet`
    character set with this method to ensure we have a valid URL string.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的形式是键/值对，这意味着每个参数都有一个键和一个值。在URL中，参数的键和值由等号（`=`）分隔。在我们的例子中，键是`term`，值是`jimmy+buffett`。接下来，我们通过`stringByAddingPercentEncodingWithAllowedCharacters()`方法运行我们刚刚创建的URL字符串，以确保我们的URL字符串已正确编码。我们使用`URLQueryAllowedCharacterSet`字符集与此方法一起使用，以确保我们有一个有效的URL字符串。
- en: Next, we use the URL string that we just built to create an `NSURL` instance
    named `url`. Since we are making a GET request, this `NSURL` instance will represent
    both the location of the web service and the parameters that we are sending to
    it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们刚刚构建的 URL 字符串来创建一个名为 `url` 的 `NSURL` 实例。由于我们正在执行 GET 请求，这个 `NSURL`
    实例将代表网络服务的位置和我们发送给它的参数。
- en: We create an instance of the `NSMutableURLRequest` class using the `NSURL` instance
    that we just created. We use the `NSMutableURLRequest` class, instead of the `NSURLRequest`
    class so that we can set the properties needed for our request. In this example,
    we set the `HTTPMethod` property; however, we can also set other properties such
    as the timeout interval or add items to our HTTP header.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们刚刚创建的 `NSURL` 实例创建一个 `NSMutableURLRequest` 类的实例。我们使用 `NSMutableURLRequest`
    类而不是 `NSURLRequest` 类，这样我们就可以设置我们请求所需的属性。在这个例子中，我们设置了 `HTTPMethod` 属性；然而，我们也可以设置其他属性，例如超时间隔或向我们的
    HTTP 标头添加项。
- en: Now, we use the `sessionConfiguration` variable (instance of the `NSURLSessionConfiguration
    class`) that we created at the beginning of the `sendGetRequest()` function to
    create an instance of the `NSURLSession` class. The `NSURLSession` class provides
    the API that we will use to connect to Apple's iTunes search API. In this example,
    we use the `dataTaskWithRequest()` method of the `NSURLSession` instance to return
    an instance of the `NSURLSessionDataTask` instance named `sessionTask`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用在 `sendGetRequest()` 函数开头创建的 `sessionConfiguration` 变量（`NSURLSessionConfiguration`
    类的实例）来创建 `NSURLSession` 类的实例。`NSURLSession` 类提供了我们将用于连接到苹果的 iTunes 搜索 API 的 API。在这个例子中，我们使用
    `NSURLSession` 实例的 `dataTaskWithRequest()` 方法来返回名为 `sessionTask` 的 `NSURLSessionDataTask`
    实例。
- en: The `sessionTask` instance is what makes the request to the iTunes search API.
    When we receive the response from the service, we use the handler callback to
    return both the `NSURLResponse` object and the `NSData` object. The `NSURLResponse`
    contains information about the response, and the `NSData` instance contains the
    body of the response.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionTask` 实例是向 iTunes 搜索 API 发送请求的部分。当我们从服务收到响应时，我们使用处理程序回调来返回 `NSURLResponse`
    对象和 `NSData` 对象。`NSURLResponse` 包含有关响应的信息，而 `NSData` 实例包含响应的主体。'
- en: Finally, we call the `resume()` method of the `NSURLSessionDataTask` instance
    to make the request to the web service. Remember, as we mentioned earlier, an
    `NSURLSessionTask` instance will not send the request to the service until we
    call the `resume()` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `NSURLSessionDataTask` 实例的 `resume()` 方法来向网络服务发送请求。记住，正如我们之前提到的，一个 `NSURLSessionTask`
    实例将不会向服务发送请求，直到我们调用 `resume()` 方法。
- en: 'Now, let''s look at how we would call the `sendGetRequest()` function. The
    first thing we need to do is to create a closure that will be passed to the `sendGetRequest()`
    function and called when the response from the web service is received. In this
    example, we will simply print the response to the console. Since the response
    is in the JSON format, we could use the `NSJSONSerialization` class, as describe
    in [Chapter 8](ch08.html "Chapter 8. Working with XML and JSON Data"), *Working
    with XML and JSON Data*, to parse the response; however, since this chapter is
    on networking, we will simply print the response to the console. Here is the code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何调用 `sendGetRequest()` 函数。首先，我们需要做的是创建一个闭包，该闭包将被传递给 `sendGetRequest()`
    函数并在收到网络服务的响应时被调用。在这个例子中，我们将简单地打印响应到控制台。由于响应是 JSON 格式，我们可以使用在 [第 8 章](ch08.html
    "第 8 章。处理 XML 和 JSON 数据") 中描述的 `NSJSONSerialization` 类来解析响应；然而，由于本章是关于网络编程，我们只需将响应打印到控制台。以下是代码：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We define this closure, named `printResultsClosure`, to be an instance of the
    `DataFromURLCompletionClosure` type. Within the closure, we unwrap the first parameter
    and set the value to a constant named `data`. If the first parameter is not nil,
    we convert the data constant to an instance of the `NSString` class, which is
    then printed to the console.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义这个闭包，命名为 `printResultsClosure`，为 `DataFromURLCompletionClosure` 类型的实例。在闭包内部，我们解包第一个参数并将值设置为名为
    `data` 的常量。如果第一个参数不是 nil，我们将数据常量转换为 `NSString` 类的实例，然后将其打印到控制台。
- en: 'Now, let''s call the `sendGetRequest()` method with the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码调用 `sendGetRequest()` 方法：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code creates an instance of the `HttpConnect` class and then calls the
    `sendGetRequest()` method, passing the `printResultsClosure` closure as the only
    parameter. If we run this code while we are connected to the Internet, we will
    receive a JSON response that contains a list of items related to Jimmy Buffett
    on iTunes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个`HttpConnect`类的实例，然后调用`sendGetRequest()`方法，将`printResultsClosure`闭包作为唯一参数传递。如果我们连接到互联网时运行此代码，我们将收到一个包含与iTunes上吉米·巴菲特相关项目的JSON响应。
- en: Now that we have seen how to make a simple HTTP GET request, let's look at how
    we would make an HTTP POST request to a web service.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何发起一个简单的HTTP GET请求，让我们看看如何向一个网络服务发起HTTP POST请求。
- en: Making an HTTP POST request
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发起HTTP POST请求
- en: Since Apple's iTunes, APIs use GET requests to retrieve data. In this section,
    we will use the free [http://httpbin.org](http://httpbin.org) service to show
    you how to make a POST request. The POST service that [http://httpbin.org](http://httpbin.org)
    provides can be found at [http://httpbin.org/post](http://httpbin.org/post). This
    service will echo back the parameters that it receives so that we can verify that
    our request was made properly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于苹果的iTunes，API使用GET请求来检索数据。在本节中，我们将使用免费的[http://httpbin.org](http://httpbin.org)服务向您展示如何发起POST请求。[http://httpbin.org](http://httpbin.org)提供的POST服务可以在[http://httpbin.org/post](http://httpbin.org/post)找到。此服务将回显它接收到的参数，以便我们可以验证我们的请求是否正确发起。
- en: 'When we make a POST request, we generally have some data that we want to send
    or post to the server. This data takes the form of key/value pairs. These pairs
    are separated by an ampersand (`&`) symbol, and each key is separated from its
    value by an equals sign (`=`). As an example, let''s say that we want to submit
    the following data to our service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发起POST请求时，我们通常有一些想要发送或提交给服务器的数据。这些数据以键/值对的形式存在。这些对之间由一个和号（`&`）符号分隔，每个键与其值之间由一个等号（`=`）分隔。作为一个例子，假设我们想要提交以下数据到我们的服务：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The body of the POST request would take the following format:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: POST请求的正文将采用以下格式：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once we have the data in the proper format, we will then use the `dataUsingEncoding()`
    method, as we did with the GET request to properly encode the POST data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了合适格式的数据，我们就会使用`dataUsingEncoding()`方法，就像我们在对GET请求进行正确编码POST数据时所做的那样。
- en: 'Since the data going to the server is in the key/value format, the most appropriate
    way to store this data, prior to sending it to the service, is with a `Dictionary`
    object. With this in mind, we will need to create a method that will take a `Dictionary`
    object and return a string object that can be used for the POST request. The following
    code will do that:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送到服务器的数据是键/值格式，因此在发送到服务之前，最合适的方式是使用`Dictionary`对象来存储这些数据。考虑到这一点，我们需要创建一个方法，该方法将接受一个`Dictionary`对象并返回一个字符串对象，该对象可以用于POST请求。以下代码将实现这一点：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function loops through each key/value pair of the `Dictionary` object and
    creates a `String` object that contains the key and the value separated by the
    equals sign (`=`). We then use the `joinWithSeperator()` function to join each
    item in the array, separated by the specified sting. In our case, we want to separate
    each string with the ampersand symbol (`&`). We then return this newly created
    string to the code that called it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数遍历`Dictionary`对象中的每个键/值对，并创建一个包含键和值（由等号`=`分隔）的`String`对象。然后我们使用`joinWithSeperator()`函数将数组中的每个项目连接起来，每个项目由指定的字符串分隔。在我们的例子中，我们想要用和号符号（`&`）分隔每个字符串。然后我们将这个新创建的字符串返回给调用它的代码。
- en: 'Now, let''s create our `sendPostRequest()` function that will send the POST
    request to the [http://httpbin.org](http://httpbin.org) post service. We will
    see a lot of similarities between this `sendPostRequest()` function and the `sendGetRequest()`
    function, which we showed you in the *Making an HTTP GET request* section of this
    chapter. Let''s take a look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`sendPostRequest()`函数，该函数将发送POST请求到[http://httpbin.org](http://httpbin.org)的POST服务。我们将看到这个`sendPostRequest()`函数和我们在本章的*制作HTTP
    GET请求*部分中展示的`sendGetRequest()`函数之间有很多相似之处。让我们看一下以下代码：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's walk though this code. Notice that we are using the same type alias,
    named `DataFromURLCompletionClosure`, that we used with the `sendGetRequest()`
    function. If you are not familiar with using a `typealias` object to define a
    closure type, please refer to [Chapter 12](ch12.html "Chapter 12. Working with
    Closures"), *Working with Closures*, for more information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步分析这段代码。注意，我们正在使用与 `sendGetRequest()` 函数相同的类型别名，名为 `DataFromURLCompletionClosure`。如果你不熟悉使用
    `typealias` 对象来定义闭包类型，请参阅 [第 12 章](ch12.html "第 12 章。使用闭包")，*使用闭包*，以获取更多信息。
- en: The `sendPostRequest()` function accepts one argument named `handler`, which
    is a closure that conforms to the `DataFromURLCompletionClosure` type. The handler
    closure will be used to process the data from the [http://httpbin.org](http://httpbin.org)
    service once the service responds to our request.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendPostRequest()` 函数接受一个名为 `handler` 的参数，它是一个符合 `DataFromURLCompletionClosure`
    类型的闭包。当服务对我们的请求做出响应后，handler 闭包将被用来处理来自 [http://httpbin.org](http://httpbin.org)
    服务的数据。'
- en: Within our `sendPostRequest()` method, we start off by creating an instance
    of the `NSURLSessionConfiguration` class using the `defaultSessionConfiguration()`
    method, which creates a default session configuration instance. We are able to
    modify the session configuration properties after we create it, but, in this example,
    the default configuration is what we want.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `sendPostRequest()` 方法中，我们首先使用 `defaultSessionConfiguration()` 方法创建一个 `NSURLSessionConfiguration`
    类的实例，该方法创建一个默认会话配置实例。我们可以在创建后会话配置属性，但在这个例子中，我们想要的是默认配置。
- en: After we created our session configuration, we create our URL string. This is
    the URL of the service we are connecting to. In this example, the URL is [http://httpbin.org/post](http://httpbin.org/post).
    Next, we run the URL string that we just created through the `stringByAddingPercentEncodingWithAllowedCharacters()`
    method to make sure our URL string is encoded properly. We use the `URLQueryAllowedCharacterSet`
    character set with this method to ensure we have a valid URL string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了会话配置之后，我们创建我们的 URL 字符串。这是我们要连接到的服务的 URL。在这个例子中，URL 是 [http://httpbin.org/post](http://httpbin.org/post)。接下来，我们将我们刚刚创建的
    URL 字符串通过 `stringByAddingPercentEncodingWithAllowedCharacters()` 方法运行，以确保我们的 URL
    字符串被正确编码。我们使用 `URLQueryAllowedCharacterSet` 字符集与这个方法一起使用，以确保我们有一个有效的 URL 字符串。
- en: Next, we use the URL string that we just built to create an instance of the
    `NSURL` class named `url`. Since this is a POST request, this `NSURL` instance
    will represent the location of the web service that we are connecting to.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们刚刚构建的 URL 字符串来创建一个名为 `url` 的 `NSURL` 类实例。由于这是一个 POST 请求，这个 `NSURL`
    实例将代表我们要连接到的网络服务的位置。
- en: We now create an instance of the `NSMutableURLRequest` class using the `NSURL`
    instance that we just created. We use the `NSMutableURLRequest` class, instead
    of the `NSURLRequest` class so that we can set the properties needed for our request.
    In this example, we set the `HTTPMethod` property; however, we can also set other
    properties such as the timeout interval or add items to our HTTP header.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用我们刚刚创建的 `NSURL` 实例来创建一个 `NSMutableURLRequest` 类的实例。我们使用 `NSMutableURLRequest`
    类而不是 `NSURLRequest` 类，这样我们就可以设置我们请求所需的属性。在这个例子中，我们设置了 `HTTPMethod` 属性；然而，我们也可以设置其他属性，例如超时间隔或向我们的
    HTTP 头中添加项。
- en: Now, we use our `dictionaryToQueryString()` function, which we showed you at
    the beginning of this section, to build the data that we are going to post to
    the server. We use the `dataUsingEncoding()` function to make sure that our data
    is properly encoded prior to sending it to the server, and finally, the data is
    added to the `HTTPBody` property of the `NSMutableURLRequest` instance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用我们在本节开头展示的 `dictionaryToQueryString()` 函数来构建我们要发送到服务器的数据。我们使用 `dataUsingEncoding()`
    函数确保我们的数据在发送到服务器之前被正确编码，最后，数据被添加到 `NSMutableURLRequest` 实例的 `HTTPBody` 属性中。
- en: We use the `sessionConfiguration` variable (instance of the `NSURLSessionConfiguration
    class`) that we created at the beginning of the function to create an instance
    of the `NSURLSession` class. The `NSURLSession` class provides the API that we
    will use to connect to the post on [http://httpbin.org](http://httpbin.org) post
    service. In this example, we use the `dataTaskWithRequest()` method of the `NSURLSession`
    instance to return an instance of the `NSURLSessionDataTask` class named `sessionTask`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在函数开头创建的 `sessionConfiguration` 变量（`NSURLSessionConfiguration` 类的实例）来创建
    `NSURLSession` 类的实例。`NSURLSession` 类提供了我们将用于连接到 [http://httpbin.org](http://httpbin.org)
    POST 服务的 API。在这个例子中，我们使用 `NSURLSession` 实例的 `dataTaskWithRequest()` 方法来返回一个名为
    `sessionTask` 的 `NSURLSessionDataTask` 类的实例。
- en: The `sessionTask` instance is what makes the request to the [http://httpbin.org](http://httpbin.org)
    POST service. When we receive the response from the service, we use the handler
    callback to return both the `NSURLResponse` object and the `NSData` object. The
    `NSURLResponse` contains information about the response, and the `NSData` instance
    contains the body of the response.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionTask` 实例是用来向 [http://httpbin.org](http://httpbin.org) POST 服务发起请求的。当我们从服务收到响应时，我们使用处理程序回调来返回
    `NSURLResponse` 对象和 `NSData` 对象。`NSURLResponse` 包含有关响应的信息，而 `NSData` 实例包含响应的主体。'
- en: Finally, we call the `resume()` method of the `NSURLSessionDataTask` instance
    to make the request to the web service. Remember, as we mentioned earlier, an
    `NSURLSessionTask` class will not send the request to the service until we call
    the `resume()` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `NSURLSessionDataTask` 实例的 `resume()` 方法来向网络服务发起请求。记住，正如我们之前提到的，`NSURLSessionTask`
    类不会向服务发送请求，直到我们调用 `resume()` 方法。
- en: We can then call the `sendPostRequest()` method in exactly the same way that
    we called the `sendGetRequest()` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像调用 `sendGetRequest()` 方法一样，以完全相同的方式调用 `sendPostRequest()` 方法。
- en: When developing applications that communicate to other devices and services
    over the Internet, it is good practice to verify that we have a network connection.
    When developing mobile applications, it is also good practice to verify that we
    are not using a mobile connection (3G, 4G, and so on) to transfer large amounts
    of data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发通过互联网与其他设备和服务通信的应用程序时，验证我们是否有一个网络连接是一个好的做法。在开发移动应用程序时，验证我们不是在使用移动连接（3G、4G
    等等）传输大量数据也是一个好的做法。
- en: Let's look at how to verify that we have a network connection and what type
    of connection we have.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何验证我们是否有一个网络连接以及我们有什么类型的连接。
- en: Checking network connection
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查网络连接
- en: As we create applications that communicate with other devices and services over
    the Internet, eventually, we will want to verify that we have a network connection
    prior to making the network calls. Another thing to consider when we are writing
    mobile applications is the type of network connection that the user has. As mobile
    application developers, we need to keep in mind that our users probably have a
    mobile data plan that limits the amount of data they can send/receive in a month.
    If they exceed that limit, they may have to pay an extra fee. If our application
    sends large amounts of data, it might be appropriate to warn our user prior to
    sending this data if they are on a cellular network.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们创建通过互联网与其他设备和服务通信的应用程序，我们最终将想要验证在发起网络调用之前我们已经建立了网络连接。当我们编写移动应用程序时，还需要考虑用户所拥有的网络连接类型。作为移动应用程序开发者，我们需要记住，我们的用户可能有一个限制每月可以发送/接收的数据量的移动数据计划。如果他们超过了这个限制，他们可能需要支付额外的费用。如果我们的应用程序发送大量数据，那么在用户处于蜂窝网络的情况下，在发送这些数据之前提醒用户可能是合适的。
- en: 'This next example will show us how we can verify that we have a network connection
    and it also tells us what type of connection we have. We will begin by importing
    the system configuration API and also defining an enum that contains the different
    connection types. We will import the system configuration API like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将展示我们如何验证我们是否有一个网络连接，它还告诉我们我们有什么类型的连接。我们将首先导入系统配置 API，并定义一个包含不同连接类型的枚举。我们将以这种方式导入系统配置
    API：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We create a `ConnectionType` enum. This enum will be used as the return type
    for `networkConnectionType()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `ConnectionType` 枚举。这个枚举将被用作 `networkConnectionType()` 的返回类型：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s look at the code to check the network connection type:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看检查网络连接类型的代码：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `networkConnectionType()` function begins by creating a `SCNetworkReachability`
    reference. To create the `SCNetworkRechabilityRef` reference, we use the `SCNetworkReachabilityCreateWithName()`
    function, which creates a reachability reference to the host provided.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkConnectionType()`函数首先创建一个`SCNetworkReachability`引用。为了创建`SCNetworkRechabilityRef`引用，我们使用`SCNetworkReachabilityCreateWithName()`函数，该函数创建了一个指向提供的宿主的可达性引用。'
- en: After we get our `SCNetworkReachabilityRef` reference, we need to retrieve the
    `SCNetworkReachabilityFlags` enum from the reference. This is done with the `SCNetworkReachabilityGetFlags()`
    function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取到`SCNetworkReachabilityRef`引用之后，我们需要从引用中检索`SCNetworkReachabilityFlags`枚举。这是通过`SCNetworkReachabilityGetFlags()`函数完成的。
- en: Once we have the network reachability flags, we can begin testing our connection.
    We use the bitwise AND (`&`) operator to see whether the host is reachable and
    if we need to establish a connection before we can connect to the host (`needsConnection`).
    If the reachable flag is false (we cannot currently connect to the host), or if
    `needsConnection` is true (we need to establish a connection before we can connect),
    we return `NONETWORK`, which means the host is currently not reachable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了网络可达性标志，我们就可以开始测试我们的连接。我们使用位与（`&`）运算符来查看主机是否可达，以及在我们能够连接到主机之前是否需要建立连接（`needsConnection`）。如果可达标志为假（我们目前无法连接到主机），或者如果`needsConnection`为真（我们需要在连接之前建立连接），我们返回`NONETWORK`，这意味着主机当前不可达。
- en: If we are able to connect to the host, we then check to see whether we have
    a cellular connection by checking the network reachability flags again. If we
    have a cellular connection, we return `MOBILE3GNETWORK`, otherwise, we assume
    we have a Wi-Fi connection and return `WIFINETWORK`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够连接到主机，然后我们会检查是否有蜂窝连接，通过再次检查网络可达性标志。如果有蜂窝连接，我们返回`MOBILE3GNETWORK`，否则，我们假设我们有一个Wi-Fi连接，并返回`WIFINETWORK`。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are writing applications that connect to other devices or services over
    the Internet, I would recommend putting this function in a standard library to
    use because you will want to check for networking connectivity, and also the type
    of connection that you have pretty regularly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写连接到互联网上其他设备或服务的应用程序，我建议将此功能放入标准库中使用，因为你会经常需要检查网络连接性，以及你所拥有的连接类型。
- en: Now that we have seen how to use Apple's networking APIs to connect to remote
    services, I would like to demonstrate a network library that you can use in your
    own applications. This network library makes it very easy and simple to connect
    to various types of services on the Internet. This is a library that I created
    and maintained, but I would definitely welcome anyone that would like to contribute
    to the code base. This library is called **RSNetworking**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用苹果的网络API连接到远程服务，我想展示一个你可以用在你的应用程序中的网络库。这个网络库使得连接到互联网上各种类型的服务变得非常简单和容易。这是一个我创建和维护的库，但我肯定会欢迎任何愿意为代码库做出贡献的人。这个库叫做**RSNetworking**。
- en: RSNetworking2 for Swift 2
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 2的RSNetworking2
- en: You can find `RSNetworking2` on GitHub with [https://github.com/hoffmanjon/RSNetworking2](https://github.com/hoffmanjon/RSNetworking2)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到`RSNetworking2`，链接为[https://github.com/hoffmanjon/RSNetworking2](https://github.com/hoffmanjon/RSNetworking2)
- en: The `RSNetworking2` library is a network library written entirely in the Swift
    programming language. `RSNetworking2` is built using Apple's powerful URL loading
    system ([https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html)),
    which features the `NSURLSession` class that we used earlier in this chapter.
    The main design goal of `RSNetworking2` is to make it easy and quick for developers
    to add powerful asynchronous networking requests to their applications that are
    written in Swift.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSNetworking2`库是一个完全用Swift编程语言编写的网络库。`RSNetworking2`是使用苹果强大的URL加载系统（[https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html)）构建的，该系统具有我们在此章中较早使用的`NSURLSession`类。`RSNetworking2`的主要设计目标是使开发者能够轻松快速地将强大的异步网络请求添加到他们用Swift编写的应用程序中。'
- en: 'There are the three ways in which we can use `RSNetworking2`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`RSNetworking2`的以下三种方式：
- en: '`RSURLRequest`: This API provides a very simple and easy interface to make
    single GET requests to a service.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RSURLRequest`：此API提供了一个非常简单且易于使用的接口，用于向服务发送单个GET请求。'
- en: '`RSTransaction` and `RSTransactionRequest`: These APIs provide a very powerful
    and flexible way to make both GET and POST requests to a service. This API also
    makes it very easy to make multiple requests to a service.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RSTransaction`和`RSTransactionRequest`：这些API提供了一种非常强大且灵活的方式来对服务发起GET和POST请求。此API还使得对服务发起多个请求变得非常容易。'
- en: '`Extensions`: `RSNetworking2` provides extensions to both the `UIImageView`
    and `UIButton` classes to dynamically load images from a URL and insert them into
    the `UIImageView` or `UIButton` classes after they are loaded.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Extensions`：`RSNetworking2`为`UIImageView`和`UIButton`类提供了扩展，以便从URL动态加载图像，并在加载后将其插入到`UIImageView`或`UIButton`类中。'
- en: Let's look at each of these APIs in greater detail and then provide some examples
    of how to use them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看这些API，并提供一些使用示例。
- en: RSURLRequest
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSURLRequest
- en: 'With the `RSURLRequest` API, we can make a GET request to a service and the
    only thing we need to provide is the URL and the parameters we wish to send to
    the service. The `RSURLRequest` API exposes four functions. These functions are
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RSURLRequest` API，我们可以向服务发起GET请求，我们只需要提供URL和我们希望发送给服务的参数。`RSURLRequest` API公开了四个函数。这些函数如下：
- en: '`dataFromURL(url: NSURL, completionHandler handler: RSNetworking.dataFromURLCompletionClosure)`:
    This retrieves an `NSData` object from a URL. This is the main function and is
    used by the other three functions to retrieve an `NSData` object prior to converting
    it to the requested format.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataFromURL(url: NSURL, completionHandler handler: RSNetworking.dataFromURLCompletionClosure)`:
    这个方法从URL中检索一个`NSData`对象。这是主要函数，并被其他三个函数用来在转换成所需格式之前检索`NSData`对象。'
- en: '`stringFromURL(url: NSURL, completionHandler handler: RSNetworking.stringFromURLCompletionClosure)`:
    This retrieves an `NSString` object from a URL. This function uses the `dataFromURL()`
    function to retrieve an `NSData` object and then converts it to an `NSString`
    object.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringFromURL(url: NSURL, completionHandler handler: RSNetworking.stringFromURLCompletionClosure)`:
    这个方法从URL中检索一个`NSString`对象。此函数使用`dataFromURL()`函数来检索一个`NSData`对象，并将其转换为`NSString`对象。'
- en: '`dictionaryFromJsonURL(url: NSURL, completionHandler handler: RSNetworking.dictionaryFromURLCompletionClosure)`:
    This retrieves an `NSDictionary` object from a URL. This function uses the `dataFromURL()`
    function to retrieve an `NSData` object and then converts it to an `NSDictionary`
    object. The data returned from the URL should be in the JSON format for this function
    to work properly.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dictionaryFromJsonURL(url: NSURL, completionHandler handler: RSNetworking.dictionaryFromURLCompletionClosure)`:
    这个方法从URL中检索一个`NSDictionary`对象。此函数使用`dataFromURL()`函数来检索一个`NSData`对象，并将其转换为`NSDictionary`对象。从URL返回的数据应该是JSON格式，以便此函数能正常工作。'
- en: '`imageFromURL(url: NSURL, completionHandler handler: RSNetworking.imageFromURLCompletionClosure)`:
    This retrieves a `UIImage` object from a URL. This function uses the `dataFromURL()`
    function to retrieve an `NSData` object and then converts it to a `UIImage` object.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageFromURL(url: NSURL, completionHandler handler: RSNetworking.imageFromURLCompletionClosure)`:
    这个方法从URL中检索一个`UIImage`对象。此函数使用`dataFromURL()`函数来检索一个`NSData`对象，并将其转换为`UIImage`对象。'
- en: 'Now, let''s look at an example on how to use the `RSURLRequest` API. In this
    example, we will make a request to Apple''s iTunes search API, as we did in the
    *Making an HTTP GET request* section of this chapter:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`RSURLRequest` API的示例。在这个例子中，我们将向苹果的iTunes搜索API发起请求，就像我们在本章的*制作HTTP
    GET请求*部分所做的那样：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's walk through this code. We begin by creating an instance of the `RSURLRequest`
    class and an instance of the `NSURL` class. The `NSURL` instance represents the
    URL of the service that we wish to connect to and since we are making a GET request,
    it also contains the parameters that we are sending to the service. If we recall
    from the previous *Making an HTTP GET Request* section, when we make a HTTP GET
    request, the parameters that we are sending to the service are contained within
    the URL itself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码。我们首先创建一个`RSURLRequest`类的实例和一个`NSURL`类的实例。`NSURL`实例代表我们希望连接到的服务的URL，由于我们正在发起GET请求，它还包含我们发送给服务的参数。如果我们回想一下之前的*制作HTTP
    GET请求*部分，当我们发起HTTP GET请求时，我们发送给服务的参数包含在URL本身中。
- en: Apple's iTunes search API returns the results of the search in the JSON format.
    We can see that in the API documentation and also by printing out the results
    of the search to the console; therefore, we will use the `dictionaryFromJsonURL()`
    method of the `RSURLRequest` class to make our request to the service. We could
    also use the `dataFromURL()` or `stringFromURL()` methods to retrieve the data
    if we wanted to, but this method is specifically written to handle JSON data that
    is returned form a REST-based web service.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的 iTunes 搜索 API 以 JSON 格式返回搜索结果。我们可以在 API 文档中看到这一点，也可以通过将搜索结果打印到控制台来验证；因此，我们将使用
    `RSURLRequest` 类的 `dictionaryFromJsonURL()` 方法来向服务发出请求。如果我们想获取数据，我们也可以使用 `dataFromURL()`
    或 `stringFromURL()` 方法，但此方法专门编写来处理从基于 REST 的网络服务返回的 JSON 数据。
- en: The `dictionaryFromJsonURL()` method will take the data that is returned from
    the `NSURLSession` request and convert it to an `NSDictionary` object. We use
    the `NSDictionary` object here rather than Swift's `Dictionary` object because
    the web service could return multiple types (Strings, Arrays, Numbers, and so
    on), and if we recall, a Swift `Dictionary` object can have only a single type
    for the key and a single type for the value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`dictionaryFromJsonURL()` 方法将 `NSURLSession` 请求返回的数据转换为 `NSDictionary` 对象。我们在这里使用
    `NSDictionary` 对象而不是 Swift 的 `Dictionary` 对象，因为网络服务可能返回多种类型（字符串、数组、数字等），并且如果我们回想起来，Swift
    的 `Dictionary` 对象只能有一个键类型和一个值类型。'
- en: When we call the `dictionaryFromJsonURL()` method, we pass the URL that we want
    to connect to and also a completion handler that will be called once the information
    from the service is returned and converted to an `NSDicationary` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `dictionaryFromJsonURL()` 方法时，我们传递我们想要连接的 URL 以及一个完成处理程序，该处理程序将在服务信息返回并转换为
    `NSDicationary` 对象后调用。
- en: 'Now, let''s look at our completion handler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的完成处理程序：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our completion handler is of the `RSURLRequest.dictionaryFromURLCompletionClosure`
    type. This type is defined in the same way as the `RSTransactionRequest.dictionaryFromRSTransactionCompletionClosure
    type`, which allows us to use this same closure for the `RSURLRequests` and `RSTransactionRequest`
    requests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的完成处理程序是 `RSURLRequest.dictionaryFromURLCompletionClosure` 类型。这种类型与 `RSTransactionRequest.dictionaryFromRSTransactionCompletionClosure`
    类型的定义方式相同，这使我们能够为 `RSURLRequests` 和 `RSTransactionRequest` 请求使用相同的闭包。
- en: We begin the completion handler by retrieving the three parameters that were
    passed and assign them to the `response`, `responseDictionary`, and `error` variables.
    We then check the `error` variable to see whether it is `nil`. If it is `nil`,
    we received a valid response and can retrieve values for the `NSDictionary` object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检索传递的三个参数并将它们分配给 `response`、`responseDictionary` 和 `error` 变量来开始完成处理程序。然后我们检查
    `error` 变量以查看它是否为 `nil`。如果是 `nil`，则表示我们收到了有效的响应，可以检索 `NSDictionary` 对象的值。
- en: In this example, we retrieve the `NSArray` value that is associated with the
    `results` key in the `NSDictionary` object that was returned from the service.
    This `NSArray` value will contain a list of items in the iTunes store that are
    associated with our search term. Once we have the `NSArray` value, we print out
    the first element of the array to the console.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从服务返回的 `NSDictionary` 对象中检索与 `results` 键关联的 `NSArray` 值。这个 `NSArray`
    值将包含与我们的搜索词关联的 iTunes 商店中的项目列表。一旦我们有了 `NSArray` 值，我们就将数组的第一个元素打印到控制台。
- en: The `RSURLRequest` API is very good for making single GET requests to a service.
    Now, let's look at the `RSTransaction` and `RSTransactionRequest` APIs, which
    can be used for both POST and GET requests and should be used when we need to
    make multiple requests to the same service.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSURLRequest` API 非常适合向服务发出单个 GET 请求。现在，让我们看看 `RSTransaction` 和 `RSTransactionRequest`
    API，这些 API 可以用于 POST 和 GET 请求，并且在我们需要向同一服务发出多个请求时应使用。'
- en: RSTransaction and RSTransactionRequest
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSTransaction 和 RSTransactionRequest
- en: The `RSTransaction` and `RSTransactionRequest` classes allow us to configure
    a transaction (`RSTransaction`) and then use that transaction to make a request
    (`RSTransactionRequest`) to the service. One of the things that make, this API
    so powerful is how easy it is for us to make subsequent request by simply updating
    the transaction and resubmitting it. Let's look at the API that is exposed by
    these two classes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSTransaction` 和 `RSTransactionRequest` 类允许我们配置一个事务（`RSTransaction`），然后使用该事务向服务发出请求（`RSTransactionRequest`）。使这个
    API 如此强大的一个因素是，我们通过简单地更新事务并重新提交它来执行后续请求是多么容易。让我们看看这两个类公开的 API。'
- en: RSTransaction
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSTransaction
- en: The `RSTransaction` class defines the transaction we wish to make. It exposes
    four properties and one initiator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSTransaction` 类定义了我们希望进行的交易。它公开了四个属性和一个初始化器。'
- en: 'The properties are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 属性如下：
- en: '`TransactionType`: This defines the HTTP request method. Currently, there are
    three types defined—GET, POST, and UNKNOWN. Only the GET and POST actually send
    a request.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransactionType`: 这定义了 HTTP 请求方法。目前定义了三种类型——GET、POST 和 UNKNOWN。只有 GET 和 POST
    实际上发送请求。'
- en: '`baseURL`: This is the base URL to use for the request. This will normally
    look something like [https://itunes.apple.com](https://itunes.apple.com). If we
    are using a nonstandard port, we would follow the server URL by a colon and the
    port number such as `http://mytestserver:8080`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseURL`: 这是用于请求的基本 URL。这通常看起来像 [https://itunes.apple.com](https://itunes.apple.com)。如果我们使用非标准端口，我们会在服务器
    URL 后面跟一个冒号和端口号，例如 `http://mytestserver:8080`。'
- en: '`path`: This is the path that will be added to the base URL. This will be something
    like `search`. It can also include a longer path string such as `path/to/my/service`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 这是将被添加到基本 URL 的路径。这可能是 `search` 这样的内容。它也可以包括一个更长的路径字符串，例如 `path/to/my/service`。'
- en: '`parameters`: This is a `Dictionary` object containing the parameters to send
    to the service.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters`: 这是一个包含要发送到服务的参数的 `Dictionary` 对象。'
- en: 'The initiator is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器如下：
- en: '`init(transactionType: RSTransactionType, baseURL: String, path: String, parameters:
    [String: String])`: This will initialize the `RSTransaction` class with all the
    required properties'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init(transactionType: RSTransactionType, baseURL: String, path: String, parameters:
    [String: String])`: 这将使用所有必需的属性初始化 `RSTransaction` 类。'
- en: RSTransactionRequest
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSTransactionRequest
- en: 'The `RSTransactionRequest` class builds and sends out the request that is defined
    by the four functions, which are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSTransactionRequest` 类构建并发送由以下四个函数定义的请求：'
- en: '`dataFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.dataFromRSTransactionCompletionCompletionClosure)`: This function
    retrieves an `NSData` object from the service defined by the `RSTransaction` class.
    This is the main function and is used by the other three functions to retrieve
    the `NSData` object prior to converting it to the requested format.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.dataFromRSTransactionCompletionCompletionClosure)`: 这个函数从由 `RSTransaction`
    类定义的服务中检索一个 `NSData` 对象。这是主函数，并被其他三个函数用来在将其转换为请求的格式之前检索 `NSData` 对象。'
- en: '`stringFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.stringFromRSTransactionCompletionCompletionClosure)`: This functionfn-=
    retrieves an `NSString` object from the service defined by the `RSTransaction`
    class. This function uses the `dataFromRSTransaction()` function to retrieve the
    `NSData` object and then converts it to an `NSString` object.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.stringFromRSTransactionCompletionCompletionClosure)`: 这个函数从由 `RSTransaction`
    类定义的服务中检索一个 `NSString` 对象。这个函数使用 `dataFromRSTransaction()` 函数来检索 `NSData` 对象，并将其转换为
    `NSString` 对象。'
- en: '`dictionaryFromRSTransaction(transaction: RSTransaction, completionHandler
    handler: RSNetworking.dictionaryFromRSTransactionCompletionCompletionClosure)`:
    This function retrieves an `NSDictionary` object from the service defined by the
    `RSTransaction` class. This function uses the `dataFromRSTransaction()` function
    to retrieve the `NSData` object and then converts it to an `NSDictionary` object.
    The data returned from the URL should be in the JSON format for this function
    to work properly.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dictionaryFromRSTransaction(transaction: RSTransaction, completionHandler
    handler: RSNetworking.dictionaryFromRSTransactionCompletionCompletionClosure)`:
    这个函数从由 `RSTransaction` 类定义的服务中检索一个 `NSDictionary` 对象。这个函数使用 `dataFromRSTransaction()`
    函数来检索 `NSData` 对象，并将其转换为 `NSDictionary` 对象。从 URL 返回的数据应该是 JSON 格式，这样这个函数才能正常工作。'
- en: '`imageFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.imageFromRSTransactionCompletionCompletionClosure)`: This function
    retrieves a `UIImage` object from the service defined by the `RSTransaction` class.
    This function uses the `dataFromRSTransaction()` function to retrieve the `NSData`
    object and then converts it to a `UIImage` object.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageFromRSTransaction(transaction: RSTransaction, completionHandler handler:
    RSNetworking.imageFromRSTransactionCompletionCompletionClosure)`: 这个函数从由 `RSTransaction`
    类定义的服务中检索一个 `UIImage` 对象。这个函数使用 `dataFromRSTransaction()` 函数来检索 `NSData` 对象，并将其转换为
    `UIImage` 对象。'
- en: 'Now, let''s look at an example of how we would use the `RSTransaction` and
    `RSTransactionRequest` classes to make a GET request to Apple''s iTunes search
    API. In this example, we will use the same `resultsHandler` closure that we defined
    in the *RSURLRequest* section of this chapter. Let''s take a look at the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `RSTransaction` 和 `RSTransactionRequest` 类向苹果的 iTunes 搜索 API 发出
    GET 请求的示例。在这个例子中，我们将使用本章 *RSURLRequest* 部分中定义的相同的 `resultsHandler` 闭包。让我们看一下以下代码：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we begin by creating an instance of the `RSTransactionRequest`
    class named `rsRequest`. This `RSTransactionRequest` instance will be used to
    send our request to the service defined in our `RSTransaction` instance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个名为 `rsRequest` 的 `RSTransactionRequest` 类实例。这个 `RSTransactionRequest`
    实例将被用来向我们的 `RSTransaction` 实例中定义的服务发送请求。
- en: 'After we create the `RSTransactionRequest` instance, we use the `RSTransaction`
    initiator to create an instance of the `RSTransction` class named `rsTransGet`.
    In this initiator, we define the following properties as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `RSTransactionRequest` 实例后，我们使用 `RSTransaction` 初始化器创建一个名为 `rsTransGet`
    的 `RSTransction` 类实例。在这个初始化器中，我们按以下方式定义以下属性：
- en: '`transactionType`: The `transactionType` is set to `RSTransactionType`.GET
    (this can also be `RSTransactionType`.POST or `RSTransactionType`. UNKNOWN)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactionType`: `transactionType` 被设置为 `RSTransactionType`.GET (这也可以是 `RSTransactionType`.POST
    或 `RSTransactionType`. UNKNOWN)'
- en: '`baseURL`: The `baseURL` is set to [https://itunes.apple.com](https://itunes.apple.com)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseURL`: `baseURL` 被设置为 [https://itunes.apple.com](https://itunes.apple.com)'
- en: '`path`: The `path` is set to search'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: `path` 被设置为搜索'
- en: '`parameters`: The parameter is set to `["term":"jimmy+buffett","media":"music"]`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters`: 参数被设置为 `["term":"jimmy+buffett","media":"music"]`'
- en: Finally, we use the `dictionaryFromRSTransaction()` method of the `RSTransactionRequest`
    instance. This method accepts two parameters; the first being the `RSTransaction`
    instance that defines the transaction to send and the second being the completion
    handler that will be called once the data is returned from the service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `RSTransactionRequest` 实例的 `dictionaryFromRSTransaction()` 方法。此方法接受两个参数；第一个是定义要发送的事务的
    `RSTransaction` 实例，第二个是数据从服务返回后将被调用的完成处理程序。
- en: As we mentioned earlier, one of the things that makes the `RSTransaction` and
    `RSTransactionRequest` classes so nice to use is how easy it is to make subsequent
    requests to the same service. In our example, after we make the initial request,
    we then change the parameters and make a second request to the same service. One
    thing to watch out for is that since these are asynchronous requests, if we make
    two back-to-back requests like this, we cannot guarantee which request will be
    returned first.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使 `RSTransaction` 和 `RSTransactionRequest` 类易于使用的一个原因是，向同一服务进行后续请求非常简单。在我们的例子中，在发出初始请求后，我们更改参数并向同一服务发出第二个请求。需要注意的一点是，由于这些是异步请求，如果我们连续发出两个这样的请求，我们无法保证哪个请求会先返回。
- en: Now, let's look at the last part of the `RSNetworking2` library—the extensions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `RSNetworking2` 库的最后部分——扩展。
- en: Extensions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展
- en: In Swift, extensions add new functionality to the existing classes. `RSNetworking2`
    has extensions for the `UIImageView` and `UIbutton` classes. These extensions
    allow us to load images from a URL and then add them to `UIImageView` or `UIButton`,
    once the image has finished downloading. We can also put a placeholder image that
    will be displayed in `UIImageView` or `UIButton` until the final image is downloaded.
    Once the image finishes downloading, the placeholder image will be replaced by
    the downloaded image.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，扩展向现有类添加新功能。`RSNetworking2` 为 `UIImageView` 和 `UIbutton` 类提供了扩展。这些扩展允许我们从
    URL 加载图像，然后将其添加到 `UIImageView` 或 `UIButton` 中，一旦图像下载完成。我们还可以放置一个占位符图像，在最终图像下载之前将在
    `UIImageView` 或 `UIButton` 中显示。一旦图像下载完成，占位符图像将被下载的图像替换。
- en: 'Both the `UIImageView` and `UIButton` extensions expose four new methods:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView` 和 `UIButton` 扩展都公开了四个新方法：'
- en: '`setImageForURL(url: NSString, placeHolder: UIImage)`: This method sets the
    image of the `UIImageView` or `UIButton` extensions to the placeholder image and
    then asynchronously downloads the image from the provided URL. Once the image
    downloads, it will replace the placeholder image with the downloaded image.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setImageForURL(url: NSString, placeHolder: UIImage)`: 此方法将 `UIImageView` 或
    `UIButton` 扩展的图像设置为占位符图像，然后从提供的 URL 异步下载图像。一旦图像下载完成，它将用下载的图像替换占位符图像。'
- en: '`setImageForURL(url: NSString)`: This asynchronously downloads the image from
    the URL. Once the image is downloaded, it sets the image of the `UIImageView`
    or `UIButton` extensions to the downloaded image.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setImageForURL(url: NSString)`: 这个方法异步从URL下载图像。一旦图像下载完成，它将`UIImageView`或`UIButton`扩展的图像设置为下载的图像。'
- en: '`setImageForRSTransaction(transaction:RSTransaction, placeHolder: UIImage)`:
    This method sets the image in `UIImageView` or `UIButton` to the placeholder image
    and then asynchronously downloads the image from the provided `RSTransaction`
    object. Once the image downloads, it will replace the placeholder image with the
    downloaded image.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setImageForRSTransaction(transaction:RSTransaction, placeHolder: UIImage)`:
    这个方法将`UIImageView`或`UIButton`中的图像设置为占位符图像，然后从提供的`RSTransaction`对象异步下载图像。一旦图像下载完成，它将用下载的图像替换占位符图像。'
- en: '`setImageForRSTransaction(transaction:RSTransaction)`: This asynchronously
    downloads the image from the provided `RSTransaction` object. Once the image downloads,
    it sets the image of the `UIImageView` or `UIButton` extensions to the downloaded
    image.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setImageForRSTransaction(transaction:RSTransaction)`: 这个方法异步从提供的`RSTransaction`对象下载图像。一旦图像下载完成，它将`UIImageView`或`UIButton`扩展的图像设置为下载的图像。'
- en: 'The `UIButton` and `UIImageView` extensions are used in exactly the same way.
    To see how to use these extensions, let''s take a look at how we would use the
    `UIImageView` extension to view an image that we download from the Internet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIButton`和`UIImageView`扩展的使用方式完全相同。为了了解如何使用这些扩展，让我们看看如何使用`UIImageView`扩展来查看从互联网下载的图像：'
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we start off by defining the URL of our image. We then verify
    that the `imageView` variable contains an instance of a `UIImageView` class. Note
    that we normally would not define the constant type (the `UIImageView` type) in
    an `if-let` statement, but I defined the type in this example to show that the
    `imageView` constant should be an instance of the `UIImageView` class. Next, we
    create an instance of the `UIImage` class with the image named `loading`. This
    image will be used as the placeholder image and will be displayed while we are
    downloading the final image from the URL.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了我们图像的URL。然后我们验证`imageView`变量是否包含`UIImageView`类的实例。请注意，我们通常不会在`if-let`语句中定义常量类型（`UIImageView`类型），但我在这个例子中定义了类型，以展示`imageView`常量应该是`UIImageView`类的实例。接下来，我们创建了一个名为`loading`的`UIImage`类的实例。这个图像将被用作占位符图像，在我们从URL下载最终图像的过程中显示。
- en: Now that we have the URL of the image and the placeholder image, we use the
    `setImageForURL()` extension method. This method accepts two parameters—the URL
    to download the image from and the placeholder image. Once we call this method,
    `RSNetworking2` will set the image of the `UIImageView` class to the placeholder
    image that is provided and then download the image from the URL provided. Once
    the image finishes downloading, `RSNetworking2` will replace the placeholder image
    with the downloaded image.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了图像的URL和占位符图像，我们使用`setImageForURL()`扩展方法。这个方法接受两个参数——下载图像的URL和占位符图像。一旦我们调用这个方法，`RSNetworking2`将`UIImageView`类的图像设置为提供的占位符图像，并从提供的URL下载图像。一旦图像下载完成，`RSNetworking2`将用下载的图像替换占位符图像。
- en: We looked at a few brief examples of `RSNetworking2` in this chapter. There
    are additional examples on the `RSNetworking2` GitHub site at [https://github.com/hoffmanjon/RSNetworking2](https://github.com/hoffmanjon/RSNetworking2).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了`RSNetworking2`的一些示例。更多示例可以在`RSNetworking2`的GitHub网站上找到：[https://github.com/hoffmanjon/RSNetworking2](https://github.com/hoffmanjon/RSNetworking2)。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In today's world, it is essential that a developer have a good working knowledge
    of network development. In this chapter, we saw how to use Apple's `NSURLSession`
    API, with other classes, to connect to HTTP REST-based web services. The `NSURLSession`
    API was written as a replacement for the older `NSURLConnection` API and is now
    the recommended API to use when making network requests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，一个开发者必须具备良好的网络开发知识。在本章中，我们看到了如何使用Apple的`NSURLSession` API，结合其他类，连接到基于HTTP
    REST的Web服务。`NSURLSession` API被编写为旧版`NSURLConnection` API的替代品，并且现在是进行网络请求时推荐使用的API。
- en: We also saw how to use Apple's system configuration API to figure out what type
    of network connection we have. If we are developing applications for a mobile
    device (iPhone, iPod, or iPad), it is essential to know whether we have a network
    connection and what type of connection it is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用苹果的系统配置API来确定我们有什么类型的网络连接。如果我们正在为移动设备（iPhone、iPod或iPad）开发应用程序，了解我们是否有网络连接以及连接类型是至关重要的。
- en: We ended the chapter discussing `RSNetworking2`, which is an open source network
    library, written entirely in Swift, that I maintain. `RSNetworking2` allows us
    to very quickly and easily add network functionality to our applications. It also
    adds an extension to both the `UIImageView` and `UIButton` classes to dynamically
    load images from the Internet and display them after the download is complete.
    I would encourage anyone who wishes to participate in the development of RSNetworking.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论了`RSNetworking2`，这是一个开源网络库，完全用Swift编写，由我维护。`RSNetworking2`使我们能够非常快速和容易地将网络功能添加到我们的应用程序中。它还向`UIImageView`和`UIButton`类添加了一个扩展，用于从互联网动态加载图像，并在下载完成后显示它们。我鼓励任何希望参与RSNetworking开发的人。
