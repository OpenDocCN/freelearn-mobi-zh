["```swift\n@class MAPlayfieldLayer;\n\ntypedef enum {\n    kGemAnyType = 0,\n    kGem1,\n    kGem2,\n    kGem3,\n    kGem4,\n    kGem5,\n    kGem6,\n    kGem7\n} GemType;\n\ntypedef enum {\n    kGemIdle = 100,\n    kGemMoving,\n    kGemScoring,\n    kGemNew\n} GemState;\n\n@interface MAGem : CCSprite {\n    NSInteger _rowNum; // Row number for this gem\n    NSInteger _colNum; // Column number for this gem\n    GemType _gemType; // The enum value of the gem\n    GemState _gemState; // The current state of the gem\n    MAPlayfieldLayer *gameLayer; // The game layer\n}\n\n@property (nonatomic, assign) NSInteger rowNum;\n@property (nonatomic, assign) NSInteger colNum;\n@property (nonatomic, assign) GemType gemType;\n@property (nonatomic, assign) GemState gemState;\n@property (nonatomic, assign) MAPlayfieldLayer *gameLayer;\n\n-(BOOL) isGemSameAs:(MAGem*)otherGem;\n-(BOOL) isGemInSameRow:(MAGem*)otherGem;\n-(BOOL) isGemInSameColumn:(MAGem*)otherGem;\n-(BOOL) isGemBeside:(MAGem*)otherGem;\n\n-(void) highlightGem;\n-(void) stopHighlightGem;\n\n- (BOOL) containsTouchLocation:(CGPoint)pos;\n@end\n```", "```swift\n@implementation MAGem\n\n@synthesize rowNum = _rowNum;\n@synthesize colNum = _colNum;\n@synthesize gemType = _gemType;\n@synthesize gemState = _gemState;\n\n@synthesize gameLayer;\n\n-(BOOL) isGemSameAs:(MAGem*)otherGem {\n    // Is the gem the same type as the other Gem?\n    return (self.gemType == otherGem.gemType);\n}\n\n-(BOOL) isGemInSameRow:(MAGem*)otherGem {\n    // Is the gem in the same row as the other Gem?\n    return (self.rowNum == otherGem.rowNum);\n}\n\n-(BOOL) isGemInSameColumn:(MAGem*)otherGem {\n    // Is the gem in the same column as the other gem?\n    return (self.colNum == otherGem.colNum);\n}\n```", "```swift\n-(BOOL) isGemBeside:(MAGem*)otherGem {\n    // If the row is the same, and the other gem is \n    // +/- 1 column, they are neighbors\n    if ([self isGemInSameRow:otherGem] && \n        ((self.colNum == otherGem.colNum - 1) || \n        (self.colNum == otherGem.colNum + 1))\n        ) {\n        return YES;\n    }\n    // If the column is the same, and the other gem is \n    // +/- 1 row, they are neighbors\n    else if ([self isGemInSameColumn:otherGem] && \n                 ((self.rowNum == otherGem.rowNum - 1) || \n                  (self.rowNum == otherGem.rowNum + 1))\n                 ) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n```", "```swift\n-(void) highlightGem {\n    // Build a simple repeating \"wobbly\" animation\n    CCMoveBy *moveUp = [CCMoveBy actionWithDuration:0.1\n                        position:ccp(0,3)];\n    CCMoveBy *moveDown = [CCMoveBy actionWithDuration:0.1\n                        position:ccp(0,-3)];\n    CCSequence *moveAround = [CCSequence actions:moveUp,\n                        moveDown, nil];\n    CCRepeatForever *gemHop = [CCRepeatForever\n                        actionWithAction:moveAround];\n\n    [self runAction:gemHop];\n}\n\n-(void) stopHighlightGem {\n    // Stop all actions (the wobbly) on the gem\n    [self stopAllActions];\n\n    // We call to the gameLayer itself to make sure we \n    // haven't left the gem a little off-base\n    // (from the highlightGem movements)\n    [gameLayer performSelector:@selector(resetGemPosition:)\n                    withObject:self];\n}\n```", "```swift\n-(MAGem*) generateGemForRow:(NSInteger)rowNum\n    andColumn:(NSInteger)colNum ofType:(GemType)newType {\n    GemType gemNum;\n\n    if (newType == kGemAnyType) {\n        // If we passed a kGemAnyType, randomize the gem\n        gemNum = (arc4random() % totalGemsAvailable) + 1;\n    } else {\n        // If we passed another value, use that gem type\n        gemNum = newType;\n    }\n\n    // Generate the sprite name\n    NSString *spritename = [NSString stringWithFormat:\n                            @\"gem%i.png\", gemNum];\n\n    // Build the MAGem, which is just an enhanced CCSprite\n    MAGem *thisGem = [MAGem\n                    spriteWithSpriteFrameName:spritename];\n\n    // Set the gem's vars\n    [thisGem setRowNum:rowNum];\n    [thisGem setColNum:colNum];\n    [thisGem setGemType:(GemType)gemNum];\n    [thisGem setGemState:kGemNew];\n    [thisGem setGameLayer:self];\n\n    // Set the position for this gem\n    [thisGem setPosition:[self positionForRow:rowNum\n                                    andColumn:colNum]];\n\n    // Add the gem to the array\n    [gemsInPlay addObject:thisGem];\n\n    // We return the newly created gem, which is already\n    // added to the gemsInPlay array\n    // It has NOT been added to the layer yet.\n    return thisGem;\n}\n\n-(void) addGemForRow:(NSInteger)rowNum\n           andColumn:(NSInteger)colNum\n              ofType:(GemType)newType {\n\n    // Add a replacement gem\n    MAGem *thisGem = [self generateGemForRow:rowNum\n                    andColumn:colNum ofType:newType];\n\n    // We reset the gem above the screen\n    [thisGem setPosition:ccpAdd(thisGem.position,\n                                ccp(0,size.height))];\n\n    // Add the gem to the scene\n    [self addChild:thisGem];\n\n    // Drop it to the correct position\n    [self moveToNewSlotForGem:thisGem];\n}\n```", "```swift\n-(void) dealloc {\n    [self setGameLayer:nil];\n\n    [super dealloc];\n}\n```", "```swift\n-(void) generatePlayfield {\n    // Randomly select gems and place on the board\n    // Iterate through all rows and columns\n    for (int row = 1; row <= boardRows; row++) {\n        for (int col = 1; col <= boardColumns; col++) {\n            // Generate a gem for this slot\n            [self generateGemForRow:row andColumn:col\n                             ofType:kGemAnyType];\n        }\n    }\n\n    // We check for matches now, and remove any gems \n    // from starting in the scoring position\n    [self fixStartingMatches];\n\n    // Add the gems to the layer\n    for (MAGem *aGem in gemsInPlay) {\n        [aGem setGemState:kGemIdle];\n        [matchsheet addChild:aGem];\n    }\n}\n```", "```swift\n-(void) fixStartingMatches {\n    // This method checks for any possible matches\n    // and will remove those gems. After fixing the gems,\n    // we call this method again (from itself) until we\n    // have a clean result\n    [self checkForMatchesOfType:kGemNew];\n    if ([gemMatches count] > 0) {\n\n        // get the first matching gem\n        MAGem *aGem = [gemMatches objectAtIndex:0];\n\n        // Build a replacement gem\n        [self generateGemForRow:[aGem rowNum] andColumn:\n                    [aGem colNum] ofType:kGemAnyType];\n\n        // Destroy the original gem\n        [gemsInPlay removeObject:aGem];\n        [gemMatches removeObject:aGem];\n\n        // We recurse so we can see if the board is clean\n        // When we have no gemMatches, we stop recursion\n        [self fixStartingMatches];\n    }\n}\n```", "```swift\n-(void) checkForMatchesOfType:(GemType)desiredGemState {\n  // Let's look for horizontal matches    \n  for (MAGem *aGem in gemsInPlay) {\n    // Let's grab the first gem\n    if (aGem.gemState == desiredGemState) {\n      // If it is the desired state, let's look\n      // for a matching neighbor gem\n      for (MAGem *bGem in gemsInPlay) {\n        // If the gem is the same type and state,\n        // in the same row, and to the right\n        if ([aGem isGemSameAs:bGem] &&\n          [aGem isGemInSameRow:bGem] &&\n            aGem.colNum == bGem.colNum - 1 &&\n            bGem.gemState == desiredGemState) {\n            // Now we loop through again,\n            // looking for a 3rd in a row\n            for (MAGem *cGem in gemsInPlay) {\n              // If this is the 3rd gem in a row\n              // in the desired state\n              if (aGem.colNum == cGem.colNum - 2 &&\n                  cGem.gemState == desiredGemState) {\n                   // Is the gem the same type\n                   // and in the same row?\n                   if ([aGem isGemSameAs:cGem] &&\n                 [aGem isGemInSameRow:cGem]) {\n                         // Add gems to match array\n                  [self addGemToMatch:aGem];\n                   [self addGemToMatch:bGem];\n                  [self addGemToMatch:cGem];\n                          break;\n                   }\n              }\n           }  \n        } \n     }\n  }\n```", "```swift\n-(void) addGemToMatch:(MAGem*)thisGem {\n    // Only adds it to the array if it isn't already there\n    if ([gemMatches indexOfObject:thisGem] == NSNotFound) {\n        [gemMatches addObject:thisGem];\n    }\n}\n```", "```swift\n // Let's look for vertical matches\n  for (MAGem *aGem in gemsInPlay) {\n    // Let's grab the first gem\n    if (aGem.gemState == desiredGemState) {\n       // If it is the desired state, let's look for a\n      // matching neighbor gem\n      for (MAGem *bGem in gemsInPlay) {\n        // If the gem is the same type and state,\n      // in the same column, and above\n        if ([aGem isGemSameAs:bGem] &&\n          [aGem isGemInSameColumn:bGem] &&\n            aGem.rowNum == bGem.rowNum - 1 &&\n            bGem.gemState == desiredGemState) {\n              // Now we looking for a 3rd in the column\n              for (MAGem *cGem in gemsInPlay) {\n                 // If this is the 3rd gem in a row\n                 if (bGem.rowNum == cGem.rowNum - 1 &&\n                     cGem.gemState == desiredGemState) {\n                       // Is the gem the same type and\n                 // in the same column?\n                      if ([bGem isGemSameAs:cGem] &&\n                          [bGem isGemInSameColumn:cGem]) {\n                            // Add gems to match array\n                            [self addGemToMatch:aGem];\n                     [self addGemToMatch:bGem];\n                      [self addGemToMatch:cGem];\n                            break;\n\n                      } \n                   }\n                }\n             }\n          } \n       }\n    }\n  }\n}\n```", "```swift\n-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {\n\n    CGPoint location = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:location];\n\n    // If we reached game over, any touch returns to menu\n    if (isGameOver) {\n        [[CCDirector sharedDirector]\n                replaceScene:[MAMenuScene scene]];\n        return YES;\n    }\n\n    // If the back button was pressed, we exit\n    if (CGRectContainsPoint([backButton boundingBox],\n                            convLoc)) {\n        [[CCDirector sharedDirector]\n         replaceScene:[MAMenuScene node]];\n        return YES;\n    }\n\n    // If we have only 0 or 1 gem in gemsTouched, track\n    if ([gemsTouched count] < 2) {\n        // Check each gem\n        for (MAGem *aGem in gemsInPlay) {\n            // If the gem was touched AND the gem is idle,\n            // return YES to track the touch\n            if ([aGem containsTouchLocation:convLoc] &&\n                            aGem.gemState == kGemIdle) {\n                return YES;\n            }\n        }\n    }\n\n    // If we failed to find any good touch, return\n    return NO;\n}\n```", "```swift\n-(void) ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event {\n    // Swipes are handled here.\n    [self touchHelper:touch withEvent:event];\n}\n```", "```swift\n-(void) touchHelper:(UITouch *)touch withEvent:(UIEvent *)event {\n    // If we're already checking for a match, ignore\n    if ([gemsTouched count] >= 2 || gemsMoving == YES) {\n        return;\n    }\n\n    CGPoint location = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:location];\n\n    // Let's figure out which gem was touched (if any)\n    for (MAGem *aGem in gemsInPlay) {\n        if ([aGem containsTouchLocation:convLoc] &&\n            aGem.gemState == kGemIdle) {\n            // We can't add the same gem twice\n            if ([gemsTouched containsObject:aGem] == NO) {\n                // Add the gem to the array\n                [self playDing];\n                [gemsTouched addObject:aGem];\n                [aGem highlightGem];\n            }\n        }\n    }\n\n    // We now have touched 2 gems.  Let's swap them.\n    if ([gemsTouched count] >= 2) {\n        MAGem *aGem = [gemsTouched objectAtIndex:0];\n        MAGem *bGem = [gemsTouched objectAtIndex:1];\n\n        // If the gems are adjacent, we can swap\n        if ([aGem isGemBeside:bGem]) {\n            [self swapGem:aGem withGem:bGem];\n        } else {\n            // They're not adjacent, so let's drop\n            // the first gem\n            [aGem stopHighlightGem];\n            [gemsTouched removeObject:aGem];\n        }\n    }\n}\n```", "```swift\n-(void) ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {\n    // Taps are handled here.    \n    [self touchHelper:touch withEvent:event];\n}\n```", "```swift\n-(void)swapGem:(MAGem*)aGem withGem:(MAGem*)bGem {\n    NSInteger tempRowNumA;\n    NSInteger tempColNumA;\n\n    // Stop the highlight\n    [aGem stopHighlightGem];\n    [bGem stopHighlightGem];\n\n    // Grab the temp location of aGem\n    tempRowNumA = [aGem rowNum];\n    tempColNumA = [aGem colNum];\n\n    // Set the aGem to the values from bGem\n    [aGem setRowNum:[bGem rowNum]];\n    [aGem setColNum:[bGem colNum]];\n\n    // Set the bGem to the values from the aGem temp vars\n    [bGem setRowNum:tempRowNumA];\n    [bGem setColNum:tempColNumA];\n    // Move the gems\n    [self moveToNewSlotForGem:aGem];\n    [self moveToNewSlotForGem:bGem];\n}\n```", "```swift\n-(void) moveToNewSlotForGem:(MAGem*)aGem {\n    // Set the gem's state to moving\n    [aGem setGemState:kGemMoving];\n\n    // Move the gem, play sound, let it rest\n    CCMoveTo *moveIt = [CCMoveTo\n            actionWithDuration:0.2\n            position:[self positionForRow:[aGem rowNum]\n                                andColumn:[aGem colNum]]];\n    CCCallFunc *playSound = [CCCallFunc\n            actionWithTarget:self\n                    selector:@selector(playSwoosh)];\n    CCCallFuncND *gemAtRest = [CCCallFuncND\n            actionWithTarget:self\n            selector:@selector(gemIsAtRest:) data:aGem];\n    [aGem runAction:[CCSequence actions:moveIt,\n                     playSound, gemAtRest, nil]];\n}\n```", "```swift\n-(void) gemIsAtRest:(MAGem*)aGem {\n    // Reset the gem's state to Idle\n    [aGem setGemState:kGemIdle];\n\n    // Identify that we need to check for matches\n    checkMatches = YES;\n}\n```", "```swift\n-(void) checkMove {\n    // A move was made, so check for potential matches\n    [self checkForMatchesOfType:kGemIdle];\n\n    // Did we have any matches?\n    if ([gemMatches count] > 0) {\n        // Iterate through all matched gems\n        for (MAGem *aGem in gemMatches) {\n            // If the gem is not already in scoring state\n            if (aGem.gemState != kGemScoring) {\n                // Trigger the scoring & removal of gem\n                [self animateGemRemoval:aGem]; \n            }\n        }\n        // All matches processed.  Clear the array.\n        [gemMatches removeAllObjects];\n    // If we have any selected/touched gems, we must\n    // have made an incorrect move\n    } else if ([gemsTouched count] > 0) {\n        // If there was only one gem, grab it\n        MAGem *aGem = [gemsTouched objectAtIndex:0];\n\n        // If we had 2 gems in the touched array\n        if ([gemsTouched count] == 2) {\n            // Grab the second gem\n            MAGem *bGem = [gemsTouched objectAtIndex:1];\n            // Swap them back to their original slots\n            [self swapGem:aGem withGem:bGem];\n        } else {\n            // If we only had 1 gem, stop highlighting it\n            [aGem stopHighlightGem];\n        }\n    }\n    // Touches were processed.  Clear the touched array.\n    [gemsTouched removeAllObjects];\n}\n```", "```swift\n-(void) animateGemRemoval:(MAGem*)aGem {\n    // We swap the image to \"boom\", and animate it out\n    CCCallFuncND *changeImage = [CCCallFuncND\n            actionWithTarget:self\n            selector:@selector(changeGemFace:) data:aGem];\n    CCCallFunc *updateScore = [CCCallFunc\n            actionWithTarget:self\n            selector:@selector(incrementScore)];\n    CCCallFunc *addTime = [CCCallFunc\n            actionWithTarget:self\n            selector:@selector(addTimeToTimer)];\n    CCMoveBy *moveUp = [CCMoveBy actionWithDuration:0.3\n            position:ccp(0,5)];\n    CCFadeOut *fade = [CCFadeOut actionWithDuration:0.2];\n    CCCallFuncND *removeGem = [CCCallFuncND\n            actionWithTarget:self\n            selector:@selector(removeGem:) data:aGem];\n\n    [aGem runAction:[CCSequence actions:changeImage,\n            updateScore, addTime, moveUp, fade,\n            removeGem, nil]];\n}\n```", "```swift\n-(void) changeGemFace:(MAGem*)aGem {\n    // Swap the gem texture to the \"boom\" image\n    [aGem setDisplayFrame:[[CCSpriteFrameCache\n                        sharedSpriteFrameCache]\n                        spriteFrameByName:@\"boom.png\"]];\n}\n```", "```swift\n-(void) removeGem:(MAGem*)aGem {\n    // Clean up after ourselves and get rid of this gem\n    [gemsInPlay removeObject:aGem];\n    [aGem setGemState:kGemScoring];\n    [self fillHolesFromGem:aGem];\n    [aGem removeFromParentAndCleanup:YES];\n    checkMatches = YES;\n} \n```", "```swift\n-(void) fillHolesFromGem:(MAGem*)aGem {\n    // aGem passed is one that is being scored.\n    // We know we will need to fill in the holes, so \n    // this method takes care of that.\n\n    for (MAGem *thisGem in gemsInPlay) {\n        // If thisGem is in the same column and ABOVE\n        // the current matching gem, we reset the\n        // position down, so we can fill the hole\n        if (aGem.colNum == thisGem.colNum && \n            aGem.rowNum < thisGem.rowNum) {\n            // Set thisGem to drop down one row\n            [thisGem setRowNum:thisGem.rowNum - 1];            \n            [self moveToNewSlotForGem:thisGem];\n        }\n    }\n\n    // Call the smart fill method.\n    [self smartFill];\n}\n```", "```swift\n-(void) update:(ccTime)dt {\n\n    gemsMoving = NO;\n\n    // See if we have any gems currently moving\n    for (MAGem *aGem in gemsInPlay) {\n        if (aGem.gemState == kGemMoving) {\n            gemsMoving = YES;\n            break;\n        }\n    }\n\n    // If we flagged that we need to check the board\n    if (checkMatches) {\n        [self checkMove];\n        [self checkMovesRemaining];\n        checkMatches = NO;\n    }\n\n    // Too few gems left.  Let's fill it up.\n    // This will avoid any holes if our smartFill left\n    // gaps, which is common on 4 and 5 gem matches.\n    if ([gemsInPlay count] < boardRows * boardColumns &&\n        gemsMoving == NO) {\n        [self addGemsToFillBoard];\n    }\n\n    // Update the timer value & display\n\n    // Game Over / Time's Up\n\n    }\n} \n```", "```swift\n-(void) addGemsToFillBoard {\n    // Loop through all positions, see if we have a gem\n    for (int i = 1; i <= boardRows; i++) {\n        for (int j = 1; j <= boardColumns; j++) {\n\n            BOOL missing = YES;\n\n            // Look for a missing gem in each slot\n            for (MAGem *aGem in gemsInPlay) {\n                if (aGem.rowNum == i && aGem.colNum == j\n                    && aGem.gemState != kGemScoring) {\n                    // Found a gem, not missing\n                    missing = NO;\n                }\n            }\n            // We didn't find anything in this slot.\n            if (missing) {\n                [self addGemForRow:i andColumn:j\n                            ofType:kGemAnyType];\n            }\n        }\n    }\n    // We possibly changed the board, trigger match check\n    checkMatches = YES;\n}\n```", "```swift\n-(void) checkMovesRemaining {\n\n    NSInteger matchesFound = 0;\n    NSInteger gemsInAction = 0;\n\n    // Create a temporary C-style array\n    NSInteger map[12][12];\n\n    // Make sure it is cleared\n    for (int i = 1; i< 12; i++) {\n        for (int j = 1; j < 12; j++) {\n            map[i][j] = 0;\n        }\n    }\n\n    // Load all gem types into it\n    for (MAGem *aGem in gemsInPlay) {\n        if (aGem.gemState != kGemIdle) {\n            // If gem is moving or scoring, fill with zero\n            map[aGem.rowNum][aGem.colNum] = 0;\n            gemsInAction++;\n        } else {            \n            map[aGem.rowNum][aGem.colNum] = aGem.gemType;\n        }\n    }\n\n    // Loop through all slots on the board\n    for (int row = 1; row <= boardRows; row++) {\n        for (int col = 1; col <= boardColumns; col++) {\n\n            // Grid variables look like:\n            //\n            //        j\n            //        h i\n            //    k l e f g \n            //    m n a b c d\n            //        o p\n            //        q r\n\n            // where \"a\" is the root gem we're testing\n            // The swaps we test are a/b and a/e\n            // So we need to identify all possible matches\n            // that those swaps could cause\n            GemType a = map[row][col];\n            GemType b = map[row][col+1];\n            GemType c = map[row][col+2];\n            GemType d = map[row][col+3];\n            GemType e = map[row+1][col];\n            GemType f = map[row+1][col+1];\n            GemType g = map[row+1][col+2];\n            GemType h = map[row+2][col];\n            GemType i = map[row+2][col+1];\n            GemType j = map[row+3][col];\n            GemType k = map[row+1][col-2];\n            GemType l = map[row+1][col-1];\n            GemType m = map[row][col-2];\n            GemType n = map[row][col-1];\n            GemType o = map[row-1][col];\n            GemType p = map[row-1][col+1];\n            GemType q = map[row-2][col];\n            GemType r = map[row-2][col+1];\n\n            // deform the board-swap of a and b, test\n            GemType newA = b;\n            GemType newB = a;\n\n            matchesFound = matchesFound +\n                [self findMatcheswithA:h andB:e\n                            andC:newA andD:o andE:q];\n            matchesFound = matchesFound + \n                [self findMatcheswithA:i andB:f\n                            andC:newB andD:p andE:r];\n            matchesFound = matchesFound +\n                [self findMatcheswithA:m andB:n\n                            andC:newA andD:0 andE:0];\n            matchesFound = matchesFound +\n                [self findMatcheswithA:newB andB:c\n                            andC:d andD:0 andE:0];\n\n            // Now we swap a and e, then test\n            newA = e;\n            GemType newE = a;\n            matchesFound = matchesFound +\n                [self findMatcheswithA:m andB:n\n                            andC:newA andD:b andE:c];\n            matchesFound = matchesFound +\n                [self findMatcheswithA:k andB:l\n                            andC:newE andD:f andE:g];\n            matchesFound = matchesFound +\n                [self findMatcheswithA:newA andB:o\n                            andC:q andD:0 andE:0];\n            matchesFound = matchesFound +\n                [self findMatcheswithA:newE andB:h\n                            andC:j andD:0 andE:0];\n        }\n    }\n\n    // See if we have gems in motion on the board\n    // Set the BOOL so other methods don't try to fix \n    // any \"problems\" with a moving board\n    gemsMoving = (gemsInAction > 0);\n\n    movesRemaining = matchesFound;\n}\n```", "```swift\n-(NSInteger) findMatcheswithA:(NSInteger)a\n                         andB:(NSInteger)b\n                         andC:(NSInteger)c\n                         andD:(NSInteger)d\n                         andE:(NSInteger)e {\n    NSInteger matches = 0;\n\n    if (a == b && b == c && c == d && d == e &&\n                            a + b + c + d + e != 0) {\n        // 5 match\n        matches++;        \n    } else if (a == b && b == c && c == d  &&\n                            a + b + c + d != 0) {\n        // 4 match (left)\n        matches++;\n    } else if (b == c && c == d && d == e &&\n                            b + c + d + e != 0) {\n        // 4 match (right)\n        matches++;\n    } else if (a == b && b == c && a + b + c != 0) {\n        // 3 match (left)\n        matches++;\n    } else if (b == c && c == d && b + c + d != 0) {\n        // 3 match (mid)\n        matches++;\n    } else if (c == d && d == e && c + d + e != 0) {\n        // 3 match (right)\n        matches++;\n    }\n    return matches;\n}\n```", "```swift\n -(void) smartFill {\n    // In case we were scheduled, unschedule it first\n    [self unschedule:@selector(smartFill)];\n\n    // If anything is moving, we don't want to fill yet\n    if (gemsMoving) {\n        // We reschedule so we retry when gems not moving\n        [self schedule:@selector(smartFill) interval:0.05];\n        return;\n    }\n\n    // If we have plenty of matches, use a random fill\n    if (movesRemaining >= 6) {\n        [self addGemsToFillBoard];\n        return;\n    }\n\n    // Create a temporary C-style array\n    // We make it bigger than the playfield on purpose\n    // This way we can evaluate past the edges\n    NSInteger map[12][12];\n\n    // Make sure it is cleared\n    for (int i = 1; i< boardRows + 5; i++) {\n        for (int j = 1; j < boardColumns + 5; j++) {\n            if (i > boardRows || j > boardColumns) {\n                // If row or column is bigger than board,\n                // assign a -1 value\n                map[i][j] = -1;\n            } else {\n                // If it is on the board, zero it\n                map[i][j] = 0;\n            }\n        }\n    }\n\n    // Load all gem types into it\n    for (MAGem *aGem in gemsInPlay) {\n        // We don't want to include scoring gems\n        if (aGem.gemState == kGemScoring) {\n            map[aGem.rowNum][aGem.colNum] = 0;\n        } else {\n            // Assign the gemType to the array slot\n            map[aGem.rowNum][aGem.colNum] = aGem.gemType;\n        }\n    }\n\n    // Parse through the map, looking for zeroes\n    for (int row = 1; row <= boardRows; row++) {\n        for (int col = 1; col <= boardColumns; col++) {\n\n            // We use \"intelligent randomness\" to fill \n            // holes when close to running out of matches\n\n            // Grid variables look like:\n            //        \n            //        h\n            //        e   g \n            //      n a b c \n            //      s o p t\n            //    \n\n            // where \"a\" is the root gem we're testing\n\n            GemType a = map[row][col];\n            GemType b = map[row][col+1];\n            GemType c = map[row][col+2];\n            GemType e = map[row+1][col];\n            GemType g = map[row+1][col+2];\n            GemType h = map[row+2][col];\n            GemType n = map[row][col-1];\n            GemType o = map[row-1][col];\n            GemType p = map[row-1][col+1];\n            GemType s = map[row-1][col-1];\n            GemType t = map[row-1][col+2];\n\n            // Vertical hole, 3 high\n            if (a == 0 && e == 0 && h == 0) {\n                if ((int)p >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:p];\n                    [self addGemForRow:row+1 andColumn:col\n                                ofType:p];\n                    [self addGemForRow:row+2 andColumn:col\n                                ofType:kGemAnyType];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n\n                if ((int)s >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:s];\n                    [self addGemForRow:row+1 andColumn:col\n                                ofType:s];\n                    [self addGemForRow:row+2 andColumn:col\n                                ofType:kGemAnyType];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n\n                if ((int)n >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:kGemAnyType];\n                    [self addGemForRow:row+1 andColumn:col\n                                ofType:n];\n                    [self addGemForRow:row+2 andColumn:col\n                                ofType:n];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n\n                if ((int)b >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:kGemAnyType];\n                    [self addGemForRow:row+1 andColumn:col\n                                ofType:b];\n                    [self addGemForRow:row+2 andColumn:col\n                                ofType:b];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n            }\n\n            // Horizontal hole, 3 high\n            if (a == 0 && b == 0 && c == 0) {\n                if ((int)o >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:kGemAnyType];\n                    [self addGemForRow:row andColumn:col+1\n                                ofType:o];\n                    [self addGemForRow:row andColumn:col+2\n                                ofType:o];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n\n                if ((int)t >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:t];\n                    [self addGemForRow:row andColumn:col+1\n                                ofType:t];\n                    [self addGemForRow:row andColumn:col+2\n                                ofType:kGemAnyType];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n\n                if ((int)e >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:kGemAnyType];\n                    [self addGemForRow:row andColumn:col+1\n                                ofType:e];\n                    [self addGemForRow:row andColumn:col+2\n                                ofType:e];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n                if ((int)g >= 1) {\n                    [self addGemForRow:row andColumn:col\n                                ofType:g];\n                    [self addGemForRow:row andColumn:col+1\n                                ofType:g];\n                    [self addGemForRow:row andColumn:col+2\n                                ofType:kGemAnyType];\n                    [self checkMovesRemaining];\n                    [self smartFill];\n                    return;\n                }\n            }\n        }\n    }\n}\n```"]