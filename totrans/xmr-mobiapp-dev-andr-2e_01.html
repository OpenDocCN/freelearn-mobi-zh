<html><head></head><body><h1 id="e-Xj2y">Chapter 1. The Anatomy of an Android App</h1>
<p id="e-WKhE">We live in an age where technologies are being developed and have become more and more accessible than ever before. The rise of the mobile computing platform has taken the technology evolution to a new high. The phones and tablets are getting smarter day by day and becoming the alternatives to a traditional PC. In this fiercely competitive world of mobile computing, every traditional PC manufacturers to small start-ups are in the race brining the devices of various form factors.</p>
<p id="e-DmvU">In this book, we will show you how to take advantage of your existing C# skills to write applications that run on Android powered devices. While most of this book will be focused on learning how to develop Android apps using C# and Xamarin.Android, we will start with a more general discussion of Android. What is Android? How does Android facilitate the task of creating great mobile apps? This chapter will help you answer these questions by providing a base-level understanding of the following topics:</p>
<ul id="e-fipg">
<li id="e-bHz6">An overview of the Android platform</li>
<li id="e-BbGY">Android platform versions and feature releases</li>
<li id="e-pMem">Android applications (building blocks)</li>
</ul>
<h1 id="e-LnOL">The Android platform</h1>
<p id="e-aWtc">The Android platform has been one of the most powerful, evolving, and advanced mobile operating systems developed in recent years, which provides various services and features, that helps developers to build rich mobile applications. Android is an open source operating system currently developed and maintained by Google. Due to its open source nature, it has a larger community base of developers and device manufacturers.</p>
<p id="e-n3gE">The Android operating system was primarily designed for low powered computing phones, but later, its base was widen to various form factors, including smartphones, tablets, Android TV, and Wearables.</p>
<h2 id="e-Dhgf">Versions of Android</h2>
<p id="e-AhQa">The Android operating system has evolved with a series of frequent updates since its initial beta release in November 2007. Identifying the version of the Android platform can be somewhat confusing; there is a version number, API level, and nickname, and these are sometimes used interchangeably.</p>
<p id="e-ihHD">The version number represents a release of the platform. Sometimes, a new release is created to deliver new capabilities, while sometimes it is created to fix bugs.</p>
<p id="e-YFXa">The API level is an integer value that represents a set of capabilities. As the API level increases, new capabilities are delivered to the developer.</p>
<p id="e-g9sB">The following table lists all the major Android platform releases in the reverse chronological order:</p>
<p id="e-xgL3">Platform version</p>
<p id="e-glOV">API level</p>
<p id="e-iPWS">Release date</p>
<p id="e-dSgf">Feature updates</p>
<p id="e-yaqC">5.1 (Lollipop)</p>
<p id="e-XZKi">22</p>
<p id="e-C3r0">03/09/2015</p>
<ul id="e-WsBb">
<li id="e-dZlJ">Stability and performance improvements over Lollipop.</li>
<li id="e-GBgo">Adds multiple SIM card support.</li>
</ul>
<p id="e-c1G9">5.0 (Lollipop)</p>
<p id="e-SOby">21</p>
<p id="e-PyZc">11/12/2014</p>
<ul id="e-EDsK">
<li id="e-rskR">Introduced new runtime ART that replaced Dalvik.</li>
<li id="e-KWlz">A complete UI overhaul with an introduction to material design.</li>
<li id="e-gwQ3">Improved lock screen notification.</li>
<li id="e-Yjz1">Updated the media API for better camera capture and media playback.</li>
<li id="e-fXOD">Added the project Volta to increase the battery life.</li>
</ul>
<p id="e-Qyem">4.4W, 4.4W.1, 4.4W.2 (KitKat Wearables)</p>
<p id="e-KyHN">20</p>
<p id="e-etOj">06/25/2014</p>
<ul id="e-OSRx">
<li id="e-EI0b">Initial release for the Android Wear platform's smart watches.</li>
<li id="e-KBbg">Fork of same Android 4.4 KitKat code branch with added wearable extensions.</li>
</ul>
<p id="e-qkc9">4.4.x (KitKat)</p>
<p id="e-Eh8V">19</p>
<p id="e-Zym7">10/31/2013</p>
<ul id="e-gLgQ">
<li id="e-cnK9">The default interface is made white instead of blue.</li>
<li id="e-e32Q">Added wireless printing capability.</li>
<li id="e-pE2V">Support for translucent navigation and status bars.</li>
<li id="e-cSy9">Ability for apps to use immersive mode to allow navigation and status bars hidden while maintaining user interaction.</li>
<li id="e-VX0L">Action overflow menu buttons are always visible, even for the devices with the hardware Menu key.</li>
<li id="e-KWP6">New framework (property animation) for UI transitions.</li>
<li id="e-FgQI">Built-in screen recording feature.</li>
<li id="e-pv89">Introduced <strong>Android Runtime</strong> (<strong>ART</strong>) as a new experimental runtime environment.</li>
<li id="e-JaZl">Other security enhancements and bug fixes.</li>
</ul>
<p id="e-tPpZ">4.3.x (Jelly Bean)</p>
<p id="e-lAhn">18</p>
<p id="e-mIMA">07/24/2013</p>
<ul id="e-s7ew">
<li id="e-VLEN">Supports restricted access mode for new user profiles.</li>
<li id="e-hSRS">Introduced a platform support for Khronos OpenGL ES 3.0, providing better performance for 2D and 3D graphics rendering.</li>
<li id="e-hxCB">Bluetooth low energy support.</li>
<li id="e-CzfB">Optimized location and sensor capabilities, including hardware geo fencing optimizations.</li>
<li id="e-xKE7">Many security enhancements, performance enhancements, and bug fixes.</li>
</ul>
<p id="e-qu6k">4.2, 4.2.2 (Jelly Bean)</p>
<p id="e-Bz4a">17</p>
<p id="e-wXGF">11/13/2012</p>
<ul id="e-L8IM">
<li id="e-W20d">Improved the hardware-accelerated 2D renderer to make the animation smoother.</li>
<li id="e-PUhT">Introduced the interactive screensaver mode called Daydream.</li>
<li id="e-L6BT">Adds a presentation window and external display support.</li>
<li id="e-fDLy">Full native support for <strong>right-to-left</strong> (<strong>RTL</strong>) layouts.</li>
<li id="e-Zy05">Numerous bug fixes.</li>
</ul>
<p id="e-mFsc">4.1, 4.1.x (Jelly Bean)</p>
<p id="e-Bq3J">16</p>
<p id="e-NfcY">07/09/2012</p>
<ul id="e-bdaf">
<li id="e-ZTtL">Faster and smoother interface.</li>
<li id="e-JYLa">Bi-directional text and other language support.</li>
<li id="e-Dsr6">Introduced expandable notification.</li>
<li id="e-c0nx">Added the new activity launcher animation via <code>ActivityOptions</code>.</li>
<li id="e-boai">Improved <code>WebView</code> to provide better HTML5 video viewing and canvas animation.</li>
</ul>
<p id="e-plMS">4.0.3, 4.0.4 (Ice Cream Sandwich)</p>
<p id="e-he20">15</p>
<p id="e-IbDL">12/16/2011</p>
<ul id="e-Xuw6">
<li id="e-iRXQ">Bug fixes and stability improvements.</li>
<li id="e-lFcp">New APIs, including a social stream API in the Contacts provider.</li>
<li id="e-VV7l">Better camera performance.</li>
<li id="e-z62N">Smoother screen rotation.</li>
</ul>
<p id="e-rBJb">4.0, 4.0.1, 4.0.2 (Ice Cream Sandwich)</p>
<p id="e-aJYN">14</p>
<p id="e-LC3V">10/19/2011</p>
<ul id="e-vISe">
<li id="e-GxCT">Major interface overhaul with the new Roboto font family.</li>
<li id="e-JKe5">Unified the UI framework to work for phones, tablets, and more.</li>
<li id="e-BBal">Lock screen improvements with the ability to access apps from lock screen.</li>
<li id="e-XUcp">Introduced the new voice input engine.</li>
<li id="e-aaQ5">Improved media streaming capabilities.</li>
<li id="e-XCIU">Ability to shut down applications from the recent apps list with a swipe.</li>
<li id="e-csQM">Hardware acceleration of the UI.</li>
</ul>
<p id="e-AUHw">3.2.x (Honeycomb)</p>
<p id="e-bfvf">13</p>
<p id="e-PaB8">07/15/2011</p>
<ul id="e-rNeY">
<li id="e-RMCg">Optimizations for a wider range of tablets.</li>
<li id="e-KYRq">Added a system-wide sync facility that made the SD card files accessible to apps from the system media store.</li>
<li id="e-GRxP">Bug fixes and other minor improvements.</li>
</ul>
<p id="e-dLwi">3.1 (Honeycomb)</p>
<p id="e-YuaD">12</p>
<p id="e-OCoP">05/10/2011</p>
<ul id="e-nfJN">
<li id="e-xbcP">Connectivity API for USB accessories.</li>
<li id="e-Jux2">Various UI framework updates.</li>
<li id="e-eBMm">Resizable home screen app widgets.</li>
<li id="e-uXwB">Support for an HTTP proxy for each connected Wi-Fi access point.</li>
<li id="e-mzdo">High-performance Wi-Fi lock, maintaining high-performance Wi-Fi connections when the device's screen is off.</li>
<li id="e-ITze">Updated the animation framework class with <code>ViewPropertyAnimator</code> and animating background color.</li>
</ul>
<p id="e-xTBj">3.0 (Honeycomb)</p>
<p id="e-XT7V">11</p>
<p id="e-xWif">02/22/2011</p>
<ul id="e-BIih">
<li id="e-EC6I">Added a new user interface, which optimized tablets.</li>
<li id="e-HQ3H">Introduced an action bar, giving access to contextual quick actions at the top of the screen.</li>
<li id="e-O6im">Added the fragment, a self-contained container that can be embedded in an activity. It has its own life cycle callback and is used to design tablets.</li>
<li id="e-NqYe">Added the system-wide clipboard.</li>
<li id="e-Qz16">Improved the status bar notification to support more content-rich notifications.</li>
<li id="e-hsLR">Added new animation frameworks.</li>
</ul>
<p id="e-Czmz">2.3.3, 2.3.7 (Gingerbread)</p>
<p id="e-NJYy">10</p>
<p id="e-yF2R">02/02/2011</p>
<ul id="e-IgQa"><li id="e-BaHm">Improvements and bug fixes.</li></ul>
<p id="e-AIHd">2.3, 2.3.1, 2.3.2 (Gingerbread)</p>
<p id="e-Ecqa">9</p>
<p id="e-gr1T">12/06/2010</p>
<ul id="e-nf9M">
<li id="e-DBG6">Updated the user interface design for simplicity and speed.</li>
<li id="e-vRfR">Added support for <strong>Near Field Communication</strong> (<strong>NFC</strong>).</li>
<li id="e-pPdz">Support for extra-large screen sizes and resolutions.</li>
<li id="e-nX1o">Native support for more sensors, including gyroscopes and barometers.</li>
<li id="e-ywaG">Introduced the concurrent garbage collection for improved app responsiveness and smoother animation.</li>
</ul>
<p id="e-zdgj">2.2.x (Froyo)</p>
<p id="e-UAsX">8</p>
<p id="e-tc8M">05/20/2010</p>
<ul id="e-OEKS">
<li id="e-qrcR">Improved speed, memory, and performance optimizations.</li>
<li id="e-xcJ3">Improved application speed using the JIT compilation.</li>
<li id="e-RpEX">Support for the <strong>Android Cloud to Device Messaging</strong> (<strong>C2DM</strong>) service.</li>
<li id="e-AVCV">Support for installing applications to the SD card memory.</li>
<li id="e-jpvk">USB tethering and Wi-Fi hotspot functionality.</li>
<li id="e-tzPn">Bug fixes and security patch updates.</li>
</ul>
<p id="e-hbli">2.1 (Eclair)</p>
<p id="e-tw5d">7</p>
<p id="e-qmtr">01/12/2010</p>
<ul id="e-lDFM"><li id="e-JiZE">Minor API changes and bug fixes.</li></ul>
<p id="e-GYIt">2.0.1 (Eclair)</p>
<p id="e-VnIx">6</p>
<p id="e-AdPV">12/03/2009</p>
<ul id="e-UnRb"><li id="e-R6RF">Minor API changes and bug fixes.</li></ul>
<p id="e-wGn7">2.0 (Donut)</p>
<p id="e-zpIv">5</p>
<p id="e-Sawo">10/26/2009</p>
<ul id="e-UzhB">
<li id="e-FW60">Updated camera features, including flash, digital zoom, white balance, color effect, and scene mode.</li>
<li id="e-E5uL">Optimized hardware speed and UI overhaul.</li>
<li id="e-m9eO">The <code>MotionEvent</code> class enhanced to track multi-touch events.</li>
<li id="e-VzFf">Expanded account sync, allowing users to add multiple accounts to a device.</li>
</ul>
<p id="e-LbaG">1.6 (Donut)</p>
<p id="e-gXP6">4</p>
<p id="e-W2BZ">09/15/2009</p>
<ul id="e-CXqx">
<li id="e-Y7Cq">Multilingual speech synthesis engine added to convert a text to speech.</li>
<li id="e-giPd">Updated support for CDMA/EVDO, 802.1x, VPNs technologies.</li>
</ul>
<p id="e-UwaF">1.5 (Cupcake)</p>
<p id="e-UBKe">3</p>
<p id="e-eaGw">04/27/2009</p>
<ul id="e-hgSz">
<li id="e-D82h">Added third-party keyboard support with text prediction and user dictionary.</li>
<li id="e-W1KJ">Video recording and playback in MPEG-4 and 3GP formats.</li>
<li id="e-EkZi">Added copy and paste features in the web browser.</li>
<li id="e-bCGo">Animated screen transitions.</li>
<li id="e-PGLR">Home screen widget support.</li>
</ul>
<p id="e-Xswl">1.1</p>
<p id="e-XCKE">2</p>
<p id="e-Mp1o">02/09/2009</p>
<ul id="e-DRog">
<li id="e-jL0U">First Android platform update.</li>
<li id="e-xKv0">Updated the Map application.</li>
<li id="e-niFe">In-call screen timeout default is now longer when using the speakerphone.</li>
<li id="e-y4il">Adds support for saving attachments from MMS.</li>
<li id="e-xqUs">Adds support for marquee in layouts.</li>
<li id="e-MTeS">Various bug fixes.</li>
</ul>
<p id="e-g6ZQ">1.0</p>
<p id="e-baO2">1</p>
<p id="e-W6TF">09/23/2008</p>
<ul id="e-Q6G4">
<li id="e-Y2cD">First commercial version of the Android platform.</li>
<li id="e-B5J0">Included apps such as Android Market, Gmail, Camera, Calendar, Contacts, Google Talk, Map, Media Player, Picture, Settings, and Browser.</li>
<li id="e-tY9b">Wi-Fi and Bluetooth support.</li>
<li id="e-M92h">Instant messaging, text messaging, and MMS support.</li>
</ul>
<p id="e-iUFu">The Android platform is comprised of applications, operating systems, runtime, middleware, services, and libraries. The following diagram provides a high-level view of how each layer in the Android platform is organized, and the subsequent sections provide a brief description of each major component:</p>
<img data-width="600" data-height="646" src="E5ZZ97vm.jpg"/><h2 id="e-Gctt">The Linux kernel</h2>
<p id="e-ogxi">Android is a Linux-based operating system designed and customized primarily for mobile devices, such as smartphones and tablets. Positioned at the bottom of the Android stack, the Linux kernel provides the interface between device hardware and Android software layers. The latest versions of Android are based on the Linux kernel version 3.4 or above (version 2.6 for versions prior to Android 4.0).</p>
<p id="e-EgcH">The Linux kernel provides some of the core system services such as memory management, process and task management, power management, networking stack, and various device drivers to interact with the device hardware.</p>
<h2 id="e-P6kt">Native libraries</h2>
<p id="e-SNTb">Android is delivered with a set of native libraries written in C/C++, which provide various types of services. These libraries predominantly come from the open source community.</p>
<h2 id="e-YiFI">The Android runtime</h2>
<p id="e-z6qi">The Android apps run within the <strong>Dalvik Virtual Machine</strong> (<strong>Dalvik VM</strong>), which is similar to a Java VM but has been optimized for devices with limited memory and processing capacity.</p>
<p id="e-fbGU">The Android apps are initially compiled to the Java byte code using the Java compiler, but they have an additional compilation step that transforms the Java byte code to the Dalvik byte code using a process called the <strong>Just in Time</strong> (<strong>JIT</strong>) compilation. The output produced by the JIT compiler is suitable to run within the Dalvik VM:</p>
<img data-width="700" data-height="60" src="xxjTzrxi.jpg"/><p id="e-Xt7r">Dalvik is delivered with the Android core libraries. These libraries do not align with a specific Java platform (JSE, JEE, or JME) but rather act as a hybrid platform most closely aligned with JSE, minus the user interface-focused components, AWT and Swing. The <strong>Android Application Framework</strong> (<strong>AAF</strong>) provides an alternate means of creating user interfaces.</p>
<p id="e-bo1a">Although Dalvik worked pretty well, the downside is that there is a huge lag every time the application is launched. That's where the new virtual machine, ART, comes in.</p>
<p id="e-WvJl">ART is precursor to Dalvik. It is the new application runtime introduced in Android 4.4 (KitKat) as a new experimental runtime environment and is implemented fully in Android 5.0 (Lollipop). This is primarily designed for performance and an improved app start up time. The primary difference between ART and Dalvik is the compilation approach. While Dalvik uses JIT, ART employs a new concept called <strong>Ahead-of-Time</strong> (<strong>AOT</strong>). What this means is that new apps are getting compiled during installation, before they are even launched. To learn more about ART, you can refer to <a href="https://source.android.com/devices/tech/dalvik/">https://source.android.com/devices/tech/dalvik/</a>.</p>

<h1 id="e-Hg7d">The application framework</h1>
<p id="e-CQsn">The application framework is the part of the Android platform, which is most familiar to developers. It is delivered as a set of Java libraries and allows you to build user interfaces, interact with device capabilities such as the camera or location services, load and work with various types of application resources, and perform many more useful tasks. Here are some of the major services:</p>
<ul id="e-QGI3">
<li id="e-YgsK">
<strong>ActivityManager</strong>: This service is responsible for the activity life cycle, state management, and controls the activity stack. Later, in this chapter, we will learn more about the activity life cycle.</li>
<li id="e-Op1Q">
<strong>WindowManager</strong>: This service is responsible for managing the z-order list of screens. Each activity is attached to a window that is used to display the content on the screen, which is controlled by <code>WindowManager</code>.</li>
<li id="e-aHLw">
<strong>Content providers</strong>: This provides an interface to publish and share data between applications.</li>
<li id="e-S7X4">
<strong>View system</strong>: This provides a set of UI controls to build an application user interface.</li>
<li id="e-Yyyz">
<strong>NotificationManage</strong>: This service manages application alerts and notifications.</li>
<li id="e-UcXS">
<strong>Resource</strong> Manager: This service provides access to resources, such as user interface layout, strings, color, dimensions, and so on.</li>
<li id="e-ke5E">
<strong>PackageManager</strong>: This holds the metadata of all the installed applications on the device.</li>
<li id="e-whNc">
<strong>TelephonyManager</strong>: This provides information on the telephone services available on the device, such as status and subscriber information, to the application.</li>
<li id="e-k72h">
<strong>LocationManager</strong>: This provides access to system location services.</li>
</ul>
<h2 id="e-P1Et">The application layer</h2>
<p id="e-oxeb">At the top of the stack sits the humble application, the component that actually delivers value to the user. Android comes with a set of applications that provide base functionality such as managing contacts, using the phone, checking e-mails, and browsing the web. The key to Android's success is the vast array of third-party applications that can be installed, which allow users to do things, such as stream live sports events, edit a movie captured on the phone, interact with friends through their favorite social media site, and much more.</p>

<h1 id="e-oysb">The building blocks of the Android application</h1>
<p id="e-QZ8W">Now, let's spend some time discussing applications—those things we write that provide value to the user. The Android applications are made up of various types of classes and resources. The following sections describe the different building blocks that an application can be composed of.</p>
<h2 id="e-PCtr">The Android packages (.apk)</h2>
<p id="e-ShYy">Applications are delivered for installation in an Android package format. An Android package is created as the result of compiling an Android app and is an archive file with an <code>.apk</code> extension.</p>
<p id="e-mF4a">An Android package contains all of the code and the supporting files required to run a single application, including the following:</p>
<ul id="e-hvKI">
<li id="e-i570">Dalvik executables (<code>.dex</code> files)</li>
<li id="e-iyBu">Resources</li>
<li id="e-xByi">Native libraries</li>
<li id="e-zsVS">The application manifest</li>
</ul>
<p id="e-CYi7">The Android packages can be installed directly via e-mails, URLs, or memory cards. They can also be installed indirectly through app stores such as Google Play.</p>
<h2 id="e-u1Sm">The application manifest</h2>
<p id="e-vXJg">All the Android applications have a manifest file (<code>AndroidManifest.xml</code>) that tells the Android platform everything it needs to know to successfully run the application, including the following:</p>
<ul id="e-fb05">
<li id="e-Br2R">Minimum API level required by the application</li>
<li id="e-KWrk">Hardware/software features used or required by the application</li>
<li id="e-AdJJ">Permissions required by the application such as location or camera</li>
<li id="e-LlkL">The initial screen (Android activity) to start with when the application is launched</li>
<li id="e-dOJX">The ability to install the application in the external memory</li>
<li id="e-AEit">Libraries, other than AAF, required by the application and so on</li>
</ul>
<h2 id="e-eh7M">Activities</h2>
<p id="e-KtL1">One of the most fundamental parts of an Android application is an activity. An activity represents a single screen with a user interface through which a user can interact with the application. A single application is composed of many activities. For example, a phone book application can have multiple activities representing different functions, such as list contacts, add contacts, capture contact photos, and so on.</p>
<p id="e-MrA9">A user interacts with an activity through one or more Views, which are described later in this chapter. If you are familiar with the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) pattern, you would have noticed that the activities fulfill the role of the controller.</p>
<h3 id="e-tmMG">The life cycle of an activity</h3>
<p id="e-PQWU">Activities have a well-defined life cycle that can be described in terms of states, transitions, and events. The following diagram provides a graphical view of the life cycle of an activity:</p>
<img data-width="600" data-height="321" src="uFpzoHIM.jpg"/><p id="e-EVYw">The states depicted in the preceding diagram are derived, which means that there is no <code>State</code> variable on an activity that explicitly identifies one of these states, but the state is implied and useful for discussion. The following table describes the behavior of an activity based on its state:</p>
<p id="e-rOXR">State</p>
<p id="e-QY18">Description</p>
<p id="e-wRRt"><code>Running</code></p>
<p id="e-TNyV">The activity has been created and initialized and is visible and available to the user for interaction.</p>
<p id="e-qv8Y"><code>Paused</code></p>
<p id="e-ww3v">The activity view is being partially blocked by another activity.</p>
<p id="e-vy3q"><code>Stopped</code></p>
<p id="e-rEIT">The activity is no longer visible to the user. The activity has not been destroyed, and the state is retained but it is placed in the background and no processing is allowed.</p>
<h3 id="e-sPKr">The events of an activity</h3>
<p id="e-yWua">During the transition between states, a series of events are called on the activity. These events provide developers a platform for various types of processing. The following table describes the different event callbacks and typically, the processing done in the application during each callback:</p>
<p id="e-ggkc">Event</p>
<p id="e-aUCt">Called</p>
<p id="e-DwXC">Typical processing</p>
<p id="e-FTGw"><code>onCreate</code></p>
<p id="e-xH5j">When an activity is created, generally from a user choosing to start the app</p>
<ul id="e-MRy4">
<li id="e-VJ77">This creates Views</li>
<li id="e-ZphB">This initializes variables</li>
<li id="e-GK8H">This allocates long-lived resources</li>
</ul>
<p id="e-CVrJ"><code>onStart</code></p>
<p id="e-o8hL">After <code>onCreate</code> and right before an activity becomes visible to the user</p>
<ul id="e-FGgk"><li id="e-jNJG">This allocates resources</li></ul>
<p id="e-gGua"><code>onResume</code></p>
<p id="e-hc6M">Before an activity is ready to start interacting with a user and immediately after the <code>onStart</code> callback</p>
<ul id="e-BeZE">
<li id="e-Xe3B">This initializes UI widgets for viewing</li>
<li id="e-cUxO">This starts animations or videos</li>
<li id="e-aHtq">This starts listening for GPS updates</li>
</ul>
<p id="e-NIA3"><code>onPause</code></p>
<p id="e-gCNq">When an activity's view has become partially blocked and is not the focus of input</p>
<ul id="e-UwLK">
<li id="e-HoeN">This commits unsaved updates</li>
<li id="e-euZj">This pauses animations or videos</li>
<li id="e-aYxm">This stops listening for GPS updates</li>
</ul>
<p id="e-CApQ"><code>onStop</code></p>
<p id="e-qNjk">When an activity's view is no longer visible to the user</p>
<ul id="e-qtfo"><li id="e-nuS5">This releases resources</li></ul>
<p id="e-F4QJ"><code>onRestart</code></p>
<p id="e-Ag7n">An activity is being placed back in the foreground, generally, because the user has selected the back button</p>
<ul id="e-etxq"><li id="e-INtw">This allocates resources</li></ul>
<p id="e-Ios0"><code>onDestroy</code></p>
<p id="e-c8Va">Before the activity is destroyed</p>
<ul id="e-ij78"><li id="e-XSIL">This cleans up resources that may have been allocated by an activity</li></ul>
<p id="e-ju0X">Something that is not obvious to developers and new to Android is the way the framework deals with device orientation changes. By default, when the orientation of a device is changed from portrait to landscape, Android destroys and recreates existing activities to help ensure that the most appropriate layout is used for the current device orientation.</p>
<p id="e-RyBC">If needed, this behavior can be overridden and activities can be retained. We will discuss special considerations in dealing with state and other processing concerns related to this topic in Chapter 6, <em>Making Your App Orientation-aware</em>.</p>
<h2 id="e-Lkp0">Fragments</h2>
<p id="e-PQ0j">A fragment is a reusable user interface component, introduced since Android 3.0 (API level 11), and is primarily intended to build dynamic and modular user interfaces for different screen sizes. A fragment is always embedded in an activity, and like any other view, it lives in a <code>ViewGroup</code> (<strong>ViewGroups</strong> are explained in more detail later in this chapter) inside the view hierarchy. Like an activity, a fragment defines its own layout and has its own life cycle callbacks. When designing your application to support multiple form factors, fragments can be reused to optimize the user experience based on the available screen space.</p>
<p id="e-Xt6z">Let's examine how fragments can be used to develop a modular user interface with the following example.</p>
<p id="e-K21b">The following figure depicts the wireframe of a newsreader application, designed to work on both smartphone and tablet devices. As a tablet has more screen space, the news list and the details are presented as split views in a single activity, whereas the phone uses two different activities for this:</p>
<img data-width="800" data-height="413" src="XkseWZq2.jpg"/><p id="e-cgYP">The Android smartphone uses two activities: <strong>ActivityA</strong> containing <strong>FragmentA</strong> is used to show the news list and <strong>ActivityB</strong> containing <strong>FragmentB</strong> is used to show the details of the selected news. In a tablet, we have a single activity <strong>ActivityA</strong> that contains both <strong>FragmentA</strong> and <strong>FragmentB.</strong></p>
<p id="e-GYcF">As you can see here, <strong>FragmentA</strong> and <strong>FragmentB</strong> are the same implementation and are reused in different layout configurations to provide a different user experience on both the phone and tablet.</p>
<h3 id="e-v0Ng">The fragment life cycle</h3>
<p id="e-HbEc">Unlike the activity life cycle, understanding the fragment life cycle can be a bit tricky. In the following section, we will dig more into the fragment behavior and its life cycle methods.</p>
<p id="e-Bded">The Android fragment has its own life cycle method, which is very similar to an activity. It contains all of the activity life cycle methods and is supplied with some additional callback methods. Fragments are always embedded in an activity, so its callbacks are directly affected due to the host activities' life cycle. For example, if the host activity receives <code>onStop()</code>, all the attached fragments also receive the <code>onStop()</code> callback.</p>
<p id="e-t8Ka">The following diagram provides a graphical view of the fragment life cycle:</p>
<img data-width="700" data-height="728" src="wePfR5c7.jpg"/><p id="e-xSA3">Let's take a look at each of the fragment life cycle events that gets called:</p>
<ul id="e-mzmr">
<li id="e-bhtS">
<code>onInflate</code>: This event is called only if we define a fragment directly in an activity layout using the <code>fragment</code> tag, and while the content view of the activity is being inflated (typically, when <code>setContentView()</code> is called on an activity). This method passes <code>AttributeSet</code> that holds all the fragment attributes passed from the <code>fragment</code> tag. These attributes can be stored for later use. At this stage, the fragment is not even associated with an activity, and hence, we cannot perform any user interface-related tasks.</li>
<li id="e-XZNu">
<code>onAttach</code>: This is called once the fragment instance is associated with an activity.</li>
<li id="e-mPxM">
<code>onCreate</code>: This event is called after <code>onAttach</code> and before <code>onCreateView</code>; when the fragment instance is created or recreated. At this point, the base activity that holds this fragment is in the process of being created. At this point, you may use a background thread to get data for the fragment to use.</li>
<li id="e-Kdwf">
<code>onCreateView</code>: At this point, the fragment instantiates its user interface and loads the view object hierarchy it contains. This method passes three arguments: <code>LayoutInflater</code>, <code>ViewGroup</code>, and <code>bundle</code>. The <code>LayoutInflater</code> argument can be used to inflate any layout for a fragment. A <code>bundle</code> specifies whether the fragment is created freshly or recreated. If it is recreated from the previous saved state, then the bundle will be non-null.</li>
<li id="e-q4YT">
<code>onActivityCreated</code>: This method is called when the activity that contains the fragment has been created, and the fragment's view hierarchy is instantiated. At this point, you can access the view by its ID using the <code>findViewById()</code> method and make any changes before it is visible to the user.</li>
<li id="e-MFWb">
<code>onStart</code>: This method is tied to the activity <code>onStart()</code> callback and is called when the fragment becomes visible to the user. At this point, the fragment is visible but not available for user interaction just yet.</li>
<li id="e-WPAl">
<code>onResume</code>: This method is called before the fragment is ready to start interacting with a user. At this point, the fragment is said to be running and the user is free to perform any operations on the app.</li>
<li id="e-f4Za">
<code>onPause</code>: This method is tied to the activity <code>onPause()</code> callback and is called when the fragment is taken out of the foreground.</li>
<li id="e-FiwJ">
<code>onStop</code>: This method is tied to the activity <code>onStop()</code> callback and called when the fragment is not visible.</li>
<li id="e-mosY">
<code>onDestroyView</code>: This method tells the fragment that the view created from <code>onCreateView()</code> is now detached from the fragment. This callback is called after <code>onStop()</code> and before the <code>onDestroy()</code> method.</li>
<li id="e-c8KX">
<code>onDestroy</code>: This method is called when the fragment is no longer in use. This is called after <code>onStop()</code> and before <code>onDetach()</code>.</li>
<li id="e-Kiz8">
<code>onDetach</code>: This method is called after <code>onDestroy()</code>, and when the fragment is no longer attached to an activity.</li>
</ul>
<h2 id="e-HAQH">Services</h2>
<p id="e-MosC">Services are application components that run in the background to perform long-running operations with no direct access to the user interface. A typical long-running task can be periodic downloading of data from the Internet, persisting multiple records in a database, performing file I/O, fetching a phone contacts list, and so on. Such long-running tasks can be implemented using services to provide a smooth user experience by letting the user interact with other activities, while long-running jobs are being processed in the background.</p>
<h2 id="e-Q7Kp">Content providers</h2>
<p id="e-l4JH">Content providers manage access to a central repository of data such as contacts. It provides you with a standard interface through which the other applications can access and manage the data repository.</p>
<h2 id="e-Kvnt">Broadcast receivers</h2>
<p id="e-Ee5C">Broadcast receivers are components that perform some type of processing in response to system-wide broadcasts. Broadcasts are generally initiated by the system for events such as low battery, taking a picture, or turning on Bluetooth. Applications may also choose to send broadcasts; a content provider might send a broadcast when data, such as a contact, has been updated. While broadcast receivers do not have a user interface, they may indirectly cause updates to a status.</p>
<h2 id="e-XO6M">Views and ViewGroups</h2>
<p id="e-gtOh">Everything that you see in an Android app is a View; buttons, labels, text boxes, and radio buttons are all examples of Views. Views are organized in a hierarchy using various types of ViewGroups. A ViewGroup is a special kind of View that is used to arrange (layout) other Views on the screen.</p>
<h2 id="e-DyRD">Declarative versus programmatic View creation</h2>
<p id="e-Xnf2">Views and ViewGroups can be created using two different methods: programmatically or declaratively. When using a programmatic approach, a developer makes API calls to create and position each individual View on the screen. When using a declarative approach, a developer creates XML layout files that specify how Views should be arranged. The declarative method enjoys several advantages stated as follows:</p>
<ul id="e-Lcyo">
<li id="e-YkQ6">It provides better separation of the visual design of an application from the processing logic</li>
<li id="e-k7Y5">It allows multiple layouts to be created to support multiple devices or device configurations with a single code base</li>
<li id="e-O8k1">Development tools, such as Android Studio and the Android plugins for Eclipse and Xamarin Studio Android designer, allow you to view the user interface as you build it, without the need to compile and execute your application after each change</li>
</ul>
<p id="e-RkPN">While most developers prefer the declarative method of View creation; in practice, some combination of programmatic and declarative methods is often required.</p>
<h2 id="e-by7O">User interface widgets</h2>
<p id="e-jAyW">Android provides a comprehensive set of user interface widgets that can be used to build a rich user experience. All of these widgets are subtypes of a View and can be organized into sophisticated layouts using various types of ViewGroups. All of the user interface widgets can be found in the <code>android.widget</code> package within the application framework.</p>
<p id="e-lfI9">The following screenshot depicts some of the basic Android widgets:</p>
<img data-width="600" data-height="357" src="ThiUXqjF.jpg"/><h2 id="e-GWMS">Common layouts</h2>
<p id="e-Apiq">The application framework has a number of subclasses of <code>ViewGroup</code>, each of which provides a unique and useful way of organizing content:</p>
<img data-width="700" data-height="299" src="dWevjEtX.jpg"/><p id="e-a7wx">The preceding diagram depicts some of the common layout managers available in Android. Layout managers are the <code>ViewGroup</code> classes that act as containers to host child views or layouts. Each of these standard layout managers provides a specific strategy to manage the size and position of its children. For example, the <code>LinearLayout</code> class places its children either horizontally or vertically, one view adjacent to the other.</p>
<p id="e-XFUs">The following table lists the different types of layout managers available in Android:</p>
<p id="e-fSvd">Layout</p>
<p id="e-YuR4">Description</p>
<p id="e-DyYd">Scenario</p>
<p id="e-zXNZ">Linear layout</p>
<p id="e-e7th">This organizes its children into a single horizontal or vertical row and creates a scrollbar when required.</p>
<p id="e-gZ7U">Use this when widget positions flow horizontally or vertically.</p>
<p id="e-YsEw">Relative layout</p>
<p id="e-O3lJ">This organizes child objects relative to each other or to the parent.</p>
<p id="e-l9BX">Use this when widget positions can best be described in relationship to another widget (to the left of) or the boundary area of the parent (right side, centered).</p>
<p id="e-rXR7">Table layout</p>
<p id="e-wlBe">This organizes its children into rows and columns.</p>
<p id="e-I1Vt">Use this when widget positions would naturally fit into rows and columns. This is great when multiple columns of entry and labels are needed.</p>
<p id="e-SXxu">For complex layout scenarios, Android allows layouts to be nested. Deeply nested layouts can have an impact on the performance and should be avoided if possible.</p>
<h3 id="e-XRk5">Tip</h3>
<p id="e-ChLJ"><strong>Downloading the example code</strong></p>
<p id="e-Y5NQ">You can download the example code files from your account at <a href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p>
<h2 id="e-o7XJ">Adapter layouts</h2>
<p id="e-Ho8B">For layouts that are driven by a dynamic data source, the application framework has a set of classes derived from <code>AdapterView</code>:</p>
<img data-width="700" data-height="297" src="AN5eT7Jh.jpg"/><p id="e-U8qj">The preceding diagram depicts two of the most common adapter layouts:</p>
<ul id="e-b9bK">
<li id="e-PJxG">
<strong>ListView</strong>: This organizes content from the data source into a scrolling single column list</li>
<li id="e-Ywep">
<strong>GridView</strong>: This organizes content from the data source into a grid of columns and rows</li>
</ul>
<h2 id="e-yyGa">XML layout files</h2>
<p id="e-r7Ar">To create a UI using a declarative method, Android provides an XML vocabulary with tags that define the various types of elements that can compose a View. The concept behind Android XML layout files is very similar to the way HTML tags are used to define web pages or Microsoft's XAML tags are used to define <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) user interfaces. The following example shows a simple View using a linear layout and containing a search entry field and search button:</p>
<pre id="e-fbfE">&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;LinearLayout xmlns:android="http://schemas.android.com/apk
/res/android"
  android:orientation="vertical"
  android:layout_width="fill_parent"
  android:layout_height="fill_parent"&amp;gt;
   &amp;lt;TextView
    android:text="Enter Search Criteria"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:id="@+id/searchCriteriaTextView" /&amp;gt;
     &amp;lt;Button
      android:text="Search"
      android:layout_width="fill_parent"
      android:layout_height="wrap_content"
      android:id="@+id/searchButton" /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;</pre>
<h3 id="e-g4GP">Element and attribute names</h3>
<p id="e-nq5x">Care has been taken to align the names for elements and attributes in the XML vocabulary with class and method names from the application framework. In the previous example, the element names <code>LinearLayout</code>, <code>TextView</code>, and <code>Button</code> correspond to class names in the application framework. Likewise, in the <code>Button</code> element, the <code>android:text</code> attribute corresponds to the <code>setText()</code> setter on the class.</p>
<h3 id="e-hEKe">The View and layout identifiers</h3>
<p id="e-hquk">Each View can have a unique integer ID associated with it and can be used to reference the View from within an application's code. In the XML file, the ID is specified as a user-friendly text name. For example, consider the following line of code:</p>
<pre id="e-hRuK">android:id="@+id/searchButton"</pre>
<p id="e-ob8W">In this example, the <code>@</code> operator tells the parser that it should treat the remainder of the string as an ID resource; the <code>+</code> symbol tells the parser that this is a new resource name that should be added to the resource file, <code>R.java</code>. The resource file defines integer constants that can be used to reference resources.</p>
<h2 id="e-WK4R">Using XML layouts from activities</h2>
<p id="e-zEhv">XML layouts can easily be loaded by an application at runtime. This task is generally performed from within the <code>onCreate()</code> method of an activity using the <code>setContentView()</code> method. For example, consider the following line of code:</p>
<pre id="e-YuNa">setContentView(R.layout.main);</pre>
<h2 id="e-YhIn">Intents</h2>
<p id="e-U6Dz">Intents are messages that can be sent to the various types of components in an Android app in order to request some type of action to be performed. Intents may be used to accomplish any of the following:</p>
<ul id="e-FpQz">
<li id="e-oQPg">Start an activity with the option of receiving a result</li>
<li id="e-BZTY">Start or stop a service</li>
<li id="e-ROD5">Notify the component of conditions, such as low battery or time zone change</li>
<li id="e-KGOr">Request an action from another app, such as request the map app to display a location or request that the camera app take a picture and save it</li>
</ul>
<h2 id="e-x8wU">Resources</h2>
<p id="e-mXe2">Creating an Android application involves more than simply writing code. A rich mobile app requires things such as images, audio files, animations, menus, and style, just to name a few. The application framework provides APIs that can be used to load and utilize the various types of resources with your Android apps.</p>
<h2 id="e-TTWB">The R.java file</h2>
<p id="e-UeqS">Resources are generally referenced from within an application using an integer constant that is automatically assigned when the resource is added to the project and compiled. These constants are placed in a Java source file named <code>R.java</code>. The following example shows the <code>R.java</code> class from a simple application:</p>
<pre id="e-NXIQ">public final class R {
  public static final class attr {
  }
  public static final class drawable {
    public static final int icon=0x7f020000;
  }
  public static final class id {
    public static final int myButton=0x7f050000;
    public static final int searchButton=0x7f050002;
    public static final int searchCriteriaTextView=0x7f050001;
  }
  public static final class layout {
    public static final int main=0x7f030000;
    public static final int search=0x7f030001;
  }
  public static final class string {
    public static final int app_name=0x7f040001;
    public static final int hello=0x7f040000;
  }
}</pre>

<h1 id="e-VWns">Summary</h1>
<p id="e-L4Lg">In this chapter, we have provided a concise and adequate introduction to the Android platform and the Android application's building blocks. We have also seen how the Android platform has evolved with rich features being added to each platform releases.</p>
<p id="e-HztH">In the next chapter, we will turn our attention to Xamarin.Android and the facilities it provides to allow the Android development with .NET and C#.</p>
</body></html>