- en: Chapter 15. Advanced Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reproducing the page curl effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating content sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using physics in UI elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the text-to-speech feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore only some of the huge variety of advanced features
    that the iOS platform has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will create a project that displays content separated into
    pages, which the user can navigate through like in a normal book, with the help
    of the newly introduced `UIPageViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: We will then discuss integrating content-sharing features and providing share/post
    functionality in our app with the help of `UIActivityViewController`. For the
    user interface, we will explore some basic aspects of **UIKit Dynamics** that
    allows rich animations for a better user experience. We will also learn how to
    provide custom transitions between view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the last recipe of this chapter, we will work with the new text-to-speech
    feature and create an app that speaks, with the help of the `AVSpeechSynthesizer`
    class!
  prefs: []
  type: TYPE_NORMAL
- en: Reproducing the page curl effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an app that displays content like that of a book
    with the help of the `UIPageViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `BookApp`.
    Add another controller to the project and name it `Page`. Configure the appearance
    of the `Page` controller however you like. In the source code for this recipe,
    the contains a `UIImageView` and a `UILabel`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the `BookAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a property to the `Page` class and change its constructor, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, configure the content that will be displayed in `Page`, in the `ViewDidLoad`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Click-and-drag the cursor on the simulator's
    screen area to change the page. The result should look similar to the following
    screenshot:![How to do it...](img/8924OT_15_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIPageViewController` class introduced with iOS 5 was a desired component
    by many developers. It allows us to navigate through content with the effect of
    a real book, like in Apple's *iBooks* app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize it with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the constructor determines the type of the effect. The
    only available value right now is `PageCurl`. The second parameter determines
    the orientation of the effect. The `Horizontal` parameter is the value for the
    effect similar to a book, while `Vertical` is the value for the effect similar
    to a notebook, where the pages are bound at the top. The third parameter determines
    the position of the bind of the book. The `Min` parameter declares that the bind
    is on one edge of the screen (in this case, on the left-hand side).
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing the page controller, we need to set its first page by calling
    its `SetViewControllers` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The method's first parameter is an array of `UIViewController` objects. We can
    set either one or two controllers for this parameter, depending on the device's
    orientation. For example, if the app supports landscape orientation, we might
    want to show two pages at the same time. The second parameter basically determines
    the navigation direction of the included pages. The `Forward` parameter means
    the next page will be loaded if we swipe from right to left on the screen, while
    `Reverse` means the previous page will be loaded for the same swipe. The last
    parameter is of delegate type `UICompletionHandler` and represents the handler
    to be executed after the controllers have been added. In this example, we do not
    need it, so we just pass an empty lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to provide the data source for the rest of the pages of our "book."
    Once again, Xamarin simplifies things for us by providing two very helpful properties
    for us to use: `GetNextViewController` and `GetPreviousViewController`. These
    properties merely represent the callback methods we would have to override if
    we were creating a delegate object for the page controller. Apart from their names,
    the signatures of these two methods are identical, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter gives us the page controller, while the second parameter
    gives us the controller that is currently displayed on screen when the method
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of these methods, we simply have to return the controller
    that should be loaded after or before the current one. If we do not want the effect
    to be activated, we just return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we set the size of the page controller''s view and add
    it to a superview so it will be displayed, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we would like our app to support landscape orientation, we would first have
    to implement the `ShouldAutoRotate` and `GetSupportedInterfaceOrientations` methods
    in the `BookAppViewController` class. Secondly, we would have to provide two view
    controllers to the `SetViewControllers` method of the `UIPageViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Double-sided pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might have noticed in the previous screenshot of this recipe, when we
    turn a page, its content is displayed in reverse on the page's back, like when
    we see through a page in real books. We have the option of creating double-sided
    pages by setting the `UIPageViewController.DoubleSided` property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating content sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will add the content-sharing functionality in an app. The
    app will be able to share content through social networks, e-mail, SMS, or **AirDrop**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `ContentShareApp`.
    The app will work on the simulator, but more sharing targets will be available
    on an actual device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button to the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `ContentShareAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on a device. Tap the **Share link** button, and a screen
    similar to the following screenshot will appear:![How to do it...](img/8924OT_15_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIActivityViewController` class is responsible for displaying the available
    sharing options, depending on the availability of these options on each device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize an instance of `UIActivityViewController`, we pass the following
    two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is an array of `NSObject` objects. In this example, we just
    pass one object of the `NSString` type. This object is a URL. The second parameter
    is an array of `UIActivity` objects. In this example, we pass `null`. The `UIActivity`
    class is meant to be subclassed so we can add our own custom activity "providers"
    to `UIActivityViewController`, with our own icon and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then set the callback that will be called when the user completes the action,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Through the callback, we get an `NSString` representation of the type of activity
    and a bool indicating whether the user actually completed (`true`) or cancelled
    (`false`) the activity. Note that this parameter will be `false`, whether the
    user tapped the cancelled button on `UIActivityViewController` or actually cancelled
    the action later through the corresponding screen (for example, tapping the **Cancel**
    button in the mail-composition screen).
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have set up `UIActivityViewController`, we present it modally using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The controller will be automatically dismissed whether the user has completed
    the action or cancelled it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we tap one of the available options, the corresponding screen will appear.
    The following screenshot shows the Facebook-share screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can exclude activities we do not want to display through the `ExcludeActivityTypes`
    property. For example, to remove the mail activity from the options, we set the
    following array of `NSString` objects to the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Implementing custom transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an app that displays a view controller modally
    but with our own custom-animated transition.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `CustomTransitionApp`.
    Add another view controller to the project and name it `ModalController`. Finally,
    we will need a button on each of these controllers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following classes to the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method of `CustomTransitionAppViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the button and watch the modal
    controller being presented smoothly from the top-left corner. The result should
    be similar to the following screenshot:![How to do it...](img/8924OT_15_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create our custom transition, we need to create two objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first object is a subclass of `UIViewControllerAnimatedTransitioning` as
    shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This class contains two methods that we need: `TransitionDuration`, which specifies
    the duration of the animated transition, and `AnimateTransition`, where the actual
    animation takes place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `AnimateTransition` method, we get a `IUIViewControllerContextTransitioning`
    object, which is responsible for the whole process. The animation will take place
    on a `UIView` that the object creates for this purpose. This `UIView` object is
    accessed through the transition context object''s `ContainerView` property, as
    shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Through the transition context object, we can also get the controllers that
    take part in the transitioning. To get the target controller, we call the `GetViewControllerForKey`
    method, passing to it `UITransitionContext.ToViewControllerKey`, using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After we get the objects we need, we add the target controller''s view to the
    transition context''s view and change its frame with the `UIView.Animate` method.
    When all animations are executed, we need to call the `CompleteTransition` method
    on the transition context, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second object is a subclass of `UIViewControllerTransitioningDelegate`.
    The declaration of the class is shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `MyTransitionDelegate` subclass, we override the `PresentingController`
    method and return an instance of `MyTransitionAnimator` that we created earlier,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsPresenting` property of `MyTransitionAnimator` is used as a flag so
    the animator will know if the transition is for presenting a controller or dismissing
    it. We set it to `false` inside the `GetAnimationControllerForDismissedController`
    method from which we return the same `MyTransitionAnimator` instance, using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is clear that one method will be called when the controller is to be presented
    and the other is to be dismissed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to enable everything, we set the `ModalPresentationStyle` property
    to `UIModalPresentationStyle.Custom`, and a new instance of `MyTransitioningDelegate`
    to the `TransitioningDelegate` property of the controller that will be presented,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom transitions are not limited to modal controllers. We can use custom transitions
    for pushing controllers into the navigation stack of a navigation controller or
    completely create our own navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning between child controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UIViewController` class contains the `Transition` method that allows us
    to transition from one child controller to another, inside the parent controller.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Child controllers are controllers whose views are part of the hierarchy of a
    third controller's view. This controller is the parent controller.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Animating views* recipe in [Chapter 11](ch11.html "Chapter 11. Graphics
    and Animation"), *Graphics and Animation*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using physics in UI elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use UIKit Dynamics to add the properties of physics
    to an image view. The image view will drop from its initial position to the bottom
    of the screen, simulating the effect of an object dropping on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `ViewPhysicsApp`.
    Add `UIImageView` and two buttons to the controller. We will also need an image
    to show in the image view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following fields in the `ViewPhysicsAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the `ViewDidLoad` method again, add the following button handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the **Drop!** button and watch
    the image view drop to the bottom of the screen. Tap the **Reset** button to reset
    it back to its original position. The following screenshot shows the app in its
    initial state and after the **Drop!** button is tapped:![How to do it...](img/8924OT_15_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UIKit Dynamics offers a variety of objects that allow us to add the properties
    of physics to UIKit objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to initialize a `UIDynamicAnimator` object.
    This class provides the context in which all the physics animations will take
    place. We pass the controller''s view, which automatically makes it our 2D "physics
    world," using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created the dynamic animator, we need to add some behavior to
    it. Inside the `btnDrop` handler, we first make sure the image view will be affected
    by gravity by creating a `UIGravityBehavior` instance, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we leave it as it is, the image view will just drop below the bottom boundary
    of the screen. So, we also need a collision behavior, which we can add using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the collision also needs a boundary to collide with, or it will have
    the same effect if it was not there. In this case, we use the boundary of our
    animator object, as indicated in the preceding highlighted code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our behavior set up, we add them to our animator to put everything
    into motion, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also modify how the image view will bounce when it hits the ground.
    Try adding the following code below the `UICollisionBehavior` initialization line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, don''t forget to add the new behavior to the animator, as shown
    in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you run the app and tap the **Drop!** button, the image will bounce more
    when it hits the ground!
  prefs: []
  type: TYPE_NORMAL
- en: UIKit Dynamics usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UIKit Dynamics was designed to provide simple 2D physics to `UIView` objects
    or to every object that implements the Objective-C `UIDynamicItem` protocol (`IUIDynamicItem`
    interface in C#). It was not designed to develop games with `UIView` objects.
    For this purpose, we have the **SpriteKit framework**, which is available through
    the `MonoTouch.SpriteKit` namespace. This is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the text-to-speech feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to work with `AVSpeechSynthesizer`, the class
    that provides the **Text-To-Speech** (**TTS**) functionality for many different
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `SpeechApp`.
    Add a `UITextField` and a button to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `MonoTouch.AVFoundation` namespace in the `SpeechAppViewController.cs`
    file, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Type some text in English in the text
    field and tap the **Speak** button. Listen while your app speaks!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AVSpeechSynthesizer` class was introduced with iOS 7\. It provides very
    simple and practical TTS functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing an instance of the class, we create an `AVSpeechUtterance`
    object, passing it to the text we want it to process, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set the rate of the speech and assign a voice to the utterance, using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The rate adjusts the speed at which the text will be spoken. You can test various
    speeds to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The voice is an instance of `AVSpeechSynthesisVoice`. To initialize it, we call
    the `FromLanguage` static method, passing the BCP-47 language code. Unfortunately,
    there is only one type of voice for each available language, and we have no control
    over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to start the speech, we call the `SpeakUtterance` method to the synthesizer,
    passing the utterance object to it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can call the `SpeakUtterance` method multiple subsequent times, passing a
    different utterance object each time. The speech synthesizer will queue each utterance
    and play it in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can enumerate the available language codes that the speech synthesizer supports
    by enumerating the return value of the `AVSpeechSynthesisVoice.GetSpeechVoices()`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adjusting the utterance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can make more adjustments to how the speech will be performed through the
    following properties of the `AVSpeechUtterance` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PitchMultiplier`: This is the pitch of the utterance. It is a float whose
    values are in the range of `0.5` and `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostUtteranceDelay`, `PreUtteranceDelay`: This is the amount of time to wait
    after (post) and/or before (pre) each utterance is spoken, in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Volume`: This is the audio volume of the speech. It is in the range of `0.0`
    (silent) to `1.0` (loudest).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
