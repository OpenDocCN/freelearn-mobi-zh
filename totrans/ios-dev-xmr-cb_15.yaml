- en: Chapter 15. Advanced Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。高级功能
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reproducing the page curl effect
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新生成翻页效果
- en: Integrating content sharing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成内容共享
- en: Implementing custom transitions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义过渡效果
- en: Using physics in UI elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI元素中使用物理效果
- en: Implementing the text-to-speech feature
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现文本到语音的功能
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will explore only some of the huge variety of advanced features
    that the iOS platform has to offer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索iOS平台提供的众多高级功能中的一部分。
- en: Specifically, we will create a project that displays content separated into
    pages, which the user can navigate through like in a normal book, with the help
    of the newly introduced `UIPageViewController` class.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将创建一个项目，显示内容分为页面，用户可以通过`UIPageViewController`类像在普通书中一样导航。
- en: We will then discuss integrating content-sharing features and providing share/post
    functionality in our app with the help of `UIActivityViewController`. For the
    user interface, we will explore some basic aspects of **UIKit Dynamics** that
    allows rich animations for a better user experience. We will also learn how to
    provide custom transitions between view controllers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将讨论集成内容共享功能，并使用`UIActivityViewController`在我们的应用中提供分享/发布功能。对于用户界面，我们将探讨**UIKit
    Dynamics**的一些基本方面，它允许丰富的动画，以提供更好的用户体验。我们还将学习如何提供视图控制器之间的自定义过渡。
- en: In the last recipe of this chapter, we will work with the new text-to-speech
    feature and create an app that speaks, with the help of the `AVSpeechSynthesizer`
    class!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个小节中，我们将使用新的文本到语音功能，并创建一个应用，该应用使用`AVSpeechSynthesizer`类进行语音输出！
- en: Reproducing the page curl effect
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新生成翻页效果
- en: In this recipe, we will create an app that displays content like that of a book
    with the help of the `UIPageViewController` class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将创建一个应用，使用`UIPageViewController`类显示类似书籍的内容。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `BookApp`.
    Add another controller to the project and name it `Page`. Configure the appearance
    of the `Page` controller however you like. In the source code for this recipe,
    the contains a `UIImageView` and a `UILabel`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用**，并将其命名为`BookApp`。向项目中添加另一个控制器，并将其命名为`Page`。根据您的喜好配置`Page`控制器的外观。在此菜谱的源代码中，包含一个`UIImageView`和一个`UILabel`。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Enter the following code in the `BookAppViewController` class:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BookAppViewController`类中输入以下代码：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a property to the `Page` class and change its constructor, as shown in
    the following code:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Page`类添加一个属性并更改其构造函数，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, configure the content that will be displayed in `Page`, in the `ViewDidLoad`
    method:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`ViewDidLoad`方法中配置将在`Page`中显示的内容：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Compile and run the app on the simulator. Click-and-drag the cursor on the simulator's
    screen area to change the page. The result should look similar to the following
    screenshot:![How to do it...](img/8924OT_15_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。在模拟器的屏幕区域上点击并拖动光标以更改页面。结果应类似于以下截图：![如何操作...](img/8924OT_15_01.jpg)
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIPageViewController` class introduced with iOS 5 was a desired component
    by many developers. It allows us to navigate through content with the effect of
    a real book, like in Apple's *iBooks* app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 5中引入的`UIPageViewController`类是许多开发人员期望的组件。它允许我们通过类似于真实书籍的效果导航内容，就像在苹果的*iBooks*应用中一样。
- en: 'We initialize it with the following line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下行初始化它：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first parameter of the constructor determines the type of the effect. The
    only available value right now is `PageCurl`. The second parameter determines
    the orientation of the effect. The `Horizontal` parameter is the value for the
    effect similar to a book, while `Vertical` is the value for the effect similar
    to a notebook, where the pages are bound at the top. The third parameter determines
    the position of the bind of the book. The `Min` parameter declares that the bind
    is on one edge of the screen (in this case, on the left-hand side).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的第一个参数确定效果的类型。目前唯一可用的值是`PageCurl`。第二个参数确定效果的方向。`Horizontal`参数是类似于书的效应的值，而`Vertical`是类似于笔记本的效应的值，其中页面在顶部装订。第三个参数确定书的装订位置。`Min`参数表示装订在屏幕的一边（在这种情况下，在左侧）。
- en: 'After initializing the page controller, we need to set its first page by calling
    its `SetViewControllers` method, as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化页面控制器之后，我们需要通过调用其`SetViewControllers`方法来设置其第一页，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method's first parameter is an array of `UIViewController` objects. We can
    set either one or two controllers for this parameter, depending on the device's
    orientation. For example, if the app supports landscape orientation, we might
    want to show two pages at the same time. The second parameter basically determines
    the navigation direction of the included pages. The `Forward` parameter means
    the next page will be loaded if we swipe from right to left on the screen, while
    `Reverse` means the previous page will be loaded for the same swipe. The last
    parameter is of delegate type `UICompletionHandler` and represents the handler
    to be executed after the controllers have been added. In this example, we do not
    need it, so we just pass an empty lambda.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的第一参数是一个`UIViewController`对象的数组。我们可以为该参数设置一个或两个控制器，具体取决于设备的方向。例如，如果应用支持横屏方向，我们可能希望同时显示两个页面。第二个参数基本上决定了包含页面的导航方向。`Forward`参数意味着如果我们从右向左在屏幕上滑动，将加载下一页，而`Reverse`意味着对于相同的滑动将加载上一页。最后一个参数是委托类型`UICompletionHandler`，表示在控制器被添加后要执行的处理器。在这个例子中，我们不需要它，所以我们只传递一个空的lambda。
- en: 'Next, we need to provide the data source for the rest of the pages of our "book."
    Once again, Xamarin simplifies things for us by providing two very helpful properties
    for us to use: `GetNextViewController` and `GetPreviousViewController`. These
    properties merely represent the callback methods we would have to override if
    we were creating a delegate object for the page controller. Apart from their names,
    the signatures of these two methods are identical, as shown in the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的“书籍”的其余页面提供数据源。Xamarin再次通过为我们提供两个非常有用的属性来简化事情：`GetNextViewController`和`GetPreviousViewController`。这两个属性仅仅代表如果我们为页面控制器创建一个委托对象时必须重写的回调方法。除了它们的名称外，这两个方法的签名是相同的，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first parameter gives us the page controller, while the second parameter
    gives us the controller that is currently displayed on screen when the method
    is called.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数给我们页面控制器，而第二个参数给我们在方法调用时屏幕上当前显示的控制器。
- en: In the implementation of these methods, we simply have to return the controller
    that should be loaded after or before the current one. If we do not want the effect
    to be activated, we just return `null`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法的实现中，我们只需返回在当前控制器之后或之前应该加载的控制器。如果我们不想激活效果，我们只需返回`null`。
- en: 'Last but not least, we set the size of the page controller''s view and add
    it to a superview so it will be displayed, using the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们通过以下代码设置页面控制器的视图大小并将其添加到父视图中，以便它将被显示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: If we would like our app to support landscape orientation, we would first have
    to implement the `ShouldAutoRotate` and `GetSupportedInterfaceOrientations` methods
    in the `BookAppViewController` class. Secondly, we would have to provide two view
    controllers to the `SetViewControllers` method of the `UIPageViewController` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的应用支持横屏方向，我们首先必须在`BookAppViewController`类中实现`ShouldAutoRotate`和`GetSupportedInterfaceOrientations`方法。其次，我们必须向`UIPageViewController`类的`SetViewControllers`方法提供两个视图控制器。
- en: Double-sided pages
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双面页面
- en: As you might have noticed in the previous screenshot of this recipe, when we
    turn a page, its content is displayed in reverse on the page's back, like when
    we see through a page in real books. We have the option of creating double-sided
    pages by setting the `UIPageViewController.DoubleSided` property to `true`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在前面的菜谱截图中所注意到的，当我们翻页时，其内容在页面的背面以相反的方式显示，就像我们通过真实书籍的一页看过去一样。我们有通过将`UIPageViewController.DoubleSided`属性设置为`true`来创建双面页面的选项。
- en: Integrating content sharing
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成内容共享
- en: In this recipe, we will add the content-sharing functionality in an app. The
    app will be able to share content through social networks, e-mail, SMS, or **AirDrop**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向应用中添加内容共享功能。应用将能够通过社交网络、电子邮件、短信或**AirDrop**来共享内容。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ContentShareApp`.
    The app will work on the simulator, but more sharing targets will be available
    on an actual device.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`ContentShareApp`。该应用将在模拟器上运行，但在实际设备上会有更多的共享目标。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a button to the controller.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中添加一个按钮。
- en: 'Add the following code in the `ContentShareAppViewController` class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContentShareAppViewController`类中添加以下代码：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile and run the app on a device. Tap the **Share link** button, and a screen
    similar to the following screenshot will appear:![How to do it...](img/8924OT_15_02.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用。点击**分享链接**按钮，将出现类似于以下截图的屏幕：![如何操作...](img/8924OT_15_02.jpg)
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIActivityViewController` class is responsible for displaying the available
    sharing options, depending on the availability of these options on each device.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIActivityViewController`类负责显示可用的分享选项，具体取决于每个设备上这些选项的可用性。'
- en: 'To initialize an instance of `UIActivityViewController`, we pass the following
    two arguments:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化一个`UIActivityViewController`实例，我们需要传递以下两个参数：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first parameter is an array of `NSObject` objects. In this example, we just
    pass one object of the `NSString` type. This object is a URL. The second parameter
    is an array of `UIActivity` objects. In this example, we pass `null`. The `UIActivity`
    class is meant to be subclassed so we can add our own custom activity "providers"
    to `UIActivityViewController`, with our own icon and functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个`NSObject`对象的数组。在这个例子中，我们只传递一个`NSString`类型的对象。此对象是一个URL。第二个参数是一个`UIActivity`对象的数组。在这个例子中，我们传递`null`。`UIActivity`类旨在被继承，这样我们就可以向`UIActivityViewController`添加我们自己的自定义活动“提供者”，并具有我们自己的图标和功能。
- en: 'We then set the callback that will be called when the user completes the action,
    using the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码设置当用户完成操作时将被调用的回调：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Through the callback, we get an `NSString` representation of the type of activity
    and a bool indicating whether the user actually completed (`true`) or cancelled
    (`false`) the activity. Note that this parameter will be `false`, whether the
    user tapped the cancelled button on `UIActivityViewController` or actually cancelled
    the action later through the corresponding screen (for example, tapping the **Cancel**
    button in the mail-composition screen).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回调，我们获取活动类型的`NSString`表示和一个布尔值，表示用户是否实际上完成了（`true`）或取消了（`false`）活动。请注意，无论用户是否在`UIActivityViewController`上点击了取消按钮，还是后来通过相应的屏幕（例如，在邮件编写屏幕中点击**取消**按钮）实际上取消了操作，此参数都将为`false`。
- en: 'After we have set up `UIActivityViewController`, we present it modally using
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置了`UIActivityViewController`之后，我们使用以下代码以模态方式展示它：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The controller will be automatically dismissed whether the user has completed
    the action or cancelled it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论用户是否完成了操作或取消了操作，控制器都将自动消失。
- en: 'When we tap one of the available options, the corresponding screen will appear.
    The following screenshot shows the Facebook-share screen:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击一个可用的选项时，将出现相应的屏幕。以下截图显示了Facebook分享屏幕：
- en: '![How it works...](img/8924OT_15_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8924OT_15_03.jpg)'
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can exclude activities we do not want to display through the `ExcludeActivityTypes`
    property. For example, to remove the mail activity from the options, we set the
    following array of `NSString` objects to the property:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`ExcludeActivityTypes`属性排除我们不想显示的活动。例如，要从选项中删除邮件活动，我们将以下`NSString`对象的数组设置到该属性：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing custom transitions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义过渡
- en: In this recipe, we will create an app that displays a view controller modally
    but with our own custom-animated transition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个应用，该应用以模态方式显示视图控制器，但具有我们自己的自定义动画过渡。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `CustomTransitionApp`.
    Add another view controller to the project and name it `ModalController`. Finally,
    we will need a button on each of these controllers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用**，并将其命名为`CustomTransitionApp`。将另一个视图控制器添加到项目中，并将其命名为`ModalController`。最后，我们还需要在每个控制器上添加一个按钮。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the following classes to the project:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下类添加到项目中：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code in the `ViewDidLoad` method of `CustomTransitionAppViewController`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomTransitionAppViewController`的`ViewDidLoad`方法中添加以下代码：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compile and run the app on the simulator. Tap the button and watch the modal
    controller being presented smoothly from the top-left corner. The result should
    be similar to the following screenshot:![How to do it...](img/8924OT_15_04.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。点击按钮，观察模态控制器从左上角平滑地展示。结果应该类似于以下截图：![如何操作...](img/8924OT_15_04.jpg)
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To create our custom transition, we need to create two objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的自定义过渡，我们需要创建两个对象。
- en: 'The first object is a subclass of `UIViewControllerAnimatedTransitioning` as
    shown in the following line of code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象是 `UIViewControllerAnimatedTransitioning` 的子类，如下面的代码行所示：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This class contains two methods that we need: `TransitionDuration`, which specifies
    the duration of the animated transition, and `AnimateTransition`, where the actual
    animation takes place.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含我们需要的两个方法：`TransitionDuration`，它指定了动画过渡的持续时间，以及 `AnimateTransition`，其中实际进行动画。
- en: 'Inside the `AnimateTransition` method, we get a `IUIViewControllerContextTransitioning`
    object, which is responsible for the whole process. The animation will take place
    on a `UIView` that the object creates for this purpose. This `UIView` object is
    accessed through the transition context object''s `ContainerView` property, as
    shown in the following line of code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AnimateTransition` 方法内部，我们得到一个 `IUIViewControllerContextTransitioning` 对象，该对象负责整个过程。动画将在对象为此目的创建的
    `UIView` 上进行。这个 `UIView` 对象可以通过过渡上下文对象的 `ContainerView` 属性访问，如下面的代码行所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Through the transition context object, we can also get the controllers that
    take part in the transitioning. To get the target controller, we call the `GetViewControllerForKey`
    method, passing to it `UITransitionContext.ToViewControllerKey`, using the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过过渡上下文对象，我们还可以获取参与过渡的控制器。要获取目标控制器，我们调用 `GetViewControllerForKey` 方法，传递给它 `UITransitionContext.ToViewControllerKey`，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After we get the objects we need, we add the target controller''s view to the
    transition context''s view and change its frame with the `UIView.Animate` method.
    When all animations are executed, we need to call the `CompleteTransition` method
    on the transition context, as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取所需的对象后，我们将目标控制器的视图添加到过渡上下文的视图中，并使用 `UIView.Animate` 方法更改其框架。当所有动画执行完毕后，我们需要在过渡上下文中调用
    `CompleteTransition` 方法，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second object is a subclass of `UIViewControllerTransitioningDelegate`.
    The declaration of the class is shown in the following line of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对象是 `UIViewControllerTransitioningDelegate` 的子类。类的声明如下面的代码行所示：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the `MyTransitionDelegate` subclass, we override the `PresentingController`
    method and return an instance of `MyTransitionAnimator` that we created earlier,
    as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MyTransitionDelegate` 子类内部，我们重写 `PresentingController` 方法并返回我们之前创建的 `MyTransitionAnimator`
    实例，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `IsPresenting` property of `MyTransitionAnimator` is used as a flag so
    the animator will know if the transition is for presenting a controller or dismissing
    it. We set it to `false` inside the `GetAnimationControllerForDismissedController`
    method from which we return the same `MyTransitionAnimator` instance, using the
    following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyTransitionAnimator` 的 `IsPresenting` 属性用作标志，以便动画器知道过渡是为了显示控制器还是取消显示。我们在
    `GetAnimationControllerForDismissedController` 方法中将它设置为 `false`，并返回相同的 `MyTransitionAnimator`
    实例，如下面的代码所示：'
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is clear that one method will be called when the controller is to be presented
    and the other is to be dismissed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，当控制器要被显示时，将调用一个方法，而当控制器要被取消显示时，将调用另一个方法。
- en: 'Finally, to enable everything, we set the `ModalPresentationStyle` property
    to `UIModalPresentationStyle.Custom`, and a new instance of `MyTransitioningDelegate`
    to the `TransitioningDelegate` property of the controller that will be presented,
    using the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了启用一切，我们将 `ModalPresentationStyle` 属性设置为 `UIModalPresentationStyle.Custom`，并将一个新的
    `MyTransitioningDelegate` 实例设置到将要显示的控制器 `TransitioningDelegate` 属性中，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Custom transitions are not limited to modal controllers. We can use custom transitions
    for pushing controllers into the navigation stack of a navigation controller or
    completely create our own navigation stack.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义过渡不仅限于模态控制器。我们可以使用自定义过渡将控制器推入导航控制器的导航堆栈，或者完全创建我们自己的导航堆栈。
- en: Transitioning between child controllers
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在子控制器之间切换
- en: The `UIViewController` class contains the `Transition` method that allows us
    to transition from one child controller to another, inside the parent controller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewController` 类包含 `Transition` 方法，允许我们在父控制器内部从一个子控制器切换到另一个子控制器。'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Child controllers are controllers whose views are part of the hierarchy of a
    third controller's view. This controller is the parent controller.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 子控制器是那些其视图是第三个控制器视图层次结构一部分的控制器。这个控制器是父控制器。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Animating views* recipe in [Chapter 11](ch11.html "Chapter 11. Graphics
    and Animation"), *Graphics and Animation*
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第11章的*动画视图*菜谱中，*图形和动画*，[第11章](ch11.html "第11章。图形和动画")
- en: Using physics in UI elements
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UI元素中使用物理
- en: In this recipe, we will use UIKit Dynamics to add the properties of physics
    to an image view. The image view will drop from its initial position to the bottom
    of the screen, simulating the effect of an object dropping on the floor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用UIKit Dynamics为图像视图添加物理属性。图像视图将从其初始位置下落到屏幕底部，模拟物体掉落在地面的效果。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ViewPhysicsApp`.
    Add `UIImageView` and two buttons to the controller. We will also need an image
    to show in the image view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`ViewPhysicsApp`。向控制器中添加`UIImageView`和两个按钮。我们还需要一个要在图像视图中显示的图像。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the following fields in the `ViewPhysicsAppViewController` class:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewPhysicsAppViewController`类中添加以下字段：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, in the `ViewDidLoad` method again, add the following button handlers:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次在`ViewDidLoad`方法中添加以下按钮处理程序：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compile and run the app on the simulator. Tap the **Drop!** button and watch
    the image view drop to the bottom of the screen. Tap the **Reset** button to reset
    it back to its original position. The following screenshot shows the app in its
    initial state and after the **Drop!** button is tapped:![How to do it...](img/8924OT_15_05.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击**Drop!**按钮，观察图像视图下落到屏幕底部。点击**Reset**按钮将其重置到原始位置。以下截图显示了应用程序的初始状态和点击**Drop!**按钮后的状态：![如何操作...](img/8924OT_15_05.jpg)
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: UIKit Dynamics offers a variety of objects that allow us to add the properties
    of physics to UIKit objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: UIKit Dynamics提供了一系列对象，允许我们向UIKit对象添加物理属性。
- en: 'The first thing we need to do is to initialize a `UIDynamicAnimator` object.
    This class provides the context in which all the physics animations will take
    place. We pass the controller''s view, which automatically makes it our 2D "physics
    world," using the following line of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是初始化一个`UIDynamicAnimator`对象。这个类提供了所有物理动画将发生的上下文。我们传递控制器的视图，这会自动使其成为我们的2D“物理世界”，如下面的代码行所示：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After we have created the dynamic animator, we need to add some behavior to
    it. Inside the `btnDrop` handler, we first make sure the image view will be affected
    by gravity by creating a `UIGravityBehavior` instance, as shown in the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了动态动画器之后，我们需要向其中添加一些行为。在`btnDrop`处理程序内部，我们首先确保图像视图会受到重力的影响，通过创建一个`UIGravityBehavior`实例，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we leave it as it is, the image view will just drop below the bottom boundary
    of the screen. So, we also need a collision behavior, which we can add using the
    following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持原样，图像视图将直接下落到屏幕底部边界以下。因此，我们还需要一个碰撞行为，我们可以使用以下代码添加它：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the collision also needs a boundary to collide with, or it will have
    the same effect if it was not there. In this case, we use the boundary of our
    animator object, as indicated in the preceding highlighted code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，碰撞也需要一个与之碰撞的边界，否则如果没有边界，它将产生相同的效果。在这种情况下，我们使用动画器对象的边界，如前面突出显示的代码所示。
- en: 'Now that we have our behavior set up, we add them to our animator to put everything
    into motion, using the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了行为，我们将它们添加到我们的动画器中，使用以下代码来使一切动起来：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can also modify how the image view will bounce when it hits the ground.
    Try adding the following code below the `UICollisionBehavior` initialization line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以修改图像视图撞击地面时的弹跳效果。尝试在`UICollisionBehavior`初始化行下方添加以下代码：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Of course, don''t forget to add the new behavior to the animator, as shown
    in the following line of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，别忘了将新的行为添加到动画器中，如下面的代码行所示：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you run the app and tap the **Drop!** button, the image will bounce more
    when it hits the ground!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序并点击**Drop!**按钮，图像在撞击地面时会弹跳得更高！
- en: UIKit Dynamics usage
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIKit Dynamics使用
- en: UIKit Dynamics was designed to provide simple 2D physics to `UIView` objects
    or to every object that implements the Objective-C `UIDynamicItem` protocol (`IUIDynamicItem`
    interface in C#). It was not designed to develop games with `UIView` objects.
    For this purpose, we have the **SpriteKit framework**, which is available through
    the `MonoTouch.SpriteKit` namespace. This is outside the scope of this book.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: UIKit Dynamics被设计用来为`UIView`对象或实现Objective-C `UIDynamicItem`协议（在C#中为`IUIDynamicItem`接口）的每个对象提供简单的2D物理。它不是用来用`UIView`对象开发游戏的。为此，我们有**SpriteKit框架**，它可以通过`MonoTouch.SpriteKit`命名空间访问。这超出了本书的范围。
- en: Implementing the text-to-speech feature
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现文本到语音功能
- en: In this recipe, we will learn to work with `AVSpeechSynthesizer`, the class
    that provides the **Text-To-Speech** (**TTS**) functionality for many different
    languages.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用`AVSpeechSynthesizer`类，该类为许多不同的语言提供了文本到语音（TTS）功能。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `SpeechApp`.
    Add a `UITextField` and a button to the controller.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，命名为`SpeechApp`。将一个`UITextField`和一个按钮添加到控制器中。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the `MonoTouch.AVFoundation` namespace in the `SpeechAppViewController.cs`
    file, using the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SpeechAppViewController.cs`文件中添加`MonoTouch.AVFoundation`命名空间，使用以下代码：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compile and run the app on the simulator. Type some text in English in the text
    field and tap the **Speak** button. Listen while your app speaks!
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在文本字段中输入一些英文文本，然后点击**说话**按钮。当你的应用程序说话时，请听一下！
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `AVSpeechSynthesizer` class was introduced with iOS 7\. It provides very
    simple and practical TTS functionality.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVSpeechSynthesizer`类是在iOS 7中引入的。它提供了非常简单实用的文本到语音（TTS）功能。'
- en: 'After initializing an instance of the class, we create an `AVSpeechUtterance`
    object, passing it to the text we want it to process, as shown in the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化类的实例之后，我们创建一个`AVSpeechUtterance`对象，将其传递给要处理的文本，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then set the rate of the speech and assign a voice to the utterance, using
    the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置语音的速率并使用以下代码将一个语音分配给语音：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The rate adjusts the speed at which the text will be spoken. You can test various
    speeds to suit your needs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 速率调整文本将被说话的速度。你可以测试各种速度以满足你的需求。
- en: The voice is an instance of `AVSpeechSynthesisVoice`. To initialize it, we call
    the `FromLanguage` static method, passing the BCP-47 language code. Unfortunately,
    there is only one type of voice for each available language, and we have no control
    over it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 语音是一个`AVSpeechSynthesisVoice`的实例。要初始化它，我们调用`FromLanguage`静态方法，传递BCP-47语言代码。不幸的是，每种可用语言都只有一种语音类型，我们无法控制它。
- en: 'Finally, to start the speech, we call the `SpeakUtterance` method to the synthesizer,
    passing the utterance object to it using the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了开始语音，我们调用合成器的`SpeakUtterance`方法，并使用以下代码将语音对象传递给它：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can call the `SpeakUtterance` method multiple subsequent times, passing a
    different utterance object each time. The speech synthesizer will queue each utterance
    and play it in sequence.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以多次调用`SpeakUtterance`方法，每次传递一个不同的语音对象。语音合成器将排队每个语音并按顺序播放。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We can enumerate the available language codes that the speech synthesizer supports
    by enumerating the return value of the `AVSpeechSynthesisVoice.GetSpeechVoices()`
    method, as shown in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过枚举`AVSpeechSynthesisVoice.GetSpeechVoices()`方法的返回值来枚举语音合成器支持的可用语言代码，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Adjusting the utterance
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整语音
- en: 'We can make more adjustments to how the speech will be performed through the
    following properties of the `AVSpeechUtterance` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下`AVSpeechUtterance`类的属性来进一步调整语音的执行方式：
- en: '`PitchMultiplier`: This is the pitch of the utterance. It is a float whose
    values are in the range of `0.5` and `2`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PitchMultiplier`：这是语音的音调。它是一个浮点数，其值在`0.5`和`2`之间。'
- en: '`PostUtteranceDelay`, `PreUtteranceDelay`: This is the amount of time to wait
    after (post) and/or before (pre) each utterance is spoken, in seconds.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostUtteranceDelay`，`PreUtteranceDelay`：这是在每个语音被说出之后（post）和/或之前（pre）等待的时间量，以秒为单位。'
- en: '`Volume`: This is the audio volume of the speech. It is in the range of `0.0`
    (silent) to `1.0` (loudest).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Volume`：这是语音的音频音量。它在`0.0`（静音）到`1.0`（最响）之间。'
