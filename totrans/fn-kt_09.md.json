["```kt\n    $ git clone https://github.com/ReactiveX/RxKotlin.git\n    $ cd RxKotlin/\n    $ ./gradlew build\n\n```", "```kt\nfun main(args: Array<String>) { \n    var list:List<Any> = listOf(1, \"Two\", 3, \"Four\", \"Five\", 5.5f) // 1 \n    var iterator = list.iterator() // 2 \n    while (iterator.hasNext()) { // 3 \n        println(iterator.next()) // Prints each element 4 \n    } \n} \n```", "```kt\nfun main(args: Array<String>) { \n    var list = listOf(1, \"Two\", 3, \"Four\", \"Five\", 5.5f) // 1 \n    var observable = list.toObservable(); \n\n    observable.subscribeBy(  // named arguments for lambda Subscribers \n            onNext = { println(it) }, \n            onError =  { it.printStackTrace() }, \n            onComplete = { println(\"Done!\") } \n    ) \n} \n```", "```kt\nfun main(args: Array<String>) { \n\n    val observer = object :Observer<Any>{//1 \n    override fun onComplete() {//2 \n        println(\"All Completed\") \n    } \n\n        override fun onNext(item: Any) {//3 \n            println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) {//4 \n            println(\"Error Occured $e\") \n        } \n\n        override fun onSubscribe(d: Disposable) {//5 \n            println(\"Subscribed to $d\") \n        } \n    } \n\n    val observable = listOf(1, \"Two\", 3, \"Four\", \"Five\", 5.5f).toObservable() //6 \n\n    observable.subscribe(observer)//7 \n\n    val observableOnList = Observable.just(listOf(\"One\", 2, \"Three\", \"Four\", 4.5, \"Five\", 6.0f), \n            listOf(\"List with 1 Item\"), \n            listOf(1,2,3))//8 \n\n    observableOnList.subscribe(observer)//9 \n} \n```", "```kt\nfun main(args: Array<String>) { \n\n    val observer: Observer<String> = object : Observer<String> { \n        override fun onComplete() { \n            println(\"All Completed\") \n        } \n\n        override fun onNext(item: String) { \n            println(\"Next $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occured => ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"New Subscription \") \n        } \n    }//Create Observer \n\n    val observable:Observable<String> = Observable.create<String> {//1 \n        it.onNext(\"Emitted 1\") \n        it.onNext(\"Emitted 2\") \n        it.onNext(\"Emitted 3\") \n        it.onNext(\"Emitted 4\") \n        it.onComplete() \n    } \n\n    observable.subscribe(observer) \n\n    val observable2:Observable<String> = Observable.create<String> {//2 \n        it.onNext(\"Emitted 1\") \n        it.onNext(\"Emitted 2\") \n        it.onError(Exception(\"My Exception\")) \n    } \n\n    observable2.subscribe(observer) \n} \n```", "```kt\nfun main(args: Array<String>) { \n\n    val observer: Observer<String> = object : Observer<String> { \n        override fun onComplete() { \n            println(\"Completed\") \n        } \n\n        override fun onNext(item: String) { \n            println(\"Received-> $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occured => ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"Subscription\") \n        } \n    }//Create Observer \n\n    val list = listOf(\"Str 1\",\"Str 2\",\"Str 3\",\"Str 4\") \n    val observableFromIterable: Observable<String> = Observable.fromIterable(list)//1 \n    observableFromIterable.subscribe(observer) \n\n    val callable = object : Callable<String> { \n        override fun call(): String { \n            return \"I'm From Callable\" \n        } \n\n    } \n    val observableFromCallable:Observable<String> = Observable.fromCallable(callable)//2 \n    observableFromCallable.subscribe(observer) \n\n    val future:Future<String> = object : Future<String> { \n        val retStr = \"I'm from Future\" \n\n        override fun get() = retStr \n\n        override fun get(timeout: Long, unit: TimeUnit?)  = retStr \n\n        override fun isDone(): Boolean = true \n\n        override fun isCancelled(): Boolean = false \n\n        override fun cancel(mayInterruptIfRunning: Boolean): Boolean = false \n\n    } \n    val observableFromFuture:Observable<String> = Observable.fromFuture(future)//3 \n    observableFromFuture.subscribe(observer) \n} \n```", "```kt\nfun main(args: Array<String>) { \n    val observer: Observer<String> = object : Observer<String> { \n        override fun onComplete() { \n            println(\"Completed\") \n        } \n\n        override fun onNext(item: String) { \n            println(\"Received-> $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occured => ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"Subscription\") \n        } \n    }//Create Observer \n    val list:List<String> = listOf(\"Str 1\",\"Str 2\",\"Str 3\",\"Str 4\") \n\n    val observable: Observable<String> = list.toObservable() \n\n    observable.subscribe(observer) \n\n} \n```", "```kt\nfun <T : Any> Iterator<T>.toObservable(): Observable<T> = toIterable().toObservable() \nfun <T : Any> Iterable<T>.toObservable(): Observable<T> = Observable.fromIterable(this) \nfun <T : Any> Sequence<T>.toObservable(): Observable<T> = asIterable().toObservable() \n\nfun <T : Any> Iterable<Observable<out T>>.merge(): Observable<T> = Observable.merge(this.toObservable()) \nfun <T : Any> Iterable<Observable<out T>>.mergeDelayError(): Observable<T> = Observable.mergeDelayError(this.toObservable()) \n```", "```kt\nfun main(args: Array<String>) { \n    val observable = Observable.range(1,5)//1 \n\n    observable.subscribe({//2 \n        //onNext method \n        println(\"Next-> $it\") \n    },{ \n        //onError Method \n        println(\"Error=> ${it.message}\") \n    },{ \n        //onComplete Method \n        println(\"Done\") \n    }) \n\n    val observer: Observer<Int> = object : Observer<Int> {//3 \n    override fun onComplete() { \n        println(\"All Completed\") \n    } \n\n        override fun onNext(item: Int) { \n            println(\"Next-> $item\") \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error Occurred=> ${e.message}\") \n        } \n\n        override fun onSubscribe(d: Disposable) { \n            println(\"New Subscription \") \n        } \n    } \n\n    observable.subscribe(observer) \n} \n```", "```kt\nfun main(args: Array<String>) { \n\n    val observale = Observable.interval(100, TimeUnit.MILLISECONDS)//1 \n    val observer = object : Observer<Long> { \n\n        lateinit var disposable: Disposable//2 \n\n        override fun onSubscribe(d: Disposable) { \n            disposable = d//3 \n        } \n\n        override fun onNext(item: Long) { \n            println(\"Received $item\") \n            if (item >= 10 && !disposable.isDisposed) {//4 \n                disposable.dispose()//5 \n                println(\"Disposed\") \n            } \n        } \n\n        override fun onError(e: Throwable) { \n            println(\"Error ${e.message}\") \n        } \n\n        override fun onComplete() { \n            println(\"Complete\") \n        } \n\n    } \n    runBlocking { \n        observale.subscribe(observer) \n        delay(1500)//6 \n    } \n} \n```", "```kt\ninterface Disposable { \n  /** \n * Dispose the resource, the operation should be idempotent. \n */ \n  fun dispose() \n  /** \n * Returns true if this resource has been disposed. \n * @return true if this resource has been disposed \n */ \n  val isDisposed:Boolean \n} \n```"]