<html><head></head><body>
        

                            
                    <h1 class="header-title">Alerts and Notifications</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Lights, Action, and Sound - getting the user's attention!</li>
<li>Creating a Toast with a custom layout</li>
<li>Displaying a message box with AlertDialog</li>
<li>Displaying a progress dialog</li>
<li>Lights, Action, and Sound Redux using Notifications</li>
<li>Creating a Media Player Notification</li>
<li>Making a Flashlight with a Heads-Up Notification</li>
<li>Notifications with Direct Reply</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Android provides many ways to notify your user, including both visual and non-visual methods. Keep in mind, notifications distract your user, so it's a good idea to be very judicious when using any notification. Users like to be in control of their device (it is theirs, after all), so give them the option to enable and disable notifications as they desire. Otherwise, your user might get annoyed and uninstall your app altogether.</p>
<p>We'll start by reviewing the following non-UI-based notification options:</p>
<ul>
<li>Flash LED</li>
<li>Vibrate phone</li>
<li>Play ringtone</li>
</ul>
<p>Then, we'll move on to visual notifications, including the following:</p>
<ul>
<li>Toasts</li>
<li>AlertDialog</li>
<li>ProgressDialog</li>
<li>Status Bar Notifications</li>
</ul>
<p>The recipes that follow will show you how to implement each of these notifications in your own applications. It's worth reading the following link to understand best practices when using notifications:</p>
<p>Refer to Android Notification Design Guidelines at <a href="http://developer.android.com/design/patterns/notifications.html">http://developer.android.com/design/patterns/notifications.html</a>.<a href="http://developer.android.com/design/patterns/notifications.html"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lights, Action, and Sound – getting the user's attention!</h1>
                
            
            
                
<p>Most of the recipes in this chapter use the <kbd>Notification</kbd> object to alert your users, so this recipe will show an alternative approach for when you don't actually need a notification.</p>
<p>As the recipe title implies, we're going to use lights, action, and sound:</p>
<ul>
<li><strong>Lights</strong>: Normally, you'd use the LED device, but that is only available through the <kbd>Notification</kbd> object, which we'll demonstrate later in the chapter. Instead, we'll take this opportunity to use <kbd>setTorchMode()</kbd> (added in API 23-Android 6.0), to use the camera flash as a flashlight. (Note: as you'll see in the code, this feature will only work on an Android 6.0 device with a camera flash.)</li>
<li><strong>Action</strong>: We'll vibrate the phone.</li>
<li><strong>Sound</strong>: We'll use the <kbd>RingtoneManager</kbd> to play the default notification sound.</li>
</ul>
<p>As you'll see, the code for each of these is quite simple.</p>
<p>As demonstrated in the following <em>Lights, Action, and Sound Redux using Notifications</em> recipe, all three options, LED, vibrate, and sounds, are available through the <kbd>Notification</kbd> object. The <kbd>Notification</kbd> object would certainly be the most appropriate method to provide alerts and reminders when the user is not actively engaged in your app. But for those times when you want to provide feedback while they are using your app, these options are available. The vibrate option is a good example; if you want to provide haptic feedback to a button press (common with keyboard apps), call the vibrate method directly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>LightsActionSound</kbd>. When prompted for the API level, we need API 21 or above to compile the project. Select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll use three buttons to initiate each action, so start by opening <kbd>activity_main.xml</kbd> and perform the following steps:</p>
<ol>
<li>Replace the existing layout XML with the following layout:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;<br/>&amp;lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&amp;gt;<br/>    &amp;lt;ToggleButton<br/>        android:id="@+id/buttonLights"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Lights"<br/>        android:layout_centerHorizontal="true"<br/>        android:layout_above="@+id/buttonAction"<br/>        android:onClick="clickLights" /&amp;gt;<br/>    &amp;lt;Button<br/>        android:id="@+id/buttonAction"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Action"<br/>        android:layout_centerVertical="true"<br/>        android:layout_centerHorizontal="true"<br/>        android:onClick="clickVibrate"/&amp;gt;<br/>    &amp;lt;Button<br/>        android:id="@+id/buttonSound"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Sound"<br/>        android:layout_below="@+id/buttonAction"<br/>        android:layout_centerHorizontal="true"<br/>        android:onClick="clickSound"/&amp;gt;<br/>&amp;lt;/RelativeLayout&amp;gt;</pre>
<ol start="2">
<li>Add the following permission to the Android Manifest:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;uses-permission android:name="android.permission.VIBRATE" /&amp;gt;</pre>
<ol start="3">
<li>Open <kbd>ActivityMain.java</kbd> and add the following global variables:</li>
</ol>
<pre style="padding-left: 60px">private CameraManager mCameraManager;<br/>private String mCameraId=null;<br/>private ToggleButton mButtonLights;</pre>
<ol start="4">
<li>Add the following method to get the Camera ID:</li>
</ol>
<pre style="padding-left: 60px">private String getCameraId() {<br/>    try {<br/>        String[] ids = mCameraManager.getCameraIdList();<br/>        for (String id : ids) {<br/>            CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);<br/>            Boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);<br/>            Integer facingDirection = c.get(CameraCharacteristics.LENS_FACING);<br/>            if (flashAvailable != null <br/>                    &amp;&amp; flashAvailable <br/>                    &amp;&amp; facingDirection != null <br/>                    &amp;&amp; facingDirection == CameraCharacteristics.LENS_FACING_BACK) {<br/>                return id;<br/>            }<br/>        }<br/>    } catch (CameraAccessException e) {<br/>        e.printStackTrace();<br/>    }<br/>    return null;<br/>}</pre>
<ol start="5">
<li>Add the following code to the <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">mButtonLights = findViewById(R.id.buttonLights);<br/>if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M) {<br/>    mCameraManager = (CameraManager) this.getSystemService(Context.CAMERA_SERVICE);<br/>    mCameraId = getCameraId();<br/>    if (mCameraId==null) { mButtonLights.setEnabled(false);<br/>    } else {<br/>        mButtonLights.setEnabled(true);<br/>    }<br/>} else {<br/>    mButtonLights.setEnabled(false);<br/>}</pre>
<ol start="6">
<li>Now, add the code to handle each of the button clicks:</li>
</ol>
<pre style="padding-left: 60px">public void clickLights(View view) {<br/>    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M) {<br/>        try {<br/>            mCameraManager.setTorchMode(mCameraId, mButtonLights.isChecked());<br/>        } catch (CameraAccessException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}<br/>        <br/>public void clickVibrate(View view) {<br/>    ((Vibrator) getSystemService(VIBRATOR_SERVICE)).vibrate(1000);<br/>}<br/><br/>public void clickSound(View view) {<br/>    Uri notificationSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);<br/>    Ringtone ringtone = RingtoneManager.getRingtone(getApplicationContext(), <br/>            notificationSoundUri);<br/>    ringtone.play();<br/>}</pre>
<ol start="7">
<li>You're ready to run the application on a physical device. The code presented here will need Android 6.0 (or higher) to use the flashlight option.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As you can see from the previous paragraphs, most of the code is related to finding and opening the camera to use the flash feature. <kbd>setTorchMode()</kbd> was introduced in API 23, which is why we have the API version check:</p>
<pre>if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M){} </pre>
<p>This app demonstrates using the new <kbd>camera2</kbd> libraries, which were introduced in Lollipop (API 21). Both the <kbd>vibrate</kbd> and <kbd>ringtone</kbd> methods have been available since API 1.</p>
<p>The <kbd>getCameraId()</kbd> method is where we check for the camera. We want an outward-facing camera with a flash. If one is found, the ID is returned; otherwise, it is null. If the camera id is null, we disable the button.</p>
<p>To play the sound, we use the <kbd>Ringtone</kbd> object from the <kbd>RingtoneManager</kbd>. Besides being relatively easy to implement, another benefit to this method is that we can use the default notification sound, which we get with this code:</p>
<pre>Uri notificationSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION); </pre>
<p>This way, if the user changes their preferred notification sound, we use it automatically.</p>
<p>Last is the call to vibrate the phone. This was the simplest code to use, but it does require permission, which we added to the Manifest:</p>
<pre>&amp;lt;uses-permission android:name="android.permission.VIBRATE" /&amp;gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In a production-level application, you wouldn't want to simply disable the button if you didn't have to. In this case, there are other means to use the camera flash as a flashlight. For additional examples on using the camera, see <a href="1949a5cc-7bc6-4348-8ae1-896b238c3090.xhtml">Chapter 12</a>, <em>Multimedia</em>, where we'll see <kbd>getCameraId()</kbd> used again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to the <em>Lights, Action, and Sound Redux using Notifications</em> recipe later in this chapter to see the equivalent features using the <kbd>Notification</kbd> object</li>
<li>Refer to <a href="1949a5cc-7bc6-4348-8ae1-896b238c3090.xhtml">Chapter 12</a>, <em>Multimedia</em>, for examples using the new camera API and other sound options</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Toast with a custom layout</h1>
                
            
            
                
<p>We've used Toasts quite a bit already in previous chapters as they provide a quick and easy way to display information, both for user notification and for ourselves when debugging.</p>
<p>The previous examples have all used the simple one-line syntax, but Toasts aren't limited to this. Toasts, like most components in Android, can be customized, as we'll demonstrate in this recipe.</p>
<p>Android Studio offers a shortcut for making a simple Toast statement. As you start to type the Toast command, you'll see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/44c7d353-5999-4177-b8c5-b866050de1ba.png" style="width:43.92em;height:7.58em;"/></p>
<p>Press <em>Enter</em> to auto-complete. Then, press <em>Ctrl</em> + spacebar and you'll see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c01f19dc-45f8-49b0-9d3e-88fec8c5996d.png" style="width:71.50em;height:7.00em;"/></p>
<p>When you press Enter again, it will auto-complete with the following:</p>
<pre>Toast.makeText(this, "", Toast.LENGTH_SHORT).show();</pre>
<p>In this recipe, we'll use the Toast Builder to change the default layout, and gravity to create a custom Toast, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bb3c59dd-5a32-45f0-a14f-ef9f48f8e85b.png" style="width:22.00em;height:43.92em;"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>CustomToast</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We're going to change the shape of the Toast to a square and create a custom layout to display an image and text message. Start by opening <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing <kbd>&amp;lt;TextView&amp;gt;</kbd> element with a <kbd>&amp;lt;Button&amp;gt;</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;Button<br/>    android:id="@+id/button"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Show Toast"<br/>    android:onClick="showToast"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&amp;gt;</pre>
<ol start="2">
<li>Create a new drawable resource file in the <kbd>res/drawable</kbd> folder named <kbd>border_square.xml</kbd> using the following code:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;<br/>&amp;lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&amp;gt;<br/>    &amp;lt;item<br/>        android:left="4px"<br/>        android:top="4px"<br/>        android:right="4px"<br/>        android:bottom="4px"&amp;gt;<br/>        &amp;lt;shape android:shape="rectangle" &amp;gt;<br/>            &amp;lt;solid android:color="@android:color/black" /&amp;gt;<br/>            &amp;lt;stroke android:width="5px" android:color="@android:color/white"/&amp;gt;<br/>        &amp;lt;/shape&amp;gt;<br/>    &amp;lt;/item&amp;gt;<br/>&amp;lt;/layer-list&amp;gt;</pre>
<ol start="3">
<li>Create a new layout resource file in the <kbd>res/layout</kbd> folder named <kbd>toast_custom.xml</kbd> with the following code:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;<br/>&amp;lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:id="@+id/toast_layout_root"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:orientation="horizontal"<br/>    android:background="@drawable/border_square"&amp;gt;<br/>    &amp;lt;ImageView<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:id="@+id/imageView"<br/>        android:layout_weight="1"<br/>        android:src="img/ic_launcher" /&amp;gt;<br/>    &amp;lt;TextView<br/>        android:id="@android:id/message"<br/>        android:layout_width="0dp"<br/>        android:layout_height="match_parent"<br/>        android:layout_weight="1"<br/>        android:textColor="@android:color/white"<br/>        android:padding="10dp" /&amp;gt;<br/>&amp;lt;/LinearLayout&amp;gt;</pre>
<ol start="4">
<li>Now, open <kbd>ActivityMain.java</kbd> and add the following method:</li>
</ol>
<pre style="padding-left: 60px">public void showToast(View view) {<br/>    LayoutInflater inflater = (LayoutInflater)this<br/>            .getSystemService(Context.LAYOUT_INFLATER_SERVICE);<br/>    View layout = inflater.inflate(R.layout.toast_custom, null);<br/>    ((TextView)layout.findViewById(android.R.id.message)).setText("Custom Toast");<br/>    Toast toast = new Toast(this);<br/>    toast.setGravity(Gravity.CENTER, 0, 0);<br/>    toast.setDuration(Toast.LENGTH_LONG);<br/>    toast.setView(layout);<br/>    toast.show();<br/>}</pre>
<ol start="5">
<li>Run the program on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This custom Toast changes the default gravity and shape, and adds an image just to show that "it can be done."</p>
<p>The first step is to create a new Toast layout, which we do by inflating our <kbd>custom_toast</kbd> layout. Once we have the new layout, we need to get the <kbd>TextView</kbd> so we can set our message, which we do with the standard <kbd>setText()</kbd> method. With this done, we create a Toast object and set the individual properties. We set the Toast gravity with the <kbd>setGravity()</kbd> method. The gravity determines where on the screen our Toast will display. We specify our custom layout with the <kbd>setView()</kbd> method call. And just like in the single-line variation, we display the Toast with the <kbd>show()</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>For a Kotlin version, see the <em>Creating a Toast in Kotlin</em> recipe in <a href="939d2c0b-84d8-4093-a827-641186032dee.xhtml">Chapter 16</a>, <em>Getting Started with Kotlin</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying a message box with AlertDialog</h1>
                
            
            
                
<p>In <a href="271b832c-648f-4a10-967e-aac99272e9a9.xhtml">Chapter 4</a>, <em>Menus</em>, we created a theme to make an Activity look like a dialog. In this recipe, we'll demonstrate how to create a dialog using the <kbd>AlertDialog</kbd> class. <kbd>AlertDialog</kbd> offers a Title, up to three buttons, and a list or custom layout area, as shown in the following example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8b2eb26c-250a-4baf-830a-12322aad6f53.png" style="width:19.67em;height:9.42em;"/></p>
<p>The button arrangement can vary depending on the OS version.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>AlertDialog</kbd>. Use the default Phone &amp; Tablet options and select the Empty Activity option when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To demonstrate, we'll create a Confirm Delete dialog to prompt the user for confirmation after pressing the Delete button. Start by opening the <kbd>main_activity.xml</kbd> layout file and follow these steps:</p>
<ol>
<li>Add the following <kbd>&amp;lt;Button&amp;gt;</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;Button<br/>    android:id="@+id/buttonDelete"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Delete"<br/>    android:onClick="confirmDelete"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&amp;gt;</pre>
<ol start="2">
<li>Add the <kbd>confirmDelete()</kbd> method to <kbd>ActivityMain.java</kbd>; this is called by the button:</li>
</ol>
<pre style="padding-left: 60px">public void confirmDelete(View view) {<br/>    AlertDialog.Builder builder = new AlertDialog.Builder(this);<br/>    builder.setTitle("Delete")<br/>            .setMessage("Are you sure you?")<br/>            .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {<br/>                public void onClick(DialogInterface dialog, int id) {<br/>                    Toast.makeText(MainActivity.this, "OK Pressed", <br/>                            Toast.LENGTH_SHORT).show();<br/>                }<br/>            })<br/>            .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {<br/>                public void onClick(DialogInterface dialog, int id) {<br/>                    Toast.makeText(MainActivity.this, "Cancel Pressed", <br/>                            Toast.LENGTH_SHORT).show();<br/>                }<br/>            });<br/>    builder.create().show();<br/>}</pre>
<ol start="3">
<li>Run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This dialog is meant to serve as a simple confirmation dialog, such as confirming a delete action. Basically, just create an <kbd>AlertDialog.Builder</kbd> object and set the properties as needed. We use a Toast message to indicate the user selection. We don't even have to close the dialog; it's taken care of by the base class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>As shown in the recipe introduction screenshot, the <kbd>AlertDialog</kbd> also has a third button, called the Neutral button, which can be set using the following method:</p>
<pre>builder.setNeutralButton() </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Add an icon</h1>
                
            
            
                
<p>To add an icon to the dialog, use the <kbd>setIcon()</kbd> method. The following is an example:</p>
<pre>.setIcon(R.mipmap.ic_launcher) </pre>
<p>Introduced in Android 4.3, the mipmap folder is a drawable folder for storing bitmaps that should not be modified/converted during APK optimization. This is the recommended location for storing app icons so the launcher can have the best available image when displaying the app icon.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a list</h1>
                
            
            
                
<p>We can also create a list of items to select from with various list setting methods, including the following:</p>
<pre>.setItems() 
.setAdapter() 
.setSingleChoiceItems() 
.setMultiChoiceItems() </pre>
<p>As you can see, there are also methods for single-choice (using a radio button) and multi-choice lists (using a checkbox).</p>
<p>You can't use both the Message and the Lists, as <kbd>setMessage()</kbd> will take priority.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Custom layout</h1>
                
            
            
                
<p>Finally, we can also create a custom layout, and set it using the following:</p>
<pre>.setView() </pre>
<p>If you use a custom layout and replace the standard buttons, you are also responsible for closing the dialog. Use <kbd>hide()</kbd> if you plan to reuse the dialog and <kbd>dismiss()</kbd> when finished to release the resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying a progress dialog</h1>
                
            
            
                
<p><kbd>ProgressDialog</kbd> has been available since API 1 and is widely used. As we'll demonstrate in this recipe, it's simple to use, but keep this message in mind (posted on the Android Dialog Guidelines site at <a href="http://developer.android.com/guide/topics/ui/dialogs.html">http://developer.android.com/guide/topics/ui/dialogs.html</a>):</p>
<p>Android includes another dialog class called ProgressDialog that shows a dialog with a progress bar. However, if you need to indicate loading or indeterminate progress, you should instead follow the design guidelines for Progress &amp; Activity and use a ProgressBar in your layout.</p>
<p>This message doesn't mean <kbd>ProgressDialog</kbd> is deprecated or is bad code. It's suggesting that the use of <kbd>ProgressDialog</kbd> should be avoided since the user cannot interact with your app while the dialog is displayed. If possible, use a layout that includes a progress bar (so other views are still usable), instead of stopping everything with <kbd>ProgressDialog</kbd>.</p>
<p>The Google Play app provides a good example. When adding items to download, Google Play shows a progress bar, but it's not a dialog so the user can continue interacting with the app, even adding more items to download. If possible, use that approach instead.</p>
<p>There are times when you may not have that luxury; for example, after placing an order, the user is going to expect an order confirmation. (Even with Google Play, you still see a confirmation dialog when actually purchasing apps.) So, remember to avoid the progress dialog if possible. But, for those times when something must complete before continuing, this recipe provides an example of how to use <kbd>ProgressDialog</kbd>. The following screenshot shows <kbd>ProgressDialog</kbd> from the recipe:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/640a6b6f-9297-470f-8b50-d305d54b35c4.png" style="width:19.58em;height:39.17em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ProgressDialog</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Since this is just a demonstration of using the ProgressDialog, we will create a button to show the dialog. To simulate waiting for a server response, we will use a delayed message to dismiss the dialog. To start, open <kbd>activity_main.xml</kbd> and follow these steps:</li>
<li>Replace <kbd>&amp;lt;TextView&amp;gt;</kbd> with the following <kbd>&amp;lt;Button&amp;gt;</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;Button<br/>    android:id="@+id/button"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Show Dialog"<br/>    android:onClick="startProgress"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&amp;gt;</pre>
<ol start="3">
<li>Open <kbd>MainActivity.java</kbd> and add the following two global variables:</li>
</ol>
<pre style="padding-left: 60px">private ProgressDialog mDialog; final int THIRTY_SECONDS=30*1000; </pre>
<ol start="4">
<li>Add the <kbd>showDialog()</kbd> method referenced by the button click:</li>
</ol>
<pre style="padding-left: 60px">public void startProgress(View view) {<br/>    mDialog = new ProgressDialog(this);<br/>    mDialog.setMessage("Doing something...");<br/>    mDialog.setCancelable(false);<br/>    mDialog.show();<br/>    new Handler().postDelayed(new Runnable() {<br/>        public void run() {<br/>            mDialog.dismiss();<br/>        }<br/>    }, THIRTY_SECONDS);<br/>}</pre>
<ol start="5">
<li>Run the program on a device or emulator. When you press the Show Dialog button, you'll see the dialog shown in the screen from the Introduction.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We use the <kbd>ProgressDialog</kbd> class to display our dialog. The options should be self-explanatory, but this setting is worth nothing:</p>
<pre>mDialog.setCancelable(false); </pre>
<p>Normally, a dialog can be canceled using the back key, but when this is set to false, the user is stuck on the dialog until it is hidden/dismissed from the code. To simulate a delayed response from a server, we use a <kbd>Handler</kbd> and the <kbd>postDelayed()</kbd> method. After the specified milliseconds (30,000 in this case, to represent 30 seconds), the <kbd>run()</kbd> method will be called, which will dismiss our dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We used the default <kbd>ProgressDialog</kbd> settings for this recipe, which creates an indeterminate dialog indicator, for example, the continuously spinning circle. If you can measure the task at hand, such as loading files, you can use a determinate style instead.<br/>
Add and run this line of code:</p>
<pre>mDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); </pre>
<p>With <kbd>STYLE_HORIZONTAL</kbd>, you'll see the percentage dialog shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/aa026cdc-5be9-4900-ba94-2fb059044c13.png" style="width:20.83em;height:8.58em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lights, Action, and Sound Redux using Notifications</h1>
                
            
            
                
<p>You're probably already familiar with Notifications as they've become a prominent feature (even making their way to the desktop environment) and for good reason. They provide an excellent way to raise information for your user. They provide the least intrusive option of all the alerts and notification options available.</p>
<p>As we saw in the first recipe, <em>Lights, Action, and Sound - getting the user's attention!</em> Lights, vibration, and sound are all very useful means of getting the user's attention. That's why the <kbd>Notification</kbd> object includes support for all three options, as we'll demonstrate in this recipe. Given this ability to get your user's attention, care should still be taken not to abuse your user. Otherwise, they'll likely uninstall your app. It's generally a good idea to give your users the option to enable/disable notifications and even how to present the notification: with sound or without, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>LightsActionSoundRedux</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll need permission to use the vibrate option, so start by opening the Android Manifest file, and follow the remaining steps:</p>
<ol>
<li>Add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;uses-permission android:name="android.permission.VIBRATE"/&amp;gt;</pre>
<ol start="2">
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>&amp;lt;TextView&amp;gt;</kbd> with the following button:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;Button<br/>    android:id="@+id/buttonSound"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Lights, Action, and Sound"<br/>    android:onClick="clickLightsActionSound"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&amp;gt;</pre>
<ol start="3">
<li>Now, open <kbd>MainActivity.java</kbd> and add the following declaration to the class: </li>
</ol>
<pre style="padding-left: 60px">final String CHANNEL_ID="notifications";</pre>
<ol start="4">
<li>Next, add the method to handle the button click:</li>
</ol>
<pre style="padding-left: 60px">public void clickLightsActionSound(View view) {<br/>    Uri notificationSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);<br/><br/>    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {<br/>        AudioAttributes audioAttributes = new AudioAttributes.Builder()<br/>                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)<br/>                .setUsage(AudioAttributes.USAGE_NOTIFICATION_RINGTONE)<br/>                .build();<br/>        NotificationChannel channel = new NotificationChannel(CHANNEL_ID, <br/>                "Notifications", NotificationManager.IMPORTANCE_HIGH);<br/>        channel.setDescription("All app notifications");<br/>        channel.setSound(notificationSoundUri,audioAttributes);<br/>        channel.setLightColor(Color.BLUE);<br/>        channel.enableLights(true);<br/>        channel.enableVibration(true);<br/>        NotificationManager notificationManager = getSystemService(NotificationManager.class);<br/>        notificationManager.createNotificationChannel(channel);<br/>    }<br/><br/>    NotificationCompat.Builder notificationBuilder = new<br/>            NotificationCompat.Builder(this,CHANNEL_ID)<br/>            .setSmallIcon(R.mipmap.ic_launcher)<br/>            .setContentTitle(getString(R.string.app_name))<br/>            .setContentText("Lights, Action &amp; Sound")<br/>            .setSound(notificationSoundUri)<br/>            .setLights(Color.BLUE, 500, 500)<br/>            .setVibrate(new long[]{250,500,250,500,250,500})<br/>            .setDefaults(Notification.DEFAULT_LIGHTS | Notification.DEFAULT_VIBRATE);<br/>    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);<br/>    notificationManager.notify(0, notificationBuilder.build());<br/>}</pre>
<ol start="5">
<li>Run the program on a physical device to experience all the notification effects.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We combined all three actions into a single notification, simply because we could. You don't have to use all three extra notification options or even any. Only the following are required:</p>
<pre>.setSmallIcon() 
.setContentText() </pre>
<p>If you don't set both the icon and text, the notification will not show.</p>
<p>We used <kbd>NotificationCompat</kbd> to build our notification. This comes from the support library and makes it easier to be backward-compatible with older OS versions. If we request a notification feature that is not available on the user's version of OS, it will simply be ignored.</p>
<p>These three lines of code produce our extra notification options:</p>
<pre>.setSound(notificationSoundUri) 
.setLights(Color.BLUE, 500, 500) 
.setVibrate(new long[]{250,500,250,500,250,500}); </pre>
<p>It's worth noting that we use the same sound URI with the notification as we did with the <kbd>RingtoneManager</kbd> from the earlier <em>Lights, Action, and Sound</em> recipe. The vibrate feature also required the same vibrate permission as the previous recipe, but notice the value we send is different. Instead of sending just a duration for the vibration, we are sending a vibrate pattern. The first value represents the <kbd>off</kbd> duration (in milliseconds); the next value represents the vibration <kbd>on</kbd> duration and repeats.</p>
<p>As you can see in the following line of code:</p>
<pre>if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O)</pre>
<p>If the app is running on Android 8 Oreo (API 26) or greater, there are two parts to creating a notification: the notification itself along with the notification channel (or "category" as the user will see in the settings). The notification "category" feature was added to Android 8 to make it easier for the user to manage the many notifications being displayed by apps. Prior to this feature being added, notifications were either on or off for an app. The user had no way to allow only certain notification types.</p>
<p>If the user is running on Android 8 or greater, we need to create the channel and channel characteristics. Keep in mind, once the channel is created, the properties cannot be changed. For example, if you don't have sound enabled when you first create the channel, changing it later will have no effect. (This applies across app restarts as well.)</p>
<p>On devices with LED notification, you won't see the LED notification while the screen is active.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>This recipe shows the basics of a notification, but like many features on Android, options have expanded with later OS releases. (Keep in mind the following Toasts can vary in appearance based on the OS version and manufacturer.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a button to the notification using addAction()</h1>
                
            
            
                
<p>There are several design considerations you should keep in mind when adding action buttons, as listed in the Notification Guidelines link in the chapter introduction. You can add a button (up to three) using the <kbd>addAction()</kbd> method on the notification builder. The following is an example of a notification with one action button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e246da9-4ff0-4da8-859a-e73f7d2d0106.png" style="width:24.42em;height:7.00em;"/></p>
<p>Here's the code to create this notification:</p>
<pre>NotificationCompat.Builder notificationBuilder = new<br/>        NotificationCompat.Builder(this, CHANNEL_ID)<br/>        .setSmallIcon(R.mipmap.ic_launcher)<br/>        .setContentTitle("LightsActionSoundRedux")<br/>        .setContentText("Lights, Action &amp; Sound");<br/>Intent activityIntent = new Intent(this, MainActivity.class);<br/>PendingIntent pendingIntent = PendingIntent.getActivity(<br/>        this,0,activityIntent,0);<br/>notificationBuilder.addAction(android.R.drawable.ic_dialog_email, "Email",<br/>        pendingIntent);</pre>
<p>An <kbd>Action</kbd> requires three parameters: the image, the text, and <kbd>PendingIntent</kbd>. The first two items are for the visual display, while the third item, <kbd>PendingIntent</kbd>, is called when the user presses the button.</p>
<p>The previous code creates a very simple <kbd>PendingIntent;</kbd> it just launches the app. This is probably the most common intent for notifications and is often used when the user presses the notification. To set the notification intent, use the following code:</p>
<pre>.setContentIntent(pendingIntent) </pre>
<p>A button action would probably require more information as it should take the user to the specific item in your app. You should also create an application back-stack for the best user experience.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Expanded notifications</h1>
                
            
            
                
<p>Expanded notifications were introduced in Android 4.1 (API 16) and are available by using the <kbd>setStyle()</kbd> method on the Notification Builder. If the user's OS does not support expanded notifications, the notification will appear as a normal notification.</p>
<p>The three expanded styles currently available in the <kbd>NotificationCompat</kbd> library include the following:</p>
<ul>
<li>InboxStyle: Large-format notifications that include a list of strings</li>
<li>BigPictureStyle: Large-format notification that includes a large image attachment</li>
<li>BigTextStyle: Large-format notifications that include a lot of text</li>
</ul>
<p>Here's an example of each notification style, and the code used to create the example:</p>
<ol>
<li class="mce-root"><kbd>InboxStyle</kbd>: Large-format notifications that include a list of strings</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7863ea24-8119-4393-bad7-0f81497304a8.png" style="width:30.67em;height:7.08em;"/></p>
<p class="mce-root"/>
<p style="padding-left: 60px">Here's the code for this style:</p>
<pre style="padding-left: 60px">NotificationCompat.Builder notificationBuilder =<br/>        new NotificationCompat.Builder(this, CHANNEL_ID)<br/>                .setSmallIcon(R.mipmap.ic_launcher);<br/>NotificationCompat.InboxStyle inboxStyle = new NotificationCompat.InboxStyle();<br/>inboxStyle.setBigContentTitle("InboxStyle - Big Content Title")<br/>        .addLine("Line 1")<br/>        .addLine("Line 2");<br/>notificationBuilder.setStyle(inboxStyle);</pre>
<ol start="2">
<li><kbd>BigPictureStyle</kbd>: Large-format notification that includes a large image attachment</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5dfd9531-454b-47f3-9ea0-de07aa5c3d2a.png" style="width:23.67em;height:17.58em;"/></p>
<p style="padding-left: 60px">Check out the code for this style:<br/></p>
<pre style="padding-left: 60px">NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this, CHANNEL_ID)<br/>        .setSmallIcon(R.mipmap.ic_launcher)<br/>        .setContentTitle("LightsActionSoundRedux")<br/>        .setContentText("BigPictureStyle");<br/>NotificationCompat.BigPictureStyle bigPictureStyle = new NotificationCompat.BigPictureStyle();<br/>bigPictureStyle.bigPicture(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));<br/>notificationBuilder.setStyle(bigPictureStyle);</pre>
<ol start="3">
<li><kbd>BigTextStyle</kbd> : Large-format notifications that include a lot of text</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0bcb4f9b-22ad-43d4-a5b1-889f1210f523.png" style="width:25.25em;height:5.50em;"/></p>
<p style="padding-left: 60px">Here's how the code for this style would look.</p>
<pre style="padding-left: 60px">NotificationCompat.Builder notificationBuilder = <br/>        new NotificationCompat.Builder(this, CHANNEL_ID)<br/>        .setSmallIcon(R.mipmap.ic_launcher)<br/>        .setContentTitle("LightsActionSoundRedux");<br/>NotificationCompat.BigTextStyle BigTextStyle = new NotificationCompat.BigTextStyle();<br/>BigTextStyle.bigText("This is an example of the BigTextStyle expanded notification.");<br/>notificationBuilder.setStyle(BigTextStyle);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Lock screen notifications</h1>
                
            
            
                
<p>Android 5.0 (API 21) and above can show notifications on the lock screen, based on the user's lock screen visibility. Use <kbd>setVisibility()</kbd> to specify the notification visibility using the following values:</p>
<ul>
<li><kbd>VISIBILITY_PUBLIC</kbd>: All content can be displayed.</li>
<li><kbd>VISIBILITY_SECRET</kbd>: No content should be displayed.</li>
<li><kbd>VISIBILITY_PRIVATE</kbd>: Display the basic content (title and icon) but the rest is hidden.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>See the <em>Creating a Media Player Notification</em> and <em>Making a Flashlight with a<br/>
Heads-Up Notification</em> recipes for additional notification options with Android 5.0<br/>
(API 21) and greater.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Media Player Notification</h1>
                
            
            
                
<p>This recipe is going to take a look at the new Media Player style introduced in Android 5.0 (API 21). Unlike the previous recipe, <em>Lights, Action, and Sound Redux using Notifications, </em>which used <kbd>NotificationCompat</kbd>, this recipe does not, as this style is not available in the support library.</p>
<p>Here's a screenshot showing how the notification will appear:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8a015041-d7d2-4b11-9df8-9e8d0f57d483.png" style="width:24.83em;height:9.17em;"/></p>
<p>This screenshot shows an example of the Media Player Notification on a lock screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c28438ff-e154-4c08-902f-16a25e0a76c8.png" style="width:24.92em;height:5.00em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>MediaPlayerNotification</kbd>. In the Target Android Devices dialog, select API 21: Android 5.0 (Lollipop), or higher, for this project. Select Empty Activity on the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We just need a single button to call our code to send the notification. Open <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing <kbd>&amp;lt;TextView&amp;gt;</kbd> with the following button code:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;Button<br/>    android:id="@+id/button"<br/>    android:layout_width="wrap_content" <br/>    android:layout_height="wrap_content" <br/>    android:text="Show Notification" <br/>    android:onClick="showNotification"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&amp;gt;</pre>
<ol start="2">
<li>Open <kbd>MainActivity.java</kbd> and add the <kbd>showNotification()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">@SuppressWarnings("deprecated")<br/>public void showNotification(View view) {<br/>    Intent activityIntent = new Intent(this,MainActivity.class);<br/>    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, activityIntent, 0);<br/><br/>    Log.i(this.getClass().getSimpleName(),"showNotification()" );<br/>    Notification.Builder notificationBuilder;<br/>    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M) {<br/>        notificationBuilder = new Notification.Builder(this)<br/>                .setVisibility(Notification.VISIBILITY_PUBLIC)<br/>                .setSmallIcon(Icon.createWithResource(this, R.mipmap.ic_launcher))<br/>                .addAction(new Notification.Action.Builder(<br/>                        Icon.createWithResource(this, android.R.drawable.ic_media_previous),<br/>                        "Previous", pendingIntent).build())<br/>                .addAction(new Notification.Action.Builder(<br/>                        Icon.createWithResource(this, android.R.drawable.ic_media_pause),<br/>                        "Pause", pendingIntent).build())<br/>                .addAction(new Notification.Action.Builder(<br/>                        Icon.createWithResource(this, android.R.drawable.ic_media_next),<br/>                        "Next", pendingIntent).build())<br/>                .setContentTitle("Music")<br/>                .setContentText("Now playing...")<br/>                .setLargeIcon(Icon.createWithResource(this, R.mipmap.ic_launcher))<br/>                .setStyle(new Notification.MediaStyle().setShowActionsInCompactView(1));<br/>    } else {<br/>        notificationBuilder = new Notification.Builder(this)<br/>                .setVisibility(Notification.VISIBILITY_PUBLIC)<br/>                .setSmallIcon(R.mipmap.ic_launcher)<br/>                .addAction(new Notification.Action.Builder(android.R.drawable.ic_media_previous,<br/>                        "Previous", pendingIntent).build())<br/>                .addAction(new Notification.Action.Builder(android.R.drawable.ic_media_pause,<br/>                        "Pause", pendingIntent).build())<br/>                .addAction(new Notification.Action.Builder(android.R.drawable.ic_media_next,<br/>                        "Next", pendingIntent).build())<br/>                .setContentTitle("Music")<br/>                .setContentText("Now playing...")<br/>                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))<br/>                .setStyle(new Notification.MediaStyle().setShowActionsInCompactView(1));<br/>    }<br/>    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {<br/>        notificationBuilder.setChannelId(createChannel());<br/>    }<br/>    NotificationManager notificationManager =<br/>            (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);<br/>    notificationManager.notify(0, notificationBuilder.build());<br/>}</pre>
<ol start="3">
<li>Add the following method to create the channel for Android O and later: </li>
</ol>
<pre style="padding-left: 60px">private String createChannel() {<br/>    final String channelId = "mediaplayer";<br/>    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {<br/>        NotificationChannel channel = new NotificationChannel(channelId, "Notifications",<br/>                NotificationManager.IMPORTANCE_HIGH);<br/>        channel.setDescription("All app notifications");<br/>        channel.enableVibration(true);<br/>        NotificationManager notificationManager =<br/>                getSystemService(NotificationManager.class);<br/>        notificationManager.createNotificationChannel(channel);<br/>    }<br/>    return channelId;<br/>}</pre>
<ol start="4">
<li>Run the program on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first detail to note is that we decorate our <kbd>showNotification()</kbd> method with the following:</p>
<pre>@SuppressWarnings("deprecated")</pre>
<p>This tells the compiler we know we are using deprecated calls. (Without this, the compiler will flag the code.) We follow this with an API check, using this call:</p>
<pre>if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.M) </pre>
<p>The icon resource was changed in API 23, but we want this application to run on API 21 (Android 5.0) and later, so we still need to call the old methods when running on API 21 and API 22.</p>
<p>If the user is running on Android 6.0 (or higher), we use the new <kbd>Icon</kbd> class to create our icons; otherwise, we use the old constructor. (You'll notice the IDE shows deprecated calls with a strikethrough.) Checking the current OS version during runtime is a common strategy for remaining backward-compatible.</p>
<p>We create three actions using <kbd>addAction()</kbd> to handle the media player functionality. Since we don't really have a media player going, we use the same intent for all the actions, but you'll want to create separate intents in your application.</p>
<p>To make the notification visible on the lock screen, we need to set the visibility level to <kbd>VISIBILITY_PUBLIC</kbd>, which we do with the following call:</p>
<pre>.setVisibility(Notification.VISIBILITY_PUBLIC) </pre>
<p>This call is worth noting:</p>
<pre>.setShowActionsInCompactView(1) </pre>
<p>Just as the method name implies, this sets the actions to show when the notification is shown with a reduced layout. (See the lock screen image in the recipe introduction.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We only created the visual notification in this recipe. If we were creating an actual media player, we could instantiate a <kbd>MediaSession</kbd> class and pass in the session token with this call:</p>
<pre>.setMediaSession(mMediaSession.getSessionToken()) </pre>
<p>This will allow the system to recognize the media content and react accordingly, such as updating the lock screen with the current album artwork.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>MediaSession developer documents: <a href="https://developer.android.com/reference/android/media/session/MediaSession.html">https://developer.android.com/reference/android/media/session/MediaSession.html</a></li>
<li>The <em>Lock Screen Visibility</em> section in the <em>Lights, Action, and Sound Redux using Notifications</em> recipe discusses visibility options</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Making a Flashlight with a Heads-Up Notification</h1>
                
            
            
                
<p>Android 5.0-Lollipop (API 21) introduced a new type of notification called the Heads-Up Notification. Many people do not care for this new notification as it can be extremely intrusive, as it forces its way on top of other apps. (See the following screenshot.) Keep this in mind when using this type of notification. We're going to demonstrate the Heads-Up Notification with a Flashlight as this demonstrates a good use case scenario.</p>
<p>Here's a screenshot showing the Heads-Up Notification we'll create further on:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f6feface-55d9-4290-8bb2-ad20ce00e8e9.png" style="width:55.58em;height:6.67em;"/></p>
<p>If you have a device running Android 6.0, you may have noticed the new Flashlight settings option. As a demonstration, we're going to create something similar in this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>FlashlightWithHeadsUp</kbd>. When prompted for the API level, we need API 23 (or higher) for this project. Select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Our activity layout will consist of just a <kbd>ToggleButton</kbd> to control the flashlight mode. We'll be using the same <kbd>setTorchMode()</kbd> code as the <em>Lights, Action, and Sound - getting the user's attention!</em> recipe presented earlier, and will add a Heads-Up Notification. We'll need permission to use the vibrate option, so start by opening the Android Manifest and following these steps:</p>
<ol>
<li>Add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;uses-permission android:name="android.permission.VIBRATE"/&amp;gt;</pre>
<ol start="2">
<li>Specify that we only want a single instance of <kbd>MainActivity</kbd> by adding <kbd>android:launchMode="singleInstance"</kbd> to the <kbd>&amp;lt;MainActivity&amp;gt;</kbd> element. It will look as follows:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;activity android:name=".MainActivity" 
    android:launchMode="singleInstance"&amp;gt; </pre>
<ol start="3">
<li>With the changes to <kbd>AndroidManifest</kbd> done, open the <kbd>activity_main.xml</kbd> layout and replace the existing <kbd>&amp;lt;TextView&amp;gt;</kbd> element with this <kbd>&amp;lt;ToggleButton&amp;gt;</kbd> code:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;ToggleButton<br/>    android:id="@+id/buttonLight"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Flashlight"<br/>    android:onClick="clickLight"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&amp;gt;</pre>
<ol start="4">
<li>Now, open <kbd>ActivityMain.java</kbd> and add the following global variables:</li>
</ol>
<pre style="padding-left: 60px">private static final String ACTION_STOP="STOP"; 
private CameraManager mCameraManager; 
private String mCameraId=null; 
private ToggleButton mButtonLight; </pre>
<ol start="5">
<li>Add the following code to <kbd>onCreate()</kbd> to set up the camera:</li>
</ol>
<pre style="padding-left: 60px">mButtonLight = findViewById(R.id.buttonLight);<br/>mCameraManager = (CameraManager) this.getSystemService(Context.CAMERA_SERVICE);<br/>mCameraId = getCameraId();<br/>if (mCameraId==null) {<br/>    mButtonLight.setEnabled(false);<br/>} else {<br/>    mButtonLight.setEnabled(true);<br/>}</pre>
<ol start="6">
<li>Add the following method to handle the response when the user presses the notification:</li>
</ol>
<pre style="padding-left: 60px">@Override 
protected void onNewIntent(Intent intent) { 
    super.onNewIntent(intent); 
    if (ACTION_STOP.equals(intent.getAction())) { 
        setFlashlight(false); 
    } 
} </pre>
<ol start="7">
<li>Add the method to get the camera ID:</li>
</ol>
<pre style="padding-left: 60px">private String getCameraId() {<br/>    try {<br/>        String[] ids = mCameraManager.getCameraIdList();<br/>        for (String id : ids) {<br/>            CameraCharacteristics c = mCameraManager.getCameraCharacteristics(id);<br/>            Boolean flashAvailable = c.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);<br/>            Integer facingDirection = c.get(CameraCharacteristics.LENS_FACING);<br/>            if (flashAvailable != null<br/>                    &amp;&amp; flashAvailable<br/>                    &amp;&amp; facingDirection != null<br/>                    &amp;&amp; facingDirection == CameraCharacteristics.LENS_FACING_BACK) {<br/>                return id;<br/>            }<br/>        }<br/>    } catch (CameraAccessException e) {<br/>        e.printStackTrace();<br/>    }<br/>    return null;<br/>}</pre>
<ol start="8">
<li>Add these two methods to handle the flashlight mode:</li>
</ol>
<pre style="padding-left: 60px">public void clickLight(View view) {<br/>    setFlashlight(mButtonLight.isChecked());<br/>    if (mButtonLight.isChecked()) {<br/>        showNotification();<br/>    }<br/>}<br/><br/>private void setFlashlight(boolean enabled) {<br/>    mButtonLight.setChecked(enabled);<br/>    try {<br/>        mCameraManager.setTorchMode(mCameraId, enabled);<br/>    } catch (CameraAccessException e) {<br/>        e.printStackTrace();<br/>    }<br/>}</pre>
<ol start="9">
<li>Finally, add this method to create the notification:</li>
</ol>
<pre style="padding-left: 60px">private void showNotification() {<br/>    final String CHANNEL_ID = "flashlight";<br/>    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {<br/>        NotificationChannel channel = new NotificationChannel(CHANNEL_ID,<br/>                "Notifications", NotificationManager.IMPORTANCE_HIGH);<br/>        channel.setDescription("All app notifications");<br/>        channel.enableVibration(true);<br/>        NotificationManager notificationManager = getSystemService(NotificationManager.class);<br/>        notificationManager.createNotificationChannel(channel);<br/>    }<br/><br/>    Intent activityIntent = new Intent(this, MainActivity.class);<br/>    activityIntent.setAction(ACTION_STOP);<br/>    PendingIntent pendingIntent = <br/>            PendingIntent.getActivity(this, 0, activityIntent, 0);<br/>    final NotificationCompat.Builder notificationBuilder = <br/>            new NotificationCompat.Builder(this, CHANNEL_ID)<br/>            .setContentTitle("Flashlight")<br/>            .setContentText("Press to turn off the flashlight")<br/>            .setSmallIcon(R.mipmap.ic_launcher)<br/>            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))<br/>            .setContentIntent(pendingIntent)<br/>            .setVibrate(new long[]{DEFAULT_VIBRATE})<br/>            .setPriority(PRIORITY_MAX)<br/>            .setAutoCancel(true);<br/>    NotificationManager notificationManager = (NotificationManager) <br/> this.getSystemService(Context.NOTIFICATION_SERVICE);<br/> notificationManager.notify(0, notificationBuilder.build());<br/>}</pre>
<ol start="10">
<li>You're ready to run the application on a physical device. As noted previously, you'll need an Android 6.0 (or higher) device, with an outward-facing camera flash.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Since this recipe uses the same flashlight code as <em>Lights, Action, and Sound - getting the user's attention!</em>, we'll jump to the <kbd>showNotification()</kbd> method. Most notification builder calls are the same as in previous examples, but there are two significant differences:</p>
<pre>.setVibrate() 
.setPriority(PRIORITY_MAX) </pre>
<p>Notifications will not be escalated to Heads-Up Notifications unless the priority is set to <kbd>HIGH</kbd> (or above) and uses either vibrate or sound.<br/>
<br/>
Note this from the Developer documentation at <a href="http://developer.android.com/reference/android/app/Notification.html#headsUpContentView">http://developer.android.com/reference/android/app/Notification.html#headsUpContentView</a>:<br/>
<br/>
"At its discretion, the system UI may choose to show this as a heads-up notification."</p>
<p>We create a <kbd>PendingIntent</kbd> as we've done previously, but here we set the action with the following:</p>
<pre>activityIntent.setAction(ACTION_STOP); </pre>
<p>We set the app to only allow a single instance in the <kbd>AndroidManifest</kbd> file, as we don't want to start a new instance of the app when the user presses the notification. The <kbd>PendingIntent</kbd> we created sets the action, which we check in the <kbd>onNewIntent()</kbd> callback. If the user opens the app without pressing the notification, they can still disable the flashlight with the <kbd>ToggleButton</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You may have noticed the following line of code:</p>
<pre>.setAutoCancel(true);</pre>
<p><kbd>.setAutoCancel()</kbd> tells the OS to automatically remove the notification when the user clicks on it. This is great if the user presses the notification to turn off the light, but what happens if they use the toggle button? The light will turn off as it should, but they are left with a useless notification. To fix that, we can add a new method to cancel the notification:</p>
<pre>private void cancelNotification() {<br/>    NotificationManager notificationManager = (NotificationManager)<br/>            this.getSystemService(Context.NOTIFICATION_SERVICE);<br/>    notificationManager.cancelAll();<br/>}</pre>
<p>Then we call it when they press the button. Here's how <kbd>clickLight()</kbd> will look:</p>
<pre>public void clickLight(View view) {<br/>    setFlashlight(mButtonLight.isChecked());<br/>    if (mButtonLight.isChecked()) {<br/>        showNotification();<br/>    } else {<br/>        cancelNotification();<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to the earlier <em>Lights, Action, and Sound - getting the user's attention!</em> recipe for more information on the torch API</li>
<li>Refer to the earlier <em>Lights, Action, and Sound Redux using Notifications</em> recipe for more Notification examples</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Notifications with Direct Reply</h1>
                
            
            
                
<p>One of the most exciting new features introduced in Android N was inline reply, called Direct Reply. With Direct Reply, users can respond without leaving the Notification Bar!</p>
<p>In this recipe, we’ll add the ability to create an inline reply by passing a RemoteInput to the <kbd>addRemoteInput()</kbd> method. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>DirectReply</kbd>. In the Target Android Devices dialog, select the Phone &amp; Tablet option and choose API 24: Android Nougat 7.0 (or later) for the Minimum SDK. Select Empty Activity when prompted for the Activity Type. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Our app will consist of a single button on the main screen to initiate the initial notification. Start by opening <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing <kbd>TextView</kbd> with the button XML:</li>
</ol>
<pre style="padding-left: 60px">&amp;lt;Button<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Send Notification"<br/>    android:id="@+id/buttonSend"<br/>    android:onClick="onClickSend"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&amp;gt;</pre>
<ol start="2">
<li>Now, open <kbd>MainActivity.java</kbd> and add the following code to the class:</li>
</ol>
<pre style="padding-left: 60px">private final String KEY_REPLY_TEXT = "KEY_REPLY_TEXT";<br/>private final int NOTIFICATION_ID = 1;</pre>
<ol start="3">
<li>Add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">if (getIntent()!=null) {<br/>    Toast.makeText(MainActivity.this, getReplyText(getIntent()), Toast.LENGTH_SHORT).show();<br/>}</pre>
<ol start="4">
<li>Override the <kbd>onNewIntent()</kbd> method as follows:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onNewIntent(Intent intent) {<br/>    super.onNewIntent(intent);<br/>    Toast.makeText(MainActivity.this, getReplyText(intent), Toast.LENGTH_SHORT).show();<br/>}</pre>
<ol start="5">
<li>Add the following method to handle the button click:</li>
</ol>
<pre style="padding-left: 60px">public void onClickSend(View view){<br/>    Intent activityIntent = new Intent(this,MainActivity.class);<br/>    PendingIntent pendingIntent =<br/>            PendingIntent.getActivity(this,0,activityIntent,0);<br/><br/>    RemoteInput remoteInput = new RemoteInput.Builder(KEY_REPLY_TEXT)<br/>            .setLabel("Reply")<br/>            .build();<br/><br/>    NotificationCompat.Action action = <br/>            new NotificationCompat.Action.Builder(android.R.drawable.ic_menu_revert, <br/>                    "Reply", pendingIntent)<br/>                    .addRemoteInput(remoteInput)<br/>                    .build();<br/><br/>    NotificationCompat.Builder notificationBuilder = <br/>            new NotificationCompat.Builder(this,getChannelId())<br/>                    .setSmallIcon(android.R.drawable.ic_dialog_email)<br/>                    .setContentTitle("Reply")<br/>                    .setContentText("Content")<br/>                    .addAction(action);<br/><br/>    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);<br/>    notificationManager.notify(0, notificationBuilder.build());<br/>}<br/><br/>private String getChannelId() {<br/>    final String channelId = "directreply";<br/>    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {<br/>        NotificationChannel channel = new NotificationChannel(channelId,<br/>                "Notifications", NotificationManager.IMPORTANCE_DEFAULT);<br/>        channel.setDescription("All app notifications");<br/>        channel.enableVibration(true);<br/>        NotificationManager notificationManager = getSystemService(NotificationManager.class);<br/>        notificationManager.createNotificationChannel(channel);<br/>    }<br/>    return channelId;<br/>}</pre>
<ol start="6">
<li>Add the <kbd>getReplyText()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">private CharSequence getReplyText(Intent intent) {<br/>    Bundle notificationReply = RemoteInput.getResultsFromIntent(intent);<br/>    if (notificationReply != null) {<br/>        return notificationReply.getCharSequence(KEY_REPLY_TEXT);<br/>    }<br/>    return null;<br/>}</pre>
<ol start="7">
<li>You’re ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Adding the Inline Reply option to a notification is actually very simple. We start with a Notification object as we've done in the previous recipes. (We're using NotifcationCompat from the support library to provide greater backward compatibility.) When creating the Action, call the <kbd>addRemoteInput()</kbd> method, passing in a RemoteInput. RemoteInput is where you define they key to retrieve the user input text. After the user enters a reply, the OS calls the PendingIntent, passing the data back to your app in an Intent. Use <kbd>RemoteInput.getResultsFromIntent()</kbd> to retrieve the user text as we did in the <kbd>getReplyText()</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The Notifications Overview guide at <a href="https://developer.android.com/guide/topics/ui/notifiers/notifications">https://developer.android.com/guide/topics/ui/notifiers/notifications</a></li>
</ul>


            

            
        
    </body></html>