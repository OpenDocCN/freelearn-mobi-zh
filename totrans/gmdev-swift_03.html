<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Mix in the Physics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Mix in the Physics</h1></div></div></div><p>SpriteKit includes a fully functional physics engine. It is easy to implement and very useful; most mobile game designs require some level of physical interaction between game objects. In our game, we want to know when the player runs into the ground, an enemy, or a power-up. The physics system can track these collisions and execute our specific game code when any of these events occur. SpriteKit's physics engine can also apply gravity to the world, bounce and spin colliding sprites against each other, and create realistic movement through impulses – and it does all of this before every single frame is drawn to the screen.</p><p>The topics in this chapter include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adopting a protocol for consistency</li><li class="listitem" style="list-style-type: disc">Organizing game objects into classes</li><li class="listitem" style="list-style-type: disc">Adding the player's character</li><li class="listitem" style="list-style-type: disc">Renovating the <code class="literal">GameScene</code> class</li><li class="listitem" style="list-style-type: disc">Physics bodies and gravity</li><li class="listitem" style="list-style-type: disc">Exploring physics simulation mechanics</li><li class="listitem" style="list-style-type: disc">Movement with impulses and forces</li><li class="listitem" style="list-style-type: disc">Bumping bees into bees</li></ul></div><div class="section" title="Laying the foundation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Laying the foundation</h1></div></div></div><p>So far, we have learned through small bits of code, individually added to the <code class="literal">GameScene</code> class. The intricacy of our application is about to increase. To build a complex game world, we will need to construct re-usable classes and actively organize our new code.</p><div class="section" title="Following protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Following protocol</h2></div></div></div><p>To start, we want individual<a id="id97" class="indexterm"/> classes for each of our game objects (a bee class, a player penguin class, a power-up class, and so on). Furthermore, we want all of our game object classes to share a consistent set of properties and methods. We can <a id="id98" class="indexterm"/>enforce this commonality by creating a <span class="strong"><strong>protocol</strong></span>, or a blueprint for our game classes. The protocol does not provide any functionality on its own, but each class that adopts the protocol must follow its specifications exactly before Xcode can compile the project. Protocols are very similar to interfaces, if you are from a Java or C# background.</p><p>Add a new file to your project (right-click in the project navigator and choose <span class="strong"><strong>New File</strong></span>, then <span class="strong"><strong>Swift File</strong></span>) and name it <code class="literal">GameSprite.swift</code>. Then add the following code to your new file:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

protocol GameSprite {
    var textureAtlas: SKTextureAtlas { get set }
    func spawn(parentNode: SKNode, position: CGPoint, size: 
        CGSize)
    func onTap()
}</pre></div><p>Now, any class that adopts the <code class="literal">GameSprite</code> protocol must implement a <code class="literal">textureAtlas</code> property, a <code class="literal">spawn</code> function, and an <code class="literal">onTap</code> function. We can safely assume that the game objects provide these implementations when we work with them in our code.</p></div><div class="section" title="Reinventing the bee"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Reinventing the bee</h2></div></div></div><p>Our old bee is working wonderfully, but we want to spawn many bees throughout the world. We will<a id="id99" class="indexterm"/> create a <code class="literal">Bee</code> class, inheriting from <code class="literal">SKSpriteNode</code>, so we can cleanly stamp as many bees to the world as we please.</p><p>It is a common convention to separate each class into its own file. Add a new <code class="literal">Swift</code> file to your project and name it <code class="literal">Bee.swift</code>. Then, add this code:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

// Create the new class Bee, inheriting from SKSpriteNode
// and adopting the GameSprite protocol:
class Bee: SKSpriteNode, GameSprite {
    // We will store our texture atlas and bee animations as
    // class wide properties.
    var textureAtlas:SKTextureAtlas = 
        SKTextureAtlas(named:"bee.atlas")
    var flyAnimation = SKAction()

    // The spawn function will be used to place the bee into
    // the world. Note how we set a default value for the size
    // parameter, since we already know the size of a bee
    func spawn(parentNode:SKNode, position: CGPoint, size: CGSize 
        = CGSize(width: 28, height: 24)) {
        parentNode.addChild(self)
        createAnimations()
        self.size = size
        self.position = position
        self.runAction(flyAnimation)
    }

    // Our bee only implements one texture based animation.
    // But some classes may be more complicated,
    // So we break out the animation building into this function:
    func createAnimations() {
        let flyFrames:[SKTexture] = 
            [textureAtlas.textureNamed("bee.png"), 
            textureAtlas.textureNamed("bee_fly.png")]
        let flyAction = SKAction.animateWithTextures(flyFrames, 
            timePerFrame: 0.14)
        flyAnimation = SKAction.repeatActionForever(flyAction)
    }

    // onTap is not wired up yet, but we have to implement this
    // function to adhere to our protocol.
    // We will explore touch events in the next chapter.
    func onTap() {}
}</pre></div><p>It is now easy to<a id="id100" class="indexterm"/> spawn as many bees as we like. Switch back to <code class="literal">GameScene.swift</code>, and add this code in <code class="literal">didMoveToView</code>:</p><div class="informalexample"><pre class="programlisting">// Create three new instances of the Bee class:
let bee2 = Bee()
let bee3 = Bee()
let bee4 = Bee()
// Use our spawn function to place the bees into the world:
bee2.spawn(world, position: CGPoint(x: 325, y: 325))
bee3.spawn(world, position: CGPoint(x: 200, y: 325))
bee4.spawn(world, position: CGPoint(x: 50, y: 200))</pre></div><p>Run the project. Bees, bees everywhere! Our original bee is flying back and forth through a swarm. Your simulator should look like this:</p><div class="mediaobject"><img src="graphics/Image_B04532_03_01.jpg" alt="Reinventing the bee"/></div><p>Depending <a id="id101" class="indexterm"/>on how you look at it, you may perceive that the new bees are moving and the original bee is still. We need to add a point of reference. Next, we will add the ground.</p></div><div class="section" title="The icy tundra"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>The icy tundra</h2></div></div></div><p>We will add<a id="id102" class="indexterm"/> some ground at the bottom of the screen to serve as a constraint for player positioning and as a reference point for movement. We will create a new class named <code class="literal">Ground</code>. First, let us add the texture atlas for the ground art to our project.</p><div class="section" title="Another way to add assets"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Another way to add assets</h3></div></div></div><p>We will use a different method of adding files to Xcode. Follow these steps to add the new artwork:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In Finder, navigate to the asset pack you downloaded in <a class="link" href="ch02.html" title="Chapter 2. Sprites, Camera, Actions!">Chapter 2</a>, <span class="emphasis"><em>Sprites, Camera, Actions!</em></span>, and then to the <code class="literal">Environment</code> folder.</li><li class="listitem">You learned to create a texture atlas earlier, for our bee. I have already created texture atlases for the rest of the art we use in this game. Locate the <code class="literal">ground.atlas</code> folder.</li><li class="listitem">Drag and drop this folder into the project manager in Xcode, under the project folder, as seen in this screenshot:<div class="mediaobject"><img src="graphics/Image_B04532_03_02.jpg" alt="Another way to add assets"/></div></li><li class="listitem">In <a id="id103" class="indexterm"/>the dialog box, make sure your settings match the following screenshot, and then click <span class="strong"><strong>Finish</strong></span>:<div class="mediaobject"><img src="graphics/Image_B04532_03_03.jpg" alt="Another way to add assets"/></div></li></ol></div><p>Perfect – you should see the ground texture atlas in the project navigator.</p></div><div class="section" title="Adding the Ground class"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Adding the Ground class</h3></div></div></div><p>Next, we<a id="id104" class="indexterm"/> will add the code for the ground. Add a new Swift file to your project and name it <code class="literal">Ground.swift</code>. Use the following code:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

// A new class, inheriting from SKSpriteNode and
// adhering to the GameSprite protocol.
class Ground: SKSpriteNode, GameSprite {
    var textureAtlas:SKTextureAtlas = 
        SKTextureAtlas(named:"ground.atlas")
    // Create an optional property named groundTexture to store 
    // the current ground texture:
    var groundTexture:SKTexture?

    func spawn(parentNode:SKNode, position:CGPoint, size:CGSize) {
        parentNode.addChild(self)
        self.size = size
        self.position = position
        // This is one of those unique situations where we use
        // non-default anchor point. By positioning the ground by
        // its top left corner, we can place it just slightly
        // above the bottom of the screen, on any of screen size.
        self.anchorPoint = CGPointMake(0, 1)

        // Default to the ice texture:
        if groundTexture == nil {
            groundTexture = textureAtlas.textureNamed("ice-
                tile.png");
        }

        // We will create child nodes to repeat the texture.
        createChildren()
    }

    // Build child nodes to repeat the ground texture
    func createChildren() {
        // First, make sure we have a groundTexture value:
        if let texture = groundTexture {
            var tileCount:CGFloat = 0
            let textureSize = texture.size()
            // We will size the tiles at half the size
            // of their texture for retina sharpness:
            let tileSize = CGSize(width: textureSize.width / 2, 
                height: textureSize.height / 2)

            // Build nodes until we cover the entire Ground width
            while tileCount * tileSize.width &lt; self.size.width {
                let tileNode = SKSpriteNode(texture: texture)
                tileNode.size = tileSize
                tileNode.position.x = tileCount * tileSize.width
                // Position child nodes by their upper left corner
                tileNode.anchorPoint = CGPoint(x: 0, y: 1)
                // Add the child texture to the ground node:
                self.addChild(tileNode)

                tileCount++
            }
        }
    }

    // Implement onTap to adhere to the protocol:
    func onTap() {}
}</pre></div></div><div class="section" title="Tiling a texture"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>Tiling a texture</h3></div></div></div><p>Why do <a id="id105" class="indexterm"/>we need the <code class="literal">createChildren</code> function? SpriteKit does not support a built-in method to repeat a texture over the size of a node. Instead, we create children nodes for each texture tile and append them across the width of the parent. Performance is not an issue; as long as we attach the children to one parent, and the textures all come from the same texture atlas, SpriteKit handles them with one draw call.</p></div><div class="section" title="Running wire to the ground"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec11"/>Running wire to the ground</h3></div></div></div><p>We have <a id="id106" class="indexterm"/>added the ground art to the project and created the <code class="literal">Ground</code> class. The final step is to create an instance of <code class="literal">Ground</code> in our scene. Follow these steps to wire-up the ground:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">GameScene.swift</code> and add a new property to the <code class="literal">GameScene</code> class to create an instance of the <code class="literal">Ground</code> class. You can place this underneath the line that instantiates the world node (the new code is in bold):<div class="informalexample"><pre class="programlisting">let world = SKNode()
<span class="strong"><strong>let ground = Ground()</strong></span>
</pre></div></li><li class="listitem">Locate the <code class="literal">didMoveToView</code> function. Add the following code at the bottom, underneath our bee spawning lines:<div class="informalexample"><pre class="programlisting">// size and position the ground based on the screen size.
// Position X: Negative one screen width.
// Position Y: 100 above the bottom (remember the ground's top
// left anchor point).
let groundPosition = CGPoint(x: -self.size.width, y: 100)
// Width: 3x the width of the screen.
// Height: 0. Our child nodes will provide the height.
let groundSize = CGSize(width: self.size.width * 3, height: 0)
// Spawn the ground!
ground.spawn(world, position: groundPosition, size: groundSize)</pre></div></li></ol></div><p>Run the <a id="id107" class="indexterm"/>project. You will see the icy tundra appear underneath our bees. This small change goes a long way towards creating the feeling that our central bee is moving through space. Your simulator should look like this:</p><div class="mediaobject"><img src="graphics/Image_B04532_03_04.jpg" alt="Running wire to the ground"/></div></div></div><div class="section" title="A wild penguin appears!"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>A wild penguin appears!</h2></div></div></div><p>There is<a id="id108" class="indexterm"/> one more class to build before we start our physics lesson: the <code class="literal">Player</code> class! It is time to replace our moving bee with a node designated as the player.</p><p>First, we will add the texture atlas for our penguin art. By now, you are familiar with adding files through the project navigator. Add the Pierre art as you did previously with the ground assets. I named Pierre's texture atlas <code class="literal">pierre.atlas</code>. You can find it in the asset pack, inside the <code class="literal">Pierre</code> folder.</p><p>Once you <a id="id109" class="indexterm"/>add Pierre's texture atlas to the project, you can create the <code class="literal">Player</code> class. Add a new Swift file to your project and name it <code class="literal">Player.swift</code>. Then add this code:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

class Player : SKSpriteNode, GameSprite {
    var textureAtlas:SKTextureAtlas = 
        SKTextureAtlas(named:"pierre.atlas")
    // Pierre has multiple animations. Right now we will
    // create an animation for flying up, and one for going down:
    var flyAnimation = SKAction()
    var soarAnimation = SKAction()

    func spawn(parentNode:SKNode, position: CGPoint,
        size:CGSize = CGSize(width: 64, height: 64)) {
        parentNode.addChild(self)
        createAnimations()
        self.size = size
        self.position = position
        // If we run an action with a key, "flapAnimation",
        // we can later reference that key to remove the action.
        self.runAction(flyAnimation, withKey: "flapAnimation")
    }

    func createAnimations() {
        let rotateUpAction = SKAction.rotateToAngle(0, duration: 
            0.475)
        rotateUpAction.timingMode = .EaseOut
        let rotateDownAction = SKAction.rotateToAngle(-1, 
            duration: 0.8)
        rotateDownAction.timingMode = .EaseIn

        // Create the flying animation:
        let flyFrames:[SKTexture] = [
            textureAtlas.textureNamed("pierre-flying-1.png"),
            textureAtlas.textureNamed("pierre-flying-2.png"),
            textureAtlas.textureNamed("pierre-flying-3.png"),
            textureAtlas.textureNamed("pierre-flying-4.png"),
            textureAtlas.textureNamed("pierre-flying-3.png"),
            textureAtlas.textureNamed("pierre-flying-2.png")
        ]
        let flyAction = SKAction.animateWithTextures(flyFrames, 
            timePerFrame: 0.03)
        // Group together the flying animation frames with a 
        // rotation up:
        flyAnimation = SKAction.group([
            SKAction.repeatActionForever(flyAction),
            rotateUpAction
        ])

        // Create the soaring animation, just one frame for now:
        let soarFrames:[SKTexture] = 
            [textureAtlas.textureNamed("pierre-flying-1.png")]
        let soarAction = SKAction.animateWithTextures(soarFrames, 
            timePerFrame: 1)
        // Group the soaring animation with the rotation down:
        soarAnimation = SKAction.group([
            SKAction.repeatActionForever(soarAction),
            rotateDownAction
        ])
    }

    func onTap() {}
}</pre></div><p>Great! Before <a id="id110" class="indexterm"/>we continue, we need to replace our original bee with an instance of the new <code class="literal">Player</code> class we just created. Follow these steps to replace the bee:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In <code class="literal">GameScene.swift</code>, near the top, remove the line that creates a <code class="literal">bee</code> constant in the <code class="literal">GameScene</code> class. Instead, we want to instantiate an instance of <code class="literal">Player</code>. Add the new line: <code class="literal">let player = Player()</code>.</li><li class="listitem">Completely delete the <code class="literal">addTheFlyingBee</code> function.</li><li class="listitem">In <code class="literal">didMoveToView</code>, remove the line that calls <code class="literal">addTheFlyingBee</code>.</li><li class="listitem">In <code class="literal">didMoveToView</code>, at the bottom, add a new line to spawn the player:<div class="informalexample"><pre class="programlisting">player.spawn(world, position: CGPoint(x: 150, y: 250))</pre></div></li><li class="listitem">Further down, in <code class="literal">didSimulatePhysics</code>, replace the references to the bee with references to <code class="literal">player</code>. Recall that we created the <code class="literal">didSimulatePhysics</code> function in <a class="link" href="ch02.html" title="Chapter 2. Sprites, Camera, Actions!">Chapter 2</a>, <span class="emphasis"><em>Sprites, Camera, Actions!</em></span>, when we centered the camera on one node.</li></ol></div><p>We have successfully transformed the original bee into a penguin. Before we move on, we will make sure your <code class="literal">GameScene</code> class includes all of the changes we have made so far in this chapter. After that, we will begin to explore the physics system.</p></div><div class="section" title="Renovating the GameScene class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Renovating the GameScene class</h2></div></div></div><p>We have made quite a few<a id="id111" class="indexterm"/> changes to our project. Luckily, this is the last major overhaul of the previous animation code. Moving forward, we will use the terrific structure we built in this chapter. At this point, your <code class="literal">GameScene.swift</code> file should look something like this:</p><div class="informalexample"><pre class="programlisting">class GameScene: SKScene {
    let world = SKNode()
    let player = Player()
    let ground = Ground()

    override func didMoveToView(view: SKView) {
        // Set a sky-blue background color:
        self.backgroundColor = UIColor(red: 0.4, green: 0.6, blue: 
            0.95, alpha: 1.0)

        // Add the world node as a child of the scene:
        self.addChild(world)

        // Spawn our physics bees:
        let bee2 = Bee()
        let bee3 = Bee()
        let bee4 = Bee()
        bee2.spawn(world, position: CGPoint(x: 325, y: 325))
        bee3.spawn(world, position: CGPoint(x: 200, y: 325))
        bee4.spawn(world, position: CGPoint(x: 50, y: 200))

        // Spawn the ground:
        let groundPosition = CGPoint(x: -self.size.width, y: 30)
        let groundSize = CGSize(width: self.size.width * 3, 
            height: 0)
        ground.spawn(world, position: groundPosition, size: 
            groundSize)

        // Spawn the player:
        player.spawn(world, position: CGPoint(x: 150, y: 250))
    }

    override func didSimulatePhysics() {
        let worldXPos = -(player.position.x * world.xScale – 
            (self.size.width / 2))
        let worldYPos = -(player.position.y * world.yScale – 
            (self.size.height / 2))
        world.position = CGPoint(x: worldXPos, y: worldYPos)
    }
}</pre></div><p>Run the project. You <a id="id112" class="indexterm"/>will see our new penguin hovering near the bees. Great work; we are now ready to explore the physics system with all of our new nodes. Your simulator should look something like this screenshot:</p><div class="mediaobject"><img src="graphics/Image_B04532_03_05.jpg" alt="Renovating the GameScene class"/></div></div></div></div>
<div class="section" title="Exploring the physics system"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Exploring the physics system </h1></div></div></div><p>SpriteKit simulates<a id="id113" class="indexterm"/> physics with <a id="id114" class="indexterm"/>
<span class="strong"><strong>physics bodies</strong></span>. We attach physics bodies to all the nodes that need physics computations. We will set up a quick example before exploring all of the details.</p><div class="section" title="Dropping like flies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Dropping like flies</h2></div></div></div><p>Our<a id="id115" class="indexterm"/> bees need to be part of the physics simulation, so we will add physics bodies to their nodes. Open your <code class="literal">Bee.swift</code> file and locate the <code class="literal">spawn</code> function. Add the following code at the bottom of the function:</p><div class="informalexample"><pre class="programlisting">// Attach a physics body, shaped like a circle
// and sized roughly to our bee.
self.physicsBody = SKPhysicsBody(circleOfRadius: size.width / 2)</pre></div><p>It is that easy to add a node to the physics simulation. Run the project. You will see our three <code class="literal">Bee</code> instances drop off the screen. They are now subject to gravity, which is on by default.</p></div><div class="section" title="Solidifying the ground"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Solidifying the ground</h2></div></div></div><p>We want the ground<a id="id116" class="indexterm"/> to catch falling game objects. We can give the ground its own physics body so the physics simulation can stop the bees from falling through it. Open your <code class="literal">Ground.swift</code> file, locate the <code class="literal">spawn</code> function, and then add this code at the bottom of the function:</p><div class="informalexample"><pre class="programlisting">// Draw an edge physics body along the top of the ground node.
// Note: physics body positions are relative to their nodes.
// The top left of the node is X: 0, Y: 0, given our anchor point.
// The top right of the node is X: size.width, Y: 0
let pointTopRight = CGPoint(x: size.width, y: 0)
self.physicsBody = SKPhysicsBody(edgeFromPoint: CGPointZero, 
    toPoint: pointTopRight)</pre></div><p>Run the project. The bees will now quickly drop and then stop once they collide with the ground. Notice how bees that fall farther bounce more energetically. After the bees land, your simulator will look like this:</p><div class="mediaobject"><img src="graphics/Image_B04532_03_06.jpg" alt="Solidifying the ground"/></div></div></div>
<div class="section" title="Checkpoint 3-A"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Checkpoint 3-A</h1></div></div></div><p>Great work so far. We have added a lot of structure to our game and started to explore the physics system. If you would like to download my project to this point, do so here:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-3">http://www.thinkingswiftly.com/game-development-with-swift/chapter-3</a>
</p></div>
<div class="section" title="Exploring physics simulation mechanics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Exploring physics simulation mechanics</h1></div></div></div><p>Let's take a closer look<a id="id117" class="indexterm"/> at the specifics of SpriteKit's physics system. For instance, why are the bees subject to gravity, but the ground stays where it is? Though we attached physics bodies to both nodes, we actually used two different styles of physics bodies. There are three types of physics bodies, and each behaves slightly differently:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dynamic</strong></span> physics bodies have <a id="id118" class="indexterm"/>volume <a id="id119" class="indexterm"/>and are fully subject to forces and collisions in the system. We will use dynamic physics bodies for most parts of the game world: the player, enemies, power-ups, and others.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Static</strong></span> physics bodies <a id="id120" class="indexterm"/>have <a id="id121" class="indexterm"/>volume but no velocity. The physics simulation does not move nodes with static bodies but they can still collide with other game objects. We can use static bodies for walls or obstacles.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Edge</strong></span> physics bodies<a id="id122" class="indexterm"/> have no volume and the <a id="id123" class="indexterm"/>physics simulation will never move them. They mark off the boundaries of movement; other physics bodies will never cross them. Edges can cross each other to create small containment areas.</li></ul></div><p>Voluminous (dynamic and static) bodies have a variety of properties that modify how they react to collisions and movement through space. This allows us to create a wide range of realistic physics effects. Each property controls one aspect of a body's physical characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Restitution</strong></span> <a id="id124" class="indexterm"/>determines how much energy is lost when one body bounces into another. This changes the body's bounciness. SpriteKit measures restitution on a scale from 0.0 to 1.0. The default value is 0.2.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Friction</strong></span> describes <a id="id125" class="indexterm"/>the amount of force necessary to slide one body against another body. This property also uses a scale of 0.0 to 1.0, with a default value of 0.2.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Damping </strong></span>determines<a id="id126" class="indexterm"/> how quickly a body slows as it moves through space. You can think of damping as air friction. Linear damping determines how quickly a body loses speed, while angular damping affects rotation. Both measure from 0.0 to 1.0, with a default value of 0.1.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mass </strong></span>is measured<a id="id127" class="indexterm"/> in kilograms. It describes how far colliding objects push the body and factors in momentum during movement. Bodies with more mass will move less when hit by another body and will push other bodies further when they collide with them. The physics engine automatically uses the mass and the area of the body to determine <a id="id128" class="indexterm"/><span class="strong"><strong>density</strong></span>. Alternatively, you can set the density and let the physics engine calculate mass. It is usually more intuitive to set the mass.</li></ul></div><p>All right – enough with the textbook! Let us solidify our learning with some examples.</p><p>First, we want<a id="id129" class="indexterm"/> gravity to skip our bees. We will set their flight paths manually. We need the bees to be dynamic physics bodies in order to interact properly with other nodes, but we need these bodies to ignore gravity. For such instances, SpriteKit provides a property named <code class="literal">affectedByGravity</code>. Open <code class="literal">Bee.swift</code> and, at the bottom of the <code class="literal">spawn</code> function, add this code:</p><div class="informalexample"><pre class="programlisting">self.physicsBody?.affectedByGravity = false</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>The question mark after <code class="literal">physicsBody</code> is optional chaining. We need to unwrap <code class="literal">physicsBody</code>, since it is optional. If <code class="literal">physicsBody</code> is nil, the entire statement will return nil (instead of triggering an error). You can think of it as gracefully unwrapping an optional property with an inline statement.</p></div></div><p>Run the project. The bees should now hover in place as they did before we added their bodies. However, SpriteKit's physics simulation now affects them; they will react to impulses and collisions. Great, let us purposefully collide the bees.</p></div>
<div class="section" title="Bee meets bee"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Bee meets bee</h1></div></div></div><p>You may have noticed that we<a id="id130" class="indexterm"/> positioned <code class="literal">bee2</code> and <code class="literal">bee3</code> at the same height in the game world. We only need to push one of them horizontally to create a collision – perfect crash test dummies! We can use an <span class="strong"><strong>impulse</strong></span><a id="id131" class="indexterm"/> to create velocity for the outside bee.</p><p>Locate the <code class="literal">didMoveToView</code> function in <code class="literal">GameScene.swift</code>. At the bottom, below all of our spawn code, add this line:</p><div class="informalexample"><pre class="programlisting">bee2.physicsBody?.applyImpulse(CGVector(dx: -3, dy: 0))</pre></div><p>Run the project. You will see the outermost bee fly towards the middle and crash into the inner bee. This pushes the inner bee to the left and slows the first bee from the contact.</p><p>Attempt the same experiment with a variable: increased mass. Before the impulse line, add this code to adjust the mass of <code class="literal">bee2</code>:</p><div class="informalexample"><pre class="programlisting">bee2.physicsBody?.mass = 0.2</pre></div><p>Run the project. Hmm, our heavier bee does not move very far with the same impulse (it is a 200-gram bee, after all.) It eventually bumps into the inner bee, but it is not a very exciting collision. We will need to crank up the impulse to propel our beefier bee. Change the impulse line to use a <code class="literal">dx</code> value of <code class="literal">-15</code>:</p><div class="informalexample"><pre class="programlisting">bee2.physicsBody?.applyImpulse(CGVector(dx: -15, dy: 0))</pre></div><p>Run the project again. This<a id="id132" class="indexterm"/> time, our impulse provides enough energy to move the heavy bee in an interesting way. Notice how much energy the heavy bee transfers to the normal bee when they collide; the lighter bee shoots away after contact. Both bees possess enough momentum to eventually slide completely off the screen. Your simulator should look something like this screenshot, just before the bees slide off the screen:</p><div class="mediaobject"><img src="graphics/Image_B04532_03_07.jpg" alt="Bee meets bee"/></div><p>Before you move on, you may wish to experiment with the various physics properties that I outlined earlier in the chapter. You can create many collision variations; the physics simulation offers a lot of depth with out much effort.</p><div class="section" title="Impulse or force?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Impulse or force?</h2></div></div></div><p>You have several <a id="id133" class="indexterm"/>options for moving nodes with physics bodies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An impulse<a id="id134" class="indexterm"/> is an immediate, one-time change to a physics body's velocity. In our test, an impulse gave the bee its velocity, and it slowly bled speed to damping and its collision. Impulses are perfect for projectiles: missiles, bullets, disgruntled birds, and so on.</li><li class="listitem" style="list-style-type: disc">A force <a id="id135" class="indexterm"/>applies velocity for only one physics calculation cycle. When we use a force, we typically apply it before every frame. Forces are useful for rocket ships, cars, or anything else that is continually self-propelled.</li><li class="listitem" style="list-style-type: disc">You can <a id="id136" class="indexterm"/>also edit the <code class="literal">velocity</code> and <code class="literal">angularVelocity</code> properties of a body directly. This is useful for setting a manual velocity limit.</li></ul></div></div></div>
<div class="section" title="Checkpoint 3-B"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Checkpoint 3-B</h1></div></div></div><p>We have made a number of structural changes to our project in this chapter. Feel free to download my project to this point:</p><p>
<a class="ulink" href="http://www.thinkingswiftly.com/game-development-with-swift/chapter-3">http://www.thinkingswiftly.com/game-development-with-swift/chapter-3</a>
</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Summary</h1></div></div></div><p>We have made great strides in this chapter. Our new class organization will serve us well over the course of this book. We learned how to use protocols to enforce commonality across classes, encapsulated our game objects into distinct classes, and explored tiling textures over the width of the ground node. Finally, we cleaned out some of our previous learning code from <code class="literal">GameScene</code> and used the new class system to spawn all of our game objects.</p><p>We also applied the physics simulation to our game. We have only scratched the surface of the powerful physics system in SpriteKit – we will dive deeper into custom collision events in <a class="link" href="ch07.html" title="Chapter 7. Implementing Collision Events">Chapter 7</a>, <span class="emphasis"><em>Implementing Collision Events</em></span> – but we have already gained quite a bit of functionality. We explored the three types of physics bodies and studied the various physics properties you can use to fine-tune the physical behavior of your game objects. Then, we put all of our hard work into practice by bumping our bees together and watching the results.</p><p>Next, we will try several control schemes and move our player around the game world. This is an exciting addition; our project will begin to feel like a true game in <a class="link" href="ch04.html" title="Chapter 4. Adding Controls">Chapter 4</a>, <span class="emphasis"><em>Adding Controls</em></span>.</p></div></body></html>