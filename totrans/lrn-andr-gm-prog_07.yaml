- en: Adding Boundaries and Using Sprites to Create Explosions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our preceding chapter, we covered the part where we successfully detected
    collisions. Now that we have understood how to deal with collisions, we can play
    around with our knowledge and add some cool stuff to our game. This chapter will be
    pretty concise, and if you have understood the concept of collision detection
    properly, then this will be a breeze for you. Here''s what we will do in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a ground for our player as a boundary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect a collision between our player and rocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn an explosion sprite on the point where a collision takes place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Observe that from the preceding tasks, we have already accomplished our second task,
    so we have to focus on the first and third tasks. Let''s dive into creating a
    ground for our player because right now our player is simply going down infinitely.
    We will also add an upper boundary in order to contain our player within the screen,
    otherwise, our player would go right outside the screen. Again, we will divide
    this chapter into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding boundaries to our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sprites to create explosions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Adding boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are quite familiar with the process of creating a new class, we will
    simply create our two new classes for our upper and lower boundary and call them
    `UpperBoundary.java` and `LowerBoundary.java`, respectively. We have the following
    objectives for our boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: Make them appear at the top and bottom of our game screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a player collides with them, then reset the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these objectives in mind, we will move ahead to create boundaries for our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the classes for our boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before actually creating our boundaries, we will need an image sprite in order
    to make them visible on the screen. For this purpose, we will take a simple sprite
    with a plain color. Here''s the sprite that we will be using for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Our ground.png file
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will place this file in our `res/drawable` folder as we did for our
    previous image files. Once you are done with this, move on to the next part.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, let''s create our `UpperBoundary.java` class. Go ahead, create a new
    class and write the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are simply creating our boundary class with its constructor
    and `update()` and `draw()` functions. The constructor is pretty simple to understand
    here. Whenever we create an instance of our boundaries, we will pass in a sprite,
    the x y position, and the height. We will also set a speed in which the boundaries
    will move backward, giving an illusion that our player is moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all our previous game objects, this class also extends our main `GameObj`
    class. In a similar way, we will also create our `LowerBoundary.java` class. The
    only change we will make is in our `height` and `width` variable and the rest
    of the entire code remains the same as that of the `UpperBoundary.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note here that we are keeping the `height` constant since we want to spawn our
    bottom border as low as possible and thereby `200` is a safe limit for the same.
    You can experiment with these values as per your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our classes ready, it is time for us to bring them into our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating boundaries in our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will go step by step here since this part may get a bit tricky. We will have
    to deal with a lot of math calculations for our boundaries as well as lots and
    lots of new variables. Let's start by declaring some variables in our `GameView.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this part, we will be working only in our `GameView.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the variables required
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the new variables that we will declare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create our `upperBoundary` and `lowerBoundary` variables as `ArrayList` to
    keep a track of our actual game object on the screen, then we also create two
    integer variables--`maxBoundaryHeight` and `minBoundaryHeight`--to keep a track
    of the maximum and minimum heights for our upper boundary. We also create two
    Boolean variables--`upBound` and `lowBound`--if our boundaries go out of our specified
    minimum or maximum height. The `progressDenom` variable is created as an integer
    in order to create a cool pattern for our ground rather than just being plane.
    Finally, we have a `newGameCreated` Boolean variable, which will reset our game
    automatically if our player crashes with any object.
  prefs: []
  type: TYPE_NORMAL
- en: We are set with our variables. We will now move on to referencing our boundaries
    when the game is started.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing our boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we assigned a value to our reference in our rocks, we will do the same for
    both our boundaries. We will do so in our `surfaceCreated()` method by adding
    the variables marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Looks neat! Now comes the tricky part. We will have to write the update logic
    for both our boundaries. Don't confuse this with the `update()` method in our
    individual boundaries. That update method will simply make our ground move backward.
    We will also need to actually write the logic to spawn them on screen. Let's see
    how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be updating our upper boundaries on every 50th score and lower boundaries
    on every 40th score. Let''s write the code for our boundaries. This involves a
    lot of tricky mathematical calculations, so watch out. However, contradictory
    to that, every step is quite self-explanatory here. Here''s the base logic for
    our boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: Update on every 50th or 40th score
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our image onto the screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After every frame, call the `update()` method in our boundary class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the boundary goes out of screen, then remove it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either of the boundary exceeds its maximum or minimum value, then accordingly
    set its `upBound` or `lowBound` variable to either `true` or `false`, depending
    on its position
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the logic for our boundaries, and the same is repeated for both our
    upper and lower boundaries. This code block is written after our `draw()` method.
    We write the code for them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to actually draw our boundaries on our screen, so we will go to
    our `draw()` method to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing our boundaries on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with our previous images, we use the `draw()` method to write our code for
    displaying our ground on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even this part is taken care of for now. Now, we have to look at the collision
    part of our ground. We need to detect a collision on our ground with the player.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a collision between the ground and player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have already created our collision method, we simply go ahead and
    use the function. We already have a clear understanding of how a collision works
    because of the previous chapter, so we write the following code in our `update()`
    method of our `GameView.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Collision detection between the player and the ground is completed. Now, we
    also have to assign our maximum and minimum boundary heights as well as tweak
    them as per our `progressDenom`.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum and minimum boundary heights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `update()` method, we will assign these values based on the player score
    and `progressDenom`. We will also use this method to call our `updateUpperBound()`
    and `updateLowerBound()` methods that we created earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We're almost there. Now, the only thing remaining to create is our `newGame()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a `newGame()` function that will get called every time the player
    crashes with an object. We''re doing nothing, but just resetting our objects as
    they were initially when we started the game. So, here''s how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we still have to call this function from somewhere. As per our objective,
    we need it to be called after our player crashes. So, we add an else block in
    our update function after our `if(playerCharacter.getPlaying())` condition, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready with our code. Let''s review our code for changes marked in bold
    and check whether you missed any step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build and run your game; we have our boundaries ready!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Our player won't fall down infinitely now
  prefs: []
  type: TYPE_NORMAL
- en: We can now proceed to our next part of creating explosions on our screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating explosions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re almost done with our game here, and only the following two parts are
    remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding particle effects of an explosion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying our score on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will divide this part into two sections wherein we will finish half of our
    explosions in this chapter, and the further half will be completed along with
    the UI of our game that will then conclude this game. So, let''s get started with
    this now. For our explosion, we will be needing a sprite sheet. We will use the
    following sprite sheet for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Our explosion sprite sheet
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new class named `ExplosionEffect.java`. Note here that we
    will not be extending this file to our `GameObj` file since we don''t need any
    of the collision components of this image. We will simply spawn it on the screen
    and make it stay at the same place. So, open up your `ExplosionEffect.java` file
    and let''s define our variables first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just need the `x`, `y` coordinates and the `height` and `width`
    as integer values. Also, observe here that we will be working with both rows and
    columns in this sprite sheet as opposed to our previous sprites where we just
    used a singular row or column and hence we will need an extra variable `row` to
    help us out with this problem. We need our `AnimationClass` variable in order
    to run our animation and, last but not the least, our `Bitmap spriteSheet` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we will define the constructor for our class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you observe this closely, you will see that we are simply repeating our steps
    that we did for our previous game objects, except that we have an extra `row`
    variable here that we defined earlier, and this will help us scan through the
    rows of our sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are left with the `draw()` and `update()` methods for this class. We
    will also make a method to `getHeight()` of the sprite sheet in order for us to
    work on our calculations when we use this to actually spawn our explosion effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done with these, ensure that your `ExplosionEffect.java` file
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are all set with our `ExplosionEffect.java` file; that's it for this chapter. We
    are ready with our class for our explosion, and we will start creating explosion
    effects on our screen after our rocks collide with our player in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to create boundaries for our game and also created our explosion
    effect file with the required components needed along with its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a proper upper and lower boundary in our game and we also have created
    our foundation for adding explosions in our game after our player collides with
    rocks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will spawn the explosion on the screen after our player
    collides with the rock and display our score on the screen as a User Interface
    component.
  prefs: []
  type: TYPE_NORMAL
