- en: Chapter 7\. Tailoring Your Personal Android System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the most popular custom Android ROMs.
    We started to dive deep and analyze those parts of the system involved in the
    modding process, to effectively understand where to customize and how to do it,
    mastering the Android modding toolset.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go even further, diving deeper into every single aspect
    of a ROM, using practical examples to show how to customize and increase the performance
    of your ROM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics of this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Android framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new Android applications to the build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new Linux-native apps, using the Android source code, or editing an existing
    binary ROM image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the system to better support custom hardware, with focus on the application
    layer and on the kernel layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving over the air updates – OTA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Android device is, by design, able to receive updates over time. These
    can be system updates—when a new Android version has been released, or security
    updates—when some critical vulnerability has been fixed and Google is distributing
    the patch. Once the update has been received, every device is able to decompress
    and apply this update, following the required procedure.
  prefs: []
  type: TYPE_NORMAL
- en: These types of updates are called OTA, or over the air updates, because they
    can be downloaded and applied by the Android device itself, without the support
    of a host PC. These updates are typically going to patch operating system features,
    working in the so-called *read-only* part of the system. No user app will ever
    be affected by these updates— apps installed via the Google Play Store are completely
    safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android will asynchronously notify you when a new OTA is available. Most of
    the time you will receive a notification if connected to a Wi-Fi network and if
    your battery is above 50% to ensure a possible fast download and a safe updating
    process. When an update is available, a new system notification will appear in
    the Status Bar notification area. Once the notification is clicked, Android will
    show you details about the update, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'OTA updates can be grouped into these three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Full system updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental system updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single update packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the whole system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can guess, this family of updates will bring up the whole system to a
    new version. They contain a whole system image, with `system`, `boot`, and `recovery`
    partitions.
  prefs: []
  type: TYPE_NORMAL
- en: To install these updates, the system needs to be able to properly boot the Recovery
    system and simply read and apply the update file.
  prefs: []
  type: TYPE_NORMAL
- en: Even if it is a full system update, the user partition is not affected and no
    app or user data is erased.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the system incrementally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These updates are somewhat smaller than the full system ones and their goal
    is to apply patches to specific system components. Being tailored for a specific
    version of the operating system and a specific version of the file to be patched,
    these updates cannot be randomly applied to available devices.
  prefs: []
  type: TYPE_NORMAL
- en: To enforce this constraint, before installing such update files, the system
    checks for the correct file versions and any other possible requirement needed
    by the update. If some requirement is not satisfied, Android notifies the user
    with an error icon and the update procedure is aborted.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a single component update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An OTA update package is a standard `.zip` file containing a `META-INF/com/Google/Android/update-binary`
    file. Once Android has verified the ZIP file signature, it decompresses the file
    in `/tmp` and executes it. A few arguments are passed to the command line. These
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Update-binary API version number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command line file descriptor, to communicate with the command line, to send
    progress updates to the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same folder as `update-binary`, there is another interesting file—`updater-binary`.
    This file contains the sequence of actions to perform to install the update. All
    these actions are expressed in `Edify`, a custom **Domain Specific Language**
    (**DSL**) that Google created for this task. As is usual in the open source world,
    Google documented everything about this language and you can find the documentation
    in `/bootable/recovery/edify`.
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that Recovery can execute every statically-linked binary named
    `update-library`. Leveraging this opportunity, lots of developers prefer to use
    different languages, which they are more familiar with, to perform all the operations
    needed to apply the update.
  prefs: []
  type: TYPE_NORMAL
- en: In the next pages we will see examples of both possible scenarios, using Google's
    Edify or a custom solution.
  prefs: []
  type: TYPE_NORMAL
- en: Creating over the air updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Google provided plenty of developer tools to generate the different types of
    OTA. If you want to generate a *Full Update OTA*, the following two steps are
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a ZIP file containing the full update files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the OTA package with all the necessary toolsets for the update
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To generate the `zip` file containing the chosen target files, navigate to
    the `root` folder of the AOSP sources and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the process has been successful, we should have the `zip` file containing
    the target files in the directory `dist_output`. As an example, let''s try listing
    the folder content with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we should see a `.zip` file that will also have in its name the name of
    the target we are compiling for.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you only need to generate the OTA package containing all the
    necessary files for the update. Among the available tools, there''s a utility
    that will help us do so, through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown here, you''ll find the screen with the generated OTA package and the
    command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have our OTA package ready to be installed on *development devices*,
    because the default OTA is signed with *test keys*. If you want to provide your
    users with an installable OTA package, you need to sign the OTA with your *own
    private keys*, using the specific option provided by the OTA-generation tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate an **incremental OTA**, the procedure is nearly the same,
    except that you also need to indicate the ZIP file containing the previous OTA
    version. The command will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As for our previous example, you'll get a ZIP file containing the incremental
    backup.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are no predefined tools for the composition of the `Update OTA`
    package, as it's up to us to decide what to install/update through the update
    script, which we will examine in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: OTA internals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As anticipated in the previous section, an OTA package contains a binary file
    in its folder tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This binary file is generated by Android's build system, in the `bootable/recovery/updater`
    folder, and it is used to properly perform the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary contains internal routines and an interpreter for the scripting
    language called `Edify`. This language supports a set of ad hoc commands in order
    to allow the correct execution of a system update without affecting the integrity
    of the system itself. You can find an example of an Edify script in one of the
    OTA ZIP files you have just generated, at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Shown here is an example screenshot for an Edify script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Usually, we don't need to manually write any Edify code, because in a standard
    scenario there are automated tools that generate the correct OTA packages containing
    all the necessary files, but it could be useful to manually modify them when debugging,
    or in case we are building our custom ROM from binaries and we need to customize
    the installation on the flash memory of the relative files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the Edify syntax in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Edify syntax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first thing to know is that Edify evaluates every expression as all string
    type values. An empty string is considered as `false` in a Boolean context, while
    any other value is considered as `true`. To recapitulate, Edify supports all the
    following expression types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Every string that contains the following type of character, which of course
    are not reserved words, are considered as string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With reserved words, we refer to words such as `if else`, and `endif`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant strings can also be written using *double-quotes*, in order to create
    strings with spaces or other characters not listed in the previous example, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be respectively written as follows for the new line and tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As an escape character, we use `"` and `\` in a string written with *double-quotes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operators are simply short-circuiting, that is, the right side isn''t even
    considered if the logic result is determined by the left side of the expression.
    The syntax can be very concise, as shown in the following snippet; the two lines
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `;` character is a sequence point, meaning that what's at its left is considered
    before, and what's at its right is considered after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a richer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter contains all the functions that are necessary to complete a
    correct update. Unless differently specified, the functions usually render `true`
    in case of success and `false` in case of error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The language provides utility methods to control the flow and manage edge situations.
    If, for example, we want to trigger an error to block the installation, we can
    use the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can expect, in case you want to add a new feature, you can do that by
    modifying the sources, but before that, let''s have a look at some of the most
    useful functions already available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abort([msg])`: This method gives you the opportunity to abort the currently
    running script. It also takes a string argument, `msg`, that can be shown to the
    user as further information about the abort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert(expr[, expr, ...])`: This method takes a list of expressions as argument
    and evaluates them one by one. If any of these expressions fail, or returns `false`,
    the whole script execution stops. The system also shows an "Assert failed" message
    and the assert text that just failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply_patch(src_file, tgt_file, tgt_sha1, tgt_size, patch1_sha1, patch1_blob,
    [...])`: This method takes a `patch1_blob` file and applies it as a binary patch
    to the source file `src_file` to produce the target `tgt_file`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete_recursive([dirname, ...])`: This function takes a list of folder names
    as argument and deletes them, also deleting every single file they contain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file_getprop(filename, key)`: This method can be considered as a properties
    file inspector. It takes a couple of arguments, a filename and a key, and scans
    the file as if it were a property file, looking for the provided key. If the key
    is found, its value is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format(fs_type, partition_type, location, fs_size, mount_point)`: This method
    provides a powerful way to format partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifelse(cond, e1[, e2])`: This method represents the common `it-then-else`
    computer science statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_mounted(mount_point)`: This method helps to detect mounted partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mount(fs_type, partition_type, name, mount_point)`: This method mounts a filesystem
    of `fs_type` at `mount_point`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rename(src_filename, tgt_filename)`: This method takes two arguments, to perform
    a renaming from `src_filename` to `tgt_filename`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run_program(path[, arg, ...])`: This method executes the binary at path, passing
    `args`, and it returns the program''s exit status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sleep(secs)`: This method takes an integer, `secs`, as an argument and pauses
    the execution for `secs` seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symlink(target[, source, ...])`: This method takes a `target` file and a list
    of `sources` and creates all sources as *symlinks* to target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unmount(mount_point)`: This is the counterpart of `mount`. This method unmounts
    the filesystem mounted at `mount_point`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a subset of all the available commands. If you are curious about
    the whole list, you can check the official Google documentation at [http://source.android.com/devices/tech/ota/inside_packages.html](http://source.android.com/devices/tech/ota/inside_packages.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now able to modify—or create from scratch—an *Edify* script for an Update
    installation. This knowledge will turn out to be very useful with the custom ROM,
    especially when the sources are not available, in case you want to modify the
    system through a custom recovery, installing specific files in the read-only system
    partitions.
  prefs: []
  type: TYPE_NORMAL
- en: OTA for custom ROM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As already anticipated, out of the OTA concept we get a convenient system for
    the custom ROM installation. The reason for this is that most custom ROMs are
    distributed as *Update* ZIP packages, to be fed to the custom Recovery, which
    will then take care of the package installation in the system. Analyzing the OTA
    structure—as we did in the previous section—we can intuitively understand how
    to organize a specific package to install a modified version of Android. In fact,
    through an ad hoc Edify script, it is possible to format and reinstall all the
    files that are contained in any system partition, in order to distribute your
    own modified Android version.
  prefs: []
  type: TYPE_NORMAL
- en: This task is left as an exercise to the reader as it can be achieved with the
    knowledge acquired so far.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced ROM customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, you have made your first steps within the custom ROMs
    world; we have discovered what's already available online and analyzed the most
    characteristic aspects in detail. In this chapter we will go in deep and learn
    how to modify the most internal parts of Android's framework.
  prefs: []
  type: TYPE_NORMAL
- en: Custom ROMs are often associated with those "*hackers*" who add the most unexpected
    features and then share everything online, but it doesn't always happen like that.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the previous chapters, many device manufacturers propose their
    own modified Android version, which is nothing but an Android custom ROM.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important aspect, as this book is addressed both to the previously
    mentioned *hackers* and to those who use all this knowledge in their daily work—a
    *hacker* will often work with binary ROM, and rarely with sources, while the professional
    will certainly have the sources at their disposal, as well as all the relevant
    tools to make the development of additional features possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following section, we will try to explain the two different approaches
    to customization in a simple way. These are: from the sources and from binary.'
  prefs: []
  type: TYPE_NORMAL
- en: ROM customization from binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To modify a ROM starting from binary, we regrettably have few available choices.
    As we don't have the sources to generate the different images, we can only modify
    the filesystem, adding utilities and new apps, or making aesthetic changes to
    colors and icons, starting from the framework binary.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the tools we saw in the previous chapter and apply all the required
    changes, then, when we are done, we can generate a package `update.zip` with the
    correct Edify script, that allows the installation of new features.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we can also add new applications both in *Java* and *C*, or enhance
    the system image adding a `BASH` environment, or copy in the `/system` partition
    updated application like *Gmail* or *Maps*, that might eat space in the `/data`
    partition.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the possibilities are limited in this kind of scenario, starting from
    a binary image, we can try some optimization and tweak, as we will see in the
    upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing ROM from source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have the source code, you can do almost anything, but as you know,
  prefs: []
  type: TYPE_NORMAL
- en: '*"With great power comes great responsibility"—Uncle Ben, Spider-Man.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The first step is to identify the part we want to modify, and consequently,
    its repository. Let''s take, for example Android''s `Settings` menu, which we
    will keep as a master example to modify our ROM. The source code of `Settings.apk`
    is in the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once the source code path, and so, the repository, have been identified, the
    best way to start your customization is to mirror the repository on your server,
    where you will then operate the changes to the code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make sure your repository is part of the Android system, you need
    to update the `manifest.xml`, so that when you sync again with "*repo*", you will
    clone your own `Settings` version, and not Android's.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you need to create another personal repository, where you''ll keep
    your manifest, modifying the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you see where the code will be locally downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, its remote location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that there isn''t a link in the remote position, because we''ll
    use the default one, defined at the top as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `fetch` refers to the parent folder "`..`" instead of an absolute
    path. The best thing to do to simplify our work is to add a remote as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we have defined our remote, and we only have to fix the `Settings`
    line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all the necessary configuration in place to proceed with the development:
    we have our separate repository, where we can develop the code, but most importantly,
    thanks to the modification in the manifest, we don''t have to touch the remaining
    managed parts of the system managed by Google, so that the update of other components
    of Google is made simple and smooth.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new packages to Android's build system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to add a package to Android''s build system, so that, when
    we perform our build, it will be automatically compiled and added to the ROM,
    just as it happens with other applications. We can work on two levels: adding
    a system app as a compiled binary app, written in *C*, or adding a system app
    as an *Application Layer* that runs on Android Dalvik Machine and ships as an
    APK.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create an Android application, the first thing to do is to prepare
    the environment for writing the code and generate the APK file that will be executed
    by Android's internal virtual machine. We are going to develop a standard Android
    app using Java, Android Studio, and Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a package by binary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While developing a custom ROM, you might need to add binary executables or applications
    you don't have the source code for. For example, you might want to add a particular
    application as the default application for a specific task, so that when the user
    boots the ROM, the application is already installed into the system. We can refer
    to the `Facebook` application as an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: To successfully add a new application to your system image, you just need to
    get the `APK` file and copy it in the right ROM directory. You can do that with
    an `update.zip file`, adding the right Edify script, which will install the new
    APK—as we'll see later in more detail—or, as already anticipated in the previous
    chapters, you can perform the entire operation through Android's build system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to write the correct `Android.mk`; let''s imagine we have
    our APK file at the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your APK is in place, you need to create an `Android.mk` file and add
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Analyzing the snippet, you will notice a couple of placeholders you will need
    to replace with your actual values. After that you''ll need to create a new entry
    in the `commons.mk` file, situated in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new APK installation-related line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you only have to recompile the AOSP to find the new APK in the
    system, preinstalled among the other system apps.
  prefs: []
  type: TYPE_NORMAL
- en: Another very common and handy way to add a precompiled app to our ROM is doing
    it with the help of the Android update system. Provided that you have already
    installed a custom recovery image—which will make all your operations easier—to
    add a new binary to Android's `/system/xbin` directory, you only need to create
    an `update.zip` with an Edify script inside to perform the right operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you''ll see an Edify script that performs a precompiled app installation
    in the target folder `/system/xbin`. The script is contained in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The script contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The internal structure of the `update.zip` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once the update package has been created, you only need to apply it through
    the recovery custom that is installed on your device. As you have surely noted,
    the same approach, "*edify script + update.zip + recovery*", is used over and
    over, and this shows how Android's update system is solid and flexible and comes
    in handy for a huge number of tasks and scenarios; but we can go even further.
  prefs: []
  type: TYPE_NORMAL
- en: There's yet another procedure, that we might define as "*dirty*", which allows
    even more complex installations. You would still use the procedure of the update
    package, but instead of using the Edify syntax, which might often be inconvenient
    and not so powerful for advanced scenarios, you will redefine the content of the
    `update-script` binary.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, this binary, that by default contains the interpreter to execute
    the Edify script, is launched by the system. This "*dirty*" technique consists
    of replacing this binary with a shell script that performs the operations you
    need. With this alternative approach, you have the very powerful shell scripting
    language at your disposal, and let's consider that some recovery custom includes
    the Bash—as shell—which will hence work as the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the `busybox` installation in the Android system,
    using an ad hoc `update.zip`, with a shell script that operates the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will replace our `update-script` and will operate the binary installation.
    As a result, the update package will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we can perform the most complex installations, and it turns out to be
    one of the most used methods by the Android ROM "modders".
  prefs: []
  type: TYPE_NORMAL
- en: Adding packages by source code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In system from source. In this section, we will make a real example by creating
    a `Hello World` application, with the help of Android Studio, which we will import
    and compile together with the entire Android system.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a base application with Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the installation instructions, please read the following link: [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When your system is ready, launch the IDE and create a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous image shows how to specify an app name, a domain, and a path folder
    for our Android project. Once you have entered all the data, you can click **Next**
    and move to the API level selection, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the previous image, by default Android Studio will target API 16
    to cover more than 95% of the market. This value doesn''t really matter in our
    scenario, because this app will be installed only in our custom ROM, that is probably
    Android 6\. Let''s move to the next screen—Activity Picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous image shows the plethora of possible activities we can easily
    add to our apps. For this example, we will use just an **Empty Activity**, to
    keep things simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous image shows how to rename our brand new activity—`MainActivity`
    will do the job flawlessly. Just click **Finish** and Android Studio will bring
    you to the editor screen to add some code to your `Hello, World` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The previous image shows how to display a `Toast` message when our app starts;
    nothing fancy, but it's enough to give you an idea about how things can be made
    easy with the proper tool set and knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your app is ready, just click the **Run** button and start building your
    APK file. Test it as much as you can and when you are satisfied with the results,
    copy the source code to the AOSP source code folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With your current know-how, you are able to update the manifest file to add
    this app to the Android build system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final touch is the `Android.mk` file. For this `Hello,World` example, just
    create a new file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using Android's build system, you are now able to build and package your own
    Android apps for your custom ROM.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Android framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In these customizations were related to the User Interface. UI customization
    is a tricky topic due to the *personal taste* factor involved: many users love
    a "*pure Android*" UI, many other users love the idea of a "*different Android*"
    UI, far from the mainstream UI experience.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are giving you free will and the chance to choose between
    a vanilla Android and a customized one. You will learn how to make small customizations,
    to the status bar or to the colors, for example, or big customizations, like adding
    a new item to the **Settings** menu to properly set up the custom features of
    your custom ROM.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the boot sequence UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The graphical appearance of the ¾¦+ boot sequence is definitely one of the most
    popular customizations you'd like to do and often the one that your users will
    ask for and will love.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the boot sequence, a standard Android device will show:'
  prefs: []
  type: TYPE_NORMAL
- en: The Splash image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Boot animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Splash image is a static image that the system shows in the first seconds
    after Power On. On a Google Nexus device, the Splash image looks like the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The image shows the Google brand and a lock. As we already learned, the lock
    represents the status of the *bootloader*—locked or unlocked. The Splash image
    is associated to the initial phases of the boot—typically, the system shows the
    Splash image from the Power On to the completion of the bootloader and Linux kernel
    setup sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the ¾¦+ Splash image is no easy thing, because even if theoretically
    it's just an image, or a sequence of images, stored on the NAND memory, every
    manufacturer uses a custom approach to accomplish this goal and they are very
    unwilling to document how we could revert their work. What is extremely easy for
    them, having plenty of tools and knowledge about their system, becomes hours and
    hours of reverse engineering for us, with unpredictable results and effects on
    the stability of the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: Turning our attention to the boot animation, we can see that the boot animation
    is that sequence of images, most of the time animated, that any Android device
    shows during the startup sequence, right after the Splash image and until the
    Android system completes boot. Many manufacturers customize this animation to
    enforce their brand, and you will do the same with your *own brand*. From a technical
    point of view, the moment you see the boot animation, the kernel has been loaded,
    the partitions have been mounted, and Android is starting to boot.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence of images is way easier to customize compared to the Splash image.
    This is due to the fact that, even if the majority of the device has a custom
    boot animation, every single one of them respect very strict known requirements—that
    means that we have documentation for this!
  prefs: []
  type: TYPE_NORMAL
- en: As with lots of Android components, the boot animation comes as a standard `.zip`
    file and is placed in the `/system/media/` folder or in the `/data/local/`. All
    we need to customize the boot animation is to grab it, edit it as we like, and
    place it back—piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the file, we can use our trusted `adb`. Fire up your terminal and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if the file is not there, try the second possible location, as we
    said previously. Once you have the file on your host computer, you can decompress
    it and you will see the same folder structure as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All those `part*` folders contain the images that create the animation, and
    the `desc.txt` file contains the instructions to properly perform the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `desc.txt` file with your preferred text editor and you will see something
    like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first row specifies the resolution and the frame rate at which the animation
    will be displayed. Lines `2` to `6` specify how to show the different parts of
    the animation.
  prefs: []
  type: TYPE_NORMAL
- en: The first letter, "`c`", stands for "continue", and instructs the system to
    keep playing the sequence even if the boot sequence is completed.
  prefs: []
  type: TYPE_NORMAL
- en: The first number specifies how many times the part has to be repeated. In the
    example, just once, or infinite time (using 0 as the value to indicate an infinite
    loop). The second number specifies how many seconds will be waited before starting
    the next part. The last token of the row specifies the folder containing the images
    to show to create the animated sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the inner structure of the `bootanimation.zip` file
    and how to set up the sequence, it's time to be creative and replace all those
    boring images to create your own awesome animation!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are satisfied, it''s time to create a new `bootanimation.zip file`.
    Fire up your terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Carefully, replace `partx` with the correct sequence of folders you have in
    your animated sequence. To try out your brand new boot animation, just upload
    the `zip` file to `/data/local/` folder using `adb`. You could even create a custom
    `update.zip` and flash it to your device using Recovery. It's up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'FFMPEG is a handy tool to extract images from a video to create your animated
    sequence. Fire up a terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command specifies a few interesting parameters: `-r 1` to capture
    a frame every second, `-s` to specify a resolution for the final images, and `-f
    image2` to actually capture a frame and save it as an image. As always, you can
    refer to `–h` for further documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Android Settings menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One great feature of Android is modularity: most of the system features are
    actually Android apps, developed and maintained separately. The Android `Settings`
    menu, for instance, is just an Android app itself, called `Settings.apk`, and,
    being part of the AOSP, can be freely customized, according to our needs. In the
    next pages, you will learn how to work on `Settings.apk` to add your custom menu
    item.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal emulator, and from your `WORKING_DIRECTORY` containing Android
    source code, navigate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This folder contains the source code of the vanilla `Settings` menu; this is
    your starting point for the customization.
  prefs: []
  type: TYPE_NORMAL
- en: This is a crucial example, because, when you are working on a custom ROM, you
    are improving the system, adding new features, or enhancing existing ones. Your
    new features will probably need some level of setup and placing all the possible
    configuration options where the user expects them, that is, the `Setting`s menu,
    which is a fundamental point for a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the vanilla Android `Settings` menu, the object of
    our customization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are in the `Settings` menu app folder, `packages/apps/Settings`, you
    can start editing files to add your new menu item. Let''s start with adding a
    few strings. With your preferred editor—Android Studio, Atom, SublimeText, and
    so on—edit `res/values/strings.xml` and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `strings.xml` file contains the list of every text string used in the `Settings`
    app; it's the perfect starting point for your customization and gives you an idea
    about naming conventions and structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are satisfied with the string file, create a new `.java` file named
    `CustomSettings.java` and place it in the `src/com/android/settings` folder. This
    will contain all the logic we need. The following image shows a snippet of a custom
    `PreferenceFragment` you can create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This `Fragment` will load a specific layout file that you need to create. Let''s
    call it `custom_settings.xml` and populate it as shown in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you need to add a few lines to the `AndroidManifest.xml`. Navigate to the
    `root` folder and edit the `AndroidManifest.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to the main `src/` folder and open `Settings.java`. This file contains
    every `Activity` available in the `Settings` menu. Here you can add your own `Activity`,
    as shown in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `src/` contains a `SettingsActivity.java` file. At the beginning of this
    you will find a field, `String` array, named `ENTRY_FRAGMENTS`. These are all
    the `Fragment`s that can be loaded by the `Activity` files in the `Settings` menu.
    The list is quite impressive, and on Android Marshmallow, it contains about 70
    `Fragments`; in your Android version, it will contain one more entry: yours. Add
    your `CustomSettings` class to the array, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are almost there. The next thing we need to do is compile the new package
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the new package, we can create a new update file and flash
    it using Recovery. On the next boot, we will see our brand new menu item in the
    **Settings** screen, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enhancing the system performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lots of the custom ROMs that you can find on the Net bring performance enhancements,
    extended battery life, and lots of small tweaks. Most of these enhancements can
    be achieved with a surgical tuning of the `build.prop` file.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the system property file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android `build.prop` file contains details about a variety of system settings
    that are applied to the system during the boot sequence. Before diving into its
    customization, we need an overview about its internal structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and connect to your device using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `/system` folder and open the `build.prop` file. The content
    will look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can guess, parts of these instructions are specific for every device,
    but a few of them are quite common. We surely have device model name, brand, codename
    for product, device and board, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these common values can be easily edited to obtain interesting behavioral
    changes in our system. For instance, you have probably noticed the tiny, but perceivable,
    delay that happens right before the smartphone starts ringing, when you receive
    a phone call. That delay can be removed by editing just a few lines in the `build.prop`
    file. Scan the file and look for these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Simply replace whatever value is assigned to them with a nice `0` (zero) and
    you can say goodbye to the delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ever wondered why you cannot rotate the screen when the phone is displaying
    the lock screen or the application launcher? No more wondering. Look for these
    two lines and replace the existing properties with the new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you want to rotate your device more than 180 degrees? Enable a 270 degree
    rotation with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Another UI trick we can achieve with a single line edit is changing the LCD
    density value. Search for the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `XXX` with the value you want to try. Changing this value will produce
    a resizing of the system icons and an increase of the screen space: the smaller
    the value you set, the bigger the amount of free space you get. Unfortunately,
    there is no exact science here and a little *trial-and-error* is inevitable, so
    try to experiment with a few values until you find your preferred setup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android devices are getting more powerful every day, but, back in the day,
    the available CPU power was very limited. To guarantee satisfactory performance
    and user experience, Android used smart tweaks, like the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The previous value alters the rendering quality of JPEG files. Even if it was
    useful in the past, we can consider it unnecessary on last generation smartphones,
    and we can safely set it to `100` and enjoy images at 100% of their original quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your smartphone has physical navigation buttons, you can increase screen
    estate, removing the navigation softkeys at the bottom of the screen by setting
    the next property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If your device has no physical key, you can still remove the softkeys and use
    gesture to navigate; check out the Google Play Store for gesture apps, like *All
    in one Gestures*. Continuing on the "screen estate" topic, you can remove the
    `debug mode` icon in the system notification bar with the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'These last two tweaks refer to networking settings. The first one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This line configures how many seconds will be between every automatic Wi-Fi
    scan. Android performs automatic Wi-Fi scans by default, looking for an open network
    to connect or just to increase the precision of the navigation system. You can
    increase or decrease the frequency of these scans, trying to achieve the perfect
    balance between a higher precision of navigation and a longer battery life. The
    second networking tweak gives you the opportunity to set a default DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is extremely useful in countries in which the government filters Internet
    websites according to their IP addresses. Using the DNS IPs shown in the previous
    snippet, Google's DNS servers, you will be able to bypass this kind of censorship.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom init sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Linux legacy is still strong in a few key aspects of the Android architecture.
    One of the most interesting ones is the possibility to execute custom scripts
    during initialization time. If you are familiar with Linux systems, you know about
    the `/etc/init.d` folder. This system folder contains a collection of scripts
    that can be executed during system startup. To achieve the same behavior on Android,
    we can use `busybox` and its `run-parts` utility. This utility takes a folder
    as an argument and executes every script contained in this folder. For instance,
    the following command will execute every script contained in `the /system/etc/init.d
    folder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To properly copy Linux `init.d` behavior, we want to be able to execute the
    scripts in a rigorous order. You can achieve this with clever file naming. Just
    rename your scripts and prepend a number, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, the `01settings` script will be executed before the
    `02optinimations` script, and so on. Now that you have a collection of ordered
    scripts and you know how to execute them one by one, you need to edit the `install-recovery.sh`
    file we saw in the previous chapters and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Advanced Linux kernel modding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you think about customizing the core of an Android system, you immediately
    think about customizing the Linux kernel. It manages CPU, sensors, radio, and
    display, and it's the starting point of every great system customization. As we
    already saw, modifying the kernel is no easy job, but with the right mindset,
    knowledge, and toolset, it can be a satisfying experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every embedded system has its own customization possibilities and, when it
    comes to Android, most of the effort is focused on customizing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Governors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O schedulers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU overclocking/underclocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into CPU frequency management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In work, and how you can pick a different one for different scenarios. In this
    section, you will learn how to customize existing governors and how to add new
    ones to your systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *governor*, or CPU frequency manager, describes how the CPU behaves, based
    on specific environmental factors.
  prefs: []
  type: TYPE_NORMAL
- en: A typical general purpose governor would decrease the number of active cores
    and their working frequency when the system load is low and push the CPU to full
    power and full speed when the system is in need of high performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard Linux kernel provides the following governors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On-demand**: This is the default governor on most of the kernels on the market.
    It''s considered a *balanced* governor because it can guarantee the system to
    be reactive, quickly increasing the CPU frequency when needed. The truth is that,
    being so eager to increase the CPU frequency, this governor makes no real evaluation
    about the CPU power that is actually needed. The on-demand governor does not consider
    the actual system load; instead it just increases the CPU frequency to the max
    when it is triggered and then slowly decreases it if not needed. As you can see,
    this does not work well in a "battery saving" scenario: it is pushing to top speed
    every time the system thinks it is going to need more power, without a deeper
    analysis. This approach will surely guarantee a reactive device, but will definitely
    drain the battery very quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Powersave**: This is definitely the most effective way to save battery life,
    in a way. This governor sets the maximum CPU frequency to the lowest possible
    value. The battery will surely last "*an eternity*", but the device will be unusable:
    a 2 GHz Quad-core CPU can easily go down to 200 MHz, and if it stays there all
    the time, that''s just nonsense.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: This governor behaves as the exact opposite of the *Powersave*
    one: it sets the minimum CPU frequency to the maximum possible value to achieve
    maximum performance. Battery-wise, this will drain the battery in no time: a 2
    GHz Quad-core running all the time at full power is surely performing well, but
    the smartphone won''t last long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interactive**: This is a smarter version of the *On-demand* governor. Its
    goal is to provide a reactive CPU scaling without falling into on-demand pitfalls.
    The On-demand governor changes the CPU frequency according to preset values, without
    any specific analysis. The interactive governor, instead, continuously evaluates
    the system load and adjusts the CPU frequency accordingly, with a more linear
    CPU scaling curve: definitely a big pro. The whole CPU scaling analysis is not
    based on raw workload, but is performed according to the requested time. This
    approach guarantees system fluidity and better performance in a multimedia scenario,
    because the CPU won''t jump up and down in frequency, but will be steady during
    the whole necessary time, providing a constant framerate when required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conservative**: This governor is a smoother version of the On-demand governor.
    Unlike On-demand, the Conservative governor won''t push the CPU to the top frequency
    every single time, but will proceed through a series of CPU frequency steps, according
    to the CPU load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Userspace**: This is the most customizable and least "automatic" governor.
    It provides the user with the possibility to manually pick the desired frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a custom CPU frequency governor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a specific CPU behavior, or you simply want to dig deeper into kernel
    customization, you can create your own CPU governor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this task, you will need the kernel source code and to navigate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This folder contains every governor we saw in the previous section and every
    possible custom governor you are going to add or that your device manufacturer
    already added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new governor, creating a `.c` file in this folder, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the file in place, you need to add it to the file mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We make changes as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done with the `Kconfig`, edit the `Makefile` and add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last step, edit the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Around line 400, there is a list of currently available governors, as shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following the same pattern, let''s add your new governor reference, using the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Mission completed: your new governor is now available and ready to be integrated
    in your next kernel build. Try to run `menuconfig` and navigate to the governor
    screen; you will be able to enable it and set it as the default governor.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring I/O schedulers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I/O schedulers specify how I/O-bound operations must be performed and balanced
    among CPU cores. Android comes with a default set of I/O schedulers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Noop**: This can be barely considered a scheduler. Practically speaking,
    it has no effect on the tasks list: it just queues them as they come in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIO**: This is the first real scheduler. Even if it does no task reordering,
    it guarantees the smallest possible latency from the moment the task is enqueued
    and the moment it is performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CFQ**: This scheduler orders tasks in separated queues, according to specific
    categories, and assigns an execution time window to every queue. The window size
    depends on the priority assigned to the tasks involved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BFQ**: This scheduler is similar to the CFQ scheduler, but it uses disk bandwidth
    windows instead of time windows to group and schedule tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anticipatory**: This scheduler uses prediction techniques to group and schedule
    tasks, pausing executions for a short time period and waiting for a possible new
    task to be added to a specific queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROW**: This scheduler is based on the "*read over write*" rule: every reading
    task has priority over writing tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deadline**: This scheduler guarantees termination for the enqueued tasks,
    trying to avoid "starvation" scenarios. *Starvation* is a well-known concept in
    computer science and applies to resource management. Imagine that *N* processes
    want to use the same shared resource. The shared resource can be used by one process
    at a time, and processes alternate according to their priority. What is going
    to happen if a low-priority process is asking for the resource, but the resource
    never becomes available due to other high-priority processes using it? The low-priority
    process will wait forever for the resource and never get to enjoy it. In computer
    science terminology, it will *starve*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every available scheduler is stored in the following folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Creating an I/O scheduler can be challenging and it's beyond the purpose of
    this book. What we can do is point you in the right direction and get you curious
    about the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the writing of this book, we were lucky enough to have a look at the
    upcoming Android N. The new version will probably be available at the end of 2016
    as a stable release, after a few months of public *developer preview*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android N introduces a few interesting features, like the "*Multi-Window*"
    mode shown in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At Google, they are very focused on user feedback, and they decided to introduce
    this feature into the official version after a few months of testing by Samsung.
    Most of us will recognize the Multi-Windows mode from the already-available Android
    ROM, by Samsung. In Android N, this will be available for everybody, on every
    Android device, with full support for both orientations, portrait and landscape,
    and even the possibility to *resize* the split windows by dragging the "separator
    line".
  prefs: []
  type: TYPE_NORMAL
- en: According to lots of blog posts, one of the most popular categories for Google
    Play Store apps is Caller ID filters. With Android N, this feature will be already
    available as a system feature as for the new "mobile data saving" feature that
    aims to reduce background data consumption for specific apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the new UI enhancements that comes with Android N is the possibility
    to add and remove action icons in the scroll down `quick settings` menu, as shown
    in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, the scroll down `notification` menu comes with a new notification
    design, that enables richer interactions, with quicker access to common actions,
    as shown in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Settings** section received a bit of love as well, with the new in-place
    notifications, like the one shown in the next image, that gives you the opportunity
    to disable or enable settings without navigating to the specific location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next image shows, also, the new `Navigation Drawer` that has been added
    to the `Setting` section, for a quicker navigation to the deeper menu levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An incredible amount of small fixes will be available in this new version, and
    lots of improvements are aiming to increase performance and battery life, as the
    most wanted *doze on the go*, that promises to be a game changer for Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter you learned how to effectively customize Android at different
    levels, following real-world examples. You now know how to programmatically create
    a custom ROM from source code, preparing a customized folder structure with every
    piece in place, ready to be assembled by Android's build system. You also know
    how to approach the customization task if you have an already-assembled system
    image, and how to customize and reassemble a binary image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will bring you *outside* the pure smartphone experience and
    will show you how Android is effectively becoming ubiquitous in our lives: Internet
    of Things, Android Auto and Android Wear, domotics, and entertainment are just
    a few of the scenarios in which we can currently find the *green droid*.'
  prefs: []
  type: TYPE_NORMAL
