<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Exploring Fragments, AppWidgets, and the System UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Exploring Fragments, AppWidgets, and the System UI</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and using a Fragment</li><li class="listitem" style="list-style-type: disc">Adding and removing Fragments during runtime</li><li class="listitem" style="list-style-type: disc">Passing data between Fragments</li><li class="listitem" style="list-style-type: disc">Creating a shortcut on the Home screen</li><li class="listitem" style="list-style-type: disc">Creating a Home screen widget</li><li class="listitem" style="list-style-type: disc">Adding Search to the Action Bar</li><li class="listitem" style="list-style-type: disc">Showing your app full screen</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Introduction</h1></div></div></div><p>With a firm understanding of layouts from <a class="link" href="ch02.html" title="Chapter 2. Layouts">Chapter 2</a>, <span class="emphasis"><em>Layouts</em></span>, we'll dig deeper into UI development with Fragments. Fragments are a way to separate your UI into smaller sections that can easily be reused. Think of Fragments as mini-activities, complete with their own classes, layouts, and lifecycle. Instead of designing your screen in one Activity Layout, possibly duplicating functionality across multiple layouts, you can break the screen into smaller, logical sections and turn them in to Fragments. Your Activity Layout can then reference one or multiple Fragments, as needed. The first three recipes will explore Fragments in-depth.</p><p>With an understanding of Fragments, we're ready to expand on our discussion of Widgets. In <a class="link" href="ch03.html" title="Chapter 3. Views, Widgets, and Styles">Chapter 3</a>, <span class="emphasis"><em>Views, Widgets, and Styles</em></span>, we discussed how to add widgets to your own app. Now, we'll look at how to create an App Widget so users can put their app on their Home screen.</p><p>The last recipes of the chapter will explore System UI options. We have a recipe for adding a <code class="literal">Search</code> option to the Action Bar using the Android <code class="literal">SearchManager</code> API. The last recipe shows Full Screen mode and several additional variations of altering the System UI.</p></div></div>
<div class="section" title="Creating and using a Fragment"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Creating and using a Fragment</h1></div></div></div><p>Android didn't always support<a id="id222" class="indexterm"/> Fragments. The early versions of Android were designed for <a id="id223" class="indexterm"/>phones, when screens had relatively small displays. It wasn't until Android started being used on tablets that there was a need to split the screen into smaller sections. Android 3.0 introduced the <code class="literal">Fragments</code> class and the Fragment Manager.</p><p>Along with a new class, also came the Fragment Lifecycle. The Fragment Lifecycle is similar to the Activity Lifecycle introduced in <a class="link" href="ch01.html" title="Chapter 1. Activities">Chapter 1</a>, <span class="emphasis"><em>Activities</em></span>, as most events parallel the Activity Lifecycle.</p><p>Here's a brief overview of the <a id="id224" class="indexterm"/>main callbacks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onAttach()</code>: It's<a id="id225" class="indexterm"/> called when the Fragment is associated with an Activity.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onCreate()</code>: It's<a id="id226" class="indexterm"/> called when the Fragment is first created.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onCreateView()</code>: It's<a id="id227" class="indexterm"/> called when the Fragment is about to be displayed for the first time.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onActivityCreated()</code>: It's<a id="id228" class="indexterm"/> called when the associated Activity is created.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onStart()</code>: It's called <a id="id229" class="indexterm"/>when the Fragment will become visible to the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onResume()</code>: It's <a id="id230" class="indexterm"/>called just before a Fragment is displayed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onPause()</code>: It's<a id="id231" class="indexterm"/> called when the Fragment is first suspended. The user may return to the Fragment, but this is where you should persist any user data.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onStop()</code>: It's <a id="id232" class="indexterm"/>called when the Fragment is no longer visible to the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onDestroyView()</code>: It's <a id="id233" class="indexterm"/>called to allow final cleanup.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onDetach()</code>: It's <a id="id234" class="indexterm"/>called when the Fragment is no longer<a id="id235" class="indexterm"/> associated with the Activity.</li></ul></div><p>For our first exercise, we will create a new Fragment derived from the standard <code class="literal">Fragment</code> class. But there are several other <code class="literal">Fragment</code> classes we could derive from, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DialogFragment</code>: It's used<a id="id236" class="indexterm"/> for creating a floating dialog</li><li class="listitem" style="list-style-type: disc"><code class="literal">ListFragment</code>: It's creates <a id="id237" class="indexterm"/>a <code class="literal">ListView</code> in a Fragment, similar to the <code class="literal">ListActivity</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">PreferenceFragment</code>: It's <a id="id238" class="indexterm"/>creates a list of Preference objects, commonly used for a Settings page</li></ul></div><p>In this recipe, we will walk through creating a basic Fragment derived from the <code class="literal">Fragment</code> class and include it in an Activity Layout.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec131"/>Getting ready</h2></div></div></div><p>Create a new project<a id="id239" class="indexterm"/> in Android Studio and call it: <code class="literal">CreateFragment</code>. Use the <a id="id240" class="indexterm"/>default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select the <span class="strong"><strong>Empty Activity</strong></span> option when prompted for the Activity Type.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec132"/>How to do it...</h2></div></div></div><p>In this recipe, we will create a new <code class="literal">Fragment</code> class with an accompanying layout file. We will then add the Fragment to the Activity Layout so it will be visible when the Activity starts. Here are the steps to create and display a new Fragment:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new layout called <code class="literal">fragment_one.xml</code> using the following XML:<div class="informalexample"><pre class="programlisting">&lt;RelativeLayout 
    android:layout_height="match_parent"
    android:layout_width="match_parent"&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Fragment One"
        android:id="@+id/textView"
        android:layout_centerVertical="true"
        android:layout_centerHorizontal="true" /&gt;
&lt;/RelativeLayout&gt;</pre></div></li><li class="listitem">Create a new Java file called <code class="literal">FragmentOne</code> with the following code:<div class="informalexample"><pre class="programlisting">public class FragmentOne extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_one, container, false);
    }
}</pre></div></li><li class="listitem">Open the <code class="literal">main_activity.xml</code> file and replace the existing <code class="literal">&lt;TextView&gt;</code> element with the following <code class="literal">&lt;fragment&gt;</code> element:<div class="informalexample"><pre class="programlisting">  &lt;fragment
    android:name="com.packtpub.androidcookbook.createfragment.FragmentOne"
    android:id="@+id/fragment"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    tools:layout="@layout/fragment_one" /&gt;</pre></div></li><li class="listitem">Run the program on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec133"/>How it works...</h2></div></div></div><p>We start by creating a <a id="id241" class="indexterm"/>new class, the same as we do for an Activity. In this recipe, we<a id="id242" class="indexterm"/> only create an overwrite for the <code class="literal">onCreateView()</code> method to load our Fragment layout. But, just like with the Activity events, we can override the other events as we need them. Once the new Fragment is created, we then add it to the Activity Layout. Since the <code class="literal">Activity</code> class was created before <code class="literal">Fragments</code> existed, they do not support <code class="literal">Fragments</code>. If we were using pure framework classes, we would want to use <code class="literal">FragmentActivity</code> instead. If you used the Android Studio New Project Wizard, then by default the <code class="literal">MainActivity</code> extends <code class="literal">AppCompatActivity</code>, which already includes support for Fragments.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec134"/>There's more...</h2></div></div></div><p>We're only creating a single, simple Fragment in this recipe to teach the fundamentals of Fragments. But this is a good time to point out the power of Fragments. If we are creating multiple Fragments (and usually we are, as that's the point of using Fragments), when creating the Activity Layouts as we did in Step 4, we could create different layout configurations using the Android Resource Folders. The portrait layout may have only a single Fragment while the landscape may have two or more.</p></div></div>
<div class="section" title="Adding and removing Fragments during runtime"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Adding and removing Fragments during runtime</h1></div></div></div><p>Defining a Fragment <a id="id243" class="indexterm"/>in the layout, as we did in the previous recipe, is<a id="id244" class="indexterm"/> known as a static Fragment <a id="id245" class="indexterm"/>and cannot be changed during runtime. Rather than using the <code class="literal">&lt;fragment&gt;</code> element, we will create a container to hold the Fragment, then create the Fragment dynamically in the Activity's <code class="literal">onCreate()</code> method.</p><p>The <code class="literal">FragmentManager</code> provides the APIs for adding, removing, and changing Fragments during runtime using a <code class="literal">FragmentTransaction</code>. A Fragment transaction consists of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Starting a transaction</li><li class="listitem" style="list-style-type: disc">Performing one or multiple actions</li><li class="listitem" style="list-style-type: disc">Committing the transaction</li></ul></div><p>This recipe will demonstrate the <code class="literal">FragmentManager</code> by adding and removing Fragments during runtime.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec135"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">RuntimeFragments</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select the <span class="strong"><strong>Empty Activity</strong></span> option when prompted for the <span class="strong"><strong>Activity Type</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec136"/>How to do it...</h2></div></div></div><p>To demonstrate adding and removing Fragments, we first need to create the Fragments, which we will do be extending the <code class="literal">Fragment</code> class. After creating the new Fragments, we need to alter the layout for the Main Activity to include the <code class="literal">Fragment</code> container. From there, we just add the code to handle the Fragment transactions. Here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new layout file called <code class="literal">fragment_one.xml</code> and include the following XML:<div class="informalexample"><pre class="programlisting">&lt;RelativeLayout 
    android:layout_height="match_parent"
    android:layout_width="match_parent"&gt;
    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Fragment One"
        android:id="@+id/textView"
        android:layout_centerVertical="true"
        android:layout_centerHorizontal="true" /&gt;
&lt;/RelativeLayout&gt;</pre></div></li><li class="listitem">The second layout file called <code class="literal">fragment_two.xml</code> is almost identical, with the only difference being the text:<div class="informalexample"><pre class="programlisting">android:text="Fragment Two"</pre></div></li><li class="listitem">Create a new Java file called <code class="literal">FragmentOne</code> with the following code:<div class="informalexample"><pre class="programlisting">public class FragmentOne extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_one, container, false);
    }
}</pre></div><p>Import from the following library:</p><div class="informalexample"><pre class="programlisting">android.support.v4.app.Fragment</pre></div></li><li class="listitem">Create the <a id="id246" class="indexterm"/>second Java file called <code class="literal">FragmentTwo</code> with<a id="id247" class="indexterm"/> the following code:<div class="informalexample"><pre class="programlisting">public class FragmentTwo extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_two, container, false);
    }
}</pre></div><p>Import from the following library:</p><div class="informalexample"><pre class="programlisting">android.support.v4.app.Fragment</pre></div></li><li class="listitem">Now we need to add a container and a button to the Main Activity layout. Change <code class="literal">main_activity.xml</code> as follows:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;FrameLayout
        android:id="@+id/frameLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_above="@+id/buttonSwitch"
        android:layout_alignParentTop="true"&gt;
    &lt;/FrameLayout&gt;
    &lt;Button
        android:id="@+id/buttonSwitch"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Switch"
        android:layout_alignParentBottom="true"
        android:layout_centerInParent="true"
        android:onClick="switchFragment"/&gt;
&lt;/RelativeLayout&gt;</pre></div></li><li class="listitem">With the Fragments created and the container added to the layout, we are now ready to write the code to manipulate the Fragments. Open <code class="literal">MainActivity.java</code> and add the following code below the class constructor:<div class="informalexample"><pre class="programlisting">FragmentOne mFragmentOne;
FragmentTwo mFragmentTwo;
int showingFragment=0;</pre></div></li><li class="listitem">Add the <a id="id248" class="indexterm"/>following code to the existing <code class="literal">onCreate()</code> method, below<a id="id249" class="indexterm"/> <code class="literal">setContentView()</code>:<div class="informalexample"><pre class="programlisting">mFragmentOne = new FragmentOne();
mFragmentTwo = new FragmentTwo();
FragmentManager fragmentManager = getSupportFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
fragmentTransaction.add(R.id.frameLayout, mFragmentOne);
fragmentTransaction.commit();
showingFragment=1;</pre></div><p>Import from the following libraries:</p><div class="informalexample"><pre class="programlisting">android.support.v4.app.FragmentManager
android.support.v4.app.FragmentTransaction</pre></div></li><li class="listitem">The last code we need to add handles the Fragment switching, called by the button:<div class="informalexample"><pre class="programlisting">public void switchFragment(View view) {
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
    if (showingFragment==1) {
        fragmentTransaction.replace(R.id.frameLayout, mFragmentTwo);
        showingFragment = 2;
    } else {
        fragmentTransaction.replace(R.id.frameLayout, mFragmentOne);
        showingFragment=1;
    }
    fragmentTransaction.commit();
}</pre></div></li><li class="listitem">Run the program on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec137"/>How it works...</h2></div></div></div><p>Most of the steps<a id="id250" class="indexterm"/> for this recipe involve setting up the Fragments. Once<a id="id251" class="indexterm"/> the Fragments are declared, we create them in the <code class="literal">onCreate()</code> method. Though the code can be condensed to a single line, it's shown in the long form as it makes it easier to read and understand.</p><p>First, we get the <code class="literal">FragmentManager</code> so we can begin a <code class="literal">FragmentTransaction</code>. Once we have a <code class="literal">FragmentTransaction</code>, we start the transaction with <code class="literal">beginTransaction()</code>. Multiple actions can occur within the transaction, but all we need here is to <code class="literal">add()</code> our initial Fragment. We call the <code class="literal">commit()</code> method to finalize the transaction.</p><p>Now that you understand the Fragment transaction, here is the succinct version for <code class="literal">onCreate()</code>:</p><div class="informalexample"><pre class="programlisting">getFragmentManager().beginTransaction().add(R.id.framLayout, mFragmentOne).commit();</pre></div><p>
<code class="literal">switchFragment</code> does basically the same type of Fragment transaction. Instead of calling the <code class="literal">add()</code> method, we call the <code class="literal">replace()</code> method with the existing Fragment. We keep track of the current Fragment with the <code class="literal">showingFragment</code> variable so we know which Fragment to show next. We are not limited to switching between two Fragments either. If we needed additional Fragments, we just need to create them.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec138"/>There's more...</h2></div></div></div><p>In the <span class="emphasis"><em>Switching between activities</em></span> recipe from <a class="link" href="ch01.html" title="Chapter 1. Activities">Chapter 1</a>, <span class="emphasis"><em>Activities</em></span>, we discussed the back stack. Most users would expect the back key to move backward through the "screens" and they don't know or care if those screens are activities or Fragments. Fortunately, Android makes it very easy to add Fragments to the back stack just by adding a call to <code class="literal">addToBackStack()</code> before calling <code class="literal">commit()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>When a Fragment is removed or replaced without adding it to the back stack, it is immediately destroyed. If it is added to the back stack, it is stopped and, if the user returns to the Fragment, it is restarted, instead of recreated.</p></div></div></div></div>
<div class="section" title="Passing data between Fragments"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Passing data between Fragments</h1></div></div></div><p>Often, the need arises to <a id="id252" class="indexterm"/>pass information between the Fragments. An <a id="id253" class="indexterm"/>email application serves as a classic example. It's common to have the list of emails in one Fragment, and show the email details in another Fragment (this is commonly referred to as a Master/Detail pattern). Fragments make creating this pattern easier because we only have to code each Fragment once, then we can include them in different layouts. We can easily have a single Fragment in a portrait layout with the ability to swap out the master Fragment with the detail Fragment when an email is selected. We can also create a two-panel layout where both the list and detail Fragments are side-by-side. Either way, when the user clicks the email in the list, the email opens up in the detail panel. This is when we need to communicate between two Fragments.</p><p>Since one of the primary goals of Fragments is that they be completely self-contained, direct communication between Fragments is discouraged, and for good reason. If Fragments had to rely on other Fragments, your code would likely break when the layouts changed and only one Fragment was available. Fortunately, direct communication is not required for this scenario either. All Fragment communication should pass through the host Activity. The host activity is responsible for managing the Fragments and can properly route the messages.</p><p>Now the question becomes: How do Fragments communicate with the activity? The answer is with an <code class="literal">interface</code>. You're probably already familiar with an interface, as that's how a view communicates an event back to an activity. A button click is a common example.</p><p>In this recipe, we will create two Fragments to demonstrate passing data from one Fragment to another via the host activity. We'll also build on what we learned from the previous recipe by including two different Activity Layouts—one for portrait and one for landscape. When in portrait mode, the activity will swap the Fragments as needed. Here is a screenshot of when the application first runs in portrait mode:</p><div class="mediaobject"><img src="graphics/B05057_05_01.jpg" alt="Passing data between Fragments"/></div><p>This is the screen showing<a id="id254" class="indexterm"/> the detail Fragment when you click on a country <a id="id255" class="indexterm"/>name:</p><div class="mediaobject"><img src="graphics/B05057_05_02.jpg" alt="Passing data between Fragments"/></div><p>When in landscape, both <a id="id256" class="indexterm"/>Fragments will be side-by-side, as shown in the<a id="id257" class="indexterm"/> landscape screenshot:</p><div class="mediaobject"><img src="graphics/B05057_05_03.jpg" alt="Passing data between Fragments"/></div><p>Since the Master/Detail<a id="id258" class="indexterm"/> pattern generally involves a list for the <a id="id259" class="indexterm"/>master, we'll take advantage of the <code class="literal">ListFragment</code> (mentioned in the <span class="emphasis"><em>Creating and using a Fragment</em></span> introduction.) When an item in the list is selected, the item text (country name in our example) will be sent to the detail Fragment via the host Activity.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec139"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">Fragmentcommunication</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select <span class="strong"><strong>Empty Activity</strong></span> when prompted for the <span class="strong"><strong>Activity Type</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec140"/>How to do it...</h2></div></div></div><p>To fully demonstrate working Fragments, we'll need to create two Fragments. The first Fragment will extend from the <code class="literal">ListFragment</code> so it will not need a layout. We're going to go one step further by creating both portrait and landscape layouts for our Activity. For portrait mode, we'll swap Fragments and for landscape mode, we'll show both Fragments side-by-side.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>When typing this code, Android Studio will offer two different library import options. Since the New Project Wizard automatically references the <code class="literal">AppCompat</code> library, we need to use the support library APIs instead of the framework APIs. Though very similar, the following code uses the support Fragment APIs.</p></div></div><p>Here are the steps, starting with<a id="id260" class="indexterm"/> the first Fragment:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new Java class<a id="id261" class="indexterm"/> called <code class="literal">MasterFragment</code> and change it so it extends <code class="literal">ListFragment</code> as shown:<div class="informalexample"><pre class="programlisting">public class MasterFragment extends ListFragment</pre></div><p>Import from the following library:</p><div class="informalexample"><pre class="programlisting">android.support.v4.app.ListFragment</pre></div></li><li class="listitem">Create the following <code class="literal">interface</code> inside the <code class="literal">MasterFragment</code> class:<div class="informalexample"><pre class="programlisting">public interface OnMasterSelectedListener {
    public void onItemSelected(String countryName);
}</pre></div></li><li class="listitem">Set up the interface callback listener with the following code:<div class="informalexample"><pre class="programlisting">private OnMasterSelectedListener mOnMasterSelectedListener=null;

public void setOnMasterSelectedListener(OnMasterSelectedListener listener) {
    mOnMasterSelectedListener=listener;
}</pre></div></li><li class="listitem">The last step for the <code class="literal">MasterFragment</code> is to create a <code class="literal">ListAdapter</code> to populate the <code class="literal">ListView</code>, which we do in the <code class="literal">onViewCreated()</code> method. We'll use the <code class="literal">setOnItemClickListener()</code> to call our <code class="literal">OnMasterSelectedListener</code> interface when a country name is selected with the following code:<div class="informalexample"><pre class="programlisting">public void onViewCreated(View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    String[] countries = new String[]{"China", "France", "Germany", "India", "Russia", "United Kingdom", "United States"};
    ListAdapter countryAdapter = new ArrayAdapter&lt;String&gt;(getActivity(), android.R.layout.simple_list_item_1, countries);
    setListAdapter(countryAdapter);
    getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
            if (mOnMasterSelectedListener != null) {
                mOnMasterSelectedListener.onItemSelected(((TextView) view).getText().toString());
            }
        }
    });
}</pre></div></li><li class="listitem">Next we need to<a id="id262" class="indexterm"/> create the <code class="literal">DetailFragment</code>, starting <a id="id263" class="indexterm"/>with the Layout. Create a new layout file called: <code class="literal">fragment_detail.xml</code> with the following XML:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;TextView
        android:id="@+id/textViewCountryName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerVertical="true"
        android:layout_centerHorizontal="true" /&gt;
&lt;/RelativeLayout&gt;</pre></div></li><li class="listitem">Create a new Java class called <code class="literal">DetailFragment</code> extending from <code class="literal">Fragment</code> as follows:<div class="informalexample"><pre class="programlisting">public class DetailFragment extends Fragment</pre></div><p>Import from the following library:</p><div class="informalexample"><pre class="programlisting">android.support.v4.app.Fragment</pre></div></li><li class="listitem">Add the following constant to the class:<div class="informalexample"><pre class="programlisting">public static String KEY_COUNTRY_NAME="KEY_COUNTRY_NAME";</pre></div></li><li class="listitem">Override <code class="literal">onCreateView()</code> as follows:<div class="informalexample"><pre class="programlisting">public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    return inflater.inflate(R.layout.fragment_detail, container, false);
}</pre></div></li><li class="listitem">Code the <code class="literal">onViewCreated()</code> as follows:<div class="informalexample"><pre class="programlisting">public void onViewCreated(View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);

    Bundle bundle = getArguments();
    if (bundle != null &amp;&amp; bundle.containsKey(KEY_COUNTRY_NAME)) {
        showSelectedCountry(bundle.getString(KEY_COUNTRY_NAME));
    }
}</pre></div></li><li class="listitem">The last step for this Fragment is to update the TextView when we receive the selected country name. Add the following method to the class:<div class="informalexample"><pre class="programlisting">public void showSelectedCountry(String countryName) {
    ((TextView)getView().findViewById(R.id.textViewCountryName)).setText(countryName);
}</pre></div></li><li class="listitem">The existing <code class="literal">activity_main.xml</code> layout will handle the portrait mode layout. Remove <a id="id264" class="indexterm"/>the existing <code class="literal">&lt;TextView&gt;</code> and <a id="id265" class="indexterm"/>replace with the following <code class="literal">&lt;FrameLayout&gt;</code>:<div class="informalexample"><pre class="programlisting">&lt;FrameLayout
    android:id="@+id/frameLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"/&gt;</pre></div></li><li class="listitem">Create a new directory in the <span class="strong"><strong>res</strong></span> folder for the landscape layout as: <code class="literal">res/layout-land</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>If you do not see the new res/layout-land directory, change from <span class="strong"><strong>Android</strong></span> <span class="strong"><strong>view</strong></span> to <span class="strong"><strong>Project</strong></span> <span class="strong"><strong>view</strong></span>.</p></div></div></li><li class="listitem">Create a new <code class="literal">activity_main.xml</code> layout in <code class="literal">res/layout-land</code> as follows:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout 
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"&gt;
    &lt;FrameLayout
        android:id="@+id/frameLayoutMaster"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="match_parent"/&gt;
    &lt;FrameLayout
        android:id="@+id/frameLayoutDetail"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="match_parent"/&gt;
&lt;/LinearLayout&gt;</pre></div></li><li class="listitem">The final<a id="id266" class="indexterm"/> steps are to set up the <code class="literal">MainActivity</code> to <a id="id267" class="indexterm"/>handle the Fragments. Open the <code class="literal">MainActivity.java</code> file and add the following class variable to track single/dual pane:<div class="informalexample"><pre class="programlisting">boolean dualPane;</pre></div></li><li class="listitem">Next, change <code class="literal">onCreate()</code> as follows:<div class="informalexample"><pre class="programlisting">protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    MasterFragment masterFragment=null;
    FrameLayout frameLayout = (FrameLayout)findViewById(R.id.frameLayout);
    if (frameLayout != null) {
        dualPane=false;
        FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
        masterFragment=(MasterFragment)getSupportFragmentManager().findFragmentByTag("MASTER");
        if (masterFragment == null) {
            masterFragment = new MasterFragment();
            fragmentTransaction.add(R.id.frameLayout, masterFragment, "MASTER");
        }
        DetailFragment detailFragment = (DetailFragment)getSupportFragmentManager().findFragmentById(R.id.frameLayoutDetail);
        if (detailFragment != null) {
            fragmentTransaction.remove(detailFragment);
        }
        fragmentTransaction.commit();
    } else {
        dualPane=true;
        FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
        masterFragment=(MasterFragment)getSupportFragmentManager().findFragmentById(R.id.frameLayoutMaster);
        if (masterFragment==null) {
            masterFragment = new MasterFragment();
            fragmentTransaction.add(R.id.frameLayoutMaster, masterFragment);
        }
        DetailFragment detailFragment=(DetailFragment)getSupportFragmentManager().findFragmentById(R.id.frameLayoutDetail);
        if (detailFragment==null) {
            detailFragment = new DetailFragment();
            fragmentTransaction.add(R.id.frameLayoutDetail, detailFragment);
        }
        fragmentTransaction.commit();
    }
    masterFragment.setOnMasterSelectedListener(new MasterFragment.OnMasterSelectedListener() {
        @Override
        public void onItemSelected(String countryName) {
            sendCountryName(countryName);
        }
    });
}</pre></div></li><li class="listitem">The last code to add<a id="id268" class="indexterm"/> is the <code class="literal">sendCountryName()</code> method, which <a id="id269" class="indexterm"/>handles sending the country name to <code class="literal">DetailFragment</code>:<div class="informalexample"><pre class="programlisting">private void sendCountryName(String countryName) {
    DetailFragment detailFragment;
    if (dualPane) {
        //Two pane layout
        detailFragment = (DetailFragment)getSupportFragmentManager().findFragmentById(R.id.frameLayoutDetail);
        detailFragment.showSelectedCountry(countryName);
    } else {
        // Single pane layout
        detailFragment = new DetailFragment();
        Bundle bundle = new Bundle();
        bundle.putString(DetailFragment.KEY_COUNTRY_NAME, countryName);
        detailFragment.setArguments(bundle);
        FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
        fragmentTransaction.replace(R.id.frameLayout, detailFragment);
        fragmentTransaction.addToBackStack(null);
        fragmentTransaction.commit();
    }
}</pre></div></li><li class="listitem">Run the program on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec141"/>How it works...</h2></div></div></div><p>We start by creating the <code class="literal">MasterFragment</code>. In the Master/Detail pattern we are using, this usually represents a list, so<a id="id270" class="indexterm"/> we create a list by extending the <code class="literal">ListFragment</code>. The <code class="literal">ListFragment</code> is the Fragment equivalent of the <code class="literal">ListActivity</code>. Other than <a id="id271" class="indexterm"/>extending from a Fragment, it's basically the same.</p><p>As stated in the recipe introduction, we shouldn't attempt to communicate directly with other Fragments.</p><p>To provide a means to communicate the list item selection, we expose the interface: <code class="literal">OnMasterSelectedListener</code>. We call <code class="literal">onItemSelected()</code> every time an item is selected in the list.</p><p>Most of the work for passing data between Fragments is done in the host activity but, ultimately, the receiving Fragment needs a way to receive the data. <code class="literal">DetailFragment</code> supports this in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Passing the country name in the argument bundle, available at creation time.</li><li class="listitem" style="list-style-type: disc">A public method for the activity to call directly.</li></ul></div><p>When the activity creates the Fragment, it also creates a <code class="literal">bundle</code> to hold the data we want to send. Here we add the country name using <code class="literal">KEY_COUNTRY_NAME</code> defined in Step 7. We retrieve this bundle with <code class="literal">getArguments()</code> in <code class="literal">onViewCreated()</code>. If the key is found in the bundle, it is extracted and displayed using the <code class="literal">showSelectedCountry()</code> method. This is the same method the activity will call directly if the Fragment is already visible (in the two-panel layout).</p><p>Most of the work for this recipe is in the activity. We created two layouts: one for portrait and one for landscape. Android will choose the landscape layout using the <code class="literal">res/layout-land</code> directory created in <span class="emphasis"><em>Step 12</em></span>. Both layouts use a <code class="literal">&lt;FrameLayout&gt;</code> placeholder, similar to the previous exercise. We manage the Fragments in both <code class="literal">onCreate()</code> and <code class="literal">sendCountryName()</code>.</p><p>In <code class="literal">onCreate()</code>, we set the <code class="literal">dualPane</code> flag by checking whether the current layout includes the <code class="literal">frameLayout</code> view. If <code class="literal">frameLayout</code> is found (it won't be null), then we have only a single panel because the <code class="literal">frameLayout</code> ID is only in the portrait layout. If frameLayout is not found, then we have two <code class="literal">&lt;FrameLayout&gt;</code> elements instead: one for the <code class="literal">MasterFragment</code> and another for the <code class="literal">DetailFragment</code>.</p><p>The last thing we do in the <code class="literal">onCreate()</code> is to set up the <code class="literal">MasterFragment</code> listener by creating an anonymous callback, which passes the country name to <code class="literal">sendCountryName()</code>.</p><p>
<code class="literal">sendCountryName()</code> is where the data is actually passed to the <code class="literal">DetailFragment</code>. If we are in portrait (or single pane) mode, we need to create a <code class="literal">DetailFragment</code> and replace the existing <code class="literal">MasterFragment</code>. This is where we create the bundle with the country name and call <code class="literal">setArguments()</code>. Notice how we call <code class="literal">addToBackStack()</code> before committing the transaction? This allows the back key to bring the user back to the list (<code class="literal">MasterFragment</code>). If we are in landscape mode, the <code class="literal">DetailFragment</code> is already visible so we call the <code class="literal">showSelectedCountry()</code> public method directly.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec142"/>There's more...</h2></div></div></div><p>In the <code class="literal">MasterFragment</code>, before <a id="id272" class="indexterm"/>sending the <code class="literal">onItemSelected()</code> event, we check <a id="id273" class="indexterm"/>to make sure the listener is not null with this code:</p><div class="informalexample"><pre class="programlisting">if (mOnMasterSelectedListener != null)</pre></div><p>Though it's the job of the activity to set up the callback to receive the events, we don't want this code to crash if there's no listener. An alternative approach would be to verify the activity extends our interface in the Fragment's <code class="literal">onAttach()</code> callback.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec143"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information on ListViews, see <span class="emphasis"><em>Using ListView, GridView and Adapters</em></span> in <a class="link" href="ch02.html" title="Chapter 2. Layouts">Chapter 2</a>, <span class="emphasis"><em>Layouts</em></span>.</li><li class="listitem" style="list-style-type: disc">For more information on resource directories, see <span class="emphasis"><em>Selecting themes based on the Android version</em></span> in <a class="link" href="ch03.html" title="Chapter 3. Views, Widgets, and Styles">Chapter 3</a>, <span class="emphasis"><em>Views, Widgets, and Styles</em></span>.</li></ul></div></div></div>
<div class="section" title="Creating a shortcut on the Home screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Creating a shortcut on the Home screen</h1></div></div></div><p>This recipe explains how to <a id="id274" class="indexterm"/>create a link or create a shortcut for your app <a id="id275" class="indexterm"/>on the user's Home screen. So as not to be too obtrusive, it's generally best to make this an option for the user to initiate, such as in the settings.</p><p>Here is a screenshot showing our shortcut on the Home screen:</p><div class="mediaobject"><img src="graphics/B05057_05_04.jpg" alt="Creating a shortcut on the Home screen"/></div><p>As you can see, this is just <a id="id276" class="indexterm"/>a shortcut, but we will explore creating a Home <a id="id277" class="indexterm"/>screen (AppWidget) in the next recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec144"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">HomescreenShortcut</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select the <span class="strong"><strong>Empty Activity</strong></span> option when prompted for the <span class="strong"><strong>Activity Type</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec145"/>How to do it...</h2></div></div></div><p>The first step is to add the appropriate permission. Here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">AndroidManifest</code> file and add the following permission:<div class="informalexample"><pre class="programlisting">&lt;uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT" /&gt;</pre></div></li><li class="listitem">Next, open<a id="id278" class="indexterm"/> <code class="literal">activity_main.xml</code> and replace the<a id="id279" class="indexterm"/> existing TextView with the following button:<div class="informalexample"><pre class="programlisting">&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Create Shortcut"
    android:id="@+id/button"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    android:onClick="createShortcut"/&gt;</pre></div></li><li class="listitem">Add the following method to <code class="literal">ActivityMain.java</code>:<div class="informalexample"><pre class="programlisting">public void createShortcut(View view) {
    Intent shortcutIntent = new Intent(this, MainActivity.class);
    shortcutIntent.setAction(Intent.ACTION_MAIN);
    Intent intent = new Intent();
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.app_name));
    intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, Intent.ShortcutIconResource.fromContext(this, R.mipmap.ic_launcher));
    intent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
    sendBroadcast(intent);
}</pre></div></li><li class="listitem">Run the program on a device or emulator. Notice, each time you press the button, the app will make a shortcut on the Home screen.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec146"/>How it works...</h2></div></div></div><p>Once you set up the proper permission, this is a rather straightforward task. When the button is clicked, the code creates a new intent called: <code class="literal">shortcutIntent</code>. This is the intent that will be called when the icon is pressed on the Home screen. The next intent created, <code class="literal">installIntent</code>, is<a id="id280" class="indexterm"/> responsible for actually creating the <a id="id281" class="indexterm"/>shortcut.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec147"/>There's more...</h2></div></div></div><p>If you also wanted to remove the<a id="id282" class="indexterm"/> shortcut, you would need the following permission:</p><div class="informalexample"><pre class="programlisting">&lt;uses-permission android:name="com.android.launcher.permission.UNINSTALL_SHORTCUT" /&gt;</pre></div><p>Instead of using the INSTALL_SHORTCUT action, you would set the following action instead:</p><div class="informalexample"><pre class="programlisting">com.android.launcher.action.UNINSTALL_SHORTCUT</pre></div></div></div>
<div class="section" title="Creating a Home screen widget"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Creating a Home screen widget</h1></div></div></div><p>Before we dig in to the<a id="id283" class="indexterm"/> code for creating an App Widget, let's cover the basics. There are three required and one optional component:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">AppWidgetProviderInfo</code> file: It's an XML resource described later on</li><li class="listitem" style="list-style-type: disc">The <code class="literal">AppWidgetProvider</code> class: This is a Java class</li><li class="listitem" style="list-style-type: disc">The View layout file: It's a standard layout XML file, with some restrictions listed later on</li><li class="listitem" style="list-style-type: disc">The App Widget configuration Activity (optional): This Activity launches when placing the widget to set configuration options</li></ul></div><p>The <code class="literal">AppWidgetProvider</code> must also be declared in the <code class="literal">AndroidManifest</code> file. Since the <code class="literal">AppWidgetProvider</code> is a helper class based on the Broadcast Receiver, it is declared in the manifest with the <code class="literal">&lt;receiver&gt;</code> element. Here is an example manifest entry:</p><div class="informalexample"><pre class="programlisting">&lt;receiver android:name="AppWidgetProvider" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data android:name="android.appwidget.provider"
        android:resource="@xml/appwidget_info" /&gt;
&lt;/receiver&gt;</pre></div><p>The meta-data points to the <code class="literal">AppWidgetProviderInfo</code> file, which is placed in the <code class="literal">res/xml</code> directory. Here is a sample <code class="literal">AppWidgetProviderInfo.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;appwidget-provider 
    android:minWidth="40dp"
    android:minHeight="40dp"
    android:updatePeriodMillis="1800000"
    android:previewImage="@drawable/preview_image"
    android:initialLayout="@layout/appwidget"
    android:configure="com.packtpub.androidcookbook.AppWidgetConfiguration"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen"&gt;
&lt;/appwidget-provider&gt;</pre></div><p>Here's a brief overview <a id="id284" class="indexterm"/>of the available attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">minWidth</code>: The default <a id="id285" class="indexterm"/>width when placed on the Home <a id="id286" class="indexterm"/>screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">minHeight</code>: The default <a id="id287" class="indexterm"/>height when placed on the Home screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">updatePeriodMillis</code>: It's part<a id="id288" class="indexterm"/> of <code class="literal">onUpdate()</code> polling interval (in milliseconds)</li><li class="listitem" style="list-style-type: disc"><code class="literal">initialLayout</code>: The <a id="id289" class="indexterm"/>AppWidget layout</li><li class="listitem" style="list-style-type: disc"><code class="literal">previewImage</code> (optional): The image<a id="id290" class="indexterm"/> shown when browsing App Widgets</li><li class="listitem" style="list-style-type: disc"><code class="literal">configure</code> (optional): The activity <a id="id291" class="indexterm"/>to launch for configuration settings</li><li class="listitem" style="list-style-type: disc"><code class="literal">resizeMode</code> (optional): The <a id="id292" class="indexterm"/>flags indicate resizing options — <code class="literal">horizontal</code>, <code class="literal">vertical</code>, <code class="literal">none</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">minResizeWidth</code> (optional): The <a id="id293" class="indexterm"/>minimum width allowed when resizing</li><li class="listitem" style="list-style-type: disc"><code class="literal">minResizeHeight</code> (optional): The <a id="id294" class="indexterm"/>minimum height allowed when resizing</li><li class="listitem" style="list-style-type: disc"><code class="literal">widgetCategory</code> (optional): Android 5+ only <a id="id295" class="indexterm"/>supports Home screen widgets</li></ul></div><p>The <code class="literal">AppWidgetProvider</code> extends the <code class="literal">BroadcastReceiver</code> class, which is why <code class="literal">&lt;receiver&gt;</code> is used when declaring the <code class="literal">AppWidget</code> in the Manifest. As it's <code class="literal">BroadcastReceiver</code>, the class still receives the OS broadcast events, but the helper class filters those events down to those applicable for an App Widget. The <code class="literal">AppWidgetProvider</code> class<a id="id296" class="indexterm"/> exposes the following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onUpdate()</code>: It's <a id="id297" class="indexterm"/>called when initially created and at the interval specified.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onAppWidgetOptionsChanged()</code>: It's called when initially created and any time the size <a id="id298" class="indexterm"/>changes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onDeleted()</code>: It's <a id="id299" class="indexterm"/>called any time a widget is removed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onEnabled()</code>: It's <a id="id300" class="indexterm"/>called the first time a widget is placed (is not called when adding a second and subsequent widgets).</li><li class="listitem" style="list-style-type: disc"><code class="literal">onDisabled()</code>: It's <a id="id301" class="indexterm"/>called when the last widget is removed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onReceive()</code>: It's <a id="id302" class="indexterm"/>called on every event received, including the preceding event. Usually not overridden as the default implementation only sends the applicable events.</li></ul></div><p>The last required <a id="id303" class="indexterm"/>component is the layout. Remote Views only support a subset of the available layouts. As an App Widget is a Remote View, only the following layouts are supported:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FrameLayout</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LinearLayout</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">RelativeLayout</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GridLayout</code></li></ul></div><p>And the following widgets:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AnalogClock</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Button</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Chronometer</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ImageButton</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ImageView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ProgressBar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TextView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewFlipper</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ListView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GridView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">StackView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">AdapterViewFlipper</code></li></ul></div><p>With the App Widget <a id="id304" class="indexterm"/>basics covered, it's now time to start coding. Our example will cover the basics so you can expand the functionality as needed. This recipe uses a View with a clock, which, when pressed, opens our activity.</p><p>This screenshot shows the widget in the widget list when adding to the Home screen:</p><div class="mediaobject"><img src="graphics/B05057_05_05.jpg" alt="Creating a Home screen widget"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The widget list<a id="id305" class="indexterm"/> appearance varies by launcher.</p></div></div><p>Here's a screenshot<a id="id306" class="indexterm"/> showing the widget after it is added to the Home screen:</p><div class="mediaobject"><img src="graphics/B05057_05_06.jpg" alt="Creating a Home screen widget"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec148"/>Getting ready</h2></div></div></div><p>Create a new project in <a id="id307" class="indexterm"/>Android Studio and call it: <code class="literal">AppWidget</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select the <span class="strong"><strong>Empty Activity</strong></span> option when prompted for the <span class="strong"><strong>Activity Type</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec149"/>How to do it...</h2></div></div></div><p>We'll start by creating the widget layout, which resides in the standard layout resource directory. Then we'll create the xml resource directory to store the <code class="literal">AppWidgetProviderInfo</code> file. We'll add a new Java class and extend <code class="literal">AppWidgetProvider</code>, which handles the <code class="literal">onUpdate()</code> call for the widget. With the receiver created, we can then add it to the Android Manifest. </p><p>Here are the detailed steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new file in <code class="literal">res/layout</code> called <code class="literal">widget.xml</code> using the following XML:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;AnalogClock
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/analogClock"
        android:layout_centerVertical="true"
        android:layout_centerHorizontal="true" /&gt;
&lt;/RelativeLayout&gt;</pre></div></li><li class="listitem">Create a new directory called <code class="literal">xml</code> in the resource directory. The final result will be: <code class="literal">res/xml</code>.</li><li class="listitem">Create a new file in <code class="literal">res/xml</code> called <code class="literal">appwidget_info,xml</code> using the following xml:<div class="informalexample"><pre class="programlisting">&lt;appwidget-provider 
    android:minWidth="40dp"
    android:minHeight="40dp"
    android:updatePeriodMillis="0"
    android:initialLayout="@layout/widget"
    android:resizeMode="none"
    android:widgetCategory="home_screen"&gt;
&lt;/appwidget-provider&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>If you cannot see the new xml directory, switch from <span class="strong"><strong>Android</strong></span> view to <span class="strong"><strong>Project</strong></span> view in the <span class="strong"><strong>Project</strong></span> panel dropdown.</p></div></div></li><li class="listitem">Create a new <a id="id308" class="indexterm"/>Java class called <code class="literal">HomescreenWidgetProvider</code> extending <code class="literal">AppWidgetProvider</code>.</li><li class="listitem">Add the following <code class="literal">onUpdate()</code> method to the <code class="literal">HomescreenWidgetProvider</code> class:<div class="informalexample"><pre class="programlisting">public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    super.onUpdate(context, appWidgetManager, appWidgetIds);
    for (int count=0; count&lt;appWidgetIds.length; count++) {
        RemoteViews appWidgetLayout = new RemoteViews(context.getPackageName(), R.layout.widget);
        Intent intent = new Intent(context, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
        appWidgetLayout.setOnClickPendingIntent(R.id.analogClock, pendingIntent);
        appWidgetManager.updateAppWidget(appWidgetIds[count], appWidgetLayout);
    }
}</pre></div></li><li class="listitem">Add <code class="literal">HomescreenWidgetProvider</code> to <code class="literal">AndroidManifest</code> using the following XML declaration within the <code class="literal">&lt;application&gt;</code> element:<div class="informalexample"><pre class="programlisting">&lt;receiver android:name=".HomescreenWidgetProvider" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data android:name="android.appwidget.provider"
        android:resource="@xml/appwidget_info" /&gt;
&lt;/receiver&gt;</pre></div></li><li class="listitem">Run the program on a device or emulator. After first running the application, the widget will then be available to add to the Home screen.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec150"/>How it works...</h2></div></div></div><p>Our first step is to create the layout file for the widget. This is a standard layout resource with the restrictions based on the App Widget being a Remote View, as discussed in the recipe introduction. Though our example uses an Analog Clock widget, this is where you'd want to expand the functionality based on your application needs.</p><p>The xml resource directory serves to store the <code class="literal">AppWidgetProviderInfo</code>, which defines the default widget settings. The configuration settings determine how the widget is displayed when initially browsing the available widgets. We use very basic settings for this recipe, but they can easily be expanded to include additional features such as a preview image to show a functioning widget and sizing options. The <code class="literal">updatePeriodMillis</code> attribute sets the update frequency. Since the update will wake up the device, it's a trade-off between having up-to-date data and battery life. (This is where the optional Settings Activity is useful to let the user decide.)</p><p>The <code class="literal">AppWidgetProvider</code> class<a id="id309" class="indexterm"/> is where we handle the <code class="literal">onUpdate()</code> event triggered by the <code class="literal">updatePeriodMillis</code> polling. Our example doesn't need any updating so we set the polling to zero. The update is still called when initially placing the widget. The <code class="literal">onUpdate()</code> is where we set the pending intent to open our app when the clock is pressed.</p><p>Since the <code class="literal">onUpdate()</code> method is probably the most complicated aspect of AppWidgets, we'll explain this is some detail. First, it's worth noting that <code class="literal">onUpdate()</code> will occur only once each polling interval for all the widgets is created by this provider. (Widgets created after the first will be on the cycle of the first widget.) This explains the <code class="literal">for</code> loop, as we need it to iterate through all the existing widgets. This is where we create a pending intent to call our app when the clock is pressed. As discussed earlier, an AppWidget is a Remote View. Therefore, to get the layout, we call <code class="literal">RemoteViews()</code> with our fully qualified package name and the layout ID. Once we have the layout, we can attach the pending intent to the clock view using <code class="literal">setOnClickPendingIntent()</code>. We call the <code class="literal">AppWidgetManager</code> named <code class="literal">updateAppWidget()</code> to initiate the changes we made.</p><p>The last step to make all this work is to declare the widget in the Android Manifest. We identify the action we want to handle with the <code class="literal">&lt;intent-filter&gt;</code>. Most App Widgets will likely want to handle the Update event, as ours does. The other item to note in the declaration is this line:</p><div class="informalexample"><pre class="programlisting">&lt;meta-data android:name="android.appwidget.provider"
    android:resource="@xml/appwidget_info" /&gt;</pre></div><p>This tells the system where to find our configuration file.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec151"/>There's more...</h2></div></div></div><p>Adding an App Widget configuration Activity allows greater flexibility with your widget. Not only can you offer polling options, but you could offer different layouts, click behaviors, and so on. Users tend to really appreciate flexible App Widgets.</p><p>Adding a configuration Activity requires a few additional steps. The Activity needs to be declared in the Manifest as usual, but needs to include the <code class="literal">APPWIDGET_CONFIGURE</code> action, as shown in this example:</p><div class="informalexample"><pre class="programlisting">&lt;activity android:name=".AppWidgetConfigureActivity"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_CONFIGURE"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</pre></div><p>The Activity also needs to be specified in the <code class="literal">AppWidgetProviderInfo</code> file using the configure attribute, as shown in this example:</p><div class="informalexample"><pre class="programlisting">android:configure="com.packtpub.androidcookbook.appwidget.AppWidgetConfigureActivity"</pre></div><p>The <code class="literal">configure</code> attribute requires the fully qualified package name as this Activity will be called from outside of your application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Remember, the <code class="literal">onUpdate()</code> method will not be called when using a configuration Activity. The configuration Activity is responsible for handling any initial setup, if required.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec152"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For<a id="id310" class="indexterm"/> App Widget Design Guidelines, visit Google's page at: <a class="ulink" href="http://developer.android.com/design/patterns/widgets.html">http://developer.android.com/design/patterns/widgets.html</a></li></ul></div></div></div>
<div class="section" title="Adding Search to the Action Bar"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Adding Search to the Action Bar</h1></div></div></div><p>Along with the <a id="id311" class="indexterm"/>Action Bar, Android 3.0 introduced the <code class="literal">SearchView</code> widget, which<a id="id312" class="indexterm"/> can be included as a menu item when creating a menu. This is now the recommended UI pattern to provide a consistent user experience.</p><p>The following screenshot shows the initial appearance of the Search icon in the Action Bar:</p><div class="mediaobject"><img src="graphics/B05057_05_07.jpg" alt="Adding Search to the Action Bar"/></div><p>This screenshot shows how the Search option expands when pressed:</p><div class="mediaobject"><img src="graphics/B05057_05_08.jpg" alt="Adding Search to the Action Bar"/></div><p>If you want to add a Search functionality to your application, this recipe will walk you through the steps to set up your User Interface and properly configure the Search Manager API.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec153"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">SearchView</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select <span class="strong"><strong>Empty Activity</strong></span> when prompted for the Activity Type.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec154"/>How to do it...</h2></div></div></div><p>To set up the Search UI <a id="id313" class="indexterm"/>pattern, we need to create the Search menu item and <a id="id314" class="indexterm"/>a resource called <code class="literal">searchable</code>. We'll create a second activity to receive the search query. Then we'll hook it all up in the <code class="literal">AndroidManifest</code> file. To get started, open the <code class="literal">strings.xml</code> file in <code class="literal">res/values</code> and follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following string resources:<div class="informalexample"><pre class="programlisting">&lt;string name="search_title"&gt;Search&lt;/string&gt;
&lt;string name="search_hint"&gt;Enter text to search&lt;/string&gt;</pre></div></li><li class="listitem">Create the menu directory: <code class="literal">res/menu</code>.</li><li class="listitem">Create a new menu resource called <code class="literal">menu_options.xml</code> in <code class="literal">res/menu</code> using the following xml:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu
    
    &gt;
    &lt;item android:id="@+id/menu_search"
        android:title="@string/search_title"
        android:icon="@android:drawable/ic_menu_search"
        app:showAsAction="collapseActionView|ifRoom"
        app:actionViewClass="android.support.v7.widget.SearchView" /&gt;
&lt;/menu&gt;</pre></div></li><li class="listitem">Override <code class="literal">onCreateOptionsMenu()</code> to inflate the menu and set up the Search Manager as follows:<div class="informalexample"><pre class="programlisting">public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.menu_options, menu);
    SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
    SearchView searchView = (SearchView) MenuItemCompat.getActionView(menu.findItem(R.id.menu_search));
    searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));
    return true;
}</pre></div></li><li class="listitem">Create a new xml<a id="id315" class="indexterm"/> resource directory: <code class="literal">res/xml</code>.</li><li class="listitem">Create a new file in<a id="id316" class="indexterm"/> the <code class="literal">res/xml</code> called <code class="literal">searchable.xml</code> using the following xml:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;searchable 
    android:label="@string/app_name"
    android:hint="@string/search_hint" /&gt;</pre></div></li><li class="listitem">Crate a new layout called <code class="literal">activity_search_result.xml</code> using this xml:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout 
    
    android:layout_width="match_parent"
    android:layout_height="match_parent" &gt;
    &lt;TextView
        android:id="@+id/textViewSearchResult"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true" /&gt;
&lt;/RelativeLayout&gt;</pre></div></li><li class="listitem">Create a new Activity called <code class="literal">SearchResultActivity</code>.</li><li class="listitem">Add the following variable to the class:<div class="informalexample"><pre class="programlisting">TextView mTextViewSearchResult;</pre></div></li><li class="listitem">Change the <code class="literal">onCreate()</code> to load our layout, set the TextView and check for the <code class="literal">QUERY</code> action:<div class="informalexample"><pre class="programlisting">protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_search_result);
    mTextViewSearchResult = (TextView)findViewById(R.id.textViewSearchResult);

    if (Intent.ACTION_SEARCH.equals(getIntent().getAction())) {
        handleSearch(getIntent().getStringExtra(SearchManager.QUERY));
}</pre></div></li><li class="listitem">Add the following <a id="id317" class="indexterm"/>method to handle the search:<div class="informalexample"><pre class="programlisting">private void handleSearch(String searchQuery) {
    mTextViewSearchResult.setText(searchQuery);
}</pre></div></li><li class="listitem">With the User Interface <a id="id318" class="indexterm"/>and code now complete, we just need to hook everything up correctly in the <code class="literal">AndroidManifest</code>. Here is the complete manifest including both activities:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.packtpub.androidcookbook.searchview" &gt;
    &lt;application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme" &gt;
        &lt;meta-data
            android:name="android.app.default_searchable"
            android:value=".SearchResultActivity" /&gt;
        &lt;activity android:name=".MainActivity" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.MAIN" /&gt;
                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
        &lt;activity android:name=".SearchResultActivity" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.SEARCH" /&gt;
            &lt;/intent-filter&gt;
            &lt;meta-data android:name="android.app.searchable" android:resource="@xml/searchable" /&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></li><li class="listitem">Run the application on a device or emulator. Type in a search query and hit the <span class="strong"><strong>Search</strong></span> button (or press enter). The <code class="literal">SearchResultActivity</code> will display showing the search query entered.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec155"/>How it works...</h2></div></div></div><p>Since the New Project <a id="id319" class="indexterm"/>Wizard uses the <code class="literal">AppCompat</code> library, our example uses the<a id="id320" class="indexterm"/> support library API. Using the support library provides the greatest device compatibility as it allows the use of modern features (such as the Action Bar) on older versions of the Android OS. This can sometimes provide an extra challenge as often the official documentation focuses on the framework API. Though usually the support library closely follows the framework API, they are not always interchangeable. The Search UI pattern is one of those situations, so it's worth paying extra attention to the steps outlined previously.</p><p>We start by creating string resources for the <code class="literal">searchable</code>, as declared in Step 6.</p><p>In Step 3, we create the menu resource, as we've done many times. One difference is that we use the <code class="literal">app</code> namespace for the <code class="literal">showAsAction</code> and <code class="literal">actionViewClass</code> attributes. The earlier versions of the Android OS don't include these attributes in their Android namespace. This serves as a way to bring new functionality to older versions of the Android OS</p><p>In Step 4, we set up the <code class="literal">SearchManager</code>, again using the support library APIs.</p><p>Step 6 is where we define the <code class="literal">searchable</code>, which is an xml resource used by the <code class="literal">SearchManager</code>. The only required attribute is the <code class="literal">label</code>, but the <code class="literal">hint</code> is recommended so the user will have an idea of what they should type in the field.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>The <code class="literal">android:label</code> must match the application name or the activity name and must use a string resource (as it does not work with a hard-coded string).</p></div></div><p>Steps 7-11 are for the <code class="literal">SearchResultActivity</code>. Calling a second activity is not a requirement of the <code class="literal">SearchManager</code>, but is commonly done to provide a single activity for all searches initiated in your application.</p><p>If you ran the application at this point, you would see the search icon, but nothing would work. Step 12 is where we put it all together in the <code class="literal">AndroidManifest</code> file. The first item to note is the following:</p><div class="informalexample"><pre class="programlisting">&lt;meta-data
android:name="android.app.default_searchable"
android:value=".SearchResultActivity" /&gt;</pre></div><p>Notice this is in the application element and not in either of the <code class="literal">&lt;activity&gt;</code> elements.</p><p>We specify the searchable<a id="id321" class="indexterm"/> resource in the <code class="literal">SearchResultActivity &lt;meta-data&gt;</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;meta-data android:name="android.app.searchable" android:resource="@xml/searchable" /&gt;</pre></div><p>We also need to set the intent filter for <code class="literal">SearchResultActivity</code> as we do here:</p><div class="informalexample"><pre class="programlisting">&lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.SEARCH" /&gt;
&lt;/intent-filter&gt;</pre></div><p>The <code class="literal">SearchManager</code> <a id="id322" class="indexterm"/>broadcasts the <code class="literal">SEARCH</code> intent when the user initiates the search. This declaration directs the intent to the <code class="literal">SearchResultActivity</code> activity. Once the search is triggered, the query text is sent to the <code class="literal">SearchResultActivity</code> using the <code class="literal">SEARCH</code> intent. We check for the <code class="literal">SEARCH</code> intent in the <code class="literal">onCreate()</code> and extract the query string using the following code:</p><div class="informalexample"><pre class="programlisting">if (Intent.ACTION_SEARCH.equals(getIntent().getAction())) {
    handleSearch(getIntent().getStringExtra(SearchManager.QUERY));
}</pre></div><p>You now have the Search UI pattern fully implemented. With the UI pattern complete, how you handle the search is specific to your application needs. Depending on your application, you might search a local database or maybe a web service.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec156"/>See also</h2></div></div></div><p>To take your search to the Internet, see <span class="emphasis"><em>Internet queries</em></span> in <a class="link" href="ch12.html" title="Chapter 12. Telephony, Networks, and the Web">Chapter 12</a>, <span class="emphasis"><em>Telephony, Networks, and the Web</em></span>.</p></div></div>
<div class="section" title="Showing your app full screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Showing your app full screen</h1></div></div></div><p>Android 4.4 (API 19) introduced a<a id="id323" class="indexterm"/> UI feature called <a id="id324" class="indexterm"/>Immersive Mode. Unlike the previous full screen flag, your app receives all the touch events while in Immersive Mode. This mode is ideal for certain activities, such as reading books and news, full-screen drawing, gaming, or watching a video. There are several different approaches to full screen, and each have a best use case:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reading books/articles, and so on: Immersive Mode with easy access to the system UI</li><li class="listitem" style="list-style-type: disc">Game/Drawing app: Immersive Mode for full screen use but minimal system UI</li><li class="listitem" style="list-style-type: disc">Watching video: Full screen and normal system UI</li></ul></div><p>The key difference between the modes is how the System UI responds. In the first two scenarios, your app is expecting user interaction, so the System UI is hidden to make it easier for your user (such as not hitting the back button while playing a game). While using full screen with a normal system UI, such as watching a video, you wouldn't expect your user to use the screen at all, so when they do, the system UI should respond normally. In all modes, the user can bring back the System UI with a swipe inward across the hidden System Bar.</p><p>Since watching a video doesn't<a id="id325" class="indexterm"/> require the<a id="id326" class="indexterm"/> new <span class="strong"><strong>Immersive Mode</strong></span>, full-screen mode can be achieved using the two flags: <code class="literal">SYSTEM_UI_FLAG_FULLSCREEN</code> and <code class="literal">SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>, available since Android 4.0 (API 14).</p><p>Our recipe will demonstrate setting up Immersive Mode. We're also going to add the ability to toggle the System UI with a tap on the screen.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec157"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">ImmersiveMode</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select <span class="strong"><strong>Empty Activity</strong></span> when prompted for the <span class="strong"><strong>Activity Type</strong></span>. When selecting the <span class="strong"><strong>Minimum API Level</strong></span>, choose <span class="strong"><strong>API 19</strong></span> or higher.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec158"/>How to do it...</h2></div></div></div><p>We'll create two functions for handling the system UI visibility, then we'll create a gesture listener to detect the screen tap. All the steps for this recipe are adding code to <code class="literal">MainActivity.java</code>, so open the file and let's begin:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following method to hide the System UI:<div class="informalexample"><pre class="programlisting">private void hideSystemUi() {
    getWindow().getDecorView().setSystemUiVisibility(
        View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
}</pre></div></li><li class="listitem">Add the following method to show the System UI:<div class="informalexample"><pre class="programlisting">private void showSystemUI() {
    getWindow().getDecorView().setSystemUiVisibility(
        View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
}</pre></div></li><li class="listitem">Add the <a id="id327" class="indexterm"/>following class variable:<div class="informalexample"><pre class="programlisting">private GestureDetectorCompat mGestureDetector;</pre></div></li><li class="listitem">Add the following <code class="literal">GestureListener</code> class at the class level, below the previous class variable:<div class="informalexample"><pre class="programlisting">private class GestureListener extends GestureDetector.SimpleOnGestureListener {
    @Override
    public boolean onDown(MotionEvent event) {
        return true;
    }

    @Override
    public boolean onFling(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY) {
        return true;
    }

    @Override
    public boolean onSingleTapUp(MotionEvent e) {
        if (getSupportActionBar()!= null &amp;&amp; getSupportActionBar().isShowing()) {
            hideSystemUi();
        } else {
            showSystemUI();
        }
        return true;
    }
}</pre></div></li><li class="listitem">Override the <code class="literal">onTouchEvent()</code> callback with the following:<div class="informalexample"><pre class="programlisting">public boolean onTouchEvent(MotionEvent event){
    mGestureDetector.onTouchEvent(event);
    return super.onTouchEvent(event);
}</pre></div></li><li class="listitem">Add the following code to the <code class="literal">onCreate()</code> method to set the <code class="literal">GestureListener</code> and hide the System UI:<div class="informalexample"><pre class="programlisting">mGestureDetector = new GestureDetectorCompat(this, new GestureListener());
hideSystemUi();</pre></div></li><li class="listitem">Run the <a id="id328" class="indexterm"/>application on a device or emulator. Swiping inward across a hidden System Bar will show the System UI. Tapping the screen will toggle the System UI.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec159"/>How it works...</h2></div></div></div><p>We create the <code class="literal">showSystemUI()</code> and <code class="literal">hideSystemUI()</code> methods by using <code class="literal">setSystemUiVisibility()</code> on the application window. The flags we set (and don't set) control what is visible and what is hidden. When we set the visibility without the <code class="literal">SYSTEM_UI_FLAG_IMMERSIVE</code> flag, we in effect, disable Immersive Mode.</p><p>If all we wanted to do was hide the System UI, we could just add <code class="literal">hideSystemUI() </code>to <code class="literal">onCreate()</code> and we'd be done. The problem is it wouldn't stay hidden. Once the user exited Immersive Mode, it would stay in the regular display mode. That's why we created the <code class="literal">GestureListener</code>. (We'll discuss gestures again in <a class="link" href="ch08.html" title="Chapter 8. Using the Touchscreen and Sensors">Chapter 8</a>, <span class="emphasis"><em>Using the Touchscreen and Sensors</em></span>.) Since we only want to respond to the <code class="literal">onSingleTapUp()</code> gesture, we don't implement the full range of gestures. When <code class="literal">onSingleTapUp</code> is detected, we toggle the System UI.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec160"/>There's more...</h2></div></div></div><p>Let's look at some of the other important tasks that can be performed:</p><div class="section" title="Sticky Immersion"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec07"/>Sticky Immersion</h3></div></div></div><p>There's another option we can use if we <a id="id329" class="indexterm"/>want the System UI to stay hidden automatically. Instead of using <code class="literal">SYSTEM_UI_FLAG_IMMERSIVE</code> to hide the UI, we can use <code class="literal">SYSTEM_UI_FLAG_IMMERSIVE_STICKY</code>.</p></div><div class="section" title="Dimming the System UI"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec08"/>Dimming the System UI</h3></div></div></div><p>If all you need is to<a id="id330" class="indexterm"/> reduce the visibility of the Navigation bar, there's also <code class="literal">SYSTEM_UI_FLAG_LOW_PROFILE</code> to dim the UI.</p><p>Use this flag with the same <code class="literal">setSystemUiVisibility()</code> call as the Immersive Mode flag:</p><div class="informalexample"><pre class="programlisting">getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);</pre></div><p>Call <code class="literal">setSystemUiVisibility()</code> with 0 to clear all flags:</p><div class="informalexample"><pre class="programlisting">getWindow().getDecorView().setSystemUiVisibility(0);</pre></div></div><div class="section" title="Setting the Action Bar as an Overlay"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Setting the Action Bar as an Overlay</h3></div></div></div><p>If you just need to hide or show the<a id="id331" class="indexterm"/> Action Bar, use these <a id="id332" class="indexterm"/>methods:</p><div class="informalexample"><pre class="programlisting">getActionBar().hide();
getActionBar().show();</pre></div><p>One problem with this approach is that the system resizes the layout each time either method is called. Instead, you might want to consider using a theme option to make the System UI behave as an overlay. To enable overlay mode, add the following to the theme:</p><div class="informalexample"><pre class="programlisting">&lt;item name="android:windowActionBarOverlay"&gt;true&lt;/item&gt;</pre></div></div><div class="section" title="Translucent system bars"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Translucent system bars</h3></div></div></div><p>These two themes enable the <a id="id333" class="indexterm"/>translucent settings:</p><div class="informalexample"><pre class="programlisting">Theme.Holo.NoActionBar.TranslucentDecor
Theme.Holo.Light.NoActionBar.TranslucentDecor</pre></div><p>If you are creating your own theme, use the following theme settings:</p><div class="informalexample"><pre class="programlisting">&lt;item name="android:windowTranslucentNavigation"&gt;true&lt;/item&gt;
&lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec161"/>See also</h2></div></div></div><p>The <span class="emphasis"><em>Recognizing a gesture</em></span> recipe in <a class="link" href="ch08.html" title="Chapter 8. Using the Touchscreen and Sensors">Chapter 8</a>, <span class="emphasis"><em>Using the Touchscreen and Sensors</em></span>.</p></div></div></body></html>