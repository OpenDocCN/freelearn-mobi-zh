<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Working with Video and Audio</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Playing local FLV video</li><li class="listitem" style="list-style-type: disc">Playing local H.264 video</li><li class="listitem" style="list-style-type: disc">Controlling video</li><li class="listitem" style="list-style-type: disc">Embedding audio</li><li class="listitem" style="list-style-type: disc">Playing embedded audio</li><li class="listitem" style="list-style-type: disc">Streaming audio</li><li class="listitem" style="list-style-type: disc">Controlling audio playback</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec01"/>Introduction</h1></div></div></div><p>With carriers able to support larger downloads and iOS hardware relentlessly marching forward, developers are able to build larger apps. Apple itself acknowledged this by doubling its over-the-air download limit, making it possible to include more bandwidth-heavy content such as video and high-quality audio.</p><p>On the web, the Flash platform has been a leader in both video and audio playback for many years. Adobe AIR brings many of these capabilities to iOS, enabling the creation of apps that will engage, inspire, and immerse the user.</p><p>This chapter will explore the many options for working with video and sound. It will start by guiding you through the steps required to include and play back video, before moving onto the handling of embedded and streaming audio.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec02"/>Playing local FLV video</h1></div></div></div><p>Key to the Flash platform's success over the years has been its FLV file format, which delivers Sorenson Spark or ON2 VP6 encoded video both locally and over the Internet.</p><p>In this recipe, we will see how to load FLV video that has been bundled with an AIR for iOS app.<a id="id976" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec01"/>Getting ready</h2></div></div></div><p>Use<code class="literal"> chapter12\recipe1\recipe.fla</code> from the book's accompanying code bundle as a starting point.</p><p>Also, an FLV video is available from<code class="literal"> chapter12\resources\video.flv</code> and should be copied to<code class="literal"> chapter12\recipe1\</code> before proceeding.<a id="id977" class="indexterm"/>
</p><p>The video is intended to be viewed on a device held in a landscape orientation. To accommodate this requirement, the FLA's stage size has been set to 480x320 pixels rather than the default portrait orientation of 320x480.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec02"/>How to do it...</h2></div></div></div><p>This recipe is split into two main steps. First we will bundle the FLV video with the app, then we will write some ActionScript to play it back.<a id="id978" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec01"/>Bundling the FLV video</h3></div></div></div><p>Perform the following steps to bundle the video with the app:<a id="id979" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Open the AIR for iOS Settings panel by selecting<strong> File</strong> |<strong> AIR for iOS Settings</strong> from Flash's drop-down menu.</li><li class="listitem">If it isn't already selected, click on the panel's<strong> General</strong> tab.</li><li class="listitem">Set the<strong> Rendering</strong> field to<strong> CPU</strong>.</li><li class="listitem">At the bottom of the panel is the<strong> Included files</strong> list. Click on the<strong> +</strong> symbol above the list and select<code class="literal"> chapter12\recipe1\video.flv</code>. The video will now be bundled with your IPA file when the FLA is published.</li><li class="listitem">Click on<strong> OK</strong> to close the AIR for iOS Settings panel.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec02"/>Playing the FLV video</h3></div></div></div><p>With the FLV now included within your FLA, we can turn our attention to the ActionScript required to play it.<a id="id980" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following import statements to the class:<div><pre class="programlisting"><strong>import flash.desktop.NativeApplication;

import flash.desktop.SystemIdleMode;
</strong>
import flash.display.MovieClip;
<strong>
import flash.media.Video;
import flash.net.NetConnection;
import flash.net.NetStream;
</strong>
</pre></div></li><li class="listitem">Declare a constant to store the name of the FLV video:<div><pre class="programlisting">static private const VIDEO_URL:String = "video.flv";
</pre></div></li><li class="listitem">Create three member variables required to play back video:<div><pre class="programlisting">private var netConnection:NetConnection;
private var netStream:NetStream;
private var video:Video;
</pre></div></li><li class="listitem">Within the constructor, load and play back the FLV video:<div><pre class="programlisting">public function Main() {
<strong>
NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;
netConnection = new NetConnection();
netConnection.connect(null);
netStream = new NetStream(netConnection);
netStream.client = this;
netStream.play(VIDEO_URL);
video = new Video();
video.attachNetStream(netStream);
video.width = 480;
video.height = 320;
addChildAt(video, 0);
</strong>
}
</pre></div></li><li class="listitem">You will also need to provide callback methods that capture metadata and cue point events as the FLV plays. Add the following two empty methods to your document class:<div><pre class="programlisting">public function onMetaData(dataObj:Object):void {
; // Do nothing.
}
public function onXMPData(dataObj:Object):void {
; // Do nothing.
}
</pre></div></li><li class="listitem">Save both the class file and your FLA.</li><li class="listitem">Publish the FLA and deploy the IPA to your device.</li></ol></div><p>When launched, the app will load and play the FLV from the file system.<a id="id981" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec03"/>How it works...</h2></div></div></div><p>Our code loads<code class="literal"> video.flv</code> locally from the device and plays it back to the user. All files bundled with an app are copied to its Application directory during installation. This is the same folder where the app itself lives, and is where the FLV video is stored.<a id="id982" class="indexterm"/>
</p><p>Loading and playing the video is a three-stage process that involves the<code class="literal"> NetConnection, NetStream</code>, and<code class="literal"> Video</code> classes.</p><p>First a<code class="literal"> NetConnection</code> object is created and<code class="literal"> null</code> is passed to its<code class="literal"> connect()</code> method. This indicates that we won't be connecting to a Flash Media Server, and instead intend to either connect to a file that is stored locally on the device's file system or hosted on a web server. For this recipe, we used the local FLV that we bundled with the app:<a id="id983" class="indexterm"/>
</p><div><pre class="programlisting">netConnection = new NetConnection();
netConnection.connect(null);
</pre></div><p>Next a<code class="literal"> NetStream</code> object is created and used to play the actual video. The<code class="literal"> NetConnection</code> object is passed to the<code class="literal"> NetStream</code> object's constructor, allowing it to stream the local video from the device:</p><div><pre class="programlisting">netStream = new NetStream(netConnection);
netStream.client = this;
netStream.play(VIDEO_URL);
</pre></div><p>Finally the<code class="literal"> NetStream</code> object is attached to a<code class="literal"> Video</code> object, allowing the video to be displayed to the user:</p><div><pre class="programlisting">video = new Video();
video.attachNetStream(netStream);
video.width = 480;
video.height = 320;
addChildAt(video, 0);
</pre></div><p>The<code class="literal"> Video</code> class inherits from<code class="literal"> flash.display.DisplayObject</code>, meaning it can be added to the display list and manipulated in an identical manner to all other display objects. Two<code class="literal"> DisplayObject</code> properties that we use are<code class="literal"> width</code> and<code class="literal"> height</code> to set the video's size on screen. In order to maximize playback performance, ensure the dimensions match that of the FLV perfectly. Scaling an FLV video will degrade performance.</p><p>Notice that CPU rendering was selected for this recipe. Although the GPU can be used, the hardware video decoder isn't capable of decoding arbitrary resolutions, which can sometimes lead to the incorrect sizing of your<code class="literal"> Video</code> object. Additionally, if you are using Flash Professional CS5 and AIR 2.0, then avoid GPU rendering of video altogether.</p><p>For more information, perform a search for<code class="literal"> flash.net.NetConnection, flash.net.NetStream</code>, and<code class="literal"> flash.media.Video</code> within Adobe Community Help.<a id="id984" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec04"/>There's more...</h2></div></div></div><p>Now let us go back to the subject of metadata and cue points. We will also touch upon a few other considerations before moving on.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec03"/>Metadata and cue point events</h3></div></div></div><p>As a video plays, its<code class="literal"> NetStream</code> object can be used to capture and process cue point and various metadata events including<code class="literal"> onMetaData</code> and<code class="literal"> onXMPData</code>.</p><p>While this recipe had no need for these events, we still had to write empty callback handlers for each. Failing to do so will result in a runtime exception being thrown when an event is triggered.<a id="id985" class="indexterm"/>
</p><p>To handle these events, set the<code class="literal"> NetStream</code> object's<code class="literal"> client</code> property to an object that contains callback methods for each. The method names must match those of the events exactly. For this recipe, we simply set the<code class="literal"> client</code> property to<code class="literal"> this</code> and added the handlers to the document class.</p><p>Refer to<a class="ulink" href="http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html"> http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html</a> for details regarding how to actually use the data from cue point and metadata events.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec04"/>Playing remote FLV video</h3></div></div></div><p>In addition to local playback, FLV video can be progressively streamed over HTTP from a remote location. Simply pass the video's URL to the<code class="literal"> NetStream.play()</code> method to commence playback. You can also determine the status of the<code class="literal"> NetStream</code> object's internal playback buffer by listening for it dispatching<code class="literal"> NetStatusEvent.NET_STATUS</code>.<a id="id986" class="indexterm"/>
</p><p>You can find more information about available<code class="literal"> NetStream</code> events at<a class="ulink" href="http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html"> http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec05"/>Screen lock</h3></div></div></div><p>When watching video, the screen will dim after a short period of inactivity from the user. Within this recipe's constructor, we prevent this from happening by setting<code class="literal"> NativeApplication.systemIdleMode</code> to<code class="literal"> SystemIdleMode.KEEP_AWAKE</code>.</p><p>While indefinitely preventing the screen from locking is acceptable for demonstration purposes, it is unlikely to be suitable for real-world applications. A better practice is to disable screen locking during playback of a video, and then re-enable it when the video is paused or stopped.<a id="id987" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec06"/>Maximizing playback performance</h3></div></div></div><p>To maximize performance, minimize your display list and try not to overlay other graphical elements on top of the video during playback. Also attempt to limit the amount of ActionScript being executed during playback. This is especially true of older first and second generation hardware where FLV performance can struggle.<a id="id988" class="indexterm"/>
</p><p>If you are using the AIR 3.0 SDK or above, then consider using hardware accelerated H.264 video above FLV as its playback performance and video quality is significantly better.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec07"/>Bundling multiple videos</h3></div></div></div><p>Files can be added individually to the<strong> Included files</strong> list, or you can specify a folder for inclusion. This is convenient when writing apps that have multiple videos as you can simply group the files within a single location. Every file within the folder will be bundled with your IPA.<a id="id989" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec05"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Playing local H.264 video</em></li><li class="listitem" style="list-style-type: disc"><em>Controlling video</em></li><li class="listitem" style="list-style-type: disc"><em>Preventing screen idle, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></li><li class="listitem" style="list-style-type: disc"><em>Understanding GPU-Blend mode, <a class="link" href="ch06.html" title="Chapter 6. Graphics and Hardware Acceleration">Chapter 6</a></em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec03"/>Playing local H.264 video</h1></div></div></div><p>AIR for iOS now provides support for the high-quality, low bit-rate H.264 video format, enabling best-in-class high-definition playback through the<code class="literal"> StageVideo</code> class. By taking advantage of hardware acceleration, H.264 video reduces CPU usage and consumes less memory than comparable formats including FLV.<a id="id990" class="indexterm"/>
</p><p>In this recipe, we will play back H.264 video that has been bundled locally with an app.<a id="id991" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec06"/>Getting ready</h2></div></div></div><p>The steps covered here are applicable only to those using AIR 3.0 and above. If you are using Flash Professional CS5, then you will be unable to attempt this recipe.</p><p>From the chapter's accompanying code bundle, use<code class="literal"> chapter12\recipe2\recipe.fla</code> as a starting point.</p><p>An H.264 encoded video is available from<code class="literal"> chapter12\resources\video.mp4</code> and should be copied to<code class="literal"> chapter12\recipe2\</code> before proceeding.</p><p>The video is intended to be viewed on a device held in a landscape orientation. To accommodate this requirement, the FLA's stage size has been set to 480x320 pixels rather than the default portrait orientation of 320x480.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec07"/>How to do it...</h2></div></div></div><p>This recipe is broken into two main steps. First we will bundle the H.264 video with the app, before writing some ActionScript to play it back.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec08"/>Bundling the H.264 video</h3></div></div></div><p>Perform the following steps to bundle the video with the app:<a id="id992" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Open the AIR for iOS Settings panel by selecting<strong> File</strong> |<strong> AIR for iOS Settings</strong> from Flash's drop-down menu.</li><li class="listitem">If it isn't already selected, click on the panel's<strong> General</strong> tab.</li><li class="listitem">Set the<strong> Rendering</strong> field to<strong> GPU</strong>.</li><li class="listitem">At the bottom of the panel is the<strong> Included files</strong> list. Click on the<strong> +</strong> symbol above the list and select<code class="literal"> chapter12\recipe2\video.mp4</code>. The file will now be bundled with your IPA file when the FLA is published.</li><li class="listitem">Click on<strong> OK</strong> to close the AIR for iOS Settings panel.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec09"/>Playing the H.264 video</h3></div></div></div><p>With the video now included within your FLA, we can turn our attention to the ActionScript required to play it.<a id="id993" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following import statements to the class:<div><pre class="programlisting"><strong>import flash.desktop.NativeApplication;
import flash.desktop.SystemIdleMode;
</strong>
import flash.display.MovieClip;
<strong>import flash.geom.Rectangle;
import flash.media.StageVideo;
import flash.net.NetConnection;
import flash.net.NetStream;
</strong>
</pre></div></li><li class="listitem">Declare a constant to store the name of the video:<div><pre class="programlisting">static private const VIDEO_URL:String = "video.mp4";
</pre></div></li><li class="listitem">Create three member variables required to play back video:<div><pre class="programlisting">private var netConnection:NetConnection;
private var netStream:NetStream;
private var video:StageVideo;
</pre></div></li><li class="listitem">Within the constructor, set-up and play back the video:<div><pre class="programlisting">public function Main() {
<strong>
NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;
netConnection = new NetConnection();
netConnection.connect(null);
netStream = new NetStream(netConnection);
netStream.client = this;
video = stage.stageVideos[0];
video.attachNetStream(netStream);
video.viewPort = new Rectangle(0, 25, 480, 270);
netStream.play(VIDEO_URL);
</strong>
}
</pre></div></li><li class="listitem">You will also need to provide a callback method that captures metadata events as the video plays. Add the following empty method to your document class:<div><pre class="programlisting">public function onMetaData(dataObj:Object):void {
; // Do nothing.
}
</pre></div></li><li class="listitem">Save both the class file and your FLA.<div><h3 class="title"><a id="note48"/>Note</h3><p>The AIR Debug Launcher (ADL) does not currently support H.264 video playback. If you attempt to test this recipe using ADL, then you will receive a runtime error.</p></div></li><li class="listitem">Publish the FLA and deploy the IPA to your device.</li></ol></div><p>When launched, the app will load and play the H.264 video from the file system.<a id="id994" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec08"/>How it works...</h2></div></div></div><p>Our code loads<code class="literal"> video.mp4</code> locally from the device and plays it back to the user. All files bundled with an app are copied to its Application directory during installation. This is the same folder where the app itself lives and is where the H.264 video is stored.<a id="id995" class="indexterm"/>
</p><p>Loading and playing the video is a four-step process that involves the<code class="literal"> NetConnection, NetStream</code>, and<code class="literal"> StageVideo</code> classes.</p><p>First a<code class="literal"> NetConnection</code> object is created and<code class="literal"> null</code> is passed to its<code class="literal"> connect()</code> method. This indicates that we won't be connecting to a Flash Media Server, and instead intend to either connect to a file that is stored locally on the device's file system or hosted on a web server. For this recipe, we used the local FLV that we bundled with the app:</p><div><pre class="programlisting">netConnection = new NetConnection();
netConnection.connect(null);
</pre></div><p>Next a<code class="literal"> NetStream</code> object is created and will be used to play the actual video. The<code class="literal"> NetConnection</code> object is passed to the<code class="literal"> NetStream</code> object's constructor, allowing it to stream the local video from the device:</p><div><pre class="programlisting">netStream = new NetStream(netConnection);
netStream.client = this;
</pre></div><p>The<code class="literal"> NetStream</code> object needs to be attached to a<code class="literal"> StageVideo</code> object in order for it to be displayed to the user. However, you don't explicitly create one yourself. Instead a<code class="literal"> StageVideo</code> object is obtained from a vector array made available by the<code class="literal"> Stage</code> object's<code class="literal"> stageVideos</code> property. On iOS devices, this vector will contain a single<code class="literal"> StageVideo</code> instance capable of rendering video:<a id="id996" class="indexterm"/>
</p><div><pre class="programlisting">video = stage.stageVideos[0];
video.attachNetStream(netStream);
</pre></div><p>The final step is to create a viewport for the video and begin playback. Video rendered by the<code class="literal"> StageVideo</code> class is hardware-accelerated and not part of the display list. Instead,<code class="literal"> StageVideo</code> instances are rendered behind the display list within a rectangular region, which specifies the absolute position and size of the video. Once the viewport has been defined, call the<code class="literal"> NetStream</code> object's<code class="literal"> play()</code> method:<a id="id997" class="indexterm"/>
</p><div><pre class="programlisting">video.viewPort = new Rectangle(0, 25, 480, 270);
netStream.play(VIDEO_URL);
</pre></div><p>The video used for this recipe is 400x224 pixels in size, but you may have noticed in the code above that the viewport has been assigned a rectangular region of 480x270. This scales the video to cover the screen's entire horizontal width while still maintaining the video's aspect ratio. Also, the viewport is shifted down by 25 pixels to ensure that it is vertically centered on screen.<a id="id998" class="indexterm"/>
</p><p>GPU rendering was selected for this recipe. Decoding H.264 video is computationally expensive and requires hardware to ensure acceptable playback performance on iOS devices. Although the video is not part of the display list, it does sit behind it, meaning display objects such as UI components can be overlaid on top.</p><p>For more information, perform a search for<code class="literal"> flash.net.NetConnection, flash.net.NetStream</code>, and<code class="literal"> flash.media.StageVideo</code> within Adobe Community Help.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec09"/>There's more...</h2></div></div></div><p>Now let us go back to the subject of metadata. We will also touch upon a few other considerations before moving on.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec10"/>Metadata and cue point events</h3></div></div></div><p>As a video plays, its<code class="literal"> NetStream</code> object can be used to capture and process cue point and various metadata events including<code class="literal"> onMetaData, onCuePoint</code>, and<code class="literal"> onXMPData</code>.<a id="id999" class="indexterm"/>
</p><p>While this recipe had no need for the<code class="literal"> onMetaData</code> event, we still had to write an empty callback handler for it. Failing to do so will result in a runtime exception being thrown when the event is triggered.<a id="id1000" class="indexterm"/>
</p><p>To handle this, and other events, set the<code class="literal"> NetStream</code> object's<code class="literal"> client</code> property to an object that contains callback methods for each. The method names must match those of the events exactly. For this recipe, we simply set the<code class="literal"> client</code> property to<code class="literal"> this</code> and added the handlers to the document class.</p><p>Refer to<a class="ulink" href="http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html"> http://help.adobe.com/en_US/as3/dev/WSD30FA424-950E-43ba-96C8-99B926943FE7.html</a> for details regarding how to actually use the data from cue point and metadata events.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec11"/>Playing video captured by the default camera</h3></div></div></div><p>Video successfully captured using the<code class="literal"> CameraUI</code> class is stored temporarily on the device's file system. Using the<code class="literal"> MediaEvent</code> object dispatched by<code class="literal"> CameraUI</code>, it is possible to determine the video's URL in order to play it back. An example is given as follows:<a id="id1001" class="indexterm"/>
</p><div><pre class="programlisting">private function captured(e:MediaEvent):void {
<strong>var mediaPromise:MediaPromise = e.data;
var videoUrl:String = mediaPromise.file.url;
</strong>
playVideo(videoUrl);
}
</pre></div><p>Once you have the URL, you can simply pass it to your<code class="literal"> NetStream</code> object's<code class="literal"> play()</code> method to initiate playback.</p><p>The<code class="literal"> CameraUI</code> class is covered in the<em> Capturing with the default camera app</em> recipe from<a class="link" href="ch10.html" title="Chapter 10. Camera and Microphone Support"> Chapter 10</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec12"/>Determining the video's size</h3></div></div></div><p>You can retrieve the width and height of the encoded video from a<code class="literal"> StageVideo</code> object's<code class="literal"> videoWidth</code> and<code class="literal"> videoHeight</code> read-only properties. However, you first need to wait for this information to become available by listening for<code class="literal"> StageVideoEvent.RENDER_STATE</code> being dispatched from your<code class="literal"> StageVideo</code> instance.<a id="id1002" class="indexterm"/>
</p><p>Also, be careful when playing back video captured from the device's camera. On iOS, the camera captures video in landscape orientation. If your application uses a portrait aspect ratio, then you will need to swap the values of the<code class="literal"> videoWidth</code> and<code class="literal"> videoHeight</code> properties when specifying your viewport's dimensions.</p><p>For more information, perform a search for<code class="literal"> flash.events.StageVideoEvent</code> within Adobe Community Help.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec13"/>Playing remote H.264 video</h3></div></div></div><p>In addition to local playback, H.264 video can be progressively streamed over HTTP from a remote location. Simply pass the video's URL to the<code class="literal"> NetStream.play()</code> method to commence playback. You can also determine the status of the<code class="literal"> NetStream</code> object's internal playback buffer by listening for it dispatching a<code class="literal"> NetStatusEvent.NET_STATUS</code> event.<a id="id1003" class="indexterm"/>
</p><p>You can find more information about available<code class="literal"> NetStream</code> events at<a class="ulink" href="http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html"> http://help.adobe.com/en_US/as3/dev/WS901d38e593cd1bac-3d11a09612fffaf8447-8000.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec14"/>Encoding H.264 video</h3></div></div></div><p>H.264 video playback can be computationally expensive. With such a wide range of hardware configurations across the range of iOS devices, it is important that the correct encoding strategy is employed to guarantee playback on the lowest common denominator. Adobe provides some H.264 encoding recommendations at<a class="ulink" href="http://www.adobe.com/devnet/devices/articles/mobile_video_encoding.html"> www.adobe.com/devnet/devices/articles/mobile_video_encoding.html</a>.<a id="id1004" class="indexterm"/>
</p><p>You can encode video using the H.264 codec with Adobe Media Encoder, which comes with Flash Professional as an optional install. An introduction to Adobe Media Encoder can be found on the Adobe Developer Connection website at<a class="ulink" href="http://www.adobe.com/devnet/flash/quickstart/video_encoder.html"> www.adobe.com/devnet/flash/quickstart/video_encoder.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec15"/>Bundling multiple videos</h3></div></div></div><p>Files can be added individually to the<strong> Included files</strong> list, or you can specify a folder for inclusion. This is convenient when writing apps that have multiple videos as you can simply group the files within a single location. Every file within the folder will be bundled with your IPA.<a id="id1005" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec10"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Controlling video</em></li><li class="listitem" style="list-style-type: disc"><em>Preventing screen idle, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></li><li class="listitem" style="list-style-type: disc"><em>Understanding GPU-Vector mode, <a class="link" href="ch06.html" title="Chapter 6. Graphics and Hardware Acceleration">Chapter 6</a></em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec04"/>Controlling video</h1></div></div></div><p>As well as commencing playback, the<code class="literal"> NetStream</code> class provides additional control of video. In this recipe, we will add the ability for the user to pause, resume, and restart either an FLV or H.264 video.<a id="id1006" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec11"/>Getting ready</h2></div></div></div><p>From the book's accompanying code bundle, open either<code class="literal"> chapter12\recipe3-flv\recipe.fla</code> or<code class="literal"> chapter12\recipe3-mp4\recipe.fla</code> and use it as a starting point. The first FLA's document class contains the code written for the<em> Playing local FLV video</em> recipe, while the second FLA contains the code from the<em> Playing local H.264 video</em> recipe.</p><p>Two movie clips have been added to the stage. The first has been given an instance name of<code class="literal"> blocker</code>. The second has been named<code class="literal"> controls</code> and sits in front of<code class="literal"> blocker</code>. Both movie clips will sit in front of the FLV or H.264 video.</p><p>Within the<code class="literal"> controls</code> movie clip are three buttons named<code class="literal"> playBtn, restartBtn</code>, and<code class="literal"> resumeBtn</code>. These will be used to play, restart, and un-pause the video respectively. Tapping anywhere on the screen during playback will pause the video.<a id="id1007" class="indexterm"/>
</p><p>The<code class="literal"> blocker</code> movie clip has an alpha transparency of 60% and will be used to dim the video when it is currently being paused. During playback,<code class="literal"> blocker</code> will be made invisible ensuring that the video isn't obscured. The following screenshot shows the video being dimmed by the<code class="literal"> blocker</code> movie clip:</p><div><img src="img/1383_13_01.jpg" alt="Getting ready"/></div><p>Before proceeding, you will also need to copy either an FLV or H.264 video to your FLA's root directory. If you are working with FLV video, then copy<code class="literal"> chapter12\resources\video.flv</code> to<code class="literal"> chapter12\recipe3-flv\</code>. For H.264 video, copy<code class="literal"> chapter12\resources\video.mp4</code> to<code class="literal"> chapter12\recipe3-mp4\</code>.<a id="id1008" class="indexterm"/>
</p><p>Okay, let us write the ActionScript required for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec12"/>How to do it...</h2></div></div></div><p>Open the FLA's document class and make the following changes to it:</p><div><ol class="orderedlist"><li class="listitem">Add two new import statements:<div><pre class="programlisting">import flash.events.MouseEvent;
import flash.events.NetStatusEvent;
</pre></div></li><li class="listitem">Within the constructor, listen for the<code class="literal"> NetStream</code> instance dispatching a<code class="literal"> NetStatusEvent.NET_STATUS</code> event:<a id="id1009" class="indexterm"/><div><pre class="programlisting">netStream = new NetStream(netConnection);
netStream.client = this;
<strong>netStream.addEventListener(NetStatusEvent.NET_STATUS, statusUpdated);
</strong>
</pre></div></li><li class="listitem">Also, remove the following line of code from the constructor:<div><pre class="programlisting">netStream.play(VIDEO_URL);
</pre></div><div><h3 class="title">Note</h3><p>In the line above and throughout this recipe,<code class="literal"> VIDEO_URL</code> is a constant containing the URL to the local video to be played. It will point to either<code class="literal"> video.flv</code> or<code class="literal"> video.mp4</code> depending on whether you are working with FLV or H.264 video.</p></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">We no longer want the video to start playing immediately. Instead we will wait for the user to tap the Play button.</li></ul></div></li><li class="listitem">Finally, at the end of the constructor, call a support method that will set up the playback controls:<div><pre class="programlisting">setupControls();
</pre></div></li><li class="listitem">Now add the actual<code class="literal"> setupControls()</code> method. Add an event listener to each of the control buttons and make only the Play button visible initially—we will show the other buttons only when the video is paused.<a id="id1010" class="indexterm"/><div><pre class="programlisting">private function setupControls():void {
controls.playBtn.addEventListener(MouseEvent.MOUSE_UP, playVideo);
controls.restartBtn.addEventListener(MouseEvent.MOUSE_UP, restartVideo);
controls.resumeBtn.addEventListener(MouseEvent.MOUSE_UP, resumeVideo);
stage.addEventListener(MouseEvent.MOUSE_UP, pauseVideo);
showBtns(["playBtn"]);
}
</pre></div></li><li class="listitem">When the Play button is pressed, we will begin playback of the video and hide the controls from view. Add the following event handler to do this:<div><pre class="programlisting">private function playVideo(e:MouseEvent):void {
netStream.play(VIDEO_URL);
hideBtns();
e.stopPropagation();
}
</pre></div></li><li class="listitem">The user will be able to pause the video by tapping anywhere on the screen during playback. When paused, the control panel's Restart and Resume buttons will be shown. Add an event handler for this and pause the<code class="literal"> NetStream</code> object's video stream:<div><pre class="programlisting">private function pauseVideo(e:MouseEvent):void {
if(controls.visible == false)
{
netStream.pause();
showBtns(["resumeBtn", "restartBtn"]);
}
}
</pre></div></li><li class="listitem">Now add an event handler for the Restart button. This handler will move back to the beginning of the<code class="literal"> NetStream</code> object's video and also hide the controls from view:<a id="id1011" class="indexterm"/><div><pre class="programlisting">private function restartVideo(e:MouseEvent):void {
netStream.seek(0);
netStream.resume();
hideBtns();
e.stopPropagation();
}
</pre></div></li><li class="listitem">Write a similar handler for the Resume button, un-pausing the<code class="literal"> NetStream</code> object's video stream:<div><pre class="programlisting">private function resumeVideo(e:MouseEvent):void {
netStream.resume();
hideBtns();
e.stopPropagation();
}
</pre></div></li><li class="listitem">We also want to offer the user the chance to watch the video again once it has played to completion. Write a handler for the<code class="literal"> NetStream</code> object's<code class="literal"> NET_STATUS</code> event and show the Play button if the video has stopped:<div><pre class="programlisting">private function statusUpdated(e:NetStatusEvent):void {
if(e.info.code == "NetStream.Play.Stop")
{
showBtns(["playBtn"]);
}
}
</pre></div></li><li class="listitem">We are just about finished. Add the following two support methods to manage the visibility of the control buttons and the blocker:<div><pre class="programlisting">private function hideBtns():void {
controls.visible = false;
blocker.visible = false;
}
private function showBtns(btns:Array):void {
controls.visible = true;
blocker.visible = true;
for(var instName:String in controls)
{
if(btns.indexOf(instName) != -1)
{
controls[instName].visible = true;
}
else
{
controls[instName].visible = false;
}
}
}
</pre></div></li><li class="listitem">Save your document class and move back to the FLA.</li><li class="listitem">Publish and test the app on your device.<a id="id1012" class="indexterm"/></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec13"/>How it works...</h2></div></div></div><p>The following three methods of the<code class="literal"> NetStream</code> class were used to control video playback:<a id="id1013" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pause():</code> Pauses the current video stream<a id="id1014" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">resume():</code> Resumes playback of the paused video stream<a id="id1015" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">seek():</code> Moves to a specific point in time within the video stream<a id="id1016" class="indexterm"/></li></ul></div><p>The<code class="literal"> seek()</code> method expects a time, measured in seconds, to move to. The time is actually an approximation as the<code class="literal"> NetStream</code> object will move to the keyframe closest to it.</p><p>It should also be noted that the<code class="literal"> play()</code> method should not be used to resume playback. It is used for commencing playback only. Instead call<code class="literal"> resume()</code> to continue playback of a paused video.</p><p>The<code class="literal"> NetStream</code> class does not provide a<code class="literal"> stop()</code> method. Within our code example, the paused video was restarted from the beginning by seeking to the first keyframe, then resuming playback.<a id="id1017" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec14"/>There's more...</h2></div></div></div><p>Here are some last words before we leave video and move on to audio.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec16"/>NetStream status</h3></div></div></div><p>The<code class="literal"> NetStatusEvent</code> object is dispatched in response to a plethora of useful status changes, errors, and warnings. Here are just a few strings that the<code class="literal"> info.code</code> property can be queried for:<a id="id1018" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NetStream.Play.Start:</code> Playback has started</li><li class="listitem" style="list-style-type: disc"><code class="literal">NetStream.Play.Stop:</code> Playback has stopped</li><li class="listitem" style="list-style-type: disc"><code class="literal">NetStream.Play.StreamNotFound:</code> The video file cannot be found</li><li class="listitem" style="list-style-type: disc"><code class="literal">NetStream.Play.InsufficientBW:</code> The client does not have sufficient bandwidth to play the video at its intended frame rate</li><li class="listitem" style="list-style-type: disc"><code class="literal">NetStream.Pause.Notify:</code> The stream has paused</li><li class="listitem" style="list-style-type: disc"><code class="literal">NetStream.Unpause.Notify:</code> The stream has un-paused</li><li class="listitem" style="list-style-type: disc"><code class="literal">NetStream.Buffer.Flush:</code> Playback has ended and the buffer is now empty</li></ul></div><p>You can determine the code's type by examining the<code class="literal"> info.level</code> property, which will be set to one of the following strings:<code class="literal"> status, error</code>, or<code class="literal"> warning</code>. For a comprehensive list of supported strings, perform a search for<code class="literal"> flash.events.NetStatusEvent</code> within Adobe Community Help.</p><p>The<code class="literal"> flash.net.NetConnection</code> object also dispatches<code class="literal"> NetStatusEvent</code> objects, which you can listen for.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec17"/>Closing the video stream</h3></div></div></div><p>When you are done with a video and you have no more need for it, call the<code class="literal"> NetStream</code> object's<code class="literal"> close()</code> method. This will stop the playback of the video and make the stream available for some other use.<a id="id1019" class="indexterm"/>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec05"/>Embedding audio</h1></div></div></div><p>Sound is an important part of any application and when applied correctly can immerse the user within the interactive experience. In order to provide this experience, it is important that latency is minimized during playback. For example, there should be no delay when playing game sound effects or providing audio feedback from a user interface.<a id="id1020" class="indexterm"/>
</p><p>Flash allows sound files to be embedded directly within the library, providing the fastest playback path for your audio. Let us walk through the steps required to do this.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec15"/>How to do it...</h2></div></div></div><p>Perform the following steps to embed sound within an FLA's library:</p><div><ol class="orderedlist"><li class="listitem">From Flash Professional, create a new AIR for iOS document by selecting<strong> File</strong> |<strong> New</strong> <em>(Ctrl + N</em> |<em> Cmd</em> +<em> N)</em>. From the<strong> New Document</strong> panel, select the<strong> AIR for iOS</strong> document type and click on the<strong> OK</strong> button.<a id="id1021" class="indexterm"/><div><h3 class="title"><a id="note49"/>Note</h3><p>If you are a Flash Professional CS5 user, then it is known as an<strong> iPhone OS</strong> document rather than an<strong> AIR for iOS</strong> document.</p></div></li><li class="listitem">Select<strong> File</strong> |<strong> Import</strong> |<strong> Import to Library</strong> from Flash's drop-down menu. A file browser window will appear.</li><li class="listitem">From the browser window, navigate to and select<code class="literal"> chapter12\resources\sound.mp3</code>. Click on the<strong> Open</strong> button. The sound file will be imported and listed within the Library panel as<strong> sound.mp3</strong>.</li><li class="listitem">From the Library panel, right-click on<strong> sound.mp3</strong> and select<strong> Properties</strong> from the drop-down menu. The<strong> Sound Properties</strong> panel will open.</li><li class="listitem">From the<strong> Sound Properties</strong> panel, select<strong> ADPCM</strong> from the<strong> Compression</strong> drop-down box. Ensure that the<strong> Convert stereo to mono</strong> checkbox is selected; set the<strong> Sample rate</strong> to<strong> 22kHz</strong> and<strong> ADPCM bits</strong> to<strong> 4 bit</strong>. If you are using Flash Professional CS5.5, then, as shown in the following screenshot, ensure that the panel's<strong> Options</strong> tab is selected first.<div><img src="img/1383_13_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Now check the<strong> Export for ActionScript</strong> checkbox and change the text within the<strong> Class</strong> field to<code class="literal"> SoundEffect</code>. If you are using Flash Professional CS5.5, then this should be performed from the panel's<strong> ActionScript</strong> tab.<a id="id1022" class="indexterm"/></li><li class="listitem">Click on the<strong> OK</strong> button to close the panel.</li><li class="listitem">Depending on your preference settings within Flash Professional, a warning panel may appear containing the following text:<p><strong>A definition for this class could not be found in the classpath, so one will be automatically generated in the SWF file upon export.
</strong>
</p><p>This is expected. Click on the <strong>OK</strong> button to continue. The sound file has been assigned an ActionScript class name of SoundEffect.
</p></li><li class="listitem">Save your FLA.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec16"/>How it works...</h2></div></div></div><p>Embedding sound files within your library places them directly within the application's binary, making them immediately available for playback. However, adding sound files this way will increase your application's file size. The larger your application becomes, the longer it will take to load and the more memory it will consume. Before embedding a sound file, consider carefully whether or not you actually need immediate access to it.<a id="id1023" class="indexterm"/>
</p><p>It is also important that you select the appropriate audio codec for your embedded sound. Flash provides two types of codec: compressed and uncompressed. Compressed sound, such as MP3, consumes less space than an uncompressed sound, such as ADPCM. However, the device needs to decode the audio during playback which can be demanding especially if you are attempting to play several compressed sounds at once.</p><p>If you need to simultaneously play multiple sound files and with minimum latency, then use an uncompressed codec. Flash provides both ADPCM and RAW for this. Of course, using uncompressed audio will increase the memory consumed by your app.</p><p>If you are only playing a single sound at any one time, then opt for MP3. Doing so will reduce your app's memory footprint.</p><p>If you want to access your embedded audio using ActionScript, then you must assign a unique class name to each sound within the library. For this recipe, we assigned the class name<code class="literal"> SoundEffect</code> to our embedded sound.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec17"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating an AIR for iOS document, <a class="link" href="ch02.html" title="Chapter 2. Building iOS Apps Using Flash">Chapter 2</a></em></li><li class="listitem" style="list-style-type: disc"><em>Playing embedded audio</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec06"/>Playing embedded audio</h1></div></div></div><p>ActionScript can be used to play back sound files embedded within an FLA's library. The sound must have a unique class name associated with it.<a id="id1024" class="indexterm"/>
</p><p>In this recipe, we will cover how to play such embedded sounds.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec18"/>Getting ready</h2></div></div></div><p>From the book's code bundle, open<code class="literal"> chapter12\recipe5\recipe.fla</code> into Flash Professional and use it as a starting point.</p><p>The embedded sound from the<em> Embedding audio</em> recipe can be found in the FLA's library and has a class name of<code class="literal"> SoundEffect</code> linked to it.</p><p>Also, sitting on the stage is a button named<code class="literal"> playBtn</code>. We will play the embedded sound whenever this button is pressed.<a id="id1025" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec19"/>How to do it...</h2></div></div></div><p>Perform the following steps to play the sound associated with the<code class="literal"> SoundEffect</code> class:<a id="id1026" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Import the<code class="literal"> MouseEvent</code> class and listen for<code class="literal"> playBtn</code> being pressed:<div><pre class="programlisting">package {
import flash.display.MovieClip;
<strong>import flash.events.MouseEvent;
</strong>
public class Main extends MovieClip {
public function Main() {
<strong>playBtn.addEventListener(MouseEvent.MOUSE_UP, playSound);
</strong>
}
}
}
</pre></div></li><li class="listitem">Now add an event handler for the button and within it create an instance of the embedded sound's<code class="literal"> SoundEffect</code> class:<div><pre class="programlisting">private function playSound(e:MouseEvent):void {
var soundEffect:SoundEffect = new SoundEffect();
}
</pre></div></li><li class="listitem">Staying within the handler, call the<code class="literal"> SoundEffect</code> object's<code class="literal"> play()</code> method:<div><pre class="programlisting">private function playSound(e:MouseEvent):void {
var soundEffect:SoundEffect = new SoundEffect();
<strong>soundEffect.play();
</strong>
}
</pre></div></li><li class="listitem">Save both your class file and the FLA.</li><li class="listitem">Publish the app and test it on your device. Tap the button to initiate playback of the sound. Repeatedly tap the button to initiate several instances of it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec20"/>How it works...</h2></div></div></div><p>Audio is played using a<code class="literal"> flash.media.Sound</code> object. All embedded sounds that are linked for ActionScript usage will inherit from this class.<a id="id1027" class="indexterm"/>
</p><p>To use an embedded sound, simply instantiate it, then call its<code class="literal"> play()</code> method. This is just one of many methods and properties that are provided by the<code class="literal"> Sound</code> class.</p><p>In this recipe, we used an embedded sound file that had a class name of<code class="literal"> SoundEffect</code> assigned to it. The following two lines of code were all that was needed to play it:</p><div><pre class="programlisting">var soundEffect:SoundEffect = new SoundEffect();
soundEffect.play();
</pre></div><p>When<code class="literal"> play()</code> is called, a<code class="literal"> SoundChannel</code> object is created to play back the sound. Successive calls to<code class="literal"> play()</code> creates new<code class="literal"> SoundChannel</code> objects which independently play their own copy of the sound. You can hear this in action by repeatedly tapping the Play button within this recipe's example app.</p><p>Although we had no use for it in this recipe, the<code class="literal"> play()</code> method returns a reference to a newly instantiated<code class="literal"> SoundChannel</code> object, which can be used to control the sound's playback. This is covered in the<em> Controlling audio playback</em> recipe in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec21"/>There's more...</h2></div></div></div><p>Let us look at a few more options available when playing sound.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec18"/>Playback position</h3></div></div></div><p>The<code class="literal"> play()</code> method has a number of default parameters, the first of which starts playback from a specified position within the sound. The following example shows playback being commenced 500 milliseconds from the start:<a id="id1028" class="indexterm"/>
</p><div><pre class="programlisting">soundEffect.play(500);
</pre></div><p>If omitted, the sound will be played from the beginning.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec19"/>Looping</h3></div></div></div><p>A sound can be looped by passing a value to the<code class="literal"> play()</code> method's second parameter. In the following example, the sound plays at a point 200 milliseconds from the start, six times in succession:<a id="id1029" class="indexterm"/>
</p><div><pre class="programlisting">soundEffect.play(200, 6);
</pre></div><p>If omitted, playback will occur only once.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec22"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Embedding audio</em></li><li class="listitem" style="list-style-type: disc"><em>Controlling audio playback</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec07"/>Streaming audio</h1></div></div></div><p>When working with large sound files, you may want to keep them outside your application's binary in order to minimize its load time and memory consumption. The<code class="literal"> Sound</code> class can stream an MP3 file from the web or locally from the device's file system, removing the need to embed the audio directly within your FLA.<a id="id1030" class="indexterm"/>
</p><p>In this recipe, we will bundle an MP3 file with an app and progressively play it back.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec23"/>Getting ready</h2></div></div></div><p>An<code class="literal"> .mp3</code> file has been provided for this recipe. Using either Windows Explorer or Finder, copy<code class="literal"> chapter12\resources\music.mp3</code> from the book's accompanying code bundle to<code class="literal"> chapter12\recipe6\</code>.</p><p>Open<code class="literal"> chapter12\recipe6\recipe.fla</code> within Flash Professional. Sitting in the center of the stage is a button named<code class="literal"> playBtn</code>. We will write some ActionScript to stream<code class="literal"> music.mp3</code> whenever this button is pressed.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec24"/>How to do it...</h2></div></div></div><p>This recipe will be split into two parts. First we will bundle an MP3 with the app, then we will write the ActionScript required to play it.<a id="id1031" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec20"/>Bundling the MP3 file</h3></div></div></div><p>Follow the steps to bundle the<code class="literal"> .mp3</code> file with your app:<a id="id1032" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Open the AIR for iOS Settings panel by selecting<strong> File</strong> |<strong> AIR for iOS Settings</strong> from Flash's drop-down menu.</li><li class="listitem">If it isn't already selected, click on the panel's<strong> General</strong> tab.</li><li class="listitem">At the bottom of the panel is the<strong> Included files</strong> list. Click on the<strong> +</strong> symbol above the list and select<code class="literal"> chapter12\recipe6\music.mp3</code>. The file will now be bundled with your IPA when the FLA is published.</li><li class="listitem">Click on<strong> OK</strong> to close the AIR for iOS Settings panel.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec21"/>Playing the MP3 file</h3></div></div></div><p>With the MP3 now included within your FLA, let us turn our attention to the ActionScript required to stream it.<a id="id1033" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following import statements to the class:<div><pre class="programlisting">package {
import flash.display.MovieClip;
<strong>
import flash.events.MouseEvent;
import flash.media.Sound;
import flash.net.URLRequest;
</strong>
public class Main extends MovieClip {
public function Main() {
// constructor code
}
}
}
</pre></div></li><li class="listitem">Within the constructor, listen for<code class="literal"> playBtn</code> being pressed:<div><pre class="programlisting">public function Main() {
<strong>playBtn.addEventListener(MouseEvent.MOUSE_UP, playSound);
</strong>
}
</pre></div></li><li class="listitem">Now let us add the button's event handler. Within it, create a<code class="literal"> URLRequest</code> object for the local<code class="literal"> music.mp3</code> file:<div><pre class="programlisting">private function playSound(e:MouseEvent):void {
var url:URLRequest = new URLRequest("music.mp3");
}
</pre></div></li><li class="listitem">Finally, pass the request to a new<code class="literal"> Sound</code> object and call its<code class="literal"> play()</code> method:<div><pre class="programlisting">private function playSound(e:MouseEvent):void {
var url:URLRequest = new URLRequest("music.mp3");
<strong>var sound:Sound = new Sound(url);
sound.play();
</strong>
}
</pre></div></li><li class="listitem">Save both your class file and the FLA.</li><li class="listitem">Publish the app and test it on your device. Tap the button to initiate streaming of the<code class="literal"> .mp3</code> file. Repeatedly tap the button to initiate several instances of it.</li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec25"/>How it works...</h2></div></div></div><p>In addition to the playback of embedded audio, the<code class="literal"> flash.media.Sound</code> class can stream external sound files. The technique employed is identical to progressive downloading used when playing FLV or H.264 video and can be used for sound files that are either bundled with the app or stored remotely on the web.<a id="id1034" class="indexterm"/>
</p><p>While Flash supports both compressed and uncompressed embedded audio, only<code class="literal"> .mp3</code> files can be directly streamed using the<code class="literal"> Sound</code> class. It is, therefore, advisable to keep the number of external files you simultaneously stream to a minimum as decoding the audio can be computationally expensive.<a id="id1035" class="indexterm"/>
</p><p>Playing an<code class="literal"> .mp3</code> file using the<code class="literal"> Sound</code> class is straightforward. First a<code class="literal"> URLRequest</code> for the sound file needs to be created:</p><div><pre class="programlisting">var url:URLRequest = new URLRequest("music.mp3");
</pre></div><p>Then the request is passed to a new<code class="literal"> Sound</code> instance. The file starts to stream when the<code class="literal"> Sound</code> object's<code class="literal"> play()</code> method is called:</p><div><pre class="programlisting">var sound:Sound = new Sound(url);
sound.play();
</pre></div><p>Once<code class="literal"> play()</code> is called, the<code class="literal"> Sound</code> object can't be used with another<code class="literal"> .mp3</code> file. To stream a different file, create a new<code class="literal"> Sound</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec26"/>There's more...</h2></div></div></div><p>The following details are applicable to sound in general within Flash, but are of particular importance when dealing with MP3 files held either locally on the device's file system or on the web.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec22"/>Increasing the buffer time</h3></div></div></div><p>If the audio data is consumed faster than it is being loaded, then playback will be paused until the<code class="literal"> Sound</code> object's internal buffer has filled again.<a id="id1036" class="indexterm"/>
</p><p>To help prevent buffer under run, you can increase the number of milliseconds of data that has gathered before playback begins. Use a<code class="literal"> flash.media.SoundLoaderContext</code> object to specify the buffer time and pass it to the<code class="literal"> Sound</code> object's constructor:</p><div><pre class="programlisting">var context:SoundLoaderContext = new SoundLoaderContext(9000);
var sound:Sound = new Sound(request, context);
</pre></div><p>This example specifies that the buffer must contain 9000 milliseconds of audio data before playback is to continue. The default is 5000 milliseconds.</p><p>You can query the<code class="literal"> Sound</code> object's<code class="literal"> isBuffering</code> property to determine if the audio is currently paused while more data loads.<a id="id1037" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec23"/>Monitoring load progress</h3></div></div></div><p>When loading, a<code class="literal"> Sound</code> object dispatches a number of events that can help you monitor its progress:<a id="id1038" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Event.COMPLETE:</code> The sound's data has been completely loaded<a id="id1039" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ProgressEvent.PROGRESS:</code> Dispatched periodically as data is received<a id="id1040" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">IOErrorEvent.IO_ERROR:</code> The sound file could not be found<a id="id1041" class="indexterm"/></li></ul></div><p>In addition, the<code class="literal"> ProgressEvent</code> class provides the<code class="literal"> bytesLoaded</code> and<code class="literal"> bytesTotal</code> properties, which can be used to determine exactly how much of the file has loaded.<a id="id1042" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec24"/>Sound length</h3></div></div></div><p>The<code class="literal"> Sound</code> class provides a<code class="literal"> length</code> property, which can be used to determine the length of the current sound in milliseconds. When working with streaming sound, be careful as this property will return the length for only the data that has currently loaded. If you want to know the full sound file's duration, then wait for the<code class="literal"> Sound</code> object to dispatch<code class="literal"> Event.COMPLETE</code> first.<a id="id1043" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec25"/>Sound metadata</h3></div></div></div><p>MP3 audio can contain metadata in the form of ID3 tags, which contain information such as title, artist, album, and track number. If a file contains ID3 metadata, then<code class="literal"> Event.ID3</code> will be dispatched from its<code class="literal"> Sound</code> object. You can listen for this event, and then use the<code class="literal"> Sound</code> object's<code class="literal"> id3</code> property to read the tags.<a id="id1044" class="indexterm"/>
</p><p>The following code example shows the<code class="literal"> id3</code> property being enumerated in order to discover all tags embedded within the sound file:<a id="id1045" class="indexterm"/>
</p><div><pre class="programlisting">private function ID3InfoReceived(e:Event):void {
var id3:ID3Info = e.target.id3;
for(var prop:String in id3)
{
trace(prop + ": " + id3[prop]);
}
}
</pre></div><p>The<code class="literal"> ID3Info</code> class can be found in the<code class="literal"> flash.media</code> package.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec26"/>Working with raw PCM sound data</h3></div></div></div><p>Although the<code class="literal"> Sound</code> class primarily allows for the loading and playback of external MP3 files, AIR 3.0 provides a new method for working with uncompressed PCM sound data. The<code class="literal"> loadPCMFromByteArray()</code> method injects PCM 32-bit floating point sound data from a<code class="literal"> ByteArray</code> object into a<code class="literal"> Sound</code> object.<a id="id1046" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec27"/>Playing audio in the background</h3></div></div></div><p>From AIR 3.0 onwards, you can write multitasking applications that continue to play audio while in the background. This is achieved by inserting the<code class="literal"> UIBackgroundModes</code> key into your application descriptor file:<a id="id1047" class="indexterm"/>
</p><div><pre class="programlisting">&lt;iPhone&gt;
&lt;InfoAdditions&gt;
&lt;![CDATA[&lt;key&gt;UIDeviceFamily&lt;/key&gt;
&lt;array&gt;&lt;string&gt;1&lt;/string&gt;&lt;/array&gt;
<strong>&lt;key&gt;UIBackgroundModes&lt;/key&gt;
&lt;array&gt;&lt;string&gt;audio&lt;/string&gt;&lt;/array&gt;]]&gt;
</strong>
&lt;/InfoAdditions&gt;
</pre></div><p>Any audio that is currently playing when the app is closed will continue to do so.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec27"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Embedding audio</em></li><li class="listitem" style="list-style-type: disc"><em>Controlling audio playback</em></li><li class="listitem" style="list-style-type: disc"><em>Editing the application descriptor file, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec08"/>Controlling audio playback</h1></div></div></div><p>A<code class="literal"> SoundChannel</code> object is created for each sound that is played. Using the class' API, you can control the playback of a sound.<a id="id1048" class="indexterm"/>
</p><p>In this recipe, we will learn how to pause and resume a sound.<a id="id1049" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec28"/>Getting ready</h2></div></div></div><p>An<code class="literal"> .mp3</code> file and an FLA have been provided within the book's accompanying code bundle.</p><p>Open<code class="literal"> chapter12\recipe7\recipe.fla</code> into Flash Professional. Sitting in the center of the stage is a button named<code class="literal"> playBtn</code>. In the layer directly below is another button named<code class="literal"> pauseBtn</code>. During this recipe, we will write ActionScript to toggle between the two, indicating whether or not the MP3 is currently playing.</p><p>The MP3 we will be using can be found at<code class="literal"> chapter12\resources\music.mp3</code>. Before proceeding, copy it to the FLA's root folder at<code class="literal"> chapter12\recipe7\</code>.<a id="id1050" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec29"/>How to do it...</h2></div></div></div><p>This recipe is covered in two main steps. First we will bundle the MP3 with the app, then we will write the ActionScript required to control its playback.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec28"/>Bundling the MP3 file</h3></div></div></div><p>Let us start by bundling the<code class="literal"> .mp3</code> file with your app:<a id="id1051" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Open the AIR for iOS Settings panel by selecting<strong> File</strong> |<strong> AIR for iOS Settings</strong> from Flash's drop-down menu.</li><li class="listitem">If it isn't already selected, click the panel's<strong> General</strong> tab.</li><li class="listitem">At the bottom of the panel is the<strong> Included files</strong> list. Click on the<strong> +</strong> symbol above the list and select<code class="literal"> chapter12\recipe7\music.mp3</code>. The file will now be bundled with your IPA file when the FLA is published.</li><li class="listitem">Click on<strong> OK</strong> to close the AIR for iOS Settings panel.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec29"/>Controlling playback</h3></div></div></div><p>Now that the MP3 file has been included, let us focus on the ActionScript:<a id="id1052" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Import the classes required for this recipe:<div><pre class="programlisting">import flash.display.MovieClip;
<strong>
import flash.events.Event;
import flash.events.MouseEvent;
import flash.media.Sound;
import flash.media.SoundChannel;
import flash.net.URLRequest;
</strong>
</pre></div></li><li class="listitem">Declare the following member variables, which we will use to control the sound:<div><pre class="programlisting">private var sound:Sound;
private var channel:SoundChannel;
private var pausePosition:int;
</pre></div></li><li class="listitem">Within the constructor, add an event listener to each of the buttons and initially hide the Pause button from view:<a id="id1053" class="indexterm"/><div><pre class="programlisting">public function Main() {
<strong>
pausePosition = 0;
playBtn.addEventListener(MouseEvent.MOUSE_UP, playSound);
pauseBtn.addEventListener(MouseEvent.MOUSE_UP, pauseSound);
pauseBtn.visible = false;
</strong>
}
</pre></div></li><li class="listitem">Also notice that the pausePosition member variable has been initialized. Every time the MP3 is paused, we will update this variable with the time it was stopped at.</li><li class="listitem">When the Play button is pressed, playback of the MP3 should either commence for the first time, or continue from where it was previously paused. We will also need to listen for the MP3 playing to completion. In addition, the Pause button should be shown, allowing the user to stop the MP3 at some point.<p>To manage all this, add the following event handler:
</p><div><pre class="programlisting">private function playSound(e:MouseEvent):void {
if(sound == null)
{
var url:URLRequest = new URLRequest("music.mp3");
sound = new Sound(url);
}
channel = sound.play(pausePosition);
channel.addEventListener(Event.SOUND_COMPLETE, complete);
toggleBtn();
}
</pre></div></li><li class="listitem">When pausing playback of the MP3, the current point in time that was reached needs to be obtained and stored. Also, the Play button should be made available again, allowing the user to resume playback at their convenience. The following block of code handles this:<div><pre class="programlisting">private function pauseSound(e:MouseEvent):void {
pausePosition = channel.position;
channel.stop();
channel.removeEventListener(Event.SOUND_COMPLETE, complete);
toggleBtn();
}
</pre></div></li><li class="listitem">Add an event handler that is called when the MP3 plays to completion. This will reset the<code class="literal"> pausePosition</code> member variable and also make the Play button visible again, allowing the user to restart playback of the MP3:<div><pre class="programlisting">private function complete(e:Event):void {
channel.removeEventListener(Event.SOUND_COMPLETE, complete);
audio playbackcontrollingpausePosition = 0;
toggleBtn();
}
</pre></div></li><li class="listitem">Finally add the following support method, which is used to toggle between the Play and Pause button:<div><pre class="programlisting">private function toggleBtn():void {
playBtn.visible = !playBtn.visible;
pauseBtn.visible = !pauseBtn.visible;
}
</pre></div></li><li class="listitem">Now save both your class file and the FLA.</li><li class="listitem">Publish the app and test it on your device. Toggle playback by pressing the Play and Pause buttons.</li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec30"/>How it works...</h2></div></div></div><p>When the<code class="literal"> Sound.play()</code> method is called, a<code class="literal"> SoundChannel</code> object is created and returned. A<code class="literal"> SoundChannel</code> object is responsible for the playback of a single sound. Successive calls to<code class="literal"> Sound.play()</code> will return additional<code class="literal"> SoundChannel</code> objects, each playing their own copy of the<code class="literal"> Sound</code> object's data.<a id="id1055" class="indexterm"/>
</p><p>While a call to<code class="literal"> play()</code> will initially play the sound from start to finish, the<code class="literal"> SoundChannel</code> class' API can be used to perform other operations. In this recipe, we utilized the class to provide pause and resume functionality to the user.</p><p>It is not possible to literally pause a sound during playback; the<code class="literal"> SoundChannel</code> class only provides a method to stop playback. However, you can store the position in time that a sound was stopped at, and then replay the sound from that position later.<a id="id1056" class="indexterm"/>
</p><p>This was achieved by storing the<code class="literal"> position</code> property before stopping the sound. The<code class="literal"> position</code> property returns the sound's position in time, measured in milliseconds:<a id="id1057" class="indexterm"/>
</p><div><pre class="programlisting">pausePosition = channel.position;
channel.stop();
</pre></div><p>Playback is resumed by passing the stored position to<code class="literal"> Sound.play()</code>. Doing so plays the MP3 from the specified point in time and returns a new<code class="literal"> SoundChannel</code> object representing it:</p><div><pre class="programlisting">channel = sound.play(pausePosition);
</pre></div><p>Remember that the<code class="literal"> pausePosition</code> member variable was initialized to<code class="literal"> 0</code> within the constructor. This guaranteed that the first time the Play button was pressed, playback of the MP3 would take place from the beginning.</p><p>When a sound has finished playing, its<code class="literal"> SoundChannel</code> object will dispatch an<code class="literal"> Event.SOUND_COMPLETE</code> event.<a id="id1058" class="indexterm"/>
</p><p>While we used an external MP3 for this recipe, playback of sound embedded within the library is also controlled in an identical manner.</p><p>For more information, perform a search within Adobe Community Help for<code class="literal"> flash.media.Sound</code> and<code class="literal"> flash.media.SoundChannel</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec31"/>There's more...</h2></div></div></div><p>Here is some final information regarding the control of sound.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec30"/>Volume and panning</h3></div></div></div><p>The volume and stereo panning of a sound can also be controlled. To do this, create a<code class="literal"> flash.media.SoundTransform</code> object and either pass it to the<code class="literal"> SoundChannel</code> object's<code class="literal"> play()</code> method or the object's<code class="literal"> soundTransform</code> property.<a id="id1059" class="indexterm"/>
</p><p>The<code class="literal"> SoundTransform</code> object's constructor takes two parameters: the sound's volume and a value specifying its left-to-right panning. The volume ranges from<code class="literal"> 0</code> (silent) to<code class="literal"> 1</code> (full volume), while the panning ranges from<code class="literal"> -1</code> (fully left) to<code class="literal"> 1</code> (fully right).</p><p>Following is an example where the sound is played at full volume and panned hard left:</p><div><pre class="programlisting">soundTransform = new SoundTransform(1, -1);
soundChannel = sound.play(0, 1, soundTransform);
</pre></div><p>The sound's volume and panning can be adjusted at any point during playback. Simply make a change to your<code class="literal"> SoundTransform</code> object and assign it to the<code class="literal"> SoundChannel</code> object's<code class="literal"> soundTransform</code> property:</p><div><pre class="programlisting">soundTransform.pan = 0;
soundTransform.volume = 0.5;
soundChannel.soundTransform = soundTransfrom;
</pre></div><p>Note the use of the<code class="literal"> SoundTransform</code> object's<code class="literal"> pan</code> and<code class="literal"> volume</code> properties to make the required alterations.</p><p>When testing stereo panning, be aware that you will need to use headphones as the loudspeaker found on iOS devices only delivers monophonic sound.</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec31"/>Global sound</h3></div></div></div><p>As well as individual sounds, it is possible to control the volume and panning globally using the<code class="literal"> flash.media.SoundMixer</code> class. It has its own<code class="literal"> soundTransform</code> property, which when set affects all sound being played.<a id="id1060" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec32"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Playing embedded audio</em></li><li class="listitem" style="list-style-type: disc"><em>Streaming audio</em></li></ul></div></div></div></body></html>