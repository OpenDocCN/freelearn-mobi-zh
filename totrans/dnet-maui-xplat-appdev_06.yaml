- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigation Using .NET MAUI Shell and NavigationPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we’ve tackled **user interface** (**UI**) design,
    the MVVM pattern, and data binding. These elements allow us to devise UIs at the
    page level. For real-world applications, the ability to navigate between pages
    is crucial. Consequently, most application frameworks include their own distinct
    navigation mechanisms, .NET MAUI being no exception. In this chapter, we’ll introduce
    the navigation mechanisms in .NET MAUI. We’ll start by demonstrating how to accomplish
    the most basic navigation using NavigationPage, then we’ll delve into a more structured
    navigation mechanism – `Shell`.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, we’ll enhance the navigation capabilities of our application with
    `Shell`. In *Chapter 2*, *Building Our First .NET MAUI App*, we created our app
    using a `Shell` template. Despite this, our app has not yet reached the complexity
    required for multi-level navigation. With the integration of `Shell`, we’ll execute
    multi-level navigation. In order to facilitate this, it’s necessary to refine
    our model to support the navigation implementation. By the end of this chapter,
    our application will be able to support login, the selection of a page from the
    flyout menu, and switching to the item details or navigation to a child group.
    After delving deeper into the navigation design, we’ll gain an understanding of
    how navigation functions within .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Shell`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving design and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following branch on GitHub:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter05](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/3e70eadfc910ef454ba068dc2bceb6b8e3437678).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to implement the navigation logic of our password
    manager app. This will include the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging in and connecting to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring data in the password database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation design has a significant impact on user experience. In .NET MAUI,
    there is a built-in mechanism to help developers implement navigation efficiently.
    As we saw in the previous chapters, we can use `Shell` in our app. In this chapter,
    we will learn about `Shell` and enhance our app with features provided by `Shell`.
    Before we dive into `Shell`, we will explore the basic navigation mechanism in
    .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common ways to implement navigation are hierarchial and modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchical navigation** provides a navigation experience where the user
    can navigate through pages, both forward and backward. This pattern typically
    uses a toolbar or navigation bar at the top of the screen to display an Up or
    Back button in the top-left corner. It usually maintains a LIFO stack of pages
    to handle the navigation. **LIFO** stands for **last in**, **first out**, which
    means the last page to enter is the first one to pop out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modal navigation** is different from hierarchical navigation in terms of
    how users can respond to it. If a modal page is displayed on the screen, the users
    must complete or cancel the required task on the page before they can take other
    actions. The users cannot navigate away from modal pages before the required task
    is completed or canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: INavigation interface and NavigationPage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In .NET MAUI, both hierarchical navigation and model navigation are supported
    through the `INavigation` interface. The `INavigation` interface is supported
    by a special page called `NavigationPage`. `NavigationPage` is used to manage
    the navigation of a stack of other pages. The inheritance hierarchy of `NavigationPage`
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object** | **BindableObject** | **Element** | **NavigableElement** | **VisualElement**
    | **Page** | **NavigationPage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigableElement` defines a property called `Navigation` that implements the
    `INavigation` interface. This inherited property can be called from any `VisualElement`
    or `Page` for navigation purposes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `NavigationPage`, we must add the first page to a navigation stack as
    the root page of the application. We can see an example of this in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We build the navigation stack in the constructor of the `App` class, which is
    a derived class of `Application`. `TheFirstPage`, which is a derived class of
    `ContentPage`, is pushed onto the navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: Using the navigation stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to navigate to or from a page. When we want to browse a
    new page, we can add the new page to the navigation stack. This action is called
    a **push**. If we want to go back to the previous page, we can **pop** the previous
    page from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Push and pop ](img/B21554_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Push and pop'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 5.1*, we can use the `PushAsync()` or `PopAsync()` method
    in the `INavigation` interface to change to a new page or go back to the previous
    page, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are on **Page1**, we can change to **Page2** with the `GotoPage2()` event
    handler. In this function, we are pushing the new page, **Page2**, to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are on **Page2**, we can go back with the `BackToPage1()` event handler.
    In this function, we are popping the previous page from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we navigated to a new page using the hierarchical
    navigation method. To display a modal page, we can use the modal stack. For example,
    in our app, if we want to create a new item in `ItemsPage`, we can call `PushModalAsync()`
    in `ItemsViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the new item has been created, we can call `PopModalAsync()` in `NewItemViewModel`
    to dismiss the modal page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: On the `NewItemPage` model page, we cannot navigate to other pages before we
    complete or cancel the task. Both `PopAsync()` and `PopModalAsync()` return an
    awaitable task of the `Task<Page>` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find more information about NavigationPage, please refer to the following
    Microsoft document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/pages/navigationpage](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/pages/navigationpage)'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the navigation stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In hierarchical navigation, we can not only push or pop pages from the stack,
    but we can also manipulate the navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can insert a page into the stack using the `InsertPageBefore` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InsertPageBefore` method requires two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`page`: This is the page to be added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before`: This is the page before which the page is inserted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Figure 5.1*, when we are at **Page2**, we can insert another page, **Page1**,
    before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Removing a page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also remove a specific page from the stack using the `RemovePage()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 5.1*, given we have a reference of **Page2** when we are at **Page3**,
    we can remove **Page2** from the stack. After `PopAsync()` is called, we will
    be back at **Page1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, we have learned how to build a navigation stack using `NavigationPage`.
    Upon creating a navigation stack, we can utilize the `INavigation` interface to
    execute navigation actions. For a simple application, this method may suffice.
    However, for more complex applications, this approach can involve a significant
    amount of work. Fortunately, .NET MAUI offers a structured alternative called
    `Shell`. `Shell` is designed to improve the navigation structure of your applications
    by providing a unified, declarative syntax for defining the flyout menu, tab bars,
    and other navigational UIs. Utilizing `Shell` allows us to deliver an enhanced
    navigation experience to users with significantly less effort.
  prefs: []
  type: TYPE_NORMAL
- en: Using Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `INavigation` interface and `NavigationPage` offer basic navigation functionality.
    Relying solely on them would require us to create complex navigation mechanisms
    by ourselves. Fortunately, .NET MAUI provides built-in page templates to choose
    from, which can deliver various navigation experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the class diagram in *Figure 5.2*, there are built-in pages available
    for different use cases. All these pages – `TabbedPage`, `ContentPage`, `FlyoutPage`,
    `NavigationPage`, and `Shell` – are derived classes of `Page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Class diagram of the built-in pages in .NET MAUI ](img/B21554_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Class diagram of the built-in pages in .NET MAUI'
  prefs: []
  type: TYPE_NORMAL
- en: '`ContentPage`, `TabbedPage`, and `FlyoutPage` can be used to create various
    UIs per your requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ContentPage` is the most commonly used page type and can include any layout
    and view elements. It is suitable for single-page designs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TabbedPage` can be used to host multiple pages. Each child page can be selected
    by a series of tabs, located at either the top or bottom of the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlyoutPage` can display a list of items, similar to menu items in a desktop
    application. Users can navigate to individual pages through the items in the menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `Shell` is also a derived class of `Page`, it includes a common navigation
    user experience that simplifies developers’ tasks. `Shell` assists developers
    by reducing the complexity of application development and consolidating highly
    customizable, rich features in one location.
  prefs: []
  type: TYPE_NORMAL
- en: '`Shell` provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A single place to describe the visual hierarchy of an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A highly customizable common navigation user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A URI-based navigation scheme that is very similar to what we have in a web
    browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integrated search handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The top-level building blocks of `Shell` are flyouts and tabs. We can use flyouts
    and tabs to create the navigation structure of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Flyout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A flyout can be used as the top-level menu of a `Shell` app. In our app, we
    must use both flyouts and tabs to create the top-level navigation design. In this
    section, we will explore flyouts; in the next section, we will discuss using tabs
    in our app.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5.3*, we can see what the flyout looks like in our app. From the
    flyout menu, we can switch to the `AboutPage`, `ItemsPage`, or `LoginPage`. To
    access the flyout menu, we can either swipe from the left edge of the screen or
    click the flyout icon, which is the hamburger icon **(1)**. When we click the
    **Root Group** **(2)** in the flyout menu, we will see a list of password entries
    or groups.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Flyout'
  prefs: []
  type: TYPE_NORMAL
- en: The flyout menu consists of flyout items or menu items. In *Figure 5.3*, **About**
    and **Root****Group** are flyout items, while **Logout** is a menu item.
  prefs: []
  type: TYPE_NORMAL
- en: Flyout items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each flyout item is a `FlyoutItem` object that contains a `ShellContent` object.
    We can define flyout items like so in the `AppShell.xaml` file. We assign a `string`
    resource to the `Title` attribute **(1)** and an `ImageSource` to the `Icon` attribute
    **(2)**. These correspond to the properties of the `FlyoutItem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Shell` has implicit conversion operators that can be used to remove the `FlyoutItem`
    and `Tab` objects so that the preceding XAML code can also be simplified, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Menu items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some instances, using flyout items for navigation to a content page might
    not be necessary; instead, we may desire to perform an action. In such cases,
    menu items can be utilized. For our scenario, we have designated `Logout` as a
    menu item to execute an action rather than navigating to another content page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding XAML code, each menu item is a `MenuItem` object.
    The `MenuItem` class has a `Clicked` event and a `Command` property. When `MenuItem`
    is tapped, we can execute an action. In the preceding menu item, we assigned `OnMenuItemClicked`
    as the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at `AppShell.xaml`, as shown in *Listing 5.1*. In this
    file, we have defined two flyout items and one menu item. The flyout items allow
    us to select the `AboutPage` **(1)** and `ItemsPage` **(2)**, while the menu item
    enables us to log out **(3)**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5.1: `AppShell.xaml` in PassXYZ.Vault ([https://epa.ms/AppShell5-1](https://epa.ms/AppShell5-1))'
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `TabBar` **(4)** defined for `LoginPage` and `SignUpPage`. Let’s
    review tabs now.
  prefs: []
  type: TYPE_NORMAL
- en: Tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilizing tabs in `Shell` enables the creation of a navigation experience akin
    to that of `TabbedPage`. As depicted in *Figure 5.4*, both Android and iOS platforms
    feature two tabs on the bottom tab bar. However, the appearance of the tabs differs
    when implemented on the Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Tab bar and tabs on Android'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in *Figure 5.5*, on Windows, the tab bar is at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Tab bar and tabs on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to incorporate tabs into our app, we need to create a `TabBar` object.
    This `TabBar` object can comprise one or more `Tab` objects, with each `Tab` object
    representing an individual tab on the tab bar. Additionally, each `Tab` object
    can encompass one or more `ShellContent` objects. The subsequent XAML code demonstrates
    its similarity to the code used when defining a flyout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the approach we took in the flyout XAML code, we can simplify the
    previous code by eliminating the `Tab` tags. By utilizing the implicit conversion
    operators of `Shell`, we can remove the `Tab` objects. As demonstrated, it is
    possible to omit the `Tab` tags and directly define the `Title` and `Icon` attributes
    within the `ShellContent` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In a situation where we define both `TabBar` objects and `FlyoutItem` objects
    in `AppShell.xaml`, the `TabBar` objects will disable the flyout items. This is
    why, upon launching our app, we are presented with a tabbed screen displaying
    either the login or signup pages. Once the user successfully logs in, we can navigate
    them to the `RootPage`, which is the registered route illustrated in *Listing
    5.1*. In the following section, we will delve into the process of registering
    routes and navigating using these registered routes.
  prefs: []
  type: TYPE_NORMAL
- en: Shell navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `Shell`, navigating to pages is achieved through registered routes. Similar
    to a web browser, .NET MAUI uses URI-based navigation. The URI might look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the URI format allows us to specify the path within the application
    interface and potentially, include additional parameters. Beginning the URI with
    a double slash “//” signifies the root of navigation. Just like in file system
    navigation, we can also utilize “..” to execute backward navigation. This way,
    programmers can navigate the navigation stack in a way that’s both intuitive and
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods for registering routes. The first method involves registering
    routes within Shell’s visual hierarchy. The second method requires explicitly
    registering them by utilizing the `RegisterRoute` static method found in the `Routing`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Registering absolute routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have the option to register routes in Shell’s visual hierarchy, as demonstrated
    in *Listing 5.1*. Routes can be specified through the `Route` property of `FlyoutItem`,
    `TabBar`, `Tab`, or `ShellContent`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `AppShell.xaml` file, we registered the following routes.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route** | **Page** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `LoginPage` | `LoginPage` | This route displays a page for user login |'
  prefs: []
  type: TYPE_TB
- en: '| `SignUpPage` | `SignUpPage` | This route displays a page for user signup
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AboutPage` | `AboutPage` | This route displays a page about our app |'
  prefs: []
  type: TYPE_TB
- en: '| `RootPage` | `ItemsPage` | This route displays a page for navigating the
    password database |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Registered routes in the visual hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: To navigate to a route in Shell’s visual hierarchy, we can use an absolute route
    URI. The absolute URI starts with a double slash “//”, such as `//LoginPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering relative routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also possible to navigate to a page without predefining it in the visual
    hierarchy. For instance, the password entry detail page, `ItemDetailPage`, can
    be navigated to at any hierarchy level of the password groups. In our app, we
    can explicitly register the following routes using `RegisterRoute` in the code-behind
    file, `AppShell.xaml.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined the following routes.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route** | **Page** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ItemDetailPage` | `ItemDetailPage` | This is the route to display details
    about a password entry |'
  prefs: []
  type: TYPE_TB
- en: '| `NewItemPage` | `NewItemPage` | This is the route to add a new item (entry
    or group) |'
  prefs: []
  type: TYPE_TB
- en: '| `ItemsPage` | `ItemsPage` | This is the route to display a page for navigating
    the password database |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: Registered detail page routes'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to illustrate the usage of relative routes, we will proceed by adding
    a new item. When the need arises to add a new item, we can navigate to the `NewItemPage`
    utilizing a relative route, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, the `NewItemPage` route is searched, and if the route is identified,
    the page will be displayed and added to the navigation stack. This navigation
    stack is the same as the one we discussed while explaining basic navigation using
    the `INavigation` interface. When defining a relative route and navigating to
    it, we pass a string as the route’s name. To prevent errors, we can use the class
    name as the route name by employing the **nameof** expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have entered the details for the new item in the `NewItemPage`, we
    can click either the **Save** or **Cancel** button. Within the event handler for
    the **Save** or **Cancel** button, we can navigate back to the previous page using
    the code provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can also navigate back using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Just like in file system navigation, here, the “..” represents the parent page
    in the navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: As evident from the code mentioned earlier, there are two methods to navigate
    back. The first option involves using the `PopModalAsync` method of the `INavigation`
    interface. Due to `Shell` being a derived class of `Page`, it implements the `INavigation`
    interface through the inherited `Navigation` property. We can call the `PopModalAsync`
    modal navigation method to go back, with `NewItemPage` functioning as a modal
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method involves utilizing the `GoToAsync` function to navigate back.
    As the `NewItemPage` serves as a modal page, you might be curious about how to
    distinguish between a modal page and a non-modal page when invoking `GoToAsync`.
    In `Shell` navigation, this distinction is determined by the page presentation
    mode. The content page of `NewItemPage` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As observed, the `Shell.PresentationMode` **(1)** property is defined within
    the content page. Based on our preference for implementing animation, we can assign
    different values to this property. For a standard content page, we can set it
    to either `NotAnimated` or `Animated`. In the case of a modal page, the options
    are `Modal`, `ModalAnimated`, or `ModalNotAnimated`. If left unchanged, the default
    value is set to `Animated`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To navigate back, the `GoToAsync` method is utilized along with the route assigned
    to “..”. This approach is reminiscent of file system navigation or browser URL
    navigation. The relative route, “..”, signifies navigating back to the parent
    route. It can also be combined with a route to access a page at the parent level,
    as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In *Table 5.1* and *Table 5.2*, you will notice that `ItemsPage` is registered
    as both the absolute route `RootPage` and the relative route `ItemsPage`. It is
    important to note that `ItemsPage` may encompass password groups at various levels.
    When positioned at the top level, it serves as an absolute route, whereas at all
    subsequent navigation hierarchy levels, it functions as a relative route.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to elaborate on the reasoning behind registering `ItemsPage` with both
    absolute and relative routes, let’s examine the navigation hierarchy of our app,
    as depicted in *Figure 5.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Navigation hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: In our app, once the user successfully logs in, the main page showcases a list
    of entries and groups situated at the top tier of the password database, referred
    to as Root Group. This resembles the navigation structure of a file system that
    displays the top-level files and folders at its root.
  prefs: []
  type: TYPE_NORMAL
- en: The first instance of `ItemsPage` employs the `RootPage` route, which can be
    accessed via the flyout item. Assume there are sub-groups named **Group1** and
    **Group2** within the Root Group, as depicted in *Figure 5.6*. We can navigate
    to these sub-groups, which also represent instances of `ItemsPage`. Since these
    instances utilize relative routes and rely on navigation stacks that are pushed
    on demand, they cannot be pre-defined. These navigation stacks can extend as deep
    as the actual data present in the password database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two distinct routes of `ItemsPage` are defined in `AppShell.xaml` and `AppShell.xaml.cs`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RootPage` route (absolute route):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemsPage` route (relative route):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you might be curious about how to navigate from the Root Group
    to **Group1** or **Group2**. If the `ItemsPage` is capable of displaying the content
    of either **Group1** or **Group2**, how can we inform `ItemsPage` which group
    needs to be displayed?
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Shell` navigation, data can be transmitted to a content page using query
    parameters. The syntax is akin to the parameters passed in a URL within a web
    browser. For instance, the following URL can be used to search for **.net** on
    Google: [https://www.google.com.hk/search?q=.net.](https://www.google.com.hk/search?q=.net.)'
  prefs: []
  type: TYPE_NORMAL
- en: The desired outcome is achieved by appending a question mark (`?`) after a route,
    along with a pair of query parameter IDs and their respective values. In the preceding
    example, the key is `q` and the value is `.net`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon selecting an item in the list of Root Groups, it can be either an entry
    or a group. The click event activates the `OnItemSelection` method in `ItemsViewModel`,
    demonstrated in *Listing 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5.2: `ItemsViewModel.cs` ([https://epa.ms/ItemsViewModel5-2](https://epa.ms/ItemsViewModel5-2))'
  prefs: []
  type: TYPE_NORMAL
- en: Based on the item type, we might navigate to either the `ItemsPage` **(3)**
    or the `ItemDetailPage` **(4)**. In both instances, we transfer the `Id` of the
    item to the `ItemId` query parameter, which is defined in both the `ItemsViewModel`
    and the `ItemDetailViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of *Listing 5.2*, **(1)** `ItemId` is established as the `QueryPropertyAttribute`
    within the `ItemsViewModel`. The first argument of `QueryPropertyAttribute` corresponds
    to the name of the property designated to receive the data, which in this instance
    is `ItemId` **(2)**.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument corresponds to the `id` parameter. Upon selecting a group
    from the list, the view model’s `OnItemSelected` method **(3)** is triggered and
    the item `Id` of the chosen group is passed as the value for the `ItemId` query
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When the `ItemsPage` is loaded along with the `ItemId` query parameter, the
    `ItemId` property **(2)** gets set. In the setter of the `ItemId` property, we
    examine whether the query parameter value is empty. If it is empty, it might be
    our initial navigation to the `RootPage` route without any query parameter. In
    this case, we just set `SelectedItem` to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: If it is not empty, we will find the item and set it to `SelectedItem`.
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** If we select an entry from the list, we can navigate to `ItemDetailPage`
    with the item `Id` as the value of the query parameter. To accommodate this query
    parameter, we can modify the ItemId property of the `ItemDetailViewModel` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ItemDetailViewModel` class, we implement the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ItemId` **(1)** serves as the property that accepts the query parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When setting the `ItemId`, the `LoadItemId` method **(2)** is called to load
    the item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within `LoadItemId`, the data service method `GetItem` **(3)** is called to
    obtain the item using its corresponding `Id`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the item is an instance of `PwEntry` **(4)**, which can be cast
    accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PassXYZLib extension method, `GetFields` **(5)**, is utilized to update
    the list of fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous two sections, we acquired knowledge of basic navigation and
    `Shell` navigation and enhanced our navigation design using `Shell`. At this point,
    it is essential to revisit the MVVM pattern and further refine our data model
    to improve the quality of our password manager app.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 4*, *Exploring MVVM and Data Binding*, we analyzed various use cases
    and developed a few. In this section, utilizing the knowledge we have acquired,
    we will augment the existing use cases and introduce new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be working on the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case 1**: As a password manager user, I want to log in to the password
    manager app so that I can access my password data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this use case, we have not yet fully implemented user login; we plan to complete
    this in the subsequent chapter. For now, we will implement a pseudo-logic that
    encompasses all aspects except the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, in *Chapter 4*, *Exploring MVVM and Data Binding*, we covered a
    use case that supports one level of navigation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case 3**: As a password manager user, I want to see a list of groups
    and entries so that I can explore my password data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To accommodate multiple levels of navigation, we will implement the following
    use cases in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case 6**: As a password manager user, when I click on a group in the
    current list, I want to see the groups and entries belonging to that group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 7**: As a password manager user, when navigating through my password
    data, I want to be able to go back to the previous group or parent group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous implementation (use case 1), after login, we implemented the
    navigation to the root page using an absolute route. However, the implementation
    of the `LoginService` is not done yet. We need to implement it in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the root page (use case 3), at present, we can only browse the
    root-level entries and groups. We are not yet able to enter a child group from
    the root level. To address this limitation, we are introducing use cases 6 and
    7 in this chapter. In use cases 6 and 7, we aim to navigate forward and backward
    using relative routes.
  prefs: []
  type: TYPE_NORMAL
- en: With the MVVM pattern, we access our model through services, which are typically
    abstracted as interfaces, separate from the actual implementation. The `IDataStore`
    interface is an example of this. In order to support use case 6 and enhance use
    case 1, we need to develop a new interface called `IUserService` for user login
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the improved design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the services and the enhanced model, let’s review the enhanced
    design in *Figure 5.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Model and service in MVVM ](img/B21554_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Model and service in MVVM'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.7* presents a class diagram that illustrates the majority of our
    design. To comprehend the design of our app, we can examine this class diagram
    in conjunction with the table provided. For the sake of simplicity, I have excluded
    some elements. For instance, you can add the `NewItemPage` or `SignUpPage` to
    *Figure 5.7* and *Table 5.3* by yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Model** | **View** | **View Model** |'
  prefs: []
  type: TYPE_TB
- en: '| **Data Model** | **Service** |'
  prefs: []
  type: TYPE_TB
- en: '| `User` | `IUserService` | `LoginPage` | `LoginViewModel` |'
  prefs: []
  type: TYPE_TB
- en: '| `Item` | `IDataStore` | `ItemsPage` | `ItemsViewModel` |'
  prefs: []
  type: TYPE_TB
- en: '| `Field` | `ItemDetailPage` | `ItemDetailViewModel` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.3: Classes and interfaces in the MVVM pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Registering absolute routes and relative routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, when introducing pages and routes, you may notice that the
    names of pages and routes could be the same. To distinguish between them, I’ll
    use bold font to identify a page and italic font to identify a route.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, both absolute and relative routes are registered within
    the `AppShell` class. The absolute routes, *LoginPage*, *SignUpPage*, *RootPage*,
    and *AboutPage*, are created as parts of the `Shell`. Conversely, the relative
    routes – *ItemsPage*, *ItemDetailPage*, and *NewItemPage* – are defined within
    the constructor of the `AppShell`.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate multi-level navigation, the page **ItemsPage** is registered as
    both the absolute route *RootPage* and the relative route *ItemsPage*.
  prefs: []
  type: TYPE_NORMAL
- en: Upon application loading, the route *LoginPage* is utilized. Post-login, the
    app navigates to *RootPage*. If a user selects a child group, the relative route
    *ItemsPage* is loaded, thereby permitting navigation deeper into multi-levels.
    When a user selects an entry, the relative route *ItemsDetailPage* is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Model and services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To save application data, we typically store it in a database, which could be
    either a relational database or a NoSQL database. In our case, our password database
    is not a relational database. Nevertheless, while working on our design, we can
    employ the analogous logic of relational databases when formulating our business
    logic. Our model is represented by three distinct classes – `User`, `Item`, and
    `Field`.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of our design, `Item` and `Field` represent a password entry
    and the content within that entry, respectively. An entry can be visualized as
    a row in a table, with a field acting as a cell. To model a password entry, we
    employ the `PwEntry` from KeePassLib. In this instance, a group refers to a collection
    of entries, and `PwGroup` is utilized to model this group. A group can be compared
    to a table within a database, and fields that share the same key values across
    a group are akin to a column. In order to develop the interface for our data services,
    we can adopt a similar approach for processing data within our database.
  prefs: []
  type: TYPE_NORMAL
- en: How can we manage data within a database? You might be familiar with the term
    CRUD operations. In our situation, we can employ the augmented `create`, `read`,
    `update`, `delete`, and `list` (**CRUDL**) operations for defining the interface
    of our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To process password entries and groups, we can use the following `IDataStore`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `IDataStore` interface, we define the following CRUDL operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create**: We use `AddItemAsync` to add an entry or a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read**: We use `GetItem` or `GetItemAsync` to read an entry or a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update**: We use `UpdateItemAsync` to update an entry or a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete**: We use `DeleteItemAsync` to delete an entry or a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: We use `GetItemsAsync` to get a list of entries and groups in the
    current group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To manage users, we can utilize the following `IUserService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define a set of CRUDL operations to handle users as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create**: We can create a new user using `AddUserAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read**: We can get the user information using `GetUser`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete**: We can delete a user using `DeleteUserAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: We can get a list of users using `GetUsersList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoginAsync** and **Logout**: We can log in or log out using an instance of
    `User`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor of `ItemsViewModel` class, we initialize the `IDataStore`
    and `ILogger` services through a dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of IUserService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our application, the `UserService` class serves as the implementation of
    the `IUserService` interface. The code for this can be found in *Listing 5.3*.
    For the sake of simplifying the testing process, we have not implemented all features
    in this chapter, as we continue to utilize a mock data store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5.3: `UserService.cs` ([https://epa.ms/UserService5-3](https://epa.ms/UserService5-3))'
  prefs: []
  type: TYPE_NORMAL
- en: In the `UserService` constructor **(1)**, an `IDataStore` instance is initialized
    via dependency injection. The available functions can be classified into two types.
    Functions such as `GetUser`, `DeleteUserAsync`, and `GetUserList` can be implemented
    using methods from the `User` class. Meanwhile, methods like `AddUserAsync`, `LoginAsync`,
    and `Logout` are implemented using the `IDataStore` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the login process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the process of user management, we may need to add new users or remove outdated
    users from the system. For our app, it only allows one user to log in at a time.
    To support this feature, we can implement a class using the singleton pattern.
    Alternatively, we can implement a class and utilize dependency injection to have
    a similar effect on the singleton pattern. For instance, we can create a `LoginService`
    class that inherits from the `User` class, as demonstrated in *Listing 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5.4: `LoginService.cs` ([https://epa.ms/LoginService5-4](https://epa.ms/LoginService5-4))'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The LoginService class is derived from the PxUser subclass, which in
    turn inherits from the User class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** Within LoginService, we initialize the IUserService interface through
    dependency injection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** To execute user login, we can invoke the IUserService method by passing
    a LoginService instance as the argument. **(4)** The same process is applicable
    in the case of user signup.'
  prefs: []
  type: TYPE_NORMAL
- en: Login view model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After introducing the model and service layer, we can now focus on the view
    model and view for the login and signup functionality. Let’s start by examining
    the implementation of the view model, as presented in *Listing 5.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5.5: `LoginViewModel.cs` ([https://epa.ms/LoginViewModel5-5](https://epa.ms/LoginViewModel5-5))'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** In the `LoginViewModel`, we inject an instance of `LoginService` through
    dependency injection and save it in the private member variable `_currentUser`.
    This variable is utilized to track all login and signup activities.'
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, we created the `LoginCommand` **(2)** and `SignUpCommand` **(3)**
    using the `RelayCommand` attribute from the .NET Community Toolkit. Within these
    functions, we call the `LoginAsync` and `SignUpAsync` methods from the `LoginService`.
  prefs: []
  type: TYPE_NORMAL
- en: To validate both commands, we created the `ValidateLogin` and `ValidateSignUp`
    methods to perform the necessary checks. In `ValidateLogin`, we ensure that both
    the username and password are not empty before allowing the login process to proceed.
    In `ValidateSignUp`, we not only verify the username and password but also confirm
    that the password and confirmation password fields match. **(4)** To trigger the
    validation methods, the `NotifyCanExecuteChangedFor` attribute is added to decorate
    the properties. This is part of the MVVM toolkit implementation, which we discussed
    in *Chapter 4**, Exploring MVVM and Data Binding*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have upgraded our model and services to optimize the login process.
    Reviewing the class diagram in *Figure 5.7*, we have modified the source code
    at the view, view model, and service layers to improve our application. The actual
    model is contained within two libraries, `KPCLib` and `PassXYZLib`. We have exposed
    the capabilities of these libraries through the `IDataStore` and `IUserService`
    interfaces. By creating the implementing classes for these two interfaces, we
    have further enhanced our model. In the following section, we will focus on the
    view layer and examine the upgraded UI.
  prefs: []
  type: TYPE_NORMAL
- en: Login UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now enhance the login and signup UI. Currently, the login page only contains
    a single button. Let’s add a username field and a password field to `LoginPage.xaml`,
    as illustrated in *Figure 5.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: LoginPage'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this new UI design, we made the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a 4x3 grid layout within a frame. **(1)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first two rows, we added two `Entry` controls to hold the username **(2)**
    and password **(3)**. We established a data binding between the `Text` fields
    of the `Entry` controls and the properties of the `LoginViewModel`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third row, we incorporated an `ActivityIndicator` control **(4)** to
    display the login status, which is bound to the `IsBusy` property of the view
    model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the final row, we defined a `Button` control **(5)** for the login action.
    The `Button` control has a `Command` property that implements the `ICommand` interface.
    We used data binding to link this `Command` property to the method in the view
    model responsible for performing the login action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on fundamental navigation principles and the `Shell`
    framework. We chose `Shell` as the navigation foundation for our app design, examined
    its capabilities, and discussed how to integrate it into our app’s UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we completed most of the UI design, we enhanced our model by making changes
    to two service interfaces: `IDataStore` and `IUserService`. We improved the login
    process after making changes in the view, view model, and service layers. In the
    service layer, we are still using the `MockDataStore` class. However, we haven’t
    finalized the implementation in the `IDataStore` service to perform the actual
    login activities yet. We will leave this to the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completing the majority of the UI design, we proceeded to refine our model
    by modifying two service interfaces: `IDataStore` and `IUserService`. By making
    alterations in the view, view model, and service layers, we enhanced the login
    process. In the service layer, we continued to utilize the `MockDataStore` class.
    However, the implementation of the `IDataStore` service for performing actual
    login activities has yet to be finalized, and we will address this in the subsequent
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into dependency injection in .NET MAUI, which
    is done quite differently compared to Xamarin.Forms. We will instruct you on how
    to register our services using dependency injection and how to initialize our
    service via constructor injection or property injection. Furthermore, we will
    develop the actual service to supersede the `MockDataStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
