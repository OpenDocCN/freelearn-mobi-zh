- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Navigation Using .NET MAUI Shell and NavigationPage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET MAUI Shell和NavigationPage进行导航
- en: In the preceding chapters, we’ve tackled **user interface** (**UI**) design,
    the MVVM pattern, and data binding. These elements allow us to devise UIs at the
    page level. For real-world applications, the ability to navigate between pages
    is crucial. Consequently, most application frameworks include their own distinct
    navigation mechanisms, .NET MAUI being no exception. In this chapter, we’ll introduce
    the navigation mechanisms in .NET MAUI. We’ll start by demonstrating how to accomplish
    the most basic navigation using NavigationPage, then we’ll delve into a more structured
    navigation mechanism – `Shell`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们处理了**用户界面**（**UI**）设计、MVVM模式和数据绑定。这些元素使我们能够在页面级别设计UI。对于现实世界的应用，页面间的导航能力至关重要。因此，大多数应用框架都包括它们自己的独特导航机制，.NET
    MAUI也不例外。在本章中，我们将介绍.NET MAUI中的导航机制。我们将首先演示如何使用NavigationPage完成最基本的导航，然后我们将深入探讨一个更结构化的导航机制——`Shell`。
- en: Subsequently, we’ll enhance the navigation capabilities of our application with
    `Shell`. In *Chapter 2*, *Building Our First .NET MAUI App*, we created our app
    using a `Shell` template. Despite this, our app has not yet reached the complexity
    required for multi-level navigation. With the integration of `Shell`, we’ll execute
    multi-level navigation. In order to facilitate this, it’s necessary to refine
    our model to support the navigation implementation. By the end of this chapter,
    our application will be able to support login, the selection of a page from the
    flyout menu, and switching to the item details or navigation to a child group.
    After delving deeper into the navigation design, we’ll gain an understanding of
    how navigation functions within .NET MAUI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们将使用`Shell`增强我们应用的导航功能。在*第2章*，*构建我们的第一个.NET MAUI应用*中，我们使用`Shell`模板创建了我们的应用。尽管如此，我们的应用尚未达到多级导航所需的复杂性。通过集成`Shell`，我们将执行多级导航。为了实现这一点，有必要完善我们的模型以支持导航实现。到本章结束时，我们的应用将能够支持登录、从飞出菜单中选择页面以及切换到项目详情或导航到子组。在深入导航设计之后，我们将了解导航在.NET
    MAUI中的工作方式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing navigation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现导航
- en: Using `Shell`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Shell`
- en: Improving design and navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进设计和导航
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章的源代码，您需要在您的PC或Mac上安装Visual Studio 2022。有关详细信息，请参阅*第1章*，*使用.NET MAUI入门*中的*开发环境设置*部分。
- en: 'The source code for this chapter is available in the following branch on GitHub:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter05](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/3e70eadfc910ef454ba068dc2bceb6b8e3437678).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub分支中找到：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter05](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/3e70eadfc910ef454ba068dc2bceb6b8e3437678)。
- en: 'To check out the source code of this chapter, we can use the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查本章的源代码，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书源代码的信息，请参阅*第2章*，*构建我们的第一个.NET MAUI应用*中的*管理本书的源代码*部分。
- en: Implementing navigation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现导航
- en: 'In this chapter, we are going to implement the navigation logic of our password
    manager app. This will include the following functionalities:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现密码管理器应用的导航逻辑。这包括以下功能：
- en: Logging in and connecting to the database
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录并连接到数据库
- en: Exploring data in the password database
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在密码数据库中探索数据
- en: Navigation design has a significant impact on user experience. In .NET MAUI,
    there is a built-in mechanism to help developers implement navigation efficiently.
    As we saw in the previous chapters, we can use `Shell` in our app. In this chapter,
    we will learn about `Shell` and enhance our app with features provided by `Shell`.
    Before we dive into `Shell`, we will explore the basic navigation mechanism in
    .NET MAUI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 导航设计对用户体验有重大影响。在 .NET MAUI 中，有一个内置机制可以帮助开发者高效地实现导航。正如我们在前面的章节中看到的，我们可以在我们的应用程序中使用
    `Shell`。在本章中，我们将学习 `Shell` 并使用 `Shell` 提供的功能增强我们的应用程序。在我们深入 `Shell` 之前，我们将探索 .NET
    MAUI 中的基本导航机制。
- en: 'The most common ways to implement navigation are hierarchial and modal:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实现导航最常见的方式是层次结构和模态：
- en: '**Hierarchical navigation** provides a navigation experience where the user
    can navigate through pages, both forward and backward. This pattern typically
    uses a toolbar or navigation bar at the top of the screen to display an Up or
    Back button in the top-left corner. It usually maintains a LIFO stack of pages
    to handle the navigation. **LIFO** stands for **last in**, **first out**, which
    means the last page to enter is the first one to pop out.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构导航**提供了一种用户可以向前和向后导航页面的导航体验。这种模式通常在屏幕顶部使用工具栏或导航栏来显示左上角的上一个或返回按钮。它通常维护一个后进先出（LIFO）的页面堆栈来处理导航。**LIFO**
    代表 **last in, first out**，意味着最后进入的页面是第一个弹出的页面。'
- en: '**Modal navigation** is different from hierarchical navigation in terms of
    how users can respond to it. If a modal page is displayed on the screen, the users
    must complete or cancel the required task on the page before they can take other
    actions. The users cannot navigate away from modal pages before the required task
    is completed or canceled.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模态导航**在用户如何响应它方面与层次结构导航不同。如果屏幕上显示模态页面，用户必须在完成或取消所需任务之前才能执行其他操作。在完成或取消所需任务之前，用户不能从模态页面导航离开。'
- en: INavigation interface and NavigationPage
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INavigation 接口和 NavigationPage
- en: 'In .NET MAUI, both hierarchical navigation and model navigation are supported
    through the `INavigation` interface. The `INavigation` interface is supported
    by a special page called `NavigationPage`. `NavigationPage` is used to manage
    the navigation of a stack of other pages. The inheritance hierarchy of `NavigationPage`
    looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，通过 `INavigation` 接口支持层次结构和模型导航。`INavigation` 接口由一个称为 `NavigationPage`
    的特殊页面支持。`NavigationPage` 用于管理其他页面的导航堆栈。`NavigationPage` 的继承层次结构如下所示：
- en: '**Object** | **BindableObject** | **Element** | **NavigableElement** | **VisualElement**
    | **Page** | **NavigationPage**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象** | **可绑定对象** | **元素** | **可导航元素** | **可视元素** | **页面** | **NavigationPage**'
- en: '`NavigableElement` defines a property called `Navigation` that implements the
    `INavigation` interface. This inherited property can be called from any `VisualElement`
    or `Page` for navigation purposes, as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigableElement` 定义了一个名为 `Navigation` 的属性，该属性实现了 `INavigation` 接口。这个继承属性可以从任何
    `VisualElement` 或 `Page` 用于导航目的，如下所示：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use `NavigationPage`, we must add the first page to a navigation stack as
    the root page of the application. We can see an example of this in the following
    code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `NavigationPage`，我们必须将第一个页面添加到导航堆栈中，作为应用程序的根页面。我们可以在下面的代码片段中看到一个例子：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We build the navigation stack in the constructor of the `App` class, which is
    a derived class of `Application`. `TheFirstPage`, which is a derived class of
    `ContentPage`, is pushed onto the navigation stack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `App` 类的构造函数中构建导航堆栈，`App` 类是 `Application` 的派生类。`TheFirstPage` 是 `ContentPage`
    的派生类，被推入导航堆栈。
- en: Using the navigation stack
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导航堆栈
- en: 'There are two ways to navigate to or from a page. When we want to browse a
    new page, we can add the new page to the navigation stack. This action is called
    a **push**. If we want to go back to the previous page, we can **pop** the previous
    page from the stack:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以导航到或从页面。当我们想要浏览新页面时，我们可以将新页面添加到导航堆栈中。这个动作称为 **推**。如果我们想回到上一个页面，我们可以从堆栈中
    **弹** 出上一个页面：
- en: '![Figure 5.1: Push and pop ](img/B21554_05_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：推和弹](img/B21554_05_01.png)'
- en: 'Figure 5.1: Push and pop'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：推和弹
- en: As shown in *Figure 5.1*, we can use the `PushAsync()` or `PopAsync()` method
    in the `INavigation` interface to change to a new page or go back to the previous
    page, respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.1* 所示，我们可以使用 `INavigation` 接口中的 `PushAsync()` 或 `PopAsync()` 方法分别切换到新页面或返回到上一个页面。
- en: 'If we are on **Page1**, we can change to **Page2** with the `GotoPage2()` event
    handler. In this function, we are pushing the new page, **Page2**, to the stack:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于 **Page1** 页面，我们可以通过 `GotoPage2()` 事件处理器切换到 **Page2**。在这个函数中，我们将新页面 **Page2**
    推送到堆栈：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we are on **Page2**, we can go back with the `BackToPage1()` event handler.
    In this function, we are popping the previous page from the stack:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处于 **Page2** 页面，我们可以通过 `BackToPage1()` 事件处理器返回。在这个函数中，我们从堆栈中弹出前一页：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding example, we navigated to a new page using the hierarchical
    navigation method. To display a modal page, we can use the modal stack. For example,
    in our app, if we want to create a new item in `ItemsPage`, we can call `PushModalAsync()`
    in `ItemsViewModel`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用分层导航方法导航到一个新页面。要显示模态页面，我们可以使用模态堆栈。例如，在我们的应用程序中，如果我们想在 `ItemsPage`
    中创建一个新项目，我们可以在 `ItemsViewModel` 中调用 `PushModalAsync()`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the new item has been created, we can call `PopModalAsync()` in `NewItemViewModel`
    to dismiss the modal page:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目后，我们可以在 `NewItemViewModel` 中调用 `PopModalAsync()` 来关闭模态页面：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On the `NewItemPage` model page, we cannot navigate to other pages before we
    complete or cancel the task. Both `PopAsync()` and `PopModalAsync()` return an
    awaitable task of the `Task<Page>` type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NewItemPage` 模型页面中，在完成任务或取消任务之前，我们无法导航到其他页面。`PopAsync()` 和 `PopModalAsync()`
    都返回一个 `Task<Page>` 类型的可等待任务。
- en: 'To find more information about NavigationPage, please refer to the following
    Microsoft document:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关 `NavigationPage` 的更多信息，请参阅以下 Microsoft 文档：
- en: '[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/pages/navigationpage](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/pages/navigationpage)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/pages/navigationpage](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/pages/navigationpage)'
- en: Manipulating the navigation stack
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作导航堆栈
- en: In hierarchical navigation, we can not only push or pop pages from the stack,
    but we can also manipulate the navigation stack.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在分层导航中，我们不仅可以从堆栈中推送或弹出页面，还可以操作导航堆栈。
- en: Inserting a page
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入页面
- en: 'We can insert a page into the stack using the `InsertPageBefore` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `InsertPageBefore` 方法将页面插入到堆栈中：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `InsertPageBefore` method requires two parameters:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertPageBefore` 方法需要两个参数：'
- en: '`page`: This is the page to be added.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`: 这是将要添加的页面。'
- en: '`before`: This is the page before which the page is inserted.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before`: 这是插入页面之前的那一页。'
- en: 'In *Figure 5.1*, when we are at **Page2**, we can insert another page, **Page1**,
    before it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.1* 中，当我们处于 **Page2** 页面时，我们可以在它之前插入另一个页面，**Page1**：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Removing a page
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除页面
- en: 'We can also remove a specific page from the stack using the `RemovePage()`
    method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `RemovePage()` 方法从堆栈中移除特定的页面：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In *Figure 5.1*, given we have a reference of **Page2** when we are at **Page3**,
    we can remove **Page2** from the stack. After `PopAsync()` is called, we will
    be back at **Page1**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.1* 中，假设我们在 **Page3** 页面时有一个 **Page2** 的引用，我们可以从堆栈中移除 **Page2**。调用 `PopAsync()`
    后，我们将返回到 **Page1**：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In conclusion, we have learned how to build a navigation stack using `NavigationPage`.
    Upon creating a navigation stack, we can utilize the `INavigation` interface to
    execute navigation actions. For a simple application, this method may suffice.
    However, for more complex applications, this approach can involve a significant
    amount of work. Fortunately, .NET MAUI offers a structured alternative called
    `Shell`. `Shell` is designed to improve the navigation structure of your applications
    by providing a unified, declarative syntax for defining the flyout menu, tab bars,
    and other navigational UIs. Utilizing `Shell` allows us to deliver an enhanced
    navigation experience to users with significantly less effort.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们学习了如何使用 `NavigationPage` 构建导航堆栈。在创建导航堆栈后，我们可以利用 `INavigation` 接口来执行导航操作。对于简单的应用程序，这种方法可能足够。然而，对于更复杂的应用程序，这种方法可能需要大量的工作。幸运的是，.NET
    MAUI 提供了一个结构化的替代方案，称为 `Shell`。`Shell` 通过提供用于定义飞出菜单、标签栏和其他导航 UI 的统一、声明性语法来设计，以改善应用程序的导航结构。利用
    `Shell` 可以让我们以更少的努力为用户提供增强的导航体验。
- en: Using Shell
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shell
- en: The `INavigation` interface and `NavigationPage` offer basic navigation functionality.
    Relying solely on them would require us to create complex navigation mechanisms
    by ourselves. Fortunately, .NET MAUI provides built-in page templates to choose
    from, which can deliver various navigation experiences.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`INavigation` 接口和 `NavigationPage` 提供基本的导航功能。仅依赖它们将需要我们自行创建复杂的导航机制。幸运的是，.NET
    MAUI 提供了内置的页面模板供选择，可以提供各种导航体验。'
- en: 'As shown in the class diagram in *Figure 5.2*, there are built-in pages available
    for different use cases. All these pages – `TabbedPage`, `ContentPage`, `FlyoutPage`,
    `NavigationPage`, and `Shell` – are derived classes of `Page`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.2* 中的类图所示，根据不同的用例提供了内置的页面。所有这些页面 – `TabbedPage`、`ContentPage`、`FlyoutPage`、`NavigationPage`
    和 `Shell` – 都是 `Page` 的派生类：
- en: '![Figure 5.2: Class diagram of the built-in pages in .NET MAUI ](img/B21554_05_02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：.NET MAUI 内置页面的类图](img/B21554_05_02.png)'
- en: 'Figure 5.2: Class diagram of the built-in pages in .NET MAUI'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：.NET MAUI 内置页面的类图
- en: '`ContentPage`, `TabbedPage`, and `FlyoutPage` can be used to create various
    UIs per your requirements:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage`、`TabbedPage` 和 `FlyoutPage` 可以根据您的需求创建各种 UI：'
- en: '`ContentPage` is the most commonly used page type and can include any layout
    and view elements. It is suitable for single-page designs.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentPage` 是最常用的页面类型，可以包含任何布局和视图元素。它适用于单页设计。'
- en: '`TabbedPage` can be used to host multiple pages. Each child page can be selected
    by a series of tabs, located at either the top or bottom of the page.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabbedPage` 可以用来托管多个页面。每个子页面可以通过位于页面顶部或底部的标签系列进行选择。'
- en: '`FlyoutPage` can display a list of items, similar to menu items in a desktop
    application. Users can navigate to individual pages through the items in the menu.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlyoutPage` 可以显示项目列表，类似于桌面应用程序中的菜单项。用户可以通过菜单中的项目导航到单个页面。'
- en: Although `Shell` is also a derived class of `Page`, it includes a common navigation
    user experience that simplifies developers’ tasks. `Shell` assists developers
    by reducing the complexity of application development and consolidating highly
    customizable, rich features in one location.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Shell` 也是 `Page` 的派生类，但它包括一个通用的导航用户体验，这简化了开发者的任务。`Shell` 通过减少应用程序开发的复杂性并集中高度可定制的丰富功能在一个位置来帮助开发者。
- en: '`Shell` provides the following features:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shell` 提供以下功能：'
- en: A single place to describe the visual hierarchy of an app
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个地方来描述应用程序的视觉层次结构
- en: A highly customizable common navigation user experience
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个高度可定制的通用导航用户体验
- en: A URI-based navigation scheme that is very similar to what we have in a web
    browser
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于 URI 的导航方案，与我们网页浏览器中的非常相似
- en: An integrated search handler
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成搜索处理程序
- en: The top-level building blocks of `Shell` are flyouts and tabs. We can use flyouts
    and tabs to create the navigation structure of our app.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shell` 的顶级构建块是弹出菜单和标签。我们可以使用弹出菜单和标签来创建我们应用程序的导航结构。'
- en: Flyout
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出菜单
- en: A flyout can be used as the top-level menu of a `Shell` app. In our app, we
    must use both flyouts and tabs to create the top-level navigation design. In this
    section, we will explore flyouts; in the next section, we will discuss using tabs
    in our app.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单可以用作 `Shell` 应用程序的最高级菜单。在我们的应用程序中，我们必须同时使用弹出菜单和标签来创建最高级导航设计。在本节中，我们将探讨弹出菜单；在下一节中，我们将讨论在我们的应用程序中使用标签。
- en: In *Figure 5.3*, we can see what the flyout looks like in our app. From the
    flyout menu, we can switch to the `AboutPage`, `ItemsPage`, or `LoginPage`. To
    access the flyout menu, we can either swipe from the left edge of the screen or
    click the flyout icon, which is the hamburger icon **(1)**. When we click the
    **Root Group** **(2)** in the flyout menu, we will see a list of password entries
    or groups.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.3* 中，我们可以看到在我们的应用程序中弹出菜单的外观。从弹出菜单中，我们可以切换到 `AboutPage`、`ItemsPage` 或
    `LoginPage`。要访问弹出菜单，我们可以从屏幕左侧边缘滑动或点击弹出图标，即汉堡图标 **(1)**。当我们点击弹出菜单中的 **根组** **(2)**
    时，我们将看到密码条目或组列表。
- en: '![](img/B21554_05_03.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_05_03.png)'
- en: 'Figure 5.3: Flyout'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：弹出菜单
- en: The flyout menu consists of flyout items or menu items. In *Figure 5.3*, **About**
    and **Root****Group** are flyout items, while **Logout** is a menu item.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出菜单由弹出项或菜单项组成。在 *图 5.3* 中，**关于** 和 **根** **组** 是弹出项，而 **注销** 是菜单项。
- en: Flyout items
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹出菜单项
- en: 'Each flyout item is a `FlyoutItem` object that contains a `ShellContent` object.
    We can define flyout items like so in the `AppShell.xaml` file. We assign a `string`
    resource to the `Title` attribute **(1)** and an `ImageSource` to the `Icon` attribute
    **(2)**. These correspond to the properties of the `FlyoutItem` class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个弹出菜单项都是一个 `FlyoutItem` 对象，它包含一个 `ShellContent` 对象。我们可以在 `AppShell.xaml` 文件中这样定义弹出菜单项。我们将一个
    `string` 资源分配给 `Title` 属性 **(1**) 并将 `ImageSource` 分配给 `Icon` 属性 **(2**)。这些对应于
    `FlyoutItem` 类的属性：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Shell` has implicit conversion operators that can be used to remove the `FlyoutItem`
    and `Tab` objects so that the preceding XAML code can also be simplified, like
    so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shell` 有隐式转换运算符，可以用来移除 `FlyoutItem` 和 `Tab` 对象，这样前面的 XAML 代码也可以简化，如下所示：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Menu items
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单项
- en: 'In some instances, using flyout items for navigation to a content page might
    not be necessary; instead, we may desire to perform an action. In such cases,
    menu items can be utilized. For our scenario, we have designated `Logout` as a
    menu item to execute an action rather than navigating to another content page:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用弹出菜单项导航到内容页面可能不是必要的；相反，我们可能希望执行一个动作。在这种情况下，可以使用菜单项。对于我们的场景，我们已将`Logout`指定为执行动作的菜单项，而不是导航到另一个内容页面：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see from the preceding XAML code, each menu item is a `MenuItem` object.
    The `MenuItem` class has a `Clicked` event and a `Command` property. When `MenuItem`
    is tapped, we can execute an action. In the preceding menu item, we assigned `OnMenuItemClicked`
    as the event handler.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的XAML代码中我们可以看到，每个菜单项都是一个`MenuItem`对象。`MenuItem`类有一个`Clicked`事件和一个`Command`属性。当`MenuItem`被点击时，我们可以执行一个动作。在前面的菜单项中，我们将`OnMenuItemClicked`作为事件处理程序。
- en: Let’s take a closer look at `AppShell.xaml`, as shown in *Listing 5.1*. In this
    file, we have defined two flyout items and one menu item. The flyout items allow
    us to select the `AboutPage` **(1)** and `ItemsPage` **(2)**, while the menu item
    enables us to log out **(3)**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看*清单5.1*中所示的`AppShell.xaml`。在这个文件中，我们定义了两个弹出菜单项和一个菜单项。弹出菜单项允许我们选择`AboutPage`
    **(1)** 和`ItemsPage` **(2)**，而菜单项允许我们注销 **(3)**。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5.1: `AppShell.xaml` in PassXYZ.Vault ([https://epa.ms/AppShell5-1](https://epa.ms/AppShell5-1))'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5.1：PassXYZ.Vault中的`AppShell.xaml` ([https://epa.ms/AppShell5-1](https://epa.ms/AppShell5-1))
- en: There is also a `TabBar` **(4)** defined for `LoginPage` and `SignUpPage`. Let’s
    review tabs now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还为`LoginPage`和`SignUpPage`定义了一个`TabBar` **(4)**。现在让我们来回顾一下标签。
- en: Tabs
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: Utilizing tabs in `Shell` enables the creation of a navigation experience akin
    to that of `TabbedPage`. As depicted in *Figure 5.4*, both Android and iOS platforms
    feature two tabs on the bottom tab bar. However, the appearance of the tabs differs
    when implemented on the Windows platform.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Shell`中使用标签可以创建类似于`TabbedPage`的导航体验。如图*图5.4*所示，Android和iOS平台在底部的标签栏上都有两个标签。然而，当在Windows平台上实现时，标签的显示方式会有所不同。
- en: '![](img/B21554_05_04.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21554_05_04.png)'
- en: 'Figure 5.4: Tab bar and tabs on Android'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：Android上的标签栏和标签
- en: 'As we can see in *Figure 5.5*, on Windows, the tab bar is at the top:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5.5*所示，在Windows上，标签栏位于顶部：
- en: '![](img/B21554_05_05.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21554_05_05.png)'
- en: 'Figure 5.5: Tab bar and tabs on Windows'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：Windows上的标签栏和标签
- en: 'In order to incorporate tabs into our app, we need to create a `TabBar` object.
    This `TabBar` object can comprise one or more `Tab` objects, with each `Tab` object
    representing an individual tab on the tab bar. Additionally, each `Tab` object
    can encompass one or more `ShellContent` objects. The subsequent XAML code demonstrates
    its similarity to the code used when defining a flyout:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将标签页集成到我们的应用中，我们需要创建一个`TabBar`对象。这个`TabBar`对象可以包含一个或多个`Tab`对象，每个`Tab`对象代表标签栏上的一个单独的标签。此外，每个`Tab`对象可以包含一个或多个`ShellContent`对象。接下来的XAML代码展示了它与定义弹出菜单时使用的代码的相似性：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similar to the approach we took in the flyout XAML code, we can simplify the
    previous code by eliminating the `Tab` tags. By utilizing the implicit conversion
    operators of `Shell`, we can remove the `Tab` objects. As demonstrated, it is
    possible to omit the `Tab` tags and directly define the `Title` and `Icon` attributes
    within the `ShellContent` tags:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在弹出菜单XAML代码中采取的方法类似，我们可以通过删除`Tab`标签来简化之前的代码。通过使用`Shell`的隐式转换运算符，我们可以删除`Tab`对象。如所示，我们可以省略`Tab`标签，并在`ShellContent`标签内直接定义`Title`和`Icon`属性：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In a situation where we define both `TabBar` objects and `FlyoutItem` objects
    in `AppShell.xaml`, the `TabBar` objects will disable the flyout items. This is
    why, upon launching our app, we are presented with a tabbed screen displaying
    either the login or signup pages. Once the user successfully logs in, we can navigate
    them to the `RootPage`, which is the registered route illustrated in *Listing
    5.1*. In the following section, we will delve into the process of registering
    routes and navigating using these registered routes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们同时在`AppShell.xaml`中定义`TabBar`对象和`FlyoutItem`对象的情况下，`TabBar`对象将禁用弹出菜单项。这就是为什么在我们启动应用时，我们看到的是一个显示登录或注册页面的标签页界面。一旦用户成功登录，我们可以将他们导航到`RootPage`，这是在*清单5.1*中展示的已注册路由。在下一节中，我们将深入了解注册路由和使用这些已注册路由进行导航的过程。
- en: Shell navigation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell导航
- en: 'In `Shell`, navigating to pages is achieved through registered routes. Similar
    to a web browser, .NET MAUI uses URI-based navigation. The URI might look something
    like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Shell`中，通过注册的路由来实现页面导航。类似于网页浏览器，.NET MAUI使用基于URI的导航。URI可能看起来像以下这样：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, it might look like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可能看起来像以下这样：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the URI format allows us to specify the path within the application
    interface and potentially, include additional parameters. Beginning the URI with
    a double slash “//” signifies the root of navigation. Just like in file system
    navigation, we can also utilize “..” to execute backward navigation. This way,
    programmers can navigate the navigation stack in a way that’s both intuitive and
    efficient.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，URI格式允许我们指定应用程序界面中的路径，并且可能包括额外的参数。以双斜杠“//”开始URI表示导航的根。就像在文件系统导航中一样，我们也可以使用“..”来执行向后导航。这样，程序员可以以直观且高效的方式导航导航堆栈。
- en: There are two methods for registering routes. The first method involves registering
    routes within Shell’s visual hierarchy. The second method requires explicitly
    registering them by utilizing the `RegisterRoute` static method found in the `Routing`
    class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注册路由有两种方法。第一种方法是在Shell的可视层次结构内注册路由。第二种方法需要通过使用`Routing`类中找到的`RegisterRoute`静态方法显式地注册它们。
- en: Registering absolute routes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册绝对路由
- en: We have the option to register routes in Shell’s visual hierarchy, as demonstrated
    in *Listing 5.1*. Routes can be specified through the `Route` property of `FlyoutItem`,
    `TabBar`, `Tab`, or `ShellContent`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择在Shell的视觉层次结构中注册路由，如*列表5.1*所示。路由可以通过`FlyoutItem`、`TabBar`、`Tab`或`ShellContent`的`Route`属性来指定。
- en: In the `AppShell.xaml` file, we registered the following routes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppShell.xaml`文件中，我们注册了以下路由。
- en: '| **Route** | **Page** | **Description** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **路由** | **页面** | **描述** |'
- en: '| `LoginPage` | `LoginPage` | This route displays a page for user login |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `LoginPage` | `LoginPage` | 此路由显示用户登录页面 |'
- en: '| `SignUpPage` | `SignUpPage` | This route displays a page for user signup
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `SignUpPage` | `SignUpPage` | 此路由显示用户注册页面 |'
- en: '| `AboutPage` | `AboutPage` | This route displays a page about our app |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `AboutPage` | `AboutPage` | 此路由显示有关我们应用程序的页面 |'
- en: '| `RootPage` | `ItemsPage` | This route displays a page for navigating the
    password database |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `RootPage` | `ItemsPage` | 此路由显示用于导航密码数据库的页面 |'
- en: 'Table 5.1: Registered routes in the visual hierarchy'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1：视觉层次结构中注册的路由
- en: To navigate to a route in Shell’s visual hierarchy, we can use an absolute route
    URI. The absolute URI starts with a double slash “//”, such as `//LoginPage`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Shell的可视层次结构中导航到某个路由，我们可以使用绝对路由URI。绝对URI以双斜杠“//”开头，例如`//LoginPage`。
- en: Registering relative routes
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册相对路由
- en: 'It is also possible to navigate to a page without predefining it in the visual
    hierarchy. For instance, the password entry detail page, `ItemDetailPage`, can
    be navigated to at any hierarchy level of the password groups. In our app, we
    can explicitly register the following routes using `RegisterRoute` in the code-behind
    file, `AppShell.xaml.cs`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在不预先在视觉层次结构中定义的情况下导航到页面。例如，密码输入详细页面`ItemDetailPage`可以在密码组的任何层次结构级别导航到。在我们的应用程序中，我们可以通过在代码后文件`AppShell.xaml.cs`中使用`RegisterRoute`显式注册以下路由：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we defined the following routes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了以下路由。
- en: '| **Route** | **Page** | **Description** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **路由** | **页面** | **描述** |'
- en: '| `ItemDetailPage` | `ItemDetailPage` | This is the route to display details
    about a password entry |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `ItemDetailPage` | `ItemDetailPage` | 这是显示密码条目详细信息的路由 |'
- en: '| `NewItemPage` | `NewItemPage` | This is the route to add a new item (entry
    or group) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `NewItemPage` | `NewItemPage` | 这是添加新项目（条目或组）的路由 |'
- en: '| `ItemsPage` | `ItemsPage` | This is the route to display a page for navigating
    the password database |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `ItemsPage` | `ItemsPage` | 这是显示用于导航密码数据库的页面的路由 |'
- en: 'Table 5.2: Registered detail page routes'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：注册的详细页面路由
- en: 'In order to illustrate the usage of relative routes, we will proceed by adding
    a new item. When the need arises to add a new item, we can navigate to the `NewItemPage`
    utilizing a relative route, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明相对路由的使用，我们将通过添加一个新项目来继续。当需要添加新项目时，我们可以使用相对路由导航到`NewItemPage`，如下所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this scenario, the `NewItemPage` route is searched, and if the route is identified,
    the page will be displayed and added to the navigation stack. This navigation
    stack is the same as the one we discussed while explaining basic navigation using
    the `INavigation` interface. When defining a relative route and navigating to
    it, we pass a string as the route’s name. To prevent errors, we can use the class
    name as the route name by employing the **nameof** expression.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，搜索`NewItemPage`路由，如果识别到该路由，页面将被显示并添加到导航堆栈中。这个导航堆栈与我们解释基本导航时使用的`INavigation`接口所讨论的是相同的。当定义一个相对路由并导航到它时，我们传递一个字符串作为路由的名称。为了防止错误，我们可以通过使用`nameof`表达式来使用类名作为路由名称。
- en: 'Once we have entered the details for the new item in the `NewItemPage`, we
    can click either the **Save** or **Cancel** button. Within the event handler for
    the **Save** or **Cancel** button, we can navigate back to the previous page using
    the code provided:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`NewItemPage`中输入了新项目的详细信息，我们可以点击**保存**或**取消**按钮。在**保存**或**取消**按钮的事件处理程序中，我们可以使用提供的代码返回到上一页：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, we can also navigate back using the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用以下代码返回：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Just like in file system navigation, here, the “..” represents the parent page
    in the navigation stack.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在文件系统导航中一样，这里的“..”代表导航堆栈中的父页面。
- en: As evident from the code mentioned earlier, there are two methods to navigate
    back. The first option involves using the `PopModalAsync` method of the `INavigation`
    interface. Due to `Shell` being a derived class of `Page`, it implements the `INavigation`
    interface through the inherited `Navigation` property. We can call the `PopModalAsync`
    modal navigation method to go back, with `NewItemPage` functioning as a modal
    page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，有两种返回的方法。第一种选项是使用`INavigation`接口的`PopModalAsync`方法。由于`Shell`是`Page`的派生类，它通过继承的`Navigation`属性实现了`INavigation`接口。我们可以调用`PopModalAsync`模态导航方法来返回，其中`NewItemPage`作为模态页面。
- en: 'The second method involves utilizing the `GoToAsync` function to navigate back.
    As the `NewItemPage` serves as a modal page, you might be curious about how to
    distinguish between a modal page and a non-modal page when invoking `GoToAsync`.
    In `Shell` navigation, this distinction is determined by the page presentation
    mode. The content page of `NewItemPage` is defined as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法涉及使用`GoToAsync`函数返回。由于`NewItemPage`是一个模态页面，你可能想知道在调用`GoToAsync`时如何区分模态页面和非模态页面。在`Shell`导航中，这种区分由页面展示模式确定。`NewItemPage`的内容页面定义如下：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As observed, the `Shell.PresentationMode` **(1)** property is defined within
    the content page. Based on our preference for implementing animation, we can assign
    different values to this property. For a standard content page, we can set it
    to either `NotAnimated` or `Animated`. In the case of a modal page, the options
    are `Modal`, `ModalAnimated`, or `ModalNotAnimated`. If left unchanged, the default
    value is set to `Animated`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如观察所示，`Shell.PresentationMode` **(1**) 属性是在内容页面中定义的。根据我们实现动画的偏好，我们可以为这个属性分配不同的值。对于标准内容页面，我们可以将其设置为`NotAnimated`或`Animated`。对于模态页面，选项是`Modal`、`ModalAnimated`或`ModalNotAnimated`。如果保持不变，默认值设置为`Animated`。
- en: 'To navigate back, the `GoToAsync` method is utilized along with the route assigned
    to “..”. This approach is reminiscent of file system navigation or browser URL
    navigation. The relative route, “..”, signifies navigating back to the parent
    route. It can also be combined with a route to access a page at the parent level,
    as demonstrated here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回上一级，使用`GoToAsync`方法并指定路由为“..”。这种方法让人联想到文件系统导航或浏览器URL导航。相对路由“..”表示返回到父路由。它也可以与一个路由结合使用，以访问父级页面，如下所示：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In *Table 5.1* and *Table 5.2*, you will notice that `ItemsPage` is registered
    as both the absolute route `RootPage` and the relative route `ItemsPage`. It is
    important to note that `ItemsPage` may encompass password groups at various levels.
    When positioned at the top level, it serves as an absolute route, whereas at all
    subsequent navigation hierarchy levels, it functions as a relative route.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表5.1*和*表5.2*中，你会注意到`ItemsPage`既注册为绝对路由`RootPage`，也注册为相对路由`ItemsPage`。重要的是要注意，`ItemsPage`可能包含不同级别的密码组。当位于顶级时，它作为绝对路由，而在所有后续的导航层次级别中，它作为相对路由。
- en: Passing data to pages
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向页面传递数据
- en: In order to elaborate on the reasoning behind registering `ItemsPage` with both
    absolute and relative routes, let’s examine the navigation hierarchy of our app,
    as depicted in *Figure 5.6*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐述将 `ItemsPage` 注册为绝对和相对路由背后的原因，让我们检查我们应用的导航层次结构，如图 *5.6* 所示。
- en: '![](img/B21554_05_06.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_05_06.png)'
- en: 'Figure 5.6: Navigation hierarchy'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：导航层次结构
- en: In our app, once the user successfully logs in, the main page showcases a list
    of entries and groups situated at the top tier of the password database, referred
    to as Root Group. This resembles the navigation structure of a file system that
    displays the top-level files and folders at its root.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，一旦用户成功登录，主页将展示位于密码数据库顶层的一组条目和组，被称为根组。这类似于文件系统的导航结构，在根目录下显示顶级文件和文件夹。
- en: The first instance of `ItemsPage` employs the `RootPage` route, which can be
    accessed via the flyout item. Assume there are sub-groups named **Group1** and
    **Group2** within the Root Group, as depicted in *Figure 5.6*. We can navigate
    to these sub-groups, which also represent instances of `ItemsPage`. Since these
    instances utilize relative routes and rely on navigation stacks that are pushed
    on demand, they cannot be pre-defined. These navigation stacks can extend as deep
    as the actual data present in the password database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `ItemsPage` 实例使用 `RootPage` 路由，可以通过飞出项访问。假设根组内部有名为 **Group1** 和 **Group2**
    的子组，如图 *5.6* 所示。我们可以导航到这些子组，这些子组也代表 `ItemsPage` 的实例。由于这些实例使用相对路由并依赖于按需推入的导航堆栈，因此它们不能预先定义。这些导航堆栈可以延伸到密码数据库中实际数据的深度。
- en: 'The two distinct routes of `ItemsPage` are defined in `AppShell.xaml` and `AppShell.xaml.cs`
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsPage` 的两个不同路由在 `AppShell.xaml` 和 `AppShell.xaml.cs` 中定义如下：'
- en: 'The `RootPage` route (absolute route):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`RootPage` 路由（绝对路由）：'
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ItemsPage` route (relative route):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsPage` 路由（相对路由）：'
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section, you might be curious about how to navigate from the Root Group
    to **Group1** or **Group2**. If the `ItemsPage` is capable of displaying the content
    of either **Group1** or **Group2**, how can we inform `ItemsPage` which group
    needs to be displayed?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你可能想知道如何从根组导航到 **Group1** 或 **Group2**。如果 `ItemsPage` 能够显示 **Group1** 或
    **Group2** 的内容，我们如何通知 `ItemsPage` 需要显示哪个组？
- en: 'In `Shell` navigation, data can be transmitted to a content page using query
    parameters. The syntax is akin to the parameters passed in a URL within a web
    browser. For instance, the following URL can be used to search for **.net** on
    Google: [https://www.google.com.hk/search?q=.net.](https://www.google.com.hk/search?q=.net.)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Shell` 导航中，可以使用查询参数将数据传输到内容页面。语法类似于在网页浏览器中传递的 URL 参数。例如，以下 URL 可以用于在 Google
    上搜索 **.net**：[https://www.google.com.hk/search?q=.net.](https://www.google.com.hk/search?q=.net.)
- en: The desired outcome is achieved by appending a question mark (`?`) after a route,
    along with a pair of query parameter IDs and their respective values. In the preceding
    example, the key is `q` and the value is `.net`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在路由后附加一个问号（`?`），以及一对查询参数 ID 和它们的相应值，可以实现所需的结果。在上面的例子中，键是 `q`，值是 `.net`。
- en: 'Upon selecting an item in the list of Root Groups, it can be either an entry
    or a group. The click event activates the `OnItemSelection` method in `ItemsViewModel`,
    demonstrated in *Listing 5.2*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在根组列表中选择一个项目后，它可以是条目或组。点击事件激活 `ItemsViewModel` 中的 `OnItemSelection` 方法，如 *Listing
    5.2* 所示：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 5.2: `ItemsViewModel.cs` ([https://epa.ms/ItemsViewModel5-2](https://epa.ms/ItemsViewModel5-2))'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2：`ItemsViewModel.cs` ([https://epa.ms/ItemsViewModel5-2](https://epa.ms/ItemsViewModel5-2))
- en: Based on the item type, we might navigate to either the `ItemsPage` **(3)**
    or the `ItemDetailPage` **(4)**. In both instances, we transfer the `Id` of the
    item to the `ItemId` query parameter, which is defined in both the `ItemsViewModel`
    and the `ItemDetailViewModel`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目类型，我们可能导航到 `ItemsPage` **（3**）或 `ItemDetailPage` **（4**）。在这两种情况下，我们将项目的
    `Id` 传递给 `ItemId` 查询参数，该参数在 `ItemsViewModel` 和 `ItemDetailViewModel` 中定义。
- en: In the context of *Listing 5.2*, **(1)** `ItemId` is established as the `QueryPropertyAttribute`
    within the `ItemsViewModel`. The first argument of `QueryPropertyAttribute` corresponds
    to the name of the property designated to receive the data, which in this instance
    is `ItemId` **(2)**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Listing 5.2* 的上下文中，**（1**）`ItemId` 在 `ItemsViewModel` 中被设置为 `QueryPropertyAttribute`。`QueryPropertyAttribute`
    的第一个参数对应于接收数据的属性名称，在这个例子中是 `ItemId` **（2**）。
- en: The second argument corresponds to the `id` parameter. Upon selecting a group
    from the list, the view model’s `OnItemSelected` method **(3)** is triggered and
    the item `Id` of the chosen group is passed as the value for the `ItemId` query
    parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数对应于`id`参数。在选择列表中的一个组后，视图模型的`OnItemSelected`方法**（3**）被触发，并将所选组的`Id`作为`ItemId`查询参数的值传递。
- en: When the `ItemsPage` is loaded along with the `ItemId` query parameter, the
    `ItemId` property **(2)** gets set. In the setter of the `ItemId` property, we
    examine whether the query parameter value is empty. If it is empty, it might be
    our initial navigation to the `RootPage` route without any query parameter. In
    this case, we just set `SelectedItem` to `null`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ItemsPage`与`ItemId`查询参数一起加载时，`ItemId`属性**（2**）被设置。在`ItemId`属性的设置器中，我们检查查询参数值是否为空。如果为空，这可能意味着我们初始导航到没有查询参数的`RootPage`路由。在这种情况下，我们只需将`SelectedItem`设置为`null`。
- en: If it is not empty, we will find the item and set it to `SelectedItem`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不为空，我们将找到项目并将其设置为`SelectedItem`。
- en: '**(4)** If we select an entry from the list, we can navigate to `ItemDetailPage`
    with the item `Id` as the value of the query parameter. To accommodate this query
    parameter, we can modify the ItemId property of the `ItemDetailViewModel` as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**（4**）如果我们从列表中选择一个条目，我们可以导航到带有项目`Id`作为查询参数值的`ItemDetailPage`。为了适应这个查询参数，我们可以修改`ItemDetailViewModel`的`ItemId`属性如下：'
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `ItemDetailViewModel` class, we implement the following logic:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ItemDetailViewModel`类中，我们实现以下逻辑：
- en: '`ItemId` **(1)** serves as the property that accepts the query parameter.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemId`**（1**）作为接受查询参数的属性。'
- en: When setting the `ItemId`, the `LoadItemId` method **(2)** is called to load
    the item.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置`ItemId`时，调用`LoadItemId`方法**（2**）来加载项目。
- en: Within `LoadItemId`, the data service method `GetItem` **(3)** is called to
    obtain the item using its corresponding `Id`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`LoadItemId`中，数据服务方法`GetItem`**（3**）被调用，以使用其相应的`Id`获取项目。
- en: In this case, the item is an instance of `PwEntry` **(4)**, which can be cast
    accordingly.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，项目是一个`PwEntry`实例**（4**），可以相应地进行转换。
- en: The PassXYZLib extension method, `GetFields` **(5)**, is utilized to update
    the list of fields.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PassXYZLib扩展方法`GetFields`**（5**）被用来更新字段列表。
- en: In the previous two sections, we acquired knowledge of basic navigation and
    `Shell` navigation and enhanced our navigation design using `Shell`. At this point,
    it is essential to revisit the MVVM pattern and further refine our data model
    to improve the quality of our password manager app.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个章节中，我们了解了基本导航和`Shell`导航，并使用`Shell`增强了我们的导航设计。此时，重新审视MVVM模式并进一步细化我们的数据模型，以改善密码管理器应用的质量至关重要。
- en: Improving our app
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的应用
- en: In *Chapter 4*, *Exploring MVVM and Data Binding*, we analyzed various use cases
    and developed a few. In this section, utilizing the knowledge we have acquired,
    we will augment the existing use cases and introduce new ones.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*探索MVVM和数据绑定*中，我们分析了各种用例并开发了一些。在本节中，利用我们所获得的知识，我们将增强现有的用例并引入新的用例。
- en: 'We will be working on the following use cases:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将致力于以下用例：
- en: '**Use case 1**: As a password manager user, I want to log in to the password
    manager app so that I can access my password data.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例1**：作为密码管理器用户，我想登录到密码管理器应用，以便我可以访问我的密码数据。'
- en: In this use case, we have not yet fully implemented user login; we plan to complete
    this in the subsequent chapter. For now, we will implement a pseudo-logic that
    encompasses all aspects except the data layer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，我们尚未完全实现用户登录；我们计划在下一章中完成这项工作。目前，我们将实现一个伪逻辑，涵盖所有方面，除了数据层。
- en: Previously, in *Chapter 4*, *Exploring MVVM and Data Binding*, we covered a
    use case that supports one level of navigation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的*第4章*，*探索MVVM和数据绑定*中，我们介绍了一个支持一级导航的用例。
- en: '**Use case 3**: As a password manager user, I want to see a list of groups
    and entries so that I can explore my password data.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例3**：作为密码管理器用户，我想看到一组和条目的列表，以便我可以探索我的密码数据。'
- en: 'To accommodate multiple levels of navigation, we will implement the following
    use cases in this section:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应多级导航，我们将在本节中实现以下用例：
- en: '**Use case 6**: As a password manager user, when I click on a group in the
    current list, I want to see the groups and entries belonging to that group.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例6**：作为密码管理器用户，当我点击当前列表中的一个组时，我想看到属于该组的组和条目。'
- en: '**Use case 7**: As a password manager user, when navigating through my password
    data, I want to be able to go back to the previous group or parent group.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例 7**：作为密码管理器用户，当我在密码数据中导航时，我希望能够返回到上一个组或父组。'
- en: In the previous implementation (use case 1), after login, we implemented the
    navigation to the root page using an absolute route. However, the implementation
    of the `LoginService` is not done yet. We need to implement it in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实现（用例 1）中，登录后，我们使用绝对路径实现了对根页面的导航。然而，`LoginService` 的实现尚未完成。我们需要在本章中实现它。
- en: After loading the root page (use case 3), at present, we can only browse the
    root-level entries and groups. We are not yet able to enter a child group from
    the root level. To address this limitation, we are introducing use cases 6 and
    7 in this chapter. In use cases 6 and 7, we aim to navigate forward and backward
    using relative routes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载根页面（用例 3）后，目前我们只能浏览根级别的条目和组。我们还没有从根级别进入子组的能力。为了解决这个限制，我们在本章中引入了用例 6 和 7。在用例
    6 和 7 中，我们的目标是使用相对路径进行前后导航。
- en: With the MVVM pattern, we access our model through services, which are typically
    abstracted as interfaces, separate from the actual implementation. The `IDataStore`
    interface is an example of this. In order to support use case 6 and enhance use
    case 1, we need to develop a new interface called `IUserService` for user login
    support.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MVVM 模式，我们通过服务访问我们的模型，这些服务通常被抽象为接口，与实际实现分离。`IDataStore` 接口就是这样一个例子。为了支持用例
    6 并增强用例 1，我们需要开发一个新的接口，称为 `IUserService`，以支持用户登录。
- en: Understanding the improved design
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解改进的设计
- en: 'To understand the services and the enhanced model, let’s review the enhanced
    design in *Figure 5.7*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解服务和增强的模型，让我们回顾 *图 5.7* 中的增强设计：
- en: '![Figure 5.7: Model and service in MVVM ](img/B21554_05_07.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：MVVM 中的模型和服务](img/B21554_05_07.png)'
- en: 'Figure 5.7: Model and service in MVVM'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：MVVM 中的模型和服务
- en: '*Figure 5.7* presents a class diagram that illustrates the majority of our
    design. To comprehend the design of our app, we can examine this class diagram
    in conjunction with the table provided. For the sake of simplicity, I have excluded
    some elements. For instance, you can add the `NewItemPage` or `SignUpPage` to
    *Figure 5.7* and *Table 5.3* by yourself.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.7* 展示了一个类图，说明了我们设计的大部分内容。为了简化，我排除了某些元素。例如，你可以自己将 `NewItemPage` 或 `SignUpPage`
    添加到 *图 5.7* 和 *表 5.3* 中。'
- en: '| **Model** | **View** | **View Model** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **模型** | **视图** | **视图模型** |'
- en: '| **Data Model** | **Service** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **数据模型** | **服务** |'
- en: '| `User` | `IUserService` | `LoginPage` | `LoginViewModel` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `User` | `IUserService` | `LoginPage` | `LoginViewModel` |'
- en: '| `Item` | `IDataStore` | `ItemsPage` | `ItemsViewModel` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `Field` | `ItemDetailPage` | `ItemDetailViewModel` |'
- en: '| `Field` | `ItemDetailPage` | `ItemDetailViewModel` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `Field` | `ItemDetailPage` | `ItemDetailViewModel` |'
- en: 'Table 5.3: Classes and interfaces in the MVVM pattern'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3：MVVM 模式中的类和接口
- en: Registering absolute routes and relative routes
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册绝对路径和相对路径
- en: In this section, when introducing pages and routes, you may notice that the
    names of pages and routes could be the same. To distinguish between them, I’ll
    use bold font to identify a page and italic font to identify a route.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，当介绍页面和路径时，你可能注意到页面和路径的名称可能是相同的。为了区分它们，我将使用粗体字体来标识页面，使用斜体字体来标识路径。
- en: In our application, both absolute and relative routes are registered within
    the `AppShell` class. The absolute routes, *LoginPage*, *SignUpPage*, *RootPage*,
    and *AboutPage*, are created as parts of the `Shell`. Conversely, the relative
    routes – *ItemsPage*, *ItemDetailPage*, and *NewItemPage* – are defined within
    the constructor of the `AppShell`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，`AppShell` 类内部注册了绝对路径和相对路径。绝对路径，如 `LoginPage`、`SignUpPage`、`RootPage`
    和 `AboutPage`，作为 `Shell` 的部分创建。相反，相对路径——`ItemsPage`、`ItemDetailPage` 和 `NewItemPage`——在
    `AppShell` 的构造函数中定义。
- en: To facilitate multi-level navigation, the page **ItemsPage** is registered as
    both the absolute route *RootPage* and the relative route *ItemsPage*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于多级导航，页面 `ItemsPage` 被注册为绝对路径 `RootPage` 和相对路径 `ItemsPage`。
- en: Upon application loading, the route *LoginPage* is utilized. Post-login, the
    app navigates to *RootPage*. If a user selects a child group, the relative route
    *ItemsPage* is loaded, thereby permitting navigation deeper into multi-levels.
    When a user selects an entry, the relative route *ItemsDetailPage* is loaded.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序加载时，使用*LoginPage*路由。登录后，应用导航到*RootPage*。如果用户选择子组，将加载相关的*ItemsPage*路由，从而允许在多级结构中进行更深入的导航。当用户选择条目时，将加载相关的*ItemsDetailPage*路由。
- en: Model and services
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型和服务
- en: To save application data, we typically store it in a database, which could be
    either a relational database or a NoSQL database. In our case, our password database
    is not a relational database. Nevertheless, while working on our design, we can
    employ the analogous logic of relational databases when formulating our business
    logic. Our model is represented by three distinct classes – `User`, `Item`, and
    `Field`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存应用程序数据，我们通常将其存储在数据库中，这可以是关系型数据库或NoSQL数据库。在我们的案例中，我们的密码数据库不是关系型数据库。然而，在我们设计的过程中，我们可以使用关系型数据库的类似逻辑来制定我们的业务逻辑。我们的模型由三个不同的类表示——`User`、`Item`和`Field`。
- en: In the context of our design, `Item` and `Field` represent a password entry
    and the content within that entry, respectively. An entry can be visualized as
    a row in a table, with a field acting as a cell. To model a password entry, we
    employ the `PwEntry` from KeePassLib. In this instance, a group refers to a collection
    of entries, and `PwGroup` is utilized to model this group. A group can be compared
    to a table within a database, and fields that share the same key values across
    a group are akin to a column. In order to develop the interface for our data services,
    we can adopt a similar approach for processing data within our database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计背景下，`Item`和`Field`分别代表密码条目和该条目中的内容。一个条目可以想象成表格中的一行，字段作为单元格。为了模拟密码条目，我们使用KeePassLib中的`PwEntry`。在这个例子中，组指的是条目的集合，`PwGroup`用于模拟这个组。组可以比作数据库中的表，而共享相同键值的字段可以比作列。为了开发我们的数据服务接口，我们可以在数据库中处理数据时采用类似的方法。
- en: How can we manage data within a database? You might be familiar with the term
    CRUD operations. In our situation, we can employ the augmented `create`, `read`,
    `update`, `delete`, and `list` (**CRUDL**) operations for defining the interface
    of our service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在数据库中管理数据？你可能熟悉CRUD操作这个术语。在我们的情况下，我们可以使用增强的`创建`、`读取`、`更新`、`删除`和`列表`（**CRUDL**）操作来定义我们服务的接口。
- en: 'To process password entries and groups, we can use the following `IDataStore`
    interface:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理密码条目和组，我们可以使用以下`IDataStore`接口：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `IDataStore` interface, we define the following CRUDL operations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IDataStore`接口中，我们定义了以下CRUDL操作：
- en: '**Create**: We use `AddItemAsync` to add an entry or a group'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：我们使用`AddItemAsync`来添加条目或组'
- en: '**Read**: We use `GetItem` or `GetItemAsync` to read an entry or a group'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取**：我们使用`GetItem`或`GetItemAsync`来读取条目或组'
- en: '**Update**: We use `UpdateItemAsync` to update an entry or a group'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：我们使用`UpdateItemAsync`来更新条目或组'
- en: '**Delete**: We use `DeleteItemAsync` to delete an entry or a group'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：我们使用`DeleteItemAsync`来删除条目或组'
- en: '**List**: We use `GetItemsAsync` to get a list of entries and groups in the
    current group'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：我们使用`GetItemsAsync`来获取当前组中的条目和组列表'
- en: 'To manage users, we can utilize the following `IUserService` interface:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理用户，我们可以使用以下`IUserService`接口：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can define a set of CRUDL operations to handle users as well:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一组CRUDL操作来处理用户：
- en: '**Create**: We can create a new user using `AddUserAsync`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：我们可以使用`AddUserAsync`创建新用户'
- en: '**Read**: We can get the user information using `GetUser`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取**：我们可以使用`GetUser`获取用户信息'
- en: '**Delete**: We can delete a user using `DeleteUserAsync`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：我们可以使用`DeleteUserAsync`删除用户'
- en: '**List**: We can get a list of users using `GetUsersList`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：我们可以使用`GetUsersList`获取用户列表'
- en: '**LoginAsync** and **Logout**: We can log in or log out using an instance of
    `User`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录**和**登出**：我们可以使用`User`实例来登录或登出'
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the constructor of `ItemsViewModel` class, we initialize the `IDataStore`
    and `ILogger` services through a dependency injection.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ItemsViewModel`类的构造函数中，我们通过依赖注入初始化了`IDataStore`和`ILogger`服务。
- en: Implementation of IUserService
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IUserService`的实现'
- en: 'In our application, the `UserService` class serves as the implementation of
    the `IUserService` interface. The code for this can be found in *Listing 5.3*.
    For the sake of simplifying the testing process, we have not implemented all features
    in this chapter, as we continue to utilize a mock data store:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，`UserService` 类是 `IUserService` 接口的实现。这个代码可以在 *列表 5.3* 中找到。为了简化测试过程，我们没有在本章实现所有功能，因为我们继续使用模拟数据存储：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 5.3: `UserService.cs` ([https://epa.ms/UserService5-3](https://epa.ms/UserService5-3))'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5.3: `UserService.cs` ([https://epa.ms/UserService5-3](https://epa.ms/UserService5-3))'
- en: In the `UserService` constructor **(1)**, an `IDataStore` instance is initialized
    via dependency injection. The available functions can be classified into two types.
    Functions such as `GetUser`, `DeleteUserAsync`, and `GetUserList` can be implemented
    using methods from the `User` class. Meanwhile, methods like `AddUserAsync`, `LoginAsync`,
    and `Logout` are implemented using the `IDataStore` instance.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UserService` 构造函数 **(1)** 中，通过依赖注入初始化 `IDataStore` 实例。可用的功能可以分为两种类型。例如 `GetUser`、`DeleteUserAsync`
    和 `GetUserList` 等功能可以使用 `User` 类的方法实现。同时，`AddUserAsync`、`LoginAsync` 和 `Logout`
    等方法使用 `IDataStore` 实例实现。
- en: Improving the login process
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进登录过程
- en: 'In the process of user management, we may need to add new users or remove outdated
    users from the system. For our app, it only allows one user to log in at a time.
    To support this feature, we can implement a class using the singleton pattern.
    Alternatively, we can implement a class and utilize dependency injection to have
    a similar effect on the singleton pattern. For instance, we can create a `LoginService`
    class that inherits from the `User` class, as demonstrated in *Listing 5.4*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户管理的过程中，我们可能需要向系统中添加新用户或删除过时的用户。对于我们的应用程序，它一次只允许一个用户登录。为了支持这个功能，我们可以通过单例模式实现一个类。或者，我们可以实现一个类并利用依赖注入来达到类似单例模式的效果。例如，我们可以创建一个继承自
    `User` 类的 `LoginService` 类，如 *列表 5.4* 所示：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5.4: `LoginService.cs` ([https://epa.ms/LoginService5-4](https://epa.ms/LoginService5-4))'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5.4: `LoginService.cs` ([https://epa.ms/LoginService5-4](https://epa.ms/LoginService5-4))'
- en: '**(1)** The LoginService class is derived from the PxUser subclass, which in
    turn inherits from the User class.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** `LoginService` 类是从 `PxUser` 子类派生的，而 `PxUser` 子类又继承自 `User` 类。'
- en: '**(2)** Within LoginService, we initialize the IUserService interface through
    dependency injection.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** 在 `LoginService` 中，我们通过依赖注入初始化 `IUserService` 接口。'
- en: '**(3)** To execute user login, we can invoke the IUserService method by passing
    a LoginService instance as the argument. **(4)** The same process is applicable
    in the case of user signup.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3)** 要执行用户登录，我们可以通过传递一个 `LoginService` 实例作为参数来调用 `IUserService` 方法。**(4)**
    同样的过程也适用于用户注册的情况。'
- en: Login view model
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录视图模型
- en: 'After introducing the model and service layer, we can now focus on the view
    model and view for the login and signup functionality. Let’s start by examining
    the implementation of the view model, as presented in *Listing 5.5*:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了模型和服务层之后，我们现在可以专注于登录和注册功能的视图模型和视图。让我们首先检查视图模型的实现，如 *列表 5.5* 所示：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5.5: `LoginViewModel.cs` ([https://epa.ms/LoginViewModel5-5](https://epa.ms/LoginViewModel5-5))'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5.5: `LoginViewModel.cs` ([https://epa.ms/LoginViewModel5-5](https://epa.ms/LoginViewModel5-5))'
- en: '**(1)** In the `LoginViewModel`, we inject an instance of `LoginService` through
    dependency injection and save it in the private member variable `_currentUser`.
    This variable is utilized to track all login and signup activities.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 在 `LoginViewModel` 中，我们通过依赖注入注入一个 `LoginService` 实例，并将其保存到私有成员变量 `_currentUser`
    中。这个变量用于跟踪所有登录和注册活动。'
- en: Subsequently, we created the `LoginCommand` **(2)** and `SignUpCommand` **(3)**
    using the `RelayCommand` attribute from the .NET Community Toolkit. Within these
    functions, we call the `LoginAsync` and `SignUpAsync` methods from the `LoginService`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们创建了 `LoginCommand` **(2)** 和 `SignUpCommand` **(3)**，使用 .NET Community
    Toolkit 中的 `RelayCommand` 属性。在这些函数中，我们调用 `LoginAsync` 和 `SignUpAsync` 方法从 `LoginService`。
- en: To validate both commands, we created the `ValidateLogin` and `ValidateSignUp`
    methods to perform the necessary checks. In `ValidateLogin`, we ensure that both
    the username and password are not empty before allowing the login process to proceed.
    In `ValidateSignUp`, we not only verify the username and password but also confirm
    that the password and confirmation password fields match. **(4)** To trigger the
    validation methods, the `NotifyCanExecuteChangedFor` attribute is added to decorate
    the properties. This is part of the MVVM toolkit implementation, which we discussed
    in *Chapter 4**, Exploring MVVM and Data Binding*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这两个命令，我们创建了`ValidateLogin`和`ValidateSignUp`方法来执行必要的检查。在`ValidateLogin`中，我们在允许登录过程继续之前确保用户名和密码都不为空。在`ValidateSignUp`中，我们不仅验证用户名和密码，还确认密码和确认密码字段匹配。**（4**）为了触发验证方法，我们添加了`NotifyCanExecuteChangedFor`属性来装饰属性。这是MVVM工具包实现的一部分，我们在**第4章**，探索MVVM和数据绑定中讨论了它。
- en: Now, we have upgraded our model and services to optimize the login process.
    Reviewing the class diagram in *Figure 5.7*, we have modified the source code
    at the view, view model, and service layers to improve our application. The actual
    model is contained within two libraries, `KPCLib` and `PassXYZLib`. We have exposed
    the capabilities of these libraries through the `IDataStore` and `IUserService`
    interfaces. By creating the implementing classes for these two interfaces, we
    have further enhanced our model. In the following section, we will focus on the
    view layer and examine the upgraded UI.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经升级了我们的模型和服务以优化登录过程。通过查看*图5.7*中的类图，我们已经修改了视图、视图模型和服务层的源代码来改进我们的应用。实际模型包含在两个库中，`KPCLib`和`PassXYZLib`。我们通过`IDataStore`和`IUserService`接口公开了这些库的功能。通过为这两个接口创建实现类，我们进一步增强了我们的模型。在下一节中，我们将重点关注视图层并检查升级的UI。
- en: Login UI
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录UI
- en: We can now enhance the login and signup UI. Currently, the login page only contains
    a single button. Let’s add a username field and a password field to `LoginPage.xaml`,
    as illustrated in *Figure 5.8*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以增强登录和注册UI。目前，登录页面只包含一个按钮。让我们向`LoginPage.xaml`添加用户名字段和密码字段，如图*图5.8*所示。
- en: '![](img/B21554_05_08.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21554_05_08.png]'
- en: 'Figure 5.8: LoginPage'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：LoginPage
- en: 'In this new UI design, we made the following changes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的UI设计中，我们做了以下更改：
- en: We created a 4x3 grid layout within a frame. **(1)**
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在框架内创建了一个4x3的网格布局**（1**）。
- en: In the first two rows, we added two `Entry` controls to hold the username **(2)**
    and password **(3)**. We established a data binding between the `Text` fields
    of the `Entry` controls and the properties of the `LoginViewModel`.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前两行中，我们添加了两个`Entry`控件来保存用户名**（2**）和密码**（3**）。我们在`Entry`控件的`Text`字段和`LoginViewModel`的属性之间建立了数据绑定。
- en: In the third row, we incorporated an `ActivityIndicator` control **(4)** to
    display the login status, which is bound to the `IsBusy` property of the view
    model.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三行，我们引入了一个`ActivityIndicator`控件**（4**）来显示登录状态，它与视图模型的`IsBusy`属性绑定。
- en: In the final row, we defined a `Button` control **(5)** for the login action.
    The `Button` control has a `Command` property that implements the `ICommand` interface.
    We used data binding to link this `Command` property to the method in the view
    model responsible for performing the login action.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一行中，我们定义了一个`Button`控件**（5**）用于登录操作。`Button`控件有一个实现`ICommand`接口的`Command`属性。我们使用数据绑定将这个`Command`属性链接到视图模型中负责执行登录操作的方法。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on fundamental navigation principles and the `Shell`
    framework. We chose `Shell` as the navigation foundation for our app design, examined
    its capabilities, and discussed how to integrate it into our app’s UI.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于基本导航原则和`Shell`框架。我们选择`Shell`作为我们应用设计的导航基础，检查了其功能，并讨论了如何将其集成到我们应用的UI中。
- en: 'After we completed most of the UI design, we enhanced our model by making changes
    to two service interfaces: `IDataStore` and `IUserService`. We improved the login
    process after making changes in the view, view model, and service layers. In the
    service layer, we are still using the `MockDataStore` class. However, we haven’t
    finalized the implementation in the `IDataStore` service to perform the actual
    login activities yet. We will leave this to the next chapter.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成大部分UI设计后，我们通过修改两个服务接口`IDataStore`和`IUserService`来增强了我们的模型。我们在视图、视图模型和服务层进行更改后改进了登录过程。在服务层，我们仍然使用`MockDataStore`类。然而，我们还没有在`IDataStore`服务中完成实际登录活动的实现。我们将把这个留到下一章。
- en: 'Upon completing the majority of the UI design, we proceeded to refine our model
    by modifying two service interfaces: `IDataStore` and `IUserService`. By making
    alterations in the view, view model, and service layers, we enhanced the login
    process. In the service layer, we continued to utilize the `MockDataStore` class.
    However, the implementation of the `IDataStore` service for performing actual
    login activities has yet to be finalized, and we will address this in the subsequent
    chapter.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成大部分 UI 设计后，我们通过修改两个服务接口 `IDataStore` 和 `IUserService` 来细化我们的模型。通过在视图、视图模型和服务层中进行修改，我们增强了登录过程。在服务层中，我们继续使用
    `MockDataStore` 类。然而，用于执行实际登录活动的 `IDataStore` 服务实现尚未完成，我们将在下一章中解决这个问题。
- en: In the next chapter, we will delve into dependency injection in .NET MAUI, which
    is done quite differently compared to Xamarin.Forms. We will instruct you on how
    to register our services using dependency injection and how to initialize our
    service via constructor injection or property injection. Furthermore, we will
    develop the actual service to supersede the `MockDataStore`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 .NET MAUI 中的依赖注入，这与 Xamarin.Forms 的做法大不相同。我们将指导您如何使用依赖注入注册我们的服务，以及如何通过构造函数注入或属性注入初始化我们的服务。此外，我们将开发实际的服务以取代
    `MockDataStore`。
- en: Learn more on Discord
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
- en: '![](img/QR_Code166522361691420406.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code166522361691420406.png)'
