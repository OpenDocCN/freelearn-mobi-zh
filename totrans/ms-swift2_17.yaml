- en: Chapter 17. Adopting Design Patterns in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the Gang of Four''s *Design Patterns: Elements of Reusable Object-Oriented
    Software* was first published in October 1994, it has only been in the last 6
    or 7 years that I started paying attention to design patterns. Like most experienced
    developers, when I first started reading about design patterns, I recognized a
    lot of the patterns because I had already been using them without realizing what
    they were. I would have to say that in the past 6 or 7 years since I first read
    about design patterns, I did not write a serious application without using at
    least one of the Gang of Four''s design patterns. I will tell you that I am definitely
    not a design pattern zealot, and actually, if I get into a conversation about
    design patterns, there is usually only a couple that I can name without having
    to look them up, but one thing that I do remember is the concepts of the major
    patterns and the problems they are written to solve. This way, when I encounter
    one of these problems, I can look up the appropriate pattern and apply it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between reference and value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What design patterns are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What types of patterns make up the creational, structural, and behavioral categories
    of design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the builder, factory method, and singleton creational patterns
    in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the bridge, façade, and proxy structural patterns in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the strategy and command behavioral patterns in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value versus reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Classes and Structures"), *Classes and
    Structures*, we discussed the difference between value and reference types. It
    is important that we understand the basic differences between the two types, especially
    when we are architecting our code. Certain design patterns work best with reference
    types, while other work best with value types; therefore, knowing when to use
    each type is important in design patterns. With that in mind, let's review the
    difference between reference and value types.
  prefs: []
  type: TYPE_NORMAL
- en: A class is a reference type. What this means is that when we pass an instance
    of a class around our code, we are passing a reference to the original instance.
    Since we are passing a reference to the original instance, any changes that are
    made to this instance are reflected back to the original instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structures, enums, and tuples are all value types. When we pass an instance
    of a value type, we are passing a copy of the type. This means that any changes
    made to this copy is not reflected back to the original. Let''s take a look at
    the difference between a value and reference types by looking at some code. We
    will begin by creating a class named `MyClass` and a structure named `MyStruct`.
    Both of these types contain a single property named `number` that will be of the
    Int type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create an instance of the `MyClass` class. We will also create a
    second constant of the `MyClass` type that is created from the first instance.
    We will then change the `number` property in one of the instances, and see what
    the value is in both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran this code, we would see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, when we changed the `number` property in one instance, it changed
    the value in both. This also means that there is only one instance of the `MyClass`
    class in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at this same example, but this time, we will use the `MyStruct`
    structure (value type) rather than the `MyClass` class (reference type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran this code, we would see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in this example, when we change the `number` property of one instance,
    it did not change the property in the other. Since the `myStruct2` structure was
    created with a copy of the `myStruct` structure, we now have two instances of
    the `MyStruct` structure in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we defined the instances of the `MyClass` class as constants
    with the `let` keyword; however, we defined the instances of the `MyStruct` structure
    as variables with the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: When a constant refers to an instance of a reference type, we are unable to
    change the instance that the constant is referring to; however, we are able to
    change the values of the properties of that instances, as shown in the previous
    example. When a constant refers to an instance of a value type, we will not only
    be unable to change the instance that the constant is referring to, but we will
    also be unable to change any of the property values. Swift arrays and dictionaries
    are value types which is why when they are declared constants, they are immutable.
    This means, in our previous example, in order to change the values of the `number`
    properties, we needed to create the instances of the `MyStruct` structures as
    variables and not constants.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some of the design patterns in this chapter, we used structures and for
    some other, we used classes. The choice to use either a structure or class for
    these examples is based on the experience of the author. For most of the patterns,
    the choice of using either a structure or a class should be based on the needs
    of the individual application. In each section, we will explain why we chose either
    a structure or a class to help you understand why it was chosen.
  prefs: []
  type: TYPE_NORMAL
- en: What are design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every experienced developer has a set of informal strategies that shape how
    he/she designs and writes applications. These strategies are shaped by their past
    experiences and the obstacles that they have had to overcome in previous projects.
    Though these developers might swear by their strategies, it does not mean that
    their strategies have been fully vetted and proven. The use of these strategies
    also introduces inconsistent implementations between different developers.
  prefs: []
  type: TYPE_NORMAL
- en: A design pattern identifies a common software development problem and provides
    a strategy for dealing with it. Over the years, the strategies behind these design
    patterns have been proven to effectively solve the problem they are intended to
    solve.
  prefs: []
  type: TYPE_NORMAL
- en: While there is a lot to like about design patterns, and they are extremely beneficial
    to developers and architects, they are not the solution for world hunger that
    some developers make them out to be. Sometimes in your development career, you
    will probably meet a developer or architect who thinks that design patterns are
    immutable laws. These developers usually try to force the use of design patterns
    even when they are not necessary. A good rule of thumb is to make sure that you
    have a problem to fix before you try to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that design patterns are starting points for avoiding and solving
    common programming problems. We can think of each design pattern as a recipe for
    a food dish, and just like a good recipe, we can tinker and adjust it to meet
    our particular taste, but we usually do not want to stray too far from the original
    recipe because we may mess it up.
  prefs: []
  type: TYPE_NORMAL
- en: There are also times that we do not have a recipe for a certain dish, just like
    there are times when there isn't a design pattern to solve the problem we face.
    In these cases, we can use our knowledge of design patterns and their underlying
    philosophy to come up with an effective solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Design patterns can be broken into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: These support the creation of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: These are concerned with class and object compositions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral patterns**: These are concerned with communication between classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the Gang of Four defined over 20 design patterns, we are only going to
    give examples of some of the most popular patterns in this chapter. Let's start
    off by looking at the creational patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creational patterns are design patterns that deal with how an object is created.
    These patterns create objects in a manner that is suitable for the particular
    situation. There are two basic ideas behind creational patterns. The first is
    encapsulating the knowledge of which concrete classes should be created and the
    second is hiding how the instances of these classes are created.     There are five well-known patterns that are part of the creational pattern category:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract factory pattern**: This provides an interface for creating related
    objects without specifying the concrete class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Builder pattern**: This separates the construction of a complex object from
    its representation so the same process can be used to create similar types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory method pattern**: This creates objects without exposing the underlying
    logic of how the object or which type is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype pattern**: This creates an object by cloning an existing one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton pattern**: This allows one and only one instance of a class for
    the lifetime of an application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to show you examples of how to use the builder,
    factory method, and singleton patterns in Swift. Let's start off by looking at
    one of the most controversial and possibly overused design patterns—the singleton
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the singleton pattern is a fairly controversial subject among certain
    corners of the development community. One of the main reasons for this is the
    singleton pattern is probably the most overused and misused pattern. Another reason
    why this pattern is controversial is that the singleton pattern introduces a global
    state into an application, which allows the ability to change the object at any
    point within the application, thereby ignoring the scope. My personal opinion
    is, if the singleton pattern is used correctly, there is nothing wrong with using
    it; however, we do need to be careful not to misuse it.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern restricts the instantiation of a class to one instance
    for the lifetime of an application. This pattern is very effective when we need
    exactly one object to coordinate actions within our application. An example of
    a good use of a singleton is if our application communicates with a remote device
    over Bluetooth and we also want to maintain that connection throughout our application.
    While some would say that we can pass the instance of the connection class from
    one page to the next, that is essentially what a singleton is.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the singleton pattern, in this instance, is much cleaner because
    with the singleton pattern, any page that needs the connection can get it without
    forcing every page to maintain the instance. This also allows us to maintain the
    connection without having to reconnect each time we go to another page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways to implement the singleton pattern in Swift. The way
    that is presented here uses class constants, which were introduced in version
    1.2 of Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would implement the singleton pattern with Swift. The
    following code example shows how to create a singleton class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see that within the `MySingleton` class, we create a static constant
    named `sharedInstance`, which contains an instance of the `MySingleton` class.
    A static constant can be called without having to instantiate the class. Since
    we declared the `sharedInstance` constant static, only one instance will exist
    throughout the life cycle of the application, thereby creating the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We also create a private initiator that will restrict other code from creating
    another instance of the `MySingleton` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how this pattern works. The `MySingleton` pattern has another
    property named `number`, which is of the Int type. We will monitor how this property
    changes as we use the `sharedInstance` property to create multiple variables of
    the `MySingleton` type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `sharedInstance` property to create three variables
    of the `MySingleton` type. We initially set the `number` property of the second
    `MySingleton` variable (`singleB`) to the number `2`. When we print out the value
    of the `number` property for `singleA`, `singleB`, and `singleC`, we see that
    the `number` property for all the three equals to `2`. We then change the value
    of the `number` property of the third `MySingleton` variable (`singleC`) to the
    number `3`. When we print out the value of the `number` property again, we see
    that this time, all the three now have the value of `3`. Therefore, when we change
    the value of the `number` property in any of the instances, it changes the values
    for all the three because each variable is pointed to the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern can be very useful when we need to maintain the state
    of an object throughout our application, but be careful not to overuse it. The
    singleton pattern should not be used unless there is a specific requirement (requirement
    is the keyword here) for having one, and only one, instance of our class throughout
    the life cycle of our application. If we are using the singleton pattern simply
    for convenience, then we are misusing it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the singleton pattern, we created the `MySingleton` type as a class (reference
    type) because we wanted to ensure that only one instance of the type existed throughout
    our application. If we created the `MySingleton` type as a structure (value type),
    we would run the risk of the existence of multiple instances because structures
    are value type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the builder design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The builder design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The builder pattern helps us in the creation of complex objects and enforces
    the process of how these objects are created. With this pattern, we generally
    separate the creation logic from the complex class and put it in another class.
    This allows us to use the same construction process to create different representations
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how to use the builder pattern by creating a `Burger`
    class and then use various different burger builders to create different types
    of burgers. Before we see how to use the builder pattern, let's look at how to
    create a `Burger` class without the builder pattern and the problems we'll run
    into.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a class named `BurgerOld` and does not use the builder
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `BurgerOld` class, we have several properties that define what is on
    the burger and also the name of the burger. Since we need to know which items
    are on the burgers and which aren''t, when we create an instance of the `BurgerOld`
    class, the initializer requires us to define each item. This can lead to some
    complex initializations throughout our application, not to mention that if we
    had more than one standard burger (bacon cheeseburger, cheeseburger, hamburger,
    and so on), we would need to make sure that we define each correctly. Let''s see
    how to create the instances of the `BurgerOld` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at a better way to do this. We will begin by creating a `BurgerBuilder`
    protocol that will have the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This protocol simply defines the nine properties that will be required for
    any class that implements this protocol. Now, let''s create two classes that implement
    this protocol—the `HamburgerBuilder` and `CheeseBurgerBuilder` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In both the `HamburgerBuilder` and `CheeseBurgerBuilder` classes, all we are
    doing is defining the values for each of the required properties. In more complex
    classes, we might need to initialize other objects that are required by this instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our `Burger` class that will use implementations of the
    `BugerBuilder` protocol to create instances of itself. Let''s take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between this `Burger` class and the `BurgerOld` class, shown
    earlier in this section, is the initializer. In the previous `BurgerOld` class,
    the initializer took nine arguments—one for each constant defined in the class.
    In the new `Burger` class, the initializer takes one argument, which is an instance
    of a class that conforms to the `BurgerBuilder` protocol. This new initializer
    allows us to create instances of the `Burger` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we compare how we created instances of the new `Burger` class to the earlier
    `BurgerOld` class, we can see that it is much easier to create instances of the
    `Burger` class. We also know that we are setting the values for each type of burger
    correctly because the values are set directly in the builder classes.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the builder pattern helps us to simplify the creation of complex
    objects. It also ensures that our objects are fully created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, for our builder types, we chose to use classes (reference types).
    There really is not a huge advantage to using either a reference or value type;
    therefore, the reference type was chosen because it did not make sense to make
    multiple copies of our builder types.
  prefs: []
  type: TYPE_NORMAL
- en: For our last example of a creational pattern, we will look at the factory method
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method pattern uses factory methods to create instance of objects
    without specifying the exact class that will be created. This allows us to pick
    the exact class to create at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use the factory method pattern by creating a computer
    store class that allows us to pick a computer from multiple models. We will begin
    by creating a protocol named `Computer`. Each class that represents a different
    computer model will implement the `Computer` protocol. Here is the code for the
    `Computer` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The only method in the `Computer` protocol is a method that returns a string
    type that represents the model of the computer. Now, let''s create three concrete
    classes that implement the `Computer` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the three classes that implement the `Computer` protocol return a unique
    string type in the `getType()` method. This will identify which class was created.
    Now, let''s look at our `ComputerStore` class that will create an instance of
    one of these three classes depending on the type of computer we are looking for.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the `ComputerStore` class, we begin by creating an enum named `ComputerType`,
    which defines the types of computers that we sell. These types are `Laptop`, `Desktop`,
    and `Headless`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ComputerStore` class has one method and that is the `getModel()` method.
    This method accepts one argument, which is of the `ComputerType` types and returns
    an instance of a type that conforms to the `Computer` protocol, depending on the
    `ComputerType` enum that was passed in. Within this method, we create a `switch`
    statement that will create and return an instance of a class that confirms to
    the `Computer` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to use the `ComputerStore` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by creating an instance of the `ComputerStore` class.
    We then call the `getModel()` method to retrieve an instance of a class that conforms
    the `Computer` protocol by passing in a `ComputerType` value. The code that is
    calling the `getModel()` method does not need to know how the backend code selects
    which type of class to create; all it knows is that it should get a valid instance
    of a type that conforms to the `Computer` protocol or `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: I find myself using this pattern a lot. Anytime we have multiple types that
    conform to the same protocol, we may want to consider using the factory method
    pattern to centralize the creation of these objects; otherwise, we may find that
    we are repeating the object creation code in multiple parts of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the builder pattern, we chose to use classes to represent the different
    computer types mainly because it does not make sense to create multiple copies
    of the computer types.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key ideas about design patterns, especially the creational patterns,
    is that we take the logic about how and what to create out of our general code
    and put it into specific classes or functions. Then, when we need to make changes
    to our code in the future, the logic is embedded in a single spot and can be easily
    changed, rather than having the logic in multiple spots throughout our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural design patterns describe how classes can be combined to form larger
    structures. These larger structures can generally be easier to work with and hide
    a lot of the complexity of the individual classes. Most of the patterns in the
    structural pattern category involve connections between objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are seven well-known patterns that are part of the structural design
    pattern type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapter**: This allows classes with incompatible interfaces to work together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge**: This is used to separate the abstract elements of a class from
    the implementation so that the two can vary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: This allows us to treat a group of objects as a single object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: This lets us add or override behavior in an existing method
    of an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Façade**: This provides a simplified interface for a larger and more complex
    body of code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flyweight**: This allows us to reduce the resources needed to create and
    use a large number of similar objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: This is a class acting as an interface for another class or classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to give examples of how to use bridge, façade,
    and proxy patterns in Swift. Let's start off by looking at the bridge pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bridge pattern decouples the abstraction from the implementation so that
    they can both vary independently. The bridge pattern can also be thought of as
    a two-layer abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will show you how to use the bridge pattern by creating
    a simple universal remote class that can control multiple TV objects. We will
    begin by creating protocols for both the remote control and the TVs, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `TV` protocol defines one property and two functions. The `currentChannel`
    property is used to keep track of the current channel that the TV is on. The functions
    are `turnOn()` and `turnOff()`,which are used to turn the TV on or off.
  prefs: []
  type: TYPE_NORMAL
- en: The `RemoteControl` protocol defines one property and one initializer. The `tv`
    property holds the instance of the TV that we want to control. The initializer
    will initiate the remote with a type that conforms to the `TV` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will extend both the `TV` and `RemoteControl` protocols to add common
    functionalities for types that conform to the protocols. Keep in mind that the
    functionality added here could be overridden in the types that conform to the
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `TV` extension, we are adding a method to change the channel on the TV.
    In the `RemoteControl` extension, we are adding five methods that turn the TV
    on/off or change the channel on the TV.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to create structures that conform to the `TV` protocol.
    For this, we will define two concrete implementations of the protocol, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, we define both the `SonyTV` and `VizioTV` implementations of
    the `TV` protocol. Within these structures, we implement all of the requirements
    for the `TV` protocol. We will be using these implementations to tell the universal
    remote which TV to control. Now, let''s see how to implement the `RemoteControl`
    protocol, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Within the `MyUniversalRemote` class, we implement the required initializer
    for the `Remote` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this pattern, we would begin by creating an instance of the `TV` type
    that we wish to control. We would then use that instance to initiate our remote
    control type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The bridge pattern can be thought of as two layers of abstraction where the
    abstraction and implementations should not be bound at compile time. This allows
    us to define which objects to use at runtime. This also allows us to add more
    TVs to our `myUniversalRemote` class simply by creating new classes that implement
    the `TV` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this pattern, we implemented the types that conform to the `TV` protocol
    using structures. Structures were chosen because it is very easy to create one
    instance of a TV type and then use it to create multiple instances of the remote
    control types, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if the `VizioTV` type were implemented with a class, then the
    both `MyUniversalRemote` instances would refer to the same TV rather than different
    TVs. Therefore, even though we had two TVs, each with separate remotes, both of
    the remotes would actually on work on one of the TVs.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we want this behavior and for those times, we should use
    classes; however, in my experience, this is usually not the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the next pattern in the structural category—the façade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The façade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The façade pattern provides a simplified interface to a larger and more complex
    body of code. This allows us to make our libraries easier to use and understand
    by hiding some of the complexities. It also allows us to combine multiple API's
    into a single, easier to use API, which is what we will see in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will make a simplified travel API that combines the hotel,
    flight, and rental car APIs into a single, easy-to-use interface. We will start
    off by defining the hotel, flight, and rental car classes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In each of these APIs, we define a single static method that will return a list
    of items (hotels, flights, or rental cars) that are available for the requested
    date. We actually do not implement any logic here because we would need to define
    a data source, and I would prefer to keep the example simple to concentrate on
    how the pattern works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our `TravelFacade` class that will combine these three
    APIs into a single, easier to use API, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `TravelFacade` class, we create a single initializer that accepts
    two `NSDate` objects as the parameters. We then use those two `NSDate` objects
    to retrieve the hotels, flights, and rental cars that are available for the time
    period defined by the dates.
  prefs: []
  type: TYPE_NORMAL
- en: The façade pattern is very useful when we have a complex API structure that
    we want to simplify. It is also very useful when we have a series of multiple
    related APIs, as we saw in our example, to consolidate them in a single API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this pattern, we chose to use structures when we implemented the three booking
    types; however, which type is used (classes or structures) is really dependent
    on the individual design of the application. In the *The bridge pattern* section
    of this chapter, we were able to say that the majority of the time structures
    would be preferred; however, in this pattern, we really cannot say that either
    type is preferred the majority of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at our last structural pattern, which is the proxy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the proxy design pattern, there is one object acting as an interface for
    other objects. This wrapper class, which is the proxy, can then add functionality
    to the object, make the object available over a network, or restrict access to
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate the proxy pattern by creating a house
    class that we can add multiple floor plans to, where each floor plan represents
    a different story of the house. Let''s begin by creating a `FloorPlanProtocol`
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In `FloorPlanProtocol`, we define five properties that will represent the number
    of rooms contained in each floor plan. Now, let''s create an implementation of
    the `FloorPlanProtocol` protocol named `FloorPlan`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FloorPlan` class implements all the five properties required from `FloorPlanProtocol`
    and assigns default values to them. Next, we will create the `House` class, which
    will represent a house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Within our `House` class, we have an array of the `FloorPlanProtocols` objects
    where each floor plan will represent one story of the house. We also have one
    function named `addStory()`, which accepts an instance of an object that conforms
    to the `FloorPlanProtocol` protocol. This function will add the floor plan to
    the array of the `FloorPlanProtocols` protocols.
  prefs: []
  type: TYPE_NORMAL
- en: If we think about the logic of this class, there is one problem that we might
    encounter. The problem is that we are allowed to add as many floor plans as we
    want, which may lead to houses that are 60 or 70 stories high. This would be great
    if we were building skyscrapers, but we just want to build basic single-family
    houses. If we want to limit the number of floor plans without changing the `House`
    class (either we cannot change it or we simply do not want to), we can implement
    the proxy pattern. The following example shows how to implement the `HouseProxy`
    class, where we limit the number of floor plans we can add to the house, which
    is as follows;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin the `HouseProxy` class by creating an instance of the `House` class.
    We then create a method named `addStory()` that lets us add a new floor plan to
    the house. In the `addStory()` method, we check whether the number of stories
    in the house is less than three, and if so, we add the floor plan to the house
    and return `true`. If the number of stories is equal to or greater than three,
    then we do not add the floor plan to the house and return `false`. Let''s see
    how we use this proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In our example code, we start off by creating an instance of the `HouseProxy`
    class named `ourHouse`. We then create four instances of the `FloorPlan` class,
    each with a different number of rooms. Finally, we attempt to add each of the
    floor plans to the `ourHouse` instance. If we then run the code, we see that the
    first three instances of the `FloorPlan` class were added to the house successfully,
    but the last one wasn't because we are only allowed to add three floors.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern is very useful when we want to add some additional functionality
    or error-checking to a class, but we do not want to change the actual class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the proxy pattern, we chose to use a class to implement the pattern because
    normally, we would not want to make copies of the type we are proxying. Instead,
    we would normally want to maintain the changes made to the instance. This is kind
    of the reverse of the bridge pattern where, in my experience, the structure would
    be preferred the majority of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the behavioral design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral design patterns explain how objects interact with each other. These
    patterns describe how different objects send messages to each other to make things
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are nine well-known patterns that are part of the structural design pattern
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain of responsibility**: This is used to process a variety of requests,
    each of which may be delegated to a different handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: This creates objects that can encapsulate actions or parameters
    so that they can be invoked later or by a different component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator**: This allows us to access the elements of an object sequentially
    without exposing the underlying structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mediator**: This is used to reduce coupling between classes that communicate
    with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: This is used to capture the current state of an object and store
    it in a manner that can be restored later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: This allows an object to publish changes to its state. Other
    objects can then subscribe so that they can be notified of any changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: This is used to alter the behavior of an object when its internal
    state changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: This allows one out of a family of algorithms to be chosen at
    runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: This is a way of separating an algorithm from an object structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we are going to give examples of how to use strategy and command
    patterns in Swift. Let's start off by looking at the command pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The command design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command design pattern lets us define actions that we can execute later.
    This pattern generally encapsulates all the information needed to call or trigger
    the actions at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how to use the command pattern by creating
    a `Light` class. In this example, we will define two commands—`lightOnCommand`
    and `lightOffCommand`. We will then use the `turnOnLight()` and `turnOffLight()`
    methods to call the commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating a protocol named `Command` that all of our commands
    will need to conform to. Here is the `Command` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This protocol contains one method named `execute`, which will be used to execute
    the command. Now, let''s look at our `LightOneCommand` and `LightOffCommand` classes
    that the `Light` class will use to turn the light on and off. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RockerSwitchLightOffCommand`, `RockerSwitchLightOnCommand`, `PullSwitchLightOnCommand`,
    and `PullSwitchLightOffCommand` commands conform to the `Command` protocol by
    implementing the `execute()` method, so we will be able to use them in our `Light`
    class. Now, let''s look at how to implement the `Light` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the `Light` class, we start off by creating two variables named `lightOnCommand`
    and `lightOffCommand`, which hold instances of classes that conform to the `Command`
    protocol. We then create an initiator that lets us set both of the commands when
    we initiate the class. Finally, we create the `turnOnLight()` and `turnOffLight()`
    methods that we will use to turn the light on and off. In these methods, we call
    the appropriate command to turn the light on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would then use the `Light` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by creating an instance of the `PullSwitchLightOnCommand`
    class named `on` and an instance of the `PullSwitchLightOffCommand` class named
    `off`. We then create an instance of the `Light` class using the two commands
    that we just created and call the `turnOnLight()` and `turnOffLight()` methods
    of the `Light` instance to turn our light on and off. In the last two lines, we
    changed the `lightOnCommand` method, which was originally set to an instance of
    the `PullSwitchLightOnCommand` class to an instance of the `RockerSwitchLightOnCommand`
    class. The `light` instance will now use the `RockerSwitchLightOnCommand` class
    whenever we turn the light on. This allows us to change the functionality of the
    `Light` class during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of benefits of using the command pattern. One of the main
    benefits is that we are able to set the implementation of the commands at runtime,
    which also lets us swap the commands out with different implementations that conform
    to the `Command` protocol, as needed throughout the life of the application. Another
    advantage of the command pattern is that we encapsulate the details of the command
    implementations within the command classes themselves rather than in the container
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the command pattern, we used structures to implement our command types because
    it is very easy to create one instance of a command type and then use it to create
    multiple instances of the `Light` class. In that case, if one `Light` class changed
    anything in the command instance, it would then be reflexed in all the instances
    of the `Light` class that used that command instance. Generally, this is not the
    behavior we want; however, if that is the behavior your application needs, then
    you should use a class rather than a structure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at our last design pattern, which is the strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy pattern is pretty similar to the command pattern in the fact that
    they both allow us to decouple implementation details from our calling class and
    also allow us to switch the implementation out at runtime. The big difference
    is, the strategy pattern is intended to encapsulate algorithms. By swapping out
    an algorithm, we are expecting the object to perform the same functionality but
    in a different way. In the command pattern, when we swap out the commands, we
    are expecting the object to function differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate the strategy pattern by showing you how
    we could swap out compression strategies at runtime. Let''s begin this example
    by creating a `CompressionStrategy` protocol that each one of our compression
    classes will conform to. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This protocol defines one method named `compressFiles()` that accepts a single
    parameter, which is an array of strings that contain the paths of the files to
    compress. We will now create two structures that conform to the `CompressionStrategy`
    protocol. These classes are the `ZipCompressionStrategy` and `RarCompressionStrategy`
    classes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Both of these structures implement the `CompressionStrategy` protocol by having
    a method named `compressFiles()`, which accepts an array of strings. Within these
    methods, we simply print out the name of the compression that we are using. Normally,
    we would implement the compression logic in these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our `CompressContent` class that will be called to compress
    the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we start off by defining a variable named `strategy` that will
    contain an instance of a class that conforms to the `CompressStrategy` protocol.
    We then create an initiator that will be used to set the compression type when
    the class is initiated. Finally, we create a method named `compressFiles()` that
    accepts an array of strings that contain the paths to the list of files that we
    wish to compress. In this method, we compress the files using the compression
    strategy that is set in the strategy variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `CompressContent` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating an array of strings that contain the files we wish to compress.
    We also create an instance of both the `ZipCompressionStrategy` and `RarCompressionStrategy`
    classes. We then create an instance of the `CompressContent` class, setting the
    compression strategy to the `ZipCompressionStrategy` instance and call the `compressFiles()`
    method, which will print the `Using zip compression` message to the console. We
    then set the compression strategy to the `RarCompressionStrategy` instance and
    call the `compressFiles()` method again, which will print the `Using rar compression`
    message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern is really good for setting the algorithms to use at runtime,
    which also lets us swap the algorithms out with different implementations as needed
    by the application. Another advantage of the strategy pattern is, we encapsulate
    the details of the algorithm within the strategy classes themselves and not in
    the main implementation class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like the command pattern, we used structures to implement the strategy
    pattern because it is very easy to create one instance of a strategy type and
    then use it to create multiple instances of the `CompressContent` class. In this
    case, if anything is changed in the strategy instance, it would be reflexed in
    all of the `CompressContent` types. Generally, this is not the behavior we want;
    however, if that is the behavior your application needs, then you should use a
    class rather than a structure.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our tour of design patterns in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are solutions to software design problems that we tend to see
    over and over again in real-world application designs. These patterns are designed
    to help us create reusable and flexible code. Design patterns can also make our
    code easier to read and understand for other developers and also for ourselves
    when we look back at out code months/years later.
  prefs: []
  type: TYPE_NORMAL
- en: If we looked at the examples in the chapter carefully, we would notice that
    one of the backbones of design patterns is protocols. Almost all the design patterns
    (the singleton design pattern is an exception) use protocols to help us create
    very flexible and reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: If this was the first time that you really looked at design patterns, you probably
    noticed some similarities to strategies that you may have used in the past in
    your own code. This is expected when experienced developers are first introduced
    to design patterns. I would also encourage you to read about design patterns more
    because they will definitely help you to create more flexible and reusable code.
  prefs: []
  type: TYPE_NORMAL
