- en: Chapter 17. Adopting Design Patterns in Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章. 在Swift中采用设计模式
- en: 'Although the Gang of Four''s *Design Patterns: Elements of Reusable Object-Oriented
    Software* was first published in October 1994, it has only been in the last 6
    or 7 years that I started paying attention to design patterns. Like most experienced
    developers, when I first started reading about design patterns, I recognized a
    lot of the patterns because I had already been using them without realizing what
    they were. I would have to say that in the past 6 or 7 years since I first read
    about design patterns, I did not write a serious application without using at
    least one of the Gang of Four''s design patterns. I will tell you that I am definitely
    not a design pattern zealot, and actually, if I get into a conversation about
    design patterns, there is usually only a couple that I can name without having
    to look them up, but one thing that I do remember is the concepts of the major
    patterns and the problems they are written to solve. This way, when I encounter
    one of these problems, I can look up the appropriate pattern and apply it.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管四人帮的《设计模式：可复用面向对象软件元素》一书首次出版于1994年10月，但直到最近6或7年，我才开始关注设计模式。像大多数经验丰富的开发者一样，当我最初开始阅读有关设计模式的内容时，我认识到了很多模式，因为我已经在没有意识到它们是什么的情况下使用了它们。我必须说，自从我开始阅读有关设计模式以来，过去6或7年，我没有在不使用四人帮的至少一种设计模式的情况下编写过任何严肃的应用程序。我要告诉你，我绝对不是设计模式的狂热者，实际上，如果我陷入关于设计模式的对话，通常只有一两样我可以不用查找就能说出名字，但有一件事我记得很清楚，那就是主要模式的概念以及它们旨在解决的问题。这样，当我遇到这些问题之一时，我可以查找适当的模式并应用它。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: The difference between reference and value types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型和值类型之间的区别
- en: What design patterns are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式
- en: What types of patterns make up the creational, structural, and behavioral categories
    of design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成设计模式创建、结构和行为类别的模式类型
- en: How to implement the builder, factory method, and singleton creational patterns
    in Swift
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中实现建造者、工厂方法和单例创建模式
- en: How to implement the bridge, façade, and proxy structural patterns in Swift
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中实现桥接、外观和代理结构模式
- en: How to implement the strategy and command behavioral patterns in Swift
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中实现策略和命令行为模式
- en: Value versus reference types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: In [Chapter 5](ch05.html "Chapter 5. Classes and Structures"), *Classes and
    Structures*, we discussed the difference between value and reference types. It
    is important that we understand the basic differences between the two types, especially
    when we are architecting our code. Certain design patterns work best with reference
    types, while other work best with value types; therefore, knowing when to use
    each type is important in design patterns. With that in mind, let's review the
    difference between reference and value types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。类和结构")中，我们讨论了值类型和引用类型之间的区别。了解这两种类型的基本区别非常重要，尤其是在我们构建代码架构时。某些设计模式与引用类型配合得最好，而其他则与值类型配合得最好；因此，知道何时使用每种类型在设计模式中很重要。考虑到这一点，让我们回顾一下引用类型和值类型之间的区别。
- en: A class is a reference type. What this means is that when we pass an instance
    of a class around our code, we are passing a reference to the original instance.
    Since we are passing a reference to the original instance, any changes that are
    made to this instance are reflected back to the original instance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个引用类型。这意味着当我们传递一个类的实例在我们的代码中时，我们正在传递原始实例的引用。由于我们正在传递原始实例的引用，因此对这个实例所做的任何更改都会反映到原始实例上。
- en: 'Structures, enums, and tuples are all value types. When we pass an instance
    of a value type, we are passing a copy of the type. This means that any changes
    made to this copy is not reflected back to the original. Let''s take a look at
    the difference between a value and reference types by looking at some code. We
    will begin by creating a class named `MyClass` and a structure named `MyStruct`.
    Both of these types contain a single property named `number` that will be of the
    Int type:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体、枚举和元组都是值类型。当我们传递一个值类型的实例时，我们正在传递该类型的副本。这意味着对这个副本所做的任何更改都不会反映到原始实例上。让我们通过查看一些代码来了解值类型和引用类型之间的区别。我们将首先创建一个名为`MyClass`的类和一个名为`MyStruct`的结构体。这两种类型都包含一个名为`number`的单个属性，其类型为Int：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s create an instance of the `MyClass` class. We will also create a
    second constant of the `MyClass` type that is created from the first instance.
    We will then change the `number` property in one of the instances, and see what
    the value is in both:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`MyClass`类的实例。我们还将创建一个`MyClass`类型的第二个常量，它是由第一个实例创建的。然后我们将改变其中一个实例的`number`属性，并查看两个实例中的值：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we ran this code, we would see the following output:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会看到以下输出：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, when we changed the `number` property in one instance, it changed
    the value in both. This also means that there is only one instance of the `MyClass`
    class in memory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当我们在一个实例中改变了`number`属性时，它在两个实例中都改变了值。这也意味着在内存中只有一个`MyClass`类的实例。
- en: 'Now let''s look at this same example, but this time, we will use the `MyStruct`
    structure (value type) rather than the `MyClass` class (reference type):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个相同的例子，但这次，我们将使用`MyStruct`结构（值类型）而不是`MyClass`类（引用类型）：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we ran this code, we would see the following output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会看到以下输出：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that in this example, when we change the `number` property of one instance,
    it did not change the property in the other. Since the `myStruct2` structure was
    created with a copy of the `myStruct` structure, we now have two instances of
    the `MyStruct` structure in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，当我们改变一个实例的`number`属性时，它并没有改变另一个实例的属性。由于`myStruct2`结构是通过`myStruct`结构的副本创建的，我们现在在内存中有两个`MyStruct`结构的实例。
- en: Also notice that we defined the instances of the `MyClass` class as constants
    with the `let` keyword; however, we defined the instances of the `MyStruct` structure
    as variables with the `var` keyword.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们使用`let`关键字将`MyClass`类的实例定义为常量；然而，我们使用`var`关键字将`MyStruct`结构的实例定义为变量。
- en: When a constant refers to an instance of a reference type, we are unable to
    change the instance that the constant is referring to; however, we are able to
    change the values of the properties of that instances, as shown in the previous
    example. When a constant refers to an instance of a value type, we will not only
    be unable to change the instance that the constant is referring to, but we will
    also be unable to change any of the property values. Swift arrays and dictionaries
    are value types which is why when they are declared constants, they are immutable.
    This means, in our previous example, in order to change the values of the `number`
    properties, we needed to create the instances of the `MyStruct` structures as
    variables and not constants.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个常量引用一个引用类型的实例时，我们无法改变常量所引用的实例；然而，我们可以改变该实例的属性值，就像上一个例子中所示。当一个常量引用一个值类型的实例时，我们不仅无法改变常量所引用的实例，而且也无法改变任何属性值。Swift的数组和字典是值类型，这就是为什么当它们被声明为常量时是不可变的。这意味着，在我们的上一个例子中，为了改变`number`属性的值，我们需要将`MyStruct`结构的实例作为变量而不是常量来创建。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For some of the design patterns in this chapter, we used structures and for
    some other, we used classes. The choice to use either a structure or class for
    these examples is based on the experience of the author. For most of the patterns,
    the choice of using either a structure or a class should be based on the needs
    of the individual application. In each section, we will explain why we chose either
    a structure or a class to help you understand why it was chosen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的一些设计模式中，我们使用了结构体，而在其他一些中，我们使用了类。选择使用结构体或类来举例是基于作者的经验。对于大多数模式，选择使用结构体或类应该基于单个应用程序的需求。在每个部分中，我们将解释为什么选择结构体或类，以帮助您理解为什么做出这样的选择。
- en: What are design patterns
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是设计模式
- en: Every experienced developer has a set of informal strategies that shape how
    he/she designs and writes applications. These strategies are shaped by their past
    experiences and the obstacles that they have had to overcome in previous projects.
    Though these developers might swear by their strategies, it does not mean that
    their strategies have been fully vetted and proven. The use of these strategies
    also introduces inconsistent implementations between different developers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个经验丰富的开发者都有一套非正式的策略，这些策略塑造了他/她设计和编写应用程序的方式。这些策略是由他们过去的经验和他们在以前的项目中必须克服的障碍所塑造的。尽管这些开发者可能发誓支持他们的策略，但这并不意味着他们的策略已经完全经过检验和证明。使用这些策略也引入了不同开发者之间不一致的实现。
- en: A design pattern identifies a common software development problem and provides
    a strategy for dealing with it. Over the years, the strategies behind these design
    patterns have been proven to effectively solve the problem they are intended to
    solve.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式识别一个常见的软件开发问题，并提供了解决该问题的策略。多年来，这些设计模式背后的策略已被证明能够有效地解决它们旨在解决的问题。
- en: While there is a lot to like about design patterns, and they are extremely beneficial
    to developers and architects, they are not the solution for world hunger that
    some developers make them out to be. Sometimes in your development career, you
    will probably meet a developer or architect who thinks that design patterns are
    immutable laws. These developers usually try to force the use of design patterns
    even when they are not necessary. A good rule of thumb is to make sure that you
    have a problem to fix before you try to fix it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设计模式有很多优点，并且对开发人员和架构师来说非常有益，但它们并不是一些开发者所说的解决世界饥饿问题的方案。在你的开发生涯中，你可能会遇到一些认为设计模式是不可变法则的开发人员或架构师。这些开发者通常会试图强制使用设计模式，即使它们不是必要的。一个好的经验法则是，在尝试解决问题之前，确保你有一个问题要解决。
- en: Keep in mind that design patterns are starting points for avoiding and solving
    common programming problems. We can think of each design pattern as a recipe for
    a food dish, and just like a good recipe, we can tinker and adjust it to meet
    our particular taste, but we usually do not want to stray too far from the original
    recipe because we may mess it up.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，设计模式是避免和解决常见编程问题的起点。我们可以将每个设计模式视为一道菜品的食谱，就像一个好的食谱一样，我们可以对其进行调整以满足我们的特定口味，但我们通常不想偏离原始食谱太远，因为我们可能会把它搞砸。
- en: There are also times that we do not have a recipe for a certain dish, just like
    there are times when there isn't a design pattern to solve the problem we face.
    In these cases, we can use our knowledge of design patterns and their underlying
    philosophy to come up with an effective solution to the problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 也有时候我们没有某个菜品的食谱，就像有时候没有设计模式来解决我们面临的问题一样。在这些情况下，我们可以利用我们对设计模式和它们背后的哲学的了解，来提出一个有效的解决方案来解决问题。
- en: 'Design patterns can be broken into three categories:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式可以分为三类：
- en: '**Creational patterns**: These support the creation of objects'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型模式**：这些模式支持对象的创建'
- en: '**Structural patterns**: These are concerned with class and object compositions'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构模式**：这些模式关注类和对象的组合'
- en: '**Behavioral patterns**: These are concerned with communication between classes'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：这些模式关注类之间的通信'
- en: While the Gang of Four defined over 20 design patterns, we are only going to
    give examples of some of the most popular patterns in this chapter. Let's start
    off by looking at the creational patterns.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“四人帮”定义了超过20种设计模式，但我们将在本章中仅给出一些最流行模式的示例。让我们从创建型模式开始。
- en: Creational patterns
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型模式
- en: 'Creational patterns are design patterns that deal with how an object is created.
    These patterns create objects in a manner that is suitable for the particular
    situation. There are two basic ideas behind creational patterns. The first is
    encapsulating the knowledge of which concrete classes should be created and the
    second is hiding how the instances of these classes are created.     There are five well-known patterns that are part of the creational pattern category:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式是处理对象创建的设计模式。这些模式以适合特定情况的方式创建对象。创建型模式背后有两个基本思想。第一个是封装应该创建哪些具体类的知识，第二个是隐藏这些类的实例是如何创建的。在创建型模式类别中，有五种知名的模式：
- en: '**Abstract factory pattern**: This provides an interface for creating related
    objects without specifying the concrete class'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂模式**：提供一个接口来创建相关对象，而不指定具体的类'
- en: '**Builder pattern**: This separates the construction of a complex object from
    its representation so the same process can be used to create similar types'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者模式**：将复杂对象的构建与其表示分离，以便可以使用相同的流程创建类似类型的对象'
- en: '**Factory method pattern**: This creates objects without exposing the underlying
    logic of how the object or which type is created'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法模式**：创建对象而不暴露对象或其类型创建的底层逻辑'
- en: '**Prototype pattern**: This creates an object by cloning an existing one'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型模式**：通过克隆现有对象来创建对象'
- en: '**Singleton pattern**: This allows one and only one instance of a class for
    the lifetime of an application'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：这允许一个类在应用程序的生命周期内只有一个实例'
- en: In this chapter, we are going to show you examples of how to use the builder,
    factory method, and singleton patterns in Swift. Let's start off by looking at
    one of the most controversial and possibly overused design patterns—the singleton
    pattern.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何在 Swift 中使用构建器、工厂方法和单例模式的示例。让我们从最具有争议性且可能被过度使用的模式之一——单例模式开始。
- en: The singleton design pattern
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: The use of the singleton pattern is a fairly controversial subject among certain
    corners of the development community. One of the main reasons for this is the
    singleton pattern is probably the most overused and misused pattern. Another reason
    why this pattern is controversial is that the singleton pattern introduces a global
    state into an application, which allows the ability to change the object at any
    point within the application, thereby ignoring the scope. My personal opinion
    is, if the singleton pattern is used correctly, there is nothing wrong with using
    it; however, we do need to be careful not to misuse it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式在开发社区的一些角落里是一个相当有争议的话题。其中一个主要原因是单例模式可能是最被过度使用和误用的模式。这个模式引起争议的另一个原因是，单例模式将全局状态引入了应用程序中，这使得在应用程序的任何点上都可以更改对象，从而忽略了作用域。我个人认为，如果单例模式被正确使用，使用它是没有问题的；然而，我们确实需要小心不要误用它。
- en: The singleton pattern restricts the instantiation of a class to one instance
    for the lifetime of an application. This pattern is very effective when we need
    exactly one object to coordinate actions within our application. An example of
    a good use of a singleton is if our application communicates with a remote device
    over Bluetooth and we also want to maintain that connection throughout our application.
    While some would say that we can pass the instance of the connection class from
    one page to the next, that is essentially what a singleton is.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式限制了类在应用程序生命周期内的实例化，使其只有一个实例。当我们需要恰好一个对象来协调应用程序内的操作时，这个模式非常有效。单例的一个良好用途是，如果我们的应用程序通过蓝牙与远程设备通信，并且我们还想在整个应用程序中保持这个连接。虽然有些人可能会说我们可以从一页传递连接类的实例到另一页，但这本质上就是单例。
- en: In my opinion, the singleton pattern, in this instance, is much cleaner because
    with the singleton pattern, any page that needs the connection can get it without
    forcing every page to maintain the instance. This also allows us to maintain the
    connection without having to reconnect each time we go to another page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，在这个例子中，单例模式要干净得多，因为有了单例模式，任何需要连接的页面都可以获取它，而不必强迫每个页面都维护实例。这也允许我们在不每次切换到另一页时重新连接的情况下维护连接。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are several ways to implement the singleton pattern in Swift. The way
    that is presented here uses class constants, which were introduced in version
    1.2 of Swift.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中实现单例模式有几种方法。这里介绍的方法使用了类常量，这是在 Swift 1.2 版本中引入的。
- en: 'Let''s look at how we would implement the singleton pattern with Swift. The
    following code example shows how to create a singleton class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Swift 实现单例模式。以下代码示例展示了如何创建一个单例类：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that within the `MySingleton` class, we create a static constant
    named `sharedInstance`, which contains an instance of the `MySingleton` class.
    A static constant can be called without having to instantiate the class. Since
    we declared the `sharedInstance` constant static, only one instance will exist
    throughout the life cycle of the application, thereby creating the singleton pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在 `MySingleton` 类中，我们创建了一个名为 `sharedInstance` 的静态常量，它包含了一个 `MySingleton`
    类的实例。静态常量可以在不实例化类的情况下被调用。由于我们声明了 `sharedInstance` 常量是静态的，因此在整个应用程序的生命周期中只有一个实例存在，从而创建了单例模式。
- en: We also create a private initiator that will restrict other code from creating
    another instance of the `MySingleton` class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个私有的初始化器，这将限制其他代码创建 `MySingleton` 类的另一个实例。
- en: 'Now, let''s see how this pattern works. The `MySingleton` pattern has another
    property named `number`, which is of the Int type. We will monitor how this property
    changes as we use the `sharedInstance` property to create multiple variables of
    the `MySingleton` type, as shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个模式是如何工作的。`MySingleton` 模式还有一个名为 `number` 的属性，其类型为 Int。我们将监控这个属性在我们使用
    `sharedInstance` 属性创建多个 `MySingleton` 类型的变量时的变化，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we use the `sharedInstance` property to create three variables
    of the `MySingleton` type. We initially set the `number` property of the second
    `MySingleton` variable (`singleB`) to the number `2`. When we print out the value
    of the `number` property for `singleA`, `singleB`, and `singleC`, we see that
    the `number` property for all the three equals to `2`. We then change the value
    of the `number` property of the third `MySingleton` variable (`singleC`) to the
    number `3`. When we print out the value of the `number` property again, we see
    that this time, all the three now have the value of `3`. Therefore, when we change
    the value of the `number` property in any of the instances, it changes the values
    for all the three because each variable is pointed to the same instance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`sharedInstance`属性创建了三个`MySingleton`类型的变量。我们最初将第二个`MySingleton`变量（`singleB`）的`number`属性设置为数字`2`。当我们打印出`singleA`、`singleB`和`singleC`的`number`属性值时，我们看到这三个的`number`属性都等于`2`。然后我们改变第三个`MySingleton`变量（`singleC`）的`number`属性值为数字`3`。当我们再次打印出`number`属性值时，我们看到这次，所有三个的值现在都是`3`。因此，当我们改变任何实例的`number`属性值时，它将改变所有三个的值，因为每个变量都指向同一个实例。
- en: The singleton pattern can be very useful when we need to maintain the state
    of an object throughout our application, but be careful not to overuse it. The
    singleton pattern should not be used unless there is a specific requirement (requirement
    is the keyword here) for having one, and only one, instance of our class throughout
    the life cycle of our application. If we are using the singleton pattern simply
    for convenience, then we are misusing it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在整个应用程序中维护一个对象的状态时，单例模式非常有用，但请注意不要过度使用它。单例模式只有在有具体要求（关键字是需求）在整个应用程序的生命周期中只有一个实例时才应该使用。如果我们仅仅为了方便而使用单例模式，那么我们就是在误用它。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the singleton pattern, we created the `MySingleton` type as a class (reference
    type) because we wanted to ensure that only one instance of the type existed throughout
    our application. If we created the `MySingleton` type as a structure (value type),
    we would run the risk of the existence of multiple instances because structures
    are value type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单例模式，我们创建了`MySingleton`类型作为一个类（引用类型），因为我们希望确保在整个应用程序中只存在该类型的一个实例。如果我们把`MySingleton`类型作为一个结构（值类型），我们就会面临存在多个实例的风险，因为结构是值类型。
- en: Now, let's look at the builder design pattern.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构建者设计模式。
- en: The builder design pattern
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建者设计模式
- en: The builder pattern helps us in the creation of complex objects and enforces
    the process of how these objects are created. With this pattern, we generally
    separate the creation logic from the complex class and put it in another class.
    This allows us to use the same construction process to create different representations
    of the class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式帮助我们创建复杂对象，并强制执行这些对象的创建过程。使用这个模式，我们通常将创建逻辑从复杂的类中分离出来，并将其放入另一个类中。这允许我们使用相同的构建过程来创建类的不同表示形式。
- en: In this section, we will see how to use the builder pattern by creating a `Burger`
    class and then use various different burger builders to create different types
    of burgers. Before we see how to use the builder pattern, let's look at how to
    create a `Burger` class without the builder pattern and the problems we'll run
    into.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个`Burger`类并使用各种不同的汉堡构建者来创建不同类型的汉堡来了解如何使用构建者模式。在我们了解如何使用构建者模式之前，让我们看看如何在不使用构建者模式的情况下创建一个`Burger`类以及我们可能会遇到的问题。
- en: 'The following code creates a class named `BurgerOld` and does not use the builder
    pattern:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`BurgerOld`的类，并且没有使用构建者模式：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `BurgerOld` class, we have several properties that define what is on
    the burger and also the name of the burger. Since we need to know which items
    are on the burgers and which aren''t, when we create an instance of the `BurgerOld`
    class, the initializer requires us to define each item. This can lead to some
    complex initializations throughout our application, not to mention that if we
    had more than one standard burger (bacon cheeseburger, cheeseburger, hamburger,
    and so on), we would need to make sure that we define each correctly. Let''s see
    how to create the instances of the `BurgerOld` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BurgerOld`类中，有几个属性定义了汉堡上有什么以及汉堡的名称。由于我们需要知道哪些项目在汉堡上，哪些不在，当我们创建`BurgerOld`类的实例时，初始化器要求我们定义每个项目。这可能导致我们应用程序中的一些复杂初始化，更不用说如果我们有多个标准汉堡（培根芝士汉堡、芝士汉堡、汉堡等），我们需要确保我们正确地定义了每个汉堡。让我们看看如何创建`BurgerOld`类的实例：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s look at a better way to do this. We will begin by creating a `BurgerBuilder`
    protocol that will have the following code in it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看更好的做法。我们将首先创建一个`BurgerBuilder`协议，其中将包含以下代码：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This protocol simply defines the nine properties that will be required for
    any class that implements this protocol. Now, let''s create two classes that implement
    this protocol—the `HamburgerBuilder` and `CheeseBurgerBuilder` classes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议简单地定义了任何实现此协议的类所需的九个属性。现在，让我们创建两个实现此协议的类——`HamburgerBuilder`和`CheeseBurgerBuilder`类：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In both the `HamburgerBuilder` and `CheeseBurgerBuilder` classes, all we are
    doing is defining the values for each of the required properties. In more complex
    classes, we might need to initialize other objects that are required by this instance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HamburgerBuilder`和`CheeseBurgerBuilder`类中，我们所做的只是为每个必需的属性定义值。在更复杂的类中，我们可能需要初始化由该实例需要的其他对象。
- en: 'Now, let''s look at our `Burger` class that will use implementations of the
    `BugerBuilder` protocol to create instances of itself. Let''s take a look at the
    following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`Burger`类，它将使用`BugerBuilder`协议的实现来创建自身的实例。让我们看看以下代码：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The difference between this `Burger` class and the `BurgerOld` class, shown
    earlier in this section, is the initializer. In the previous `BurgerOld` class,
    the initializer took nine arguments—one for each constant defined in the class.
    In the new `Burger` class, the initializer takes one argument, which is an instance
    of a class that conforms to the `BurgerBuilder` protocol. This new initializer
    allows us to create instances of the `Burger` class like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与本节前面展示的`BurgerOld`类相比，这个`Burger`类的主要区别在于初始化器。在先前的`BurgerOld`类中，初始化器接受九个参数——每个类中定义的一个常量。在新的`Burger`类中，初始化器接受一个参数，即符合`BurgerBuilder`协议的类的实例。这个新的初始化器允许我们像这样创建`Burger`类的实例：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we compare how we created instances of the new `Burger` class to the earlier
    `BurgerOld` class, we can see that it is much easier to create instances of the
    `Burger` class. We also know that we are setting the values for each type of burger
    correctly because the values are set directly in the builder classes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将创建新`Burger`类实例的方式与早期的`BurgerOld`类进行比较，我们可以看到创建`Burger`类的实例要容易得多。我们还知道我们为每种汉堡设置了正确的值，因为这些值是在构建类中直接设置的。
- en: As we can see, the builder pattern helps us to simplify the creation of complex
    objects. It also ensures that our objects are fully created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，建造者模式帮助我们简化了复杂对象的创建。它还确保我们的对象被完全创建。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, for our builder types, we chose to use classes (reference types).
    There really is not a huge advantage to using either a reference or value type;
    therefore, the reference type was chosen because it did not make sense to make
    multiple copies of our builder types.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对于我们的构建类型，我们选择使用类（引用类型）。实际上，使用引用类型或值类型并没有太大的优势；因此，选择了引用类型，因为它没有理由复制我们的构建类型。
- en: For our last example of a creational pattern, we will look at the factory method
    pattern.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后一个创建型模式的例子中，我们将看看工厂方法模式。
- en: The factory method pattern
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The factory method pattern uses factory methods to create instance of objects
    without specifying the exact class that will be created. This allows us to pick
    the exact class to create at runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式使用工厂方法来创建对象的实例，而不指定将要创建的确切类。这允许我们在运行时选择要创建的确切类。
- en: 'Let''s look at how to use the factory method pattern by creating a computer
    store class that allows us to pick a computer from multiple models. We will begin
    by creating a protocol named `Computer`. Each class that represents a different
    computer model will implement the `Computer` protocol. Here is the code for the
    `Computer` protocol:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个允许我们从多个型号中选择计算机的计算机商店类来查看如何使用工厂方法模式。我们将首先创建一个名为`Computer`的协议。每个代表不同计算机模型的类都将实现`Computer`协议。以下是`Computer`协议的代码：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The only method in the `Computer` protocol is a method that returns a string
    type that represents the model of the computer. Now, let''s create three concrete
    classes that implement the `Computer` protocol:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Computer`协议中只有一个方法，它返回一个表示计算机型号的字符串类型。现在，让我们创建三个具体类来实现`Computer`协议：'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each of the three classes that implement the `Computer` protocol return a unique
    string type in the `getType()` method. This will identify which class was created.
    Now, let''s look at our `ComputerStore` class that will create an instance of
    one of these three classes depending on the type of computer we are looking for.
    Let''s take a look at the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Computer`协议的三个类中的每一个都在`getType()`方法中返回一个独特的字符串类型。这将标识创建了哪个类。现在，让我们看看我们的`ComputerStore`类，它将根据我们寻找的计算机类型创建这三个类中的一个实例。让我们看看以下代码：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `ComputerStore` class, we begin by creating an enum named `ComputerType`,
    which defines the types of computers that we sell. These types are `Laptop`, `Desktop`,
    and `Headless`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ComputerStore`类中，我们首先创建一个名为`ComputerType`的枚举，它定义了我们销售的计算机类型。这些类型是`Laptop`、`Desktop`和`Headless`。
- en: The `ComputerStore` class has one method and that is the `getModel()` method.
    This method accepts one argument, which is of the `ComputerType` types and returns
    an instance of a type that conforms to the `Computer` protocol, depending on the
    `ComputerType` enum that was passed in. Within this method, we create a `switch`
    statement that will create and return an instance of a class that confirms to
    the `Computer` protocol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputerStore`类有一个方法，那就是`getModel()`方法。该方法接受一个参数，该参数是`ComputerType`类型，并返回一个符合`Computer`协议的类型的实例，具体取决于传入的`ComputerType`枚举。在这个方法中，我们创建了一个`switch`语句，该语句将创建并返回一个符合`Computer`协议的类的实例。'
- en: 'Now, let''s look at how to use the `ComputerStore` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`ComputerStore`类：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we begin by creating an instance of the `ComputerStore` class.
    We then call the `getModel()` method to retrieve an instance of a class that conforms
    the `Computer` protocol by passing in a `ComputerType` value. The code that is
    calling the `getModel()` method does not need to know how the backend code selects
    which type of class to create; all it knows is that it should get a valid instance
    of a type that conforms to the `Computer` protocol or `nil`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建`ComputerStore`类的一个实例。然后，我们调用`getModel()`方法，通过传递一个`ComputerType`值来检索符合`Computer`协议的类的实例。调用`getModel()`方法的代码不需要知道后端代码如何选择要创建哪种类型的类；它只知道它应该得到一个符合`Computer`协议或`nil`的有效实例。
- en: I find myself using this pattern a lot. Anytime we have multiple types that
    conform to the same protocol, we may want to consider using the factory method
    pattern to centralize the creation of these objects; otherwise, we may find that
    we are repeating the object creation code in multiple parts of our application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现自己经常使用这个模式。每当有多个类型符合相同的协议时，我们可能需要考虑使用工厂方法模式来集中创建这些对象；否则，我们可能会发现我们在应用程序的多个部分中重复了对象创建代码。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like the builder pattern, we chose to use classes to represent the different
    computer types mainly because it does not make sense to create multiple copies
    of the computer types.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建者模式类似，我们选择使用类来表示不同的计算机类型，主要是因为创建多个计算机类型的副本没有意义。
- en: One of the key ideas about design patterns, especially the creational patterns,
    is that we take the logic about how and what to create out of our general code
    and put it into specific classes or functions. Then, when we need to make changes
    to our code in the future, the logic is embedded in a single spot and can be easily
    changed, rather than having the logic in multiple spots throughout our code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设计模式，尤其是创建模式的关键思想之一是，我们将有关如何以及创建什么的逻辑从我们的通用代码中提取出来，并将其放入特定的类或函数中。然后，当我们未来需要修改我们的代码时，逻辑嵌入在单个位置，可以轻松更改，而不是在代码的多个位置中都有逻辑。
- en: Now, let's look at the structural design patterns.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看结构化设计模式。
- en: Structural design patterns
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构型设计模式
- en: Structural design patterns describe how classes can be combined to form larger
    structures. These larger structures can generally be easier to work with and hide
    a lot of the complexity of the individual classes. Most of the patterns in the
    structural pattern category involve connections between objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型设计模式描述了如何将类组合成更大的结构。这些更大的结构通常更容易处理，并隐藏了大量单个类的复杂性。结构型模式类别中的大多数模式都涉及对象之间的连接。
- en: 'There are seven well-known patterns that are part of the structural design
    pattern type:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有七个著名的模式属于结构型设计模式类型：
- en: '**Adapter**: This allows classes with incompatible interfaces to work together'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器（Adapter）**：这允许具有不兼容接口的类一起工作'
- en: '**Bridge**: This is used to separate the abstract elements of a class from
    the implementation so that the two can vary'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接（Bridge）**：这用于将类的抽象元素与实现分离，以便两者可以独立变化'
- en: '**Composite**: This allows us to treat a group of objects as a single object'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合（Composite）**：这允许我们将一组对象视为单个对象'
- en: '**Decorator**: This lets us add or override behavior in an existing method
    of an object'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器（Decorator）**：这让我们可以在现有对象的方法中添加或覆盖行为'
- en: '**Façade**: This provides a simplified interface for a larger and more complex
    body of code'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观（Façade）**：这为更大的更复杂的代码库提供了一个简化的接口'
- en: '**Flyweight**: This allows us to reduce the resources needed to create and
    use a large number of similar objects'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元（Flyweight）**：这允许我们减少创建和使用大量相似对象所需的资源'
- en: '**Proxy**: This is a class acting as an interface for another class or classes'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理（Proxy）**：这是一个充当其他类或类的接口的类'
- en: In this chapter, we are going to give examples of how to use bridge, façade,
    and proxy patterns in Swift. Let's start off by looking at the bridge pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将给出如何在 Swift 中使用桥接、外观和代理模式的示例。让我们首先看看桥接模式。
- en: The bridge pattern
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接模式
- en: The bridge pattern decouples the abstraction from the implementation so that
    they can both vary independently. The bridge pattern can also be thought of as
    a two-layer abstraction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式将抽象与实现解耦，以便它们可以独立变化。桥接模式也可以被视为一种双层抽象。
- en: 'In this section, we will show you how to use the bridge pattern by creating
    a simple universal remote class that can control multiple TV objects. We will
    begin by creating protocols for both the remote control and the TVs, as shown
    in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个简单的通用遥控器类来展示如何使用桥接模式，该类可以控制多个电视对象。我们将首先创建遥控器和电视的协议，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `TV` protocol defines one property and two functions. The `currentChannel`
    property is used to keep track of the current channel that the TV is on. The functions
    are `turnOn()` and `turnOff()`,which are used to turn the TV on or off.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`TV` 协议定义了一个属性和两个函数。`currentChannel` 属性用于跟踪电视当前所在的频道。函数 `turnOn()` 和 `turnOff()`
    用于打开或关闭电视。'
- en: The `RemoteControl` protocol defines one property and one initializer. The `tv`
    property holds the instance of the TV that we want to control. The initializer
    will initiate the remote with a type that conforms to the `TV` protocol.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoteControl` 协议定义了一个属性和一个初始化器。`tv` 属性持有我们想要控制的电视实例。初始化器将使用符合 `TV` 协议的类型启动遥控器。'
- en: 'Now we will extend both the `TV` and `RemoteControl` protocols to add common
    functionalities for types that conform to the protocols. Keep in mind that the
    functionality added here could be overridden in the types that conform to the
    protocol:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将扩展 `TV` 和 `RemoteControl` 协议，为符合协议的类型添加常用功能。请注意，这里添加的功能可以在符合协议的类型中重写：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `TV` extension, we are adding a method to change the channel on the TV.
    In the `RemoteControl` extension, we are adding five methods that turn the TV
    on/off or change the channel on the TV.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TV` 扩展中，我们添加了一个方法来更改电视的频道。在 `RemoteControl` 扩展中，我们添加了五个方法，这些方法可以打开/关闭电视或更改电视的频道。
- en: 'Now, let''s look at how to create structures that conform to the `TV` protocol.
    For this, we will define two concrete implementations of the protocol, which are
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建符合 `TV` 协议的结构。为此，我们将定义两个协议的具体实现，如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this code, we define both the `SonyTV` and `VizioTV` implementations of
    the `TV` protocol. Within these structures, we implement all of the requirements
    for the `TV` protocol. We will be using these implementations to tell the universal
    remote which TV to control. Now, let''s see how to implement the `RemoteControl`
    protocol, which is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们定义了`SonyTV`和`VizioTV`对`TV`协议的实现。在这些结构体中，我们实现了`TV`协议的所有要求。我们将使用这些实现来告诉通用遥控器控制哪个电视。现在，让我们看看如何实现`RemoteControl`协议，如下所示：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Within the `MyUniversalRemote` class, we implement the required initializer
    for the `Remote` protocol.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyUniversalRemote`类中，我们实现了`Remote`协议所需的初始化器。
- en: 'To use this pattern, we would begin by creating an instance of the `TV` type
    that we wish to control. We would then use that instance to initiate our remote
    control type, as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模式，我们首先创建一个我们想要控制的`TV`类型的实例。然后，我们会使用该实例来启动我们的遥控器类型，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The bridge pattern can be thought of as two layers of abstraction where the
    abstraction and implementations should not be bound at compile time. This allows
    us to define which objects to use at runtime. This also allows us to add more
    TVs to our `myUniversalRemote` class simply by creating new classes that implement
    the `TV` protocol.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式可以看作是两层抽象，其中抽象和实现不应该在编译时绑定。这允许我们在运行时定义要使用哪些对象。这也允许我们通过创建实现`TV`协议的新类来简单地给我们的`myUniversalRemote`类添加更多的电视。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For this pattern, we implemented the types that conform to the `TV` protocol
    using structures. Structures were chosen because it is very easy to create one
    instance of a TV type and then use it to create multiple instances of the remote
    control types, as shown in the following example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，我们使用结构体实现了符合`TV`协议的类型。选择结构体是因为创建一个`TV`类型的实例非常容易，然后可以使用它来创建多个遥控器类型的实例，如下面的示例所示：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, if the `VizioTV` type were implemented with a class, then the
    both `MyUniversalRemote` instances would refer to the same TV rather than different
    TVs. Therefore, even though we had two TVs, each with separate remotes, both of
    the remotes would actually on work on one of the TVs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`VizioTV`类型是用类实现的，那么两个`MyUniversalRemote`实例将引用同一个电视而不是不同的电视。因此，尽管我们有两个电视，每个电视都有单独的遥控器，但这两个遥控器实际上都在操作同一个电视。
- en: There are times when we want this behavior and for those times, we should use
    classes; however, in my experience, this is usually not the desired behavior.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想要这种行为，对于那些时候，我们应该使用类；然而，根据我的经验，这通常不是我们想要的行为。
- en: Now, let's look at the next pattern in the structural category—the façade pattern.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看结构类别中的下一个模式——外观模式。
- en: The façade pattern
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观模式
- en: The façade pattern provides a simplified interface to a larger and more complex
    body of code. This allows us to make our libraries easier to use and understand
    by hiding some of the complexities. It also allows us to combine multiple API's
    into a single, easier to use API, which is what we will see in our example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式提供了一个简化的大规模和更复杂代码库的接口。这允许我们通过隐藏一些复杂性来使我们的库更容易使用和理解。它还允许我们将多个API组合成一个单一、更易于使用的API，这正是我们将在示例中看到的。
- en: 'In this example, we will make a simplified travel API that combines the hotel,
    flight, and rental car APIs into a single, easy-to-use interface. We will start
    off by defining the hotel, flight, and rental car classes, which are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个简化的旅行API，将酒店、航班和租车API组合成一个单一、易于使用的接口。我们将从定义酒店、航班和租车类开始，如下所示：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In each of these APIs, we define a single static method that will return a list
    of items (hotels, flights, or rental cars) that are available for the requested
    date. We actually do not implement any logic here because we would need to define
    a data source, and I would prefer to keep the example simple to concentrate on
    how the pattern works.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些API中的每一个，我们定义一个单一的静态方法，该方法将返回一个列表，其中包含（酒店、航班或租车）在请求日期可用的项目。实际上，我们在这里没有实现任何逻辑，因为我们需要定义一个数据源，而我更喜欢保持示例简单，以便集中精力了解模式的工作原理。
- en: 'Now, let''s look at our `TravelFacade` class that will combine these three
    APIs into a single, easier to use API, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`TravelFacade`类，它将这三个API组合成一个单一、更易于使用的API，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inside the `TravelFacade` class, we create a single initializer that accepts
    two `NSDate` objects as the parameters. We then use those two `NSDate` objects
    to retrieve the hotels, flights, and rental cars that are available for the time
    period defined by the dates.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TravelFacade` 类内部，我们创建了一个单例初始化器，它接受两个 `NSDate` 对象作为参数。然后我们使用这两个 `NSDate`
    对象来检索在由日期定义的时间段内可用的酒店、航班和租赁汽车。
- en: The façade pattern is very useful when we have a complex API structure that
    we want to simplify. It is also very useful when we have a series of multiple
    related APIs, as we saw in our example, to consolidate them in a single API.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个复杂的 API 结构想要简化时，外观模式非常有用。它同样非常有用，当我们有一系列多个相关的 API，就像我们在示例中看到的那样，将它们合并到一个
    API 中。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this pattern, we chose to use structures when we implemented the three booking
    types; however, which type is used (classes or structures) is really dependent
    on the individual design of the application. In the *The bridge pattern* section
    of this chapter, we were able to say that the majority of the time structures
    would be preferred; however, in this pattern, we really cannot say that either
    type is preferred the majority of the time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，我们在实现三种预订类型时选择了使用结构体；然而，使用哪种类型（类或结构体）实际上取决于应用程序的个体设计。在本章的 *桥接模式* 部分，我们能够说在大多数情况下结构体会被优先选择；然而，在这个模式中，我们真的不能说哪种类型在大多数情况下会被优先选择。
- en: Now, let's look at our last structural pattern, which is the proxy design pattern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的最后一个结构化模式，即代理设计模式。
- en: The proxy design pattern
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理设计模式
- en: In the proxy design pattern, there is one object acting as an interface for
    other objects. This wrapper class, which is the proxy, can then add functionality
    to the object, make the object available over a network, or restrict access to
    the object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理设计模式中，有一个对象充当其他对象的接口。这个包装类，即代理，可以给对象添加功能，使对象可以通过网络访问，或者限制对对象的访问。
- en: 'In this section, we will demonstrate the proxy pattern by creating a house
    class that we can add multiple floor plans to, where each floor plan represents
    a different story of the house. Let''s begin by creating a `FloorPlanProtocol`
    protocol:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个可以添加多个楼层平面图（每个楼层平面图代表房子的不同楼层）的房屋类来演示代理模式。让我们首先创建一个 `FloorPlanProtocol`
    协议：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `FloorPlanProtocol`, we define five properties that will represent the number
    of rooms contained in each floor plan. Now, let''s create an implementation of
    the `FloorPlanProtocol` protocol named `FloorPlan`, which is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FloorPlanProtocol` 中，我们定义了五个属性，这些属性将代表每个楼层平面图中包含的房间数量。现在，让我们创建一个名为 `FloorPlan`
    的 `FloorPlanProtocol` 协议的实现，如下所示：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `FloorPlan` class implements all the five properties required from `FloorPlanProtocol`
    and assigns default values to them. Next, we will create the `House` class, which
    will represent a house:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloorPlan` 类实现了从 `FloorPlanProtocol` 所需的所有五个属性，并为它们分配了默认值。接下来，我们将创建一个名为 `House`
    的类，它将代表一栋房子：'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Within our `House` class, we have an array of the `FloorPlanProtocols` objects
    where each floor plan will represent one story of the house. We also have one
    function named `addStory()`, which accepts an instance of an object that conforms
    to the `FloorPlanProtocol` protocol. This function will add the floor plan to
    the array of the `FloorPlanProtocols` protocols.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `House` 类中，我们有一个 `FloorPlanProtocols` 对象的数组，其中每个楼层平面图将代表房子的一个楼层。我们还有一个名为
    `addStory()` 的函数，它接受一个符合 `FloorPlanProtocol` 协议的对象实例。这个函数将楼层平面图添加到 `FloorPlanProtocols`
    协议的数组中。
- en: If we think about the logic of this class, there is one problem that we might
    encounter. The problem is that we are allowed to add as many floor plans as we
    want, which may lead to houses that are 60 or 70 stories high. This would be great
    if we were building skyscrapers, but we just want to build basic single-family
    houses. If we want to limit the number of floor plans without changing the `House`
    class (either we cannot change it or we simply do not want to), we can implement
    the proxy pattern. The following example shows how to implement the `HouseProxy`
    class, where we limit the number of floor plans we can add to the house, which
    is as follows;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑这个类的逻辑，可能会遇到一个问题。问题是我们可以添加任意多的楼层平面图，这可能会导致房子有 60 或 70 层高。如果我们是在建造摩天大楼，那将很棒，但我们只是想建造基本的单户家庭住宅。如果我们想限制楼层平面图的数量而不改变
    `House` 类（我们无法改变它，或者我们只是不想改变它），我们可以实现代理模式。以下示例展示了如何实现 `HouseProxy` 类，其中我们限制了可以添加到房子中的楼层平面图数量，如下所示；
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We begin the `HouseProxy` class by creating an instance of the `House` class.
    We then create a method named `addStory()` that lets us add a new floor plan to
    the house. In the `addStory()` method, we check whether the number of stories
    in the house is less than three, and if so, we add the floor plan to the house
    and return `true`. If the number of stories is equal to or greater than three,
    then we do not add the floor plan to the house and return `false`. Let''s see
    how we use this proxy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建`HouseProxy`类的一个实例开始，然后创建一个名为`addStory()`的方法，允许我们向房子添加一个新的楼层平面图。在`addStory()`方法中，我们检查房子的楼层数是否少于三，如果是这样，我们就将楼层平面图添加到房子中并返回`true`。如果楼层数等于或大于三，则我们不将楼层平面图添加到房子中并返回`false`。让我们看看我们如何使用这个代理：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our example code, we start off by creating an instance of the `HouseProxy`
    class named `ourHouse`. We then create four instances of the `FloorPlan` class,
    each with a different number of rooms. Finally, we attempt to add each of the
    floor plans to the `ourHouse` instance. If we then run the code, we see that the
    first three instances of the `FloorPlan` class were added to the house successfully,
    but the last one wasn't because we are only allowed to add three floors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们首先创建了一个名为`ourHouse`的`HouseProxy`类实例。然后，我们创建了四个`FloorPlan`类实例，每个实例都有不同数量的房间。最后，我们尝试将每个楼层平面图添加到`ourHouse`实例中。如果我们运行代码，我们会看到前三个`FloorPlan`类实例成功添加到了房子中，但最后一个没有添加，因为我们只能添加三层楼。
- en: The proxy pattern is very useful when we want to add some additional functionality
    or error-checking to a class, but we do not want to change the actual class itself.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要向一个类添加一些额外的功能或错误检查，但又不想改变实际的类本身时，代理模式非常有用。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the proxy pattern, we chose to use a class to implement the pattern because
    normally, we would not want to make copies of the type we are proxying. Instead,
    we would normally want to maintain the changes made to the instance. This is kind
    of the reverse of the bridge pattern where, in my experience, the structure would
    be preferred the majority of the time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代理模式，我们选择使用一个类来实现这个模式，因为通常我们不会想要复制我们代理的类型。相反，我们通常希望保持对实例所做的更改。这在某种程度上是桥接模式的反义词，在我的经验中，结构在大多数情况下会被优先考虑。
- en: Now, let's look at the behavioral design patterns.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看行为设计模式。
- en: Behavioral design patterns
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: Behavioral design patterns explain how objects interact with each other. These
    patterns describe how different objects send messages to each other to make things
    happen.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式解释了对象之间如何交互。这些模式描述了不同的对象如何发送消息给彼此以使事情发生。
- en: 'There are nine well-known patterns that are part of the structural design pattern
    type:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有九种众所周知的设计模式属于结构设计模式类型：
- en: '**Chain of responsibility**: This is used to process a variety of requests,
    each of which may be delegated to a different handler.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任链**：这个用于处理各种请求，每个请求都可能被委派给不同的处理者。'
- en: '**Command**: This creates objects that can encapsulate actions or parameters
    so that they can be invoked later or by a different component.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：这创建可以封装动作或参数的对象，以便稍后或由不同的组件调用。'
- en: '**Iterator**: This allows us to access the elements of an object sequentially
    without exposing the underlying structure.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：这允许我们按顺序访问对象中的元素，而不暴露底层结构。'
- en: '**Mediator**: This is used to reduce coupling between classes that communicate
    with each other.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中介者**：这个用于减少相互通信的类之间的耦合。'
- en: '**Memento**: This is used to capture the current state of an object and store
    it in a manner that can be restored later.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：这个用于捕获对象的当前状态，并以可以稍后恢复的方式存储它。'
- en: '**Observer**: This allows an object to publish changes to its state. Other
    objects can then subscribe so that they can be notified of any changes.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：这允许一个对象发布其状态的变化。其他对象可以订阅，以便在发生任何变化时得到通知。'
- en: '**State**: This is used to alter the behavior of an object when its internal
    state changes.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：这个用于在对象的内部状态改变时改变对象的行为。'
- en: '**Strategy**: This allows one out of a family of algorithms to be chosen at
    runtime.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：这允许在运行时从一组算法中选择一个。'
- en: '**Visitor**: This is a way of separating an algorithm from an object structure.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者**：这是一种将算法与对象结构分离的方法。'
- en: In this section, we are going to give examples of how to use strategy and command
    patterns in Swift. Let's start off by looking at the command pattern.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将给出如何在 Swift 中使用策略和命令模式的示例。让我们首先看看命令模式。
- en: The command design pattern
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: The command design pattern lets us define actions that we can execute later.
    This pattern generally encapsulates all the information needed to call or trigger
    the actions at a later time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式允许我们定义可以在以后执行的操作。此模式通常封装了在以后时间调用或触发操作所需的所有信息。
- en: In this section, we will demonstrate how to use the command pattern by creating
    a `Light` class. In this example, we will define two commands—`lightOnCommand`
    and `lightOffCommand`. We will then use the `turnOnLight()` and `turnOffLight()`
    methods to call the commands.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个 `Light` 类来演示如何使用命令模式。在这个例子中，我们将定义两个命令——`lightOnCommand` 和 `lightOffCommand`。然后我们将使用
    `turnOnLight()` 和 `turnOffLight()` 方法来调用这些命令。
- en: 'We will begin by creating a protocol named `Command` that all of our commands
    will need to conform to. Here is the `Command` protocol:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为 `Command` 的协议，所有我们的命令都需要遵守。以下是 `Command` 协议：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This protocol contains one method named `execute`, which will be used to execute
    the command. Now, let''s look at our `LightOneCommand` and `LightOffCommand` classes
    that the `Light` class will use to turn the light on and off. They are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议包含一个名为 `execute` 的方法，它将用于执行命令。现在，让我们看看 `Light` 类将用于打开和关闭灯光的 `LightOneCommand`
    和 `LightOffCommand` 类。它们如下所示：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `RockerSwitchLightOffCommand`, `RockerSwitchLightOnCommand`, `PullSwitchLightOnCommand`,
    and `PullSwitchLightOffCommand` commands conform to the `Command` protocol by
    implementing the `execute()` method, so we will be able to use them in our `Light`
    class. Now, let''s look at how to implement the `Light` class:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`RockerSwitchLightOffCommand`、`RockerSwitchLightOnCommand`、`PullSwitchLightOnCommand`
    和 `PullSwitchLightOffCommand` 命令通过实现 `execute()` 方法符合 `Command` 协议，因此我们可以在我们的
    `Light` 类中使用它们。现在，让我们看看如何实现 `Light` 类：'
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `Light` class, we start off by creating two variables named `lightOnCommand`
    and `lightOffCommand`, which hold instances of classes that conform to the `Command`
    protocol. We then create an initiator that lets us set both of the commands when
    we initiate the class. Finally, we create the `turnOnLight()` and `turnOffLight()`
    methods that we will use to turn the light on and off. In these methods, we call
    the appropriate command to turn the light on or off.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Light` 类中，我们首先创建两个名为 `lightOnCommand` 和 `lightOffCommand` 的变量，它们持有符合 `Command`
    协议的类的实例。然后我们创建一个初始化器，它允许我们在初始化类时设置这两个命令。最后，我们创建 `turnOnLight()` 和 `turnOffLight()`
    方法，我们将使用这些方法来打开和关闭灯光。在这些方法中，我们调用适当的命令来打开或关闭灯光。
- en: 'We would then use the `Light` class like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样使用 `Light` 类：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we begin by creating an instance of the `PullSwitchLightOnCommand`
    class named `on` and an instance of the `PullSwitchLightOffCommand` class named
    `off`. We then create an instance of the `Light` class using the two commands
    that we just created and call the `turnOnLight()` and `turnOffLight()` methods
    of the `Light` instance to turn our light on and off. In the last two lines, we
    changed the `lightOnCommand` method, which was originally set to an instance of
    the `PullSwitchLightOnCommand` class to an instance of the `RockerSwitchLightOnCommand`
    class. The `light` instance will now use the `RockerSwitchLightOnCommand` class
    whenever we turn the light on. This allows us to change the functionality of the
    `Light` class during runtime.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建了一个名为 `on` 的 `PullSwitchLightOnCommand` 类的实例和一个名为 `off` 的 `PullSwitchLightOffCommand`
    类的实例。然后我们使用我们刚刚创建的两个命令创建了一个 `Light` 类的实例，并调用 `Light` 实例的 `turnOnLight()` 和 `turnOffLight()`
    方法来打开和关闭我们的灯光。在最后两行中，我们将 `lightOnCommand` 方法从最初设置为 `PullSwitchLightOnCommand`
    类的实例更改为 `RockerSwitchLightOnCommand` 类的实例。当我们将灯光打开时，`light` 实例将使用 `RockerSwitchLightOnCommand`
    类。这允许我们在运行时更改 `Light` 类的功能。
- en: There are a number of benefits of using the command pattern. One of the main
    benefits is that we are able to set the implementation of the commands at runtime,
    which also lets us swap the commands out with different implementations that conform
    to the `Command` protocol, as needed throughout the life of the application. Another
    advantage of the command pattern is that we encapsulate the details of the command
    implementations within the command classes themselves rather than in the container
    class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令模式有许多好处。其中一个主要的好处是我们能够在运行时设置命令的实现，这也允许我们根据需要在整个应用程序的生命周期中用符合`Command`协议的不同实现替换命令。命令模式的另一个优点是将命令实现的细节封装在命令类本身中，而不是在容器类中。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the command pattern, we used structures to implement our command types because
    it is very easy to create one instance of a command type and then use it to create
    multiple instances of the `Light` class. In that case, if one `Light` class changed
    anything in the command instance, it would then be reflexed in all the instances
    of the `Light` class that used that command instance. Generally, this is not the
    behavior we want; however, if that is the behavior your application needs, then
    you should use a class rather than a structure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令模式，我们使用结构体来实现我们的命令类型，因为创建一个命令类型的实例并将其用于创建`Light`类的多个实例非常容易。在这种情况下，如果`Light`类中的任何内容在命令实例中发生变化，那么它将反映在所有使用该命令实例的`Light`类的实例中。通常，我们不想这种行为；然而，如果您的应用程序需要这种行为，那么您应该使用类而不是结构体。
- en: Now, let's look at our last design pattern, which is the strategy pattern.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的最后一个设计模式，即策略模式。
- en: The strategy pattern
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern is pretty similar to the command pattern in the fact that
    they both allow us to decouple implementation details from our calling class and
    also allow us to switch the implementation out at runtime. The big difference
    is, the strategy pattern is intended to encapsulate algorithms. By swapping out
    an algorithm, we are expecting the object to perform the same functionality but
    in a different way. In the command pattern, when we swap out the commands, we
    are expecting the object to function differently.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式在某种程度上与命令模式相似，因为它们都允许我们将实现细节从我们的调用类中解耦，并允许我们在运行时切换实现。最大的区别是，策略模式旨在封装算法。通过替换算法，我们期望对象执行相同的功能，但以不同的方式。在命令模式中，当我们替换命令时，我们期望对象以不同的方式工作。
- en: 'In this section, we will demonstrate the strategy pattern by showing you how
    we could swap out compression strategies at runtime. Let''s begin this example
    by creating a `CompressionStrategy` protocol that each one of our compression
    classes will conform to. Let''s take a look at the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过展示如何在运行时替换压缩策略来演示策略模式。让我们从这个示例开始，创建一个`CompressionStrategy`协议，我们的每个压缩类都将遵循这个协议。让我们看一下以下代码：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This protocol defines one method named `compressFiles()` that accepts a single
    parameter, which is an array of strings that contain the paths of the files to
    compress. We will now create two structures that conform to the `CompressionStrategy`
    protocol. These classes are the `ZipCompressionStrategy` and `RarCompressionStrategy`
    classes, which are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议定义了一个名为`compressFiles()`的方法，它接受一个参数，即包含要压缩的文件路径的字符串数组。现在，我们将创建两个符合`CompressionStrategy`协议的结构。这些类是`ZipCompressionStrategy`和`RarCompressionStrategy`类，如下所示：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Both of these structures implement the `CompressionStrategy` protocol by having
    a method named `compressFiles()`, which accepts an array of strings. Within these
    methods, we simply print out the name of the compression that we are using. Normally,
    we would implement the compression logic in these methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个结构体通过具有名为`compressFiles()`的方法来实现`CompressionStrategy`协议，该方法接受一个字符串数组。在这些方法中，我们只是简单地打印出我们正在使用的压缩名称。通常，我们会在这些方法中实现压缩逻辑。
- en: 'Now, let''s look at our `CompressContent` class that will be called to compress
    the files:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看将被调用来压缩文件的`CompressContent`类：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this class, we start off by defining a variable named `strategy` that will
    contain an instance of a class that conforms to the `CompressStrategy` protocol.
    We then create an initiator that will be used to set the compression type when
    the class is initiated. Finally, we create a method named `compressFiles()` that
    accepts an array of strings that contain the paths to the list of files that we
    wish to compress. In this method, we compress the files using the compression
    strategy that is set in the strategy variable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个课程中，我们首先定义了一个名为 `strategy` 的变量，它将包含一个符合 `CompressStrategy` 协议的类的实例。然后我们创建了一个初始化器，用于在类初始化时设置压缩类型。最后，我们创建了一个名为
    `compressFiles()` 的方法，它接受一个包含我们希望压缩的文件路径的字符串数组。在这个方法中，我们使用在 `strategy` 变量中设置的压缩策略来压缩文件。
- en: 'We will use the `CompressContent` class like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样使用 `CompressContent` 类：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We begin by creating an array of strings that contain the files we wish to compress.
    We also create an instance of both the `ZipCompressionStrategy` and `RarCompressionStrategy`
    classes. We then create an instance of the `CompressContent` class, setting the
    compression strategy to the `ZipCompressionStrategy` instance and call the `compressFiles()`
    method, which will print the `Using zip compression` message to the console. We
    then set the compression strategy to the `RarCompressionStrategy` instance and
    call the `compressFiles()` method again, which will print the `Using rar compression`
    message to the console.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含我们希望压缩的文件的字符串数组。我们还创建了 `ZipCompressionStrategy` 和 `RarCompressionStrategy`
    类的实例。然后我们创建了一个 `CompressContent` 类的实例，将压缩策略设置为 `ZipCompressionStrategy` 实例，并调用
    `compressFiles()` 方法，该方法将在控制台打印出 `Using zip compression` 消息。然后我们将压缩策略设置为 `RarCompressionStrategy`
    实例，并再次调用 `compressFiles()` 方法，该方法将在控制台打印出 `Using rar compression` 消息。
- en: The strategy pattern is really good for setting the algorithms to use at runtime,
    which also lets us swap the algorithms out with different implementations as needed
    by the application. Another advantage of the strategy pattern is, we encapsulate
    the details of the algorithm within the strategy classes themselves and not in
    the main implementation class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式非常适合在运行时设置要使用的算法，这也允许我们根据应用程序的需要交换不同的实现。策略模式的另一个优点是，我们将算法的细节封装在策略类本身中，而不是在主实现类中。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just like the command pattern, we used structures to implement the strategy
    pattern because it is very easy to create one instance of a strategy type and
    then use it to create multiple instances of the `CompressContent` class. In this
    case, if anything is changed in the strategy instance, it would be reflexed in
    all of the `CompressContent` types. Generally, this is not the behavior we want;
    however, if that is the behavior your application needs, then you should use a
    class rather than a structure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像命令模式一样，我们使用结构体来实现策略模式，因为它非常容易创建一个策略类型的实例，然后使用它来创建 `CompressContent` 类的多个实例。在这种情况下，如果策略实例中发生了任何变化，它将反映在所有的
    `CompressContent` 类型中。通常，我们并不希望这种行为；然而，如果您的应用程序需要这种行为，那么您应该使用类而不是结构体。
- en: This concludes our tour of design patterns in Swift.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对 Swift 中设计模式的探索结束。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Design patterns are solutions to software design problems that we tend to see
    over and over again in real-world application designs. These patterns are designed
    to help us create reusable and flexible code. Design patterns can also make our
    code easier to read and understand for other developers and also for ourselves
    when we look back at out code months/years later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是解决我们在现实世界的应用程序设计中反复看到的软件设计问题的解决方案。这些模式旨在帮助我们创建可重用和灵活的代码。设计模式还可以使我们的代码更容易被其他开发人员以及我们自己阅读和理解，当我们几个月/几年后回顾我们的代码时。
- en: If we looked at the examples in the chapter carefully, we would notice that
    one of the backbones of design patterns is protocols. Almost all the design patterns
    (the singleton design pattern is an exception) use protocols to help us create
    very flexible and reusable code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看本章中的示例，我们会注意到设计模式的一个关键组成部分是协议。几乎所有的设计模式（单例设计模式除外）都使用协议来帮助我们创建非常灵活和可重用的代码。
- en: If this was the first time that you really looked at design patterns, you probably
    noticed some similarities to strategies that you may have used in the past in
    your own code. This is expected when experienced developers are first introduced
    to design patterns. I would also encourage you to read about design patterns more
    because they will definitely help you to create more flexible and reusable code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次真正关注设计模式，你可能注意到了一些与你在过去自己的代码中可能使用过的策略的相似之处。当经验丰富的开发者第一次接触设计模式时，这种情况是预料之中的。我还会鼓励你更多地阅读有关设计模式的内容，因为它们肯定会帮助你创建更灵活和可重用的代码。
