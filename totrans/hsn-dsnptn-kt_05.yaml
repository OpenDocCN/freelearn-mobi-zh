- en: Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to discuss basic principles of functional programming,
    and how they fit into the Kotlin programming language. We won''t introduce much
    new syntax, as you''ll soon see. It would have been hard to discuss benefits of
    the language in the previous chapters without touching on concepts such as *data
    immutability* and *functions as first-class values*. But, as we did before, we''ll
    look at those features from a different angle: not how to use them to implement
    well-known design patterns in a better way, but their purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why functional programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions, not statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why functional programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional programming has been around for almost as long as other programming
    paradigms, such as procedural and object-oriented programming, if not longer.
    But in the past 10 years, it has gained major momentum. The reason for that is
    because something else stalled: CPU speeds. We cannot speed up our CPUs as much
    as we did in the past, so we must parallelize our programs. And it turns out that
    the functional programming paradigm is exceptional at running parallel tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of multicore processors is a very interesting topic by itself,
    but we'll be able to cover it only briefly. Workstations had multiple processors
    since the 1980s at least, to support running tasks from different users in parallel.
    Since workstations were huge anyway, they didn't need to worry about cramming
    everything into one chip. But with multiprocessors coming to the consumer market
    around 2005, it was necessary to have one physical unit that could do work in
    parallel. That's the reason we have multiple cores on one chip in our PC or laptop.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that''s not the only reason some swear by functional programming. Here
    are a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming favors pure functions, and pure functions are usually
    easier to reason about and to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code written in a functional way is often more declarative than imperative,
    dealing with the *what* and not the *how*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the key concepts of functional programming is immutability. It means
    that from the moment the function receives input to the moment the function returns
    output, the object doesn''t change. How could it change, you wonder? Let''s see
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output would be first `"a"`, then we'll receive `ConcurrentModificationException`.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be great if we could protect ourselves from such runtime exceptions
    in the first place?
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional programming, a tuple is a piece of data that cannot be changed
    after it is created. One of the most basic tuples in Kotlin is Pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Pair contains two properties, first and second, and is immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can destructure a Pair into two separate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When iterating over a map, we receive another tuple, `Map.Entry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In general, *data classes* are usually a good implementation for tuples. But,
    as we'll see in the *Value Mutation* section, not every data class is a proper
    tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Value mutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Maronic, we would like to count the average score over one thousand games.
    For that, we have the following data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We were smart: we protected ourselves from any invalid output by checking for
    divisions by zero.'
  prefs: []
  type: TYPE_NORMAL
- en: But what will happen when we write the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Soon enough, you'll receive `ArithmeticException` anyway. Our counter somehow
    becomes zero.
  prefs: []
  type: TYPE_NORMAL
- en: If you want your data classes to be immutable, be sure to specify all their
    properties as `val` (values), and not `var` (variables).
  prefs: []
  type: TYPE_NORMAL
- en: Immutable collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I think that our junior developer learned their lesson. Instead, they produced
    this code, which is not very efficient, but which gets rid of those variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But the maleficent thread strikes again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We again receive `ArithmeticException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not enough that your data class contains only values. If its value is
    a collection, it must be immutable in order for the data class to be considered
    immutable. The same rule is applied to classes contained within other data classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now the maleficent thread cannot even call `clear()` on this collection. But
    how should we add scores to it?
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to pass the entire list in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Functions as values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already covered some of the functional capabilities of Kotlin in the chapters
    dedicated to Design Patterns. The **Strategy** and **Command** design patterns
    are but a few that heavily rely on the ability to accept functions as arguments,
    return functions, store them as values, or put them inside collections. In this
    section, we'll cover some other aspects of functional programming in Kotlin, such
    as function purity and currying.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed previously, in Kotlin, it''s possible for a function to return
    another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can also be assigned to a variable or value to be invoked later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The function assigned to a variable is usually called a *literal function*.
    It''s also possible to specify a function as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function is the last parameter, it can also be supplied ad hoc, outside
    of the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, a function without a name is called an *anonymous* function. If
    a function without a name uses short syntax, it''s called a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pure function is a function without any side effects. Take the following
    function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How do you test to see whether `"Hello"` is indeed printed? The task is not
    as simple as it seems, as we'll need some means to capture the standard output,
    the same console where we usually see stuff printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare it to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function doesn''t have any side effects. That makes it a lot
    easier to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Does the `hello()` function look a bit meaningless to your eyes? That's actually
    one of the properties of pure functions. Their invocation could be replaced by
    their result (if we knew all their results, that is). This is often called *referential
    transparency*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not every function written in Kotlin is pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the function twice on the same list, it will return different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Try this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our function is totally predictable, no matter how many times we invoke
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used an immutable interface this time, `List<T>`, which helps
    us by preventing even the possibility of mutating our input. Together with immutable
    values from the previous section, pure functions provide a very strong tool that
    allows easier testing by providing predictable results and parallelization of
    our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currying is a way to translate a function that takes a number of arguments
    into a chain of functions that each take a single argument. This may sound confusing,
    so let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a function that returns two arguments. The result is quite obvious.
    But maybe we would like to invoke this function with the following syntax instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen how we can return a function from another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is in the shorter form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And here it is in an even shorter form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Although not very useful by itself, it's still an interesting concept to grasp.
    And if you're a JavaScript developer looking for a new job, make sure you understand
    it really well, since it's being asked about in nearly every interview.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If our function always returns the same output for the same input, we could
    easily map between previous input and output, and use it as a cache. That technique
    is called *memoization*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use a method reference operator, `::`, to tell `computeIfAbsent` to use the `sum()`
    method in the event that input wasn't cached yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `sum()` is a pure function, while `summarize()` is not. The latter
    will behave differently for the same input. But that''s exactly what we want in
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The combination of immutable objects, pure functions, and plain old classes
    provides us with a powerful tool for performance optimizations. Just remember,
    nothing is free. We only trade one resource, CPU time, for another resource, memory.
    And it's up to you to decide which resource is more expensive for you in each
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions, not statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A statement is a block of code that doesn't return anything. An expression,
    on the other hand, returns a new value. Since statements produce no results, the
    only way for them to be useful is to mutate state. And functional programming
    tries to avoid mutating the state as much as possible. Theoretically, the more
    we rely on expressions, the more our functions will be pure, with all the benefits
    of functional purity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used the `if` expression many times already, so one of its benefits
    should be clear: it''s less verbose and, for that reason, less error-prone than
    the `if` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of pattern matching is like `switch/case` on steroids for someone
    who comes from Java. We've already seen how `when` expression can be used, in
    [Chapter 1](part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7), *Getting Started
    with Kotlin*, so let's briefly discuss why this concept is important for the functional
    paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: As you may know, `switch` in Java accepts only some primitive types, strings,
    or enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to decide which of the functions to call, we would need something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method could be shortened by introducing multiple returns, but in real
    projects, multiple returns are usually bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: Since we don't have a `switch` statement for classes, we need to use an `if`
    statement instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare that with the following Kotlin code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Since `when` is an expression, we avoided the intermediate variable altogether.
    But what's more, using pattern matching, we can also avoid most of the code that
    concerns type checks and casts.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursion is a function invoking itself with new arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We usually avoid recursion, due to **Stack Overflow** error that we may receive
    if our call stack is too deep. You can call this function with a list that contains
    a million numbers to experience it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: One of the great benefits of tail recursion is that it avoids the dreaded stack
    overflow exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our recursive function using a new keyword, `tailrec`, to avoid
    that problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now the compiler will optimize our call and avoid exception completely.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a better understanding of functional programming and its
    benefits.  We've discussed the concepts of immutability and pure functions. A
    combination of the two often results in more testable code, which is easier to
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Currying and memoization are two useful patterns that originate from functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin has a `tailrec` keyword that allows the compiler to optimize *tail recursion*.
    We also looked at higher-order functions, expressions versus statements, and pattern
    matching.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll put this knowledge to practical use, and discover
    how reactive programming builds upon functional programming in order to create
    scalable and resilient systems.
  prefs: []
  type: TYPE_NORMAL
