- en: '*Chapter 5*: Building a Structure for ToDo Items'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：构建待办事项的结构'
- en: iOS apps are often developed using a design pattern called **Model-View-Controller**
    (**MVC**). In this pattern, each class, struct, or enum is either a model object,
    view, or controller. Model objects are responsible for storing data. They should
    be independent of the kind of presentation provided by the UI. For example, it
    should be possible to use the same model object for an iOS app and a command-line
    tool on macOS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 应用通常使用一种称为 **模型-视图-控制器**（**MVC**）的设计模式进行开发。在这个模式中，每个类、结构体或枚举要么是模型对象、视图，要么是控制器。模型对象负责存储数据。它们应该独立于
    UI 提供的展示方式。例如，应该能够使用相同的模型对象在 iOS 应用和 macOS 的命令行工具中使用。
- en: View objects present the data. They are responsible for making the objects visible
    (or hearable, in the case of a VoiceOver-enabled app) for the user. Views are
    special for the device that the app is executed on. In the case of a cross-platform
    app, view objects cannot be shared. Each platform needs an implementation of a
    view layer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 视图对象呈现数据。它们负责使对象对用户可见（或在启用了语音覆盖的应用中可听），对于应用运行在的设备而言，视图是特殊的。在跨平台应用中，视图对象不能共享。每个平台都需要实现视图层。
- en: Controller objects communicate between the model and view objects. They are
    responsible for making the model objects presentable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器对象在模型和视图对象之间进行通信。它们负责使模型对象可展示。
- en: We will use MVC for our to-do app because it is one of the easiest design patterns,
    and it is commonly used by Apple in its sample code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 MVC 为我们的待办事项应用设计，因为它是最容易的设计模式之一，并且苹果在它的示例代码中广泛使用。
- en: This chapter starts our journey in the field of TDD with the model layer of
    our app. By the end of this chapter, we will have a structure where we can store
    all the information about a to-do item, including an optional location.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从我们的应用模型层开始，引领我们进入 TDD 领域。到本章结束时，我们将有一个可以存储待办事项所有信息的结构，包括可选的位置。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing the ToDoItem struct
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `ToDoItem` 结构体
- en: Implementing the Location struct
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `Location` 结构体
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code for this chapter can be found (in its complete form) here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在这里找到（完整形式）：[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05)。
- en: Implementing the ToDoItem struct
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `ToDoItem` 结构体
- en: To be useful, to-do items need a minimal set of information. In this section,
    we will create a structure to hold this information while using tests to guide
    their development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有用，待办事项需要一组最小信息。在本节中，我们将创建一个结构体来保存这些信息，同时使用测试来指导其开发。
- en: 'A to-do app needs a model class/struct to store information for to-do items:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个待办事项应用需要一个模型类/结构体来存储待办事项的信息：
- en: We will start by adding a new test case to the unit test target. Open the to-do
    project that we created in the *Getting started with Xcode* section of [*Chapter
    4*](B18127_04_ePub.xhtml#_idTextAnchor134), *The App We Are Going to Build*, and
    select the **ToDoTests** group.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先向单元测试目标添加一个新的测试用例。打开我们在 [*第四章*](B18127_04_ePub.xhtml#_idTextAnchor134)
    的 *开始使用 Xcode* 部分创建的待办事项项目，选择 **ToDoTests** 组。
- en: Go to `ToDoItemTests`, make it a subclass of `XCTestCase`, select **Swift**
    as the language, and click on **Next**.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `ToDoItemTests`，将其设置为 `XCTestCase` 的子类，选择 **Swift** 作为语言，然后点击 **下一步**。
- en: In the next window, click on **Create**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，点击 **创建**。
- en: Now, delete the `ToDoTests.swift` template test case.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除 `ToDoTests.swift` 模板测试用例。
- en: Adding a title property
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题属性
- en: 'A to-do item needs a `title`. Follow these steps to add one to our `ToDoItem`
    struct:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项需要一个 `title`。按照以下步骤向我们的 `ToDoItem` 结构体添加一个：
- en: 'Open `ToDoItemTests.swift` and add the following import expression right below
    `import XCTest`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ToDoItemTests.swift` 文件，并在 `import XCTest` 语句下方添加以下导入表达式：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is needed to be able to test the `ToDo` module. The `@testable` keyword
    makes the internal methods of the `ToDo` module accessible to the test case. Alternatively,
    you could make the methods accessible from the test target using the `public`
    or `open` access levels. But you should only do that when you need that access
    levels because, for example, the method is part of a Swift package.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Remove the two template test methods, `testExample()` and `testPerformanceExample()`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `title` string of a to-do item is required. Let''s write a test to ensure
    that an initializer exists that will take a `title` string. Add the following
    test method to the end of the test case (but within the `ToDoItemTests` class):'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The static analyzer that''s built into Xcode will complain that it `Cannot
    find ''ToDoItem'' in scope`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Xcode telling us that it cannot find the ToDoItem type'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B18127.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Xcode telling us that it cannot find the ToDoItem type
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: We cannot compile this code because Xcode cannot find the `ToDoItem` type. A
    non-compiling test is a failing test; as soon as we have a failing test, we need
    to write implementation code to make the test pass.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: To add a file for the implementation code, first, click on the **ToDo** group
    in the **Project** navigator. Otherwise, the added file will be put into the test
    group.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `ToDoItem.swift`, make sure that the file is added to the `ToDo` target
    and not to the `ToDoTests` target, and click on **Create**:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Adding the file to the main target'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B18127.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Adding the file to the main target
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ToDoItem.swift` in the editor and add the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is a complete implementation of a struct named `ToDoItem`. So, Xcode
    should now be able to find the `ToDoItem` identifier.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test by either going to `ToDoItem`, like this:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, we want to have an initializer that takes a title. We need to add
    a property, named `title`, of the `String` type to store the `title` string:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the test again; it will pass. We have implemented the first microfeature
    of our to-do app using TDD – and it wasn't even hard. For the rest of this book,
    we will do this over and over again until the app is complete. But first, we need
    to check whether there is anything to refactor in the existing test and implementation
    code. The tests and code are clean and simple, so there is nothing to refactor
    yet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Always remember to check whether refactoring is needed once you have made the
    tests green.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, a few things to note about the test. First, Xcode shows
    a warning stating `_ = ToDoItem(title: "Foo")`. This tells Xcode that we know
    what we are doing. We want to call the initializer of `ToDoItem`, but we do not
    care about its return value.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, there is no `XCTAssert` function call in the test. To add an assert,
    we could rewrite the test like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But in Swift, a non-failable initializer cannot return `nil`. It always returns
    a valid instance. This means that the `XCTAssertNotNil()` method is useless. We
    do not need it to ensure that we have written enough code to implement the tested
    microfeature. It is not needed to drive the development, and it does not make
    the code better.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Swift 中，一个非失败的初始化器不能返回 `nil`。它总是返回一个有效的实例。这意味着 `XCTAssertNotNil()` 方法是没有用的。我们不需要它来确保我们已经编写了足够的代码来实现测试的微特性。它不是驱动开发所必需的，而且它不会使代码变得更好。
- en: Before we proceed with the next few tests, let's set up the editor in a way
    that makes the TDD workflow easier and faster. First, open `ToDoItemTests.swift`
    in the editor. Then, open the `ToDoItem.swift` to open it in the Assistant Editor.
    Depending on the size of your screen and your preferences, you may prefer to hide
    the navigator again. With this setup, you have the tests and the code side by
    side, and switching from test to code and vice versa takes no time at all. In
    addition to this, since the relevant test is visible while you write the code,
    it can guide the implementation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行接下来的几个测试之前，让我们以使 TDD 工作流程更简单、更快捷的方式设置编辑器。首先，在编辑器中打开 `ToDoItemTests.swift`。然后，打开
    `ToDoItem.swift` 以在辅助编辑器中打开它。根据你的屏幕大小和偏好，你可能更喜欢再次隐藏导航器。使用这种设置，你可以将测试和代码并排放置，从测试切换到代码以及反之，都无需花费任何时间。此外，由于在编写代码时相关测试是可见的，它可以指导实现。
- en: Adding an itemDescription property
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `itemDescription` 属性
- en: 'A to-do item can have a description. We would like to have an initializer that
    also takes a description string. Let''s get started:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个待办事项可以有一个描述。我们希望有一个初始化器，它也接受一个描述字符串。让我们开始：
- en: 'To drive the implementation, we need a failing test for the existence of this
    initializer:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了驱动实现，我们需要一个失败的测试来验证这个初始化器的存在：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, this code does not compile because there is an extra argument called
    `itemDescription` in the call.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这段代码无法编译，因为在调用中有一个额外的名为 `itemDescription` 的参数。
- en: 'To make this test pass, we must add an `itemDescription` property of the `String?`
    type to `ToDoItem`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们必须向 `ToDoItem` 添加一个 `String?` 类型的 `itemDescription` 属性：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the tests. The `test_init_takesTitle()` test will fail (that is, it will
    not compile) because there is a `init` methods as well) can have default values
    for parameters. You will use this feature to set `itemDescription` to `nil` if
    there is no parameter for it in the initializer.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。`test_init_takesTitle()` 测试将会失败（也就是说，它将无法编译），因为有一个 `init` 方法也可以为参数设置默认值。你将使用这个特性，如果初始化器中没有为
    `itemDescription` 设置参数，则将其设置为 `nil`。
- en: 'Add the following code to `ToDoItem`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `ToDoItem` 中：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This initializer has two arguments. The second argument has a default value,
    so we do not need to provide both arguments. When the second argument is omitted,
    the default value is used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化器有两个参数。第二个参数有一个默认值，所以我们不需要提供两个参数。当省略第二个参数时，将使用默认值。
- en: Now, run the tests to make sure that both tests pass.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行测试以确保两个测试都通过。
- en: Removing a hidden source of bugs
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除隐藏的错误来源
- en: 'To be able to use a short initializer by only setting the title, we need to
    define it ourselves. But this also introduces a new source of potential bugs.
    We can remove the two microfeatures we have implemented and still have both tests
    pass. To take a look at how this works, open `ToDoItem.swift` and comment out
    the properties and assignment in the initializer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够只通过设置标题来使用简短的初始化器，我们需要自己定义它。但这同时也引入了一个新的潜在错误来源。我们可以移除我们已实现的两个微特性，并且两个测试仍然可以通过。要查看这是如何工作的，请打开
    `ToDoItem.swift` 并注释掉初始化器中的属性和赋值：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the tests. Both tests will still pass. The reason for this is that they
    do not check whether the values of the initializer arguments are set to any `ToDoItem`
    properties. We can easily extend the tests to make sure that the values are set.
    First, let''s change the name of the first test to `test_init_whenGivenTitle_setsTitle()`
    and replace it with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。两个测试仍然会通过。原因在于它们并没有检查初始化器参数的值是否被设置到了任何 `ToDoItem` 属性上。我们可以轻松地扩展测试以确保这些值被设置。首先，让我们将第一个测试的名称改为
    `test_init_whenGivenTitle_setsTitle()` 并替换为以下代码：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This test does not compile because `ToDoItem` does not have a `title` property
    (it is commented out). This shows that the test is now testing our intention.
    Remove the comment signs for the title property and assignment of the title in
    the initializer, and then run the tests again. All the tests will pass. Now, replace
    the second test with this one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试无法编译，因为 `ToDoItem` 没有标题属性（它是被注释掉的）。这表明测试现在正在测试我们的意图。移除标题属性的注释符号和在初始化器中标题的赋值，然后再次运行测试。所有的测试都会通过。现在，用这个测试替换第二个测试：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remove the remaining comment signs in `ToDoItem` and run the tests again. Both
    the tests will pass again, and they now test that the initializer works.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 `ToDoItem` 中的剩余注释符号，再次运行测试。这两个测试都会再次通过，并且现在它们测试初始化器是否工作。
- en: Tip
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a good idea to use speaking test method names – that is, names that tell
    the story of the test. It's quite common to use a pattern such as `test_<method
    name>_<precondition>_<expected behavior>`. This way, the method name tells all
    that you need to know about the test when a test fails. In this book, we will
    try to follow this pattern, but we will leave out some information (for example,
    the precondition) when the code gets harder to read because of the limited space
    we have. You should develop a pattern and use it in all your tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可读的测试方法名是一个好主意——也就是说，能够讲述测试故事的名称。使用如 `test_<方法名>_<前提条件>_<预期行为>` 这样的模式是很常见的。这样，当测试失败时，方法名就告诉你所有关于测试你需要知道的信息。在这本书中，我们将尝试遵循这个模式，但由于空间有限，我们将在代码难以阅读时省略一些信息（例如，前提条件）。你应该开发一个模式并在所有测试中使用它。
- en: Adding a timestamp property
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加时间戳属性
- en: 'A to-do item can also have a due date represented by a `timestamp` property:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个待办事项也可以有一个由 `timestamp` 属性表示的截止日期：
- en: 'Add the following test to make sure we can initialize an instance of `ToDoItem`
    with `timestamp`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试以确保我们可以使用 `timestamp` 初始化 `ToDoItem` 的实例：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, this test does not compile because there is an extra argument in the
    initializer. From the implementation of the other properties, we know that we
    have to add a `timestamp` property in `ToDoItem` and set it in the initializer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个测试无法编译，因为初始化器中有一个额外的参数。从其他属性的实现中，我们知道我们必须在 `ToDoItem` 中添加一个 `timestamp`
    属性并在初始化器中设置它。
- en: 'Change `ToDoItem` so that it looks like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ToDoItem` 改成如下所示：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the tests. With a bit of luck, all the tests will pass. But what happens
    if they don't pass on your computer? The reason for this may be because we compare
    two `TimeInterval` structures using `XCTAssertEqual(_:_:)`. `TimeInterval` is
    a type alias for `Double`. Doubles are floating-point numbers and as such are
    hard to compare to each other. Usually, you can't tell if two floating-point numbers
    are equal. You can only tell if they are equal in respect to some accuracy. That's
    why `XCTest` provides an assert method with accuracy.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。如果有点运气，所有的测试都会通过。但如果它们在你的电脑上没有通过，会发生什么呢？这种情况的原因可能是因为我们使用 `XCTAssertEqual(_:_:)`
    来比较两个 `TimeInterval` 结构。`TimeInterval` 是 `Double` 类型的一个别名。双精度浮点数是浮点数，因此很难相互比较。通常，你无法判断两个浮点数是否相等。你只能判断它们在某种精度下是否相等。这就是为什么
    `XCTest` 提供了一个具有精度的断言方法。
- en: 'Replace the assert method call in `test_init_setsTimestamp()` with the following
    method call:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `test_init_setsTimestamp()` 中的断言方法调用替换为以下方法调用：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the tests. You will see that all the tests pass.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。你会看到所有的测试都通过了。
- en: You may have noticed that we have to force unwrap `item.timestamp` to use it
    in the assert method with accuracy. The reason for this is that, in contrast to
    `XCTAssertEqual(_:_:)`, `XCTAssertEqual(_:_:accuracy:)` can't compare optional
    values. `timestamp` in `ToDoItem` is optional so that to-do items without due
    dates can be created. Force unwrapping a value in a unit test is not as problematic
    as doing so in production code because a crash in a test is only visible for the
    developer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们必须强制解包 `item.timestamp` 来在具有精度的断言方法中使用它。这是因为，与 `XCTAssertEqual(_:_:)`
    相比，`XCTAssertEqual(_:_:accuracy:)` 不能比较可选值。`ToDoItem` 中的 `timestamp` 是可选的，这样就可以创建没有截止日期的待办事项。在单元测试中强制解包一个值并不像在生产代码中那样有问题，因为测试中的崩溃只对开发者可见。
- en: But still, Apple added a feature to `XCTest` to deal with optional values better.
    This is so important for the rest of this book that it deserves a section to itself.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，苹果还是为 `XCTest` 添加了一个功能来更好地处理可选值。这对于本书的其余部分来说非常重要，因此值得单独成章。
- en: Dealing with optional values in unit tests
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单元测试中处理可选值
- en: 'With Xcode 11, Apple introduced the `XCTUnwrap(_:)` function to `XCTest`. This
    function unwraps its parameter and returns the unwrapped value. If the parameter
    is `nil`, this function throws an error. In this section, we will use this function
    to improve our test code. Replace the `test_init_setsTimestamp()` test method
    with the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode 11中，Apple将`XCTUnwrap(_:)`函数引入到`XCTest`中。这个函数展开其参数并返回展开后的值。如果参数是`nil`，这个函数会抛出一个错误。在本节中，我们将使用这个函数来改进我们的测试代码。用以下代码替换`test_init_setsTimestamp()`测试方法：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Several things have changed in this code. Let''s look at them one by one:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有几处变化。让我们逐一查看：
- en: The method is now marked with `throws`. The reason for this is that we call
    a function that can throw an error. A test method that is marked with `throws`
    fails, when an error is thrown and not caught during its execution.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法现在被标记为`throws`。这样做的原因是我们调用了一个可能会抛出错误的函数。当一个带有`throws`标记的测试方法在执行过程中抛出错误而没有被捕获时，该测试方法会失败。
- en: With `try XCTUnwrap(item.timestamp)`, we try to unwrap the `item.timestamp`
    value.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`try XCTUnwrap(item.timestamp)`，我们尝试展开`item.timestamp`的值。
- en: The result is assigned to a variable that is used in the `XCTAssertEqual` method.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果被分配给一个变量，该变量用于`XCTAssertEqual`方法。
- en: Whenever you have to deal with optionals in test code, this is the preferred
    way to do so. This way, you get the most valuable information in case the value
    is unexpectedly `nil`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在测试代码中必须处理可选值时，这是首选的方式。这样，在值意外为`nil`的情况下，你可以获得最有价值的信息。
- en: Adding a location property
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加位置属性
- en: 'The last property that we would like to be able to set in the initializer of
    `ToDoItem` is its `Location`. The location has a name and can optionally have
    a coordinate. We will use a struct to encapsulate this data into a type. Let''s
    get started:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在`ToDoItem`的初始化器中设置的最后一个属性是它的`Location`。位置有一个名称，并且可以可选地有一个坐标。我们将使用一个结构体来封装这些数据到一个类型中。让我们开始吧：
- en: 'Add the following code to `ToDoItemTests`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ToDoItemTests`：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The test is not finished, but it already fails because Xcode `Location` yet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试尚未完成，但它已经失败了，因为Xcode中的`Location`还没有完成。
- en: Open the `Location.swift` to the `ToDoItem` struct, we already know what is
    needed to make the test green.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Location.swift`到`ToDoItem`结构体，我们已经知道需要什么来使测试通过。
- en: 'Add the following code to `Location.swift`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Location.swift`：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This defines a struct called `Location` with a `name` property and makes the
    test code compilable again. But the test is not finished yet.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为`Location`的结构体，并带有`name`属性，使得测试代码再次可编译。但测试还没有完成。
- en: 'Add the following code to `test_init_whenGivenLocation_setsLocation()`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`test_init_whenGivenLocation_setsLocation()`：
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, we cannot use the location itself to check for equality yet,
    so the following assert does not work:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们目前还不能使用位置本身来检查相等性，所以下面的断言不起作用：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The reason for this is that the first two arguments of `XCTAssertEqual()` have
    to conform to the `Equatable` protocol. We will add the protocol's conformance
    in the next chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`XCTAssertEqual()`的前两个参数必须符合`Equatable`协议。我们将在下一章中添加协议的符合性。
- en: Again, this does not compile because the initializer of `ToDoItem` does not
    have an argument called `Location`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这不能编译，因为`ToDoItem`的初始化器没有名为`Location`的参数。
- en: 'Add the `location` property and initializer argument to `ToDoItem`. The result
    should look like this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`location`属性和初始化器参数添加到`ToDoItem`中。结果应该看起来像这样：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the tests again. All the tests will pass and there will be nothing to refactor.
    We have now implemented a struct to hold `ToDoItem` using TDD.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。所有测试都将通过，并且没有需要重构的地方。我们现在已经使用TDD实现了一个结构体来持有`ToDoItem`。
- en: In the next section, we will implement a structure to store location data for
    to-do items.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个结构体来存储待办事项的位置数据。
- en: Implementing the Location struct
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`Location`结构体
- en: In the previous section, we added a struct to hold information about the location.
    We will now add tests to make sure that `Location` has the required properties
    and initializer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们添加了一个结构体来存储关于位置的信息。现在我们将添加测试以确保`Location`具有所需的属性和初始化器。
- en: These tests could be added to `ToDoItemTests`, but they are easier to maintain
    when the test classes mirror the implementation classes/structs. So, we need a
    new test case class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试可以添加到`ToDoItemTests`中，但当测试类与实现类/结构体相匹配时，它们更容易维护。因此，我们需要一个新的测试用例类。
- en: Open the `ToDoTests` group, and add a unit test case class called `LocationTests`.
    Make sure that you go to **iOS** | **Source** | **Unit Test Case Class** since
    we want to test the iOS code, and Xcode sometimes navigates to **OS X** | **Source**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `ToDoTests` 组，并添加一个名为 `LocationTests` 的单元测试用例类。确保您进入 **iOS** | **源** | **单元测试用例类**，因为我们想测试
    iOS 代码，而 Xcode 有时会导航到 **OS X** | **源**。
- en: Set up the editor to show `LocationTests.swift` on the left-hand side and `Location.swift`
    in the Assistant Editor on the right-hand side. In the test class, add `@testable
    import ToDo` and remove the `testExample()` and `testPerformanceExample()` template
    tests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 设置编辑器以在左侧显示 `LocationTests.swift`，并在右侧的辅助编辑器中显示 `Location.swift`。在测试类中添加 `@testable
    import ToDo` 并删除 `testExample()` 和 `testPerformanceExample()` 模板测试。
- en: Adding a coordinate property
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加坐标属性
- en: 'The location of a to-do item will be used in the app to show a map in the details.
    A location on a map can be stored using `latitude` and `longitude` values. In
    the following steps, we will add a `coordinate` property to store this information:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项的位置将在应用中用于在详情中显示地图。地图上的位置可以使用 `latitude` 和 `longitude` 值进行存储。在以下步骤中，我们将添加一个
    `coordinate` 属性来存储此信息：
- en: To drive the addition of a `Coordinate` property, we need a failing test. For
    the coordinate, we will use the `CLLocationCoordinate2D` type from the Core Location
    framework.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了驱动 `Coordinate` 属性的添加，我们需要一个失败的测试。对于坐标，我们将使用 Core Location 框架中的 `CLLocationCoordinate2D`
    类型。
- en: 'Import `CoreLocation` below the existing import statements:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有导入语句下方导入 `CoreLocation`：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following test to `LocationTests`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下测试添加到 `LocationTests`:'
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we created a coordinate and used it to create an instance of `Location`.
    Then, we asserted that the `latitude` and `longitude` values of the location coordinates
    have been set to the correct values. We use values of `1` and `2` in the initializer
    of `CLLocationCoordinate2D` because it also has an initializer that takes no arguments
    (`CLLocationCoordinate2D()`) and sets the `longitude` and `latitude` values to
    zero. We need to make sure that the initializer of `Location` assigns the coordinate
    argument to its property in the test.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个坐标并使用它创建了一个 `Location` 实例。然后，我们断言位置坐标的 `latitude` 和 `longitude` 值已被设置为正确的值。我们在
    `CLLocationCoordinate2D` 的初始化器中使用 `1` 和 `2` 的值，因为该类还有一个不接受任何参数的初始化器（`CLLocationCoordinate2D()`），并将
    `longitude` 和 `latitude` 值设置为零。我们需要确保 `Location` 的初始化器在测试中将坐标参数分配给其属性。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that we have omitted the `message` parameter in the `XCTAssertEqual()`
    function. This is because the used assertion already gives enough context to help
    us figure out what we expect in the test. We expect that the two values are the
    same. There is no need to duplicate that information in the message. If you find
    that information useful, feel free to add a message yourself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在 `XCTAssertEqual()` 函数中省略了 `message` 参数。这是因为使用的断言已经提供了足够的信息，帮助我们了解测试中期望的内容。我们期望两个值相同。没有必要在消息中重复该信息。如果你觉得这个信息有用，你可以自己添加消息。
- en: The test does not compile because `Location` does not have a `coordinate` property
    yet. Similar to `ToDoItem`, we would like to have a short initializer for locations
    that only have a `name` argument. Therefore, we need to implement the initializer
    ourselves, and we cannot use the one provided by Swift.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试无法编译，因为 `Location` 还没有 `coordinate` 属性。类似于 `ToDoItem`，我们希望有一个只有 `name` 参数的简短初始化器。因此，我们需要自己实现初始化器，而不能使用
    Swift 提供的初始化器。
- en: 'Replace the contents of `Location.swift` with the following lines of code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Location.swift` 的内容替换为以下代码行：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, run the tests. All the tests will pass.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行测试。所有测试都将通过。
- en: Note that we have intentionally set `name` in the initializer to an empty string.
    This is the easiest implementation that makes the tests pass. But it is not what
    we want. The initializer should set the name of the location to the value in the
    `name` argument. So, we need another test to make sure that `name` is set correctly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们故意在初始化器中将 `name` 设置为空字符串。这是使测试通过的最简单实现。但这不是我们想要的。初始化器应该将位置名称设置为 `name`
    参数中的值。因此，我们需要另一个测试来确保 `name` 设置正确。
- en: 'Add the following test to `LocationTests`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下测试添加到 `LocationTests`:'
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the test to make sure it fails. To make the test pass, change `self.name
    = ""` in the initializer of `Location` to `self.name = name`. Run the tests again
    to check whether they all pass now. There is nothing to refactor in the tests
    and their implementation.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以确保它失败。为了使测试通过，将 `Location` 的初始化器中的 `self.name = ""` 改为 `self.name = name`。再次运行测试以检查它们现在是否都通过了。测试中没有需要重构的部分，它们的实现也没有问题。
- en: Now, the `Location` structure can store a name and an optional coordinate to
    be used in the user interface of the app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Location` 结构可以存储一个名称以及可选的坐标，这些坐标将用于应用的用户界面。
- en: You may have asked yourself, why did we start with the `coordinate` property
    and not the `name` property when implementing that feature? We started with the
    coordinate because it was new terrain for us. We didn't know how to tackle testing
    `Double` values. Sometimes, it can be liberating to work on the most difficult
    problem first. It depends on how you write code. Tests help us make small baby
    steps and therefore help make difficult problems easier to solve.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能自己问过自己，为什么我们在实现该功能时从 `coordinate` 属性而不是 `name` 属性开始？我们之所以从坐标开始，是因为这对我们来说是新领域。我们不知道如何处理测试
    `Double` 值。有时，先处理最困难的问题可以是一种解脱。这取决于你如何编写代码。测试帮助我们迈出小步，因此有助于使困难问题更容易解决。
- en: I wanted to show you how to test the coordinate first, to address the elephant
    in the room. If you feel better when working on the easier tests first, go for
    it. But don't write unnecessary and easy tests just to procrastinate and avoid
    working on the hard ones.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我想先向您展示如何测试坐标，以解决眼前的问题。如果你觉得先做简单的测试会让你感觉更好，那就去做吧。但不要写不必要的简单测试来拖延时间，避免处理困难的测试。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we created a structure to hold information for to-do items
    using TDD. We learned that TDD means switching between test code and production
    code all the time. In addition, we realized that we should use the assert method
    with the accuracy parameter when we need to compare floating-point numbers. What
    you learned in this chapter will help you write better and more robust unit tests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 TDD 创建了一个结构来存储待办事项的信息。我们了解到 TDD 意味着始终在测试代码和生产代码之间切换。此外，我们还意识到，当我们需要比较浮点数时，应该使用具有精度参数的断言方法。本章所学的内容将帮助您编写更好、更健壮的单元测试。
- en: In the next chapter, we will build a structure to manage to-do items. They need
    to be stored somewhere and we need to have a way to add and check off to-do items.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个结构来管理待办事项。它们需要存储在某个地方，我们还需要一种方法来添加和勾选待办事项。
- en: Exercises
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to write a test using `XCTAssertEqual(_:_:)` that fails, even if the values
    are equal, because of problems in comparing floating points. Hint: You often get
    this problem when using simple math functions such as addition and multiplication.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试编写一个使用 `XCTAssertEqual(_:_:)` 失败的测试，即使值相等，也因为比较浮点数时出现问题。提示：当你使用简单的数学函数，如加法和乘法时，你经常遇到这个问题。
- en: Make `ToDoItem` conform to `Equatable` and rewrite the assertions to take advantage
    of that conformance.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使 `ToDoItem` 遵守 `Equatable` 协议，并重写断言以利用该协议。
