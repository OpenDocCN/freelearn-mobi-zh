- en: '*Chapter 5*: Building a Structure for ToDo Items'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iOS apps are often developed using a design pattern called **Model-View-Controller**
    (**MVC**). In this pattern, each class, struct, or enum is either a model object,
    view, or controller. Model objects are responsible for storing data. They should
    be independent of the kind of presentation provided by the UI. For example, it
    should be possible to use the same model object for an iOS app and a command-line
    tool on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: View objects present the data. They are responsible for making the objects visible
    (or hearable, in the case of a VoiceOver-enabled app) for the user. Views are
    special for the device that the app is executed on. In the case of a cross-platform
    app, view objects cannot be shared. Each platform needs an implementation of a
    view layer.
  prefs: []
  type: TYPE_NORMAL
- en: Controller objects communicate between the model and view objects. They are
    responsible for making the model objects presentable.
  prefs: []
  type: TYPE_NORMAL
- en: We will use MVC for our to-do app because it is one of the easiest design patterns,
    and it is commonly used by Apple in its sample code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts our journey in the field of TDD with the model layer of
    our app. By the end of this chapter, we will have a structure where we can store
    all the information about a to-do item, including an optional location.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ToDoItem struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Location struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code for this chapter can be found (in its complete form) here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ToDoItem struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be useful, to-do items need a minimal set of information. In this section,
    we will create a structure to hold this information while using tests to guide
    their development.
  prefs: []
  type: TYPE_NORMAL
- en: 'A to-do app needs a model class/struct to store information for to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by adding a new test case to the unit test target. Open the to-do
    project that we created in the *Getting started with Xcode* section of [*Chapter
    4*](B18127_04_ePub.xhtml#_idTextAnchor134), *The App We Are Going to Build*, and
    select the **ToDoTests** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `ToDoItemTests`, make it a subclass of `XCTestCase`, select **Swift**
    as the language, and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next window, click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, delete the `ToDoTests.swift` template test case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a title property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A to-do item needs a `title`. Follow these steps to add one to our `ToDoItem`
    struct:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ToDoItemTests.swift` and add the following import expression right below
    `import XCTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is needed to be able to test the `ToDo` module. The `@testable` keyword
    makes the internal methods of the `ToDo` module accessible to the test case. Alternatively,
    you could make the methods accessible from the test target using the `public`
    or `open` access levels. But you should only do that when you need that access
    levels because, for example, the method is part of a Swift package.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the two template test methods, `testExample()` and `testPerformanceExample()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `title` string of a to-do item is required. Let''s write a test to ensure
    that an initializer exists that will take a `title` string. Add the following
    test method to the end of the test case (but within the `ToDoItemTests` class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The static analyzer that''s built into Xcode will complain that it `Cannot
    find ''ToDoItem'' in scope`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Xcode telling us that it cannot find the ToDoItem type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Xcode telling us that it cannot find the ToDoItem type
  prefs: []
  type: TYPE_NORMAL
- en: We cannot compile this code because Xcode cannot find the `ToDoItem` type. A
    non-compiling test is a failing test; as soon as we have a failing test, we need
    to write implementation code to make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: To add a file for the implementation code, first, click on the **ToDo** group
    in the **Project** navigator. Otherwise, the added file will be put into the test
    group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `ToDoItem.swift`, make sure that the file is added to the `ToDo` target
    and not to the `ToDoTests` target, and click on **Create**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Adding the file to the main target'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Adding the file to the main target
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ToDoItem.swift` in the editor and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code is a complete implementation of a struct named `ToDoItem`. So, Xcode
    should now be able to find the `ToDoItem` identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test by either going to `ToDoItem`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, we want to have an initializer that takes a title. We need to add
    a property, named `title`, of the `String` type to store the `title` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the test again; it will pass. We have implemented the first microfeature
    of our to-do app using TDD – and it wasn't even hard. For the rest of this book,
    we will do this over and over again until the app is complete. But first, we need
    to check whether there is anything to refactor in the existing test and implementation
    code. The tests and code are clean and simple, so there is nothing to refactor
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always remember to check whether refactoring is needed once you have made the
    tests green.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, a few things to note about the test. First, Xcode shows
    a warning stating `_ = ToDoItem(title: "Foo")`. This tells Xcode that we know
    what we are doing. We want to call the initializer of `ToDoItem`, but we do not
    care about its return value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, there is no `XCTAssert` function call in the test. To add an assert,
    we could rewrite the test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But in Swift, a non-failable initializer cannot return `nil`. It always returns
    a valid instance. This means that the `XCTAssertNotNil()` method is useless. We
    do not need it to ensure that we have written enough code to implement the tested
    microfeature. It is not needed to drive the development, and it does not make
    the code better.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed with the next few tests, let's set up the editor in a way
    that makes the TDD workflow easier and faster. First, open `ToDoItemTests.swift`
    in the editor. Then, open the `ToDoItem.swift` to open it in the Assistant Editor.
    Depending on the size of your screen and your preferences, you may prefer to hide
    the navigator again. With this setup, you have the tests and the code side by
    side, and switching from test to code and vice versa takes no time at all. In
    addition to this, since the relevant test is visible while you write the code,
    it can guide the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an itemDescription property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A to-do item can have a description. We would like to have an initializer that
    also takes a description string. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive the implementation, we need a failing test for the existence of this
    initializer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, this code does not compile because there is an extra argument called
    `itemDescription` in the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, we must add an `itemDescription` property of the `String?`
    type to `ToDoItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests. The `test_init_takesTitle()` test will fail (that is, it will
    not compile) because there is a `init` methods as well) can have default values
    for parameters. You will use this feature to set `itemDescription` to `nil` if
    there is no parameter for it in the initializer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `ToDoItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This initializer has two arguments. The second argument has a default value,
    so we do not need to provide both arguments. When the second argument is omitted,
    the default value is used.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the tests to make sure that both tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing a hidden source of bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to use a short initializer by only setting the title, we need to
    define it ourselves. But this also introduces a new source of potential bugs.
    We can remove the two microfeatures we have implemented and still have both tests
    pass. To take a look at how this works, open `ToDoItem.swift` and comment out
    the properties and assignment in the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests. Both tests will still pass. The reason for this is that they
    do not check whether the values of the initializer arguments are set to any `ToDoItem`
    properties. We can easily extend the tests to make sure that the values are set.
    First, let''s change the name of the first test to `test_init_whenGivenTitle_setsTitle()`
    and replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This test does not compile because `ToDoItem` does not have a `title` property
    (it is commented out). This shows that the test is now testing our intention.
    Remove the comment signs for the title property and assignment of the title in
    the initializer, and then run the tests again. All the tests will pass. Now, replace
    the second test with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Remove the remaining comment signs in `ToDoItem` and run the tests again. Both
    the tests will pass again, and they now test that the initializer works.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to use speaking test method names – that is, names that tell
    the story of the test. It's quite common to use a pattern such as `test_<method
    name>_<precondition>_<expected behavior>`. This way, the method name tells all
    that you need to know about the test when a test fails. In this book, we will
    try to follow this pattern, but we will leave out some information (for example,
    the precondition) when the code gets harder to read because of the limited space
    we have. You should develop a pattern and use it in all your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a timestamp property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A to-do item can also have a due date represented by a `timestamp` property:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to make sure we can initialize an instance of `ToDoItem`
    with `timestamp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, this test does not compile because there is an extra argument in the
    initializer. From the implementation of the other properties, we know that we
    have to add a `timestamp` property in `ToDoItem` and set it in the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `ToDoItem` so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests. With a bit of luck, all the tests will pass. But what happens
    if they don't pass on your computer? The reason for this may be because we compare
    two `TimeInterval` structures using `XCTAssertEqual(_:_:)`. `TimeInterval` is
    a type alias for `Double`. Doubles are floating-point numbers and as such are
    hard to compare to each other. Usually, you can't tell if two floating-point numbers
    are equal. You can only tell if they are equal in respect to some accuracy. That's
    why `XCTest` provides an assert method with accuracy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the assert method call in `test_init_setsTimestamp()` with the following
    method call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests. You will see that all the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have to force unwrap `item.timestamp` to use it
    in the assert method with accuracy. The reason for this is that, in contrast to
    `XCTAssertEqual(_:_:)`, `XCTAssertEqual(_:_:accuracy:)` can't compare optional
    values. `timestamp` in `ToDoItem` is optional so that to-do items without due
    dates can be created. Force unwrapping a value in a unit test is not as problematic
    as doing so in production code because a crash in a test is only visible for the
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: But still, Apple added a feature to `XCTest` to deal with optional values better.
    This is so important for the rest of this book that it deserves a section to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with optional values in unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Xcode 11, Apple introduced the `XCTUnwrap(_:)` function to `XCTest`. This
    function unwraps its parameter and returns the unwrapped value. If the parameter
    is `nil`, this function throws an error. In this section, we will use this function
    to improve our test code. Replace the `test_init_setsTimestamp()` test method
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Several things have changed in this code. Let''s look at them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: The method is now marked with `throws`. The reason for this is that we call
    a function that can throw an error. A test method that is marked with `throws`
    fails, when an error is thrown and not caught during its execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `try XCTUnwrap(item.timestamp)`, we try to unwrap the `item.timestamp`
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is assigned to a variable that is used in the `XCTAssertEqual` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you have to deal with optionals in test code, this is the preferred
    way to do so. This way, you get the most valuable information in case the value
    is unexpectedly `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a location property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last property that we would like to be able to set in the initializer of
    `ToDoItem` is its `Location`. The location has a name and can optionally have
    a coordinate. We will use a struct to encapsulate this data into a type. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `ToDoItemTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The test is not finished, but it already fails because Xcode `Location` yet.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Location.swift` to the `ToDoItem` struct, we already know what is
    needed to make the test green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `Location.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines a struct called `Location` with a `name` property and makes the
    test code compilable again. But the test is not finished yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `test_init_whenGivenLocation_setsLocation()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unfortunately, we cannot use the location itself to check for equality yet,
    so the following assert does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that the first two arguments of `XCTAssertEqual()` have
    to conform to the `Equatable` protocol. We will add the protocol's conformance
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this does not compile because the initializer of `ToDoItem` does not
    have an argument called `Location`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `location` property and initializer argument to `ToDoItem`. The result
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests again. All the tests will pass and there will be nothing to refactor.
    We have now implemented a struct to hold `ToDoItem` using TDD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will implement a structure to store location data for
    to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Location struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we added a struct to hold information about the location.
    We will now add tests to make sure that `Location` has the required properties
    and initializer.
  prefs: []
  type: TYPE_NORMAL
- en: These tests could be added to `ToDoItemTests`, but they are easier to maintain
    when the test classes mirror the implementation classes/structs. So, we need a
    new test case class.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ToDoTests` group, and add a unit test case class called `LocationTests`.
    Make sure that you go to **iOS** | **Source** | **Unit Test Case Class** since
    we want to test the iOS code, and Xcode sometimes navigates to **OS X** | **Source**.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the editor to show `LocationTests.swift` on the left-hand side and `Location.swift`
    in the Assistant Editor on the right-hand side. In the test class, add `@testable
    import ToDo` and remove the `testExample()` and `testPerformanceExample()` template
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a coordinate property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The location of a to-do item will be used in the app to show a map in the details.
    A location on a map can be stored using `latitude` and `longitude` values. In
    the following steps, we will add a `coordinate` property to store this information:'
  prefs: []
  type: TYPE_NORMAL
- en: To drive the addition of a `Coordinate` property, we need a failing test. For
    the coordinate, we will use the `CLLocationCoordinate2D` type from the Core Location
    framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `CoreLocation` below the existing import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following test to `LocationTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we created a coordinate and used it to create an instance of `Location`.
    Then, we asserted that the `latitude` and `longitude` values of the location coordinates
    have been set to the correct values. We use values of `1` and `2` in the initializer
    of `CLLocationCoordinate2D` because it also has an initializer that takes no arguments
    (`CLLocationCoordinate2D()`) and sets the `longitude` and `latitude` values to
    zero. We need to make sure that the initializer of `Location` assigns the coordinate
    argument to its property in the test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have omitted the `message` parameter in the `XCTAssertEqual()`
    function. This is because the used assertion already gives enough context to help
    us figure out what we expect in the test. We expect that the two values are the
    same. There is no need to duplicate that information in the message. If you find
    that information useful, feel free to add a message yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The test does not compile because `Location` does not have a `coordinate` property
    yet. Similar to `ToDoItem`, we would like to have a short initializer for locations
    that only have a `name` argument. Therefore, we need to implement the initializer
    ourselves, and we cannot use the one provided by Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents of `Location.swift` with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the tests. All the tests will pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we have intentionally set `name` in the initializer to an empty string.
    This is the easiest implementation that makes the tests pass. But it is not what
    we want. The initializer should set the name of the location to the value in the
    `name` argument. So, we need another test to make sure that `name` is set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `LocationTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the test to make sure it fails. To make the test pass, change `self.name
    = ""` in the initializer of `Location` to `self.name = name`. Run the tests again
    to check whether they all pass now. There is nothing to refactor in the tests
    and their implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the `Location` structure can store a name and an optional coordinate to
    be used in the user interface of the app.
  prefs: []
  type: TYPE_NORMAL
- en: You may have asked yourself, why did we start with the `coordinate` property
    and not the `name` property when implementing that feature? We started with the
    coordinate because it was new terrain for us. We didn't know how to tackle testing
    `Double` values. Sometimes, it can be liberating to work on the most difficult
    problem first. It depends on how you write code. Tests help us make small baby
    steps and therefore help make difficult problems easier to solve.
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to show you how to test the coordinate first, to address the elephant
    in the room. If you feel better when working on the easier tests first, go for
    it. But don't write unnecessary and easy tests just to procrastinate and avoid
    working on the hard ones.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a structure to hold information for to-do items
    using TDD. We learned that TDD means switching between test code and production
    code all the time. In addition, we realized that we should use the assert method
    with the accuracy parameter when we need to compare floating-point numbers. What
    you learned in this chapter will help you write better and more robust unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a structure to manage to-do items. They need
    to be stored somewhere and we need to have a way to add and check off to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to write a test using `XCTAssertEqual(_:_:)` that fails, even if the values
    are equal, because of problems in comparing floating points. Hint: You often get
    this problem when using simple math functions such as addition and multiplication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make `ToDoItem` conform to `Equatable` and rewrite the assertions to take advantage
    of that conformance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
