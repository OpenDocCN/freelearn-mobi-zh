<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. 3D Graphics Rendering</h1></div></div></div><p>The graphics hardware inside the average smartphone is now capable of rendering 3D graphics of a surprisingly high quality for a device that is small enough to fit into your pocket.</p><p>The Marmalade SDK makes using 3D graphics in your own games extremely easy to do, as you will discover when we cover the following topics in this very chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basics of 3D graphics rendering—projection, clipping, lighting, and so on</li><li class="listitem" style="list-style-type: disc">Creating and rendering a simple 3D model entirely in code</li><li class="listitem" style="list-style-type: disc">Exporting 3D model data from a modeling package</li><li class="listitem" style="list-style-type: disc">Loading exported 3D models into memory and rendering them</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>A quick 3D graphics primer</h1></div></div></div><p>Before we get <a id="id473" class="indexterm"/>our hands dirty with rendering code, let's just touch on some of the basics of how 3D rendering can be achieved. If you already have a good handle of 3D rendering techniques then feel free to skip this section.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Describing a 3D model</h2></div></div></div><p>In computer graphics a 3D representation of an object is often referred to as a <a id="id474" class="indexterm"/>
<strong>model</strong>. When we build a model in three dimensions for use in a video game, we create a group of triangles that define the shape of the model. We can also use quadrilaterals to make the modeling process easier, but these ultimately get converted into two triangles when it comes to rendering time.</p><p>The simplest representation of a 3D model<a id="id475" class="indexterm"/> is therefore little more than a big list of vertices which define the triangles required to render the model, but we often specify a host of extra information so we can control exactly how the model should appear on screen.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Specifying a model's vertex stream</h3></div></div></div><p>Every 3D model has a <a id="id476" class="indexterm"/>
<strong>pivot point</strong>, also called its <a id="id477" class="indexterm"/>
<strong>origin</strong>, which is the point around which the model will rotate and scale. In a 3D modeling package this point can be positioned wherever you want it to be, but to make the mathematics easier in a game we would normally treat the point (0, 0, 0) as the pivot point.</p><p>Each triangle in the <a id="id478" class="indexterm"/>
<a id="id479" class="indexterm"/>model is defined by three vertices, and each vertex consists of an x, y, and z component which declares the position of the vertex in what is called <strong>model space</strong>
<a id="id480" class="indexterm"/> (sometimes also referred to as <strong>object space</strong>). This just means that the components of each vertex are relative to the model's pivot point.</p><p>The following diagram shows an example of a cube. The pivot point is positioned at the very centre of the cube and is hence the origin of model space. The corner points use both positive and negative values, but each component has an absolute value of <strong>100</strong>, which yields a cube with edges of length 200 units. For clarity, the three front faces of the cube also show how they have been built from two triangles.</p><div><img src="img/3363_04_01.jpg" alt="Specifying a model's vertex stream"/></div><p>In order to provide Marmalade with the vertices of the cube, we simply use Marmalade's three-component floating pointer vector class <code class="literal">CIwFVec3</code> <a id="id481" class="indexterm"/>to provide an array of vertices. As with the 2D rendering, we've already seen this is called a vertex stream, except that this time the stream consists of three component vectors.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>Specifying a model's index stream</h3></div></div></div><p>You will notice that the corners of the cube in the previous diagram have been labeled with a number as well as their model space coordinates. If we cast our minds back to our work with 2D graphics, we will remember that Marmalade renders polygons by accepting a stream of vertices as input and also a stream of indices that defines the order in which those vertices should be processed.</p><p>The same <a id="id482" class="indexterm"/>
<a id="id483" class="indexterm"/>approach applies when rendering 3D graphics. We specify the index stream as an array of unsigned 16-bit integers (<code class="literal">uint16</code>) and this dictates the order in which the vertices will be read out of the stream for rendering.</p><p>One advantage of using an index stream is that we can potentially refer to the same point several times without having to duplicate it in the vertex stream, thus saving us some memory. Since the index stream is just telling the GPU which order it has to process the data contained in the vertex, color, UV, and normal streams, it can be as long or as short as we want it to be. The index stream doesn't even need to reference every single element of the other streams, meaning we could potentially create one set of streams that can be referenced by multiple different index streams.</p><p>Another advantage of index stream<a id="id484" class="indexterm"/>s is that we can use them to speed up rendering. You will recall that we used the function call <code class="literal">IwGxDrawPrims</code> to render a 2D polygon. To render 3D polygons, we use the exact same call. Each call to this function results in the rendering engine having to perform some initialization, so if we can find a way to minimize the number of draw calls we have to make, we can render the game world more quickly.</p><p>We can use the index stream to achieve this by inserting degenerate polygons into the polygon render list. A <strong>degenerate polygon</strong>
<a id="id485" class="indexterm"/> is one that does not modify any pixels when it is drawn and this is achieved by ensuring that all the vertices that make up the polygon will lie on the same line. Most graphics hardware are clever enough to recognize a degenerate polygon and will not waste time trying to render it.</p><p>As an example, let's assume we are rendering some triangle strips. We could render them by calling <code class="literal">IwGxDrawPrims</code> <a id="id486" class="indexterm"/>twice, or we could join the two strips with some degenerate polygons and render them both with a single call to <code class="literal">IwGxDrawPrims</code>. We can continue to do this to join together as many triangle strips as we want.</p><p>How do we specify the degenerate triangle? The easiest way, shown in the following diagram, is to duplicate the last point of the first strip and the first point of the second strip. This yields four degenerate triangles (A3A4A4, A4A4B0, A4B0B0, B0B0B1) but is preferable to making several draw calls. The dotted line in the following diagram shows the extra degenerate triangles (which collapse to form a line!) that join the strips together:</p><div><img src="img/3363_04_02.jpg" alt="Specifying a model's index stream"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>Specifying a model's color, UV, and normal streams</h3></div></div></div><p>Just as with 2D <a id="id487" class="indexterm"/>
<a id="id488" class="indexterm"/>
<a id="id489" class="indexterm"/>
<a id="id490" class="indexterm"/>
<a id="id491" class="indexterm"/>
<a id="id492" class="indexterm"/>rendering, there are a number of other stream types we can supply to make the polygons we render look more interesting. We can provide both color and texture UV streams in exactly the same way we did when rendering in two dimensions, but we can also specify a third stream type called a <a id="id493" class="indexterm"/> <strong>normal stream</strong>.</p><p>In 3D mathematics, a <strong>normal vector</strong>
<a id="id494" class="indexterm"/> is defined as the vector which is perpendicular to two other non-parallel vectors, or in other words a vector that points in the direction in which the polygon is facing. The following diagram shows an example illustrating this:</p><div><img src="img/3363_04_12.jpg" alt="Specifying a model's color, UV, and normal streams"/></div><p>Why is the normal stream useful? Well, it allows us to simulate the effects of lights on our 3D model. By providing each vertex of our model with a <strong>unit normal</strong>
<a id="id495" class="indexterm"/> (that is, a vector that points in the direction of the polygon's normal and which has a length of one unit), we can calculate the amount of light reflected from that vertex and adjust the color it is rendered with accordingly.</p><p>Real time lighting of a 3D model can be a time-intensive task, so when writing a game we try to avoid doing so when possible in order to speed up rendering. If we do not want to light a 3D model, there is no need to specify a normal stream; so, by not lighting a model we save memory too.</p><p>There are a couple of<a id="id496" class="indexterm"/>
<a id="id497" class="indexterm"/>
<a id="id498" class="indexterm"/>
<a id="id499" class="indexterm"/>
<a id="id500" class="indexterm"/>
<a id="id501" class="indexterm"/> points to bear in mind when specifying these additional streams.</p><p>Firstly, Marmalade expects the number of colors, UVs, and normals provided to match the number of vertices provided. While you can specify streams of different lengths, this will normally cause an assert to be fired and obviously it could yield unexpected results when rendering.</p><p>Secondly, and perhaps most importantly, these additional streams may require us to add extra copies of our vertices into the vertex stream since we can only provide a single index stream.</p><p>Take the example of a cube where each vertex is a corner point of three different faces of the cube. Since each face points in a different direction, we will need to duplicate each vertex three times so it can be referenced in the index stream along with the three different normal vectors.</p><div><img src="img/3363_04_13.jpg" alt="Specifying a model's color, UV, and normal streams"/></div><p>We can also run into the same problem when the UV or color at a vertex varies across each polygon that it forms a part of.</p><p>For each different <a id="id502" class="indexterm"/>
<a id="id503" class="indexterm"/>
<a id="id504" class="indexterm"/>
<a id="id505" class="indexterm"/>
<a id="id506" class="indexterm"/>
<a id="id507" class="indexterm"/>combination of color, UV, and normal we encounter, we need to provide an additional copy of each vertex, and therefore also an additional color, UV, and normal value so that all the streams are the same length.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Performing 3D to 2D projection</h2></div></div></div><p>When rendering our <a id="id508" class="indexterm"/>3D world to the display, we have to somehow convert our 3D model vertex data into 2D screen coordinates before we can draw anything. This process is called <strong>projection</strong>
<a id="id509" class="indexterm"/> and is normally carried out using matrix mathematics to convert vertices between coordinate systems until we end up with screen coordinates that allow the triangles that make up a 3D model to be rendered on screen.</p><div><img src="img/3363_04_14.jpg" alt="Performing 3D to 2D projection"/></div><p>The following sections<a id="id510" class="indexterm"/> provide an overview of the steps involved in projecting a point on to the screen to make sure you are familiar with the key concepts involved. A thorough explanation of the mathematics of 3D graphics is beyond the scope of this book, so it is expected that you will be familiar with what a matrix is, and with geometric operations such as rotations, scaling, and translations.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>Understanding matrices for 3D graphics</h3></div></div></div><p>Think back to school math lessons and you will hopefully remember matrices being described as a useful tool when trying to perform operations such as rotations, translations, and scaling on vectors.</p><p>My personal <a id="id511" class="indexterm"/>
<a id="id512" class="indexterm"/>recollection about learning matrices was that they seemed slightly magical at the time. Here was a grid of numbers that could be used to perform a range of really useful geometric operations and, what's more, you could combine several matrices by multiplying them together to perform several operations in one go. The concept itself made sense, but there were so many numbers involved that it seemed a bit bewildering.</p><p>In 3D geometry we generally use a 4 x 4 matrix, with the top left 3 x 3 grid of numbers representing the rotation and scaling part of the matrix, and the first three numbers of the bottom row representing the required translation.</p><p>While the translation part made perfect sense to me, the 3 x 3 rotation and scaling part of the matrix was something I never really had a good handle on until the day I found out that what this part of the matrix actually represents is the size and direction of the x, y, and z axes.</p><p>Take a look at the following image that shows the <strong>identity matrix</strong>
<a id="id513" class="indexterm"/> for a 4 x 4 matrix. All this means is that every element in the matrix is <code class="literal">0</code> except for those in the top-left to bottom-right diagonal, which are all <code class="literal">1</code>:</p><div><img src="img/3363_04_03.jpg" alt="Understanding matrices for 3D graphics"/></div><p>Notice that the first <a id="id514" class="indexterm"/>
<a id="id515" class="indexterm"/>three numbers on the top row are (1, 0, 0), which just so happens to be a unit vector along the x axis. Similarly, the second row is (0, 1, 0), which represents a unit vector along the y axis and the third row (0, 0, 1) is a unit vector along the z axis.</p><p>Once I realized this, it became much more obvious how to create matrices to perform different kinds of geometric operations.</p><p>Want a rotation around the y axis? Just work out vectors for the directions in which the x axis and z axis would need to lie for the desired rotation, and slot these into the relevant parts of the matrix. Similarly, a scale operation just means that we provide a non-unit-sized vector for each axis we want to scale along.</p><p>Some of you may be reading this and thinking "that's obvious", but if this helps just one person to get a better understanding of how to understand matrix mathematics, my work is done!</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>Converting between coordinate systems</h3></div></div></div><p>When we looked at how a 3D model is represented in terms of data, we talked about the vertices of the model being in model space. In order to use these vertices for rendering, we therefore have to <a id="id516" class="indexterm"/>
<a id="id517" class="indexterm"/>convert our model space vertices into screen coordinates.</p><p>The first step in this process is to use a <strong>model matrix</strong>
<a id="id518" class="indexterm"/> to convert the vertices from model space into <a id="id519" class="indexterm"/>
<strong>world space</strong>. Each vertex in the model is multiplied by the model matrix, which will first rotate and scale the vertices so that the model is orientated correctly, then translate each point so that the model's pivot point is now at the translation provided in the matrix.</p><p>Now that all our vertices are positioned correctly in our virtual world, the next step is to convert them into <a id="id520" class="indexterm"/>
<strong>view space</strong>, which is the coordinate system defined by the position and orientation of our viewpoint, which for obvious reasons is normally referred to as our camera. We do this by providing another matrix called the <strong>view matrix</strong>
<a id="id521" class="indexterm"/> (or <strong>camera matrix</strong>
<a id="id522" class="indexterm"/> if you prefer), which will rotate, scale, and translate the world space vertices so that they are now relative to our camera view.</p><p>With the vertices <a id="id523" class="indexterm"/>
<a id="id524" class="indexterm"/>now in view space, the final operation is to convert the vertices into 2D screen coordinates. We have two ways of doing this, these being an <strong>orthographic projection</strong>
<a id="id525" class="indexterm"/> or a <a id="id526" class="indexterm"/> <strong>perspective projection</strong>.</p><p>An orthographic projection takes the view space coordinates and just scales and translates the x and y components of each vertex to put them onto the screen. The z component of the vertex plays no part in calculating the actual screen coordinates but it is used for working out the drawing order of polygons since it is used as a depth value.</p><p>However, in most cases we use a perspective projection. Again the x and y components of each view space vertex are used to generate the x and y screen coordinates, but this time they are divided by the z component of the vertex, which has the effect of making objects that are further away appear smaller.</p><p>The components are also multiplied by a constant value called the <strong>perspective multiplier</strong>
<a id="id527" class="indexterm"/>. This value is actually the distance at which the <strong>view plane</strong>
<a id="id528" class="indexterm"/> lies from the camera. The view plane is the plane which contains the rectangular area of the screen display.</p><p>Normally, when we think about a camera view it is more convenient to think about the <a id="id529" class="indexterm"/>
<strong>field of view</strong>, which is the horizontal angle of our viewing cone. The following diagram shows how we can convert this angle into the correct perspective multiplier value:</p><div><img src="img/3363_04_04.jpg" alt="Converting between coordinate systems"/></div><p>The next part of perspective projection<a id="id530" class="indexterm"/> is to translate the projected point. Normally we want a point that is <a id="id531" class="indexterm"/>
<a id="id532" class="indexterm"/>directly in front of the camera to be in the center of the screen, so we would add an offset of half the screen width to the x component and half the screen height to the y-component. It is possible to specify a different offset position, which is particularly useful if we ever want to display a 3D model as part of a game's user interface. Let's say you wanted to draw a 3D model of a collectable object that the player has just picked up at the top right of the screen. Specifying the offset to be this screen position is much easier than trying to calculate a position in 3D space relative to the camera position that equates to the required area of the screen.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>Clipping planes</h3></div></div></div><p>We've already discussed the <a id="id533" class="indexterm"/>view plane as being the plane which contains the final screen display, but there are some further planes which are used to help speed up rendering and also avoid some strange graphical glitches from occurring.</p><p>First we have the <strong>far clip plane</strong>
<a id="id534" class="indexterm"/> and the <a id="id535" class="indexterm"/>
<strong>near clip plane</strong>, which lie parallel to the view plane. We tell Marmalade where we want these planes to reside by supplying the perpendicular distance of these planes from the camera view point.</p><p>The far clip plane prevents polygons that are too far away from the camera from being rendered, while the near clip plane, unsurprisingly, prevents polygons that are too close to the camera from being rendered. The near clip plane is particularly important because if we were not to use it we would start to see models that lie behind the camera being rendered on screen.</p><p>You should generally try to<a id="id536" class="indexterm"/> keep the far and near clip planes as close together as possible, as these values are also used for calculating depth buffer values. If the planes are too far apart, you can start to encounter render issues that are sometimes called <strong>shimmering</strong>
<a id="id537" class="indexterm"/> or <a id="id538" class="indexterm"/>
<strong>Z-fighting</strong>. These can occur when there is not enough resolution in the depth buffer values, which results in far distance polygons rendering with jagged edges or worse still, randomly poke through each other as they or the camera are moved. The following image shows another example of Z-fighting that can occur when trying to render two overlapping co-planar polygons:</p><div><img src="img/3363_04_15.jpg" alt="Clipping planes"/></div><p>There are also four more <a id="id539" class="indexterm"/>clipping planes named left, right, top, and bottom. These are planes which pass through the camera position and one of the left, right, top, or bottom borders of the screen display area on the view plane. Together they form a pyramid-shaped volume that emanates from the camera and defines the part of 3D space that is visible and could therefore appear on screen.</p><p>The clipping planes are managed automatically for us by Marmalade, and they are very useful as they allow us to quickly reject an entire model from being submitted for rendering if it is completely off screen. The off-screen check is performed using a bounding sphere for the model we are rendering, which is simply a sphere centered at the model's pivot point that encompasses all the vertices of the model. The bounding sphere can be quickly tested against all six clip planes and the model can be skipped if the bounding sphere is completely outside the clipping volume.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Lighting</h2></div></div></div><p>To finish up our <a id="id540" class="indexterm"/>3D primer, let's take a quick look at how real-time lighting is achieved. We won't dwell on the mathematics of it all, since Marmalade mostly takes care of this for us, so instead we'll just explain the different types of lighting we can take advantage of.</p><p>Each of the lighting types we are about to discuss can be enabled or disabled whenever you want. Disabling different lighting types can yield faster render times.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Emissive lighting</h3></div></div></div><p>The simplest type of lighting <a id="id541" class="indexterm"/>Marmalade provides is <a id="id542" class="indexterm"/>
<strong>emissive lighting</strong>, which is little more than the amount of color that a rendered polygon will naturally have. The emissive lighting color is provided by the <code class="literal">CIwMaterial</code> instance<a id="id543" class="indexterm"/> that is set when rendering the polygon.</p><p>Emissive lighting is useful if you want to draw polygons in a single flat color, but normally we want a bit more flexibility than that, so we might set a color stream instead, or use one of the other forms of lighting.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>Ambient lighting</h3></div></div></div><p>
<strong>Ambient lighting</strong>
<a id="id544" class="indexterm"/> provides the background level of light in our scene, such <a id="id545" class="indexterm"/>as the light which might be provided by the Sun.</p><p>Without ambient lighting, any polygon that is not facing a light source directly would have very little light applied to it and so would appear black. Normally this is not very desirable, so we can use ambient lighting to provide a base level of color and brightness to our polygons.</p><p>In Marmalade, we set a global ambient lighting term as an RGB color. The <code class="literal">CIwMaterial</code> instance used when rendering also has an ambient light value that is combined with the global ambient light. If the material ambient light is set to bright white, the polygon will be rendered with the full amount of the global ambient light.</p><p>If the global ambient lighting is disabled, the material ambient color is used directly to control the color of the rendered polygons. This provides an easy way of brightening or darkening a model at rendering time.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec51"/>Diffuse lighting</h3></div></div></div><p>In order to use <a id="id546" class="indexterm"/>
<strong>diffuse lighting</strong>
<a id="id547" class="indexterm"/> our model data must provide a normal stream. A diffuse light comprises of both a color and a direction in which the light is pointing. The light's direction vector is combined with the normal vector for each vertex in the model using the dot product operation.</p><p>The result of the <a id="id548" class="indexterm"/>dot product operation is multiplied by the global diffuse lighting <a id="id549" class="indexterm"/>color and the current <code class="literal">CIwMaterial</code> diffuse color or the RGB value from the color stream, if one has been provided. This will yield the final color value that is used when rendering the polygon to the screen.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec52"/>Specular lighting</h3></div></div></div><p>As with diffuse lighting, <strong>specular lighting</strong>
<a id="id550" class="indexterm"/> can only work if we have provided a normal stream. It also needs a diffuse light to be specified as it relies on the direction of the <a id="id551" class="indexterm"/>diffuse light.</p><p>This type of lighting allows us to make a model appear shinier by causing it to briefly become brighter when it is facing the direction of the diffuse light.</p><p>We can specify both a global and a specular light color specific to <code class="literal">CIwMaterial</code>, and additionally the material also provides a setting for the <strong>specular power</strong>
<a id="id552" class="indexterm"/>. This value allows us to narrow down the response of the specular lighting. A higher number means that the vertex normal must be almost parallel to the lighting direction before the specular lighting will take effect.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Using IwGx to render 3D graphics</h1></div></div></div><p>Remember <a id="id553" class="indexterm"/>
<a id="id554" class="indexterm"/>when we were looking at 2D graphics rendering in <a class="link" href="ch02.html" title="Chapter 2. Resource Management and 2D Graphics Rendering">Chapter 2</a>, <em>Resource Management and 2D Graphics Rendering</em>, I said we would be using IwGx because it would make the transition to rendering 3D graphics that much easier. Now's the time to see if my claim was true!</p><p>In this section, we shall look at how we can implement the 3D equivalent of the "Hello World" program—a spinning cube.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Preparing IwGx for 3D rendering</h2></div></div></div><p>As with 2D rendering, the <a id="id555" class="indexterm"/>
<a id="id556" class="indexterm"/>very first thing we need to do is initialize the IwGx API by calling <code class="literal">IwGxInit</code>, and of course we should call <code class="literal">IwGxTerminate</code> at the end of our program.</p><p>With IwGx ready to go we next need to set up our projection. We're going to be using a perspective projection, so we need to be able to specify the perspective multiplier value that we want to use. The code to do this is as follows:</p><div><pre class="programlisting">IwGxSetPerspMul((float) IwGxGetScreenWidth() * 0.5f);</pre></div><p>This line of code sets the perspective multiplier up, to provide a 90 degree field of view. See the section <em>Converting Between Coordinate Systems</em> earlier in this chapter for more information on how to calculate the required perspective multiplier value.</p><p>Next we have to set the far and near clipping planes' distances. For our demo purposes we'll choose a value of <code class="literal">10</code> for the near plane and <code class="literal">1000</code> for the far plane; these values are set as follows:</p><div><pre class="programlisting">IwGxSetFarZNearZ(1000.0f, 10.0f);</pre></div><p>These values are in view <a id="id557" class="indexterm"/>
<a id="id558" class="indexterm"/>space units and can be set to any value greater than zero (the far value should be greater than the near value too!) that works well for the needs of our game. Normally it is the far clip distance that is most important, as it needs to be set far enough out that our world is rendered satisfactorily, but not so far that the frame rate suffers because we are rendering too much.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>You may be wondering why these numbers have been written as <code class="literal">10.0f</code> and not just 10 or 10.0? The reason is to ensure that the compiler treats these values as a single precision <code class="literal">float</code> value. The latter two forms will both be interpreted as a <code class="literal">double</code> and this can lead to a time consuming conversion from <code class="literal">double</code> to <code class="literal">float</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Setting lighting information</h2></div></div></div><p>In order to make our<a id="id559" class="indexterm"/> spinning cube look a little more attention grabbing, we'll set up some lights so that as the cube spins its faces change color accordingly. The lighting support provided by Marmalade may look a little limited, but is generally adequate for most mobile games' needs.</p><p>Marmalade only allows us to define a single ambient light and a single diffuse light. Let's start by setting the global ambient lighting value.</p><p>The first function we call is<a id="id560" class="indexterm"/> <code class="literal">IwGxSetLightType</code>, which takes an ID number to identify the light we wish to modify and a definition describing the type of light we are specifying. Presumably this API has been chosen so that Marmalade can easily be made to support more lights in the future, but for now the ID number can only be zero or one, and the light type must be one of <code class="literal">IW_GX_LIGHT_AMBIENT</code>, <code class="literal">IW_GX_LIGHT_DIFFUSE</code>, or <code class="literal">IW_GX_LIGHT_UNUSED</code>. The latter value can be used to disable the light.</p><p>With the type of light taken care of, we set the color of light using the function call<a id="id561" class="indexterm"/> <code class="literal">IwGxSetLightCol</code>. There are two versions of this function. Both take the ID of the light we wish to modify, but the RGB color of the light can either be specified as three <code class="literal">uint8</code> values for red, green, and blue, or a pointer to a <code class="literal">CIwColour</code> instance can be supplied instead.</p><p>The following code sets the light with ID zero to be an ambient light with a mid-grey color:</p><div><pre class="programlisting">IwGxSetLightType(0, IW_GX_LIGHT_AMBIENT);
IwGxSetLightCol(0, 128, 128, 128);</pre></div><p>Now let's create a diffuse light with a specular highlight. We'll need two additional functions to do this, <code class="literal">IwGxSetLightSpecularCol</code> to set the color of the specular highlight, and <code class="literal">IwGxSetLightDirn</code> to set the direction in which the light is pointing. The direction is specified as a unit vector in terms of world space coordinates. Here's some code to illustrate this:</p><div><pre class="programlisting">CIwFVec3 lLightDir(1000.0f, 0.0f, 1000.0f);
lLightDir.Normalise();
 
IwGxSetLightType(1, IW_GX_LIGHT_DIFFUSE);
IwGxSetLightCol(1, 128, 128, 128);
IwGxSetLightSpecularCol(1, 200, 200, 200, 255);
IwGxSetLightDirn(1, &amp;lLightDir);</pre></div><p>This code snippet <a id="id562" class="indexterm"/>sets up the light ID one to be a diffuse light with mid-grey intensity and a brighter grey specular highlight. The light is pointing at a 45 degree angle between the x and z axes of the world.</p><p>Our lights have now been initialized, so all that is left to do is let Marmalade know we want to switch them on! There are a number of functions available to allow us to do this. We can either use <code class="literal">IwGxLightingOn</code> and <code class="literal">IwGxLightingOff</code> to enable or disable all the initialized light sources, or we can enable each part of the lighting model independently. The following example code disables emissive lighting but enables ambient, diffuse, and specular lighting:</p><div><pre class="programlisting">IwGxLightingAmbient(true);
IwGxLightingDiffuse(true);
IwGxLightingEmissive(false);
IwGxLightingSpecular(true);</pre></div><p>Since we are using specular lighting, there is one more thing to do. The material that is used to render our polygons must have a specular color and power specified. The material's specular color is used to modulate the global specular color, while the power value indicates how close the vertex normal must be to the light direction for the specular highlight to kick in. The power value is a <code class="literal">uint8</code> value and only very low values (that is, less than 8) produce notable differences in the rendered effect. Here is the code to illustrate this:</p><div><pre class="programlisting">CIwMaterial* lpMaterial = new CIwMaterial;
lpMaterial-&gt;SetColSpecular(255, 255, 255);
lpMaterial-&gt;SetSpecularPower(3);</pre></div><div><div><h3 class="title"><a id="note28"/>Note</h3><p>The previous examples are just making use of Marmalade's built-in lighting model since it is easy to use and works well enough for most needs. However, there is absolutely no reason we have to use this lighting model, as there is nothing stopping us from generating our own color stream using whatever lighting algorithm we want to use. Alternatively we could employ OpenGL ES 2.0 shaders, although discussion of this particular topic is beyond the scope of this book.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Model data for the cube</h2></div></div></div><p>We're going to <a id="id563" class="indexterm"/>
<a id="id564" class="indexterm"/>render a lit cube with a different color on each face, so we need to provide some data streams for the vertices, colors, and normals, and an index stream to show how this data should be interpreted by the rendering engine. Since we are not using textures in this example, there is no need to provide a UV stream.</p><p>We also want to be as efficient as possible in our drawing, so our aim is to draw the entire cube with just a single call to <code class="literal">IwGxDrawPrims</code>. To do so we'll need to have three copies of each vertex (one for each face that the vertex is part of) so we can assign different colors and normals to it, and we'll also need to specify some degenerate triangles in our index stream to join all the faces together into one big triangle strip.</p><p>Let's start with the vertex stream. We allocate an array of <code class="literal">CIwFVec3</code> and initialize it with the vertex data. The cube pivot point will be dead center, so all the vertex coordinates will have the same magnitude.</p><div><pre class="programlisting">const uint32 lVertexCount = 24;
CIwFVec3* v = new CIwFVec3[lVertexCount];
v[0].x = 100.0f;    v[0].y = -100.0f;  v[0].z = -100.0f;
v[1].x = -100.0f;   v[1].y = -100.0f;  v[1].z = -100.0f;
v[2].x = 100.0f;    v[2].y = 100.0f;   v[2].z = -100.0f;
v[3].x = -100.0f;   v[3].y = 100.0f;   v[3].z = -100.0f;
v[4].x = 100.0f;    v[4].y = -100.0f;   v[4].z = 100.0f;
v[5].x = 100.0f;    v[5].y = -100.0f;   v[5].z = -100.0f;
v[6].x = 100.0f;    v[6].y = 100.0f;    v[6].z = 100.0f;
v[7].x = 100.0f;    v[7].y = 100.0f;    v[7].z = -100.0f;
v[8].x = 100.0f;    v[8].y = -100.0f;   v[8].z = 100.0f;
v[9].x = 100.0f;    v[9].y = 100.0f;    v[9].z = 100.0f;
v[10].x = -100.0f;  v[10].y = -100.0f;  v[10].z = 100.0f;
v[11].x = -100.0f;  v[11].y = 100.0f;   v[11].z = 100.0f;
v[12].x = -100.0f;  v[12].y = -100.0f;  v[12].z = 100.0f;
v[13].x = -100.0f;  v[13].y = 100.0f;   v[13].z = 100.0f;
v[14].x = -100.0f;  v[14].y = -100.0f;  v[14].z = -100.0f;
v[15].x = -100.0f;  v[15].y = 100.0f;   v[15].z = -100.0f;
v[16].x = -100.0f;  v[16].y = 100.0f;   v[16].z = -100.0f;
v[17].x = -100.0f;  v[17].y = 100.0f;   v[17].z = 100.0f;
v[18].x = 100.0f;   v[18].y = 100.0f;   v[18].z = -100.0f;
v[19].x = 100.0f;   v[19].y = 100.0f;   v[19].z = 100.0f;
v[20].x = -100.0f;  v[20].y = -100.0f;  v[20].z = -100.0f;
v[21].x = -100.0f;  v[21].y = -100.0f;  v[21].z = 100.0f;
v[22].x = 100.0f;   v[22].y = -100.0f;  v[22].z = -100.0f;
v[23].x = 100.0f;   v[23].y = -100.0f;  v[23].z = 100.0f;</pre></div><p>The vertices have been ordered a face at a time, so the first four vertices form the front of the cube, the next four the right hand face, and so on. You are free to specify the order however you see fit, since ultimately it will be the index stream that determines how the individual triangles will be rendered.</p><p>Now we'll create <a id="id565" class="indexterm"/>
<a id="id566" class="indexterm"/>the normal stream. Normals in Marmalade are also specified as instances of <code class="literal">CIwFVec3</code>, and they are expected to have unit length. This means that the magnitude of the vector should be one. Here's a code snippet that will do the job:</p><div><pre class="programlisting">CIwFVec3* n = new CIwFVec3[lVertexCount];
n[0].x = 0.0f;      n[0].y = 0.0f;    n[0].z = -1.0f;
n[1].x = 0.0f;      n[1].y = 0.0f;    n[1].z = -1.0f;
n[2].x = 0.0f;      n[2].y = 0.0f;    n[2].z = -1.0f;
n[3].x = 0.0f;      n[3].y = 0.0f;    n[3].z = -1.0f;
n[4].x = 1.0f;      n[4].y = 0.0f;    n[4].z = 0.0f;
n[5].x = 1.0f;      n[5].y = 0.0f;    n[5].z = 0.0f;
n[6].x = 1.0f;      n[6].y = 0.0f;    n[6].z = 0.0f;
n[7].x = 1.0f;      n[7].y = 0.0f;    n[7].z = 0.0f;
n[8].x = 0.0f;      n[8].y = 0.0f;    n[8].z = 1.0f;
n[9].x = 0.0f;      n[9].y = 0.0f;    n[9].z = 1.0f;
n[10].x = 0.0f;     n[10].y = 0.0f;   n[10].z = 1.0f;
n[11].x = 0.0f;     n[11].y = 0.0f;   n[11].z = 1.0f;
n[12].x = -1.0f;    n[12].y = 0.0f;   n[12].z = 0.0f;
n[13].x = -1.0f;    n[13].y = 0.0f;    n[13].z = 0.0f;
n[14].x = -1.0f;    n[14].y = 0.0f;    n[14].z = 0.0f;
n[15].x = -1.0f;    n[15].y = 0.0f;    n[15].z = 0.0f;
n[16].x = 0.0f;     n[16].y = 1.0f;    n[16].z = 0.0f;
n[17].x = 0.0f;     n[17].y = 1.0f;    n[17].z = 0.0f;
n[18].x = 0.0f;     n[18].y = 1.0f;    n[18].z = 0.0f;
n[19].x = 0.0f;     n[19].y = 1.0f;    n[19].z = 0.0f;
n[20].x = 0.0f;     n[20].y = -1.0f;   n[20].z = 0.0f;
n[21].x = 0.0f;     n[21].y = -1.0f;   n[21].z = 0.0f;
n[22].x = 0.0f;     n[22].y = -1.0f;   n[22].z = 0.0f;
n[23].x = 0.0f;     n[23].y = -1.0f;   n[23].z = 0.0f;</pre></div><p>Now we need a color stream. Just as with 2D rendering, this requires an array of <code class="literal">CIwColour</code> instances. Here comes the code snippet!</p><div><pre class="programlisting">CIwColour* c = new CIwColour[lVertexCount];
c[0].Set(255, 0, 0, 255);
c[1].Set(255, 0, 0, 255);
c[2].Set(255, 0, 0, 255);
c[3].Set(255, 0, 0, 255);
c[4].Set(255, 255, 0, 255);
c[5].Set(255, 255, 0, 255);
c[6].Set(255, 255, 0, 255);
c[7].Set(255, 255, 0, 255);
c[8].Set(0, 255, 0, 255);
c[9].Set(0, 255, 0, 255);
c[10].Set(0, 255, 0, 255);
c[11].Set(0, 255, 0, 255);
c[12].Set(0, 0, 255, 255);
c[13].Set(0, 0, 255, 255);
c[14].Set(0, 0, 255, 255);
c[15].Set(0, 0, 255, 255);
c[16].Set(0, 255, 255, 255);
c[17].Set(0, 255, 255, 255);
c[18].Set(0, 255, 255, 255);
c[19].Set(0, 255, 255, 255);
c[20].Set(255, 128, 0, 255);
c[21].Set(255, 128, 0, 255);
c[22].Set(255, 128, 0, 255);
c[23].Set(255, 128, 0, 255);</pre></div><p>Finally, it's time<a id="id567" class="indexterm"/>
<a id="id568" class="indexterm"/> for the index stream to be created. Again, as with 2D rendering, this is just an array of <code class="literal">uint16</code> values which indicate the order in which elements of the streams should be accessed. Here's the code:</p><div><pre class="programlisting">const uint32 lIndexCount = 34;
uint16* i = new uint16[lIndexCount];
 
// Front face (red)
i[0] = 0;  i[1] = 1;  i[2] = 2;  i[3] = 3;
// Degenerate
i[4] = 3;  i[5] = 7;
// Right face (yellow)
i[6] = 7;  i[7] = 6;  i[8] = 5;  i[9] = 4;
// Degenerate
i[10] = 4;  i[11] = 9;
// Back face (green)
i[12] = 9;  i[13] = 11;  i[14] = 8;  i[15] = 10;
// Degenerate
i[16] = 10;  i[17] = 12;
// Left face (blue)
i[18] = 12;  i[19] = 13;  i[20] = 14;  i[21] = 15;
// Degenerate
i[22] = 15;  i[23] = 16;
// Bottom face (cyan)
i[24] = 16;  i[25] = 17;  i[26] = 18;  i[27] = 19;
// Degenerate
i[28] = 19;  i[29] = 23;
// Top face (orange)
i[30] = 23;  i[31] = 21;  i[32] = 22;  i[33] = 20;</pre></div><p>Note than the first <a id="id569" class="indexterm"/>
<a id="id570" class="indexterm"/>four values in the stream define the first full face of the cube. The next two values form a degenerate triangle that allows us to link the first face to the second face without actually rendering anything. As we saw earlier in this chapter, the easiest way to link two triangle strips is to repeat the last index of the first strip and start the next strip with two copies of its first index. This pattern continues until we've drawn the last face of the cube.</p><p>The order in which the vertices are specified is the most important consideration, as we must ensure we get this correct for the culling mode we'll be using. For back-face culling (so faces that are away from the camera are not rendered) we need the vertex order to be in anti-clockwise order for the first triangle specified.</p><p>As we are using triangle strips, the order of the vertices actually alternates between anti-clockwise and clockwise. Normally we don't have to worry about this too much since the natural order of the vertices in the strip takes care of it, but it can cause problems when you try to join together triangle strips that contain an odd number of vertices.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>The general rule for joining triangle strips with degenerate triangles is that a strip with an odd number of points will require the order of the points in the next strip to be reversed. For example, if your first triangle strip contains an odd number of points, the first triangle of the next strip will need to be specified in clockwise rather than anti-clockwise order; otherwise it will not be culled correctly.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>The view matrix</h2></div></div></div><p>When rendering <a id="id571" class="indexterm"/>3D graphics, we need to be able to provide a position and direction that we want to view our game world from. We do this by supplying a view or camera matrix; in Marmalade this can be done using an instance of the <code class="literal">CIwFMat</code> class.</p><p>The <code class="literal">CIwFMat</code> class<a id="id572" class="indexterm"/> represents a 4 x 4 matrix using a 3 x 3 array of <code class="literal">float</code> for the rotation part, and <code class="literal">CIwFVec3</code> for the translation part. The remaining elements of the 4 x 4 matrix (that is, the right-most column of numbers) are fixed to be the same as the identity matrix (0, 0, 0, and 1 from top to bottom of the column). These values never have any influence on normal 3D transformations; so by leaving them out we save memory, and also the matrix multiplication code can be made slightly more efficient by not having to perform multiplications for these parts of the matrix.</p><p>Time to create a suitable <a id="id573" class="indexterm"/>view matrix. For the purposes of our spinning cube, it would be good if we could specify a position for the camera and then calculate the correct rotation for the matrix to view our cube. Luckily the matrix classes have a method called <code class="literal">LookAt</code> that makes this easy to do:</p><div><pre class="programlisting">CIwFMat vm;
vm.t.x = 0.0f;  vm.t.y = 0.0f;  vm.t.z = -400.0f;
vm.LookAt(vm.t, CIwFVec3::g_Zero, CIwFVec3::g_AxisY);</pre></div><p>The previous code declares a new <code class="literal">CIwMat</code> instance and sets its translation to (0, 0, -400). We then call the<a id="id574" class="indexterm"/> <code class="literal">LookAt</code> method, which is passed the position we want the camera to be placed at, the point in space we want it to be orientated towards, and a unit vector in the vertically up direction.</p><p>Marmalade's default coordinate system when rendering in 3D has the x axis positive direction running from left to right across the screen, while the z axis positive direction runs into the screen. However, the positive y axis runs in a direction from the top of the screen to the bottom, which may not be what you initially expect. We are used to thinking about the height above the ground as a positive number, but in Marmalade it would be negative.</p><p>Once we have a view matrix, we can call the function <code class="literal">IwGxSetViewMatrix</code> with a <code class="literal">const</code> pointer<a id="id575" class="indexterm"/> to the matrix.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>The model matrix</h2></div></div></div><p>The <a id="id576" class="indexterm"/>model matrix is used to position our 3D model in the world and allow it to be rotated or scaled as desired. As with the view matrix, the model matrix can be specified using a <code class="literal">CIwFMat</code> instance.</p><p>For our spinning cube we will create a matrix that spins the cube around the x and y axes. We do this by creating two matrices, one for x axis rotation and another for y axis rotation, which we then multiply together. We will be positioning our cube at the world origin.</p><div><pre class="programlisting">CIwFMat lModelMatrix;
lModelMatrix.SetRotY(lRotationY);
CIwFMat lRotX;
lRotX.SetRotX(lRotationX);
lModelMatrix.PreMult(lRotX);</pre></div><p>The code shown declares two instances of <code class="literal">CIwFMat</code> and uses the methods <code class="literal">SetRotY</code> and <code class="literal">SetRotX</code> to generate the rotation matrices around the y and x axes respectively. The rotation angles are provided by two variables <code class="literal">lRotationY</code> and <code class="literal">lRotationX</code>, which are both of the type <code class="literal">float</code> and represent an angle (in radians) to rotate by. If we increase the values of these two <a id="id577" class="indexterm"/>variables with each iteration of the main game loop, it will change the orientation of the cube and make it appear to rotate when rendered.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>Be careful when using the<a id="id578" class="indexterm"/> <code class="literal">SetRotX</code>,<a id="id579" class="indexterm"/> <code class="literal">SetRotY</code>, and <code class="literal">SetRotZ</code> <a id="id580" class="indexterm"/>methods of the matrix classes. These methods take two further <code class="literal">bool</code> parameters that allow the translation part of the matrix and any elements of the 3 x 3 rotation part of the matrix that are not used in the rotation to be zeroed. Both of these parameters default to <code class="literal">true</code>; so, in particular, if you set up a translation in the matrix before calling one of these methods, it will get lost unless you specify <code class="literal">false</code> as the second parameter.</p></div></div><p>Once we have our two rotation matrices, we multiply them together to generate the final model matrix using the<a id="id581" class="indexterm"/> <code class="literal">PreMult</code> method. The order in which matrices are multiplied together is very important as the end rotation will vary depending on the order used. Marmalade provides us with <code class="literal">PreMult</code> and<a id="id582" class="indexterm"/> <code class="literal">PostMult</code> methods to allow us to determine whether the calling matrix is the first matrix or the second in the multiplication.</p><p>When we have our model matrix ready, we just call <code class="literal">IwGxSetModelMatrix</code> to use it for rendering.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Rendering the model</h2></div></div></div><p>All the hard work is <a id="id583" class="indexterm"/>now done and we can finally submit our cube for rendering. The following code will submit all our streams and our cube will be rendered. Hopefully you'll see just how close it is to the code we used for rendering in 2D:</p><div><pre class="programlisting">IwGxSetColClear(128, 190, 220, 255);
IwGxClear();

IwGxSetMaterial(lpMaterial);
IwGxSetVertStreamModelSpace(v, lVertexCount);
IwGxSetNormStream(n, lVertexCount);
IwGxSetColStream(c);
IwGxDrawPrims(IW_GX_TRI_STRIP, i, lIndexCount)

IwGxFlush();
IwGxSwapBuffers();</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Using a 3D modeling package to create model data</h1></div></div></div><p>We've seen how to create <a id="id584" class="indexterm"/>
<a id="id585" class="indexterm"/>the streams of data for a cube in code, and to be honest it's not pretty! Even a simple shape such as a cube requires so much data that it becomes very difficult for us to keep track of it all and almost impossible to create a more complex 3D shape.</p><p>Luckily there is an easier way. We can use a 3D modeling package to create, color, and texture a 3D model and export all the required data in a format that Marmalade can then load and use.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>The Marmalade 3D exporter plugins</h2></div></div></div><p>Marmalade comes with <a id="id586" class="indexterm"/>exporter plugins for the two modeling packages used in most professional game development studios—Maya <a id="id587" class="indexterm"/>and <a id="id588" class="indexterm"/>3DS Max. The details in the following sections apply equally to the exporters for both of these modeling packages.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec53"/>Installing the plugins</h3></div></div></div><p>The exporter plugins <a id="id589" class="indexterm"/>
<a id="id590" class="indexterm"/>are installed to your computer when you install the main SDK, but they are not automatically installed into the modeling package for use. In order to use the exporters, we must use the <strong>Marmalade Launch Pad</strong> program to set them up, as shown in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start the <strong>Marmalade LaunchPad</strong> program. On Windows it can be found inside the <strong>Marmalade</strong> folder in the <strong>Start</strong> menu. You should see a window appear, containing a tabbed view.</li><li class="listitem">Click on the tab labeled <strong>Install Exporters</strong>. The following screen shown should appear:<div><img src="img/3363_04_05.jpg" alt="Installing the plugins"/></div></li><li class="listitem">Use the <a id="id591" class="indexterm"/><a id="id592" class="indexterm"/>tabs on this screen to select the version of the 3D modeling package you want to install. You must choose both the correct version of your package and whether it is a 32-bit or 64-bit installation. Maya 7.0 and 3DS Max 8.0 are the oldest supported versions. The older versions of the exporters are contained in the tabs labeled <strong>Maya 32bit Legacy</strong> and <strong>Max 32bit legacy</strong>.</li><li class="listitem">Click on the <strong>Install…</strong> button next to the required version of your modeling package and the exporter will be installed. Windows User Account Control will probably pop up a request first to ensure you want to proceed, so just click the <strong>Yes</strong> button in this dialog.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec54"/>Exporting a model</h3></div></div></div><p>With the plugin<a id="id593" class="indexterm"/> installed, start up your 3D modeling package and create or load a model that you wish to export. Since this is a coding book, we won't be going into any details about how to create a 3D model.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>If you are a programmer by trade and have no idea how to use a 3D modeling package, don't feel bad. I have seen some truly terrible "programmer art" over the years; so think of this lack of knowledge as a good thing and get a real artist involved in making the artwork for your game. You'll be glad you did!</p></div></div><p>Assuming you have a 3D model ready to export, let's get the Marmalade exporter plugin going. The exporter window itself is shown in the following figure:</p><div><img src="img/3363_04_06.jpg" alt="Exporting a model"/></div><p>The manner in <a id="id594" class="indexterm"/>which the exporter window will be displayed depends on the modeling package you are using.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In Maya you can access the exporter by using the menu option <strong>Marmalade Tools</strong> | <strong>Marmalade Studio: Maya Exporter</strong> or from the icon in the <strong>Marmalade Studio</strong> tab.</li><li class="listitem" style="list-style-type: disc">In 3DS Max, the exporter can be opened by clicking on the <strong>Utilities</strong> tab, then clicking on the <strong>Marmalade Studio Exporter</strong> button to open the rollout section. Within the rollout, there is another button labeled <strong>Marmalade Studio Exporter</strong>, which will display the exporter window.</li></ul></div><p>The exporter <a id="id595" class="indexterm"/>window should now be on screen, and as you can see there are a great many options available. We can do without most of them for now, so we'll only cover the ones we need in order to export a non-animated 3D model.</p><p>The first thing we need to set is the <strong>Current Project</strong> field. The exporter maintains a list of projects that, at its simplest level, is just a quick way of choosing a directory where the exported model files will be created.</p><p>Since we've not yet created an exporter project, let's do so by clicking on the button labeled <strong>Set Project</strong>. The following dialog will appear:</p><div><img src="img/3363_04_07.jpg" alt="Exporting a model"/></div><p>To create a <a id="id596" class="indexterm"/>new project click on the <strong>Add…</strong> button at the bottom of the dialog and you will be prompted to enter a name for the project. Once you've accepted the name, the project will appear in the <strong>Projects:</strong> list.</p><p>Click on the <strong>Browse…</strong> button and locate the <code class="literal">data</code> directory in our code project. All resource files need to reside with our code project's <code class="literal">data</code> directory; this will make exporting model files to the correct place much easier.</p><p>For now we will ignore the other settings in this dialog as they are beyond the scope of this chapter; so click the <strong>OK</strong> button to return to the main exporter window, which should now have our newly created project selected in the <strong>Current Project</strong> drop-down list and the <code class="literal">data</code> directory we set above in the <strong>Project Data Directory</strong> field.</p><p>With the project set, we can now follow these steps to export the model:</p><div><ol class="orderedlist arabic"><li class="listitem">First locate the <strong>Export Type</strong> field. Next to this field is a button with a greater-than symbol. Click this button and choose <strong>model</strong> from the pop-up menu that appears. The <strong>Export Type</strong> field should change to <strong>scene (model)</strong>.</li><li class="listitem">Now look at the first set of checkboxes labeled <strong>Enable export of</strong>. We only need the <strong>geometry</strong> and <strong>exportgroup</strong> options to be ticked to export the correct set of files.</li><li class="listitem">The next set of checkboxes is labeled <strong>Export Flags</strong>. We don't need to have any of these settings checked.</li><li class="listitem">Now we reach the <strong>Asset Name</strong> field. This specifies the base filename that will be used when the exporter generates the various output files.</li><li class="listitem">The <strong>Save To Location</strong> <a id="id597" class="indexterm"/>field allows a directory path relative to the <strong>Project Data Directory</strong> field to be provided. All files generated will be created within this directory, which will itself be created if it does not already exist.</li><li class="listitem"><strong>Scale Factor</strong> allows us to provide a numeric scaling factor that will be applied to the x, y, and z components of every exported vertex. This allows artists to create their models using familiar units such as meters in the modeling package, but then convert those units into a different scale for use in the game, such as the ever popular "number that is a power of 2" so beloved of us programmer types. Note, however, that it is vital to ensure that all artists working on a project use the same units and scale factors as each other, otherwise you'll have real problems trying to get all these models to work together properly in the game!</li><li class="listitem">Next we can choose to export either everything in the current scene, just the selected objects, or just the visible objects using the drop-down list labeled <strong>Export</strong>.</li><li class="listitem">The <strong>Transform Type</strong> drop-down box lets us choose whether the exported vertices should be in model space or world space. In most cases, when exporting individual models we would choose the <strong>local</strong> option (another way of saying model space!).</li><li class="listitem">The final setting we may be interested in is the <strong>Texture Dir</strong> field. This allows a directory to be specified, from which any textures to be used on the model will be exported. It can be either an absolute path or relative to the <strong>Project Data Directory</strong>.</li><li class="listitem">That completes all the fields we currently need to be concerned with. All that is left to do is click on the <strong>Export!</strong> button, which will generate the necessary files and then display a window listing all the files that were created during the export process.</li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>The Blender plugin</h2></div></div></div><p>There's no doubt that both Maya and 3DS Max are superb products, but it's also true that they carry a fairly hefty price tag. Unfortunately, Marmalade does kind of rely on using one of these two heavyweight packages.</p><p>Admittedly, Marmalade <a id="id598" class="indexterm"/>does also ship with a converter for <strong>Collada</strong>
<a id="id599" class="indexterm"/>, a file format that was created to enable the interchange of 3D models between different packages. I hesitate to recommend this approach however, as at the time of writing, the Collada converter that ships with Marmalade is known to be a little buggy, particularly when it comes to exporting animations.</p><p>Luckily there is a cheaper alternative. There is a 3D modeling package by the name of Blender, which is free to download and use; however, the Blender team is always happy to accept donations to continuously improve the product, so if you find it useful do consider helping them out.</p><p>The Marmalade SDK does not come with support for Blender, but thankfully due to the efforts of Benoit Muller there is a rather groovy exporter plugin that does a great job of replacing the 3DS Max and Maya exporters.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec55"/>Installing Blender and the exporter plugin</h3></div></div></div><p>If you do not already<a id="id600" class="indexterm"/>
<a id="id601" class="indexterm"/>
<a id="id602" class="indexterm"/>
<a id="id603" class="indexterm"/> have Blender installed, head over to the Blender website and download a copy. The URL is as follows:</p><p>
<a class="ulink" href="http://www.blender.org/">http://www.blender.org/</a>
</p><p>Installing Blender is just a case of executing the downloaded installer and following the on-screen instructions.</p><p>With Blender installed, we now need to get hold of the exporter plugin, which can be found at the following URL:</p><p>
<a class="ulink" href="http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Import-Export/Marmalade_Exporter">http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Import-Export/Marmalade_Exporter</a>
</p><p>The plugin is a Python script that can be installed into Blender using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Copy the downloaded plugin file <code class="literal">io_export_marmalade.py</code> into the Blender plugins directory. On Windows this will normally be something like <code class="literal">C:\Program Files\Blender Foundation\Blender\2.63\scripts\addons</code>.</li><li class="listitem">Start Blender and go to <strong>File</strong> | <strong>User Preferences…</strong>.</li><li class="listitem">Click on the <strong>Addons</strong> tab at the top of the preferences window.</li><li class="listitem">In the <strong>Categories</strong> list on the left-hand side of the window, click on <strong>Import-Export</strong>. You should see a screen that looks something like the one shown in the following figure:<div><img src="img/3363_04_08.jpg" alt="Installing Blender and the exporter plugin"/></div></li><li class="listitem">Find the <a id="id604" class="indexterm"/><a id="id605" class="indexterm"/><a id="id606" class="indexterm"/><a id="id607" class="indexterm"/><strong>Import-Export: Marmalade Cross-platform Apps (.group)</strong> entry and click the checkbox on the right-hand side of it to enable the plugin.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec56"/>Exporting a model</h3></div></div></div><p>To export a<a id="id608" class="indexterm"/>
<a id="id609" class="indexterm"/> 3D model using the Blender exporter, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create or load the model you wish to export into Blender.</li><li class="listitem">Go to <strong>File</strong> | <strong>Export</strong> | <strong>Marmalade cross-platform Apps (.group)</strong>. The main 3D view will be replaced with a filename requester. The bottom-left corner of the window should contain the exporter options and look like the following image:<div><img src="img/3363_04_09.jpg" alt="Exporting a model"/></div></li><li class="listitem">First choose the location you want to export the datafiles to, using the file requester. There are two text edit boxes at the top of the screen; the topmost is the directory to save to and the bottom specifies the filename we want to use for exporting. This filename should be a GROUP file, so its extension should always be <code class="literal">.group</code>.</li><li class="listitem">In the exporter settings, first use the <strong>Export</strong> drop-down list to select whether you want just the selected models to be exported or all models in the current scene.</li><li class="listitem">The <strong>Merge</strong> option controls what happens when there are several models in the scene to be exported. The default option, <strong>None</strong>, exports each model individually with its coordinates in model space, and is the option we require for now. The other two options allow multiple models to be merged as either a single big mesh of polygons or as a number of separate meshes, with all vertices specified in world space coordinates.</li><li class="listitem">The <strong>Scale Percent</strong> value allows model vertices to be scaled up or down so that the artist can build the models using the most convenient measurement units in Blender, yet still allow the exported model to have vertices scaled to a set of units that may be more useful in the game.</li><li class="listitem">The <strong>Flip Normals</strong> checkbox will reverse the direction of all exported normals. Normally this can be left unchecked, but it can be useful to fix models that have been lit incorrectly and have their normals pointing in the wrong direction.</li><li class="listitem">The <strong>Apply </strong><a id="id610" class="indexterm"/><a id="id611" class="indexterm"/><strong>Modifiers</strong> checkbox will cause any mesh modifiers applied to the model in Blender to be evaluated before the export data is created. This defaults to being switched off.</li><li class="listitem">If vertex colors have been applied to the model, they will only be exported if the <strong>Export Vertices Colors</strong> checkbox is selected.</li><li class="listitem">The next checkbox, <strong>Export Material Colors</strong>, determines whether materials created during the export process will be exported with their defined colors.</li><li class="listitem">The <strong>Export Textures and UVs</strong> checkbox should be checked if you have texture-mapped polygons in your model.</li><li class="listitem">Since Marmalade will need access to any images used in texturing the model, the <strong>Copy Textures Files</strong> checkbox can be selected to ensure image files are also copied across to the export directory.</li><li class="listitem">The remaining settings are mostly concerned with exporting animations, so we can ignore them for now; however, it is worth mentioning the <strong>Verbose</strong> checkbox which logs information about the export process to Blender's console window. This may help you solve problems with your models when the export process doesn't work exactly as expected.</li><li class="listitem">When all settings have been made, click on the <strong>Export Marmalade</strong> button, which is at the top right of the Blender window. Alternatively, if you wish to cancel the export process, there is a <strong>Cancel</strong> button underneath the <a id="id612" class="indexterm"/><a id="id613" class="indexterm"/>export button.</li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>The Marmalade 3D model datafile formats</h1></div></div></div><p>We've now seen how we <a id="id614" class="indexterm"/>can export 3D model data from a modeling package, but we haven't yet looked at the files themselves that are generated as part of the export process.</p><p>While we shouldn't need to make manual changes to these files, it is useful to know a little about them as it can help to discover why a model hasn't been exported quite as expected to.</p><p>Let's take a look at the files that would be generated for a cube model similar to the one we created in code earlier in this chapter.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>The GROUP file</h2></div></div></div><p>The first file generated is a <a id="id615" class="indexterm"/>GROUP file that will be created in the directory specified<a id="id616" class="indexterm"/> in the exporter settings. The GROUP file contains a list of the individual model files (called <strong>GEO files</strong>) that were exported. Here's what the GROUP file for the example cube model would look like:</p><div><pre class="programlisting">// Source file: C:/Work/MarmaladeBook/Maya/Cube.mb
// Exported By: Sean on 05/30/12 16:30:55
 
CIwResGroup
{
  name "Cube"
  "./models/Cube.geo"
}</pre></div><p>The exporter helpfully includes the name of the source modeling package file that was used to do the export, details about when the export was made, and by whom.</p><p>It then just declares a new <code class="literal">CIwResGroup</code> instance, named based on the asset name specified at export time. The resource group is populated by a list of the GEO files that need to be loaded.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>The MTL file</h2></div></div></div><p>We've already created<a id="id617" class="indexterm"/> an <a id="id618" class="indexterm"/>MTL file by hand when working with 2D graphics, so it should already look familiar. Here is what the file might look like for the cube:</p><div><pre class="programlisting">// Source file: C:/Work/MarmaladeBook/Maya/Cube.mb
CIwMaterial
{
  name "Cube/phong1"
  colAmbient {127,127,127}
  colDiffuse {127,127,127}
  colSpecular {255,255,255}
  specularPower 3
}</pre></div><p>Again the exporter <a id="id619" class="indexterm"/>includes the name of the source modeling package file used to generate the MTL file. The <code class="literal">CIwMaterial</code> instances <a id="id620" class="indexterm"/>defined in this file are all generated from the materials used in the modeling package, so it's easy for an artist to change colors and other material attributes in the comfort of their favorite modeling tool.</p><p>The exporter creates a sub-directory called <code class="literal">models</code> in the specified export directory and the MTL files are written into this directory.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>The GEO file</h2></div></div></div><p>The most important file type to be exported is the <a id="id621" class="indexterm"/>GEO file, as this is the file that actually <a id="id622" class="indexterm"/>contains all the data to describe our 3D model. In common with all Marmalade resources, this file is yet another use of the ITX file format.</p><p>GEO files are processed by way of a resource handler class called <code class="literal">CIwResHandlerGEO</code>. This class takes care of loading all the data from the GEO file and submitting it to a singleton class called <code class="literal">CIwModelBuilder</code>. This class processes the model data and generates an optimized version of the data for fast rendering, which is then serialized to a file.</p><p>The <code class="literal">CIwModelBuilder</code> class<a id="id623" class="indexterm"/> is only available in debug builds, so you can only load model data in a release build by loading the serialized version of the GROUP file that references the GEO file.</p><p>The exporter will write the GEO files into the model's sub-directory in the same way as it does with MTL files.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>You may have noticed that the GROUP file shown earlier only references the GEO files, not the MTL files. The GEO resource handler takes care of loading the MTL files automatically by checking to see if an MTL file exists with the same base filename as the GEO file.</p></div></div><p>Let's look at the innards of the GEO file for our cube model.</p><div><pre class="programlisting">// Source file: C:/Work/MarmaladeBook/Maya/Cube.mb
CIwModel
{
  name "Cube"
  CMesh
  {
    name "Cube"
    scale 100.0
    CVerts
    {
      numVerts 8
      v {-100,-100,100}
      v {100,-100,100}
      v {-100,100,100}
      v {100,100,100}
      v {-100,100,-100}
      v {100,100,-100}
      v {-100,-100,-100}
      v {100,-100,-100}
    }
    CVertNorms
    {
      numVertNorms 6
      vn {0,0,1}
      vn {0,1,0}
      vn {0,0,-1}
      vn {0,-1,0}
      vn {1,0,0}
      vn {-1,0,0}
    }
    CVertCols
    {
      numVertCols 6
      col {1,0,0,1}
      col {0,1,1,1}
      col {0,0,1,1}
      col {1,1,0,1}
      col {1,0.50000,0,1}
      col {0,1,0,1}
    }
    CSurface
    {
      material "phong1"
      CQuads
      {
        numQuads 6
        q {2,0,-1,-1,0} {3,0,-1,-1,0} {1,0,-1,-1,0}
{0,0,-1,-1,0}
        q {4,1,-1,-1,4} {5,1,-1,-1,4} {3,1,-1,-1,4}
{2,1,-1,-1,4}
        q {6,2,-1,-1,5} {7,2,-1,-1,5} {5,2,-1,-1,5}
{4,2,-1,-1,5}
        q {0,3,-1,-1,1} {1,3,-1,-1,1} {7,3,-1,-1,1}
{6,3,-1,-1,1}
        q {3,4,-1,-1,3} {5,4,-1,-1,3} {7,4,-1,-1,3}
{1,4,-1,-1,3}
        q {4,5,-1,-1,2} {2,5,-1,-1,2} {0,5,-1,-1,2}
{6,5,-1,-1,2}
      }
    }
  }
}</pre></div><p>Yet again the <a id="id624" class="indexterm"/>exporter will include a comment referencing the source modeling package file before beginning to define an instance of <code class="literal">CIwModel</code>, which is the class used by Marmalade to represent a complete collection of 3D model data.</p><p>The <code class="literal">CIwModel</code> instance<a id="id625" class="indexterm"/> is first given a name. This name actually comes from the name given to the model in the modeling package and is the name used to access the model in our code, so it is important for the artist to name things sensibly.</p><p>A <code class="literal">CMesh</code> instance<a id="id626" class="indexterm"/> is declared next, which is a class that groups together all the various bits of model data. This class, and all the other classes we are about to see that are contained within it, are only ever used internally to the model builder. Once the model has been processed these classes will no longer exist in memory, so we can't use them in our code to access the raw model data.</p><p>The <code class="literal">scale</code> value used to export the vertex data is listed first in the <code class="literal">CMesh</code> instance, and this is followed by classes which declare the various types of model data. In the cube example we can see <code class="literal">CVerts</code>, <code class="literal">CVertNorms</code>, and <code class="literal">CVertCols</code>, which are little more than big lists of vertex, normal, and color data respectively. A similar class called <code class="literal">CUVs</code> also exists to provide texture information.</p><p>Next we see a class called<a id="id627" class="indexterm"/> <code class="literal">CSurface</code>. This class provides polygon information for the model, and an instance will exist for every material used in the model. The material used is specified first, and then comes the polygon information. A <code class="literal">CQuads</code> instance<a id="id628" class="indexterm"/> is used to provide a list of all the quadrilateral polygons using the material, and a <code class="literal">CTris</code> instance<a id="id629" class="indexterm"/> lists the triangular polygons.</p><p>A polygon is defined by supplying a collection of data for each vertex in the polygon. The polygon is supplied as a group of five numbers enclosed in curly braces. These numbers are indices into the blocks of data specified earlier in the file and occur in the following order:</p><div><pre class="programlisting">{Vertex index, Normal index, UV 0 index, UV 1 index, Color index}</pre></div><p>There are two <a id="id630" class="indexterm"/>UV values as it is possible for a material to specify two textures that will be blended together at render time, and each of these textures can have its own UV stream.</p><p>Once all this data has been loaded, the model builder class will analyze it and create a version of the data that is far more optimal for real-time rendering purposes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Loading and rendering an exported 3D model</h1></div></div></div><p>OK, so now we've got<a id="id631" class="indexterm"/>
<a id="id632" class="indexterm"/> the model data exported, how do we go about loading it into our program and rendering it? It's actually surprisingly easy, as these next sections will show.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Adding the IwGraphics API to a project</h2></div></div></div><p>Marmalade's 3D model <a id="id633" class="indexterm"/>
<a id="id634" class="indexterm"/>rendering code is part of the IwGraphics API, so before we can draw anything we need to add this library to our project. This is done by adding <code class="literal">iwgraphics</code> to the <code class="literal">subprojects</code> section of the MKB file.</p><p>We then need to add a call to <code class="literal">IwGraphicsInit</code> <a id="id635" class="indexterm"/>at the start of our program, and <code class="literal">IwGraphicsTerminate</code> <a id="id636" class="indexterm"/>at the end. This API relies on both IwGx and IwResManager, so we must call the initialization functions for both of these APIs before calling the IwGraphics one.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Loading and accessing an exported 3D model</h2></div></div></div><p>You've probably <a id="id637" class="indexterm"/>
<a id="id638" class="indexterm"/>already guessed that this is almost trivially easy. The exporter generated a GROUP file, so all we have to do is load it into memory and then dig the model out of the resource group. Here's a block of code which does just that:</p><div><pre class="programlisting">CIwResGroup* lpCubeGroup = IwGetResManager()-&gt;
LoadGroup("Cube/Cube.group");
CIwModel* lpCube = static_cast&lt;CIwModel*&gt;(lpCubeGroup-&gt;
GetResNamed("Cube", "CIwModel"));</pre></div><p>Or alternatively you could do the following if you don't want to be bothered with retaining a pointer to the resource group instance:</p><div><pre class="programlisting">CIwModel* lpCube = static_cast&lt;CIwModel*&gt;(IwGetResManager()-&gt;
GetResNamed("Cube", "CIwModel"));</pre></div><p>That's it. The model is now loaded into memory and ready to render.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Rendering an exported 3D model</h2></div></div></div><p>It is time to render <a id="id639" class="indexterm"/>the model on the screen and this too is incredibly easy. All we have to do is set our view and model matrices using <code class="literal">IwGxSetViewMatrix</code> and <code class="literal">IwGxSetModelMatrix</code>, then execute the following:</p><div><pre class="programlisting">lpCube-&gt;Render();</pre></div><p>The variable <code class="literal">lpCube</code> is the pointer to the <code class="literal">CIwModel</code> instance that we retrieved from the resource manager in the previous section.</p><p>In actual fact the <code class="literal">Render</code> method<a id="id640" class="indexterm"/> can take two optional parameters. The first parameter is a <code class="literal">bool</code> value that tells Marmalade to check a bounding sphere for the model against the clipping planes to see if it actually needs to be rendered. This parameter defaults to <code class="literal">true</code>, so the check is done by default. The bounding sphere is generated automatically for us by the model builder code.</p><p>The second parameter is a flags field. Aside from one flag that is supposed to have something to do with a 2D screen rotation (I say "supposed" because I can't say it did very much when I tried it), the other flags are only relevant when dealing with animated 3D models that contain normal data, so we will not worry over these for now.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Releasing 3D model data</h2></div></div></div><p>Since our 3D model data<a id="id641" class="indexterm"/> has been loaded into memory using the resource group system, we can make use of the same mechanism of destroying groups to release model data from memory that we no longer need. As a recap, we just do the following if we have a pointer to the <code class="literal">CIwResGroup</code> containing the 3D data:</p><div><pre class="programlisting">IwGetResManager()-&gt;DestroyGroup(lpCubeGroup);</pre></div><p>Alternatively we can release a group from memory by destroying it by name, like this:</p><div><pre class="programlisting">IwGetResManager()-&gt;DestroyGroup("Cube");</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Example code</h1></div></div></div><p>Here are some details about the example projects that accompany this chapter.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>The Cube project</h2></div></div></div><p>This is a complete <a id="id642" class="indexterm"/>
<a id="id643" class="indexterm"/>example of the first spinning cube project discussed in this chapter, where we generate the model data in code and submit it to IwGx<a id="id644" class="indexterm"/> for rendering using<a id="id645" class="indexterm"/> <code class="literal">IwGxDrawPrims</code>. See the following screenshot:</p><div><img src="img/3363_04_10.jpg" alt="The Cube project"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec68"/>The Cube2 project</h2></div></div></div><p>This project is almost<a id="id646" class="indexterm"/>
<a id="id647" class="indexterm"/> identical to the previous project, except that the model data for the cube has been exported as a GEO file from a 3D modeling package.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec69"/>The Skiing project</h2></div></div></div><p>For this chapter the <a id="id648" class="indexterm"/>
<a id="id649" class="indexterm"/>Skiing game waves goodbye to its old bitmapped graphics and instead says hello to some new 3D models instead. A screenshot of the game with its new 3D skin can be seen in the following figure:</p><div><img src="img/3363_04_11.jpg" alt="The Skiing project"/></div><p>The following sections <a id="id650" class="indexterm"/>
<a id="id651" class="indexterm"/>describe some of the other more interesting changes to the game code for this chapter.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec57"/>Migration to 3D</h3></div></div></div><p>The first step <a id="id652" class="indexterm"/>was to change all position and velocity information from being 2D vectors to 3D vectors, which meant changing<a id="id653" class="indexterm"/> <code class="literal">CIwVec2</code> instances to <code class="literal">CIwFVec3</code> <a id="id654" class="indexterm"/>and making sure that the extra component in the vector was initialized.</p><p>Since we tend to think about the y axis being the height above the ground, the y component was used for height in the game too. However, since the skier and trees are stuck to the floor, this means the y component of all position vectors is always zero.</p><p>The game therefore scrolls the trees along the z axis and the camera is placed high in the air and orientated to look at the skier. This still provides the effect of the trees moving up the screen.</p><p>The second step was to get rid of all the old 2D textures and replace them with 3D models. Since the <code class="literal">GameObject</code> class dealt with all the rendering, all that had to be done was to change this class to use<a id="id655" class="indexterm"/> <code class="literal">CIwModel</code> instances instead of<a id="id656" class="indexterm"/> <code class="literal">CIwMaterial</code> instances. The child classes then just provided a pointer to a model instead of a pointer to the material.</p><p>The <code class="literal">GameObject</code> class<a id="id657" class="indexterm"/> also had a y axis rotation added to it. This is used to rotate the skier model, which leads to a far smoother motion than we had previously.</p><p>The trees also use the rotation feature. The game features only one tree model, but by rotating it at random angles it makes the game look far more interesting without having to add more game resources.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec58"/>Addition of a collision detection system</h3></div></div></div><p>The code now <a id="id658" class="indexterm"/>
<a id="id659" class="indexterm"/>features a very simple collision detection system. The <code class="literal">GameObject</code> class now allows a collision radius to be set, which is then used to perform sphere intersection tests.</p><p>The <code class="literal">ModeGame::Update</code> method<a id="id660" class="indexterm"/> now steps through every game object (currently just trees, of course) in the game world and finds out how far away it is from the skier. If the distance is less than the combined collision radius of the skier and the other game object, a collision has occurred.</p><p>So, to act on these collisions, a virtual method called<a id="id661" class="indexterm"/> <code class="literal">OnCollide</code> has been added to the <code class="literal">GameObject</code> class. Child objects can override this class and then react accordingly whenever they collide with another object. The <code class="literal">Skier</code> class<a id="id662" class="indexterm"/> implements this method so that whenever the skier collides with a tree, the game is over.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>We now know how to render 3D graphics that have either been generated in code or have been exported from a 3D modeling package. Which method we eventually use depends on what we are trying to do.</p><p>If rendering in game characters or scenery, the exported model route is definitely the best way to go; but creating our own polygon data in code is a much better and more efficient way of creating effects such as particle systems, since it is much easier to batch a large number of individual polygons into a single draw call.</p><p>We've also learnt how to export 3D model data from three different modeling packages—Maya, 3DS Max, and Blender—and load this exported data into our program and render it.</p><p>We'll be sticking with 3D rendering for a little while longer as the next chapter is all about making our models animated.</p></div></body></html>