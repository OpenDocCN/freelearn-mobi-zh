- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Swift Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once I got past the basic Hello, World! beginner applications, I quickly began
    to realize the shortcomings of variables, especially with the Mad Libs-style applications
    that I was starting to write. These applications requested that the user enter
    numerous strings, which resulted in the creation of separate variables for each
    input field that the user entered.
  prefs: []
  type: TYPE_NORMAL
- en: Having all these separate variables quickly became cumbersome. I remember talking
    to a friend about this, and he asked me why I was not using arrays. At that time,
    I was not familiar with arrays, so I asked him to show me what they were. Even
    though he had a TI-99/4A and I had a Commodore Vic-20, the concept of arrays was
    the same. Even today, the arrays found in modern development languages have the
    same basic concepts as the arrays I used on my Commodore Vic-20\. While it is
    definitely possible to create a useful application without using collections,
    such as arrays, when used properly, collections make application development significantly
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What an array is in Swift and how to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a dictionary is in Swift and how to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a set is in Swift and how to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift collection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection groups multiple items into a single unit. Swift provides three
    native collection types. These collection types are arrays, dictionaries, and
    sets. *Arrays* store data in an ordered collection, *dictionaries* are unordered
    collections of key-value pairs, and *sets* are unordered collections of unique
    values. In an array, we access the data by the location or index within the array,
    whereas in a set we usually iterate through the collection, and dictionaries are
    accessed using a unique key.
  prefs: []
  type: TYPE_NORMAL
- en: The data stored in a Swift collection must be of the same type. This means,
    as an example, that we are unable to store a string value in an array of integers.
    Since Swift does not allow us to mismatch data types in a collection, we can be
    certain of the data type when we retrieve elements from a collection. This is
    another feature that, on the surface, might seem like a shortcoming, but actually
    helps eliminate common programming mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start off by looking at mutability with collections.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For those who are familiar with Objective-C, you will know that there are different
    classes for mutable and immutable collections. For example, to define a mutable
    array, we use the `NSMutableArray` class, and to define an immutable array, we
    use the `NSArray` class. Swift is a little different because it does not contain
    separate classes for mutable and immutable collections. Instead, we define whether
    a collection is constant (immutable) or variable (mutable) by using the `let`
    and `var` keywords. This should seem familiar since we define constants with the
    `let` keyword and variables with the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to create immutable collections unless there is a specific
    need to change the objects within the collection. This allows the compiler to
    optimize performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin our tour of collections by looking at the most common collection
    type: the array type.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays can be found in virtually all modern programming languages. In Swift,
    an array is an ordered list of objects of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: When an array is created, we must declare the type of data that can be stored
    in it by explicit type declaration or through type inference. Typically, we only
    explicitly declare the data type of an array when we are creating an empty array.
    If we initialize an array with data, the compiler uses type inference to infer
    the data type for the array.
  prefs: []
  type: TYPE_NORMAL
- en: Each object in an array is called an **element**. Each of these elements is
    stored in a set order and can be accessed by searching for its location (index)
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and initializing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can initialize an array with an array literal. An array literal is a set
    of values that prepopulates the array. The following example shows how to define
    an immutable array of integers using the `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to create a mutable array, we would use the `var` keyword to define
    the array, as we did with standard variables. The following example shows how
    to define a mutable array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding two examples, the compiler inferred the type of values stored
    in the array by looking at the type of values stored in the array literal. If
    we want to create an empty array, we need to explicitly declare the type of values
    to store in the array. There are two ways to declare null arrays in Swift. The
    following examples show how to declare an empty mutable array that can be used
    to store integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding examples, we created arrays with integer values, and the majority
    of the array examples in this chapter will also use integer values; however, we
    can create arrays in Swift with any type. The only rule is that, once an array
    is defined as containing a particular type, all the elements in the array must
    be of that type. The following example shows how we can create arrays of various
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift provides special type aliases for working with nonspecific types. These
    aliases are `AnyObject` and `Any`. We can use these aliases to define arrays whose
    elements are of different types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `AnyObject` aliases can represent an instance of any class type, while the
    `Any` aliases can represent an instance of any type, including function types.
    We should use the `Any` and `AnyObject` aliases only when there is an explicit
    need for this behavior. It is always better to be specific about the types of
    data our collections contain.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a need to mix types in a single collection, we could consider using
    a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array can also be initialized to a certain size with all the elements set
    to a predefined value. This can be very useful if we want to create an array and
    prepopulate it with default values. The following example defines an array with
    `7` elements, with each element containing the number `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Starting in Swift 5.1, with SE-0245, we have the ability to create an uninitialized
    array. With this feature, we would not populate the array with a default value
    and instead could provide what is known as a **closure to populate the array**
    as needed. We will show this feature in *Chapter 14*, *Working with Closures*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the most common arrays are one-dimensional arrays, multidimensional arrays
    can also be created. A multidimensional array is really nothing more than an array
    of arrays. For example, a two-dimensional array is an array of arrays, while a
    three-dimensional array is an array of arrays of arrays. The following examples
    show the two ways to create a two-dimensional array in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to initialize an array, let's look at how we can access
    the elements of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the array element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The subscript syntax is used to retrieve values from an array. Subscript syntax,
    for an array, is where a number appears between two square brackets, and that
    number specifies the location (index) within the array of the element we wish
    to retrieve. The following example shows how to retrieve elements from an array
    using the subscript syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an array of integers that contains six numbers.
    We then print out the value at indexes `0` and `3`.
  prefs: []
  type: TYPE_NORMAL
- en: One important fact to note is that indices in Swift arrays start with the number
    zero. This means that the first item in an array has an index of `0`. The second
    item in an array has an index of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to retrieve an individual value within a multidimensional array,
    we need to provide a subscript for each dimension of the array. If we do not provide
    a subscript for each dimension, we will retrieve an array rather than an individual
    value within the array. The following example shows how we can define a two-dimensional
    array and retrieve an individual value within the two dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we begin by defining a two-dimensional array. When we
    retrieve the value at index `0` of the first dimension (`multiArray[0]`), we retrieve
    the array `[1,2]`. When we retrieve the value at index `0` of the first dimension
    and index `1` of the second dimension (`multiArray[0][1]`), we retrieve the integer
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the first and last elements of an array using the `first` and
    `last` properties. The `first` and `last` properties return an optional value,
    since the values may be nil if the array is empty. The following example shows
    how to use these properties to retrieve the first and last elements of both a
    one-dimensional and a multidimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see how we can count the elements of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the elements of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, it is essential to know the number of elements in an array. The array
    type in Swift contains a read-only `count` property. The following example shows
    how to use this property to retrieve the number of elements in both single-dimensional
    and multidimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value that is returned by the `count` property is the number of elements
    in the array, and not the largest valid index of the array. For non-empty arrays,
    the largest valid index is the number of elements in the array minus 1\. This
    is because the first element of the array has an index number of `0`. As an example,
    if an array has two elements, the valid indexes are `0` and `1`, while the `count`
    property would return `2`. This is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to retrieve an element from an array that is outside the range
    of the array, the application will throw an **array index out of range** error.
    Therefore, if we are unsure of the size of an array, it is a good practice to
    verify that the index is not outside the range of the array. The following examples
    illustrate this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the first block would throw an **array index out of range**
    error because we are attempting to access the value from the `arrayOne` array
    at index `6`; however, there are only four elements in the array. The second example
    would not throw the error because we are checking whether the `arrayTwo` array
    contains more than six elements before trying to access the element at the sixth
    index.
  prefs: []
  type: TYPE_NORMAL
- en: Is the array empty?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check whether an array is empty (that is, it does not contain any elements),
    we use the `isEmpty` property. This property will return `true` if the array is
    empty and `false` if it is not. The following example shows how to check whether
    an array is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see how we can shuffle an array.
  prefs: []
  type: TYPE_NORMAL
- en: Shuffling an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array can be very easily shuffled using the `shuffle()` and `shuffled()`
    methods. This can be very useful if we are creating a game, such as a card game,
    where the array contains the 52 cards in the deck. To shuffle the array in place,
    the `shuffle()` method can be used; to put the shuffled results in a new array,
    leaving the original array untouched, the `shuffled()` method would be used. The
    following examples show this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at how we can append data to an array.
  prefs: []
  type: TYPE_NORMAL
- en: Appending to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A static array is somewhat useful but having the ability to add elements dynamically
    is what makes arrays really useful. To add an item to the end of an array, we
    can use the `append` method. The following example shows how to append an item
    to the end of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift also allows us to use the addition assignment operator (`+=`) to append
    an array to another array. The following example shows how to use the addition
    assignment operator to append an array to the end of another array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The way you append an element to the end of an array is really up to you. Personally,
    I prefer the assignment operator because, to me, it is a bit easier to read, but
    we will be using both in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a value into an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can insert a value into an array by using the `insert` method. The `insert`
    method will move all the items up one spot, starting at the specified index, to
    make room for the new element, and then insert the value into the specified index.
    The following example shows how to use this method to insert a new value into
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to insert a value, let's see how we can replace an
    element within an array.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing elements in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the subscript syntax to replace elements in an array. Using the subscript,
    we pick the element of the array we wish to update and then use the assignment
    operator to assign a new value. The following example shows how we will replace
    a value in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You cannot update a value that is outside the current range of the array. Attempting
    to do so will throw the same **index out of range** exception that was thrown
    when we tried to insert a value outside the range of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we can remove elements from an array.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three methods that we can use to remove one or all of the elements
    in an array. These methods are `removeLast()`, `remove(at:)`, and `removeAll()`.
    The following example shows how to use the three methods to remove elements from
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `removeLast()` and `remove(at:)` methods will also return the value of
    the element being removed. Therefore, if we want to know the value of the item
    that was removed, we can rewrite the `remove(at:)` and `removeLast()` lines to
    capture the value, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Merging two arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new array by adding two arrays together, we use the addition (`+`)
    operator. The following example shows how to use the addition (`+`) operator to
    create a new array that contains all the elements of two other arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `arrayOne` and `arrayTwo` are left unchanged, while the
    `combined` array contains the elements from `arrayOne`, followed by the elements
    from `arrayTwo`.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a subarray from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can retrieve a subarray from an existing array by using the subscript syntax
    with a range operator. The following example shows how to retrieve a range of
    elements from an existing array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator (three periods) is known as a **two-sided range operator**. The
    range operator in the preceding code says that we want all the elements from `2`
    to `4` inclusively (elements `2` and `4` as well as what is between them). There
    is another two-sided range operator, ..<, known as the **half-open range operator**.
    The half-open range operator functions the same as the previous range operator;
    however, it excludes the last element. The following example shows how to use
    the `..<` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the subarray contains two elements: `3` and `4`.
    A two-sided range operator has numbers on either side of the operator. In Swift,
    we are not limited to two-sided range operators; we can also use one-sided range
    operators. The following examples show how we can use one-sided range operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The one-sided range operators were added in version 4 of the Swift language.
    The previous range operators enable us to access a contiguous range of elements
    from an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'SE-0270 enables us to fetch elements that are not contiguous, which means the
    elements may not be next to each other. This update to the Swift standard library
    introduced a new `RangeSet` type, which is a subrange of indexes that are non-contiguous.
    Let''s see how this works with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we define an array that contains the numbers `1` through `10`.
    We then use the `subranges(where:)` method to retrieve the even elements. This
    method takes a closure as the argument, which hasn't been discussed yet. For now,
    we just need to know that we are able to retrieve non-contiguous subarrays and
    we will look at this again in *Chapter 14*, *Working with Closures*.
  prefs: []
  type: TYPE_NORMAL
- en: Making bulk changes to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the subscript syntax with a range operator to change the values
    of multiple elements. The following example shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the elements at indices `1` and `2` will be changed to
    the numbers `12` and `13`; therefore, `arrayOne` will contain `1`, `12`, `13`,
    `4`, and `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of elements that you are changing in the range operator does not
    need to match the number of values that you are passing in. Swift makes bulk changes
    by first removing the elements defined by the range operator and then inserting
    the new values. The following example demonstrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `arrayOne` array starts with five elements. We then
    replace the range of elements `1` to `3` inclusively. This causes elements `1`
    through `3` (that is, three elements) to be removed from the array first. After
    those three elements are removed, then the two new elements (`12` and `13`) are
    added to the array, starting at index `1`. After this is complete, `arrayOne`
    will contain four elements: `1`, `12`, `13`, and `5`. Using the same logic, we
    can also add more elements than we remove. The following example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `arrayOne` starts with five elements. We then say that
    we want to replace the range of elements `1` through `3` inclusively. As in the
    previous example, this causes elements `1` through `3` (three elements) to be
    removed from the array. We then add four elements (`12`, `13`, `14`, and `15`)
    to the array, starting at index `1`. After this is complete, `arrayOne` will contain
    six elements: `1`, `12`, `13`, `14`, `15`, and `5`.'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms for arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift arrays have several methods that take a closure as their argument. These
    methods transform the array in a way defined by the code in the closure. Closures
    are self-contained blocks of code that can be passed around, and are similar to
    blocks in Objective-C and lambdas in other languages. We will discuss closures
    in depth in *Chapter 14*, *Working with Closures*. For now, the goal is to become
    familiar with how the algorithms work in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **sort** algorithm sorts an array in place. This means that, when the `sort()`
    method is used, the original array is replaced with the sorted one. The closure
    takes two arguments (represented by `$0` and `$1`), and it should return a Boolean
    value that indicates whether the first element should be placed before the second
    element. The following code shows how to use the sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will sort the array in ascending order. We know this because
    the rule will return true if the first number (`$0`) is less than the second number
    (`$1`). Therefore, when the sort algorithm begins, it compares the first two numbers
    (`9` and `3`) and returns `true` if the first number (`9`) is less than the second
    number (`3`). In our case, the rule returns `false`, so the numbers are reversed.
    The algorithm continues sorting in this manner until all of the numbers are sorted
    in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort an array in ascending order, we can actually use the `sort()` method
    by itself without using a closure as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding examples sorted the array in a numerically-increasing order;
    if we wanted to reverse the order, we would reverse the arguments in the closure.
    The following code shows how to reverse the sort order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When we run this code, `arrayOne` will contain the elements `9`, `8`, `6`, `5`,
    `3`, and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code can be simplified by using the `sort(by:)` method and passing
    in a greater-than or less-than operator, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, by using the less-than operator, the array is sorted
    in ascending order. If we'd used the greater-than operator, the array would have
    been sorted in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the sort algorithm sorts the array in place (that is, it replaces the
    original array), the **sorted** algorithm does not change the original array;
    it instead creates a new array with the sorted elements from the original array.
    The following example shows how to use the sorted algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After we run this code, `arrayOne` will contain the original unsorted array
    (`9`, `3`, `6`, `2`, `8`, and `5`) and the `sorted` array will contain the new
    sorted array (`2`, `3`, `5`, `6`, `8`, and `9`).
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **filter** algorithm will return a new array by filtering the original array.
    This is one of the most powerful array algorithms and may end up being the one
    you use the most. If you need to retrieve a subset of an array based on a set
    of rules, I recommend using this algorithm rather than trying to write your own
    method to filter the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The closure takes one argument, and it should return a Boolean `true` if the
    element should be included in the new array, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the rule that we are passing to the algorithm returns
    `true` if the number is greater than `3` and less than `7`; therefore, any number
    that is greater than `3` and less than `7` is included in the new `filtered` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next example shows how we can retrieve a subset of cities that contain
    the letter `o` in their name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `range(of:)` method to return `true` if the
    string contains the letter `o`. If the method returns `true`, the string is included
    in the `filtered` array.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the filter algorithm is used to select only certain elements of an array,
    **map** is used to apply logic to all elements in the array. The following example
    shows how to use the map algorithm to divide each number by 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the new array contains the numbers `1`, `2`, `3`, and
    `4`, which is the result of dividing each element of the original array by `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new array created by the map algorithm is not required to contain the same
    element types as the original array; however, all the elements in the new array
    must be of the same type. In the following example, the original array contains
    integer values, but the new array created by the map algorithm contains string
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created an array of strings that appends the numbers
    from the original array to the `num:` string.
  prefs: []
  type: TYPE_NORMAL
- en: Count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can combine the filter algorithm with the `count` method to count the number
    of items in an array that match a rule. For example, if we had an array that contained
    the grades from a test, we could use the **count** algorithm to count how many
    of the grades were greater than or equal to `90`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did with the filter algorithm, we can use methods from the array type,
    such as the `range(of:)` method from the string type. For example, rather than
    returning a subset of cities that contain the letter `o` in their name, as we
    did in the filter algorithm, we can count the cities like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding count, the `count1` constant contains `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Diff
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift 5.1 with SE-0240, the **Diff** algorithm was introduced. This addition
    to the Swift language enables support for `diff` and patching of ordered collections
    like arrays. To really see the power of this change we need to understand how
    `switch` statements work, which is introduced in *Chapter 6*, *Control Flow*;
    therefore, we will briefly show how the Diff algorithm works here with the `applying`
    method. We will look at this algorithm more when we cover the `switch` statement
    in *Chapter 6*, *Control Flow*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we started off by creating two arrays. We then used
    the `difference(from:)` method, which returns the difference between the two arrays.
    This new array would now contain the values: `100`, `98`, `95`, `91`, `83`, `88`,
    and `72`. The return value is a collection of enumerations that tell us how we
    can produce a collection, from one collection, that will contain the same elements
    as another collection. This might not make a whole lot of sense right now, but
    as we dive into more of this, it will become clear.'
  prefs: []
  type: TYPE_NORMAL
- en: The last line uses the `applying()` method to apply the changes to the `scores1`
    array and returns an array that has the same elements as the `scores2` array;
    therefore, after this method is called, the `newArray` array contains the same
    elements as the `scores2` array.
  prefs: []
  type: TYPE_NORMAL
- en: forEach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `forEach` algorithm to iterate over a sequence. The following
    example shows how we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will print the following results to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: While using the `forEach` algorithm is very easy, it does have some limitations.
    The recommended way to iterate over an array is to use the `for-in` loop, which
    we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can iterate over all elements of an array, in order, with a `for-in` loop.
    The `for-in` loop will execute one or more statements for each element of the
    array. We will discuss the `for-in` loop in greater detail in *Chapter 6*, *Control
    Flow*. The following example shows how we would iterate over the elements of an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `for-in` loop iterates over the array and executes
    the `print(item)` line for each element in the array. If we run this code, it
    will display the following results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'There are times when we would like to iterate over an array, as we did in the
    preceding example, but we would also like to know the index, as well as the value
    of an element. To do this, we can use the `enumerated` method of an array, which
    returns a tuple for each item in the array that contains both the index and value
    of the element. The following example shows how to use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display the following results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have introduced arrays in Swift, let's move on to dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While dictionaries are not as commonly used as arrays, they have additional
    functionality that makes them incredibly powerful. A dictionary is a container
    that stores multiple key-value pairs, where all the keys are of the same type
    and all the values are of the same type. The key is used as a unique identifier
    for the value. A dictionary does not guarantee the order in which the key-value
    pairs are stored since we look up the values by key rather than by the index of
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries are good for storing items that map to unique identifiers, where
    the unique identifier should be used to retrieve the item. Countries with their
    abbreviations are a good example of items that can be stored in a dictionary.
    In the following table, we show countries with their abbreviations as key-value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| US | United States |'
  prefs: []
  type: TYPE_TB
- en: '| IN | India |'
  prefs: []
  type: TYPE_TB
- en: '| UK | United Kingdom |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Countries and their abbreviations'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and initializing dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can initialize a dictionary using a dictionary literal, similarly to how
    we initialized an array with the array literal. The following example shows how
    to create a dictionary using the key-value pairs in the preceding chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates an immutable dictionary that contains each of the
    key-value pairs in the chart we saw before. Just like the array, to create a mutable
    dictionary we will need to use the `var` keyword in place of `let`. The following
    example shows how to create a mutable dictionary that contains the countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding two examples, we created a dictionary where the key and value
    were both strings. The compiler inferred that the key and value were strings because
    that was the type of the keys and values used to initiate the dictionary. If we
    wanted to create an empty dictionary, we would need to tell the compiler what
    the key and value types are. The following examples create various dictionaries
    with different key-value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If we want to use a custom object as the key in a dictionary, we will need to
    make the custom object conform to the **Hashable** protocol from Swift's standard
    library. We will discuss protocols extensively later in this book, but for now
    just understand that it is possible to use custom objects as a key in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we can access the values of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing dictionary values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the subscript syntax to retrieve the value for a particular key. If
    the dictionary does not contain the key we are looking for, the dictionary will
    return `nil`; therefore, the variable returned from this lookup is an optional
    variable. The following example shows how to retrieve a value from a dictionary
    using its key in the subscript syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `name` variable contains the `United States` string.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the keys or values in a dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `count` property of the dictionary to get the number of key-value
    pairs in the dictionary. The following example shows how to use this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `cnt` variable will contain the number `3` since
    there are three key-value pairs in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Is the dictionary empty?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test whether a dictionary contains any key-value pairs, we can use the `isEmpty`
    property. This property will return `false` if the dictionary contains one or
    more key-value pairs and `true` if it is empty. The following example shows us
    how to use this property to determine whether our dictionary contains any key-value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `isEmpty` property returned `false` as there are
    three key-value pairs in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the value of a key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update the value of a key in a dictionary, we can use either the subscript
    syntax or the `updateValue(_: ,forKey:)` method. The `updateValue(_:, forKey:)`
    method has an additional feature that the subscript syntax doesn''t: it returns
    the original value associated with the key prior to changing the value. The following
    example shows how to use both the subscript syntax and the `updateValue(_:, forKey:)`
    method to update the value of a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the subscript syntax to change the value associated
    with the `UK` key from `United Kingdom` to `Great Britain`. The original value
    of `United Kingdom` was not saved prior to replacing it. We then used the `updateValue(_:,
    forKey:)` method to change the value associated with the `UK` key from `Great
    Britain` to `Britain`. With the `updateValue(_:, forKey:)` method, the original
    value of `Great Britain` is assigned to the `orig` variable prior to changing
    the value in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a key-value pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a new key-value pair to a dictionary, we can use the subscript syntax
    or the same `updateValue(_:, forKey:)` method that we used to update the value
    of a key. If we use the `updateValue(_:, forKey:)` method and the key is not currently
    present in the dictionary, this method will add a new key-value pair and return
    `nil`. The following example shows how to use both the subscript syntax and the
    `updateValue(_:, forKey:)` method to add a new key-value pair to a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `countries` dictionary starts with three key-value
    pairs and we then add a fourth key-value pair (`FR/France`) to the dictionary
    using the subscript syntax. We use the `updateValue(_:,forKey:)` method to add
    a fifth key-value pair (`DE/Germany`) to the dictionary. The `orig` variable is
    set to `nil` because the `countries` dictionary did not contain a value associated
    with the `DE` key.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a key-value pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There may be times when we need to remove values from a dictionary. There are
    three ways to achieve this: the subscript syntax, the `removeValue(forKey:)` method,
    or the `removeAll()` method. The `removeValue(forKey:)` method returns the value
    of the key prior to removing it. The `removeAll()` method removes all the elements
    from the dictionary. The following example shows how to use all three methods
    to remove key-value pairs from a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `countries` dictionary starts off with three key-value
    pairs. We then set the value associated with the `IN` key to `nil`, which removes
    the key-value pair from the dictionary. We use the `removeValue(forKey:)` method
    to remove the key associated with the `UK` key. Prior to removing the value associated
    with the `UK` key, the `removeValue(forKey:)` method saves the value in the `orig`
    variable. Finally, we use the `removeAll()` method to remove all the remaining
    key-value pairs in the `countries` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the set type.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The set type is a generic collection that is similar to the array type. While
    the array type is an ordered collection that may contain duplicate items, the
    set type is an unordered collection where each item must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Like the key in a dictionary, the type stored in an array must conform to the
    **Hashable** protocol. This means that the type must provide a way to compute
    a hash value for itself. All of Swift's basic types, such as `String`, `Double`,
    `Int`, and `Bool`, conform to this protocol and can be used in a set by default.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we would use the set type.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of ways to initialize a set. Just like the array and dictionary
    types, Swift needs to know what type of data is going to be stored in it. This
    means that we must either tell Swift the type of data to store in the set or initialize
    it with some data so that it can infer the data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the array and dictionary types, we use the `var` and `let` keywords
    to declare whether the set is mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Inserting items into a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `insert` method to insert an item into a set. If we attempt to insert
    an item that is already in the set, the item will be ignored. Here are some examples
    of inserting items into a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insert()` method returns a tuple that we can use to verify that the value
    was successfully added to the set. The following example shows how to check the
    returned value to see whether it was added successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Failed` would be printed to the console since we are attempting
    to add the `One` value to the set when it is already in the set.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the number of items in a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `count` property to determine the number of items in a set.
    Here is an example of how to use this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this code will print the message `3 items` to the console because
    the set contains three items.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a set contains an item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can verify whether a set contains an item by using the `contains()` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `contain` variable is set to `true` because the
    set contains `a` string with a value of `Two`.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `for-in` statement to iterate over the items in a set as we
    did with arrays. The following example shows how we would iterate through the
    items in a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will print out each item in the set to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Removing items in a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can remove a single item or all the items in a set. To remove a single item,
    we would use the `remove()` method and, to remove all the items, we would use
    the `removeAll()` method. The following example shows how to remove items from
    a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Set operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apple has provided four methods that we can use to construct a set from two
    other sets. These operations can be performed in place, on one of the sets, or
    used to create a new set. These operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`union`and`formUnion`: These create a set with all the unique values from both
    sets and can be thought of as removing the duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtracting`and`subtract`: These create a set with values from the first set
    that are not in the second set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intersection`and`formIntersection`: These create a set with values that are
    common to both sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symmetricDifference`and`formSymmetricDifference`: These create a new set with
    values that are in either set, but not in both sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at some examples and see the results that can be obtained from
    each of these operations. For all the examples of set operations, we will be using
    the following two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The first example uses the `union` method. This method takes the unique values
    from both sets to make another set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newSetUnion` variable will contain the following values: `One`, `Two`,
    `Three`, `abc`, `def`, and `ghi`. We can use the `formUnion` method to perform
    the `union` function in place without creating a new set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `mySet1set` set will contain all the unique values from
    the `mySet1` and `mySet2` sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the `subtract` and `subtracting` methods. These methods
    will create a set with the values from the first set that are not in the second
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `newSetSubtract` variable will contain the `Two` and `Three`
    values because those are the only two values that are not also in the second set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `subtract` method to perform the subtraction function in place without
    creating a new set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `mySet1` set will contain the `Two` and `Three` values
    because those are the only two values that are not in the `mySet2` set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the `intersection` method, which creates a new set from
    the values that are common between the two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `newSetIntersect` variable will contain the `One` and `abc`
    values since they are the values that are common between the two sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `formIntersection()` method to perform the intersection function
    in place without creating a new set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `mySet1` set will contain the `One` and `abc` values since
    they are the values that are common between the two sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the `symmetricDifference()` methods. These methods
    will create a new set with values that are in either set, but not in both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `newSetExclusiveOr` variable will contain the `Two`, `Three`,
    `def`, and `ghi` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this method in place, we use the `fromSymmetricDifference()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: These four operations (union, subtraction, intersection, and symmetric difference)
    add functionality that is not present with arrays. Combined with faster lookup
    speeds, as compared to an array, the set type can be a very useful alternative
    when the order of the collection is not important and the instances in the collection
    must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered Swift collections. Having a good understanding of
    the native collection types of Swift is essential to architecting and developing
    applications in Swift since all but the most basic applications use them.
  prefs: []
  type: TYPE_NORMAL
- en: The three Swift collection types are arrays, sets, and dictionaries. Arrays
    store data as an ordered collection. Sets store data as an unordered collection
    of unique values. Dictionaries store data in an unordered collection of key-value
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to use Swift's control flow statements.
  prefs: []
  type: TYPE_NORMAL
