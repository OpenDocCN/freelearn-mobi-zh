- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Using Swift Collections
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swift 集合
- en: Once I got past the basic Hello, World! beginner applications, I quickly began
    to realize the shortcomings of variables, especially with the Mad Libs-style applications
    that I was starting to write. These applications requested that the user enter
    numerous strings, which resulted in the creation of separate variables for each
    input field that the user entered.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我超越了基本的“Hello, World!”入门级应用程序，我很快就意识到变量的不足，尤其是在我开始编写的 Mad Libs 风格的应用程序中。这些应用程序要求用户输入多个字符串，这导致了为用户输入的每个输入字段创建单独的变量。
- en: Having all these separate variables quickly became cumbersome. I remember talking
    to a friend about this, and he asked me why I was not using arrays. At that time,
    I was not familiar with arrays, so I asked him to show me what they were. Even
    though he had a TI-99/4A and I had a Commodore Vic-20, the concept of arrays was
    the same. Even today, the arrays found in modern development languages have the
    same basic concepts as the arrays I used on my Commodore Vic-20\. While it is
    definitely possible to create a useful application without using collections,
    such as arrays, when used properly, collections make application development significantly
    easier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有这些单独的变量很快就变得繁琐。我记得和一个朋友谈论过这件事，他问我为什么不用数组。当时，我对数组不太熟悉，所以我让他给我展示一下它们是什么。尽管他有一个
    TI-99/4A，而我有一个 Commodore Vic-20，但数组的概念是相同的。即使今天，现代开发语言中的数组也和我当年在 Commodore Vic-20
    上使用的数组有相同的基本概念。当然，不使用集合，如数组，也可以创建有用的应用程序，但正确使用集合可以显著简化应用程序开发。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What an array is in Swift and how to use it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中数组是什么以及如何使用它
- en: What a dictionary is in Swift and how to use it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中字典是什么以及如何使用它
- en: What a set is in Swift and how to use it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中集合是什么以及如何使用它
- en: Swift collection types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 集合类型
- en: A collection groups multiple items into a single unit. Swift provides three
    native collection types. These collection types are arrays, dictionaries, and
    sets. *Arrays* store data in an ordered collection, *dictionaries* are unordered
    collections of key-value pairs, and *sets* are unordered collections of unique
    values. In an array, we access the data by the location or index within the array,
    whereas in a set we usually iterate through the collection, and dictionaries are
    accessed using a unique key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 集合将多个项目组合成一个单元。Swift 提供了三种原生集合类型。这些集合类型是数组、字典和集合。*数组*按顺序存储数据，*字典*是无序的键值对集合，而*集合*是无序的唯一值集合。在数组中，我们通过数组内的位置或索引来访问数据，而在集合中我们通常遍历集合，字典则是通过唯一键来访问。
- en: The data stored in a Swift collection must be of the same type. This means,
    as an example, that we are unable to store a string value in an array of integers.
    Since Swift does not allow us to mismatch data types in a collection, we can be
    certain of the data type when we retrieve elements from a collection. This is
    another feature that, on the surface, might seem like a shortcoming, but actually
    helps eliminate common programming mistakes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 Swift 集合中的数据必须是同一类型。这意味着，例如，我们无法在整数数组中存储字符串值。由于 Swift 不允许我们在集合中混合数据类型，因此当我们从集合中检索元素时，我们可以确定数据类型。这是另一个表面上可能看起来像是一个缺点，但实际上有助于消除常见的编程错误。
- en: Let's start off by looking at mutability with collections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看集合的可变性开始。
- en: Mutability
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变性
- en: For those who are familiar with Objective-C, you will know that there are different
    classes for mutable and immutable collections. For example, to define a mutable
    array, we use the `NSMutableArray` class, and to define an immutable array, we
    use the `NSArray` class. Swift is a little different because it does not contain
    separate classes for mutable and immutable collections. Instead, we define whether
    a collection is constant (immutable) or variable (mutable) by using the `let`
    and `var` keywords. This should seem familiar since we define constants with the
    `let` keyword and variables with the `var` keyword.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Objective-C 的人来说，你们会知道存在不同的类来表示可变和不可变集合。例如，要定义一个可变数组，我们使用 `NSMutableArray`
    类，而要定义一个不可变数组，我们使用 `NSArray` 类。Swift 稍有不同，因为它不包含用于可变和不可变集合的单独类。相反，我们通过使用 `let`
    和 `var` 关键字来定义集合是常量（不可变）还是变量（可变）。这应该看起来很熟悉，因为我们用 `let` 关键字定义常量，用 `var` 关键字定义变量。
- en: It is a good practice to create immutable collections unless there is a specific
    need to change the objects within the collection. This allows the compiler to
    optimize performance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的需要更改集合中的对象，否则创建不可变集合是一个好的实践。这允许编译器优化性能。
- en: 'Let''s begin our tour of collections by looking at the most common collection
    type: the array type.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看最常见的集合类型：数组类型开始，来开始我们的集合之旅。
- en: Arrays
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays can be found in virtually all modern programming languages. In Swift,
    an array is an ordered list of objects of the same type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数组几乎可以在所有现代编程语言中找到。在Swift中，数组是相同类型对象的有序列表。
- en: When an array is created, we must declare the type of data that can be stored
    in it by explicit type declaration or through type inference. Typically, we only
    explicitly declare the data type of an array when we are creating an empty array.
    If we initialize an array with data, the compiler uses type inference to infer
    the data type for the array.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个数组时，我们必须通过显式类型声明或通过类型推断来声明可以存储在其中的数据类型。通常，我们只有在创建一个空数组时才会显式声明数组的数据类型。如果我们用数据初始化一个数组，编译器会使用类型推断来推断数组的数据类型。
- en: Each object in an array is called an **element**. Each of these elements is
    stored in a set order and can be accessed by searching for its location (index)
    in the array.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个对象称为**元素**。这些元素按顺序存储，可以通过在数组中搜索其位置（索引）来访问。
- en: Creating and initializing arrays
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和初始化数组
- en: 'We can initialize an array with an array literal. An array literal is a set
    of values that prepopulates the array. The following example shows how to define
    an immutable array of integers using the `let` keyword:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组字面量来初始化一个数组。数组字面量是一组预填充数组的值。以下示例展示了如何使用`let`关键字定义一个不可变的整数数组：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we need to create a mutable array, we would use the `var` keyword to define
    the array, as we did with standard variables. The following example shows how
    to define a mutable array:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要创建一个可变数组，我们会使用`var`关键字来定义数组，就像我们定义标准变量一样。以下示例展示了如何定义一个可变数组：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding two examples, the compiler inferred the type of values stored
    in the array by looking at the type of values stored in the array literal. If
    we want to create an empty array, we need to explicitly declare the type of values
    to store in the array. There are two ways to declare null arrays in Swift. The
    following examples show how to declare an empty mutable array that can be used
    to store integers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个示例中，编译器通过查看数组字面量中存储的值的类型来推断数组中存储的值的类型。如果我们想创建一个空数组，我们需要显式声明要存储在数组中的值的类型。Swift中有两种声明空数组的方法。以下示例展示了如何声明一个可以用来存储整数的空可变数组：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding examples, we created arrays with integer values, and the majority
    of the array examples in this chapter will also use integer values; however, we
    can create arrays in Swift with any type. The only rule is that, once an array
    is defined as containing a particular type, all the elements in the array must
    be of that type. The following example shows how we can create arrays of various
    data types:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了包含整数值的数组，本章中的大多数数组示例也将使用整数值；然而，我们可以在Swift中使用任何类型的数组。唯一的规则是，一旦定义了一个数组包含特定类型，数组中的所有元素都必须是那种类型。以下示例展示了我们如何创建各种数据类型的数组：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Swift provides special type aliases for working with nonspecific types. These
    aliases are `AnyObject` and `Any`. We can use these aliases to define arrays whose
    elements are of different types as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Swift为处理非特定类型提供了特殊的类型别名。这些别名是`AnyObject`和`Any`。我们可以使用这些别名来定义元素类型不同的数组，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `AnyObject` aliases can represent an instance of any class type, while the
    `Any` aliases can represent an instance of any type, including function types.
    We should use the `Any` and `AnyObject` aliases only when there is an explicit
    need for this behavior. It is always better to be specific about the types of
    data our collections contain.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyObject`别名可以表示任何类类型的实例，而`Any`别名可以表示任何类型的实例，包括函数类型。我们应该只在有明确需要这种行为时使用`Any`和`AnyObject`别名。始终明确我们集合中包含的数据类型是更好的做法。'
- en: If there is a need to mix types in a single collection, we could consider using
    a tuple.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在单个集合中混合类型，我们可以考虑使用元组。
- en: 'An array can also be initialized to a certain size with all the elements set
    to a predefined value. This can be very useful if we want to create an array and
    prepopulate it with default values. The following example defines an array with
    `7` elements, with each element containing the number `3`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以初始化为特定大小，并将所有元素设置为预定义的值。如果我们想创建一个数组并预先填充默认值，这会非常有用。以下示例定义了一个包含`7`个元素的数组，每个元素包含数字`3`：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Starting in Swift 5.1, with SE-0245, we have the ability to create an uninitialized
    array. With this feature, we would not populate the array with a default value
    and instead could provide what is known as a **closure to populate the array**
    as needed. We will show this feature in *Chapter 14*, *Working with Closures*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从Swift 5.1开始，随着SE-0245的引入，我们有了创建未初始化数组的能力。使用此功能，我们不需要用默认值填充数组，而是可以根据需要提供一个**闭包来填充数组**。我们将在*第14章*，*使用闭包*中展示这一功能。
- en: 'While the most common arrays are one-dimensional arrays, multidimensional arrays
    can also be created. A multidimensional array is really nothing more than an array
    of arrays. For example, a two-dimensional array is an array of arrays, while a
    three-dimensional array is an array of arrays of arrays. The following examples
    show the two ways to create a two-dimensional array in Swift:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最常见的数组是一维数组，但也可以创建多维数组。实际上，多维数组不过是一个数组的数组。例如，二维数组是一个数组的数组，而三维数组则是一个数组的数组的数组。以下示例展示了在Swift中创建二维数组的两种方式：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have seen how to initialize an array, let's look at how we can access
    the elements of an array.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何初始化数组，让我们看看我们如何访问数组的元素。
- en: Accessing the array element
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数组元素
- en: 'The subscript syntax is used to retrieve values from an array. Subscript syntax,
    for an array, is where a number appears between two square brackets, and that
    number specifies the location (index) within the array of the element we wish
    to retrieve. The following example shows how to retrieve elements from an array
    using the subscript syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下标语法用于从数组中检索值。对于数组，下标语法是指一个数字出现在两个方括号之间，该数字指定了我们想要检索的元素在数组中的位置（索引）。以下示例展示了如何使用下标语法从数组中检索元素：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we create an array of integers that contains six numbers.
    We then print out the value at indexes `0` and `3`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个包含六个整数的数组。然后我们打印出索引`0`和`3`处的值。
- en: One important fact to note is that indices in Swift arrays start with the number
    zero. This means that the first item in an array has an index of `0`. The second
    item in an array has an index of `1`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事实是，Swift数组中的索引从数字`0`开始。这意味着数组中的第一个元素的索引为`0`。数组中的第二个元素的索引为`1`。
- en: 'If we want to retrieve an individual value within a multidimensional array,
    we need to provide a subscript for each dimension of the array. If we do not provide
    a subscript for each dimension, we will retrieve an array rather than an individual
    value within the array. The following example shows how we can define a two-dimensional
    array and retrieve an individual value within the two dimensions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从多维数组中检索单个值，我们需要为数组的每个维度提供一个下标。如果我们不为每个维度提供下标，我们将检索数组而不是数组中的单个值。以下示例展示了我们如何定义一个二维数组并从两个维度中检索单个值：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we begin by defining a two-dimensional array. When we
    retrieve the value at index `0` of the first dimension (`multiArray[0]`), we retrieve
    the array `[1,2]`. When we retrieve the value at index `0` of the first dimension
    and index `1` of the second dimension (`multiArray[0][1]`), we retrieve the integer
    `2`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先定义了一个二维数组。当我们检索第一维索引`0`的值（`multiArray[0]`）时，我们检索到数组`[1,2]`。当我们检索第一维索引`0`和第二维索引`1`的值（`multiArray[0][1]`）时，我们检索到整数`2`。
- en: 'We can retrieve the first and last elements of an array using the `first` and
    `last` properties. The `first` and `last` properties return an optional value,
    since the values may be nil if the array is empty. The following example shows
    how to use these properties to retrieve the first and last elements of both a
    one-dimensional and a multidimensional array:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`first`和`last`属性来检索数组的第一个和最后一个元素。由于数组可能为空，因此`first`和`last`属性返回一个可选值。以下示例展示了如何使用这些属性来检索一维和二维数组的第一个和最后一个元素：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's see how we can count the elements of an array.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何计算数组的元素数量。
- en: Counting the elements of an array
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算数组元素的数量
- en: 'At times, it is essential to know the number of elements in an array. The array
    type in Swift contains a read-only `count` property. The following example shows
    how to use this property to retrieve the number of elements in both single-dimensional
    and multidimensional arrays:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，知道数组中元素的数量是至关重要的。Swift中的数组类型包含一个只读的`count`属性。以下示例展示了如何使用此属性来检索单维和多维数组中的元素数量：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value that is returned by the `count` property is the number of elements
    in the array, and not the largest valid index of the array. For non-empty arrays,
    the largest valid index is the number of elements in the array minus 1\. This
    is because the first element of the array has an index number of `0`. As an example,
    if an array has two elements, the valid indexes are `0` and `1`, while the `count`
    property would return `2`. This is illustrated in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`属性返回的值是数组中的元素数量，而不是数组的最大有效索引。对于非空数组，最大有效索引是数组元素数量减1。这是因为数组的第一个元素具有索引号`0`。例如，如果一个数组有两个元素，有效的索引是`0`和`1`，而`count`属性将返回`2`。以下代码说明了这一点：'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we attempt to retrieve an element from an array that is outside the range
    of the array, the application will throw an **array index out of range** error.
    Therefore, if we are unsure of the size of an array, it is a good practice to
    verify that the index is not outside the range of the array. The following examples
    illustrate this concept:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从数组中检索超出数组范围的元素，应用程序将抛出**数组索引越界**错误。因此，如果我们不确定数组的大小，验证索引是否不在数组范围之外是一个好的做法。以下示例说明了这个概念：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the first block would throw an **array index out of range**
    error because we are attempting to access the value from the `arrayOne` array
    at index `6`; however, there are only four elements in the array. The second example
    would not throw the error because we are checking whether the `arrayTwo` array
    contains more than six elements before trying to access the element at the sixth
    index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个块将抛出**数组索引越界**错误，因为我们试图从`arrayOne`数组中索引`6`处访问值；然而，数组中只有四个元素。第二个示例不会抛出错误，因为我们试图在尝试访问第六个索引之前检查`arrayTwo`数组是否包含超过六个元素。
- en: Is the array empty?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是否为空？
- en: 'To check whether an array is empty (that is, it does not contain any elements),
    we use the `isEmpty` property. This property will return `true` if the array is
    empty and `false` if it is not. The following example shows how to check whether
    an array is empty:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查数组是否为空（即不包含任何元素），我们使用`isEmpty`属性。如果数组为空，则此属性将返回`true`；如果不为空，则返回`false`。以下示例展示了如何检查数组是否为空：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now let's see how we can shuffle an array.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何可以打乱数组。
- en: Shuffling an array
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打乱数组
- en: 'An array can be very easily shuffled using the `shuffle()` and `shuffled()`
    methods. This can be very useful if we are creating a game, such as a card game,
    where the array contains the 52 cards in the deck. To shuffle the array in place,
    the `shuffle()` method can be used; to put the shuffled results in a new array,
    leaving the original array untouched, the `shuffled()` method would be used. The
    following examples show this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以非常容易地使用`shuffle()`和`shuffled()`方法进行打乱。如果我们正在创建一个游戏，例如一副52张牌的牌局游戏，其中数组包含牌组中的所有牌，这将非常有用。要就地打乱数组，可以使用`shuffle()`方法；要将打乱的结果放入一个新数组中，同时保持原始数组不变，则应使用`shuffled()`方法。以下示例展示了这一点：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now let's look at how we can append data to an array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何将数据添加到数组中。
- en: Appending to an array
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组中添加元素
- en: 'A static array is somewhat useful but having the ability to add elements dynamically
    is what makes arrays really useful. To add an item to the end of an array, we
    can use the `append` method. The following example shows how to append an item
    to the end of an array:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数组有一定的用途，但能够动态地添加元素才是数组真正有用的地方。要将一个项目添加到数组的末尾，我们可以使用`append`方法。以下示例展示了如何将一个项目添加到数组的末尾：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Swift also allows us to use the addition assignment operator (`+=`) to append
    an array to another array. The following example shows how to use the addition
    assignment operator to append an array to the end of another array:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Swift还允许我们使用加法赋值运算符（`+=`）将一个数组添加到另一个数组中。以下示例展示了如何使用加法赋值运算符将一个数组添加到另一个数组的末尾：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The way you append an element to the end of an array is really up to you. Personally,
    I prefer the assignment operator because, to me, it is a bit easier to read, but
    we will be using both in this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你将元素追加到数组末尾的方式完全取决于你。我个人更喜欢赋值操作符，因为它对我来说更容易阅读，但在这本书中我们将使用两种方法。
- en: Inserting a value into an array
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将值插入到数组中
- en: 'We can insert a value into an array by using the `insert` method. The `insert`
    method will move all the items up one spot, starting at the specified index, to
    make room for the new element, and then insert the value into the specified index.
    The following example shows how to use this method to insert a new value into
    an array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `insert` 方法将值插入到数组中。`insert` 方法将所有项目向上移动一个位置，从指定的索引开始，为新元素腾出空间，然后将值插入到指定的索引。以下示例展示了如何使用此方法将新值插入到数组中：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have seen how to insert a value, let's see how we can replace an
    element within an array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何插入一个值，让我们看看我们如何可以在数组中替换一个元素。
- en: Replacing elements in an array
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数组中替换元素
- en: 'We use the subscript syntax to replace elements in an array. Using the subscript,
    we pick the element of the array we wish to update and then use the assignment
    operator to assign a new value. The following example shows how we will replace
    a value in an array:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下标语法在数组中替换元素。使用下标，我们选择要更新的数组元素，然后使用赋值操作符分配新值。以下示例展示了我们如何在数组中替换一个值：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You cannot update a value that is outside the current range of the array. Attempting
    to do so will throw the same **index out of range** exception that was thrown
    when we tried to insert a value outside the range of the array.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能更新数组当前范围之外的值。尝试这样做将抛出与我们在尝试将值插入到数组范围之外时抛出的相同的**索引越界**异常。
- en: Now let's look at how we can remove elements from an array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何可以从数组中移除元素。
- en: Removing elements from an array
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中移除元素
- en: 'There are three methods that we can use to remove one or all of the elements
    in an array. These methods are `removeLast()`, `remove(at:)`, and `removeAll()`.
    The following example shows how to use the three methods to remove elements from
    an array:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三种方法来移除数组中的一个或所有元素。这些方法是 `removeLast()`、`remove(at:)` 和 `removeAll()`。以下示例展示了如何使用这三种方法从数组中移除元素：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `removeLast()` and `remove(at:)` methods will also return the value of
    the element being removed. Therefore, if we want to know the value of the item
    that was removed, we can rewrite the `remove(at:)` and `removeLast()` lines to
    capture the value, as shown in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeLast()` 和 `remove(at:)` 方法也会返回被移除元素的值。因此，如果我们想知道被移除项的值，我们可以重写 `remove(at:)`
    和 `removeLast()` 行来捕获值，如下例所示：'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Merging two arrays
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并两个数组
- en: 'To create a new array by adding two arrays together, we use the addition (`+`)
    operator. The following example shows how to use the addition (`+`) operator to
    create a new array that contains all the elements of two other arrays:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过将两个数组相加来创建一个新数组，我们使用加法（`+`）操作符。以下示例展示了如何使用加法（`+`）操作符创建一个包含两个其他数组所有元素的新数组：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, `arrayOne` and `arrayTwo` are left unchanged, while the
    `combined` array contains the elements from `arrayOne`, followed by the elements
    from `arrayTwo`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`arrayOne` 和 `arrayTwo` 保持不变，而 `combined` 数组包含来自 `arrayOne` 的元素，随后是来自
    `arrayTwo` 的元素。
- en: Retrieving a subarray from an array
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中检索子数组
- en: 'We can retrieve a subarray from an existing array by using the subscript syntax
    with a range operator. The following example shows how to retrieve a range of
    elements from an existing array:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用带范围操作符的下标语法从现有数组中检索子数组。以下示例展示了如何从现有数组中检索一系列元素：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The operator (three periods) is known as a **two-sided range operator**. The
    range operator in the preceding code says that we want all the elements from `2`
    to `4` inclusively (elements `2` and `4` as well as what is between them). There
    is another two-sided range operator, ..<, known as the **half-open range operator**.
    The half-open range operator functions the same as the previous range operator;
    however, it excludes the last element. The following example shows how to use
    the `..<` operator:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符（三个点）被称为**双边范围操作符**。前面代码中的范围操作符表示我们想要从 `2` 到 `4`（包括元素 `2` 和 `4` 以及它们之间的所有元素）的所有元素。还有一个双边范围操作符，..<，被称为**半开范围操作符**。半开范围操作符的功能与前面的范围操作符相同；然而，它排除了最后一个元素。以下示例展示了如何使用
    `..<` 操作符：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, the subarray contains two elements: `3` and `4`.
    A two-sided range operator has numbers on either side of the operator. In Swift,
    we are not limited to two-sided range operators; we can also use one-sided range
    operators. The following examples show how we can use one-sided range operators:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，子数组包含两个元素：`3` 和 `4`。双向范围操作符在操作符两侧都有数字。在 Swift 中，我们不仅限于使用双向范围操作符；我们还可以使用单侧范围操作符。以下示例展示了我们如何使用单侧范围操作符：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The one-sided range operators were added in version 4 of the Swift language.
    The previous range operators enable us to access a contiguous range of elements
    from an array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单侧范围操作符是在 Swift 语言的第 4 版中添加的。之前的范围操作符使我们能够从数组中访问连续的元素范围。
- en: 'SE-0270 enables us to fetch elements that are not contiguous, which means the
    elements may not be next to each other. This update to the Swift standard library
    introduced a new `RangeSet` type, which is a subrange of indexes that are non-contiguous.
    Let''s see how this works with the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SE-0270 允许我们获取非连续的元素，这意味着元素可能不是相邻的。这个 Swift 标准库的更新引入了一个新的 `RangeSet` 类型，它是一个非连续索引的子范围。让我们看看以下代码是如何工作的：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this code, we define an array that contains the numbers `1` through `10`.
    We then use the `subranges(where:)` method to retrieve the even elements. This
    method takes a closure as the argument, which hasn't been discussed yet. For now,
    we just need to know that we are able to retrieve non-contiguous subarrays and
    we will look at this again in *Chapter 14*, *Working with Closures*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了一个包含数字 `1` 到 `10` 的数组。然后我们使用 `subranges(where:)` 方法检索偶数元素。此方法接受一个闭包作为参数，这尚未讨论。现在我们只需要知道我们能够检索非连续的子数组，我们将在第
    14 章 *使用闭包* 中再次讨论这一点。
- en: Making bulk changes to an array
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量更改数组
- en: 'We can use the subscript syntax with a range operator to change the values
    of multiple elements. The following example shows how to do this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用范围操作符的索引语法来更改多个元素的值。以下示例展示了如何进行此操作：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, the elements at indices `1` and `2` will be changed to
    the numbers `12` and `13`; therefore, `arrayOne` will contain `1`, `12`, `13`,
    `4`, and `5`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，索引 `1` 和 `2` 处的元素将被更改为数字 `12` 和 `13`；因此，`arrayOne` 将包含 `1`、`12`、`13`、`4`
    和 `5`。
- en: 'The number of elements that you are changing in the range operator does not
    need to match the number of values that you are passing in. Swift makes bulk changes
    by first removing the elements defined by the range operator and then inserting
    the new values. The following example demonstrates this concept:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围操作符中更改的元素数量不需要与传递的值的数量相匹配。Swift 通过首先移除由范围操作符定义的元素，然后插入新值来执行批量更改。以下示例演示了这一概念：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, the `arrayOne` array starts with five elements. We then
    replace the range of elements `1` to `3` inclusively. This causes elements `1`
    through `3` (that is, three elements) to be removed from the array first. After
    those three elements are removed, then the two new elements (`12` and `13`) are
    added to the array, starting at index `1`. After this is complete, `arrayOne`
    will contain four elements: `1`, `12`, `13`, and `5`. Using the same logic, we
    can also add more elements than we remove. The following example illustrates this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`arrayOne` 数组开始时有五个元素。然后我们替换从 `1` 到 `3`（包括 `3`）的元素范围。这首先会导致从数组中移除 `1`
    到 `3`（即三个元素）。在这三个元素被移除之后，然后向数组中添加两个新元素（`12` 和 `13`），从索引 `1` 开始。完成此操作后，`arrayOne`
    将包含四个元素：`1`、`12`、`13` 和 `5`。使用相同的逻辑，我们也可以添加比移除更多的元素。以下示例说明了这一点：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, `arrayOne` starts with five elements. We then say that
    we want to replace the range of elements `1` through `3` inclusively. As in the
    previous example, this causes elements `1` through `3` (three elements) to be
    removed from the array. We then add four elements (`12`, `13`, `14`, and `15`)
    to the array, starting at index `1`. After this is complete, `arrayOne` will contain
    six elements: `1`, `12`, `13`, `14`, `15`, and `5`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`arrayOne` 数组开始时有五个元素。然后我们说我们想要替换从 `1` 到 `3`（包括 `3`）的元素范围。与前面的例子一样，这会导致从数组中移除
    `1` 到 `3`（即三个元素）。然后我们在索引 `1` 处向数组中添加四个元素（`12`、`13`、`14` 和 `15`）。完成此操作后，`arrayOne`
    将包含六个元素：`1`、`12`、`13`、`14`、`15` 和 `5`。
- en: Algorithms for arrays
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组算法
- en: Swift arrays have several methods that take a closure as their argument. These
    methods transform the array in a way defined by the code in the closure. Closures
    are self-contained blocks of code that can be passed around, and are similar to
    blocks in Objective-C and lambdas in other languages. We will discuss closures
    in depth in *Chapter 14*, *Working with Closures*. For now, the goal is to become
    familiar with how the algorithms work in Swift.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 数组有几个方法，它们接受一个闭包作为参数。这些方法会根据闭包中的代码以某种方式转换数组。闭包是自包含的代码块，可以被传递，类似于 Objective-C
    中的 blocks 和其他语言中的 lambdas。我们将在第 14 章 *使用闭包* 中深入讨论闭包。现在，目标是熟悉 Swift 中算法的工作方式。
- en: Sort
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序
- en: 'The **sort** algorithm sorts an array in place. This means that, when the `sort()`
    method is used, the original array is replaced with the sorted one. The closure
    takes two arguments (represented by `$0` and `$1`), and it should return a Boolean
    value that indicates whether the first element should be placed before the second
    element. The following code shows how to use the sort algorithm:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 算法在原地排序数组。这意味着当使用 `sort()` 方法时，原始数组会被排序后的数组替换。闭包接受两个参数（分别由 `$0` 和 `$1`
    表示），并且它应该返回一个布尔值，表示第一个元素是否应该放在第二个元素之前。以下代码展示了如何使用排序算法：'
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code will sort the array in ascending order. We know this because
    the rule will return true if the first number (`$0`) is less than the second number
    (`$1`). Therefore, when the sort algorithm begins, it compares the first two numbers
    (`9` and `3`) and returns `true` if the first number (`9`) is less than the second
    number (`3`). In our case, the rule returns `false`, so the numbers are reversed.
    The algorithm continues sorting in this manner until all of the numbers are sorted
    in the correct order.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将按升序排序数组。我们知道这是因为规则会在第一个数字（`$0`）小于第二个数字（`$1`）时返回 `true`。因此，当排序算法开始时，它比较前两个数字（`9`
    和 `3`），如果第一个数字（`9`）小于第二个数字（`3`），则返回 `true`。在我们的例子中，规则返回 `false`，所以数字被反转。算法以这种方式继续排序，直到所有数字都按正确顺序排序。
- en: 'To sort an array in ascending order, we can actually use the `sort()` method
    by itself without using a closure as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要按升序排序数组，我们实际上可以使用 `sort()` 方法本身，而不使用闭包，如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding examples sorted the array in a numerically-increasing order;
    if we wanted to reverse the order, we would reverse the arguments in the closure.
    The following code shows how to reverse the sort order:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例按数值递增顺序排序了数组；如果我们想反转顺序，我们会在闭包中反转参数。以下代码展示了如何反转排序顺序：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we run this code, `arrayOne` will contain the elements `9`, `8`, `6`, `5`,
    `3`, and `2`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，`arrayOne` 将包含元素 `9`、`8`、`6`、`5`、`3` 和 `2`。
- en: 'The preceding code can be simplified by using the `sort(by:)` method and passing
    in a greater-than or less-than operator, as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以通过使用 `sort(by:)` 方法并传入大于或小于运算符来简化，如下所示：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, by using the less-than operator, the array is sorted
    in ascending order. If we'd used the greater-than operator, the array would have
    been sorted in descending order.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，通过使用小于运算符，数组被按升序排序。如果我们使用大于运算符，数组将按降序排序。
- en: Sorted
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序
- en: 'While the sort algorithm sorts the array in place (that is, it replaces the
    original array), the **sorted** algorithm does not change the original array;
    it instead creates a new array with the sorted elements from the original array.
    The following example shows how to use the sorted algorithm:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然排序算法在原地排序数组（即，它替换了原始数组），但 `sorted` 算法不会改变原始数组；它相反地创建了一个包含原始数组中排序元素的新数组。以下示例展示了如何使用排序算法：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After we run this code, `arrayOne` will contain the original unsorted array
    (`9`, `3`, `6`, `2`, `8`, and `5`) and the `sorted` array will contain the new
    sorted array (`2`, `3`, `5`, `6`, `8`, and `9`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此代码后，`arrayOne` 将包含原始未排序的数组（`9`、`3`、`6`、`2`、`8` 和 `5`），而 `sorted` 数组将包含新的排序后的数组（`2`、`3`、`5`、`6`、`8`
    和 `9`）。
- en: Filter
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: The **filter** algorithm will return a new array by filtering the original array.
    This is one of the most powerful array algorithms and may end up being the one
    you use the most. If you need to retrieve a subset of an array based on a set
    of rules, I recommend using this algorithm rather than trying to write your own
    method to filter the array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**filter** 算法将通过过滤原始数组来返回一个新的数组。这是最强大的数组算法之一，最终可能会成为你使用最多的算法之一。如果你需要根据一组规则检索数组的子集，我建议使用此算法而不是尝试编写自己的方法来过滤数组。'
- en: 'The closure takes one argument, and it should return a Boolean `true` if the
    element should be included in the new array, as shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包接受一个参数，并且它应该返回一个布尔值 `true`，如果元素应该包含在新的数组中，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, the rule that we are passing to the algorithm returns
    `true` if the number is greater than `3` and less than `7`; therefore, any number
    that is greater than `3` and less than `7` is included in the new `filtered` array.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们传递给算法的规则是，如果数字大于 `3` 且小于 `7`，则返回 `true`；因此，任何大于 `3` 且小于 `7` 的数字都被包含在新的
    `filtered` 数组中。
- en: 'This next example shows how we can retrieve a subset of cities that contain
    the letter `o` in their name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了我们如何检索包含其名称中字母 `o` 的城市子集：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we use the `range(of:)` method to return `true` if the
    string contains the letter `o`. If the method returns `true`, the string is included
    in the `filtered` array.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `range(of:)` 方法来返回字符串是否包含字母 `o`。如果方法返回 `true`，则字符串被包含在 `filtered`
    数组中。
- en: Map
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Map
- en: 'While the filter algorithm is used to select only certain elements of an array,
    **map** is used to apply logic to all elements in the array. The following example
    shows how to use the map algorithm to divide each number by 10:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然过滤器算法用于选择数组中的某些元素，但 **map** 用于对数组中的所有元素应用逻辑。以下示例展示了如何使用 map 算法将每个数字除以 10：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, the new array contains the numbers `1`, `2`, `3`, and
    `4`, which is the result of dividing each element of the original array by `10`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，新数组包含数字 `1`、`2`、`3` 和 `4`，这是通过将原始数组中的每个元素除以 `10` 得到的结果。
- en: 'The new array created by the map algorithm is not required to contain the same
    element types as the original array; however, all the elements in the new array
    must be of the same type. In the following example, the original array contains
    integer values, but the new array created by the map algorithm contains string
    elements:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由 map 算法创建的新数组不需要包含与原始数组相同的元素类型；然而，新数组中的所有元素必须属于同一类型。在以下示例中，原始数组包含整数值，但由 map
    算法创建的新数组包含字符串元素：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we created an array of strings that appends the numbers
    from the original array to the `num:` string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个字符串数组，该数组将原始数组中的数字追加到 `num:` 字符串。
- en: Count
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数
- en: 'We can combine the filter algorithm with the `count` method to count the number
    of items in an array that match a rule. For example, if we had an array that contained
    the grades from a test, we could use the **count** algorithm to count how many
    of the grades were greater than or equal to `90`, like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将过滤器算法与 `count` 方法结合起来，以计算匹配规则的数组中项目数量。例如，如果我们有一个包含测试成绩的数组，我们可以使用 **count**
    算法来计算有多少成绩大于或等于 `90`，如下所示：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As we did with the filter algorithm, we can use methods from the array type,
    such as the `range(of:)` method from the string type. For example, rather than
    returning a subset of cities that contain the letter `o` in their name, as we
    did in the filter algorithm, we can count the cities like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们使用过滤器算法一样，我们可以使用数组类型的方法，例如字符串类型的 `range(of:)` 方法。例如，而不是像在过滤器算法中那样返回包含其名称中字母
    `o` 的城市子集，我们可以这样计数城市：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding count, the `count1` constant contains `3`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的计数中，`count1` 常量包含 `3`。
- en: Diff
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Diff
- en: In Swift 5.1 with SE-0240, the **Diff** algorithm was introduced. This addition
    to the Swift language enables support for `diff` and patching of ordered collections
    like arrays. To really see the power of this change we need to understand how
    `switch` statements work, which is introduced in *Chapter 6*, *Control Flow*;
    therefore, we will briefly show how the Diff algorithm works here with the `applying`
    method. We will look at this algorithm more when we cover the `switch` statement
    in *Chapter 6*, *Control Flow*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 5.1 和 SE-0240 中，引入了 **Diff** 算法。这个 Swift 语言的补充使得支持有序集合（如数组）的 `diff`
    和修补成为可能。要真正看到这个变化的威力，我们需要了解 `switch` 语句的工作原理，这在 *第 6 章*，*控制流* 中介绍；因此，我们将简要展示如何使用
    `applying` 方法实现 Diff 算法。我们将在 *第 6 章*，*控制流* 中介绍 `switch` 语句时更详细地研究这个算法。
- en: 'Let''s look at the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we started off by creating two arrays. We then used
    the `difference(from:)` method, which returns the difference between the two arrays.
    This new array would now contain the values: `100`, `98`, `95`, `91`, `83`, `88`,
    and `72`. The return value is a collection of enumerations that tell us how we
    can produce a collection, from one collection, that will contain the same elements
    as another collection. This might not make a whole lot of sense right now, but
    as we dive into more of this, it will become clear.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了两个数组。然后我们使用了 `difference(from:)` 方法，它返回两个数组之间的差异。这个新数组现在将包含以下值：`100`，`98`，`95`，`91`，`83`，`88`
    和 `72`。返回值是一个枚举集合，告诉我们如何从一个集合生成一个包含另一个集合相同元素的集合。现在这可能不太容易理解，但当我们深入研究时，它将变得清晰。
- en: The last line uses the `applying()` method to apply the changes to the `scores1`
    array and returns an array that has the same elements as the `scores2` array;
    therefore, after this method is called, the `newArray` array contains the same
    elements as the `scores2` array.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行使用 `applying()` 方法将更改应用到 `scores1` 数组上，并返回一个与 `scores2` 数组具有相同元素的数组；因此，在调用此方法之后，`newArray`
    数组包含与 `scores2` 数组相同的元素。
- en: forEach
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forEach
- en: 'We can use the `forEach` algorithm to iterate over a sequence. The following
    example shows how we would do this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `forEach` 算法遍历一个序列。以下示例展示了我们如何进行操作：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This example will print the following results to the console:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将在控制台打印以下结果：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: While using the `forEach` algorithm is very easy, it does have some limitations.
    The recommended way to iterate over an array is to use the `for-in` loop, which
    we will see in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `forEach` 算法非常简单，但它确实有一些限制。推荐遍历数组的方式是使用 `for-in` 循环，我们将在下一节中看到。
- en: Iterating over an array
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'We can iterate over all elements of an array, in order, with a `for-in` loop.
    The `for-in` loop will execute one or more statements for each element of the
    array. We will discuss the `for-in` loop in greater detail in *Chapter 6*, *Control
    Flow*. The following example shows how we would iterate over the elements of an
    array:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for-in` 循环按顺序遍历数组的所有元素。`for-in` 循环将为数组的每个元素执行一个或多个语句。我们将在 *第 6 章*，*控制流*
    中更详细地讨论 `for-in` 循环。以下示例展示了我们如何遍历数组的元素：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding example, the `for-in` loop iterates over the array and executes
    the `print(item)` line for each element in the array. If we run this code, it
    will display the following results in the console:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`for-in` 循环遍历数组，并为数组中的每个元素执行 `print(item)` 行。如果我们运行此代码，它将在控制台显示以下结果：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are times when we would like to iterate over an array, as we did in the
    preceding example, but we would also like to know the index, as well as the value
    of an element. To do this, we can use the `enumerated` method of an array, which
    returns a tuple for each item in the array that contains both the index and value
    of the element. The following example shows how to use this function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们希望遍历数组，就像前面的例子中那样，但我们还希望知道元素的索引以及其值。为此，我们可以使用数组的 `enumerated` 方法，它为数组中的每个元素返回一个元组，包含元素的索引和值。以下示例展示了如何使用此函数：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code will display the following results in the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在控制台显示以下结果：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that we have introduced arrays in Swift, let's move on to dictionaries.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Swift 中介绍了数组，让我们继续介绍字典。
- en: Dictionaries
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: While dictionaries are not as commonly used as arrays, they have additional
    functionality that makes them incredibly powerful. A dictionary is a container
    that stores multiple key-value pairs, where all the keys are of the same type
    and all the values are of the same type. The key is used as a unique identifier
    for the value. A dictionary does not guarantee the order in which the key-value
    pairs are stored since we look up the values by key rather than by the index of
    the value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字典不像数组那样常用，但它们具有额外的功能，这使得它们非常强大。字典是一个容器，存储多个键值对，其中所有键都是同一类型，所有值也都是同一类型。键用作值的唯一标识符。由于我们是通过键而不是值的索引来查找值，因此字典不保证键值对存储的顺序。
- en: 'Dictionaries are good for storing items that map to unique identifiers, where
    the unique identifier should be used to retrieve the item. Countries with their
    abbreviations are a good example of items that can be stored in a dictionary.
    In the following table, we show countries with their abbreviations as key-value
    pairs:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 字典非常适合存储与唯一标识符相对应的项目，其中唯一标识符应用于检索项目。国家和它们的缩写是字典中可以存储的项目的一个很好的例子。在下面的表中，我们展示了国家和它们的缩写作为键值对：
- en: '| Key | Value |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 键 | 值 |'
- en: '| US | United States |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| US | 美国 |'
- en: '| IN | India |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| IN | 印度 |'
- en: '| UK | United Kingdom |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| UK | 英国 |'
- en: 'Table 5.1: Countries and their abbreviations'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：国家和它们的缩写
- en: Creating and initializing dictionaries
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和初始化字典
- en: 'We can initialize a dictionary using a dictionary literal, similarly to how
    we initialized an array with the array literal. The following example shows how
    to create a dictionary using the key-value pairs in the preceding chart:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典字面量来初始化字典，这与我们使用数组字面量初始化数组的方式类似。以下示例展示了如何使用前面的图表中的键值对创建字典：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding code creates an immutable dictionary that contains each of the
    key-value pairs in the chart we saw before. Just like the array, to create a mutable
    dictionary we will need to use the `var` keyword in place of `let`. The following
    example shows how to create a mutable dictionary that contains the countries:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个不可变的字典，其中包含我们在之前图表中看到的每个键值对。就像数组一样，要创建一个可变的字典，我们需要在`let`的位置使用`var`关键字。以下示例展示了如何创建一个包含国家的可变字典：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding two examples, we created a dictionary where the key and value
    were both strings. The compiler inferred that the key and value were strings because
    that was the type of the keys and values used to initiate the dictionary. If we
    wanted to create an empty dictionary, we would need to tell the compiler what
    the key and value types are. The following examples create various dictionaries
    with different key-value types:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个示例中，我们创建了一个字典，其中键和值都是字符串。编译器推断出键和值都是字符串，因为这是初始化字典时使用的键和值的类型。如果我们想创建一个空字典，我们需要告诉编译器键和值的类型。以下示例创建具有不同键值类型的各种字典：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If we want to use a custom object as the key in a dictionary, we will need to
    make the custom object conform to the **Hashable** protocol from Swift's standard
    library. We will discuss protocols extensively later in this book, but for now
    just understand that it is possible to use custom objects as a key in a dictionary.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在字典中使用自定义对象作为键，我们需要使自定义对象符合 Swift 标准库中的 **Hashable** 协议。我们将在本书的后面部分广泛讨论协议，但就现在而言，只需了解可以使用自定义对象作为字典中的键。
- en: Now let's see how we can access the values of a dictionary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何访问字典的值。
- en: Accessing dictionary values
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问字典值
- en: 'We use the subscript syntax to retrieve the value for a particular key. If
    the dictionary does not contain the key we are looking for, the dictionary will
    return `nil`; therefore, the variable returned from this lookup is an optional
    variable. The following example shows how to retrieve a value from a dictionary
    using its key in the subscript syntax:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下标语法来检索特定键的值。如果字典不包含我们正在寻找的键，字典将返回`nil`；因此，从这个查找返回的变量是一个可选变量。以下示例展示了如何使用下标语法从字典中检索值：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, the `name` variable contains the `United States` string.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`name`变量包含`美国`字符串。
- en: Counting the keys or values in a dictionary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算字典中的键或值数量
- en: 'We use the `count` property of the dictionary to get the number of key-value
    pairs in the dictionary. The following example shows how to use this property:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字典的`count`属性来获取字典中键值对的数量。以下示例展示了如何使用此属性：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, the `cnt` variable will contain the number `3` since
    there are three key-value pairs in the dictionary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`cnt`变量将包含数字`3`，因为字典中有三个键值对。
- en: Is the dictionary empty?
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典是否为空？
- en: 'To test whether a dictionary contains any key-value pairs, we can use the `isEmpty`
    property. This property will return `false` if the dictionary contains one or
    more key-value pairs and `true` if it is empty. The following example shows us
    how to use this property to determine whether our dictionary contains any key-value
    pairs:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个字典是否包含任何键值对，我们可以使用`isEmpty`属性。如果字典包含一个或多个键值对，则此属性将返回`false`；如果它是空的，则返回`true`。以下示例展示了如何使用此属性来确定我们的字典是否包含任何键值对：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, the `isEmpty` property returned `false` as there are
    three key-value pairs in the dictionary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`isEmpty`属性返回`false`，因为字典中有三个键值对。
- en: Updating the value of a key
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新键的值
- en: 'To update the value of a key in a dictionary, we can use either the subscript
    syntax or the `updateValue(_: ,forKey:)` method. The `updateValue(_:, forKey:)`
    method has an additional feature that the subscript syntax doesn''t: it returns
    the original value associated with the key prior to changing the value. The following
    example shows how to use both the subscript syntax and the `updateValue(_:, forKey:)`
    method to update the value of a key:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字典中更新键的值，我们可以使用下标语法或`updateValue(_:, forKey:)`方法。`updateValue(_:, forKey:)`方法有一个下标语法没有的附加功能：它在更改值之前返回与键关联的原始值。以下示例展示了如何使用下标语法和`updateValue(_:,
    forKey:)`方法来更新键的值：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding code, we use the subscript syntax to change the value associated
    with the `UK` key from `United Kingdom` to `Great Britain`. The original value
    of `United Kingdom` was not saved prior to replacing it. We then used the `updateValue(_:,
    forKey:)` method to change the value associated with the `UK` key from `Great
    Britain` to `Britain`. With the `updateValue(_:, forKey:)` method, the original
    value of `Great Britain` is assigned to the `orig` variable prior to changing
    the value in the dictionary.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用下标语法将`UK`键关联的值从`United Kingdom`更改为`Great Britain`。在替换之前，我们没有保存`United
    Kingdom`的原始值。然后我们使用`updateValue(_:, forKey:)`方法将`UK`键关联的值从`Great Britain`更改为`Britain`。使用`updateValue(_:,
    forKey:)`方法，在字典中更改值之前，将`Great Britain`的原始值赋给`orig`变量。
- en: Adding a key-value pair
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加键值对
- en: 'To add a new key-value pair to a dictionary, we can use the subscript syntax
    or the same `updateValue(_:, forKey:)` method that we used to update the value
    of a key. If we use the `updateValue(_:, forKey:)` method and the key is not currently
    present in the dictionary, this method will add a new key-value pair and return
    `nil`. The following example shows how to use both the subscript syntax and the
    `updateValue(_:, forKey:)` method to add a new key-value pair to a dictionary:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加新的键值对，我们可以使用下标语法或与更新键值相同的方法`updateValue(_:, forKey:)`。如果我们使用`updateValue(_:,
    forKey:)`方法，并且键当前不在字典中，则此方法将添加一个新的键值对并返回`nil`。以下示例展示了如何使用下标语法和`updateValue(_:,
    forKey:)`方法将新的键值对添加到字典中：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code, the `countries` dictionary starts with three key-value
    pairs and we then add a fourth key-value pair (`FR/France`) to the dictionary
    using the subscript syntax. We use the `updateValue(_:,forKey:)` method to add
    a fifth key-value pair (`DE/Germany`) to the dictionary. The `orig` variable is
    set to `nil` because the `countries` dictionary did not contain a value associated
    with the `DE` key.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`countries`字典最初有三个键值对，然后我们使用下标语法向字典中添加第四个键值对（`FR/France`）。我们使用`updateValue(_:,forKey:)`方法向字典中添加第五个键值对（`DE/Germany`）。`orig`变量被设置为`nil`，因为`countries`字典没有与`DE`键关联的值。
- en: Removing a key-value pair
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除键值对
- en: 'There may be times when we need to remove values from a dictionary. There are
    three ways to achieve this: the subscript syntax, the `removeValue(forKey:)` method,
    or the `removeAll()` method. The `removeValue(forKey:)` method returns the value
    of the key prior to removing it. The `removeAll()` method removes all the elements
    from the dictionary. The following example shows how to use all three methods
    to remove key-value pairs from a dictionary:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要从字典中删除值。有三种方法可以实现这一点：下标语法、`removeValue(forKey:)`方法或`removeAll()`方法。`removeValue(forKey:)`方法在删除之前返回键的值。`removeAll()`方法从字典中删除所有元素。以下示例展示了如何使用所有三种方法从字典中删除键值对：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, the `countries` dictionary starts off with three key-value
    pairs. We then set the value associated with the `IN` key to `nil`, which removes
    the key-value pair from the dictionary. We use the `removeValue(forKey:)` method
    to remove the key associated with the `UK` key. Prior to removing the value associated
    with the `UK` key, the `removeValue(forKey:)` method saves the value in the `orig`
    variable. Finally, we use the `removeAll()` method to remove all the remaining
    key-value pairs in the `countries` dictionary.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`countries` 字典最初包含三个键值对。然后我们将与 `IN` 键关联的值设置为 `nil`，从而从字典中删除键值对。我们使用
    `removeValue(forKey:)` 方法删除与 `UK` 键关联的键。在删除与 `UK` 键关联的值之前，`removeValue(forKey:)`
    方法将值保存在 `orig` 变量中。最后，我们使用 `removeAll()` 方法从 `countries` 字典中删除所有剩余的键值对。
- en: Now let's look at the set type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下集合类型。
- en: Set
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: The set type is a generic collection that is similar to the array type. While
    the array type is an ordered collection that may contain duplicate items, the
    set type is an unordered collection where each item must be unique.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型是一个类似于数组类型的泛型集合。虽然数组类型是有序集合，可能包含重复项，但集合类型是无序集合，其中每个元素必须是唯一的。
- en: Like the key in a dictionary, the type stored in an array must conform to the
    **Hashable** protocol. This means that the type must provide a way to compute
    a hash value for itself. All of Swift's basic types, such as `String`, `Double`,
    `Int`, and `Bool`, conform to this protocol and can be used in a set by default.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字典中的键一样，存储在数组中的类型必须符合 `Hashable` 协议。这意味着该类型必须提供一种方法来计算自己的哈希值。Swift 的所有基本类型，如
    `String`、`Double`、`Int` 和 `Bool`，都符合此协议，并且默认情况下可以用于集合。
- en: Let's look at how we would use the set type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用集合类型。
- en: Initializing a set
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化集合
- en: There are a couple of ways to initialize a set. Just like the array and dictionary
    types, Swift needs to know what type of data is going to be stored in it. This
    means that we must either tell Swift the type of data to store in the set or initialize
    it with some data so that it can infer the data type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化集合有几种方法。就像数组和字典类型一样，Swift 需要知道将要存储的数据类型。这意味着我们必须告诉 Swift 要在集合中存储的数据类型，或者用一些数据初始化它，以便它可以推断数据类型。
- en: 'Just like the array and dictionary types, we use the `var` and `let` keywords
    to declare whether the set is mutable:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组和字典类型一样，我们使用 `var` 和 `let` 关键字来声明集合是否可变：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Inserting items into a set
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将元素插入到集合中
- en: 'We use the `insert` method to insert an item into a set. If we attempt to insert
    an item that is already in the set, the item will be ignored. Here are some examples
    of inserting items into a set:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `insert` 方法将元素插入到集合中。如果我们尝试插入一个已经存在于集合中的元素，该元素将被忽略。以下是将元素插入到集合中的示例：
- en: '[PRE57]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `insert()` method returns a tuple that we can use to verify that the value
    was successfully added to the set. The following example shows how to check the
    returned value to see whether it was added successfully:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 方法返回一个元组，我们可以使用它来验证值是否成功添加到集合中。以下示例显示了如何检查返回值以查看是否成功添加：'
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, `Failed` would be printed to the console since we are attempting
    to add the `One` value to the set when it is already in the set.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，由于我们尝试将 `One` 值添加到已经包含该值的集合中，所以会打印出 `Failed` 到控制台。
- en: Determining the number of items in a set
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定集合中的元素数量
- en: 'We can use the `count` property to determine the number of items in a set.
    Here is an example of how to use this method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `count` 属性来确定集合中的元素数量。以下是如何使用此方法的示例：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When executed, this code will print the message `3 items` to the console because
    the set contains three items.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，它将在控制台打印出消息 `3 items`，因为集合包含三个元素。
- en: Checking whether a set contains an item
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查集合是否包含一个元素
- en: 'We can verify whether a set contains an item by using the `contains()` method,
    as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `contains()` 方法来验证集合是否包含一个元素，如下所示：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding example, the `contain` variable is set to `true` because the
    set contains `a` string with a value of `Two`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`contain` 变量被设置为 `true`，因为集合包含一个值为 `Two` 的字符串。
- en: Iterating over a set
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'We can use the `for-in` statement to iterate over the items in a set as we
    did with arrays. The following example shows how we would iterate through the
    items in a set:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for-in` 语句遍历集合中的元素，就像我们处理数组一样。以下示例显示了如何遍历集合中的元素：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding example will print out each item in the set to the console.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将打印出集合中的每个元素到控制台。
- en: Removing items in a set
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除集合中的项目
- en: 'We can remove a single item or all the items in a set. To remove a single item,
    we would use the `remove()` method and, to remove all the items, we would use
    the `removeAll()` method. The following example shows how to remove items from
    a set:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除集合中的一个项目或所有项目。要移除单个项目，我们会使用`remove()`方法，要移除所有项目，我们会使用`removeAll()`方法。以下示例展示了如何从集合中移除项目：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Set operations
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作
- en: 'Apple has provided four methods that we can use to construct a set from two
    other sets. These operations can be performed in place, on one of the sets, or
    used to create a new set. These operations are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了四种方法，我们可以使用这些方法从两个其他集合中构建一个集合。这些操作可以在一个集合上就地执行，或者用于创建一个新的集合。这些操作如下：
- en: '`union`and`formUnion`: These create a set with all the unique values from both
    sets and can be thought of as removing the duplicates.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`union`和`formUnion`：这些方法创建一个集合，包含两个集合的所有唯一值，可以理解为移除了重复项。'
- en: '`subtracting`and`subtract`: These create a set with values from the first set
    that are not in the second set.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtracting`和`subtract`：这些方法创建一个集合，包含第一个集合中不在第二个集合中的值。'
- en: '`intersection`and`formIntersection`: These create a set with values that are
    common to both sets.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersection`和`formIntersection`：这些方法创建一个集合，包含两个集合共有的值。'
- en: '`symmetricDifference`and`formSymmetricDifference`: These create a new set with
    values that are in either set, but not in both sets.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symmetricDifference`和`formSymmetricDifference`：这些方法创建一个新集合，包含在任一集合中但不在两个集合中的值。'
- en: 'Let''s look at some examples and see the results that can be obtained from
    each of these operations. For all the examples of set operations, we will be using
    the following two sets:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子，看看可以从这些操作中获得哪些结果。对于所有集合操作的例子，我们将使用以下两个集合：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first example uses the `union` method. This method takes the unique values
    from both sets to make another set:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子使用了`union`方法。该方法从两个集合中提取唯一值以创建另一个集合：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `newSetUnion` variable will contain the following values: `One`, `Two`,
    `Three`, `abc`, `def`, and `ghi`. We can use the `formUnion` method to perform
    the `union` function in place without creating a new set:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`newSetUnion`变量将包含以下值：`One`、`Two`、`Three`、`abc`、`def`和`ghi`。我们可以使用`formUnion`方法就地执行`union`函数，而不创建一个新的集合：'
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this example, the `mySet1set` set will contain all the unique values from
    the `mySet1` and `mySet2` sets.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mySet1set`集合将包含`mySet1`和`mySet2`集合的所有唯一值。
- en: 'Now let''s look at the `subtract` and `subtracting` methods. These methods
    will create a set with the values from the first set that are not in the second
    set:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`subtract`和`subtracting`方法。这些方法将创建一个集合，包含第一个集合中不在第二个集合中的值：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this example, the `newSetSubtract` variable will contain the `Two` and `Three`
    values because those are the only two values that are not also in the second set.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`newSetSubtract`变量将包含`Two`和`Three`值，因为这两个值是唯一不在第二个集合中的值。
- en: 'We use the `subtract` method to perform the subtraction function in place without
    creating a new set:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`subtract`方法就地执行减法函数，而不创建一个新的集合：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this example, the `mySet1` set will contain the `Two` and `Three` values
    because those are the only two values that are not in the `mySet2` set.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mySet1`集合将包含`Two`和`Three`值，因为这两个值是唯一不在`mySet2`集合中的值。
- en: 'Now let''s look at the `intersection` method, which creates a new set from
    the values that are common between the two sets:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`intersection`方法，它通过创建一个新集合，从两个集合中提取共同的值：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this example, the `newSetIntersect` variable will contain the `One` and `abc`
    values since they are the values that are common between the two sets.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`newSetIntersect`变量将包含`One`和`abc`值，因为它们是两个集合共有的值。
- en: 'We can use the `formIntersection()` method to perform the intersection function
    in place without creating a new set:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`formIntersection()`方法就地执行交集函数，而不创建一个新的集合：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this example, the `mySet1` set will contain the `One` and `abc` values since
    they are the values that are common between the two sets.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mySet1`集合将包含`One`和`abc`值，因为它们是两个集合共有的值。
- en: 'Finally, let''s look at the `symmetricDifference()` methods. These methods
    will create a new set with values that are in either set, but not in both:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`symmetricDifference()`方法。这些方法将创建一个新集合，包含在任一集合中但不在两个集合中的值：
- en: '[PRE70]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this example, the `newSetExclusiveOr` variable will contain the `Two`, `Three`,
    `def`, and `ghi` values.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`newSetExclusiveOr`变量将包含`Two`、`Three`、`def`和`ghi`值。
- en: 'To perform this method in place, we use the `fromSymmetricDifference()` method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在原地执行此方法，我们使用 `fromSymmetricDifference()` 方法：
- en: '[PRE71]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: These four operations (union, subtraction, intersection, and symmetric difference)
    add functionality that is not present with arrays. Combined with faster lookup
    speeds, as compared to an array, the set type can be a very useful alternative
    when the order of the collection is not important and the instances in the collection
    must be unique.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种操作（并集、减集、交集和对称差集）增加了数组所不具备的功能。与数组相比，集合类型具有更快的查找速度，当集合的顺序不重要且集合中的实例必须是唯一的时候，集合类型可以是一个非常有用的替代方案。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered Swift collections. Having a good understanding of
    the native collection types of Swift is essential to architecting and developing
    applications in Swift since all but the most basic applications use them.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Swift 集合。对 Swift 的原生集合类型有良好的理解对于架构和开发 Swift 应用程序至关重要，因为除了最基本的应用程序之外，所有应用程序都使用它们。
- en: The three Swift collection types are arrays, sets, and dictionaries. Arrays
    store data as an ordered collection. Sets store data as an unordered collection
    of unique values. Dictionaries store data in an unordered collection of key-value
    pairs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的三种集合类型是数组、集合和字典。数组以有序集合的形式存储数据。集合以无序集合的形式存储唯一值。字典以无序集合的形式存储键值对。
- en: In the next chapter, we will look at how to use Swift's control flow statements.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 Swift 的控制流语句。
