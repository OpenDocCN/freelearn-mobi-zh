<html><head></head><body>
		<div><h1 id="_idParaDest-238" class="chapter-number"><a id="_idTextAnchor401"/><st c="0">13</st></h1>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor402"/><st c="3">Exposing Your App to Siri with App Intents</st></h1>
			<p><st c="46">For many years, apps have lived and operated alone in system space. </st><st c="115">Each app is totally isolated from the others, without the capability to communicate or </st><st c="202">expose data.</st></p>
			<p><st c="214">Over the years, things have changed a bit. </st><st c="258">One of the most exciting</st><a id="_idIndexMarker810"/><st c="282"> features apps gained was enhancements in </st><strong class="bold"><st c="324">App Intents</st></strong><st c="335">. At this point, you should be familiar with App Intents—we discussed them in </st><a href="B21795_05.xhtml#_idTextAnchor186"><em class="italic"><st c="413">Chapter 5</st></em></a><st c="422">. However, in iOS 18, App Intents became even more powerful as they worked closely with Apple Intelligence and not just with WidgetKit. </st><st c="558">That’s why we are going to cover App Intents in </st><st c="606">more detail.</st></p>
			<p><st c="618">In this chapter, we will learn about </st><st c="656">the following:</st></p>
			<ul>
				<li><st c="670">Understanding the App </st><st c="693">Intents concept</st></li>
				<li><st c="708">Creating a simple </st><st c="727">app intent</st></li>
				<li><st c="737">Formalizing our content using </st><st c="768">app entities</st></li>
				<li><st c="780">Adjusting our app intents to work with </st><st c="820">Apple Intelligence</st></li>
			</ul>
			<p><st c="838">The ability of App Intents to open up our app is truly remarkable and full of potential. </st><st c="928">But first, let’s understand the App </st><st c="964">Intents concept.</st></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor403"/><st c="980">Technical requirements</st></h1>
			<p><st c="1003">For this chapter, it’s essential to download Xcode version 16.0 or higher from the </st><st c="1087">App Store.</st></p>
			<p><st c="1097">Ensure you’re operating on the most recent version of macOS (Ventura or newer). </st><st c="1178">Just search for Xcode in the App Store, choose the latest version, and proceed with the download. </st><st c="1276">Open Xcode and complete any further setup instructions that appear. </st><st c="1344">After Xcode is completely up and running, you </st><st c="1390">can begin.</st></p>
			<p><st c="1400">This chapter includes many code examples, some of which can be found in the following GitHub </st><st c="1494">repository:</st><a id="_idTextAnchor404"/><a id="_idTextAnchor405"/> <a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%2013"><st c="1505">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%2013</st></a><st c="1592">.</st></p>
			<p><st c="1593">Notice that some examples in this chapter require running on a modern device, such as an iPhone 15 Pro/Max, iPad with M1 and above, or Apple </st><st c="1735">Silicon Mac.</st></p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor406"/><st c="1747">Understanding the App Intents concept</st></h1>
			<p><st c="1785">We first encountered App Intents</st><a id="_idIndexMarker811"/><st c="1818"> in </st><a href="B21795_01.xhtml#_idTextAnchor014"><em class="italic"><st c="1822">Chapter 1</st></em></a><st c="1831"> and then in </st><a href="B21795_05.xhtml#_idTextAnchor186"><em class="italic"><st c="1844">Chapter 5</st></em></a><st c="1853">, when we discussed WidgetKit. </st><st c="1884">But do we really understand the concept of App Intents? </st><st c="1940">Let’s get a short background about Apple’s efforts to integrate AI deeply inside the system across many apps, including </st><st c="2060">third-party apps.</st></p>
			<p><st c="2077">To implement this integration, we need to create an API for our app that exposes the app’s core content and main actions. </st><st c="2200">For example, a to-do app can create an API that lets Siri or other system components create a new task, complete an existing task, or pull the list of tasks stored in core data. </st><st c="2378">A delivery app can have an API that returns an answer to whether the delivery services are now open or at what time the </st><st c="2498">delivery arrives.</st></p>
			<p><st c="2515">This API, called App Intents, is our way of exposing our app’s main use cases and content to the world. </st><st c="2620">It’s one of the tools we use to integrate our app with Apple Intelligence </st><st c="2694">as well.</st></p>
			<p><st c="2702">If this sounds complex, you’ll be surprised how simple it is to create an app intent. </st><st c="2789">Let’s see how </st><st c="2803">it works.</st></p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor407"/><st c="2812">Creating a simple app intent</st></h1>
			<p><st c="2841">To demonstrate how to create</st><a id="_idIndexMarker812"/><st c="2870"> an app intent, let’s imagine we have an amazing to-do list. </st><st c="2931">Not just amazing, even mighty! </st><st c="2962">So, we’ll call </st><st c="2977">it </st><code><st c="2980">MightyTasksList</st></code><st c="2995">.</st></p>
			<p><st c="2996">Our </st><code><st c="3001">MightyTasksList</st></code><st c="3016"> app is so great that our users demand that they use it with Siri while they are driving. </st><st c="3106">So, we decided to create an </st><st c="3134">app intent.</st></p>
			<p><st c="3145">To do that, we’ll open a new file and write the </st><st c="3194">following code:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="3209">import AppIntents</st></strong><st c="3227">
struct GetTasksIntent: AppIntent {
    static var title: LocalizedStringResource { "Get the number of opened tasks" }
    @MainActor
    func perform() async throws -&gt; some ProvidesDialog {
        let tasks = TaskManager().tasks
        </st><strong class="bold"><st c="3438">return .result( dialog: "Number of the opened tasks is \(tasks.count)")</st></strong><st c="3509">
    }
}</st></pre>			<p><st c="3513">This is it? </st><st c="3526">Yes! </st><st c="3531">Writing a simple</st><a id="_idIndexMarker813"/><st c="3547"> app intent is extremely easy. </st><st c="3578">Let’s narrow down what we </st><st c="3604">did here:</st></p>
			<ul>
				<li><st c="3613">We imported the </st><code><st c="3630">AppIntents</st></code><st c="3640"> framework. </st><st c="3652">In this case, we need this framework to have the </st><code><st c="3701">AppIntent</st></code><st c="3710"> protocol.</st></li>
				<li><st c="3720">We created a </st><code><st c="3734">GetTasksIntent</st></code><st c="3748"> structure that conformed to the </st><code><st c="3781">AppIntent</st></code><st c="3790"> protocol. </st><st c="3801">This structure defines our </st><st c="3828">intent functionality.</st></li>
				<li><st c="3849">As part of the </st><code><st c="3865">AppIntent</st></code><st c="3874"> protocol, we must implement two things. </st><st c="3915">The first one is the intent’s </st><code><st c="3945">title</st></code><st c="3950">, which appears in the intent gallery in the Shortcuts app (we’ll get there shortly in the </st><em class="italic"><st c="4041">Running the intent in the Shortcuts app</st></em><st c="4080"> section). </st><st c="4091">The second thing we need to implement is the </st><code><st c="4136">perform()</st></code><st c="4145"> function, which is the actual code that will be executed when the </st><st c="4212">intent runs.</st></li>
			</ul>
			<p><st c="4224">The </st><code><st c="4229">perform()</st></code><st c="4238"> function always returns an </st><code><st c="4266">IntentResult</st></code><st c="4278"> protocol-based type—in this case, we return a </st><code><st c="4325">ProvidesDialog</st></code><st c="4339"> instance that conforms to the </st><code><st c="4370">IntentResult</st></code><st c="4382"> protocol and displays a message to the user. </st><st c="4428">However, there are additional </st><a id="_idIndexMarker814"/><st c="4458">types, and we’ll discuss them in the </st><st c="4495">following sections.</st></p>
			<p><st c="4514">Next, let’s run our intent using the </st><st c="4552">Shortcuts app.</st></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor408"/><st c="4566">Running the intent with the Shortcuts app</st></h2>
			<p><st c="4608">The </st><strong class="bold"><st c="4613">Shortcuts app</st></strong><st c="4626"> is a powerful automation tool</st><a id="_idIndexMarker815"/><st c="4656"> that allows users to create</st><a id="_idIndexMarker816"/><st c="4684"> shortcuts for routines and actions in their system. </st><st c="4737">Users can also use the Shortcuts app to create scripting, automation, conditional statements, and </st><st c="4835">complex logic.</st></p>
			<p><st c="4849">Apple acquired the Shortcuts app back in 2017, which was initially developed by a start-up </st><st c="4941">called Workflows.</st></p>
			<p><st c="4958">When we build and run our app, iOS scans for structures that conform to the </st><code><st c="5035">AppIntent</st></code><st c="5044"> protocol and add them to the </st><strong class="bold"><st c="5074">Shortcuts</st></strong><st c="5083"> gallery in the Shortcuts app (</st><em class="italic"><st c="5114">Figure 13</st></em><em class="italic"><st c="5124">.1</st></em><st c="5126">):</st></p>
			<div><div><img src="img/B21795_figure_13.01.jpg" alt="Figure 13.1: Our intent is shown in the Shortcuts app"/><st c="5129"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5208">Figure 13.1: Our intent is shown in the Shortcuts app</st></p>
			<p><st c="5261">In </st><em class="italic"><st c="5265">Figure 13</st></em><em class="italic"><st c="5274">.1</st></em><st c="5276">, we can see the intent of the </st><strong class="bold"><st c="5307">Get number of the opened tasks</st></strong><st c="5337"> shortcut in the Shortcuts app when searching for action for our app. </st><st c="5407">Then, we can add the action as a new shortcut. </st><st c="5454">Let’s see what happens when we run our intent (</st><em class="italic"><st c="5501">Figure 13</st></em><em class="italic"><st c="5511">.2</st></em><st c="5513">):</st></p>
			<div><div><img src="img/B21795_figure_13.02.jpg" alt="Figure 13.2: Running the Get number of opened tasks shortcut"/><st c="5516"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5561">Figure 13.2: Running the Get number of opened tasks shortcut</st></p>
			<p><em class="italic"><st c="5621">Figure 13</st></em><em class="italic"><st c="5631">.2</st></em><st c="5633"> shows what happens when we run our app intent. </st><st c="5681">We can see the message we defined as part of the </st><code><st c="5730">perform()</st></code> <st c="5739">function results.</st></p>
			<p><st c="5757">Way to go! </st><st c="5769">We created</st><a id="_idIndexMarker817"/><st c="5779"> our first </st><st c="5790">app</st><a id="_idIndexMarker818"/><st c="5793"> intent!</st></p>
			<p><st c="5801">Now, let’s try to ease our users and create the shortcut as part of </st><st c="5870">the app.</st></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor409"/><st c="5878">Creating an app shortcut</st></h2>
			<p><st c="5903">Instead of letting the user create</st><a id="_idIndexMarker819"/><st c="5938"> a shortcut based on the action (intent) we provide, we can create a shortcut for them </st><st c="6025">to use.</st></p>
			<p><st c="6032">To do that, we need to create a structure that conforms to the </st><code><st c="6096">AppShortcutsProvider</st></code><st c="6116"> protocol to create a </st><st c="6138">pre-configured shortcut:</st></p>
			<pre class="source-code"><st c="6162">
import AppIntents
</st><strong class="bold"><st c="6181">struct AppShortcuts: AppShortcutsProvider {</st></strong><st c="6224">
    @AppShortcutsBuilder
    static var appShortcuts: [AppShortcut] {
        </st><strong class="bold"><st c="6287">AppShortcut</st></strong><st c="6298">(intent: GetTasksIntent(),
          phrases: ["What is left in \(.applicationName)?", "How many tasks left in \(.applicationName)"], shortTitle: "My tasks", systemImageName: "circle.badge.checkmark")
    }
}</st></pre>			<p><st c="6493">In this code, we have a struct called </st><code><st c="6532">AppShortcuts</st></code><st c="6544">. This struct has one variable to implement—</st><code><st c="6588">appShortcuts</st></code><st c="6601">, which contains a list of the </st><st c="6632">app shortcuts.</st></p>
			<p><st c="6646">In this case, we create a new </st><code><st c="6677">AppShortcut</st></code><st c="6688"> instance that contains </st><st c="6712">the following:</st></p>
			<ul>
				<li><st c="6726">The intent that will be executed. </st><st c="6761">Here, we put the intent we created in the preceding </st><st c="6813">section (</st><code><st c="6822">GetTasksIntent</st></code><st c="6837">).</st></li>
				<li><st c="6840">The exact phrases the user has to say to Siri. </st><st c="6888">In our case, we added two phrases. </st><st c="6923">Notice that the phrases must include the </st><st c="6964">application name.</st></li>
				<li><st c="6981">A title and a system image for </st><st c="7013">the shortcut.</st></li>
			</ul>
			<p><st c="7026">Once we run our app, the user doesn’t need to create a shortcut using the Shortcuts app—the shortcut is ready</st><a id="_idIndexMarker820"/><st c="7136"> for the user to use </st><st c="7157">with Siri.</st></p>
			<p><st c="7167">Now that we have created our first intent and shortcut, let’s dive in for more complex </st><st c="7255">use cases.</st></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor410"/><st c="7265">Adding a parameter to our app intent</st></h2>
			<p><st c="7302">In the </st><em class="italic"><st c="7310">Creating a simple app intent</st></em><st c="7338"> section, we</st><a id="_idIndexMarker821"/><st c="7350"> created a </st><code><st c="7361">GetTasksIntent</st></code><st c="7375"> struct that went to the persistent store and returned the user’s number of open tasks. </st><st c="7463">Now, let’s see how we can use the </st><code><st c="7497">AppIntents</st></code><st c="7507"> framework to create an action that inserts a new task into </st><st c="7567">the system.</st></p>
			<p><st c="7578">We’ll open a new file and add the </st><st c="7613">following code:</st></p>
			<pre class="source-code"><st c="7628">
struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource { "Create new task" }
    </st><strong class="bold"><st c="7727">@Parameter(title: "Title")</st></strong><strong class="bold"><st c="7753">var title: String</st></strong><st c="7771">
    @MainActor
    func perform() async throws -&gt; some </st><strong class="bold"><st c="7819">ReturnsValue&lt;String&gt;</st></strong><st c="7839"> {
        TaskManager().addTask(Task(title: title))
        TaskManager().saveTasks()
        </st><strong class="bold"><st c="7910">return .result(value: title)</st></strong><st c="7938">
    }
}</st></pre>			<p><code><st c="7942">AddTaskIntent</st></code><st c="7956"> is a little bit more complex but not </st><st c="7994">too complex.</st></p>
			<p><st c="8006">To start, we create a new </st><code><st c="8033">AddTaskIntent</st></code><st c="8046"> that conforms to the </st><code><st c="8068">AppIntent</st></code><st c="8077"> protocol, similar to </st><code><st c="8099">GetTasksIntent</st></code><st c="8113">. We also provide a readable title for the Shortcuts app. </st><st c="8171">But then we see a new variable—a title marked with a </st><code><st c="8224">@</st></code><code><st c="8225">Parameter</st></code><st c="8234"> attribute.</st></p>
			<p><st c="8245">We said that app intents are actually our application API. </st><st c="8305">Some APIs require input, so when adding a new task, the title is our Intent input. </st><st c="8388">We can provide this input using Siri, a dialog, or even another intent. </st><st c="8460">When we run </st><code><st c="8472">AddTaskIntent</st></code><st c="8485">, the user must provide a title for </st><st c="8521">the task.</st></p>
			<p><st c="8530">When we reach the </st><code><st c="8549">perform()</st></code><st c="8558"> function, we can see how we use the </st><code><st c="8595">title</st></code><st c="8600"> parameter to insert a new task into the persistent store. </st><st c="8659">We can also see a change compared to the </st><code><st c="8700">GetTasksIntent</st></code><st c="8714"> example in how the function returns </st><st c="8751">a value.</st></p>
			<p><st c="8759">In </st><code><st c="8763">GetTasksIntent</st></code><st c="8777">, we used</st><a id="_idIndexMarker822"/><st c="8786"> the </st><code><st c="8791">ProvidesDialog</st></code><st c="8805"> protocol. </st><st c="8816">Now, we use </st><code><st c="8828">ReturnsValue&lt;String&gt;</st></code><st c="8848">, which returns a value to our shortcut. </st><st c="8889">We can use the returned value as input for other actions. </st><st c="8947">For example, in this case, we can use the task title to create a reminder in the Reminders app with the same title or even send a message with this title to someone else. </st><st c="9118">This feature makes App Intents and the Shortcuts app extremely useful for </st><st c="9192">power users.</st></p>
			<p><st c="9204">Let’s see how it looks in the </st><st c="9235">Shortcuts app:</st></p>
			<div><div><img src="img/B21795_figure_13.03.jpg" alt="Figure 13.3: Shortcuts with two actions"/><st c="9249"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9355">Figure 13.3: Shortcuts with two actions</st></p>
			<p><st c="9394">In </st><em class="italic"><st c="9398">Figure 13</st></em><em class="italic"><st c="9407">.3</st></em><st c="9409">, we can see our shortcut with </st><st c="9440">two actions:</st></p>
			<ol>
				<li><st c="9452">The first is </st><code><st c="9466">AddTaskIntent</st></code><st c="9479"> from </st><st c="9485">our app.</st></li>
				<li><st c="9493">The second is that the result of our intent is the task title and the input of the </st><em class="italic"><st c="9577">send message</st></em><st c="9589"> action from the </st><st c="9606">messages app.</st></li>
			</ol>
			<p><st c="9619">We can see that it is possible</st><a id="_idIndexMarker823"/><st c="9650"> to chain actions together and create </st><st c="9688">powerful streams.</st></p>
			<p><st c="9705">Let’s see how it looks when we run our shortcut (</st><em class="italic"><st c="9755">Figure 13</st></em><em class="italic"><st c="9765">.4</st></em><st c="9767">):</st></p>
			<div><div><img src="img/B21795_figure_13.04.jpg" alt="Figure 13.4: Running AddTaskIntent"/><st c="9770"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9793">Figure 13.4: Running AddTaskIntent</st></p>
			<p><em class="italic"><st c="9827">Figure 13</st></em><em class="italic"><st c="9837">.4</st></em><st c="9839"> shows that the system asks for the task title when we run our shortcut by providing a standard input field. </st><st c="9948">Besides the Siri integration, this is part of what we get for free—a standard user interface</st><a id="_idIndexMarker824"/><st c="10040"> that handles all of that </st><st c="10066">for us.</st></p>
			<p><st c="10073">However, we can also create our own user interface for the shortcut! </st><st c="10143">Let’s see how to </st><st c="10160">do that.</st></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor411"/><st c="10168">Returning a custom view</st></h2>
			<p><st c="10192">We have added two important</st><a id="_idIndexMarker825"/><st c="10220"> intents in the previous sections. </st><st c="10255">The first receives a string containing the number of opened tasks, and the second is an app intent that creates a new task in the </st><st c="10385">persistent store.</st></p>
			<p><st c="10402">Let’s discuss another use case—getting the list of opened tasks. </st><st c="10468">In this case, we want to present the user with a custom view since Shortcuts and Siri don’t know how to deal with a list of </st><st c="10592">entities natively.</st></p>
			<p><st c="10610">So, let’s create a </st><st c="10630">custom view:</st></p>
			<pre class="source-code"><st c="10642">
struct MiniTasksList: View {
    let tasks: [Task]
    var body: some View {
        VStack {
            ForEach(tasks) { task in
                TaskView(task: task)
            }
        }
    }
}</st></pre>			<p><st c="10774">Our code example contains a struct named </st><code><st c="10816">MiniTasksList</st></code><st c="10829"> with a VStack that displays an array </st><st c="10867">of </st><code><st c="10870">TaskView</st></code><st c="10878">.</st></p>
			<p><st c="10879">There are two weird </st><st c="10900">things here:</st></p>
			<ol>
				<li><st c="10912">First, why do we need to create a dedicated list view? </st><st c="10968">Can’t we reuse the view we already have in </st><st c="11011">our app?</st></li>
				<li><st c="11019">Second, why do we use a VStack and not a </st><st c="11061">List view?</st></li>
			</ol>
			<p><st c="11071">These arguments</st><a id="_idIndexMarker826"/><st c="11087"> are usually valid. </st><st c="11107">We should aim to reuse our code as much as possible and use the right view for the right behavior. </st><st c="11206">However, one limitation is that we cannot use List or Scroll views as part of our custom view. </st><st c="11301">We also can’t display animations or allow user interaction. </st><st c="11361">If we want to achieve more functionality, we should use the app itself or create additional app intents to fulfill </st><st c="11476">our needs.</st></p>
			<p><st c="11486">Now that we have a custom view, let’s create an app intent that </st><st c="11551">uses it:</st></p>
			<pre class="source-code"><st c="11559">
struct </st><strong class="bold"><st c="11567">GetTasksListIntent</st></strong><st c="11585">: AppIntent {
    static var title: LocalizedStringResource { "Get my Tasks's List" }
    @MainActor
    func perform() async throws -&gt; some </st><strong class="bold"><st c="11715">ShowsSnippetView</st></strong><st c="11731"> {
        let tasks = TaskManager().tasks
</st><strong class="bold"><st c="11766">        return .result(view: MiniTasksList(tasks: tasks))</st></strong><st c="11815">
    }
}</st></pre>			<p><st c="11819">The </st><code><st c="11824">GetTasksListIntent</st></code><st c="11842"> structure is similar to the previous intents we created in the previous sections. </st><st c="11925">It also has a </st><code><st c="11939">title</st></code><st c="11944"> property and a </st><code><st c="11960">perform()</st></code><st c="11969"> function.</st></p>
			<p><st c="11979">There are two important</st><a id="_idIndexMarker827"/> <st c="12003">changes here:</st></p>
			<ul>
				<li><st c="12017">The return type of the </st><code><st c="12041">perform()</st></code><st c="12050"> function is now </st><code><st c="12067">ShowsSnippetView</st></code><st c="12083">. We use </st><code><st c="12092">ShowsSnippetView</st></code><st c="12108"> if we want to present a custom view as a result of </st><st c="12160">our function.</st></li>
				<li><st c="12173">We returned a different intent result with the </st><code><st c="12221">MiniTasksList</st></code><st c="12234"> view </st><st c="12240">we created.</st></li>
			</ul>
			<p><st c="12251">Now, let’s run our intent using the Shortcuts app and see what happens (</st><em class="italic"><st c="12324">Figure 13</st></em><em class="italic"><st c="12334">.5</st></em><st c="12336">):</st></p>
			<div><div><img src="img/B21795_figure_13.05.jpg" alt="Figure 13.5: The list of tasks as part of the intent response"/><st c="12339"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12487">Figure 13.5: The list of tasks as part of the intent response</st></p>
			<p><em class="italic"><st c="12548">Figure 13</st></em><em class="italic"><st c="12558">.5</st></em><st c="12560"> shows </st><code><st c="12567">MiniTasksList</st></code><st c="12580"> as our intent response. </st><st c="12605">Looking at how the list is displayed, we can understand why Apple limits how we can customize this view. </st><st c="12710">The goal is for our view to be as simple as possible and aligned with the rest of </st><st c="12792">the intents.</st></p>
			<p><st c="12804">Returning a view</st><a id="_idIndexMarker828"/><st c="12821"> is great. </st><st c="12832">But what if we want to return a custom view and a value that can be used for other purposes? </st><st c="12925">Is it possible? </st><st c="12941">Let’s find out if and how to </st><st c="12970">do that.</st></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor412"/><st c="12978">Having multiple result types</st></h2>
			<p><st c="13007">Imagine that, besides </st><a id="_idIndexMarker829"/><st c="13030">getting the tasks list, the user wants to add another step to its shortcut. </st><st c="13106">If the number of tasks is bigger than, let’s say, five, they want to open the calendar to re-arrange </st><st c="13207">the day.</st></p>
			<p><st c="13215">So, we would like to show the list of tasks and also return </st><st c="13276">their quantity.</st></p>
			<p><st c="13291">We can do that by returning </st><st c="13320">multiple types:</st></p>
			<pre class="source-code"><st c="13335">
struct GetTasksListIntent: AppIntent {
    static var title: LocalizedStringResource { "Get my Tasks's List" }
    @MainActor
    func perform() async throws -&gt;
      some </st><strong class="bold"><st c="13490">ShowsSnippetView &amp; ReturnsValue&lt;Int&gt;</st></strong><st c="13526"> {
        let tasks = TaskManager().tasks
        return </st><strong class="bold"><st c="13568">.result(value: tasks.count,</st></strong>
<strong class="bold"><st c="13595">          view: MiniTasksList(tasks: tasks))</st></strong><st c="13630">
    }
}</st></pre>			<p><st c="13634">In our code example, </st><code><st c="13656">perform()</st></code><st c="13665"> returns two types of results – </st><code><st c="13697">ShowsSnippetView</st></code><st c="13713"> for displaying the tasks list and </st><code><st c="13748">ReturnsValue&lt;Int&gt;</st></code><st c="13765"> for the number of tasks to be used in </st><st c="13804">other intents.</st></p>
			<p><st c="13818">We also changed </st><code><st c="13835">IntentResult</st></code><st c="13847"> at the function’s </st><st c="13866">return statement:</st></p>
			<pre class="source-code"><st c="13883">
return .result(value: tasks.count,
      view: MiniTasksList(tasks: tasks))</st></pre>			<p><st c="13953">Notice that the value we return</st><a id="_idIndexMarker830"/><st c="13985"> needs to be the same as the </st><code><st c="14014">ReturnsValue</st></code><st c="14026"> instance we declare in the </st><st c="14054">function signature.</st></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor413"/><st c="14073">Adding confirmation and conditions</st></h2>
			<p><st c="14108">Having the app perform</st><a id="_idIndexMarker831"/><st c="14131"> actions can lead to more complex use cases. </st><st c="14176">For example, there are cases where we need to confirm a specific action with the user, such as deleting or ordering something. </st><st c="14303">In other cases, we might want to inform the user that we cannot perform the action or even request </st><st c="14402">more information.</st></p>
			<p><st c="14419">The </st><code><st c="14424">AppIntents</st></code><st c="14434"> protocol has the capability to create a dialog with our users. </st><st c="14498">This dialog can be used with Siri to make the process feel </st><st c="14557">more conversational.</st></p>
			<p><st c="14577">Let’s go back to our to-do app and create an app intent that allows the user to delete all of </st><st c="14672">its tasks:</st></p>
			<pre class="source-code"><st c="14682">
struct DeleteAllTasksIntent: AppIntent {
    static var title: LocalizedStringResource { "Delete all tasks" }
</st><strong class="bold"><st c="14789">    func perform() async throws -&gt; some ProvidesDialog {</st></strong><st c="14841">
        let taskManager = TaskManager()
        if taskManager.tasks.count == 0 {
            return .result(dialog: .init("Sorry, there are no tasks to delete"))
        }
        </st><strong class="bold"><st c="14979">try await requestConfirmation(actionName: .go,</st></strong>
<strong class="bold"><st c="15025">           dialog: IntentDialog("Are you sure you want to delete all your tasks?"))</st></strong><st c="15098">
        TaskManager().deleteAllTasks()
        return .result(dialog: .init("All of your tasks have been deleted."))
    }
}</st></pre>			<p><st c="15203">This intent is a bit more complex</st><a id="_idIndexMarker832"/><st c="15237"> and smarter than our previous examples. </st><st c="15278">At the beginning of the </st><code><st c="15302">perform()</st></code><st c="15311"> function, we check to see if there are any tasks in the persistent store to delete. </st><st c="15396">If there are no tasks to delete, we notify the user by returning a simple </st><st c="15470">text dialog.</st></p>
			<p><st c="15482">Next, since it is a destructive action, we want to confirm it with our user. </st><st c="15560">So, we use the </st><code><st c="15575">requestConfirmation()</st></code><st c="15596"> function. </st><st c="15607">This function presents a dialog with a given text and a confirmation button (</st><em class="italic"><st c="15684">Figure 13</st></em><em class="italic"><st c="15694">.6</st></em><st c="15696">):</st></p>
			<div><div><img src="img/B21795_figure_13.06.jpg" alt="Figure 13.6: A confirmation dialog"/><st c="15699"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15764">Figure 13.6: A confirmation dialog</st></p>
			<p><em class="italic"><st c="15798">Figure 13</st></em><em class="italic"><st c="15808">.6</st></em><st c="15810"> shows a confirmation dialog that was derived from the </st><code><st c="15865">requestConfirmation()</st></code><st c="15886"> function. </st><st c="15897">Notice that we can choose from a set of confirmation button titles. </st><st c="15965">In our </st><a id="_idIndexMarker833"/><st c="15972">case, we selected the </st><strong class="bold"><st c="15994">Go</st></strong><st c="15996"> title.</st></p>
			<p><st c="16003">The next steps are straightforward: We perform the deletion action and notify our user that it has </st><st c="16103">been executed.</st></p>
			<p><st c="16117">Up until now, our app intents returned primitive types such as strings and int. </st><st c="16198">But what about working with our app types? </st><st c="16241">Is it possible to transfer them as part of the shortcut actions chain? </st><st c="16312">This is what </st><code><st c="16325">AppEntity</st></code> <st c="16334">is for.</st></p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor414"/><st c="16342">Formalizing our content using app entities</st></h1>
			<p><st c="16385">In our app intents, when we created</st><a id="_idIndexMarker834"/><st c="16421"> a task, we returned a string value</st><a id="_idIndexMarker835"/><st c="16456"> of the task’s title. </st><st c="16478">However, a task is more than just a title – it contains a description, status, ID, and many more properties. </st><st c="16587">In other</st><a id="_idIndexMarker836"/><st c="16595"> words, a task is not a string or a </st><code><st c="16705">Task</st></code><st c="16709">.</st></p>
			<p><st c="16710">The problem with App Intents is that no other app or the system knows what a </st><code><st c="16788">Task</st></code><st c="16792"> structure is since it’s our app’s internal type. </st><st c="16842">We need to expose the type to the system intent world to make </st><code><st c="16904">Task</st></code><st c="16908"> a known type by </st><st c="16925">the system.</st></p>
			<p><st c="16936">Let’s connect that to a use case: creating and opening a task in the app. </st><st c="17011">To make it modular, we want to create two intents: creating a task and opening a task. </st><st c="17098">When we have the two intents, we can chain them in </st><st c="17149">a shortcut.</st></p>
			<p><st c="17160">Let’s start by letting the system know what </st><code><st c="17205">Task</st></code><st c="17209"> is.</st></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor415"/><st c="17213">Conforming to AppEntity</st></h2>
			<p><st c="17237">Conforming to the </st><code><st c="17256">AppEntity</st></code><st c="17265"> protocol</st><a id="_idIndexMarker837"/><st c="17274"> makes app entities available to Siri and Shortcuts. </st><st c="17327">It means that when our app intent returns one of our entities, we can pass it as input to the next intent in </st><st c="17436">the chain.</st></p>
			<p><st c="17446">Let’s see how we can take our </st><code><st c="17477">Task</st></code><st c="17481"> structure and make it </st><a id="_idTextAnchor416"/><a id="_idTextAnchor417"/><st c="17504">conform </st><st c="17512">to </st><code><st c="17515">AppEntity</st></code><st c="17524">:</st></p>
			<pre class="source-code"><st c="17526">
struct Task: Identifiable, Codable, </st><strong class="bold"><st c="17563">AppEntity</st></strong><st c="17572"> {
    static var </st><strong class="bold"><st c="17586">typeDisplayRepresentation</st></strong><st c="17611">: TypeDisplayRepresentation { .init(stringLiteral: "Task") }
    init(id: UUID = UUID(), title: String,
      description: String = "") {
        self.id = id
        self.title = title
        self.description = description
    }
    var </st><strong class="bold"><st c="17809">displayRepresentation</st></strong><st c="17830">: DisplayRepresentation { DisplayRepresentation(stringLiteral: "title: \(title)") }
    let id: UUID
    @</st><strong class="bold"><st c="17929">Property</st></strong><st c="17938">(title: "Title")
    var title: String
    @</st><strong class="bold"><st c="17975">Property</st></strong><st c="17984">(title:"Description")
    var description: String
    static var defaultQuery = </st><strong class="bold"><st c="18057">TaskQuery</st></strong><st c="18066">()
}</st></pre>			<p><st c="18071">Let’s break down</st><a id="_idIndexMarker838"/><st c="18088"> the </st><code><st c="18093">AppEntity</st></code> <st c="18102">protocol implementation:</st></p>
			<ul>
				<li><code><st c="18127">typeDisplayRepresentation</st></code><st c="18153">: Our entity needs to have a name in the system so we can display it in the Shortcuts app. </st><st c="18245">In this case, we </st><st c="18262">return </st><code><st c="18269">Task</st></code><st c="18273">.</st></li>
				<li><code><st c="18274">displayRepresentation</st></code><st c="18296">: While </st><code><st c="18305">typeDisplayRepresentation</st></code><st c="18330"> shows the entity type name, the </st><code><st c="18363">displayRepresentation</st></code><st c="18384"> property returns the entity value representation. </st><st c="18435">In this case, this is the title value (e.g., </st><em class="italic"><st c="18480">Call </st></em><em class="italic"><st c="18485">my mom</st></em><st c="18491">).</st></li>
				<li><code><st c="18576">@Property</st></code><st c="18585"> attribute to some</st><a id="_idIndexMarker839"/><st c="18603"> of the entity’s properties, we define the entity structure for use in the </st><st c="18678">Shortcuts app.</st></li>
				<li><code><st c="18692">defaultQuery</st></code><st c="18705">: Declaring our app’s entities is not enough; we also need to provide the system with a way to retrieve them. </st><st c="18816">Our next step will be to create the query that the system will use to fetch </st><st c="18892">our entities.</st></li>
			</ul>
			<p><st c="18905">Now that our </st><code><st c="18919">Task</st></code><st c="18923"> struct is known by the system, let’s finish the implementation by </st><st c="18990">creating </st><code><st c="18999">TaskQuery</st></code><st c="19008">:</st></p>
			<pre class="source-code"><st c="19010">
struct TaskQuery: </st><strong class="bold"><st c="19029">EntityQuery</st></strong><st c="19040"> {
    func entities(for identifiers: [UUID]) async throws -&gt; [Task] {
        return TaskManager().tasks.filter {identifiers.contains($0.id)}
    }
    func suggestedEntities() async throws -&gt; [Task] {
        return TaskManager().tasks
    }
}</st></pre>			<p><st c="19253">In this code example, we can see that the </st><code><st c="19296">TaskQuery</st></code><st c="19305"> structure conforms to the </st><code><st c="19332">EntityQuery</st></code><st c="19343"> protocol.</st></p>
			<p><st c="19353">The system uses the first function, </st><code><st c="19390">entities()</st></code><st c="19400">, to retrieve the entities by identifiers. </st><st c="19443">At this point, we reach the app services (in this example, </st><code><st c="19502">TaskManager</st></code><st c="19513">) to fetch, filter, and return an array of entities. </st><st c="19567">That’s why this function </st><st c="19592">is required.</st></p>
			<p><st c="19604">The second function (</st><code><st c="19626">suggestedEntities()</st></code><st c="19646">) is not required, but it can help the system present the user with a list of entities while we are fetching the list </st><st c="19765">of entities.</st></p>
			<p><st c="19777">We know how to define </st><code><st c="19800">AppEntity</st></code><st c="19809"> and its query at this point, but we need to connect it to an app intent</st><a id="_idIndexMarker840"/><st c="19881"> to understand how they are </st><st c="19909">being used.</st></p>
			<p><st c="19920">Let’s do that by creating an </st><code><st c="19950">Open a </st></code><code><st c="19957">task</st></code><st c="19961"> intent.</st></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor418"/><st c="19969">Creating an Open a task intent</st></h2>
			<p><st c="20000">Creating an </st><code><st c="20013">Open a task</st></code><st c="20024"> intent is not that different</st><a id="_idIndexMarker841"/><st c="20053"> from what we saw in the previous examples. </st><st c="20097">This time, we’ll integrate the new app intent with the </st><code><st c="20152">AppEntity</st></code><st c="20161"> struct we’ve </st><st c="20175">just created:</st></p>
			<pre class="source-code"><st c="20188">
struct OpenTaskIntent: AppIntent {
    static var title: LocalizedStringResource { "Open a task" }
    </st><strong class="bold"><st c="20284">@Parameter(title: "Task")</st></strong>
<strong class="bold"><st c="20309">    var task: Task?</st></strong>
<strong class="bold"><st c="20325">    static let openAppWhenRun: Bool = true</st></strong><st c="20364">
    @MainActor
    func perform() async throws -&gt; some ProvidesDialog{
        let taskToOpen: Task
        if let task {
            taskToOpen = task
        } else {
            taskToOpen = </st><strong class="bold"><st c="20503">try await $task.requestDisambiguation(</st></strong>
<strong class="bold"><st c="20541">                among: TaskManager().tasks,</st></strong>
<strong class="bold"><st c="20569">                dialog: "What task would like to open?")</st></strong>
<strong class="bold"><st c="20610">        }</st></strong><st c="20612">
        Navigator.shared.path.append(taskToOpen)
        return .result(dialog: "Opening your task")
    }
}</st></pre>			<p><st c="20701">Our </st><code><st c="20706">Open a task</st></code><st c="20717"> intent is structured</st><a id="_idIndexMarker842"/><st c="20738"> like our previous intent examples. </st><st c="20774">Still, there are additional changes we need </st><st c="20818">to discuss:</st></p>
			<ul>
				<li><st c="20829">We added </st><code><st c="20839">@Parameter</st></code><st c="20849"> to </st><code><st c="20853">Task</st></code><st c="20857">. Using </st><code><st c="20865">@Parameter</st></code><st c="20875"> is not new to us—we discussed it in the </st><em class="italic"><st c="20916">Adding a parameter to our app intent </st></em><st c="20953">section. </st><st c="20962">However, this time, we do that with the </st><code><st c="21002">Task</st></code><st c="21006"> structure itself. </st><st c="21025">We can do that because </st><code><st c="21048">Task</st></code><st c="21052"> now conforms </st><st c="21066">to </st><code><st c="21069">AppEntity</st></code><st c="21078">.</st></li>
				<li><st c="21079">We set </st><code><st c="21087">openAppWhenRun</st></code><st c="21101"> property to </st><code><st c="21114">true</st></code><st c="21118"> so we can open the app and display the </st><st c="21158">task details.</st></li>
				<li><st c="21171">If the app intent doesn’t receive a task parameter, we can ask the user to select a task using the </st><code><st c="21271">requestDisambiguation</st></code><st c="21292"> function. </st><st c="21303">This function presents a dialog to the user with a given list of tasks and asks them to select </st><st c="21398">a task.</st></li>
			</ul>
			<p><st c="21405">After we have a task, we call the app navigator to open the task details. </st><st c="21480">(To read more about how navigation works in SwiftUI, go to </st><a href="B21795_04.xhtml#_idTextAnchor148"><em class="italic"><st c="21539">Chapter 4</st></em></a><st c="21548">.)</st></p>
			<p><st c="21550">Now, let’s see what happens when we run this intent (</st><em class="italic"><st c="21604">Figure 13</st></em><em class="italic"><st c="21614">.7</st></em><st c="21616">):</st></p>
			<div><div><img src="img/B21795_figure_13.07.jpg" alt="Figure 13.7: The Open a task intent"/><st c="21619"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21993">Figure 13.7: The Open a task intent</st></p>
			<p><em class="italic"><st c="22028">Figure 13</st></em><em class="italic"><st c="22038">.7</st></em><st c="22040"> shows how the </st><code><st c="22055">Open a task</st></code><st c="22066"> intent looks in the two stages where the task parameter </st><st c="22123">is nil.</st></p>
			<p><st c="22130">First, it opens the app (that’s because we set the </st><code><st c="22182">openAppWhenRun</st></code><st c="22196"> variable </st><st c="22206">to </st><code><st c="22209">true</st></code><st c="22213">).</st></p>
			<p><st c="22216">Then, it displays a native dialog where the user can pick a task. </st><st c="22283">Notice that the task display name (</st><code><st c="22318">title:&lt;title of task&gt;</st></code><st c="22340">) is something we defined in the </st><code><st c="22374">displayRepresentation</st></code><st c="22395"> variable when we conformed to </st><code><st c="22426">AppEntity</st></code><st c="22435"> (in the </st><em class="italic"><st c="22444">Conforming to </st></em><em class="italic"><st c="22458">AppEntity</st></em><st c="22467"> section).</st></p>
			<p><st c="22477">Later, we navigate to our task details screen and notify the user by returning a dialog with a </st><st c="22573">corresponding message.</st></p>
			<p><st c="22595">Letting the user pick a task</st><a id="_idIndexMarker843"/><st c="22624"> to display is a nice use case, but that’s not where the real power of </st><st c="22695">intents is.</st></p>
			<p><st c="22706">Let’s try and integrate the </st><code><st c="22735">Open a task</st></code><st c="22746"> intent into another intent by chaining </st><st c="22786">them together.</st></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor419"/><st c="22800">Chaining app intents</st></h2>
			<p><st c="22821">Let’s go back to </st><code><st c="22839">AddTaskIntent</st></code><st c="22852">, which we created</st><a id="_idIndexMarker844"/><st c="22870"> in the </st><em class="italic"><st c="22878">Adding a parameter to our app intent</st></em><st c="22914"> section, and examine its </st><code><st c="22940">perform()</st></code><st c="22949"> function:</st></p>
			<pre class="source-code"><st c="22959">
func perform() async throws -&gt; some </st><strong class="bold"><st c="22996">ReturnsValue&lt;String&gt;</st></strong><st c="23016"> {
        TaskManager().addTask(Task(title: title))
        TaskManager().saveTasks()
        </st><strong class="bold"><st c="23087">return .result(value: title)</st></strong><st c="23115">
    }</st></pre>			<p><st c="23117">The return type in the </st><code><st c="23140">perform()</st></code><st c="23149"> function is </st><code><st c="23162">ReturnsValue&lt;String&gt;</st></code><st c="23182">. Let’s modify this function to return a </st><code><st c="23223">Task</st></code><st c="23227"> instance:</st></p>
			<pre class="source-code"><st c="23237">
func perform() async throws -&gt; some </st><strong class="bold"><st c="23274">ReturnsValue&lt;Task&gt;</st></strong><st c="23292"> {
        let newTask = Task(title: title)
        TaskManager().addTask(newTask)
        TaskManager().saveTasks()
        return .result(value: </st><strong class="bold"><st c="23407">newTask</st></strong><st c="23414">)
    }</st></pre>			<p><st c="23418">In the new </st><code><st c="23430">perform()</st></code><st c="23439"> function, we changed</st><a id="_idIndexMarker845"/><st c="23460"> only two parts – the return type (now it’s </st><code><st c="23504">ReturnsValue&lt;Task&gt;</st></code><st c="23522">) and the return statement, which now returns our newly </st><st c="23579">created task.</st></p>
			<p><st c="23592">Let’s go back to the Shortcuts app and chain </st><code><st c="23638">AddTaskIntent</st></code><st c="23651"> and </st><code><st c="23656">OpenTaskIntent</st></code><st c="23670"> together (</st><em class="italic"><st c="23681">Figure 13</st></em><em class="italic"><st c="23691">.8</st></em><st c="23693">):</st></p>
			<div><div><img src="img/B21795_figure_13.08.jpg" alt="Figure 13.8: A shortcut with Create and Open a task intents"/><st c="23696"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23810">Figure 13.8: A shortcut with Create and Open a task intents</st></p>
			<p><st c="23869">Now we have a shortcut that creates a new task and opens it in the app, and we’ve done this with very </st><st c="23972">little code!</st></p>
			<p><st c="23984">But what about the properties</st><a id="_idIndexMarker846"/><st c="24014"> we defined as part of the </st><code><st c="24041">Task</st></code><st c="24045"> entity? </st><st c="24054">We haven’t used them yet! </st><st c="24080">Let’s see how to use them with </st><st c="24111">other intents.</st></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor420"/><st c="24125">Integrating our intent to other intents</st></h2>
			<p><st c="24165">We’ve seen how to chain</st><a id="_idIndexMarker847"/><st c="24189"> the added task with the </st><code><st c="24214">Open a task</st></code><st c="24225"> intents, but that was straightforward – we created both intents, so both were aware of the </st><code><st c="24317">Task</st></code><st c="24321"> entity. </st><st c="24330">But what do we do when we need to return the </st><code><st c="24375">Task</st></code><st c="24379"> entity to an intent from another app developer? </st><st c="24428">The first option is to select one of </st><st c="24465">the properties.</st></p>
			<h3><st c="24480">Selecting one of the properties</st></h3>
			<p><st c="24512">One of the good things</st><a id="_idIndexMarker848"/><st c="24535"> about </st><code><st c="24542">AppEntity</st></code><st c="24551"> is that it creates a structure that can be utilized across </st><st c="24611">our system:</st></p>
			<pre class="source-code"><st c="24622">
struct Task: Identifiable, Codable, </st><strong class="bold"><st c="24659">AppEntity</st></strong><st c="24668"> {
        </st><strong class="bold"><st c="24671">static</st></strong> <strong class="bold"><st c="24677">var</st></strong><st c="24681"> typeDisplayRepresentation: TypeDisplayRepresentation { .init(stringLiteral: "Task") }
    @</st><strong class="bold"><st c="24769">Property</st></strong><st c="24778">(title: "Title")
    var title: String
    @</st><strong class="bold"><st c="24815">Property</st></strong><st c="24824">(title:"Description")
    var description: String</st></pre>			<p><st c="24870">Our </st><code><st c="24875">Task</st></code><st c="24879"> structure contains</st><a id="_idIndexMarker849"/><st c="24898"> a display name (</st><code><st c="24915">Task</st></code><st c="24920">) and two properties – </st><code><st c="24944">Title</st></code><st c="24949"> and </st><code><st c="24954">Description</st></code><st c="24965">. We can use that to pass on one of these values to the next action in the </st><st c="25040">Shortcuts app.</st></p>
			<p><st c="25054">For example, let’s say we want to create a new task and send its title in a message. </st><st c="25140">Because we defined the </st><code><st c="25163">title</st></code><st c="25168"> variable as an </st><code><st c="25184">AppEntity</st></code><st c="25193"> property, it will show up in the Shortcuts app (</st><em class="italic"><st c="25242">Figure 13</st></em><em class="italic"><st c="25252">.9</st></em><st c="25254">):</st></p>
			<div><div><img src="img/B21795_figure_13.09.jpg" alt="Figure 13.9: Choosing the Title property in the Shortcuts app"/><st c="25257"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25429">Figure 13.9: Choosing the Title property in the Shortcuts app</st></p>
			<p><em class="italic"><st c="25490">Figure 13</st></em><em class="italic"><st c="25500">.9</st></em><st c="25502"> shows how we can select one of the </st><code><st c="25538">AppEntity</st></code><st c="25547"> properties to pass on to the </st><em class="italic"><st c="25577">send </st></em><em class="italic"><st c="25582">message</st></em><st c="25589"> intent.</st></p>
			<p><st c="25597">Passing on </st><code><st c="25609">Title</st></code><st c="25614"> is obvious—</st><code><st c="25626">Title</st></code><st c="25632"> is a string, and we can easily use it as an input for other actions. </st><st c="25702">But what if we used </st><code><st c="25722">Task</st></code><st c="25726"> as an input for the </st><em class="italic"><st c="25747">send message</st></em><st c="25759"> action? </st><st c="25768">We did that in the </st><em class="italic"><st c="25787">Chaining app intents</st></em><st c="25807"> section, but that was between two actions from the same app. </st><st c="25869">Can we share</st><a id="_idIndexMarker850"/><st c="25881"> an entity between two </st><st c="25904">different apps?</st></p>
			<p><st c="25919">That’s why we have the </st><strong class="bold"><st c="25943">Transferable</st></strong><st c="25955"> protocol. </st><st c="25966">Let’s </st><st c="25972">use it!</st></p>
			<h3><st c="25979">Use the Transferable protocol to pass the entire entity</st></h3>
			<p><st c="26035">Let’s step outside the framework </st><a id="_idIndexMarker851"/><st c="26069">of </st><code><st c="26072">AppIntent</st></code><st c="26081"> for a second. </st><st c="26096">The idea of sharing data is not limited to </st><code><st c="26139">AppIntent</st></code><st c="26148">—we have more use cases when we need to share data. </st><st c="26201">For example, dragging and dropping between views or even between apps is one example of sharing data. </st><st c="26303">Another example would be copying and pasting between screens </st><st c="26364">or apps.</st></p>
			<p><st c="26372">The main challenge when performing sharing is finding a data type each app </st><st c="26448">agrees on.</st></p>
			<p><st c="26458">To address that sharing problem, Apple introduced the </st><code><st c="26513">Transferable</st></code><st c="26525"> protocol in iOS 16, making sharing data between apps or different </st><st c="26592">spots easy.</st></p>
			<p><st c="26603">Transferable’s main usages</st><a id="_idIndexMarker852"/><st c="26630"> are copying and pasting and dragging and dropping, but it is also great for sharing app entities in the </st><st c="26735">Shortcuts app.</st></p>
			<p><st c="26749">Now, let’s extend </st><code><st c="26768">Task</st></code><st c="26772"> to conform </st><st c="26784">to </st><code><st c="26787">Transferable</st></code><st c="26799">:</st></p>
			<pre class="source-code"><st c="26801">
extension Task: </st><strong class="bold"><st c="26818">Transferable</st></strong><st c="26830"> {
    </st><strong class="bold"><st c="26833">static var transferRepresentation: some TransferRepresentation {</st></strong>
<strong class="bold"><st c="26897">…</st></strong>
<strong class="bold"><st c="26898">    }</st></strong><st c="26900">
}</st></pre>			<p><st c="26902">The </st><code><st c="26906">Transferable</st></code><st c="26918"> protocol has one static variable called </st><code><st c="26959">transferRepresentation</st></code><st c="26981">. This variable allows us to define how the structure is represented when sharing it with different apps </st><st c="27086">or views.</st></p>
			<p><st c="27095">When working with the </st><code><st c="27118">AppIntent</st></code><st c="27127"> framework, we</st><a id="_idTextAnchor421"/><a id="_idTextAnchor422"/><a id="_idTextAnchor423"/><st c="27141"> have several ways to fulfill the </st><code><st c="27175">transferRepresentation</st></code><st c="27197"> variable:</st></p>
			<ul>
				<li><code><st c="27207">DataRepresentation</st></code><st c="27226">: We use </st><code><st c="27236">DataRepresentation</st></code><st c="27254"> to convert our object to a data format such as RTF or an </st><st c="27312">image PNG</st></li>
				<li><code><st c="27321">FileRepresentation</st></code><st c="27340">: We use </st><code><st c="27350">FileRepresentation</st></code><st c="27368"> to export our entity as a file, such as </st><st c="27409">a PDF</st></li>
				<li><code><st c="27414">ProxyRepresentation</st></code><st c="27434">: This provides an alternative in case none of the other representations </st><st c="27508">are suitable</st></li>
			</ul>
			<p><st c="27520">Let’s see how we can support both RTF and </st><st c="27563">plain text:</st></p>
			<pre class="source-code"><st c="27574">
extension Task: Transferable {
    static var transferRepresentation: some TransferRepresentation {
        </st><strong class="bold"><st c="27671">DataRepresentation</st></strong><st c="27689">(exportedContentType: .rtf)
        { task in
            task.asRTF()!
        </st><st c="27742">}
        </st><strong class="bold"><st c="27744">ProxyRepresentation</st></strong><st c="27763">(exporting: \.title)
    }
}</st></pre>			<p><st c="27788">In our code example, we used both </st><code><st c="27823">DataRepresentation</st></code><st c="27841"> and </st><code><st c="27846">ProxyRepresentation</st></code><st c="27865"> to support both RTF and </st><st c="27890">plain text.</st></p>
			<p><st c="27901">This means that when we try</st><a id="_idIndexMarker853"/><st c="27929"> to share the </st><code><st c="27943">Task</st></code><st c="27947"> entity, the </st><code><st c="27960">Transferable</st></code><st c="27972"> mechanism will try to export the </st><code><st c="28006">RTF</st></code><st c="28009"> first and turn to </st><code><st c="28028">ProxyRepresentation</st></code><st c="28047"> as </st><st c="28051">a fallback.</st></p>
			<p><st c="28062">In addition, in the Shortcuts app, the user can select the data type they want to be exported to the next step in the script (</st><em class="italic"><st c="28189">Figure 13</st></em><em class="italic"><st c="28199">.10</st></em><st c="28202">):</st></p>
			<div><div><img src="img/B21795_figure_13.10.jpg" alt="Figure 13.10: The Shortcuts app with different data formats"/><st c="28205"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="28671">Figure 13.10: The Shortcuts app with different data formats</st></p>
			<p><em class="italic"><st c="28730">Figure 13</st></em><em class="italic"><st c="28740">.10</st></em><st c="28743"> shows how the user selects the data format for the </st><st c="28795">exported item.</st></p>
			<p><st c="28809">The more formats and data types we support in our app entities, the more choices our users have for using </st><st c="28916">our data.</st></p>
			<p><st c="28925">At this stage, we know how to export</st><a id="_idIndexMarker854"/><st c="28962"> our app intents and entities. </st><st c="28993">In a way, the system knows what our app is capable of. </st><st c="29048">Let’s see how we can take this one step further and adjust it to work with </st><st c="29123">Apple Intelligence.</st></p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor424"/><st c="29142">Adjusting our app intents to work with Apple Intelligence</st></h1>
			<p><st c="29200">In the previous chapter, we discussed</st><a id="_idIndexMarker855"/><st c="29238"> how we can take advantage of some of iOS’s machine learning and AI capabilities. </st><st c="29320">One of the things that evolved in that area in iOS 18 is Siri. </st><st c="29383">Siri is now smarter than ever and can allow users to perform tasks in </st><st c="29453">natural language.</st></p>
			<p><st c="29470">For example, the user can say something like </st><em class="italic"><st c="29516">Send this photo to my mom</st></em><st c="29541"> to Siri, and Siri can handle that task without needing the </st><st c="29601">exact phrase.</st></p>
			<p><st c="29614">Siri’s new capabilities are exactly where our app intents come in. </st><st c="29682">Imagine that on one side, we have Siri, which can understand the user intent. </st><st c="29760">On the other hand, we have the various actions we expose</st><a id="_idIndexMarker856"/><st c="29816"> to the system. </st><st c="29832">So, we must find a way to bind between the user intent, as Siri understands it, and our app actions. </st><st c="29933">This is what we call an </st><strong class="bold"><st c="29957">Assistant Schema</st></strong><st c="29973">.</st></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor425"/><st c="29974">Exploring the Assistant Schema</st></h2>
			<p><st c="30005">The Assistant Schema </st><a id="_idIndexMarker857"/><st c="30027">idea is simple yet advanced and full </st><st c="30064">of potential.</st></p>
			<p><st c="30077">Let’s look at </st><em class="italic"><st c="30092">Figure 13</st></em><em class="italic"><st c="30101">.11</st></em><st c="30104">, which describes how Assistant </st><st c="30136">Schema works:</st></p>
			<div><div><img src="img/B21795_figure_13.11.jpg" alt="Figure 13.11: The Assistant Schema flow"/><st c="30149"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="30343">Figure 13.11: The Assistant Schema flow</st></p>
			<p><em class="italic"><st c="30382">Figure 13</st></em><em class="italic"><st c="30392">.11</st></em><st c="30395"> describes how the Assistant Schema </st><st c="30431">flow works:</st></p>
			<ol>
				<li><st c="30442">The user requests Siri in a </st><em class="italic"><st c="30471">free and natural phrase</st></em><st c="30494"> for a specific action. </st><st c="30518">In this case, the user says, “Email this to </st><st c="30562">my wife.”</st></li>
				<li><st c="30571">Siri and Apple Intelligence convert the request to one of the system’s predefined schemas using sophisticated machine learning models. </st><st c="30707">In this case, Apple Intelligence translates the user request to the </st><code><st c="30775">createDraft</st></code><st c="30786"> schema from the </st><code><st c="30803">mail</st></code><st c="30807"> domain.</st></li>
				<li><st c="30815">Now that Siri knows the selected schema, it looks to find a matching intent in its toolbox. </st><st c="30908">We can associate some of our app intents with a </st><st c="30956">specific schema.</st></li>
				<li><st c="30972">Siri launches and performs a corresponding app intent according to the decision taken in the previous step (the </st><st c="31085">toolbox step).</st></li>
			</ol>
			<p><st c="31099">The fact that Apple Intelligence takes responsibility for understanding our users and picking the right action makes our job as developers simple – all we need to do is ensure our intents match a predefined </st><st c="31307">Assistant Schema.</st></p>
			<p><st c="31324">Let’s see how to do that. </st><st c="31351">Imagine</st><a id="_idIndexMarker858"/><st c="31358"> we have an amazing mail client app that we’ve built. </st><st c="31412">Users can browse their email accounts using our app and create and send new </st><st c="31488">email messages.</st></p>
			<p><st c="31503">One of the app’s main actions is creating a new draft; so, we’ve created an app intent to expose </st><st c="31601">that capability:</st></p>
			<pre class="source-code"><st c="31617">
struct </st><strong class="bold"><st c="31625">SendDraftIntent</st></strong><st c="31640">: AppIntent {
    static var title: LocalizedStringResource { "Send new email" }
    @Parameter(title: "Body")
    var body: String?
    </st><st c="31762">@MainActor
    func perform() async throws -&gt; some ReturnsValue
    &lt;MailDraftEntity&gt;{
        let mailDraftEntity = MailDraftEntity(body: EntityProperty(title: LocalizedStringResource(stringLiteral: body!)))
        ComposeDraftManager.shared.isPresentingCompose = true
        return .result(value: mailDraftEntity)
    }
}</st></pre>			<p><st c="32051">In this code example, we created a </st><code><st c="32087">SendDraftIntent</st></code><st c="32102"> app intent that takes a </st><code><st c="32127">body</st></code><st c="32131"> variable, creates a mail draft entity, and launches the </st><st c="32188">mail composer.</st></p>
			<p><st c="32202">It’s great that we have a </st><em class="italic"><st c="32229">create draft</st></em><st c="32241"> action our users can add to their shortcuts. </st><st c="32287">However, Siri doesn’t care that we called our app intent </st><code><st c="32344">SendDraftIntent</st></code><st c="32359"> – we want our intent to be part of its Apple Intelligence toolbox. </st><st c="32427">In other words – add it to the </st><st c="32458">Assistant Schema.</st></p>
			<p><st c="32475">To do that, we add a special Swift macro </st><st c="32517">called </st><code><st c="32524">AssistantIntent(schema:)</st></code><st c="32548">:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="32550">@AssistantIntent(schema: .mail.createDraft)</st></strong><st c="32593">
struct SendDraftIntent: AppIntent {</st></pre>			<p><st c="32629">Adding the </st><code><st c="32641">AssistantIntent</st></code><st c="32656"> Swift macro with the </st><code><st c="32678">.mail.createDraft</st></code><st c="32695"> schema to our app intent signals Apple Intelligence. </st><st c="32749">This is a </st><em class="italic"><st c="32759">create draft</st></em><st c="32771"> app intent regardless of how we </st><st c="32804">named it.</st></p>
			<p class="callout-heading"><st c="32813">Swift Macros – a reminder</st></p>
			<p class="callout"><st c="32839">Swift Macros is a new feature</st><a id="_idIndexMarker859"/><st c="32869"> Apple added to iOS 17 that can inject new properties and functions and manipulate our code to various needs. </st><st c="32979">To learn more about Swift Macros, refer to </st><a href="B21795_10.xhtml#_idTextAnchor329"><em class="italic"><st c="33022">Chapter 10</st></em></a><st c="33032">.</st></p>
			<p><st c="33033">The </st><code><st c="33038">.mail.createDraft</st></code><st c="33055"> schema</st><a id="_idIndexMarker860"/><st c="33062"> is built of two parts – the domain (</st><code><st c="33099">mail</st></code><st c="33104">) and the schema (</st><code><st c="33123">createDraft</st></code><st c="33135">). </st><st c="33139">We can use more schemas in the </st><code><st c="33170">mail</st></code><st c="33174"> domain, such as </st><code><st c="33191">deleteDraft</st></code><st c="33202">, </st><code><st c="33204">saveDraft</st></code><st c="33213">, or </st><code><st c="33218">replyMail</st></code><st c="33227">. In addition, we have more domains and schemas to work with, such as presentations, payments, browsing, photos, books, and more. </st><st c="33357">To see the full list</st><a id="_idIndexMarker861"/><st c="33377"> of domains and schemas, go to Apple’s documentation </st><st c="33430">at </st><a href="https://developer.apple.com/documentation/AppIntents/app-intent-domains"><st c="33433">https://developer.apple.com/documentation/AppIntents/app-intent-domains</st></a><st c="33504">.</st></p>
			<p><st c="33505">So, what does the </st><code><st c="33524">AssistantIntet</st></code><st c="33538"> Swift </st><st c="33545">macro do?</st></p>
			<p><st c="33554">The first thing it does is add a new static variable </st><st c="33608">named </st><code><st c="33614">__assistantSchemaIntent</st></code><st c="33637">:</st></p>
			<pre class="source-code">
<code><st c="33754">createDraft</st></code><st c="33765"> schema. </st><st c="33774">It also ensures that our intent conforms to the </st><code><st c="33822">AssistantSchemaIntent</st></code><st c="33843"> protocol, which gives it </st><st c="33869">more capabilities.</st></p>
			<p><st c="33887">Once that happens, it’s time to adjust</st><a id="_idIndexMarker862"/><st c="33926"> our code according to what the </st><st c="33958">compiler requires:</st></p>
			<ul>
				<li><st c="33976">We can remove the </st><code><st c="33995">title</st></code><st c="34000"> static variable, as the App Intents frameworks implement it </st><st c="34061">for us.</st></li>
				<li><st c="34068">The same goes for the </st><code><st c="34091">@Parameter</st></code><st c="34101"> argument. </st><st c="34112">The App Intents framework implements that for us, so we can also </st><st c="34177">remove that.</st></li>
				<li><st c="34189">We must add more properties to our app intent that are part of the </st><code><st c="34257">createDraft</st></code><st c="34268"> assistant schema – </st><code><st c="34288">account</st></code><st c="34295">, </st><code><st c="34297">attachments</st></code><st c="34308">, </st><code><st c="34310">to</st></code><st c="34312">, </st><code><st c="34314">cc</st></code><st c="34316">, </st><code><st c="34318">bcc</st></code><st c="34321">, </st><st c="34323">and </st><code><st c="34327">subject</st></code><st c="34334">.</st></li>
			</ul>
			<p><st c="34335">Our new modified </st><code><st c="34353">SendDraftIntent</st></code><st c="34368"> now looks </st><st c="34379">like this:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="34389">@AssistantIntent(schema: .mail.createDraft)</st></strong><st c="34433">
struct SendDraftIntent: AppIntent {
</st><strong class="bold"><st c="34470">    var account: MailAccountEntity?</st></strong>
<strong class="bold"><st c="34501">    var attachments: [IntentFile]</st></strong>
<strong class="bold"><st c="34531">    var to: [IntentPerson]</st></strong>
<strong class="bold"><st c="34554">    var cc: [IntentPerson]</st></strong>
<strong class="bold"><st c="34577">    var bcc: [IntentPerson]</st></strong>
<strong class="bold"><st c="34601">    var subject: String?</st></strong><st c="34622">
    var body: String?
    </st><st c="34641">@MainActor
    func perform() async throws -&gt; some ReturnsValue
    &lt;MailDraftEntity&gt;{
        let mailDraftEntity = MailDraftEntity(body:
          EntityProperty(title: LocalizedStringResource
           (stringLiteral: body!)))
        ComposeDraftManager.shared.isPresentingCompose =
          true
        return .result(value: mailDraftEntity)
    }</st></pre>			<p><st c="34929">In this code example, we can see the new modified version of the </st><code><st c="34995">SendDraftIntent</st></code><st c="35010"> struct. </st><st c="35019">The new properties, such as </st><code><st c="35047">attachments</st></code><st c="35058">, </st><code><st c="35060">to</st></code><st c="35062">, </st><code><st c="35064">cc</st></code><st c="35066">, and </st><code><st c="35072">bcc</st></code><st c="35075">, have particular types, such as </st><code><st c="35108">IntentFile</st></code><st c="35118"> and </st><code><st c="35123">IntentPerson</st></code><st c="35135">. The </st><code><st c="35141">AppIntent</st></code><st c="35150"> framework uses this type to identify people and files and have a clear interface that the system can work with. </st><st c="35263">Besides adding them to the </st><code><st c="35290">SendDraftIntent</st></code><st c="35305"> struct, we don’t need to do anything with them except use them in our </st><code><st c="35376">perform()</st></code><st c="35385"> function.</st></p>
			<p><st c="35395">When we look at the code, one question arises: How do we know what properties to add for each domain </st><st c="35497">and schema?</st></p>
			<p><st c="35508">At this time of writing, there is clear documentation of what properties each schema requires. </st><st c="35604">However, adding the </st><code><st c="35624">AssistantIntent</st></code><st c="35639"> Swift macro and building the project creates new errors that provide information about the </st><st c="35731">missing information.</st></p>
			<p><st c="35751">One exception, though, is the </st><code><st c="35782">account</st></code><st c="35789"> property, which requires</st><a id="_idIndexMarker863"/><st c="35814"> us to declare an </st><code><st c="35832">AssistantEntity</st></code><st c="35847">-based struct. </st><st c="35863">Let’s </st><st c="35869">discuss it.</st></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor426"/><st c="35880">Creating AssistantEntity</st></h2>
			<p><st c="35905">When we discussed </st><code><st c="35924">SendDraftIntent</st></code><st c="35939">, we reviewed</st><a id="_idIndexMarker864"/><st c="35952"> several properties, such as </st><code><st c="35981">attachments</st></code><st c="35992">, </st><code><st c="35994">to</st></code><st c="35996">, and </st><code><st c="36002">bcc</st></code><st c="36005">. We saw that for each one, the </st><code><st c="36037">AppIntents</st></code><st c="36047"> framework provides a dedicated type, such as </st><code><st c="36093">IntentPerson</st></code> <st c="36105">and </st><code><st c="36110">IntentFile</st></code><st c="36120">.</st></p>
			<p><st c="36121">The case of the </st><code><st c="36138">account</st></code><st c="36145"> property is a little </st><st c="36167">bit different:</st></p>
			<pre class="source-code">
<code><st c="36213">MailAccountEntity</st></code><st c="36231"> is not part of the framework of </st><code><st c="36264">AppIntent</st></code><st c="36273">—it’s a type we define that must fulfill the Assistant Schema</st><a id="_idIndexMarker865"/><st c="36335"> requirements, similar to what we did in </st><code><st c="36376">SendDraftIntent</st></code><st c="36391">. Let’s see how to </st><st c="36410">implement it:</st></p>
			<pre class="source-code"><st c="36423">
@AssistantEntity(schema: .mail.account)
struct MailAccountEntity {
    let id = UUID()
    var emailAddress: String
    var name: String
    static var defaultQuery = AccountQuery()
    struct AccountQuery:EntityStringQuery {
        func entities(matching string: String)
          async throws -&gt; [MailAccountEntity] {
            []
          }
        init() {}
        func entities(for identifiers: [MailAccountEntity.ID])
          async throws -&gt; [MailAccountEntity] {
            []
        }
    }
    var displayRepresentation: DisplayRepresentation
      { DisplayRepresentation(stringLiteral: name) }
}</st></pre>			<p><st c="36919">In this example, we can see that our </st><code><st c="36957">MailAccountEntity</st></code><st c="36974"> struct has a Swift macro named </st><code><st c="37006">@AssistantEntity(schema: .mail.account)</st></code><st c="37045">. This macro makes our entity conform to </st><code><st c="37086">AssistantSchemaEntity</st></code><st c="37107"> and requires the struct to implement important properties, such as </st><code><st c="37175">emailAddress</st></code> <st c="37187">and </st><code><st c="37192">name</st></code><st c="37196">.</st></p>
			<p><st c="37197">The Swift macro also requires us to add a default query to help the system fetch and locate accounts </st><st c="37299">when needed.</st></p>
			<p><st c="37311">The second entity</st><a id="_idIndexMarker866"/><st c="37329"> we need to implement </st><st c="37351">is </st><code><st c="37354">MailDraftEntity</st></code><st c="37369">:</st></p>
			<pre class="source-code"><st c="37371">
@AssistantEntity(schema: .mail.draft)
struct MailDraftEntity {
    static var defaultQuery = Query()
    struct Query: EntityStringQuery {
        init() {}
        func entities(for identifiers: [MailDraftEntity.ID])
          async throws -&gt; [MailDraftEntity] { [] }
        func entities(matching string: String)
          async throws -&gt; [MailDraftEntity] { [] }
    }
    var displayRepresentation: DisplayRepresentation
      { DisplayRepresentation(stringLiteral: "\(subject ?? </st><st c="37791">"")") }
    let id = UUID()
    var to: [IntentPerson]
    var cc: [IntentPerson]
    var bcc: [IntentPerson]
    var subject: String?
    </st><st c="37906">var body: String?
    </st><st c="37924">var attachments: [IntentFile]
    var account: MailAccountEntity
}</st></pre>			<p><code><st c="37986">MailDraftEntity</st></code><st c="38002"> contains properties such as those of </st><code><st c="38040">SendDraftIntent</st></code><st c="38055">. That’s because it’s the result of the </st><code><st c="38095">SendDraftIntent</st></code> <code><st c="38110">perform()</st></code><st c="38120"> function, and Siri can use it to chain the information to other actions in </st><st c="38196">its toolbox.</st></p>
			<p><st c="38208">Adding both </st><code><st c="38221">MailDraftEntity</st></code><st c="38236"> and </st><code><st c="38241">MailAccountEntity</st></code><st c="38258"> can be annoying – it requires us to adjust our information to a specific interface. </st><st c="38343">However, doing that makes our Siri integration flawless </st><st c="38399">and effective.</st></p>
			<p><st c="38413">Once we have everything</st><a id="_idIndexMarker867"/><st c="38437"> set, the user can see a photo and say something like, “Email this photo using MyMailComposer app,” and Siri will launch our app with a </st><st c="38573">new draft.</st></p>
			<p class="callout-heading"><st c="38583">An important disclaimer about the code snippets of this section</st></p>
			<p class="callout"><st c="38647">Apple Intelligence</st><a id="_idIndexMarker868"/><st c="38666"> has not yet been rolled out as of the time of writing this book. </st><st c="38732">This means the code was successfully compiled but has not yet been tested to work with Apple Intelligence. </st><st c="38839">When Apple Intelligence reaches your region, you may need to make some adjustments to your code in order for it to work with Siri </st><st c="38969">as expected.</st></p>
			<p><st c="38981">As one of Apple’s senior managers once said, we should consider all of our app actions to be app intents. </st><st c="39088">This approach makes the possibilities for us</st><a id="_idTextAnchor427"/><a id="_idTextAnchor428"/><st c="39132">ers to interact with our </st><st c="39158">app limitless.</st></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor429"/><st c="39172">Summary</st></h1>
			<p><st c="39180">That was an exciting chapter! </st><st c="39211">This is not only because app intents are a very exciting topic but also because it’s the first time we’re truly integrating our code with one of Apple’s most </st><st c="39369">significant technologies.</st></p>
			<p><st c="39394">In this chapter, we discussed the concept of app intents, created a simple app intent with different use cases, formalized our content using app entities, and even adjusted them to work with Apple Intelligence. </st><st c="39606">By now, we should be ready to bring Siri to our app in </st><st c="39661">no time!</st></p>
			<p><st c="39669">The next chapter looks at our app from a different perspective – </st><st c="39735">quality.</st></p>
		</div>
	<div></body></html>