- en: Customizing the Android Emulator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Android模拟器
- en: 'In the last chapter, we spent some time exploring the details of the Android
    system architecture. With our knowledge about kernel, HAL, and system service,
    we can start to customize the Android system ourselves. In this chapter, we will
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们花了一些时间探索Android系统架构的细节。凭借我们对内核、HAL和系统服务的了解，我们可以开始自己定制Android系统。在本章中，我们将涵盖以下主题：
- en: Why customize the Android emulator?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要自定义Android模拟器？
- en: Creating a new x86emu device
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的x86emu设备
- en: Building and testing the new x86emu device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试新的x86emu设备
- en: Why customize the Android emulator
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要自定义Android模拟器
- en: You may be wondering why we want to customize Android emulator. Google already
    provides it in the Android SDK and we can just use it without any additional effort.
    However, as a developer, you may find that it may not be good enough to meet your
    expectations. For example, in the most recent Android Studio or SDK releases,
    the Intel x86 emulator is recommended for developers, since it is much faster
    than the ARM version. One problem with using the Intel x86 emulator is that many
    Android applications with native code cannot run properly, because the x86 native
    library is not built into these applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们想要自定义Android模拟器。谷歌已经在Android SDK中提供了它，我们无需任何额外努力就可以使用它。然而，作为一名开发者，你可能会发现它可能不足以满足你的期望。例如，在最新的Android
    Studio或SDK版本中，推荐开发者使用英特尔x86模拟器，因为它比ARM版本快得多。使用英特尔x86模拟器的一个问题是，许多带有原生代码的Android应用程序无法正常运行，因为这些应用程序没有内置x86原生库。
- en: To resolve this issue, we can integrate Houdini libraries from Intel to the
    emulator. With Houdini libraries, we can execute ARM native code on the Intel
    x86 platform. Another common request for Android emulator is that **Google Mobile
    Services** (**GMS**) is not included in it. Many developers develop applications
    with the assumption that GMS should be available on the device. In the next few
    chapters, we will learn how to create a x86emu device to customize Android emulator
    so that we can integrate components such as Houdini or enable additional hardware
    interfaces, such as Wi-Fi, in Android emulator. Armed with the knowledge about
    how to create the x86emu device, you can create your own Android emulator to meet
    your requirements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以将英特尔（Intel）的Houdini库集成到模拟器中。有了Houdini库，我们可以在英特尔x86平台上执行ARM原生代码。对于Android模拟器，另一个常见的请求是它不包括**谷歌移动服务**（**GMS**）。许多开发者假设设备上应该有GMS可用，因此开发应用程序。在接下来的几章中，我们将学习如何创建x86emu设备以自定义Android模拟器，这样我们就可以集成Houdini或启用Wi-Fi等附加硬件接口等组件。掌握了如何创建x86emu设备的知识，你可以创建自己的Android模拟器以满足你的需求。
- en: It is possible, we always avoid changing too much AOSP code directly. This is
    because the more we change, the harder it is for us to port it to the latest version
    of Android. Google constantly releases new Android code from time to time. Sometime,
    new releases may be difficult to merge because of the architecture change.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是尽量避免直接更改过多的AOSP代码。这是因为我们更改得越多，将其移植到最新版本的Android就越困难。谷歌不时地发布新的Android代码。有时，由于架构变化，新版本可能难以合并。
- en: From this chapter to [Chapter 7](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml),
    *Enabling Wi-Fi on the Android Emulator*, we will teach a way to customize existing
    devices with minimal changes to the AOSP source code. From Chapter 8, *Creating
    Your Own Device on VirtualBox* to [Chapter 11](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml),
    *Enabling VirtualBox-Specific Hardware Interfaces*, we will discuss the porting
    to a new platform that we have to change to AOSP code directly. Even in that case,
    we still have to plan and consider the merge effort to a new Android release.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章到[第7章](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml)，“在Android模拟器上启用Wi-Fi”，我们将介绍一种通过最小更改AOSP源代码来定制现有设备的方法。从第8章，“在VirtualBox上创建自己的设备”到[第11章](3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml)，“启用VirtualBox特定的硬件接口”，我们将讨论移植到新平台，我们必须直接更改AOSP代码。即使在那种情况下，我们仍然需要计划和考虑将合并努力到新的Android版本中。
- en: Understanding build layers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构建层
- en: 'The AOSP build system includes the abstraction layers to build a device. After
    we understand the ideas behind these layers, it will help us to understand the
    relationship of the various Makefiles for a device. It is always good to refer
    to the original Google document at the following URL, when you start to create
    a new device. The information will usually be updated when a new Android release
    is available: [http://source.android.com/source/add-device.html](http://source.android.com/source/add-device.html).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP构建系统包括构建设备的抽象层。在理解这些层的理念之后，这将有助于我们理解设备各种Makefile之间的关系。在开始创建新设备时，总是好的参考以下URL的原始Google文档：[http://source.android.com/source/add-device.html](http://source.android.com/source/add-device.html)。
- en: In this section, we will apply the information from the previous Google document
    to the specific Android emulator virtual hardware that we are going to work on.
    In this way, we can derive all device-specific Makefiles according to the general
    guidance from the previous Google document. Throughout the process from generic
    to specific, we can apply the inheritance of object-oriented concepts to the Makefile
    system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把之前Google文档中的信息应用到我们将要工作的特定Android模拟器虚拟硬件上。这样，我们可以根据之前Google文档中的通用指导创建所有设备特定的Makefile。在整个从通用到具体的过程中，我们可以将面向对象概念中的继承应用到Makefile系统中。
- en: There are three layers, **Product**, **Board/Device**, and **Architecture**,
    in the device build system. These layers can be considered as different dimensions
    to measure the characteristic of a product. Each layer relates to the one above
    it in a one-to-many relationship, which is similar to the inheritance or composition
    relationship in the object-oriented terms. For example, one kind of hardware architecture
    can have more than one board and each board can have more than one product. We
    will see how this method works when we create a new device in this chapter later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设备构建系统中有三个层，**产品**、**板/设备**和**架构**。这些层可以被视为衡量产品特性的不同维度。每个层与其上面的层之间有一个一对多的关系，这在面向对象术语中类似于继承或组合关系。例如，一种硬件架构可以有多个板，每个板可以有多个产品。我们将在本章后面创建新设备时看到这种方法是如何工作的。
- en: The following table is a list of layers used in an AOSP build system. I created
    this table by modifying the one from the Google document and added my comments
    specific to the x86emu device, which we are going to work on in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下表是AOSP构建系统中使用的层列表。我是通过修改Google文档中的表格并添加针对我们将要工作的x86emu设备的特定注释来创建这个表格的。
- en: '| **Layer** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **层** | **描述** |'
- en: '| Product | The Product layer defines the feature specifications of the shipping
    product such as the modules to build, locales supported, and the configuration
    for various locales. In other words, this is the name of the overall product.
    Product-specific variables are defined in **product definition Makefiles**. A
    product can inherit from other product definitions, which simplifies maintenance.
    A common method is to create a base product that contains features that apply
    for all products, then creating product variants based on that base product.In
    this chapter, we inherit from a generic device for an Android emulator in AOSP
    to create our x86emu device. For the x86emu device, we can also create two products
    that differ only by their architecture variants (we can have different builds
    for x86 or x86_64). |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 产品 | 产品层定义了发货产品的功能规范，例如要构建的模块、支持的地区以及各种地区的配置。换句话说，这是整体产品的名称。产品特定的变量在**产品定义Makefile**中定义。一个产品可以继承自其他产品定义，这简化了维护。一个常见的方法是创建一个包含适用于所有产品的功能的基产品，然后基于该基产品创建产品变体。在本章中，我们继承自AOSP中Android模拟器的通用设备，以创建我们的x86emu设备。对于x86emu设备，我们还可以创建两个产品，它们仅通过其架构变体不同（我们可以为x86或x86_64有不同的构建）。
    |'
- en: '| Board/Device | The Board/Device layer represents the physical layer of plastic
    on the device (that is, the industrial design of the device). For example, North
    American devices probably include QWERTY keyboards, whereas devices sold in France
    probably include AZERTY keyboards.This layer also represents the bare schematics
    of a product. These include the peripherals on the board and their configuration.
    In the x86emu device, we need to define the size of the filesystem, the graphics
    hardware and camera, and so on. In [Chapter 7](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml),
    *Enabling Wi-Fi on the Android Emulator*, we want to support Wi-Fi in the emulator.
    We need to specify it in the board configuration file. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 板/设备 | 板/设备层代表了设备上的物理塑料层（即，设备的设计）。例如，北美设备可能包括QWERTY键盘，而在法国销售的设备可能包括AZERTY键盘。这一层还代表了产品的裸机原理图。这包括板上的外围设备和它们的配置。在x86emu设备中，我们需要定义文件系统的尺寸、图形硬件和摄像头等。在第7章[启用Android模拟器的Wi-Fi](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml)中，我们希望在模拟器中支持Wi-Fi。我们需要在板配置文件中指定它。'
- en: '| Arch | The Architecture layer describes the processor configuration and **Application
    Binary Interface** (**ABI**) running on the board. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 架构 | 架构层描述了板上的处理器配置和**应用二进制接口**（**ABI**）。'
- en: Build variants
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建变体
- en: When building for a particular product, it's often useful to have minor variations
    on what is ultimately the final release build. By using different build variants,
    it can help the different parties in the product development cycle. There are
    primarily three kinds of build variant in the AOSP so far. The **engineering build**
    is the default one and is suitable for development work. In this type of build,
    the product security policy is not fully enforced and the debugging mechanisms
    are turned on. It is easy for engineers to test and fix issues with an engineering
    build.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当为特定产品构建时，通常对最终发布构建进行一些小的变化是有用的。通过使用不同的构建变体，可以帮助产品开发周期中的不同各方。到目前为止，AOSP主要有三种构建变体。**工程构建**是默认的，适合开发工作。在这种类型的构建中，产品安全策略没有完全执行，并且调试机制被打开。工程师使用工程构建测试和修复问题很容易。
- en: The second flavor is **user build**, which is used for the final release. All
    debugging mechanisms are turned off and the product security policy is fully enforced.
    The third flavor is **userdebug,** which is in between the engineering build and
    user build. This type of build can be used in the field test, which is also used
    by the end users.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种口味是**用户构建**，用于最终发布。所有调试机制都被关闭，产品安全策略被完全执行。第三种口味是**用户调试**，位于工程构建和用户构建之间。这种类型的构建可用于现场测试，这也被最终用户使用。
- en: All components in the AOSP build are called **modules**. In a module definition,
    the module can specify tags with `LOCAL_MODULE_TAGS`, which can be one or more
    values of `optional` (default), `debug`, or `eng`. With a tag, we can define the
    usage of a module. For example, all debug tools will only be included in the engineering
    build.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP构建中的所有组件都称为**模块**。在模块定义中，模块可以使用`LOCAL_MODULE_TAGS`指定标签，可以是`optional`（默认）、`debug`或`eng`的值之一或多个。通过标签，我们可以定义模块的用途。例如，所有调试工具都只包含在工程构建中。
- en: If a module doesn't specify a tag (by `LOCAL_MODULE_TAGS`), its tag defaults
    to `optional`. An `optional` module is installed only if it is required by product
    configuration with `PRODUCT_PACKAGES`. We usually specify packages needed by a
    product in the device Makefile using the `PRODUCT_PACKAGES` variable. This way,
    we can easily define modules that are only suitable for a particular build.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块没有指定标签（通过`LOCAL_MODULE_TAGS`），其标签默认为`optional`。一个`optional`模块只有在产品配置需要`PRODUCT_PACKAGES`时才会安装。我们通常在设备的Makefile中使用`PRODUCT_PACKAGES`变量来指定产品需要的包。这样，我们可以轻松定义只适用于特定构建的模块。
- en: 'The following table shows the AOSP-defined build variants documented in the
    preceding Google URL:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了在先前的Google URL中记录的AOSP定义的构建变体：
- en: '| **Build variants** | **Description** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **构建变体** | **描述** |'
- en: '| `eng` | This is the default flavor:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '| `eng` | 这是默认口味：'
- en: 'Installs modules tagged with: `eng` and/or `debug`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装带有标签`eng`和/或`debug`的模块
- en: Installs modules according to the product definition files, in addition to tagged
    modules
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据产品定义文件安装模块，以及带有标签的模块
- en: '`ro.secure=0`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro.secure=0`'
- en: '`ro.debuggable=1`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro.debuggable=1`'
- en: '`ro.kernel.android.checkjni=1`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro.kernel.android.checkjni=1`'
- en: '`adb` is enabled by default'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认启用`adb`
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `user` | This is the flavor intended to be the final release:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '| `user` | 这是打算作为最终发布的口味：'
- en: Installs modules tagged with `user`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装标记为`user`的模块
- en: Installs modules according to the product definition files, in addition to tagged
    modules.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据产品定义文件安装模块，除了标记的模块。
- en: '`ro.secure=1`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro.secure=1`'
- en: '`ro.debuggable=0`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro.debuggable=0`'
- en: '`adb` is disabled by default'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认禁用`adb`
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `userdebug` | The same as `user`, except:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '| `userdebug` | 与`user`相同，除了：'
- en: Also installs modules tagged with `debug`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也安装了标记为`debug`的模块
- en: '`ro.debuggable=1`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro.debuggable=1`'
- en: '`adb` is enabled by default'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认启用`adb`
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Creating a new x86emu device
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的x86emu设备
- en: To customize Android emulator, we need to create a new device based on Android
    emulator and make our customization on this new device. We will work on this from
    the original AOSP source code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自定义Android模拟器，我们需要基于Android模拟器创建一个新设备，并在该新设备上进行定制。我们将从这个原始AOSP源代码开始工作。
- en: Checking out from the AOSP
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AOSP检出
- en: 'As I mentioned before, I try to avoid unnecessary changes to the AOSP source
    code as much as I can. In this chapter, in order to set up the build environment,
    you can check out the `android-7.1.1_r4` version of the AOSP source code and clone
    the kernel and x86emu source to the AOSP source tree as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，我会尽量避免对AOSP源代码进行不必要的修改。在本章中，为了设置构建环境，你可以检出AOSP源代码的`android-7.1.1_r4`版本，并将内核和x86emu源代码克隆到AOSP源代码树中，如下所示：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we have retrieved the source code step by step. The project x86emu is the
    new device that we create in this chapter and can be used to customize Android
    emulator in the next few chapters. The goldfish project is the kernel that I forked
    from the AOSP goldfish kernel: [https://android.googlesource.com/kernel/goldfish/](https://android.googlesource.com/kernel/goldfish/).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经逐步检索了源代码。项目x86emu是我们本章创建的新设备，可以用于在接下来的几章中定制Android模拟器。goldfish项目是我从AOSP
    goldfish内核分叉的内核：[https://android.googlesource.com/kernel/goldfish/](https://android.googlesource.com/kernel/goldfish/)。
- en: 'The `android-7.1.1_r4_x86emu_ch04_r1` tag is the baseline of this chapter''s
    source code release. All source code created or changed in this book is baselined
    using the naming convention `{Android version}_{project}_{chapter number}_{release
    number}`. Here is the explanation of this naming convention:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`android-7.1.1_r4_x86emu_ch04_r1`标签是本章源代码发布的基线。本书中创建或更改的所有源代码都使用命名约定`{Android版本}_{项目}_{章节号}_{发布号}`作为基线。以下是此命名约定的说明：'
- en: '`Android version` is the original AOSP version number'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android version`是原始AOSP版本号'
- en: '`project` can be x86emu or x86vbox'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project`可以是x86emu或x86vbox'
- en: '`chapter number` is what chapter we create a baseline for the source code'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter number`是我们为源代码创建基线所用的章节号'
- en: '`release number` is used to indicate the number of releases'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`release number`来表示发布次数
- en: These can work in the simple configuration of this chapter. This method is not
    good enough when we use source code from multiple sources as we will do in other
    chapters later in this book. We will use our own manifest file to manage the source
    code in this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在本章的简单配置中工作。当我们使用来自多个来源的源代码时（如本书后面的章节中所述），这种方法就不够好了。我们将使用我们自己的清单文件来管理本书中的源代码。
- en: Checking out from a local mirror
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地镜像检出
- en: 'To use our own manifest file, we can use either a local mirror or a remote
    repository. If we use a local mirror, we have to change `manifest.xml` of `android-7.1.1_r4`
    a little to make our own. We copy `.repo/manifest.xml` to our `manifests/default.xml`
    and make the following changes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们自己的清单文件，我们可以使用本地镜像或远程仓库。如果我们使用本地镜像，我们必须稍微修改`android-7.1.1_r4`的`manifest.xml`以创建我们自己的。我们将`.repo/manifest.xml`复制到我们的`manifests/default.xml`并做出以下更改：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This manifest file has an assumption that our local mirror has the following
    directory structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单文件假设我们的本地镜像具有以下目录结构：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The AOSP mirror is created under the `android` folder. GitHub mirror is created
    under the `github` folder. We need to use android-x86 source code as well later.
    We can put it under the `android-x86` folder. Our own manifest is stored at `github/manifests`
    and the preceding manifest file is `github/manifests/default.xml`. In this file,
    we add additional lines to retrieve the Android kernel and x86emu device from
    GitHub.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP镜像创建在`android`文件夹下。GitHub镜像创建在`github`文件夹下。稍后我们还需要使用android-x86源代码。我们可以将其放在`android-x86`文件夹下。我们的清单文件存储在`github/manifests`中，前面的清单文件是`github/manifests/default.xml`。在此文件中，我们添加了额外的行以从GitHub检索Android内核和x86emu设备。
- en: 'With this manifest, we can get the source code using the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此清单，我们可以使用以下命令获取源代码：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also retrieve all source code from the remote repository directly using
    our own manifest file. With that, we need to change the manifest file a little
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接使用我们自己的清单文件从远程仓库检索所有源代码。为此，我们需要稍微更改清单文件如下：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we changed the URL of the remote `aosp` to use the absolute
    path in this revision of the manifest file. To check out the source code using
    this revision, we can run the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们更改了远程 `aosp` 的URL，在本版本清单文件中使用绝对路径。要使用此修订版检出源代码，我们可以运行以下命令：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because there are multiple repositories involved in this book, I strongly encourage
    you to use a local mirror. This can make the build and debug process more efficient.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书涉及多个仓库，我强烈建议你使用本地镜像。这可以使构建和调试过程更加高效。
- en: It is also possible to use `local_manifests` to set up your workspace. You can
    refer to Appendix B, *Using Repo in This Book*, in the book *Embedded Programming
    with Android*. A sample file can be found at [https://github.com/shugaoye/build/blob/master/local_manifest.xml](https://github.com/shugaoye/build/blob/master/local_manifest.xml).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `local_manifests` 来设置你的工作空间。你可以参考书中附录B，*使用Repo本书中的Repo*，在《Android嵌入式编程》一书中。一个示例文件可以在[https://github.com/shugaoye/build/blob/master/local_manifest.xml](https://github.com/shugaoye/build/blob/master/local_manifest.xml)找到。
- en: 'In this book, I use branches for the manifest file to manage the different
    versions of source code. To create a baseline of the source code in a chapter,
    I use the following naming convention:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我使用分支来管理清单文件的不同版本源代码。为了创建章节中源代码的基线，我使用以下命名约定：
- en: '`{Android version}_{chapter number}_{remote (optional)}`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`{Android版本}_{章节编号}_{远程（可选）}`'
- en: '`Android version` is the original AOSP version number'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android版本` 是原始AOSP版本号'
- en: '`chapter number` is what chapter we create a baseline for the source code'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`章节编号` 是我们为源代码创建基线的章节'
- en: '`remote` is used to indicate how to check out the source code from the remote
    repositories'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote` 用于指示如何从远程仓库检出源代码'
- en: For example, from the following screenshot, we can see that the branch `android-7.1.1_r4_ch04`
    is used to check out the source code of chapter 4 from a local mirror. The branch
    `android-7.1.1_r4_ch04_aosp` is used to check out the source code for chapter
    4 from the remote repository. Since I am in China, I don't have access to the
    AOSP source code all the time. I created revisions (`android-7.1.1_r4_ch04_tuna`
    and `android-7.1.1_r4_ch04_ustc`) for chapter 4 to check out the source code from
    AOSP mirrors in China and GitHub. You may change the manifest file according to
    your needs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从以下截图，我们可以看到分支 `android-7.1.1_r4_ch04` 用于从本地镜像检出第4章的源代码。分支 `android-7.1.1_r4_ch04_aosp`
    用于从远程仓库检出第4章的源代码。由于我身处中国，我并不总是能访问AOSP源代码。我为第4章创建了修订版（`android-7.1.1_r4_ch04_tuna`
    和 `android-7.1.1_r4_ch04_ustc`），以便从中国的AOSP镜像和GitHub检出源代码。你可以根据需要更改清单文件。
- en: '![](img/image_04_001.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_001.png)'
- en: Creating x86emu device
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建x86emu设备
- en: 'After we check out the source code, we can look at how to create a new x86emu
    device in the `$AOSP/device` folder. The hierarchy in the `device` folder is in
    the `vendor-name/device-name` format. For example, the Nexus S from Samsung can
    be found in the `samsung/crespo` folder. The device name of Nexus S is `crespo`.
    We can create our device under a common folder, `generic`, as follows. The folder
    name for our device is `generic*/*x86emu`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检出源代码后，我们可以查看如何在 `$AOSP/device` 文件夹中创建一个新的x86emu设备。`device` 文件夹中的层次结构是 `vendor-name/device-name`
    格式。例如，三星的Nexus S可以在 `samsung/crespo` 文件夹中找到。Nexus S的设备名称是 `crespo`。我们可以在一个公共文件夹
    `generic` 下创建我们的设备，如下所示。我们设备的文件夹名称为 `generic*/*x86emu`：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the project that we create in this chapter and you can find the source
    code at [https://github.com/shugaoye/x86emu.git](https://github.com/shugaoye/x86emu.git).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章中我们创建的项目，你可以在[https://github.com/shugaoye/x86emu.git](https://github.com/shugaoye/x86emu.git)找到源代码。
- en: 'We will create a list of Makefiles in this folder to build the device. Refer
    to the build layers in the previous section. Here is a list of Makefiles that
    need to be included in the device skeleton:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在该文件夹中创建一个Makefiles列表来构建设备。参考上一节的构建层。以下是需要包含在设备骨架中的Makefiles列表：
- en: '`AndroidProducts.mk`: This is a Makefile to describe the various products that
    can be built for this device'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidProducts.mk`：这是一个Makefile，用于描述可以为该设备构建的各种产品'
- en: '`BoardConfig.mk`: This is a board configuration Makefile for the hardware board'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoardConfig.mk`：这是硬件板卡的板配置 Makefile。'
- en: '`device.mk`: This is the device Makefile that is used to declare the files
    and modules needed for the device'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device.mk`：这是用于声明设备所需文件和模块的设备 Makefile。'
- en: '`vendorsetup.sh`: This is a shell script that can be used to add your product
    (a "lunch combo") to the build along with a build variant separated by a dash'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendorsetup.sh`：这是一个可以用来将您的产品（一个 "lunch 组合"）以及通过破折号分隔的构建变体添加到构建中的 shell 脚本。'
- en: '`{Product Makefile}.mk`: This is the product definition Makefile and it is
    used to create a specific product based on the device'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{Product Makefile}.mk`：这是产品定义 Makefile，它用于根据设备创建特定的产品。'
- en: Now we can create Makefiles for our device one by one according to the preceding
    list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据前面的列表逐个创建我们设备的 Makefile。
- en: AndroidProducts.mk
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AndroidProducts.mk
- en: We included all product definition Makefiles in this file. The AOSP build system
    will start to search all product definitions using this file. The following is
    the content of `AndroidProducts.mk:`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有产品定义 Makefile 包含在这个文件中。AOSP 构建系统将开始使用此文件搜索所有产品定义。以下为 `AndroidProducts.mk`
    的内容：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, we defined two product variants for x86 and x86_64 builds.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们为 x86 和 x86_64 构建定义了两个产品变体。
- en: Both `x86emu_x86.mk` and `x86emu_x86_64.mk` are very similar. They define the
    same set of product definition variables for 32 bit and 64 bit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`x86emu_x86.mk` 和 `x86emu_x86_64.mk` 都非常相似。它们为 32 位和 64 位定义了相同的产品定义变量集。'
- en: 'The following table compares the product definition Makefiles for 32-bit and
    64-bit build:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下表比较了 32 位和 64 位构建的产品定义 Makefile：
- en: '| `x86emu_x86.mk` | `x86emu_x86_64.mk` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `x86emu_x86.mk` | `x86emu_x86_64.mk` |'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'You may notice that we inherit the common product definition files for 32-bit
    and 64-bit first at the beginning:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们在开头首先继承了 32 位和 64 位的通用产品定义文件：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以及：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are many generic product definitions defined by the AOSP build system.
    You can find them at `$AOSP/build/target/product`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP 构建系统定义了许多通用产品定义。您可以在 `$AOSP/build/target/product` 找到它们：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, a set of product definition variables `PRODUCT_BRAND`, `PRODUCT_NAME`,
    `PRODUCT_DEVICE`, and `PRODUCT_MODEL` are defined with different values. `TARGET_ARCH`
    and `TARGET_KERNEL_CONFIG` are also defined for 32 bit and 64 bit separately.
    Pay attention to `PRODUCT_MODEL`. Since we will change Makefiles in each chapter,
    in this book we use `PRODUCT_MODEL` to indicate the build for each chapter. In
    this chapter, we define `PRODUCT_MODEL` as `x86emu_x86_ch4` for the build in this
    chapter. At the end of the file, we also include a common `Makefile x86emu_base.mk`
    for both 32-bit and 64-bit products. This file includes additional configurations
    for the kernel build:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，定义了一系列具有不同值的 product 定义变量 `PRODUCT_BRAND`、`PRODUCT_NAME`、`PRODUCT_DEVICE`
    和 `PRODUCT_MODEL`。`TARGET_ARCH` 和 `TARGET_KERNEL_CONFIG` 也分别针对 32 位和 64 位进行定义。请注意
    `PRODUCT_MODEL`。由于我们将在每个章节中更改 Makefile，在这本书中我们使用 `PRODUCT_MODEL` 来表示每个章节的构建。在本章中，我们将
    `PRODUCT_MODEL` 定义为 `x86emu_x86_ch4` 以表示本章的构建。在文件末尾，我们还包含了一个通用的 `Makefile x86emu_base.mk`，用于
    32 位和 64 位产品。此文件包括内核构建的额外配置：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The kernel build is usually not included in the AOSP build. You have to build
    them separately according to the instructions from Google. In this book, we integrate
    the kernel build in our own Makefile here. The kernel `AndroidKernel.mk` Makefile
    is created based on the Makefile of the Qualcomm kernel source at [https://android.googlesource.com/kernel/msm/](https://android.googlesource.com/kernel/msm/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建通常不包括在 AOSP 构建中。您必须根据 Google 的说明单独构建它们。在这本书中，我们将内核构建集成到我们自己的 Makefile 中。`AndroidKernel.mk`
    Makefile 是基于高通内核源码的 Makefile 创建的，该源码位于 [https://android.googlesource.com/kernel/msm/](https://android.googlesource.com/kernel/msm/)。
- en: 'There are many product definition variables used in the preceding Makefiles.
    Let''s review the product definition variables that we used here. Refer to the
    Google documents for the complete list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Makefile 中使用了许多产品定义变量。让我们回顾一下我们在这里使用的产品定义变量。请参阅 Google 文档以获取完整列表：
- en: '`PRODUCT_BRAND`: This is the brand that the software is customized for. We
    just defined it as our device name.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_BRAND`：这是软件定制的品牌。我们将其定义为我们的设备名称。'
- en: '`PRODUCT_NAME`: This is the product name that we give to the device. We set
    it to `x86emu_x86` in this book. It is also the prefix that we can select in the
    lunch combo, such as `x86emu_x86-eng`. The suffix is the build variants.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_NAME`：这是我们赋予设备的名称。在这本书中，我们将其设置为 `x86emu_x86`。它也是我们可以在 lunch 组合中选择的名称前缀，例如
    `x86emu_x86-eng`。后缀是构建变体。'
- en: '`PRODUCT_DEVICE`: The name of the actual product. `TARGET_DEVICE` derives from
    this variable. This is also the board name that the build system uses to locate
    `BoardConfig.mk`. It is the x86emu for our device and it is also the directory
    name of our device at `$AOSP/device/generic/x86emu`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_DEVICE`：实际产品的名称。`TARGET_DEVICE` 从这个变量派生。这也是构建系统用来定位 `BoardConfig.mk`
    的板名。对于我们的设备，它是 x86emu，也是我们设备在 `$AOSP/device/generic/x86emu` 目录的名称。'
- en: '`PRODUCT_MODEL`: This is the name that we can see in the settings in Model.
    As I mentioned earlier, we use this variable to differentiate the build of each
    chapter in this book.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_MODEL`：这是我们在设置中的“型号”中可以看到的名称。如我之前所述，我们使用这个变量来区分本书中每个章节的构建。'
- en: '`PRODUCT_OUT`: This is the output folder of the build result. It is the same
    as the environment variable `$OUT`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_OUT`：这是构建结果的输出文件夹。它与环境变量 `$OUT` 相同。'
- en: '`PRODUCT_COPY_FILES`: This is a list of specific files that we would like to
    copy to the target''s filesystem. The list of words looks like `source_path:destination_path`.
    The file at the source path should be copied to the destination path during the
    build process.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_COPY_FILES`：这是我们希望复制到目标文件系统中的特定文件列表。单词列表看起来像 `source_path:destination_path`。在构建过程中，位于源路径的文件应该被复制到目标路径。'
- en: BoardConfig.mk
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BoardConfig.mk
- en: '`BoardConfig.mk` defines the board-specific configurations. We define CPU/ABI,
    the target architecture, OpenGLES configurations, and so on in this file. We also
    define the image file size, format, and so on:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardConfig.mk` 定义了板级特定配置。我们在该文件中定义 CPU/ABI、目标架构、OpenGLES 配置等。我们还在该文件中定义了镜像文件的大小、格式等：'
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This file is copied from a predefined AOSP board configuration at `$AOSP/build/target/board/generic_x86/BoardConfig.mk`
    with minor changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是从预定义的 AOSP 板配置 `$AOSP/build/target/board/generic_x86/BoardConfig.mk` 复制过来的，并做了少量修改。
- en: 'We can also use the system-defined board configuration directly and overwrite
    predefined variables as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接使用系统定义的板级配置，并覆盖预定义变量，如下所示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we look at the folder of `$AOSP/build/target/board/generic_x86`, it contains
    a few other files:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `$AOSP/build/target/board/generic_x86` 文件夹，它包含了一些其他文件：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to copy `system.prop` to our `device` folder as well, since this file
    defines the **Radio Interface Layer** (**RIL**) configuration for the emulator
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 `system.prop` 复制到我们的 `device` 文件夹中，因为这个文件定义了模拟器的 **Radio Interface Layer**
    （RIL）配置，如下所示：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Without this, you will find that the data connection cannot work properly in
    the build.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个，您会发现数据连接在构建中无法正常工作。
- en: device.mk
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: device.mk
- en: 'You may notice that there is a `device.mk` file in the `generic_x86` folder.
    Yes, we can reuse that file directly. The following is our `device.mk` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到 `generic_x86` 文件夹中有一个 `device.mk` 文件。是的，我们可以直接重用该文件。以下是我们 `device.mk`
    文件的内容：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see, in our `device.mk` file, we simply inherit the common `device.mk`
    from the `generic_x86` device.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在我们的 `device.mk` 文件中，我们只是简单地从 `generic_x86` 设备继承了通用的 `device.mk`。
- en: 'We can look at the `device.mk` file for the `generic_x86` device as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看 `generic_x86` 设备的 `device.mk` 文件如下：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding `device.mk` file for the `generic_x86` device, it overwrites
    a few properties and copies configuration files to the `system` folder. It also
    includes the HAL layers for the goldfish device.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `device.mk` 文件中，针对 `generic_x86` 设备，它覆盖了一些属性并将配置文件复制到 `system` 文件夹。它还包括
    goldfish 设备的 HAL 层。
- en: 'Now we can add our device build to the build system using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令将我们的设备构建添加到构建系统中：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Such as:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To automatically add this to the build system, we can add a script `vendorsetup.sh`.
    In this script, we can create all the build variants for `x86emu_x86`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动将其添加到构建系统中，我们可以添加一个脚本 `vendorsetup.sh`。在这个脚本中，我们可以为 `x86emu_x86` 创建所有构建变体：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Be aware that the 64-bit build for the x86emu device is not tested in this book.
    You must make the necessary changes by yourself if you want to test a 64-bit build.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本书中没有测试 x86emu 设备的 64 位构建。如果您想测试 64 位构建，您必须自行进行必要的更改。
- en: 'In this section, besides product-level variables as I explained before, there
    are also variables for the target device and board-level variables. The following
    is a list of variables for the target devices that are defined in `BoardConfig.mk`,
    `device.mk`, or product definition Makefiles:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，除了之前解释的产品级变量之外，还有针对目标设备和板级变量的变量。以下是在 `BoardConfig.mk`、`device.mk` 或产品定义
    Makefiles 中定义的目标设备变量列表：
- en: '`TARGET_ARCH`: This is the architecture of the device. It is usually something
    such as `arm`, `x86`, and so on.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_ARCH`: 这是指设备的架构。它通常是诸如 `arm`、`x86` 等之类的某种东西。'
- en: '`TARGET_USERIMAGES_USE_EXT4`: This variable needs to be set as `true` to build
    a filesystem in ext4 format. The filesystem can be built into other formats such
    as yaffs2 in the older Android version prior to Android 4.4.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_USERIMAGES_USE_EXT4`: 为了在 ext4 格式下构建文件系统，这个变量需要设置为 `true`。在 Android
    4.4 之前的旧版本 Android 中，文件系统可以构建为 yaffs2 等其他格式。'
- en: '`TARGET_KERNEL_SOURCE`: This is the path for the kernel source code. In our
    case, the kernel source code can be found at `$AOSP/kernel`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_KERNEL_SOURCE`: 这是内核源代码的路径。在我们的案例中，内核源代码可以在 `$AOSP/kernel` 找到。'
- en: '`TARGET_KERNEL_CONFIG` : The kernel configuration file that we use to build
    the kernel source.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_KERNEL_CONFIG`: 我们用来构建内核源代码的内核配置文件。'
- en: 'The following is a list of board-level variables that we used in this chapter:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在本章中使用的一组板级变量列表：
- en: '`BOARD_SYSTEMIMAGE_PARTITION_SIZE`: The size of the filesystem partition for
    the system image (`system.img`)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_SYSTEMIMAGE_PARTITION_SIZE`: 系统镜像文件系统分区的大小（`system.img`）'
- en: '`BOARD_USERDATAIMAGE_PARTITION_SIZE`: The size of the filesystem partition
    for the user data (`userdata.img`)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_USERDATAIMAGE_PARTITION_SIZE`: 用户数据文件系统分区的大小（`userdata.img`）'
- en: '`BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE`: The filesystem format of cache partition'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE`: 缓存分区的文件系统格式'
- en: '`BOARD_FLASH_BLOCK_SIZE`: The block size of the flash device'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOARD_FLASH_BLOCK_SIZE`: 闪存设备的块大小'
- en: Building and testing x86emu
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试 x86emu
- en: Once we have the source code, we can start to build and test our x86emu device
    in this section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了源代码，我们就可以在本节中开始构建和测试我们的 x86emu 设备。
- en: Building x86emu
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 x86emu
- en: 'Before we start to build x86emu, let''s have a quick look at the Android build
    system first. The major difference between the Android build system from other
    make-based build systems is that the Android build system doesn''t rely on recursive
    Makefiles. Android Makefiles end in the extension `.mk`; the main Makefile for
    a particular source directory is named `Android.mk`. The build system imports
    all `Android.mk` from various folders to create one large Makefile to start the
    build, as we can see from the following code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建 x86emu 之前，让我们先快速了解一下 Android 构建系统。与其他基于 make 的构建系统相比，Android 构建系统不依赖于递归的
    Makefiles。Android Makefiles 以 `.mk` 扩展名结尾；特定源目录的主要 Makefile 被命名为 `Android.mk`。构建系统从各个文件夹导入所有
    `Android.mk` 以创建一个大的 Makefile 来启动构建，正如我们可以在以下代码片段中看到的那样：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we start the build, we must set up the build environment first. The
    Android build system provides a `build/envsetup.sh` script for the build environment
    setup. We can set up the build environment by running the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建之前，我们必须首先设置构建环境。Android 构建系统提供了一个 `build/envsetup.sh` 脚本来设置构建环境。我们可以通过运行以下命令来设置构建环境：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After this, we need to specify the target that we want to build. In Android
    build system terms, this is called a lunch-combo. We can specify a lunch-combo
    directly:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要指定我们想要构建的目标。在 Android 构建系统的术语中，这被称为 lunch-combo。我们可以直接指定一个 lunch-combo：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or select it from a list in a menu:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从菜单中选择它：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We learnt this in [Chapter 2](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml), *Setting
    Up the Development Environment*, when we built the Android emulator image. You
    may notice that the difference here in the menu items is that the menu includes
    the device configurations added by us in this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 2 章](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml)中学习了这一点，*设置开发环境*，当时我们构建了
    Android 模拟器镜像。你可能注意到这里菜单项的差异在于，菜单包括了我们在本章中添加的设备配置。
- en: 'The lunch-combo that we select here is `x86emu_x86-eng`. We can start to build
    the target now using the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里选择的 lunch-combo 是 `x86emu_x86-eng`。现在我们可以使用以下命令开始构建目标：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-j4` option is used to specify the number of concurrent make sessions.
    It is related to the number of CPU cores that you have on your system, for example,
    you may choose `-j8` in a more powerful hardware platform. The `m` command is
    available after we execute `source build/envsetup.sh`. It is equivalent to `croot;
    make -j4`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`-j4` 选项用于指定并发 make 会话的数量。它与你的系统上的 CPU 核心数相关，例如，在一个更强大的硬件平台上，你可能选择 `-j8`。在执行
    `source build/envsetup.sh` 后，`m` 命令是可用的。它等同于 `croot; make -j4`。'
- en: 'If you want to see the actual commands in the build, you can use the `showcommands`
    option on the command line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在构建中看到实际的命令，你可以在命令行上使用 `showcommands` 选项：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You may use other frequently used build targets. Here is a list of them that
    you may refer to in your build:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其他常用的构建目标。以下是一些您可以在构建中参考的目标列表：
- en: '`make sdk`: Build the tools that are part of an SDK (`adb`, `fastboot`, and
    so on).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make sdk`: 构建 SDK 中的工具（如 `adb`、`fastboot` 等）。'
- en: '`make snod`: Build the system image from the current software binaries.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make snod`: 从当前软件二进制文件构建系统镜像。'
- en: '`make all`: Make everything, whether it is included in the product definition
    or not.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make all`: 构建所有内容，无论是否包含在产品定义中。'
- en: '`make clean`: Remove all built files (prepare for a new build). It is the same
    as `rm -rf out/<configuration>/`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make clean`: 删除所有构建文件（为新构建做准备）。它与 `rm -rf out/<configuration>/` 相同。'
- en: '`make modules`: Shows a list of submodules that can be built (a list of all
    `LOCAL_MODULE` definitions).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make modules`: 显示可以构建的子模块列表（所有 `LOCAL_MODULE` 定义列表）。'
- en: '`make <local_module>`: Make a specific module (note that this is not the same
    as the directory name. It is the `LOCAL_MODULE` definition in the `Android.mk`
    file).'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make <local_module>`: 构建特定模块（请注意，这与目录名不同。这是`Android.mk`文件中的`LOCAL_MODULE`定义）。'
- en: '`make clean-<local_module>`: Clean a specific module.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make clean-<local_module>`: 清理特定模块。'
- en: '`make bootimage TARGET_PREBUILT_KERNEL=/path/to/bzImage`: Create a new boot
    image with custom `bzImage`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make bootimage TARGET_PREBUILT_KERNEL=/path/to/bzImage`: 使用自定义 `bzImage` 创建新的引导镜像。'
- en: '`make recoveryimage`: Make the recovery in `bootable/recovery/`.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make recoveryimage`: 在 `bootable/recovery/` 中构建恢复。'
- en: 'Besides the build targets, there are some helper macros and functions that
    are installed when you source `envsetup.sh`. You can find out what they are by
    using the `hmm` command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建目标之外，还有一些辅助宏和函数在您源码 `envsetup.sh` 时被安装。您可以通过使用 `hmm` 命令来找出它们：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After we build the target successfully, we can find the images at `out/target/product/x86emu`
    in our case. We can also use the environment variable `$OUT` as follows to list
    the build output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们成功构建目标之后，我们可以在我们的案例中找到图像在 `out/target/product/x86emu`。我们还可以使用环境变量 `$OUT`
    如下列出构建输出：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Testing x86emu
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 x86emu
- en: 'To test x86emu, we can use the AVD `a25x86` that we created in [Chapter 2](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml),
    *Setting Up the Development Environment*. To use our own system images, we can
    create a shell script `~/bin/test-ch04.sh` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 x86emu，我们可以使用在 [第 2 章](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml) “设置开发环境”中创建的
    AVD `a25x86`。要使用我们自己的系统镜像，我们可以创建一个 shell 脚本 `~/bin/test-ch04.sh`，如下所示：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can see from the preceding shell script that the images for x86emu are
    used to start the AVD `a25x86`. You need to set your Android SDK path so you can
    use the emulator from Android SDK:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的 shell 脚本中看到，用于启动 AVD `a25x86` 的 x86emu 图像。您需要设置您的 Android SDK 路径，以便您可以从
    Android SDK 使用模拟器：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After you start the emulator, you can go to Settings | About phone to check
    the build information, as shown in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在您启动模拟器后，您可以转到设置 | 关于手机来检查构建信息，如下面的截图所示：
- en: '![](img/6099_04_01.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6099_04_01.png)'
- en: x86emu build information
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: x86emu 构建信息
- en: We can see from About phone that Model is x86emu_android-7.1.1_r4_ch04, which
    we specified in the product definition Makefile `x86emu_x86.mk`. Kernel version
    is 3.10.0 and Build number is the build target x86emu_x86-eng.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从“关于手机”中看到模型是 x86emu_android-7.1.1_r4_ch04，这是我们指定在产品定义 Makefile `x86emu_x86.mk`
    中的。内核版本是 3.10.0，构建号是构建目标 x86emu_x86-eng。
- en: If you want to test the images in this chapter without setting up your own build,
    you can download the images from SourceForge at [https://sourceforge.net/projects/Android-system-programming/files/android-7/ch04/](https://sourceforge.net/projects/Android-system-programming/files/android-7/ch04/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试本章中的图像而不设置自己的构建，您可以从 SourceForge 下载图像，网址为 [https://sourceforge.net/projects/Android-system-programming/files/android-7/ch04/](https://sourceforge.net/projects/Android-system-programming/files/android-7/ch04/)。
- en: Integrating with Eclipse
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成到 Eclipse
- en: You may use an **Integrated Development Environment** (**IDE**) for your development
    work. It is possible to integrate the AOSP build environment and selected projects
    into your favorite IDE. Here, I will use Eclipse as an example to explain how
    to integrate our projects and AOSP build environment in Eclipse. Be aware that
    since AOSP can only be built in the Linux environment, this can only work for
    Linux as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**集成开发环境**（**IDE**）进行开发工作。可以将 AOSP 构建环境和选定的项目集成到您喜欢的 IDE 中。这里，我将使用 Eclipse
    作为示例来解释如何在 Eclipse 中集成我们的项目和 AOSP 构建环境。请注意，由于 AOSP 只能在 Linux 环境中构建，因此这只能适用于 Linux。
- en: Even though Android Studio is the default IDE for Android application development,
    I prefer Eclipse for Android system programming. With Eclipse, we can build both
    native and Java applications. We can also integrate AOSP builds in Eclipse projects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Android Studio 是 Android 应用程序开发的默认 IDE，但我更喜欢 Eclipse 用于 Android 系统编程。使用 Eclipse，我们可以构建本地和
    Java 应用程序。我们还可以在 Eclipse 项目中集成 AOSP 构建。
- en: To set up the Eclipse environment, you can use the latest Eclipse with ADT plugin
    or you can download an old ADT bundle from Google.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 Eclipse 环境，您可以使用带有 ADT 插件的最新 Eclipse 或从 Google 下载旧的 ADT 套件。
- en: 'For Linux x86 or x86_64:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux x86 或 x86_64：
- en: '[http://dl.google.com/Android/adt/adt-bundle-linux-x86_64-20140702.zip](http://dl.google.com/Android/adt/adt-bundle-linux-x86_64-20140702.zip)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://dl.google.com/Android/adt/adt-bundle-linux-x86_64-20140702.zip](http://dl.google.com/Android/adt/adt-bundle-linux-x86_64-20140702.zip)'
- en: '[http://dl.google.com/Android/adt/adt-bundle-linux-x86-20140702.zip](http://dl.google.com/Android/adt/adt-bundle-linux-x86-20140702.zip)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://dl.google.com/Android/adt/adt-bundle-linux-x86-20140702.zip](http://dl.google.com/Android/adt/adt-bundle-linux-x86-20140702.zip)'
- en: 'To use Eclipse, we need to create a Makefile for our x86emu device build as
    follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Eclipse，我们需要为我们的 x86emu 设备构建创建一个 Makefile，如下所示：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We need to define a few build targets that can be used in Eclipse. Let''s see
    how to import an x86emu device build into the Eclipse project. We will use Eclipse
    from the ADT bundle to explain the process. To integrate the AOSP build with Eclipse,
    we must launch Eclipse in the AOSP build environment. Let''s start Eclipse as
    follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一些可以在 Eclipse 中使用的构建目标。让我们看看如何将 x86emu 设备构建导入到 Eclipse 项目中。我们将使用 ADT 套件中的
    Eclipse 来解释这个过程。为了将 AOSP 构建与 Eclipse 集成，我们必须在 AOSP 构建环境中启动 Eclipse。让我们按照以下步骤启动
    Eclipse：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After we have installed the ADT bundle, we can find Eclipse in the preceding
    directory under the SDK installation path. After we launch Eclipse, select the
    C/C++ Perspective, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装了 ADT 套件后，我们可以在 SDK 安装路径下的上一个目录中找到 Eclipse。在启动 Eclipse 后，选择 C/C++ 视图，如下所示：
- en: '![](img/image_04_003.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_003.png)'
- en: Select the C/C++ perspective
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 C/C++ 视图
- en: 'We can import the x86emu directory as an existing Makefile project to Eclipse
    by selecting File | Import... | Existing Code as Makefile Project, as shown in
    the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择“文件 | 导入... | 将现有代码作为 Makefile 项目导入”，将 x86emu 目录作为现有 Makefile 项目导入到
    Eclipse 中，如下所示：
- en: '![](img/image_04_004.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_004.png)'
- en: Importing existing code as a Makefile project
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有代码作为 Makefile 项目导入
- en: 'Click on Next and navigate to the `$AOSP/device/generic/x86emu` folder to import
    the source code, as shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”，导航到 `$AOSP/device/generic/x86emu` 文件夹以导入源代码，如下所示：
- en: '![](img/image_04_005.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_005.png)'
- en: Import existing code
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 导入现有代码
- en: 'Once we import the project, we should be able to see that all files under the
    `x86emu` folder are shown on the right-hand side in Project Explorer, as we can
    see in the following screenshot. Then we can click the right mouse button to see
    the menu list for the project and select Make Targets | Create... | Create Make
    Target. We can add the build target that we defined in the Makefile in the Target
    name field. If we define the default build target `all`, the default build in
    Eclipse will trigger the build target `all` in our `Makefile`. This is what we
    defined for build target `all`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入项目，我们应该能够在项目资源管理器中看到 `x86emu` 文件夹下的所有文件都显示在右侧，正如我们在以下屏幕截图中所见。然后我们可以点击鼠标右键以查看项目的菜单列表，并选择“Make
    Targets | Create... | Create Make Target”。我们可以在目标名称字段中添加我们在 Makefile 中定义的构建目标。如果我们定义默认的构建目标
    `all`，Eclipse 中的默认构建将触发我们的 `Makefile` 中的构建目标 `all`。这是我们为构建目标 `all` 定义的：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What we do here is launch the AOSP build at the AOSP root directory. We also
    generate a log file for the build using a naming convention, `x86emu-{$DATE}.txt`,
    and you can find this log file at the AOSP root folder after the build is completed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是在 AOSP 根目录启动 AOSP 构建。我们还使用命名约定 `x86emu-{$DATE}.txt` 为构建生成一个日志文件，构建完成后，您可以在
    AOSP 根目录中找到这个日志文件。
- en: '![](img/image_04_006.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_006.png)'
- en: Creating a Make Target in Eclipse
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 中创建 Make Target
- en: After we create all build targets, we can build AOSP from Eclipse by selecting
    Project | Build All or use the shortcut *Ctrl* + *B* to launch the build.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建所有构建目标后，我们可以通过选择“项目 | 构建所有”或使用快捷键 *Ctrl* + *B* 来启动构建，从 Eclipse 中构建 AOSP。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt how to create a new device based on the Android emulator
    build for Intel x86 architecture. We explained the different build layers in the
    AOSP built system and how these build layers associate with Makefiles for a device.
    After that, we build and tested the new x86emu device. Finally, to improve the
    efficiency of development work, we integrated the AOSP build in Eclipse. In the
    next chapter, we will extend Android emulator to support ARM binary translation
    using the x86emu device.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何基于为Intel x86架构构建的Android模拟器创建一个新设备。我们解释了AOSP构建系统中的不同构建层以及这些构建层如何与设备的Makefiles关联。之后，我们构建并测试了新的x86emu设备。最后，为了提高开发工作的效率，我们将AOSP构建集成到了Eclipse中。在下一章中，我们将扩展Android模拟器以支持使用x86emu设备进行ARM二进制翻译。
