["```kt\nclass ViewModelFactory(private val repository: Repository)\n :ViewModelProvider.NewInstanceFactory() {\n  override fun <T : ViewModel?> create(modelClass:\n Class<T>): T =\n    if (modelClass.isAssignableFrom\n     (TemperatureViewModel::class.java))\n      TemperatureViewModel(repository) as T\n    else\n      DistancesViewModel(repository) as T\n}\n```", "```kt\nmodelClass.isAssignableFrom\n (TemperatureViewModel::class.java)\n```", "```kt\nclass Repository(context: Context) {\n    private val prefs =\n        PreferenceManager.getDefaultSharedPreferences(context)\n    fun getInt(key: String, default: Int) = \n        prefs.getInt(key, default)\n    fun putInt(key: String, value: Int) {\n        prefs.edit().putInt(key, value).apply()\n    }\n    fun getString(key: String, \n        default: String) = prefs.getString(key, default)\n    fun putString(key: String, value: String) {\n        prefs.edit().putString(key, value).apply()\n    }\n}\n```", "```kt\nclass ComposeUnitConverterActivity : ComponentActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    val factory =\n      ViewModelFactory(Repository(applicationContext))\n    setContent {\n      ComposeUnitConverter(factory)\n    }\n  }\n}\n```", "```kt\ncomposable(ComposeUnitConverterScreen.route_temperature) {\n  TemperatureConverter(\n    viewModel = viewModel(factory = factory)\n  )\n}\n```", "```kt\nclass TemperatureViewModel(private val repository:\n Repository): ViewModel() {\n  ...\n  private val _temperature: MutableLiveData<String>\n             = MutableLiveData(\n                repository.getString(\"temperature\", \"\")\n  )\n  val temperature: LiveData<String>\n    get() = _temperature\n  fun getTemperatureAsFloat(): Float\n          = (_temperature.value ?: \"\").let {\n    return try {\n      it.toFloat()\n    } catch (e: NumberFormatException) {\n      Float.NaN\n    }\n  }\n  fun setTemperature(value: String) {\n    _temperature.value = value\n    repository.putString(\"temperature\", value)\n  }\n  fun convert() = getTemperatureAsFloat().let {\n    if (!it.isNaN())\n      if (_scale.value == R.string.celsius)\n        (it * 1.8F) + 32F\n      else\n        (it - 32F) / 1.8F\n    else\n      Float.NaN\n  }\n}\n```", "```kt\n@Composable\nfun TemperatureConverter(viewModel: TemperatureViewModel) {\n  …\n  val currentValue = viewModel.temperature.observeAsState(\n                        viewModel.temperature.value ?: \"\")\n  val scale = viewModel.scale.observeAsState(\n                 viewModel.scale.value ?: R.string.celsius)\n  var result by remember { mutableStateOf(\"\") }\n  val calc = {\n    val temp = viewModel.convert()\n    result = if (temp.isNaN())\n      \"\"\n    else\n      \"$temp${\n        if (scale.value == R.string.celsius)\n          strFahrenheit\n        else strCelsius\n      }\"\n  }\n  …\n  Column(\n    …\n  ) {\n    TemperatureTextField(\n      temperature = currentValue,\n      modifier = Modifier.padding(bottom = 16.dp),\n      callback = calc,\n      viewModel = viewModel\n    )\n    …\n    Button(\n      onClick = calc,\n      …\n    if (result.isNotEmpty()) {\n      Text(\n        text = result,\n        style = MaterialTheme.typography.h3\n      )\n    }\n    …\n```", "```kt\n@Composable\nfun TemperatureTextField(\n  temperature: State<String>,\n  modifier: Modifier = Modifier,\n  callback: () -> Unit,\n  viewModel: TemperatureViewModel\n) {\n  TextField(\n    value = temperature.value,\n    onValueChange = {\n      viewModel.setTemperature(it)\n    },\n    …\n```", "```kt\n_temperature.value = value\n```", "```kt\nprivate val _convertedDistance: MutableLiveData<Float>\n                = MutableLiveData(Float.NaN)\nval convertedDistance: LiveData<Float>\n  get() = _convertedDistance\nfun convert() {\n  getDistanceAsFloat().let {\n    viewModelScope.launch {\n      _convertedDistance.value = if (!it.isNaN())\n        if (_unit.value == R.string.meter)\n          it * 0.00062137F\n        else\n          it / 0.00062137F\n      else\n        Float.NaN\n    }\n  }\n}\n```", "```kt\nval convertedValue by\n        viewModel.convertedDistance.observeAsState()\nval result by remember(convertedValue) {\n  mutableStateOf(\n    if (convertedValue?.isNaN() != false)\n      \"\"\n    else\n      \"$convertedValue ${\n        if (unit.value == R.string.meter)\n          strMile\n        else strMeter\n      }\"\n  )\n}\nval calc = {\n  viewModel.convert()\n}\n```", "```kt\n@Composable\nfun LaunchedEffectDemo() {\n   var clickCount by rememberSaveable { mutableStateOf(0) }\n   var counter by rememberSaveable { mutableStateOf(0) }\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Row {\n            Button(onClick = {\n                clickCount += 1\n            }) {\n                Text(\n                    text = if (clickCount == 0)\n                      stringResource(id = R.string.start)\n                    else\n                      stringResource(id = R.string.restart)\n                )\n            }\n            Spacer(modifier = Modifier.width(8.dp))\n            Button(enabled = clickCount > 0,\n                onClick = {\n                    clickCount = 0\n                }) {\n                Text(text = stringResource(id =\n                              R.string.stop))\n            }\n            if (clickCount > 0) {\n                LaunchedEffect(clickCount) {\n                    counter = 0\n                    while (isActive) {\n                        counter += 1\n                        delay(1000)\n                    }\n                }\n            }\n        }\n        Text(\n            text = \"$counter\",\n            style = MaterialTheme.typography.h3\n        )\n    }\n}\n```", "```kt\nDisposableEffect(clickCount) {\n  println(\"init: clickCount is $clickCount\")\n  onDispose {\n    println(\"dispose: clickCount is $clickCount\")\n  }\n}\n```"]