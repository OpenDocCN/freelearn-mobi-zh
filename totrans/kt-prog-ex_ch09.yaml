- en: Creating the Place Reviewer Backend with Spring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring创建地点评论者后端
- en: We focused on the utilization of Kotlin in the development of applications for
    the Android platform in the previous four chapters. The chapter we just concluded
    covered, extensively, the various activities involved in securing and deploying
    an Android application. We took a look at some best practices—in relation to security—when
    working with data storage as well as when communicating over a network. In addition,
    we discussed the necessary security considerations when handling user inputs and
    working with user credentials.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前四章中，我们专注于在Android平台应用程序开发中使用Kotlin。我们刚刚结束的章节广泛地涵盖了确保和部署Android应用程序所涉及的各种活动。我们探讨了在处理数据存储以及通过网络通信时的最佳实践——与安全相关。此外，我们还讨论了处理用户输入和与用户凭证工作时必要的考虑因素。
- en: 'Furthermore, we looked at various ways of securing some Android application
    components—such as services and broadcast receivers. Lastly, we took a step-by-step
    approach to properly deploying an Android application to the Google Play Store.
    In this chapter, we will have an in-depth look at how Kotlin can be used to develop
    web-based solutions – specifically with Spring—by developing the Place Reviewer
    application. This chapter will focus on the development of the backend of the
    Place Reviewer application, and the following chapter will focus on its frontend.
    In the course of reading through this chapter, you will learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了确保某些Android应用程序组件（如服务和广播接收器）的各种方法。最后，我们采取了一种逐步的方法，以正确地将Android应用程序部署到Google
    Play Store。在本章中，我们将深入探讨如何使用Kotlin开发基于Web的解决方案——特别是通过Spring——通过开发地点评论者应用程序。本章将专注于地点评论者应用程序后端的发展，下一章将专注于其前端。在阅读本章的过程中，你将了解：
- en: The Model-View-Controller design pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器设计模式
- en: Logstash and its use in centralizing, transforming, and stashing data.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logstash及其在集中、转换和存储数据中的应用。
- en: Securing a website with Spring Security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security保护网站
- en: Let's dive right in to what we have to learn by first taking a look at the Model-View-Controller
    design pattern.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接深入了解我们需要学习的内容，首先看看模型-视图-控制器设计模式。
- en: The MVC design pattern
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC设计模式
- en: The MVC pattern, also known as the Model-View-Controller pattern, is an application
    design pattern that is used primarily for the separation of concerns within modern
    applications. More specifically, it is a design pattern for user interfaces that
    divides an application, primarily, into three distinct components. This separation
    of application modules into distinct parts is done for several reasons. One such
    reason is to isolate presentation logic from core business logic. Let us take
    a look at these three application components in the MVC pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式，也称为模型-视图-控制器模式，是一种主要用于现代应用程序中关注点分离的应用程序设计模式。更具体地说，它是一种用户界面设计模式，将应用程序主要分为三个不同的组件。这种将应用程序模块分离成不同部分的做法有多个原因。其中一个原因是将表示逻辑从核心业务逻辑中隔离出来。让我们看看MVC模式中的这三个应用程序组件。
- en: The model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: The model is the component that is in charge of the management of data and logic
    of an MVC application. As the model is the principal manager of all data and business
    logic, you can view it as the powerhouse of an MVC application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是负责MVC应用程序数据管理和逻辑的组件。由于模型是所有数据和业务逻辑的主要管理者，你可以将其视为MVC应用程序的动力源。
- en: The view
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: This is a visual representation of data that exists in and is generated by an
    application. It is the primary point of interaction that a user has with the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序中存在并由应用程序生成的数据的视觉表示。它是用户与应用程序交互的主要点。
- en: The controller
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: 'The controller is an intermediary actor between the view and the model. It
    is in charge of retrieving input – primarily from the view – and feeding an appropriately
    transformed form of the input to the model. It is also in charge of updating the
    view with data whenever the need arises:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是视图和模型之间的中介角色。它负责检索输入——主要来自视图——并将适当转换的输入形式传递给模型。它还负责在需要时更新视图中的数据：
- en: '![](img/f0cb4510-efd7-4531-8033-7b356807db73.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0cb4510-efd7-4531-8033-7b356807db73.jpg)'
- en: Designing and implementing the Place Reviewer backend
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和实现地点评论者后端
- en: Since we have previously had hands-on experience with the process of designing
    a system, in this chapter, we are going to focus less on the processes involved
    in the designing of the Place Reviewer system. Instead, we are going to make a
    number of quick use case specifications for the system, identify the necessary
    entities that will be required for the implementation of our system's database,
    and delve right into the development of the system. Let us go ahead and state
    our use cases for the Place Reviewer system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前已经有过设计系统流程的实践经验，在本章中，我们将减少对Place Reviewer系统设计过程中涉及的流程的关注。相反，我们将为系统制定一些快速的使用案例规范，确定实现我们系统数据库所需的基本实体，并直接进入系统开发。让我们继续并陈述Place
    Reviewer系统的使用案例。
- en: Use case identification
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用案例识别
- en: As we did earlier on in this book, we shall commence our use case specification
    procedure by firstly identifying the actors of the system. Before we can identify
    the actors of the system, we must have a thorough understanding of what the Place
    Reviewer web application can do.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书早期所做的那样，我们将首先识别系统的参与者来开始我们的用例规范程序。在我们能够识别系统的参与者之前，我们必须彻底了解Place Reviewer网络应用程序能做什么。
- en: As you may have figured out already, the Place Reviewer web application is an
    internet-based application that facilitates the frictionless creation of location
    reviews by users of the platform. Once a user has been registered, he/she is able
    to utilize the platform to create an opinionated review (a review based on personal
    experiences) of any location in the world. The user will be able to select the
    location that he/she wants to review with the help of a map.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经推测出的那样，Place Reviewer网络应用程序是一个基于互联网的应用程序，它为平台用户提供了无缝创建位置评价的便利。一旦用户注册，他/她就能利用该平台对世界上任何地点发表基于个人经验的评价性评论。用户将能够借助地图选择他/她想要评价的位置。
- en: 'Now that we understand what the Place Reviewer application can do, we can go
    ahead and identify the actors in the Place Reviewer system. As you will have surmised
    by this time, the implementation of the Place Reviewer application we are going
    to make only has one actor—the user. The use cases of the user are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Place Reviewer应用程序能做什么，我们可以继续并识别Place Reviewer系统中的参与者。如您此时所推测的，我们将要实施的Place
    Reviewer应用程序只有一个参与者——用户。用户的使用案例如下：
- en: The user uses the Place Reviewer application to create location reviews
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用Place Reviewer应用程序来创建位置评价
- en: The user uses the Place Reviewer application to view reviews that were created
    by other users
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用Place Reviewer应用程序查看其他用户创建的评价
- en: The user can view the exact location that was reviewed, by another user, on
    an interactive map
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在交互式地图上查看其他用户评价的确切位置
- en: The user can register on the Place Reviewer platform
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在Place Reviewer平台上注册
- en: The user can logout from his/her Place Reviewer account
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以从他的/她的Place Reviewer账户注销
- en: We have made suitable progress thus far. We have been able to state unequivocally
    what the Place Reviewer system does, identify the actors of the system, and clearly
    state the use cases of the system by its sole actor - the user. Let us go a step
    further by identifying the data that the system will need to cater for.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经取得了适当的进展。我们能够明确地说明Place Reviewer系统的作用，识别系统的参与者，并且清楚地陈述系统的使用案例，这些使用案例仅由唯一的参与者——用户——提出。让我们再进一步，确定系统需要处理的数据。
- en: Identifying data
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别数据
- en: As a consequence of our previous use case definitions, we can easily identify
    the type of data that the Place Reviewer application must cater for—by the creation
    of appropriate models. The first type of data is the user data and the second
    type is the review data. The user data, as the name implies, is the data relating
    to a user registered on the platform, whereas the review data is the necessary
    data for every review created on the platform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前的用例定义，我们可以轻松地识别Place Reviewer应用程序必须处理的数据类型——通过创建适当的模型。第一种类型的数据是用户数据，第二种类型是评价数据。用户数据，正如其名所示，是与平台上注册的用户相关的数据，而评价数据是平台上创建的每个评价所需的数据。
- en: 'We will require the following data for the user: the user''s email address,
    username, password, and account status. In addition, we will need a unique identifier
    for each user of the platform—a user ID—and the date on which the user was registered.
    With respect to the data necessary for reviews, we will need a review title, its
    body the content of the review, the address of the place reviewed, the name of
    the place reviewed, positional information of the place reviewed (its longitudinal
    and latitudinal coordinates), and a place ID to specifically identify the place
    being reviewed. In addition, a unique identifier will be required for the review
    being created as well as information relating to the time the review was created.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下用户数据：用户的电子邮件地址、用户名、密码和账户状态。此外，我们还需要为平台上的每个用户提供一个唯一的标识符——用户ID，以及用户注册的日期。至于评论所需的数据，我们需要评论标题、评论正文（评论内容）、被评论地点的地址、被评论地点的名称、被评论地点的位置信息（经纬度坐标），以及一个用于特定识别被评论地点的地点ID。此外，还需要为创建的评论提供一个唯一的标识符，以及与评论创建时间相关的信息。
- en: 'At this juncture, you might be thinking: hold on, why do we have information
    pertaining to a place (a place name, place address, place ID, and longitude and
    latitude) coupled with the information of a review? Why don''t we separate this
    information and consider it a distinct type of data we will be catering for? If
    you thought this, you are right, that will be a great approach to doing things
    if we, say, had a database table that possessed all the information of all the
    places we wanted to be reviewable on the platform. Sadly, we do not have any such
    table.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个关键时刻，你可能正在想：等等，为什么我们有关于一个地方（地点名称、地址、ID以及经纬度）的信息，还要加上评论信息？我们为什么不把这些信息分开，将其视为我们将会提供的一种独立类型的数据呢？如果你这样想过，那么你是正确的，如果我们有一个数据库表，其中包含了我们希望在平台上可评论的所有地点的所有信息，那么这样的方法将是非常好的。遗憾的是，我们没有这样的表。
- en: 'Now, you may be wondering: how can we provide a user with the ability to review
    places of which we have no information about? The answer is simple. We utilize
    Google''s Places API. We shall take a look at how to do this in the next chapter,
    but for now, hold on tight as we begin implementing the Place Reviewer backend.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道：我们如何让用户评论那些我们没有信息的地方？答案是简单的。我们利用Google的Places API。我们将在下一章中查看如何实现这一点，但现在，请紧随其后，因为我们开始实现Place
    Reviewer后端。
- en: Setting up the database
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: 'As it is necessary for our system to store information, we need to set up a
    database for our application to persist data in. As we utilized Postgres as our
    primary datastore in a previous application we developed, we will utilize it as
    our primary datastore. We have already covered how to set up Postgres on various
    systems and as such we will not bother covering that here. Let us go ahead and
    create our database. Open your Terminal and run the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的系统需要存储信息，我们需要为应用程序设置一个数据库以持久化数据。由于我们在之前开发的应用程序中使用了Postgres作为主要的数据存储，我们将继续使用它作为我们的主要数据存储。我们已经介绍了如何在各种系统上设置Postgres，因此我们在这里不再赘述。让我们继续创建我们的数据库。打开你的终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you run the command, a database named` place-reviewer` will be created
    on your system. The username you input in place of the `<username>` argument will
    be the username that you will use to connect to the database. Having set up the
    database for our application, we can go ahead with the implementation of the backend.
    We will be utilizing Spring Framework in the implementation of the backend.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了命令，系统上就会创建一个名为`place-reviewer`的数据库。你输入的用于替换`<username>`参数的用户名将是用来连接数据库的用户名。在为我们的应用程序设置了数据库之后，我们可以继续进行后端实现。我们将利用Spring框架来实现后端。
- en: Implementing the backend
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现后端
- en: 'Having established a sense of direction by specifying the various use cases
    of our application and setting up a database for our application to connect to,
    let us go straight ahead with its implementation. Open IntelliJ IDEA and create
    a new project with the Spring initializer. Upon clicking Next, IntelliJ will retrieve
    the Spring initializer, after which you will be asked to provide certain details
    for the application. Do the following before proceeding to the next stage of the
    setup:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定我们应用程序的各种用例并设置数据库连接，我们已经确立了一个方向感。现在，让我们直接进入其实施阶段。打开 IntelliJ IDEA 并使用 Spring
    initializer 创建一个新项目。点击下一步后，IntelliJ 将检索 Spring initializer，之后你将需要提供一些应用程序的详细信息。在进入下一阶段设置之前，请执行以下操作：
- en: Input `com.example` as the group ID.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `com.example` 作为组 ID。
- en: Enter `place-reviewer` as the artifact ID.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `place-reviewer` 作为工件 ID。
- en: Select Maven Project as the project type if it is not already selected.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选择，请选择 Maven 项目作为项目类型。
- en: Leave the packaging option and Java version the way they are.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持打包选项和 Java 版本不变。
- en: Select Kotlin as the language. This is important, as we are further learning
    the Kotlin language, after all.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Kotlin 作为语言。这很重要，因为毕竟我们正在进一步学习 Kotlin 语言。
- en: Change the version attribute to 1.0.0.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将版本属性更改为 1.0.0。
- en: Enter a description of your choice. Ours is `A nifty web application for the
    creation of location reviews`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你选择的描述。我们的描述是 `一个用于创建位置评论的便捷网络应用程序`。
- en: Input `com.example.placereviewer` as the package name.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `com.example.placereviewer` 作为包名。
- en: After filling in the required project information, proceed to the next screen
    by clicking Next. We are required to select the dependencies of our project in
    the screen displayed to us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写完所需的项目信息后，通过点击下一步进入下一屏幕。在这个屏幕上，我们需要选择我们项目的依赖项。
- en: The Spring initializer comes with the Spring plugin, which, at the time of writing,
    is only available on the IntelliJ IDEA Ultimate Edition, which requires a paid
    license. If you have the IntelliJ IDEA Community Edition installed, you can still
    develop this application. Simply generate the project using the Spring initializer
    utility at [https://start.spring.io](https://start.spring.io) and import the project
    into IntelliJ IDEA.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Spring initializer 随带 Spring 插件，截至编写本文时，该插件仅在 IntelliJ IDEA Ultimate Edition
    中可用，需要付费许可证。如果你已经安装了 IntelliJ IDEA Community Edition，你仍然可以开发这个应用程序。只需使用 Spring
    initializer 工具在 [https://start.spring.io](https://start.spring.io) 生成项目，并将其导入
    IntelliJ IDEA。
- en: 'Select the Spring Security, Session, Cache, and Web dependencies. In addition,
    select Thymeleaf from the template engine category. Under the SQL category, select
    PostgreSQL. In addition, in the Spring Boot Version selection dropdown menu at
    the top of the screen, select 2.0.0 M7 as the version. Upon selecting the necessary
    dependencies, the content should be similar to that in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Spring Security、Session、Cache 和 Web 依赖项。此外，从模板引擎类别中选择 Thymeleaf。在 SQL 类别下，选择
    PostgreSQL。此外，在屏幕顶部的 Spring Boot 版本选择下拉菜单中，选择 2.0.0 M7 作为版本。在选择必要的依赖项后，内容应类似于以下截图：
- en: '![](img/8bbc6e06-37a8-4ba8-a194-065e6632d774.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8bbc6e06-37a8-4ba8-a194-065e6632d774.jpg)'
- en: 'After asserting that you have selected the appropriate dependencies, click
    Next to continue to the final setup screen. Here, you are required to provide
    a project name and a project location. Fill in `place-reviewer` as the project
    name and select the location in which you want the project to be saved on your
    computer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认你已选择适当的依赖项后，点击下一步继续到最后一个设置屏幕。在这里，你需要提供一个项目名称和项目位置。将项目名称填写为 `place-reviewer`
    并选择你想要在计算机上保存项目位置：
- en: '![](img/5bda2de8-4973-411a-8eb7-caabb200993a.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bda2de8-4973-411a-8eb7-caabb200993a.jpg)'
- en: 'Once this has been done, select Finish and wait for the project to be set up.
    You will be taken to a new IDE window containing the initial project files. We
    need not give any introductions to the structure of a Spring project, as we have
    already worked with one in previous chapters. Before we go further, add the following
    dependencies to the project''s `pom` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，选择完成并等待项目设置完成。你将被带到一个新的 IDE 窗口，其中包含初始项目文件。我们不需要对 Spring 项目的结构进行介绍，因为我们已经在之前的章节中与之合作过。在继续之前，将以下依赖项添加到项目的
    `pom` 文件中：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's get on with connecting our application to our database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续将我们的应用程序连接到我们的数据库。
- en: Connecting the backend to Postgres
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将后端连接到 Postgres
- en: 'To connect the Place Reviewer backend to the PostgreSQL database we created
    for it, we must modify our project''s `application.properties` file to contain
    the necessary properties that are needed to facilitate a database connection with
    PostgreSQL. Open the project''s `application.properties` file and add the following
    properties to it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Place Reviewer 后端连接到我们为其创建的 PostgreSQL 数据库，我们必须修改项目的 `application.properties`
    文件，使其包含建立与 PostgreSQL 数据库连接所需的必要属性。打开项目的 `application.properties` 文件，并添加以下属性：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Insert an appropriate username where the `<username>` property is within the
    preceding code snippet. Having added the appropriate database connection properties,
    Spring Boot will be able to connect to the specified database upon the application
    start. Having set up the appropriate database connection properties for our project,
    let us create models for the `User` and `Review` entities we earlier identified.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个代码片段中 `<username>` 属性所在的位置插入一个合适的用户名。添加了适当的数据库连接属性后，Spring Boot 将能够在应用程序启动时连接到指定的数据库。为我们的项目设置了适当的数据库连接属性后，让我们为之前确定的
    `User` 和 `Review` 实体创建模型。
- en: Creating models
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'We previously identified two distinct types of entities that must be catered
    for in our system: the `User` entity and the `Review` entity. It is time to create
    appropriate models for these entities. The first of these entities we will concern
    ourselves with is the User. Create a `data` package within the `com.example.placereviewer`
    package. Add a `model` package within the newly created `data` package. Now, add
    a `User.kt` file within the newly created `com.example.placereviewer.data.model`
    package with the following content:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前确定了两种必须在我们的系统中考虑的实体类型：`User` 实体和 `Review` 实体。是时候为这些实体创建适当的模型了。我们将首先关注的是用户实体。在
    `com.example.placereviewer` 包内创建一个名为 `data` 的包。在新建的 `data` 包内添加一个名为 `model` 的包。现在，在新建的
    `com.example.placereviewer.data.model` 包内添加一个名为 `User.kt` 的文件，并包含以下内容：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We don''t need spend time explaining much of what is going on in the preceding
    code snippet as we have prior experience with the creation of entities in Spring.
    In the preceding snippet, we defined a `User` entity with email, `username`, `password`,
    `accountStatus`, `Id`, and `createdAt` properties as its attributes. In addition,
    we specified that a User has many Review entities. We also specified an entity
    listener for the entity with the `@EntityListener` annotation. We have created
    neither a `Review` entity nor a `UserListener` for the `User` entity. As we are
    still focused on the `User` entity, let us focus on creating its entity listener
    before concerning ourselves with the `Review` entity. Add a new `listener` package
    to `com.example.placereviewer` and add a `UserListener.kt` file to it containing
    the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前在 Spring 中有创建实体的经验，我们不需要花太多时间解释前一个代码片段中的内容。在前面的代码片段中，我们定义了一个具有电子邮件、`username`、`password`、`accountStatus`、`Id`
    和 `createdAt` 属性的 `User` 实体。此外，我们还指定了一个具有 `@EntityListener` 注解的实体监听器。我们尚未创建 `Review`
    实体或 `UserListener`。由于我们仍然专注于 `User` 实体，让我们在关注 `Review` 实体之前先创建其实体监听器。向 `com.example.placereviewer`
    添加一个新的 `listener` 包，并向其中添加一个包含以下代码的 `UserListener.kt` 文件：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`UserListener` has a single `hashPassword` function, which is invoked before
    persisting and before updating a `User` entity. The method has the single job
    of encoding the `password` property of a user into its bcrypt equivalent before
    persisting it in the database.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserListener` 有一个单一的 `hashPassword` 函数，该函数在持久化之前和更新 `User` 实体之前被调用。该方法的唯一任务是编码用户的
    `password` 属性为 bcrypt 等价物，然后在数据库中持久化之前保存它。'
- en: 'Having created the necessary listeners for the `User` entity, let us turn our
    attention to the definition of a `Review` entity. Create a `Review.kt` file in
    `com.example.placereviewer.data.models` with the following content:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了 `User` 实体的必要监听器之后，让我们将注意力转向 `Review` 实体的定义。在 `com.example.placereviewer.data.models`
    目录下创建一个名为 `Review.kt` 的文件，并包含以下内容：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As can be seen in the preceding code snippet, we created a `Review` data class
    with the following properties: `reviewer`, `title`, `body`, `placeAddress`, `placeName`,
    `placeId`, `latitude`, `longitude`, `id`, and `createdAt`. The reviewer property
    is of the type `User`. It references the creator of the review. Every review must
    be created by a user. In addition, many reviews are created by a single user.
    We use the `@ManyToOne` annotation to properly declare this relationship between
    the `Review` and `User` entities.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们创建了一个具有以下属性的 `Review` 数据类：`reviewer`、`title`、`body`、`placeAddress`、`placeName`、`placeId`、`latitude`、`longitude`、`id`
    和 `createdAt`。`reviewer` 属性的类型为 `User`。它引用了评论的创建者。每个评论都必须由用户创建。此外，许多评论都是由单个用户创建的。我们使用
    `@ManyToOne` 注解来正确声明 `Review` 和 `User` 实体之间的关系。
- en: Creating data repositories
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据仓库
- en: 'As we have now set up our necessary entities, we must create repositories which
    we will use to access data pertaining to our entities. Create a repositories package
    within the `com.example.placereviewer` package. We have two entities, and as such,
    we shall create two repositories (one to access data pertaining to each entity).
    The first of the repositories will be `UserRepository` and the second will be `ReviewRepository`.
    Create a `UserRepository` interface file within `com.example.placereviewer.data.repository`
    with the following content:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经设置了必要的实体，我们必须创建仓库，我们将使用这些仓库来访问与我们的实体相关的数据。在 `com.example.placereviewer`
    包中创建一个 `repositories` 包。我们有两个实体，因此我们将创建两个仓库（一个用于访问每个实体的数据）。第一个仓库将是 `UserRepository`，第二个将是
    `ReviewRepository`。在 `com.example.placereviewer.data.repository` 中创建一个 `UserRepository`
    接口文件，内容如下：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `findByUsername(String)` method retrieves a `User` from the database which
    has a username that corresponds to that passed as an argument to the function.
    The following is the `ReviewRepository` interface:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`findByUsername(String)` 方法从数据库中检索一个 `User` 对象，该对象的用户名与函数传入的参数相匹配。以下为 `ReviewRepository`
    接口：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Having set up our entities and repositories to query these entities, we can
    start work on implementing the core business logic of the Place Reviewer application
    in the form of services and service implementations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好我们的实体和仓库以查询这些实体之后，我们可以开始实施 Place Reviewer 应用程序的核心业务逻辑，以服务和实现服务的形式。
- en: Place Reviewer business logic implementation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Place Reviewer 业务逻辑实现
- en: As previously explained, in an application that adheres to the MVC design pattern,
    there are three primary components of consequence. These components are the model,
    view, and controller. The models are the components that are in charge of data
    management and the execution of business logic. In our Place Reviewer application,
    we are going to implement our models in the form of services that can be used
    across the backend. At this juncture, we need to create two fundamental services.
    The first to manage data pertaining to users of the application, and the second
    to manage review data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在遵循 MVC 设计模式的应用程序中，有三个主要组件至关重要。这些组件是模型、视图和控制器。模型是负责数据管理和执行业务逻辑的组件。在我们的
    Place Reviewer 应用程序中，我们将以可以在后端使用的服务形式实现我们的模型。在此阶段，我们需要创建两个基本服务。第一个用于管理与应用程序用户相关的数据，第二个用于管理评论数据。
- en: 'First, we must create a `UserService` interface that defines the behaviors
    that must be implemented by a valid `UserServiceImpl` class. We previously stated
    in our use cases for the Place Reviewer application that a user must be able to
    register (hence create an account) on the platform. As such, we must cater for
    this process in our model. Create a `service` package in the project''s root package.
    Now, add the `UserService` interface to it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个 `UserService` 接口，该接口定义了必须由有效的 `UserServiceImpl` 类实现的操作。我们之前在 Place
    Reviewer 应用程序的使用案例中提到，用户必须在平台上注册（因此创建账户）。因此，我们必须在我们的模型中考虑这个过程。在项目的根包中创建一个 `service`
    包。现在，将 `UserService` 接口添加到其中：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We declared one method that must be implemented by a valid `UserService`. This
    method is the `register (String, String, String)` method. `register()` takes three
    strings as arguments. The first is the username of the user to be registered,
    the second is a valid email address for the user, and the third is his/her password
    of choice. When invoked with appropriate arguments, `register()` attempts to register
    the user with his/her provided credentials and returns `true` if the user was
    registered successfully; otherwise, it returns `false`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个必须由有效 `UserService` 实现的方法。这个方法是 `register (String, String, String)` 方法。`register()`
    接收三个字符串参数。第一个是要注册用户的用户名，第二个是用户的有效电子邮件地址，第三个是用户选择的密码。当使用适当的参数调用时，`register()` 尝试使用提供的凭据注册用户，如果用户成功注册，则返回
    `true`；否则，返回 `false`。
- en: 'The following is the implementation of the preceding `UserService`. Add it
    to the `service` package:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面提到的 `UserService` 的实现。将其添加到 `service` 包中：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The workings of the `register()` function implemented by our `UserServiceImpl`
    class is straightforward. When valid username, email, and password arguments are
    passed to it, it creates a new object of the user - passing the appropriate arguments
    to its constructor. After the creation of an object of the user, the user is saved
    to the database with the following line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `UserServiceImpl` 类实现的 `register()` 函数的工作原理很简单。当传递有效的用户名、电子邮件和密码参数给它时，它创建一个新的用户对象——将其适当的参数传递给其构造函数。在创建用户对象之后，使用以下行将用户保存到数据库中：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`userRepository` is an instance of the `UserRepository` we created earlier.
    This instance is injected into the constructor of `UserServiceImpl` automatically
    by Spring Framework. Once the user has been saved to the database, the Boolean
    value `true` is returned.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`userRepository` 是我们之前创建的 `UserRepository` 的一个实例。这个实例通过 Spring 框架自动注入到 `UserServiceImpl`
    的构造函数中。一旦用户被保存到数据库中，就返回布尔值 `true`。'
- en: Up next is the implementation of a review service interface. Our review service
    must facilitate the creation of reviews and the listing of reviews that have been
    created by users of the platform. As a consequence of this requirement, we will
    mandate the implementation of the `createReview()` and `listReview()` methods
    in our user `service` interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实现一个评论服务接口。我们的评论服务必须便于创建评论和列出由平台用户创建的评论。由于这一要求，我们将强制在用户 `service` 接口中实现
    `createReview()` 和 `listReview()` 方法。
- en: 'Add the following `ReviewService` interface to the `service` package of the
    project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `ReviewService` 接口添加到项目的 `service` 包中：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the `ReviewServiceImpl` class for the service we have just
    created. Add it, as well as all the services we will create later on in this chapter,
    to `com.example.placereviewer.service`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们刚刚创建的服务对应的 `ReviewServiceImpl` 类。将其以及本章后面我们将创建的所有服务添加到 `com.example.placereviewer.service`：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`listReviews()` returns an iterable containing all the review data that has
    been stored within the application''s database. `createReview()`, on the other
    hand, takes a string whose value is the username of the user creating the review
    and an instance of Review containing the data for the review to be created. `createReview()`
    first retrieves the user with the specified username by invoking the `findByUsername()`
    method of `UserRepository`. This user retrieved is the creator of the review—hence,
    the reviewer.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`listReviews()` 返回一个包含存储在应用程序数据库中所有评论数据的可迭代对象。另一方面，`createReview()` 接收一个字符串，其值是创建评论的用户的用户名，以及一个包含要创建的评论数据的
    `Review` 实例。`createReview()` 首先通过调用 `UserRepository` 的 `findByUsername()` 方法检索指定用户名的用户。检索到的用户是评论的创建者——因此，是评论者。'
- en: If a null object is not returned by `UserRepository`, the user exists and as
    such, the retrieved user is assigned to the `reviewer` property of the review
    to be saved. After this assignment, the review is saved to the database and the
    function returns `true` – signifying that the process was successful. If no user
    with the username provided was found, `false` is returned by `createReview()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `UserRepository` 没有返回空对象，则表示用户存在，因此检索到的用户被分配给要保存的评论的 `reviewer` 属性。在此分配之后，评论被保存到数据库中，函数返回
    `true` ——表示过程成功。如果没有找到提供用户名的用户，`createReview()` 将返回 `false`。
- en: Having created appropriate models in the form of services, let us work on securing
    our Place Reviewer application. This is an important procedure as we do not want
    unauthorized individuals to be able to access our application resources.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在以服务的形式创建了适当的模型之后，让我们着手确保我们的位置审查员应用程序的安全。这是一个重要的程序，因为我们不希望未经授权的个人能够访问我们的应用程序资源。
- en: Securing the Place Reviewer backend
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保位置审查员后端
- en: Similar to how we went about securing the Messenger API in [Chapter 4](kt-prog-ex_ch04.html), *Designing
    and Implementing the Messenger Backend with Spring Boot 2.0*, we shall utilize
    Spring Security to secure the Place Reviewer backend. Regardless of the utilization
    of Spring Security here, there is a slight variation to the way we are going to
    go about securing our application. In [Chapter 4](kt-prog-ex_ch04.html), *Designing
    and Implementing the Messenger Backend with Spring Boot 2.0*, we configured Spring
    Security to rely explicitly on JSON web tokens for the authorization of client
    applications. This time, we will rely solely on the power of Spring Security.
    In doing so, we will not make use of any other technology, such as JSON web tokens.
    Without further ado, let us begin work on securing our backend.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在第 4 章[设计并实现 Spring Boot 2.0 的消息传递后端](kt-prog-ex_ch04.html)中确保消息传递 API 的方式类似，我们将利用
    Spring Security 来确保位置审查员后端的安全。尽管在这里我们使用了 Spring Security，但我们在确保应用程序安全的方式上略有不同。在第
    4 章[设计并实现 Spring Boot 2.0 的消息传递后端](kt-prog-ex_ch04.html)中，我们配置 Spring Security
    明确依赖于 JSON Web 令牌来授权客户端应用程序。这次，我们将仅依靠 Spring Security 的力量。这样做，我们将不使用任何其他技术，例如
    JSON Web 令牌。无需多言，让我们开始确保我们的后端安全。
- en: 'First and foremost, we must create a custom web security configuration for
    our application. This custom configuration will implement Spring Framework''s 
    `WebSecurityConfigurerAdapter`. Create a `config` package in `com.example.placereviewer`
    and add the following `WebSecurityConfig` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须为我们的应用程序创建一个自定义的 Web 安全配置。这个自定义配置将实现 Spring 框架的 `WebSecurityConfigurerAdapter`。在
    `com.example.placereviewer` 中创建一个 `config` 包，并添加以下 `WebSecurityConfig` 类：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we have explained earlier in this book, the `configure(HttpSecurity)` method
    of `WebSecurityConfig` has the task of configuring which HTTP URL paths are to
    be secured and which are not. With the `configure(HttpSecurity)` method, we have
    configured Spring Security to permit all HTTP  POST requests to `/users/registrations` and
    GET requests whose paths match the paths `/register`, `/css`, and `/webjars/**`.
    In addition, we have permitted all HTTP requests to a login page that can be accessed
    from the path `/login`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中之前解释的那样，`WebSecurityConfig` 的 `configure(HttpSecurity)` 方法负责配置哪些 HTTP
    URL 路径需要被保护，哪些不需要。通过 `configure(HttpSecurity)` 方法，我们已配置 Spring Security 允许所有到
    `/users/registrations` 的 HTTP POST 请求以及路径匹配 `/register`、`/css` 和 `/webjars/**`
    的 GET 请求。此外，我们还允许所有可以访问的登录页面的 HTTP 请求，该页面可通过路径 `/login` 访问。
- en: We added a success handler to the login action which utilizes the `redirectStrategy`
    property that we defined for our `WebSecurityConfig` class to redirect a client
    to the `/home` path upon successful login of a user. Lastly, we permitted all
    logout requests to our backend.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向登录操作添加了一个成功处理器，该处理器使用我们为 `WebSecurityConfig` 类定义的 `redirectStrategy` 属性，在用户成功登录后将客户端重定向到
    `/home` 路径。最后，我们允许所有退出请求到我们的后端。
- en: '`configure(AuthenticationManagerBuilder)` sets up the `UserDetailsService`
    in use and specifies a password encoder to be used. We made use of a `BcryptPasswordEncoder`
    in this case. As you may have noticed, we have created no implementation of `UserDetailsService`
    in our project. Let us do that now. Add `AppUserDetailsService` to the `com.example.placereviewer.service`
    package:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure(AuthenticationManagerBuilder)` 设置正在使用的 `UserDetailsService` 并指定要使用的密码编码器。在这种情况下，我们使用了
    `BcryptPasswordEncoder`。如您所注意到的，我们尚未在我们的项目中创建 `UserDetailsService` 的实现。现在让我们来做这件事。将
    `AppUserDetailsService` 添加到 `com.example.placereviewer.service` 包中：'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`loadUsername(String)` attempts to load the `UserDetails` of a user matching
    the username passed to the function. If a user matching the provided username
    cannot be found, then a `UsernameNotFoundException` is thrown.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadUsername(String)` 尝试加载与函数传递的 username 匹配的用户的 `UserDetails`。如果找不到与提供的 username
    匹配的用户，则抛出 `UsernameNotFoundException`。'
- en: With all this completed, you have successfully set up Spring Security for our
    backend. Great work!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，您已成功为我们的后端设置了 Spring Security。做得好！
- en: Now that we have finished work on our entities, repositories, services, service
    implementations, and Spring Security configuration, we can ideally begin implementing
    the frontend of our application. However, the implementation of the application's
    frontend is a task for the next chapter and as such, let us focus on other things.
    More specifically, let us explore the process of serving web content to a client
    application with Spring MVC.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对实体、存储库、服务、服务实现和Spring Security配置的工作，我们可以理想地开始实现应用程序的前端。然而，应用程序前端实现的任务将在下一章中讨论，因此让我们专注于其他事情。更具体地说，让我们探索使用Spring
    MVC向客户端应用程序提供网络内容的过程。
- en: Serving web content with Spring MVC
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring MVC提供网络内容
- en: In Spring MVC, HTTP requests are handled by controllers. Controllers are classes
    that have been annotated with `@Controller—`similar to how we annotate rest controllers
    with `@RestController`. The best way to understand the way controllers work is
    to have an example to scrutinize. Let us create a simple Spring MVC controller
    that handles HTTP GET requests sent to the `/say/hello` path by returning a view,
    which has the responsibility of rendering an HTML page to a user.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC中，HTTP请求由控制器处理。控制器是带有`@Controller`注解的类——类似于我们如何使用`@RestController`注解rest控制器。理解控制器工作方式的最佳方式是有一个示例来仔细研究。让我们创建一个简单的Spring
    MVC控制器，该控制器通过返回一个视图来处理发送到`/say/hello`路径的HTTP GET请求，该视图负责将HTML页面渲染给用户。
- en: 'Create a `controller` package in `com.example.placereviewer` and add the following
    class to it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`com.example.placereviewer`中创建一个`controller`包，并将以下类添加到其中：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As can be seen, the creation of a controller is in no way a complex task. The
    annotation of `HelloController` with `@Controller` tells Spring that this class
    is a Spring MVC controller and as such is capable of handling HTTP requests. In
    addition, annotating `HelloController` with `@RequestMapping("/say")` specifies
    that the controller handles HTTP requests that have `/say` as their base paths.
    We defined a `hello()` action within the controller. Since this action was annotated
    with `@GetMapping("/hello")`, it handles GET requests to the path `/say/hello`.
    The string returned by `hello()` is the name of the view resource that should
    be rendered to the client upon the sending of a request to this route.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，创建控制器根本不是一项复杂任务。`HelloController`类上使用`@Controller`注解告诉Spring这个类是一个Spring
    MVC控制器，因此能够处理HTTP请求。此外，使用`@RequestMapping("/say")`注解`HelloController`指定控制器处理以`/say`为基本路径的HTTP请求。我们在控制器中定义了一个`hello()`动作。由于这个动作被`@GetMapping("/hello")`注解，它处理对`/say/hello`路径的GET请求。`hello()`函数返回的字符串是应该在向此路由发送请求时渲染给客户端的视图资源名称。
- en: 'Since `hello()` requires that a view named `hello` is returned to the client,
    our next task is to add such a view to our project. Views are generally added
    to the `templates` folder of a Spring project''s `resources` directory. Add a `hello.html`
    file to the project by right-clicking on the templates and then selecting New
    | HTML File:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`hello()`函数要求返回一个名为`hello`的视图给客户端，我们的下一个任务是为我们的项目添加这样一个视图。视图通常被添加到Spring项目`resources`目录下的`templates`文件夹中。通过在`templates`上右键单击，然后选择“新建
    | HTML文件”来将`hello.html`文件添加到项目中：
- en: '![](img/eca3c1f0-78e1-4809-a037-1111921027bd.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eca3c1f0-78e1-4809-a037-1111921027bd.png)'
- en: 'You will be prompted to provide a name for the HTML file to be created. Input
    `hello` as the name and proceed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被提示为要创建的HTML文件提供名称。输入`hello`作为名称并继续：
- en: '![](img/cab8282e-1873-464a-bbde-a3d30019b953.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cab8282e-1873-464a-bbde-a3d30019b953.jpg)'
- en: 'IntelliJ IDEA will generate an HTML file in the selected directory. Once this
    is done, modify its content to contain the basic HTML, as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA将在所选目录中生成一个HTML文件。一旦完成，修改其内容以包含基本的HTML，如下所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are now ready to test if the controller we created works. We will know if
    it works if it returns an HTML page with a message reading `Hello World!` when
    we send a GET request to its route path. Before we forget, we must add GET requests
    sent to `/say/hello` as requests permitted by Spring Security without authentication.
    Doing this is straightforward; simply modify `configure(HttpSecurity)` in `WebSecurityConfig`
    to permit GET requests to `/say/hello`, as shown in the following snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好测试我们创建的控制器是否工作。如果我们向其路由路径发送GET请求，它返回一个包含消息“Hello World!”的HTML页面，我们就知道它工作正常。在我们忘记之前，我们必须将发送到`/say/hello`的GET请求添加为Spring
    Security允许的不需要认证的请求。这样做很简单；只需修改`WebSecurityConfig`中的`configure(HttpSecurity)`以允许对`/say/hello`的GET请求，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Build and run the Spring application, and then open your favorite web browser
    and navigate to the following URL: `http://localhost:5000/say/hello`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行 Spring 应用程序，然后打开您喜欢的网页浏览器并导航到以下 URL：`http://localhost:5000/say/hello`。
- en: '![](img/20cb8365-0cf8-4a39-845f-11a523220e98.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20cb8365-0cf8-4a39-845f-11a523220e98.jpg)'
- en: You will be greeted enthusiastically with a `Hello World!` message.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您将热情地收到一个 `Hello World!` 消息。
- en: Managing Spring application logs with ELK
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ELK 管理 Spring 应用程序日志
- en: When building systems that are intended to be deployed, an important thing to
    consider is the means by which server log files are managed. A server log is a
    log file that is created and maintained by a server. Log files generally consist
    of a list of activities that a server performed. A means of managing application
    log files that should be strongly considered is the use of the ELK (Elasticsearch,
    Logstash, and Kibana) stack. In this section, we will learn how to manage Spring
    application log files with the ELK stack.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建旨在部署的系统时，一个重要的事情要考虑的是服务器日志文件的管理方式。服务器日志是由服务器创建和维护的日志文件。日志文件通常包含服务器执行的活动列表。应该强烈考虑使用
    ELK（Elasticsearch、Logstash 和 Kibana）堆栈来管理应用程序日志文件。在本节中，我们将学习如何使用 ELK 堆栈管理 Spring
    应用程序日志文件。
- en: Generating logs with Spring
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 生成日志
- en: Before getting started with setting up an ELK stack to manage our Spring logs,
    we must configure Spring to generate log files. This can easily be done with a
    Spring project's application.properties file. Let's configure our Place Reviewer
    backend to generate logs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始设置 ELK 堆栈以管理我们的 Spring 日志之前，我们必须配置 Spring 以生成日志文件。这可以通过 Spring 项目的 application.properties
    文件轻松完成。让我们配置我们的 Place Reviewer 后端以生成日志。
- en: 'Open up the project''s `application.properties` file and add the following
    line of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目的 `application.properties` 文件并添加以下代码行：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This line of code configures Spring to generate and store server logs in an
    `application.log` file. This file will be generated and stored in the root directory
    of your project upon the next start of the project. What we have done is all that's
    necessary to configure server logs. Now, let's set up our log stack. We shall
    start by installing Elasticsearch.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码配置 Spring 在 `application.log` 文件中生成和存储服务器日志。在项目启动时，此文件将在项目的根目录下生成并存储。我们所做的一切都是配置服务器日志所必需的。现在，让我们设置我们的日志堆栈。我们将首先安装
    Elasticsearch。
- en: Installing Elasticsearch
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Elasticsearch
- en: 'Elasticsearch can be installed in four easy steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 可以通过四个简单的步骤进行安装：
- en: Download the Elasticsearch packaged in a ZIP  file from [https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch)
    下载打包在 ZIP 文件中的 Elasticsearch。
- en: Extract Elasticsearch from the ZIP file upon download.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后从 ZIP 文件中提取 Elasticsearch。
- en: 'Run Elasticsearch from your terminal. Thus, run `bin/elasticsearch` (`bin/elasticsearch.bat`
    on Windows):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端运行 Elasticsearch。因此，运行 `bin/elasticsearch` (`bin/elasticsearch.bat` 在 Windows
    上)：
- en: '![](img/d9f3e65b-c366-467e-8cf0-eb3a3eb05ced.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9f3e65b-c366-467e-8cf0-eb3a3eb05ced.jpg)'
- en: 'After executing `bin/elasticsearch` in your terminal, Elasticsearch will run
    on your system:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中执行 `bin/elasticsearch` 后，Elasticsearch 将在您的系统上运行：
- en: '![](img/f3e5b673-bf16-48f7-9140-10941506ef08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3e5b673-bf16-48f7-9140-10941506ef08.jpg)'
- en: 'After running Elasticsearch, you can check if it''s functioning properly by
    running the following command from your terminal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Elasticsearch 后，您可以通过在终端运行以下命令来检查它是否正常工作：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If everything is set up correctly, you will get a response similar to the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，您将得到以下类似的响应：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Installing Kibana
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Kibana
- en: 'Kibana''s installation process is similar to that of Elasticsearch:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana 的安装过程与 Elasticsearch 类似：
- en: Download an appropriate Kibana archive from [https://www.elastic.co/downloads/kibana](https://www.elastic.co/downloads/kibana).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.elastic.co/downloads/kibana](https://www.elastic.co/downloads/kibana)
    下载适当的 Kibana 存档。
- en: Extract Kibana from the archive.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存档中提取 Kibana。
- en: Run it with `bin/kibana`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `bin/kibana` 运行它。
- en: 'After downloading and running Kibana, check if it works by accessing `http://localhost:5601/`
    from your favorite browser. If all is working well, you will be presented with
    Kibana''s web interface:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并运行 Kibana 后，通过您喜欢的浏览器访问 `http://localhost:5601/` 来检查它是否工作正常。如果一切正常，您将看到 Kibana
    的网页界面：
- en: '![](img/216b20a3-63e4-4188-9020-a9618b7581fd.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/216b20a3-63e4-4188-9020-a9618b7581fd.jpg)'
- en: Installing Logstash
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Logstash
- en: 'To install Logstash:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Logstash：
- en: Download its ZIP package from [https://www.elastic.co/downloads/logstash](https://www.elastic.co/downloads/logstash).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.elastic.co/downloads/logstash](https://www.elastic.co/downloads/logstash)
    下载其 ZIP 包。
- en: Unzip the package.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压包。
- en: 'In the case of Logstash, simply downloading and running it will not suffice.
    We must configure it to understand the structure of our Spring log file. We do
    this by creating a Logstash configuration file. A Logstash config file contains
    three critical sections. These are the input, filter, and output sections. Each
    section sets up plugins that play a role in the processing of log files. Create
    a `logstash.conf` file in a suitable directory and add the following code to it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Logstash 的情况下，仅仅下载和运行是不够的。我们必须配置它以理解我们 Spring 日志文件的结构。我们通过创建一个 Logstash 配置文件来完成此操作。Logstash
    配置文件包含三个关键部分。这些是输入、过滤和输出部分。每个部分都设置了在日志文件处理中扮演角色的插件。在合适的目录中创建一个`logstash.conf`文件，并将其添加以下代码：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Explaining what all plugins in the preceding code snippet do is beyond the scope
    of this book. Comments have been added where necessary to facilitate a better
    understanding. Change `path` in the file plugin of the input section to the absolute
    path of the Place Reviewer application's `application.log` file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解释前面代码片段中所有插件的功能超出了本书的范围。已添加必要的注释以促进更好的理解。将输入部分文件插件中的`path`更改为 Place Reviewer
    应用程序的`application.log`文件的绝对路径。
- en: 'Once done with the Logstash configuration file, run Logstash with the following
    command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完成Logstash配置文件后，使用以下命令运行Logstash：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Logstash should begin storing stashing log events if things were configured
    properly. The last thing on our agenda is to configure Kibana to read the stashed
    data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置正确，Logstash 应该开始存储日志事件。我们议程上的最后一件事是配置 Kibana 以读取存储的数据。
- en: Configuring Kibana
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Kibana
- en: 'Kibana can be easily configured to read logs that have been stashed to an Elasticsearch
    index. Access the Kibana web UI (`http://localhost:5601/`) and navigate to the
    settings management page by clicking Management on the left navigation bar. Our
    first course of action in configuring Kibana is the creation of an index pattern.
    Click Index Patterns on the management screen to manage the index patterns recognized
    by Kibana:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana 可以轻松配置以读取存储到 Elasticsearch 索引中的日志。访问 Kibana 网页界面（`http://localhost:5601/`），通过点击左侧导航栏上的管理导航到设置管理页面。配置
    Kibana 的第一步是创建索引模式。在管理屏幕上点击索引模式以管理 Kibana 识别的索引模式：
- en: '![](img/13ea74c8-6f24-4bbf-b616-cb342fcfc94e.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13ea74c8-6f24-4bbf-b616-cb342fcfc94e.jpg)'
- en: 'Since you haven''t previously created an index pattern on Kibana, you will
    be prompted to do so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您之前没有在 Kibana 上创建索引模式，您将被提示创建：
- en: '![](img/2e1ff624-6965-4e08-b823-a20bd0005e75.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e1ff624-6965-4e08-b823-a20bd0005e75.jpg)'
- en: 'Input the name of one of the indices recognized by Kibana (displayed on the
    screen) in the Index pattern field. After inputting an index pattern, proceed
    to the next step. You will be required to select a time filter field name in the
    next step:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引模式字段中输入 Kibana 识别的索引名称之一（显示在屏幕上）。输入索引模式后，继续下一步。您将在下一步中需要选择一个时间过滤器字段名称：
- en: '![](img/9a13574a-f037-4e4c-82ff-487d662132cc.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a13574a-f037-4e4c-82ff-487d662132cc.jpg)'
- en: 'Select `@timestamp` as the time filter field name in the dropdown. Having selected
    a time filter field, finish the creation of the index pattern by clicking Create
    Index Pattern. You can manage index patterns you have created at any time from
    the settings management page by selecting Index Patterns. Check your saved patterns:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单中选择`@timestamp`作为时间过滤器字段名称。选择时间过滤器字段后，通过点击创建索引模式来完成索引模式的创建。您可以从设置管理页面通过选择索引模式在任何时候管理您创建的索引模式。检查您的保存模式：
- en: '![](img/7515b35d-2558-41e9-899c-0737d268a801.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7515b35d-2558-41e9-899c-0737d268a801.jpg)'
- en: If you see the pattern we just created, then congratulations; you have successfully
    configured Kibana!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到我们刚刚创建的模式，那么恭喜您；您已成功配置 Kibana！
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went deeper into our exploration of Kotlin and its usefulness
    in the development of web-based platforms by implementing the backend of the Place
    Reviewer application. In addition, we learned how to set up a Spring Framework
    project that utilizes Spring MVC to create modern applications that follow the
    Model-View-Controller design pattern. Furthermore, we learned how to configure
    Spring Security to prevent unauthenticated access to Spring web applications.
    Lastly, we explored the ELK stack and looked at how it can be utilized to manage
    server logs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过实现“地点评论者”应用程序的后端，进一步深入探索了 Kotlin 及其在基于 Web 平台开发中的实用性。此外，我们还学习了如何设置一个利用
    Spring MVC 创建遵循模型-视图-控制器设计模式的现代应用程序的 Spring 框架项目。进一步地，我们学习了如何配置 Spring Security
    以防止未经身份验证的访问 Spring Web 应用程序。最后，我们探讨了 ELK 堆栈，并了解了它如何被用于管理服务器日志。
- en: In the next chapter, we will finish building the Place Reviewer application
    by implementing its frontend. In the process of the frontend implementation, we
    will learn about how we can build rich web applications with the Google Places
    API and how to test web applications built with Spring Framework.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现其前端来完成“地点评论者”应用程序的构建。在前端实现的过程中，我们将学习如何使用 Google 地点 API 构建丰富的 Web
    应用程序，以及如何测试使用 Spring 框架构建的 Web 应用程序。
