- en: Creating the Place Reviewer Backend with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We focused on the utilization of Kotlin in the development of applications for
    the Android platform in the previous four chapters. The chapter we just concluded
    covered, extensively, the various activities involved in securing and deploying
    an Android application. We took a look at some best practices—in relation to security—when
    working with data storage as well as when communicating over a network. In addition,
    we discussed the necessary security considerations when handling user inputs and
    working with user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we looked at various ways of securing some Android application
    components—such as services and broadcast receivers. Lastly, we took a step-by-step
    approach to properly deploying an Android application to the Google Play Store.
    In this chapter, we will have an in-depth look at how Kotlin can be used to develop
    web-based solutions – specifically with Spring—by developing the Place Reviewer
    application. This chapter will focus on the development of the backend of the
    Place Reviewer application, and the following chapter will focus on its frontend.
    In the course of reading through this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logstash and its use in centralizing, transforming, and stashing data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing a website with Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dive right in to what we have to learn by first taking a look at the Model-View-Controller
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC pattern, also known as the Model-View-Controller pattern, is an application
    design pattern that is used primarily for the separation of concerns within modern
    applications. More specifically, it is a design pattern for user interfaces that
    divides an application, primarily, into three distinct components. This separation
    of application modules into distinct parts is done for several reasons. One such
    reason is to isolate presentation logic from core business logic. Let us take
    a look at these three application components in the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model is the component that is in charge of the management of data and logic
    of an MVC application. As the model is the principal manager of all data and business
    logic, you can view it as the powerhouse of an MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a visual representation of data that exists in and is generated by an
    application. It is the primary point of interaction that a user has with the application.
  prefs: []
  type: TYPE_NORMAL
- en: The controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The controller is an intermediary actor between the view and the model. It
    is in charge of retrieving input – primarily from the view – and feeding an appropriately
    transformed form of the input to the model. It is also in charge of updating the
    view with data whenever the need arises:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0cb4510-efd7-4531-8033-7b356807db73.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Designing and implementing the Place Reviewer backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have previously had hands-on experience with the process of designing
    a system, in this chapter, we are going to focus less on the processes involved
    in the designing of the Place Reviewer system. Instead, we are going to make a
    number of quick use case specifications for the system, identify the necessary
    entities that will be required for the implementation of our system's database,
    and delve right into the development of the system. Let us go ahead and state
    our use cases for the Place Reviewer system.
  prefs: []
  type: TYPE_NORMAL
- en: Use case identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we did earlier on in this book, we shall commence our use case specification
    procedure by firstly identifying the actors of the system. Before we can identify
    the actors of the system, we must have a thorough understanding of what the Place
    Reviewer web application can do.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have figured out already, the Place Reviewer web application is an
    internet-based application that facilitates the frictionless creation of location
    reviews by users of the platform. Once a user has been registered, he/she is able
    to utilize the platform to create an opinionated review (a review based on personal
    experiences) of any location in the world. The user will be able to select the
    location that he/she wants to review with the help of a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand what the Place Reviewer application can do, we can go
    ahead and identify the actors in the Place Reviewer system. As you will have surmised
    by this time, the implementation of the Place Reviewer application we are going
    to make only has one actor—the user. The use cases of the user are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user uses the Place Reviewer application to create location reviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user uses the Place Reviewer application to view reviews that were created
    by other users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can view the exact location that was reviewed, by another user, on
    an interactive map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can register on the Place Reviewer platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can logout from his/her Place Reviewer account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have made suitable progress thus far. We have been able to state unequivocally
    what the Place Reviewer system does, identify the actors of the system, and clearly
    state the use cases of the system by its sole actor - the user. Let us go a step
    further by identifying the data that the system will need to cater for.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a consequence of our previous use case definitions, we can easily identify
    the type of data that the Place Reviewer application must cater for—by the creation
    of appropriate models. The first type of data is the user data and the second
    type is the review data. The user data, as the name implies, is the data relating
    to a user registered on the platform, whereas the review data is the necessary
    data for every review created on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will require the following data for the user: the user''s email address,
    username, password, and account status. In addition, we will need a unique identifier
    for each user of the platform—a user ID—and the date on which the user was registered.
    With respect to the data necessary for reviews, we will need a review title, its
    body the content of the review, the address of the place reviewed, the name of
    the place reviewed, positional information of the place reviewed (its longitudinal
    and latitudinal coordinates), and a place ID to specifically identify the place
    being reviewed. In addition, a unique identifier will be required for the review
    being created as well as information relating to the time the review was created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this juncture, you might be thinking: hold on, why do we have information
    pertaining to a place (a place name, place address, place ID, and longitude and
    latitude) coupled with the information of a review? Why don''t we separate this
    information and consider it a distinct type of data we will be catering for? If
    you thought this, you are right, that will be a great approach to doing things
    if we, say, had a database table that possessed all the information of all the
    places we wanted to be reviewable on the platform. Sadly, we do not have any such
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may be wondering: how can we provide a user with the ability to review
    places of which we have no information about? The answer is simple. We utilize
    Google''s Places API. We shall take a look at how to do this in the next chapter,
    but for now, hold on tight as we begin implementing the Place Reviewer backend.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As it is necessary for our system to store information, we need to set up a
    database for our application to persist data in. As we utilized Postgres as our
    primary datastore in a previous application we developed, we will utilize it as
    our primary datastore. We have already covered how to set up Postgres on various
    systems and as such we will not bother covering that here. Let us go ahead and
    create our database. Open your Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the command, a database named` place-reviewer` will be created
    on your system. The username you input in place of the `<username>` argument will
    be the username that you will use to connect to the database. Having set up the
    database for our application, we can go ahead with the implementation of the backend.
    We will be utilizing Spring Framework in the implementation of the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having established a sense of direction by specifying the various use cases
    of our application and setting up a database for our application to connect to,
    let us go straight ahead with its implementation. Open IntelliJ IDEA and create
    a new project with the Spring initializer. Upon clicking Next, IntelliJ will retrieve
    the Spring initializer, after which you will be asked to provide certain details
    for the application. Do the following before proceeding to the next stage of the
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Input `com.example` as the group ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `place-reviewer` as the artifact ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Maven Project as the project type if it is not already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the packaging option and Java version the way they are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Kotlin as the language. This is important, as we are further learning
    the Kotlin language, after all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the version attribute to 1.0.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a description of your choice. Ours is `A nifty web application for the
    creation of location reviews`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `com.example.placereviewer` as the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After filling in the required project information, proceed to the next screen
    by clicking Next. We are required to select the dependencies of our project in
    the screen displayed to us.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring initializer comes with the Spring plugin, which, at the time of writing,
    is only available on the IntelliJ IDEA Ultimate Edition, which requires a paid
    license. If you have the IntelliJ IDEA Community Edition installed, you can still
    develop this application. Simply generate the project using the Spring initializer
    utility at [https://start.spring.io](https://start.spring.io) and import the project
    into IntelliJ IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Spring Security, Session, Cache, and Web dependencies. In addition,
    select Thymeleaf from the template engine category. Under the SQL category, select
    PostgreSQL. In addition, in the Spring Boot Version selection dropdown menu at
    the top of the screen, select 2.0.0 M7 as the version. Upon selecting the necessary
    dependencies, the content should be similar to that in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bbc6e06-37a8-4ba8-a194-065e6632d774.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After asserting that you have selected the appropriate dependencies, click
    Next to continue to the final setup screen. Here, you are required to provide
    a project name and a project location. Fill in `place-reviewer` as the project
    name and select the location in which you want the project to be saved on your
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bda2de8-4973-411a-8eb7-caabb200993a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this has been done, select Finish and wait for the project to be set up.
    You will be taken to a new IDE window containing the initial project files. We
    need not give any introductions to the structure of a Spring project, as we have
    already worked with one in previous chapters. Before we go further, add the following
    dependencies to the project''s `pom` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's get on with connecting our application to our database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the backend to Postgres
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect the Place Reviewer backend to the PostgreSQL database we created
    for it, we must modify our project''s `application.properties` file to contain
    the necessary properties that are needed to facilitate a database connection with
    PostgreSQL. Open the project''s `application.properties` file and add the following
    properties to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Insert an appropriate username where the `<username>` property is within the
    preceding code snippet. Having added the appropriate database connection properties,
    Spring Boot will be able to connect to the specified database upon the application
    start. Having set up the appropriate database connection properties for our project,
    let us create models for the `User` and `Review` entities we earlier identified.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We previously identified two distinct types of entities that must be catered
    for in our system: the `User` entity and the `Review` entity. It is time to create
    appropriate models for these entities. The first of these entities we will concern
    ourselves with is the User. Create a `data` package within the `com.example.placereviewer`
    package. Add a `model` package within the newly created `data` package. Now, add
    a `User.kt` file within the newly created `com.example.placereviewer.data.model`
    package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need spend time explaining much of what is going on in the preceding
    code snippet as we have prior experience with the creation of entities in Spring.
    In the preceding snippet, we defined a `User` entity with email, `username`, `password`,
    `accountStatus`, `Id`, and `createdAt` properties as its attributes. In addition,
    we specified that a User has many Review entities. We also specified an entity
    listener for the entity with the `@EntityListener` annotation. We have created
    neither a `Review` entity nor a `UserListener` for the `User` entity. As we are
    still focused on the `User` entity, let us focus on creating its entity listener
    before concerning ourselves with the `Review` entity. Add a new `listener` package
    to `com.example.placereviewer` and add a `UserListener.kt` file to it containing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`UserListener` has a single `hashPassword` function, which is invoked before
    persisting and before updating a `User` entity. The method has the single job
    of encoding the `password` property of a user into its bcrypt equivalent before
    persisting it in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having created the necessary listeners for the `User` entity, let us turn our
    attention to the definition of a `Review` entity. Create a `Review.kt` file in
    `com.example.placereviewer.data.models` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in the preceding code snippet, we created a `Review` data class
    with the following properties: `reviewer`, `title`, `body`, `placeAddress`, `placeName`,
    `placeId`, `latitude`, `longitude`, `id`, and `createdAt`. The reviewer property
    is of the type `User`. It references the creator of the review. Every review must
    be created by a user. In addition, many reviews are created by a single user.
    We use the `@ManyToOne` annotation to properly declare this relationship between
    the `Review` and `User` entities.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating data repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have now set up our necessary entities, we must create repositories which
    we will use to access data pertaining to our entities. Create a repositories package
    within the `com.example.placereviewer` package. We have two entities, and as such,
    we shall create two repositories (one to access data pertaining to each entity).
    The first of the repositories will be `UserRepository` and the second will be `ReviewRepository`.
    Create a `UserRepository` interface file within `com.example.placereviewer.data.repository`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findByUsername(String)` method retrieves a `User` from the database which
    has a username that corresponds to that passed as an argument to the function.
    The following is the `ReviewRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Having set up our entities and repositories to query these entities, we can
    start work on implementing the core business logic of the Place Reviewer application
    in the form of services and service implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Place Reviewer business logic implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously explained, in an application that adheres to the MVC design pattern,
    there are three primary components of consequence. These components are the model,
    view, and controller. The models are the components that are in charge of data
    management and the execution of business logic. In our Place Reviewer application,
    we are going to implement our models in the form of services that can be used
    across the backend. At this juncture, we need to create two fundamental services.
    The first to manage data pertaining to users of the application, and the second
    to manage review data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create a `UserService` interface that defines the behaviors
    that must be implemented by a valid `UserServiceImpl` class. We previously stated
    in our use cases for the Place Reviewer application that a user must be able to
    register (hence create an account) on the platform. As such, we must cater for
    this process in our model. Create a `service` package in the project''s root package.
    Now, add the `UserService` interface to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We declared one method that must be implemented by a valid `UserService`. This
    method is the `register (String, String, String)` method. `register()` takes three
    strings as arguments. The first is the username of the user to be registered,
    the second is a valid email address for the user, and the third is his/her password
    of choice. When invoked with appropriate arguments, `register()` attempts to register
    the user with his/her provided credentials and returns `true` if the user was
    registered successfully; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation of the preceding `UserService`. Add it
    to the `service` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The workings of the `register()` function implemented by our `UserServiceImpl`
    class is straightforward. When valid username, email, and password arguments are
    passed to it, it creates a new object of the user - passing the appropriate arguments
    to its constructor. After the creation of an object of the user, the user is saved
    to the database with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`userRepository` is an instance of the `UserRepository` we created earlier.
    This instance is injected into the constructor of `UserServiceImpl` automatically
    by Spring Framework. Once the user has been saved to the database, the Boolean
    value `true` is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Up next is the implementation of a review service interface. Our review service
    must facilitate the creation of reviews and the listing of reviews that have been
    created by users of the platform. As a consequence of this requirement, we will
    mandate the implementation of the `createReview()` and `listReview()` methods
    in our user `service` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `ReviewService` interface to the `service` package of the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `ReviewServiceImpl` class for the service we have just
    created. Add it, as well as all the services we will create later on in this chapter,
    to `com.example.placereviewer.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`listReviews()` returns an iterable containing all the review data that has
    been stored within the application''s database. `createReview()`, on the other
    hand, takes a string whose value is the username of the user creating the review
    and an instance of Review containing the data for the review to be created. `createReview()`
    first retrieves the user with the specified username by invoking the `findByUsername()`
    method of `UserRepository`. This user retrieved is the creator of the review—hence,
    the reviewer.'
  prefs: []
  type: TYPE_NORMAL
- en: If a null object is not returned by `UserRepository`, the user exists and as
    such, the retrieved user is assigned to the `reviewer` property of the review
    to be saved. After this assignment, the review is saved to the database and the
    function returns `true` – signifying that the process was successful. If no user
    with the username provided was found, `false` is returned by `createReview()`.
  prefs: []
  type: TYPE_NORMAL
- en: Having created appropriate models in the form of services, let us work on securing
    our Place Reviewer application. This is an important procedure as we do not want
    unauthorized individuals to be able to access our application resources.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the Place Reviewer backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to how we went about securing the Messenger API in [Chapter 4](kt-prog-ex_ch04.html), *Designing
    and Implementing the Messenger Backend with Spring Boot 2.0*, we shall utilize
    Spring Security to secure the Place Reviewer backend. Regardless of the utilization
    of Spring Security here, there is a slight variation to the way we are going to
    go about securing our application. In [Chapter 4](kt-prog-ex_ch04.html), *Designing
    and Implementing the Messenger Backend with Spring Boot 2.0*, we configured Spring
    Security to rely explicitly on JSON web tokens for the authorization of client
    applications. This time, we will rely solely on the power of Spring Security.
    In doing so, we will not make use of any other technology, such as JSON web tokens.
    Without further ado, let us begin work on securing our backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we must create a custom web security configuration for
    our application. This custom configuration will implement Spring Framework''s 
    `WebSecurityConfigurerAdapter`. Create a `config` package in `com.example.placereviewer`
    and add the following `WebSecurityConfig` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we have explained earlier in this book, the `configure(HttpSecurity)` method
    of `WebSecurityConfig` has the task of configuring which HTTP URL paths are to
    be secured and which are not. With the `configure(HttpSecurity)` method, we have
    configured Spring Security to permit all HTTP  POST requests to `/users/registrations` and
    GET requests whose paths match the paths `/register`, `/css`, and `/webjars/**`.
    In addition, we have permitted all HTTP requests to a login page that can be accessed
    from the path `/login`.
  prefs: []
  type: TYPE_NORMAL
- en: We added a success handler to the login action which utilizes the `redirectStrategy`
    property that we defined for our `WebSecurityConfig` class to redirect a client
    to the `/home` path upon successful login of a user. Lastly, we permitted all
    logout requests to our backend.
  prefs: []
  type: TYPE_NORMAL
- en: '`configure(AuthenticationManagerBuilder)` sets up the `UserDetailsService`
    in use and specifies a password encoder to be used. We made use of a `BcryptPasswordEncoder`
    in this case. As you may have noticed, we have created no implementation of `UserDetailsService`
    in our project. Let us do that now. Add `AppUserDetailsService` to the `com.example.placereviewer.service`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`loadUsername(String)` attempts to load the `UserDetails` of a user matching
    the username passed to the function. If a user matching the provided username
    cannot be found, then a `UsernameNotFoundException` is thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: With all this completed, you have successfully set up Spring Security for our
    backend. Great work!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished work on our entities, repositories, services, service
    implementations, and Spring Security configuration, we can ideally begin implementing
    the frontend of our application. However, the implementation of the application's
    frontend is a task for the next chapter and as such, let us focus on other things.
    More specifically, let us explore the process of serving web content to a client
    application with Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Serving web content with Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring MVC, HTTP requests are handled by controllers. Controllers are classes
    that have been annotated with `@Controller—`similar to how we annotate rest controllers
    with `@RestController`. The best way to understand the way controllers work is
    to have an example to scrutinize. Let us create a simple Spring MVC controller
    that handles HTTP GET requests sent to the `/say/hello` path by returning a view,
    which has the responsibility of rendering an HTML page to a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `controller` package in `com.example.placereviewer` and add the following
    class to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, the creation of a controller is in no way a complex task. The
    annotation of `HelloController` with `@Controller` tells Spring that this class
    is a Spring MVC controller and as such is capable of handling HTTP requests. In
    addition, annotating `HelloController` with `@RequestMapping("/say")` specifies
    that the controller handles HTTP requests that have `/say` as their base paths.
    We defined a `hello()` action within the controller. Since this action was annotated
    with `@GetMapping("/hello")`, it handles GET requests to the path `/say/hello`.
    The string returned by `hello()` is the name of the view resource that should
    be rendered to the client upon the sending of a request to this route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `hello()` requires that a view named `hello` is returned to the client,
    our next task is to add such a view to our project. Views are generally added
    to the `templates` folder of a Spring project''s `resources` directory. Add a `hello.html`
    file to the project by right-clicking on the templates and then selecting New
    | HTML File:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eca3c1f0-78e1-4809-a037-1111921027bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be prompted to provide a name for the HTML file to be created. Input
    `hello` as the name and proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cab8282e-1873-464a-bbde-a3d30019b953.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'IntelliJ IDEA will generate an HTML file in the selected directory. Once this
    is done, modify its content to contain the basic HTML, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to test if the controller we created works. We will know if
    it works if it returns an HTML page with a message reading `Hello World!` when
    we send a GET request to its route path. Before we forget, we must add GET requests
    sent to `/say/hello` as requests permitted by Spring Security without authentication.
    Doing this is straightforward; simply modify `configure(HttpSecurity)` in `WebSecurityConfig`
    to permit GET requests to `/say/hello`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the Spring application, and then open your favorite web browser
    and navigate to the following URL: `http://localhost:5000/say/hello`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20cb8365-0cf8-4a39-845f-11a523220e98.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will be greeted enthusiastically with a `Hello World!` message.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Spring application logs with ELK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building systems that are intended to be deployed, an important thing to
    consider is the means by which server log files are managed. A server log is a
    log file that is created and maintained by a server. Log files generally consist
    of a list of activities that a server performed. A means of managing application
    log files that should be strongly considered is the use of the ELK (Elasticsearch,
    Logstash, and Kibana) stack. In this section, we will learn how to manage Spring
    application log files with the ELK stack.
  prefs: []
  type: TYPE_NORMAL
- en: Generating logs with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started with setting up an ELK stack to manage our Spring logs,
    we must configure Spring to generate log files. This can easily be done with a
    Spring project's application.properties file. Let's configure our Place Reviewer
    backend to generate logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the project''s `application.properties` file and add the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This line of code configures Spring to generate and store server logs in an
    `application.log` file. This file will be generated and stored in the root directory
    of your project upon the next start of the project. What we have done is all that's
    necessary to configure server logs. Now, let's set up our log stack. We shall
    start by installing Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Elasticsearch can be installed in four easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the Elasticsearch packaged in a ZIP  file from [https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract Elasticsearch from the ZIP file upon download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run Elasticsearch from your terminal. Thus, run `bin/elasticsearch` (`bin/elasticsearch.bat`
    on Windows):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9f3e65b-c366-467e-8cf0-eb3a3eb05ced.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After executing `bin/elasticsearch` in your terminal, Elasticsearch will run
    on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3e5b673-bf16-48f7-9140-10941506ef08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After running Elasticsearch, you can check if it''s functioning properly by
    running the following command from your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is set up correctly, you will get a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Installing Kibana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kibana''s installation process is similar to that of Elasticsearch:'
  prefs: []
  type: TYPE_NORMAL
- en: Download an appropriate Kibana archive from [https://www.elastic.co/downloads/kibana](https://www.elastic.co/downloads/kibana).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract Kibana from the archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it with `bin/kibana`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After downloading and running Kibana, check if it works by accessing `http://localhost:5601/`
    from your favorite browser. If all is working well, you will be presented with
    Kibana''s web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/216b20a3-63e4-4188-9020-a9618b7581fd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing Logstash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Logstash:'
  prefs: []
  type: TYPE_NORMAL
- en: Download its ZIP package from [https://www.elastic.co/downloads/logstash](https://www.elastic.co/downloads/logstash).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of Logstash, simply downloading and running it will not suffice.
    We must configure it to understand the structure of our Spring log file. We do
    this by creating a Logstash configuration file. A Logstash config file contains
    three critical sections. These are the input, filter, and output sections. Each
    section sets up plugins that play a role in the processing of log files. Create
    a `logstash.conf` file in a suitable directory and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Explaining what all plugins in the preceding code snippet do is beyond the scope
    of this book. Comments have been added where necessary to facilitate a better
    understanding. Change `path` in the file plugin of the input section to the absolute
    path of the Place Reviewer application's `application.log` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done with the Logstash configuration file, run Logstash with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Logstash should begin storing stashing log events if things were configured
    properly. The last thing on our agenda is to configure Kibana to read the stashed
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kibana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kibana can be easily configured to read logs that have been stashed to an Elasticsearch
    index. Access the Kibana web UI (`http://localhost:5601/`) and navigate to the
    settings management page by clicking Management on the left navigation bar. Our
    first course of action in configuring Kibana is the creation of an index pattern.
    Click Index Patterns on the management screen to manage the index patterns recognized
    by Kibana:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13ea74c8-6f24-4bbf-b616-cb342fcfc94e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since you haven''t previously created an index pattern on Kibana, you will
    be prompted to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e1ff624-6965-4e08-b823-a20bd0005e75.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Input the name of one of the indices recognized by Kibana (displayed on the
    screen) in the Index pattern field. After inputting an index pattern, proceed
    to the next step. You will be required to select a time filter field name in the
    next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a13574a-f037-4e4c-82ff-487d662132cc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select `@timestamp` as the time filter field name in the dropdown. Having selected
    a time filter field, finish the creation of the index pattern by clicking Create
    Index Pattern. You can manage index patterns you have created at any time from
    the settings management page by selecting Index Patterns. Check your saved patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7515b35d-2558-41e9-899c-0737d268a801.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you see the pattern we just created, then congratulations; you have successfully
    configured Kibana!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went deeper into our exploration of Kotlin and its usefulness
    in the development of web-based platforms by implementing the backend of the Place
    Reviewer application. In addition, we learned how to set up a Spring Framework
    project that utilizes Spring MVC to create modern applications that follow the
    Model-View-Controller design pattern. Furthermore, we learned how to configure
    Spring Security to prevent unauthenticated access to Spring web applications.
    Lastly, we explored the ELK stack and looked at how it can be utilized to manage
    server logs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finish building the Place Reviewer application
    by implementing its frontend. In the process of the frontend implementation, we
    will learn about how we can build rich web applications with the Google Places
    API and how to test web applications built with Spring Framework.
  prefs: []
  type: TYPE_NORMAL
