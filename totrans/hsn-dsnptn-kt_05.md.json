["```kt\nfun <T> printAndClear(list: MutableList<T>) {\n    for (e in list) {\n        println(e)\n        list.remove(e)\n    }\n}\nprintAndClear(mutableListOf(\"a\", \"b\", \"c\"))\n```", "```kt\nval pair = \"a\" to 1\n```", "```kt\npair.first = \"b\" // Doesn't work\npair.second = 2  // Still doesn't\n```", "```kt\nval (key, value) = pair\nprintln(\"$key => $value\")\n```", "```kt\nfor (p in mapOf(1 to \"Sunday\", 2 to \"Monday\")) {\n   println(\"${p.key} ${p.value}\")\n}\n```", "```kt\ndata class AverageScore(var totalScore: Int = 0,\n                        var gamesPlayed: Int = 0) {\n    val average: Int\n        get() = if (gamesPlayed <= 0)\n                    0\n                else\n                    totalScore / gamesPlayed\n}\n```", "```kt\nval counter = AverageScore()\n\nthread(isDaemon = true) {\n    while(true) counter.gamesPlayed = 0\n}\n\nfor (i in 1..1_000) {\n    counter.totalScore += Random().nextInt(100)\n    counter.gamesPlayed++\n\n    println(counter.average)\n}\n```", "```kt\ndata class ScoreCollector(val scores: MutableList<Int> = mutableListOf())\n\nval counter = ScoreCollector()\n\nfor (i in 1..1_000) {\n    counter.scores += Random().nextInt(100)\n\n    println(counter.scores.sumBy { it } / counter.scores.size)\n}\n```", "```kt\nthread(isDaemon= true, name=\"Maleficent\") {\n    while(true) counter.scores.clear()\n}\n```", "```kt\ndata class ImmutableScoreCollector(val scores: List<Int>)\n```", "```kt\nval counter = ImmutableScoreCollector(List(1_000) {\n    Random().nextInt(100)\n})\n```", "```kt\nfun generateMultiply(): (Int, Int) -> Int {\n    return { x: Int, y: Int -> x * y}\n}\n```", "```kt\nval multiplyFunction = generateMultiply()\n...\nprintln(multiplyFunction(3, 4))\n```", "```kt\nfun mathInvoker(x: Int, y: Int, mathFunction: (Int, Int) -> Int) {\n    println(mathFunction(x, y))\n}\n\nmathInvoker(5, 6, multiplyFunction)\n```", "```kt\nmathInvoker(7, 8) { x, y ->\n   x * y\n}\n```", "```kt\nval squareAnonymous = fun(x: Int) = x * x\nval squareLambda = {x: Int -> x * x} \n```", "```kt\nfun sayHello() {\n    println(\"Hello\")\n}\n```", "```kt\nfun hello() = \"Hello\"\n```", "```kt\nfun testHello(): Boolean {\n    return \"Hello\" == hello()\n}\n```", "```kt\nfun <T> removeFirst(list: MutableList<T>): T {\n    return list.removeAt(0)\n}\n```", "```kt\nval list = mutableListOf(1, 2, 3)\n\nprintln(removeFirst(list)) // Prints 1\nprintln(removeFirst(list)) // Prints 2\n```", "```kt\nfun <T> withoutFirst(list: List<T>): T {\n    return ArrayList(list).removeAt(0)\n}\n```", "```kt\nval list = mutableListOf(1, 2, 3)\n\nprintln(withoutFirst(list)) // It's 1\nprintln(withoutFirst(list)) // Still 1\n```", "```kt\nfun subtract(x: Int, y: Int): Int {\n    return x - y\n}\nprintln(subtract(50, 8))\n```", "```kt\nsubtract(50)(8)\n```", "```kt\nfun subtract(x: Int): (Int) -> Int {\n    return fun(y: Int): Int {\n        return x - y\n    }\n}\n```", "```kt\nfun subtract(x: Int) = fun(y: Int): Int {\n    return x + y\n}\n```", "```kt\nfun subtract(x: Int) = {y: Int -> x - y}\n```", "```kt\nclass Summarizer {\n    private val resultsCache = mutableMapOf<List<Int>, Double>()\n\n    fun summarize(numbers: List<Int>): Double {\n        return resultsCache.computeIfAbsent(numbers, ::sum)\n    }\n\n    private fun sum(numbers: List<Int>): Double {\n        return numbers.sumByDouble { it.toDouble() }\n    }\n}\n```", "```kt\nval l1 = listOf(1, 2, 3)\nval l2 = listOf(1, 2, 3)\nval l3 = listOf(1, 2, 3, 4)\n\nval summarizer = Summarizer()\n\nprintln(summarizer.summarize(l1)) // Computes, new input\nprintln(summarizer.summarize(l1)) // Object is the same, no compute\nprintln(summarizer.summarize(l2)) // Value is the same, no compute\nprintln(summarizer.summarize(l3)) // Computes\n```", "```kt\nclass Cat implements Animal {\n    public String purr() {\n        return \"Purr-purr\";\n    }\n}\n\nclass Dog implements Animal {\n    public String bark() {\n        return \"Bark-bark\";\n    }\n```", "```kt\n}\n\ninterface Animal {}\n```", "```kt\npublic String getSound(Animal animal) {\n    String sound = null;\n    if (animal instanceof Cat) {\n        sound = ((Cat)animal).purr();\n    }\n    else if (animal instanceof Dog) {\n        sound = ((Dog)animal).bark();\n    }\n\n    if (sound == null) {\n        throw new RuntimeException();\n    }\n    return sound;\n}\n```", "```kt\nfun getSound(animal: Animal) = when(animal) {\n    is Cat -> animal.purr()\n    is Dog -> animal.bark()\n    else -> throw RuntimeException()\n}\n```", "```kt\nfun sumRec(i: Int, numbers: List<Int>): Long {\n    return if (i == numbers.size) {\n        0\n    } else {\n        numbers[i] + sumRec(i + 1, numbers)\n    }\n}\n```", "```kt\nval numbers = List(1_000_000) {it}\nprintln(sumRec(0,  numbers)) // Crashed pretty soon, around 7K \n```", "```kt\ntailrec fun sumRec(i: Int, sum: Long, numbers: List<Int>): Long {\n    return if (i == numbers.size) {\n        return sum\n    } else {\n        sumRec(i+1, numbers[i] + sum, numbers)\n    }\n}\n```"]