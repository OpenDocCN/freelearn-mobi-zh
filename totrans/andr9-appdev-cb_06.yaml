- en: Home Screen Widgets, Search, and the System UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shortcut on the Home screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Home screen widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Search to the Action Bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing your app full-screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock screen shortcuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an understanding of Fragments from the previous chapter, we're ready to
    expand on our discussion of widgets. In [Chapter 3](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml),* Views,
    Widgets, and Styles*, we discussed how to add widgets to your own app. Now, we'll
    look at how to create an App Widget so users can add your app on their Home screen.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining recipes in this chapter will explore System UI options. There's
    a recipe for adding a Search option to the Action Bar using the Android SearchManager API.
    Another recipe will explore Full Screen mode and several additional variations
    on altering the System UI. The final recipe will showcase the new Lock Screen
    shortcuts introduced in Android O (API 26).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shortcut on the Home screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe explains how to create a link or create a shortcut for your app
    on the user's Home screen. So as not to be too obtrusive, it's generally best
    to make this an option for the user to initiate, such as in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot showing our shortcut on the Home screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0c71732-d9bd-4752-af84-086fd7d0bbab.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this is just a shortcut to your app. The next recipe will go
    deeper by creating a Home screen (AppWidget).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `HomeScreenShortcut`. Use
    the default Phone & Tablet options and select the Empty Activity option when prompted
    for the Activity Type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For an app to create a shortcut, it must have the `INSTALL_SHORTCUT` permission.
    With the appropriate permission, it''s a simple matter of calling an intent with
    your app properties. The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest` file and add the following permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `activity_main.xml` and replace the existing TextView with the following
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method to `ActivityMain.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator. Notice that, each time you press the
    button, the app will make a shortcut on the Home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you set up the proper permission, this is a rather straightforward task.
    When the button is clicked, the code creates two intents. The first intent broadcasts
    to the OS that you want a shortcut created. The second intent is the intent that
    launches your app when the icon is pressed. One important consideration to keep
    in mind is that Home screens vary and may not support the `INSTALL_SHORTCUT` intent.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you also wanted to remove the shortcut, you would need the following permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the `INSTALL_SHORTCUT` action, you would set the following
    action instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Home screen widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dig into the code for creating an App Widget, let''s cover the basics.
    There are three required and one optional component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppWidgetProviderInfo` file: It''s an XML resource (described later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AppWidgetProvider class`: This is a Java class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `View layout` file: It''s a standard layout XML file, with some restrictions
    (explained later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The App Widget configuration Activity (optional): This is an Activity the OS
    will launch when placing the widget to provide configuration options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AppWidgetProvider` must also be declared in the `AndroidManifest` file.
    Since `AppWidgetProvider` is a helper class based on the Broadcast Receiver, it
    is declared in the manifest with the `<receiver>` element. Here is an example
    manifest entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The metadata points to the `AppWidgetProviderInfo` file, which is placed in
    the `res/xml` directory. Here is a sample `AppWidgetProviderInfo.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a brief overview of the available attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minWidth`: The default width when placed on the Home screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minHeight`: The default height when placed on the Home screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updatePeriodMillis`: It''s part of the `onUpdate()` polling interval (in milliseconds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialLayout`: The AppWidget layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previewImage` (optional): The image shown when browsing App Widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configure` (optional): The activity to launch for configuration settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resizeMode` (optional): The flags indicate resizing options: horizontal, vertical, none'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minResizeWidth` (optional): The minimum width allowed when resizing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minResizeHeight` (optional): The minimum height allowed when resizing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`widgetCategory` (optional): Android 5+ only supports Home screen widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AppWidgetProvider` extends the `BroadcastReceiver` class, which is why the `<receiver>` element is
    used when declaring the AppWidget in the Manifest. As it''s `BroadcastReceiver`,
    the class still receives OS broadcast events, but the helper class filters those
    events down to those applicable for an App Widget. The `AppWidgetProvider` class
    exposes the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onUpdate()`: It''s called when initially created and at the interval specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAppWidgetOptionsChanged()`: It''s called when initially created and any
    time the size changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDeleted()`: It''s called any time a widget is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onEnabled()`: It''s called the first time a widget is placed (it isn''t called
    when adding second and subsequent widgets).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDisabled()`: It''s called when the last widget is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onReceive()`: It''s called on every event received, including the preceding
    event. Usually not overridden as the default implementation only sends applicable
    events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last required component is the layout. An App Widget uses a Remote View,
    which only supports a subset of the available layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: AdapterViewFlipper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FrameLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GridLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GridView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinearLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ListView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RelativeLayout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StackView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ViewFlipper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And it supports the following widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: AnalogClock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chronometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageButton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ProgressBar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TextClock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TextView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With App Widget basics covered, it's now time to start coding. Our example will
    cover the basics so you can expand the functionality as needed. This recipe uses
    a View with a clock, which, when pressed, opens our activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the widget in the widget list when adding it
    to the Home screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24cd27b9-b7e1-4ac7-b7b3-b5634da66d8a.png)'
  prefs: []
  type: TYPE_IMG
- en: The purpose of the image is to show how to add a widget to the home screen
  prefs: []
  type: TYPE_NORMAL
- en: The widget list's appearance varies by the launcher used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot showing the widget after it is added to the Home screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acaa88e4-26cc-4f86-8bb8-623eddeaeda4.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it AppWidget. Use the default Phone
    & Tablet options and select the Empty Activity option when prompted for the Activity
    Type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by creating the widget layout, which resides in the standard layout
    resource directory. Then, we'll create the XML resource directory to store the `AppWidgetProviderInfo` file.
    We'll add a new Java class and extend `AppWidgetProvider`, which handles the `onUpdate()` call
    for the widget. With the receiver created, we can then add it to the Android Manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the detailed steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in `res/layout` called `widget.xml` using the following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory called XML in the resource directory. The final result
    will be `res/xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file in `res/xml` called `appwidget_info.xml` using the following
    XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you cannot see the new XML directory, switch from Android view to Project
    view in the Project panel drop-down.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class called `HomescreenWidgetProvider`, extending from `AppWidgetProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `onUpdate()` method to the `HomescreenWidgetProvider` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `HomescreenWidgetProvider` to the AndroidManifest using the following
    XML declaration within the `<application>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the program on a device or emulator. After first running the application,
    the widget will then be available to add to the Home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first step is to create the layout file for the widget. This is a standard
    layout resource with the restrictions based on the App Widget being a Remote View,
    as discussed in the recipe introduction. Although our example uses an Analog Clock
    widget, this is where you'd want to expand the functionality based on your application
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: The XML resource directory serves to store the AppWidgetProviderInfo, which
    defines the default widget settings. The configuration settings determine how
    the widget is displayed when initially browsing the available widgets. We use
    very basic settings for this recipe, but they can easily be expanded to include
    additional features, such as a preview image to show
  prefs: []
  type: TYPE_NORMAL
- en: a functioning widget and sizing options. The `updatePeriodMillis` attribute
    sets the update frequency. Since the update will wake up the device, it's a trade-off
    between having up-to-date data and battery life. (This is where the optional Settings
    Activity is useful by letting the user decide.)
  prefs: []
  type: TYPE_NORMAL
- en: The `AppWidgetProvider` class is where we handle the `onUpdate()` event triggered
    by the `updatePeriodMillis` polling. Our example doesn't need any updating so
    we set the polling to zero. The update is still called when initially placing
    the widget. `onUpdate()` is where we set the pending intent to open our app when
    the clock is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `onUpdate()` method is probably the most complicated aspect of AppWidgets,
    we'll explain this in some detail. First, it's worth noting that `onUpdate() `will
    occur only once each polling interval for all the widgets is created by this provider.
    (All additional widgets created will use the same cycle as the first widget created.)
    This explains the for loop, as we need it to iterate through all the existing
    widgets. This is where we create a pending intent, which calls our app when the
    clock widget is pressed. As discussed earlier, an AppWidget is a Remote View.
    Therefore, to get the layout, we call `RemoteViews()` with our fully qualified
    package name and the layout ID. Once we have the layout, we can attach the pending
    intent to the clock view using `setOnClickPendingIntent()`. We call the AppWidgetManager named `updateAppWidget()` to
    initiate the changes we made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to make all this work is to declare the widget in the Android
    Manifest. We identify the action we want to handle with the `<intent-filter>`.
    Most App Widgets will likely want to handle the Update event, as ours does. The
    other item to note in the declaration is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This tells the system where to find our configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding an App Widget configuration Activity allows greater flexibility with
    your widget. Not only can you offer polling options, but you could offer different
    layouts, click behaviors, and so on. Users tend to really appreciate flexible
    App Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a configuration Activity requires a few additional steps. The Activity
    needs to be declared in the Manifest as usual, but needs to include the `APPWIDGET_CONFIGURE` action,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The Activity also needs to be specified in the `AppWidgetProviderInfo` file
    using the configure attribute, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The configure attribute requires the fully qualified package name as this Activity
    will be called from outside of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the `onUpdate()` method will not be called when using a configuration
    Activity. The configuration Activity is responsible for handling any initial setup
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For App Widget Design Guidelines, visit Google's page: [http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For detailed information on RemoteViews, visit [https://developer.android.com/reference/android/widget/RemoteViews](https://developer.android.com/reference/android/widget/RemoteViews)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Search to the Action Bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the Action Bar, Android 3.0 introduced the SearchView widget, which can
    be included as a menu item when creating a menu. This is now the recommended UI
    pattern to provide a consistent user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the initial appearance of the Search icon in
    the Action Bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd37bc6b-7747-4d27-abca-bccde619583d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows how the Search option expands when pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8e33142-60e2-4c0f-b107-de4e0c850759.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to add Search functionality to your application, this recipe will
    walk you through the steps to set up your User Interface and properly configure
    the Search Manager API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `SearchView`. Use the default Phone
    & Tablet options and select Empty Activity when prompted for the Activity Type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up the Search UI pattern, we need to create the Search menu item and
    a resource called searchable. We''ll create a second activity to receive the search
    query. Then, we''ll hook it all up in the `AndroidManifest` file. To get started,
    open the `strings.xml` file in `res/values` and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following string resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Create the menu directory: `res/menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new menu resource called `menu_search.xml` in `res/menu` using the
    following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Open ActivityMain and add the following `onCreateOptionsMenu()` to inflate
    the menu and set up the Search Manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Create a new XML resource directory: `res/xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file in `res/xml` called `searchable.xml` using the following
    XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new layout called `activity_search_result.xml` using this XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Add a new Empty Activity to the project called `SearchResultActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following variable to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `onCreate()` to load our layout, set the TextView, and check for the QUERY action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method to handle the search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With the User Interface and code now complete, we just need to hook everything
    up correctly in the AndroidManifest. Here is the complete manifest, including
    both activities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run the application on a device or emulator. Type in a search query and hit
    the Search button (or press *Enter*). The SearchResultActivity will be displayed,
    showing the search query entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the New Project Wizard uses the AppCompat library, our example uses the
    support library API. Using the support library provides the greatest device compatibility
    as it allows the use of modern features (such as the Action Bar) on older versions
    of the Android OS. This can sometimes provide an extra challenge as often the
    official documentation focuses on the framework API. Although usually the support
    library closely follows the framework API, they are not always interchangeable.
    The Search UI pattern is one of those situations, so it's worth paying extra attention
    to the steps outlined previously.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating string resources for the Search View (which is declared
    later in step 6.)
  prefs: []
  type: TYPE_NORMAL
- en: In step 3, we create the menu resource, as we've done many times. One difference
    is that we use the app namespace for the `showAsAction` and `actionViewClass` attributes.
    The earlier versions of the Android OS don't include these attributes in the Android
    namespace, which is why we create an app namespace. This serves as a way to bring
    new functionality to older versions of the Android OS.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we set up the SearchManager, using the support library APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 is where we define the searchable XML resource, which is used by the SearchManager.
    The only required attribute is the label, but a hint is recommended so the user
    will have an idea of what they should type in the field.
  prefs: []
  type: TYPE_NORMAL
- en: The `android:label` must match the application name or the activity name and
    must use a string resource (as it does not work with a hardcoded string).
  prefs: []
  type: TYPE_NORMAL
- en: Steps 7-11 are for the `SearchResultActivity`. Calling the second activity is
    not a requirement of the SearchManager, but is commonly done to provide a single
    activity for all searches initiated in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ran the application at this point, you would see the search icon, but
    nothing would work. Step 12 is where we put it all together in the `AndroidManifest` file.
    The first item to note is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice this is in the `<application>` element and not in either of the `<activity>` elements.
    By defining it at the `<application>` level, it will automatically apply to all
    `<activities>`. If we moved it to the `MainActivity` element, it would behave
    exactly the same in our example.
  prefs: []
  type: TYPE_NORMAL
- en: You can define styles for your application in the `<application>` node and still
    override individual activity styles in the `<activity>` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify the searchable resource in the SearchResultActivity `<meta-data>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to set the intent filter for `SearchResultActivity` as we do here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The SearchManager broadcasts the SEARCH intent when the user initiates the
    search. This declaration directs the intent to the SearchResultActivity activity.
    Once the search is triggered, the query text is sent to the SearchResultActivity using
    the SEARCH intent. We check for the SEARCH intent in the `onCreate()` and extract
    the query string using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You now have the Search UI pattern fully implemented. With the UI pattern complete,
    what you do with the search results is specific to your application needs. Depending
    on your application, you might search a local database or maybe a web service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To take your search to the internet, see internet queries in [Chapter 13](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),* Telephony,
    Networks, and the Web.*
  prefs: []
  type: TYPE_NORMAL
- en: Showing your app full-screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android 4.4 (API 19) introduced a UI feature called Immersive Mode. Unlike
    the previous full-screen flag, your app receives all touch events while in Immersive
    Mode. This mode is ideal for certain activities, such as reading books and news,
    full-screen drawing, gaming, or watching a video. There are several different
    approaches to full-screen, and each has a best use case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading books/articles, and so on: Immersive Mode with easy access to the'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System UI
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Game/drawing app: Immersive Mode for full-screen use but minimal System UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Watching video: Full-screen and normal System UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key difference between the modes is how the System UI responds. In the first
    two scenarios, your app is expecting user interaction, so the System UI is hidden
    to make it easier for your user (such as not hitting the back button while playing
    a game). While using full-screen with a normal System UI, such as watching a video,
    you wouldn't expect your user to use the screen at all, so when they do the System
    UI should respond normally. In all modes, the user can bring back the System UI
    with a swipe inward across the hidden System Bar.
  prefs: []
  type: TYPE_NORMAL
- en: Since watching a video doesn't require the new Immersive Mode, full-screen mode
    can be achieved using two flags, `SYSTEM_UI_FLAG_FULLSCREEN` and `SYSTEM_UI_FLAG_HIDE_NAVIGATION`,
    available since Android 4.0 (API 14).
  prefs: []
  type: TYPE_NORMAL
- en: Our recipe will demonstrate setting up Immersive Mode. We're also going to add
    the ability to toggle the System UI with a tap on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and call it `ImmersiveMode`. Use the
    default Phone & Tablet options and select Empty Activity when prompted for the Activity
    Type. When selecting the Minimum API Level, choose API 19 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create two functions for handling the System UI visibility, then we''ll
    create a gesture listener to detect when the user taps on the screen. All the
    steps for this recipe are adding code to `MainActivity.java`, so open the file
    and let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to hide the System UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method to show the System UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `GestureListener` class at the class level, below the previous
    class variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onTouchEvent()` callback with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `onCreate()` method to set the GestureListener and
    hide the System UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Run the application on a device or emulator. Tapping the screen will toggle
    the System UI. Depending on your version of the Android OS, you can either swipe
    up from the bottom or swipe down from the top to reveal the System UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We call `setSystemUiVisibility()` with the appropriate flags in the `showSystemUI()` and `hideSystemUI()` methods
    to set the application window state. The flags we set (and don't set) control
    what is visible and what is hidden. When we set the visibility without the `SYSTEM_UI_FLAG_IMMERSIVE` flag,
    we in effect disable Immersive Mode.
  prefs: []
  type: TYPE_NORMAL
- en: If all we wanted to do was hide the System UI, we could just add `hideSystemUI()` to `onCreate()` and
    we'd be done. The problem is it wouldn't stay hidden. Once the user left Immersive
    Mode, it would stay in the regular display mode. That's why we created the `GestureListener`.
    (We'll discuss gestures again in [Chapter 9](9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml), *Using
    the Touchscreen and Sensors*.) Since we only want to respond to the `onSingleTapUp()` gesture,
    we don't implement the full range of gestures. When `onSingleTapUp` is detected,
    we toggle the System UI.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at some other important tasks that can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Sticky Immersion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's another option we can use if we want the System UI to stay hidden automatically.
    Instead of using `SYSTEM_UI_FLAG_IMMERSIVE` to hide the UI, we can use `SYSTEM_UI_FLAG_IMMERSIVE_STICKY`.
  prefs: []
  type: TYPE_NORMAL
- en: Dimming the System UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If all you need is to reduce the visibility of the Navigation bar, there's also `SYSTEM_UI_FLAG_LOW_PROFILE` to
    dim the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this flag with the same `setSystemUiVisibility()` call as the Immersive
    Mode flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `setSystemUiVisibility()` with 0 to clear all flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Setting the Action Bar as an overlay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you just need to hide or show the Action Bar, use these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'One problem with this approach is that the system resizes the layout each time
    either method is called. Instead, you might want to consider using a theme option
    to make the System UI behave as an overlay. To enable overlay mode, add the following
    to the theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Translucent system bars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two themes enable translucent settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are creating your own theme, use the following theme settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more on handling gestures, refer to [Chapter 9](9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml),* Using
    the Touchscreen and Sensors*.
  prefs: []
  type: TYPE_NORMAL
