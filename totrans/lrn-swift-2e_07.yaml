- en: Chapter 7. Everything Is Connected – Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。一切皆相连——内存管理
- en: When using an app, there is nothing worse than it being slow and unresponsive.
    Computer users have come to expect every piece of software to respond immediately
    to every interaction. Even the most feature-rich app will be ruined if it is unpleasant
    to use because it doesn't manage the device resources effectively. Also, with
    the growing popularity of mobile computers and devices, it is more important than
    ever to write software that uses battery power efficiently. One of the aspects
    of writing software that has the largest impact on both responsiveness and battery
    power is memory management.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个应用程序时，最糟糕的事情莫过于它运行缓慢且无响应。计算机用户已经习惯了每一款软件都能立即对每一次交互做出响应。即使是最功能丰富的应用程序，如果使用起来不愉快，因为它没有有效地管理设备资源，那么它也会被毁掉。此外，随着移动计算机和设备的日益普及，编写高效使用电池电力的软件比以往任何时候都更加重要。编写软件的方面中，对响应速度和电池寿命影响最大的是内存管理。
- en: 'In this chapter, we will discuss techniques specific to Swift that allow us
    to manage memory in order to ensure that our code remains responsive and minimizes
    its effect on battery life and other apps. We will do so by covering the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论Swift特有的技术，这些技术使我们能够管理内存，以确保我们的代码保持响应性并最小化其对电池寿命和其他应用程序的影响。我们将通过以下主题来实现这一点：
- en: Computer data storage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机数据存储
- en: Value types versus reference types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: Automatic reference counting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动引用计数
- en: Strong reference cycles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强引用循环
- en: Lost objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失踪的对象
- en: Structures versus classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体与类
- en: Computer data storage
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机数据存储
- en: Before we start looking at the code, we need to understand in some detail how
    data is represented in a computer. The common cliché is that all data in a computer
    is in 1s and 0s. This is true, but not so important when talking about memory
    management. Instead, we are concerned about *where* the data is stored. All computers,
    whether a desktop, laptop, tablet, or phone, store data in two places.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看代码之前，我们需要详细了解数据在计算机中的表示方式。常见的陈词滥调是计算机中的所有数据都是1和0。这是真的，但在讨论内存管理时并不那么重要。相反，我们关心的是数据存储的*位置*。所有计算机，无论是台式机、笔记本电脑、平板电脑还是手机，都在两个地方存储数据。
- en: The first place we normally think of is the file system. It is stored on a dedicated
    piece of hardware; this is called a hard disk drive in many computers, but more
    recently, some computers have started to use solid-state drives. The other thing
    we hear about when buying computers is the amount of "memory" it has. Computer
    memory comes in "sticks" which hold less information than normal drives. All data,
    even if primarily stored on the Internet somewhere, must be loaded into the computer's
    memory so that we can interact with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常首先想到的地方是文件系统。它存储在专门的硬件上；在许多计算机中，这被称为硬盘驱动器，但最近，一些计算机开始使用固态驱动器。当我们购买计算机时，我们还听说它有多少“内存”。计算机内存以“条”的形式出现，比普通驱动器存储的信息少。所有数据，即使主要存储在互联网上的某个地方，也必须加载到计算机的内存中，以便我们与之交互。
- en: Let's take a look at what that means for us as programmers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这对我们作为程序员意味着什么。
- en: File system
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统
- en: The file system is designed for long-term storage of data. It is far slower
    to access than memory, but it is much more cost effective for storing a lot of
    data. As the name implies, the file system is simply a hierarchical tree of files,
    which we as users can interact with directly using the *Finder* on a Mac. This
    file system still exists on iPhones and iPads but it is hidden from us. However,
    software can still read and write the file system, thus allowing us to store data
    permanently, even after turning the device off.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是为了长期存储数据而设计的。它的访问速度远慢于内存，但存储大量数据时成本效益更高。正如其名称所暗示的，文件系统只是一个文件的组织层次结构，我们可以通过Mac上的*Finder*直接与之交互。这个文件系统在iPhone和iPad上仍然存在，但它对我们来说是隐藏的。然而，软件仍然可以读取和写入文件系统，因此我们可以永久存储数据，即使在关闭设备之后。
- en: Memory
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: Memory is a little more complex than the file system. It is designed to store
    the necessary data, temporarily for the software running currently. Unlike with
    a file system, all memory is lost as soon as you turn off your device. The analogy
    is similar to how we humans have short-term and long-term memory. While we are
    having a conversation or thinking about something, we have a certain subset of
    the information we are actively thinking about and the rest is in our long-term
    memory. In order to actively think about something, we have to recall it from
    our long-term memory into our short-term memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内存比文件系统要复杂一些。它被设计用来存储当前运行的软件所需的必要数据，暂时存储。与文件系统不同，一旦关闭设备，所有内存都会丢失。这个类比类似于我们人类有短期和长期记忆。当我们正在交谈或思考某事时，我们正在积极思考的信息子集在我们的短期记忆中，其余的则在我们的长期记忆中。为了积极思考某事，我们必须将其从长期记忆中召回短期记忆。
- en: Memory is quick to access, but it is much more expensive. When computers start
    to act abnormally slow, it is commonly because it is very close to using up all
    of its memory. This is because the operating system will automatically start using
    the file system as a backup when memory is low. Information that is meant for
    short-term storage is automatically written to the file system instead, making
    it much slower to access again.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内存访问速度快，但成本更高。当计算机开始出现异常缓慢的反应时，通常是因为它几乎用完了所有的内存。这是因为当内存不足时，操作系统会自动开始使用文件系统作为备份。原本打算短期存储的信息会自动写入文件系统，这使得再次访问变得非常缓慢。
- en: This is similar to how we humans have a problem processing too much information
    at once. If we try to add two 20-digit numbers in our head, it is going to take
    us a long time or simply be impossible. Instead, we often write out the partial
    solution on paper, as we go along. In this case, the paper is acting as our file
    system. It would be faster if we could just remember everything instead of taking
    the time to write it down and read it back, but we simply can't process that much
    information at one time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于我们人类一次性处理过多信息时遇到的问题。如果我们试图在脑海中加两个20位的数字，这将花费我们很长时间，或者根本不可能完成。相反，我们通常会边做边在纸上写下部分解决方案。在这种情况下，纸张就充当了我们的文件系统。如果我们能记住所有东西，而不是花时间写下它并读回它，那会更快，但我们一次无法处理那么多信息。
- en: This is important to consider when programming because we want to reduce the
    amount of memory that we use at any given time. Using a lot of memory doesn't
    only negatively affect our own software; it can negatively affect the entire computer's
    performance. Also, when the operating system has to resort to using the file system,
    the extra processing and extra access to a second piece of hardware causes more
    power usage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时考虑这一点很重要，因为我们希望减少在任何给定时间使用的内存量。使用大量内存不仅会负面影响我们的软件，还会影响整个计算机的性能。此外，当操作系统不得不求助于使用文件系统时，额外的处理和访问第二块硬件会导致更多的能耗。
- en: Now that we understand our goal, we can start discussing how we manage memory
    better in Swift.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了我们的目标，我们可以开始讨论如何在Swift中更好地管理内存。
- en: Value types versus reference types
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: All variables and constants in Swift are stored in memory. In fact, unless you
    explicitly write data to the file system, everything you create is going to be
    in memory. In Swift, there are two different categories of types. These two categories
    are **value types** and **reference types**. The only way in which they differ
    is in the way they behave when they get assigned to new variables, passed into
    methods, or captured in closures. Essentially, they only differ when you try to
    assign a new variable or constant to the value of an existing variable or constant.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的所有变量和常量都存储在内存中。实际上，除非你明确地将数据写入文件系统，否则你创建的所有东西都将存储在内存中。在Swift中，有两种不同类型的类别。这两个类别是**值类型**和**引用类型**。它们之间的唯一区别在于它们在分配给新变量、传递给方法或捕获在闭包中的行为方式。本质上，它们只在尝试将新变量或常量的值分配给现有变量或常量时有所不同。
- en: A value type is always copied when being assigned somewhere new while a reference
    type is not. Before we look at exactly what that means in more detail, let's go
    over how we determine if a type is a value type or a reference type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型在被分配到新的位置时总是被复制，而引用类型则不是。在我们详细探讨这究竟意味着什么之前，让我们先了解一下如何确定一个类型是值类型还是引用类型。
- en: Determining value type or reference type
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定值类型或引用类型
- en: A value type is any type that is defined as either a structure or an enumeration,
    while all classes are reference types. This is easy to determine for your own
    custom types based on how you declared them. Beyond that, all of the built-in
    types for Swift, such as strings, arrays, and dictionaries are value types. If
    you are ever uncertain, you can test any of the two types you want in a playground,
    to see if its behavior is consistent with a value type or a reference type. The
    simplest behavior to check is what happens on assignment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型是指定义为结构体或枚举的任何类型，而所有类都是引用类型。根据你如何声明它们，你可以很容易地确定你自己的自定义类型。除此之外，Swift的所有内置类型，如字符串、数组和字典，都是值类型。如果你不确定，你可以在游乐场中测试任何两种类型，看看它们的行为是否与值类型或引用类型一致。最简单的行为检查是在赋值时发生的情况。
- en: Behavior on assignment
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值时的行为
- en: 'When a value type is reassigned, it is copied so that afterwards each variable
    or constant holds a distinct value that can be changed independently. Let''s take
    a look at a simple example using a string:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当值类型被重新赋值时，它会复制，这样之后每个变量或常量都持有可以独立更改的独立值。让我们通过一个简单的字符串示例来看看：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, when `value2` is set to `value1` a copy gets created. This
    is so that when we append `" World!"` to `value1`, `value2` remains unchanged,
    as `"Hello"`. We can visualize them as two completely separate entities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当`value2`被设置为`value1`时，会创建一个副本。这样，当我们向`value1`追加`" World!"`时，`value2`保持不变，仍然是`"Hello"`。我们可以将它们视为两个完全独立的实体：
- en: '![Behavior on assignment](img/B05103_07_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![行为在赋值时的表现](img/B05103_07_01.jpg)'
- en: 'On the other hand, let''s take a look at what happens with a reference type:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，让我们看看引用类型会发生什么：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, when we changed the name of `reference1`, `reference2` was
    also changed. So why is this? As the name implies, reference types are simply
    references to an instance. When you assign a reference to another variable or
    constant, both are actually referring to the exact same instance. We can visualize
    it as two separate objects referencing the same instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们更改`reference1`的名称时，`reference2`也发生了变化。那么这是为什么？正如其名所示，引用类型仅仅是实例的引用。当你将一个引用赋给另一个变量或常量时，两者实际上都指向同一个实例。我们可以将其视为两个单独的对象引用同一个实例：
- en: '![Behavior on assignment](img/B05103_07_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![行为在赋值时的表现](img/B05103_07_02.jpg)'
- en: In the real world, this would be like two kids sharing a toy. Both can play
    with the toy but if one breaks the toy, it is broken for both kids.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，这就像两个孩子分享一个玩具。他们都可以玩这个玩具，但如果其中一个孩子弄坏了玩具，两个孩子的玩具都会坏。
- en: 'However, it is important to realize that if you assign a reference type to
    a new value, it does not change the value it was originally referencing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要意识到，如果你将引用类型赋值给新的值，它不会改变它最初引用的值：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we assigned `reference2` to an entirely different `Person`
    instance, so they can now be manipulated independently. We can then visualize
    this as two separate references on two separate instances, as shown in the following
    image:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将`reference2`赋值给了完全不同的`Person`实例，因此它们现在可以独立操作。我们可以将它们视为两个不同实例上的两个单独引用，如下面的图像所示：
- en: '![Behavior on assignment](img/B05103_07_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![行为在赋值时的表现](img/B05103_07_03.jpg)'
- en: This will be like buying a new toy for one of the kids.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像给其中一个孩子买了一个新玩具。
- en: This shows you that a reference type is actually a special version of a value
    type. The difference is that a reference type is not itself an instance of any
    type. It is simply a way to refer to another instance, sort of like a placeholder.
    You can copy the reference so that you have two variables referencing the same
    instance, or you can give a variable a completely new reference to a new instance.
    With reference types, there is an extra layer of indirection based on sharing
    instances between multiple variables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明引用类型实际上是值类型的一个特殊版本。区别在于引用类型本身不是任何类型的实例。它只是引用另一个实例的一种方式，有点像占位符。你可以复制引用，以便有两个变量引用同一个实例，或者你可以给一个变量一个指向新实例的完全新的引用。在引用类型中，基于多个变量之间共享实例，存在一个额外的间接层。
- en: Now that we know this, the simplest way to verify if a type is a value type
    or a reference type is to check its behavior when being assigned. If the second
    value is changed when you modify the first value, it means that the type you are
    testing is a reference type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这一点，验证一个类型是值类型还是引用类型最简单的方法是检查它在赋值时的行为。如果你修改第一个值时第二个值发生了变化，这意味着你正在测试的类型是引用类型。
- en: Behavior on input
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入时的行为
- en: 'Another place where the behavior of a value type differs from a reference type
    is when passing them into functions and methods. However, the behavior is very
    simple to remember if you look at passing a variable or constant into a function
    as just another assignment. This means that when you pass a value type into a
    function, it is copied while a reference type still shares the same instance:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值类型的行为与引用类型不同的地方是在将它们传递到函数和方法中时。然而，如果你将传递变量或常量到函数视为另一种赋值操作，那么这种行为的记忆就会变得非常简单。这意味着当你将值类型传递到函数中时，它会被复制，而引用类型仍然共享相同的实例：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we have defined a function that takes both a reference type: `Person`
    and a value type: `String`. When we update the `Person` type within the function,
    the person we passed in is also changed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个函数，它接受一个引用类型：`Person`和一个值类型：`String`。当我们函数内部更新`Person`类型时，我们传入的人员也会发生变化：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, when we change the string within the function, the `String` passed
    into it remains unchanged.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们函数内部更改字符串时，传入的`String`保持不变。
- en: 'The place where things get a little more complicated is with `inout` parameters.
    An `inout` parameter is actually a reference to the passed-in instance. This means
    that, it will treat a value type as if it were a reference type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情变得稍微复杂一些时，是关于`inout`参数。`inout`参数实际上是对传入实例的引用。这意味着它将值类型视为引用类型：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, when we changed the `inout` version of `string` within the function,
    it also changed the `someString` variable outside of the function just as if it
    were a reference type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们函数内部更改了`inout`版本的`string`时，它也改变了函数外部的`someString`变量，就像它是一个引用类型一样。
- en: 'If we remember that a reference type is just a special version of a value type
    where the value is a reference, we can infer what will be possible with an `inout`
    version of a reference type. When we define an `inout` reference type, we actually
    have a reference *to a reference*; this reference is then the one that is pointing
    to a reference. We can visualize the difference between an `inout` value type
    and an `inout` reference type as shown:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记住引用类型只是值类型的一个特殊版本，其中值是一个引用，那么我们可以推断出引用类型的`inout`版本将可能实现什么。当我们定义一个`inout`引用类型时，我们实际上有一个指向引用的引用；这个引用就是指向引用的那个引用。我们可以将`inout`值类型和`inout`引用类型之间的区别可视化如下：
- en: '![Behavior on input](img/B05103_07_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![输入行为](img/B05103_07_04.jpg)'
- en: 'If we simply change the value of this variable, we will get the same behavior
    as if it were not an `inout` parameter. However, we can also change where the
    inner reference is referring to by declaring it as an `inout` parameter:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地更改这个变量的值，我们会得到与它不是`inout`参数时相同的行为。然而，我们也可以通过将其声明为`inout`参数来更改内部引用的指向：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We start by creating a second reference: `person2` to the same instance as
    the `person` variable that currently has the name `"Jamison"` from before. After
    this, we pass the original `person` variable into our `updatePerson:` method and
    have this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建第二个引用：`person2`，指向与之前具有名字`"Jamison"`的`person`变量相同的实例。之后，我们将原始的`person`变量传递到我们的`updatePerson:`方法中，得到以下结果：
- en: '![Behavior on input](img/B05103_07_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![输入行为](img/B05103_07_05.jpg)'
- en: 'In this method, we first change the name of the existing person to a new name.
    We can see in the output that the name of `person2` has also changed, because
    both `insidePerson` inside the function and `person2` are still referencing the
    same instance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先将现有人员的名字更改为新名字。我们可以从输出中看到`person2`的名字也发生了变化，因为函数内部的`insidePerson`和`person2`仍然引用着相同的实例：
- en: '![Behavior on input](img/B05103_07_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![输入行为](img/B05103_07_06.jpg)'
- en: 'However, we then also assign `insidePerson` to a completely new instance of
    the `Person` reference type. This results in `person` and `person2` outside of
    the function pointing at two completely different instances of `Person` leaving
    the name of `person2` to be `"New Name"` and updating the name of `person` to
    `"New Person"`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们随后也将`insidePerson`赋值给`Person`引用类型的一个全新的实例。这导致函数外部的`person`和`person2`指向两个完全不同的`Person`实例，使得`person2`的名字变为`"New
    Name"`，并将`person`的名字更新为`"New Person"`：
- en: '![Behavior on input](img/B05103_07_07.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![输入行为](img/B05103_07_07.jpg)'
- en: Here, by defining `insidePerson` as an `inout` parameter, we were able to change
    where the passed-in variable was referencing. It can help us to visualize all
    the different types as one type pointing to another.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过将`insidePerson`定义为`inout`参数，我们能够改变传入变量的引用位置。这有助于我们将所有不同的类型视为一个类型指向另一个类型。
- en: At any point, any of these arrows can be pointed at something new using an assignment
    and the instance can always be accessed through the references.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，这些箭头中的任何一个都可以通过赋值指向新的内容，实例始终可以通过引用来访问。
- en: Closure capture behavior
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包捕获行为
- en: 'The last behavior we have to worry about is when variables are captured within
    closures. This is what we did not cover about closures in [Chapter 5](ch05.html
    "Chapter 5. A Modern Paradigm – Closures and Functional Programming"), *A Modern
    Paradigm – Closures and Functional Programming*. Closures can actually use the
    variables that were defined in the same scope as the closure itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须关注的最后一个行为是当变量在闭包中被捕获时。这是我们之前在[第5章](ch05.html "第5章. 现代范式 – 闭包和函数式编程")中未涵盖的闭包内容，*现代范式
    – 闭包和函数式编程*。闭包实际上可以使用与闭包本身相同作用域中定义的变量：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is very different from normal parameters that we have seen before. We actually
    do not specify `nameToPrint` as a parameter, nor do we pass it in when calling
    the method. Instead, the closure captures the `nameToPrint` variable that is defined
    before it. These types of captures act similarly to `inout` parameters in functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的正常参数非常不同。我们实际上并没有将`nameToPrint`指定为参数，也没有在调用方法时传递它。相反，闭包捕获了定义在其之前的`nameToPrint`变量。这些类型的捕获在函数中类似于`inout`参数。
- en: 'When a value type is captured, it can be changed and it will change the original
    value as well:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获值类型时，它可以被更改，并且会改变原始值：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, `outsideName` was changed after the closure was called. This
    is exactly like an `inout` parameter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`outsideName`在调用闭包后被更改了。这正好像一个`inout`参数。
- en: 'When a reference type is captured, any changes will also be applied to the
    outside version of the variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获引用类型时，任何更改也将应用于变量的外部版本：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is also exactly like an `inout` parameter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这也正好像一个`inout`参数。
- en: 'The other part of closure capture that we need to keep in mind is that changing
    the captured value after the closure is defined will still affect the value within
    the closure. We can take advantage of this to use the `printName` closure we defined
    in the preceding section to print any name:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的关于闭包捕获的另一个部分是，在闭包定义之后更改捕获的值仍然会影响闭包内的值。我们可以利用这一点来使用我们在上一节中定义的`printName`闭包来打印任何名称：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we can change what `printName` prints out by changing the value
    of `nameToPrint`. This behavior is actually very hard to track down when it happens
    accidently, so it is usually a good idea to avoid capturing variables in closures
    whenever possible. In this case, we are taking advantage of the behavior, but
    more often than not, it will cause bugs. Here, it would be better to pass what
    we want to print as an argument.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们可以通过更改`nameToPrint`的值来更改`printName`打印的内容。实际上，这种行为在意外发生时很难追踪，因此通常最好尽可能避免在闭包中捕获变量。在这种情况下，我们正在利用这种行为，但大多数情况下，它会导致错误。在这里，最好将我们想要打印的内容作为参数传递。
- en: 'Another way to avoid this behavior is to use a feature called **capture lists**.
    With this, you can specify the variables that you want to capture by copying them:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种行为的另一种方法是使用一个名为**捕获列表**的功能。使用它，你可以通过复制来指定你想要捕获的变量：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A capture list is defined at the beginning of a closure before any parameter.
    It is a comma-separated list of all the variables being captured, which we want
    to copy within square brackets. In this case, we requested `nameToPrint` to be
    copied, so when we change it later, it does not affect the value that is printed
    out. We will see more advanced uses of capture lists later in this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获列表是在闭包的开始处定义的，在任何一个参数之前。它是由逗号分隔的变量列表，我们想要在方括号内复制这些变量。在这种情况下，我们请求复制`nameToPrint`，因此当我们稍后更改它时，它不会影响打印出的值。我们将在本章后面看到捕获列表的更高级用法。
- en: Automatic reference counting
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动引用计数
- en: Now that we understand the different ways in which data is represented in Swift,
    we can look into how we can manage the memory better. Every instance that we create
    takes up memory. Naturally, it wouldn't make sense to keep all data around forever.
    Swift needs to be able to free up memory so that it can be used for other purposes,
    once our program doesn't need it anymore. This is the key to managing memory in
    our apps. We need to make sure that Swift can free up all the memory that we no
    longer need, as soon as possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Swift 中数据表示的不同方式，我们可以探讨如何更好地管理内存。我们创建的每个实例都会占用内存。自然地，永远保留所有数据是没有意义的。Swift
    需要能够释放内存，以便它可以用于其他目的，一旦我们的程序不再需要它。这是我们管理应用程序内存的关键。我们需要确保 Swift 能够尽快释放我们不再需要的所有内存。
- en: The way that Swift knows it can free up memory is when the code can no longer
    access an instance. If there is no longer any variable or constant referencing
    an instance, it can be repurposed for another instance. This is called "freeing
    the memory" or "deleting the object".
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 知道何时可以释放内存，是因为代码无法再访问一个实例。如果没有变量或常量引用一个实例，它就可以被重新用于另一个实例。这被称为“释放内存”或“删除对象”。
- en: 'In [Chapter 3](ch03.html "Chapter 3. One Piece at a Time – Types, Scopes, and
    Projects"), *One Piece at a Time – Types, Scopes, and Projects* we already discussed
    when a variable is accessible or not in the section about scopes. This makes memory
    management very simple for value types. Since value types are always copied when
    they are reassigned or passed into functions, they can be immediately deleted
    once they go out of scope. We can look at a simple example to get the full picture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。一次一件——类型、作用域和项目") 的 *一次一件——类型、作用域和项目* 中，我们已经讨论了变量何时可访问或不可访问的问题，这部分内容在作用域部分进行了讨论。这使得值类型的内存管理变得非常简单。由于值类型在重新分配或传递给函数时总是被复制，因此一旦它们超出作用域，就可以立即删除。我们可以通过一个简单的例子来全面了解：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have a very simple function that prints out "Hello World!". When `printSomething`
    is called, `something` is assigned to a new instance of `String` with the value
    `"Hello World!"`. After `print` is called, the function exits and therefore `something`
    is no longer in scope. At that point, the memory being taken up by `something`
    can be freed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的函数，它会打印出 "Hello World!"。当调用 `printSomething` 时，`something` 被分配给一个新的
    `String` 实例，其值为 `"Hello World!"`。在调用 `print` 之后，函数退出，因此 `something` 就不再在作用域内了。此时，`something`
    所占用的内存可以被释放。
- en: While this is very simple, reference types are much more complex. At a high
    level, an instance of a reference type is deleted at the point that there is no
    longer any reference to the instance in scope anymore. This is relatively straightforward
    to understand but it gets more complex in the details. The Swift feature that
    manages this is called **Automatic Reference Counting** or **ARC** for short.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很简单，但引用类型要复杂得多。从高层次来看，引用类型的实例在作用域内不再有任何引用时被删除。这相对容易理解，但在细节上会更复杂。管理这一功能的 Swift
    特性被称为 **自动引用计数** 或简称 **ARC**。
- en: Object relationships
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象关系
- en: 'The key to ARC is that every object has relationships with one or more variables.
    This can be extended to include the idea that all objects have a relationship
    with other objects. For example, a car object would contain objects for its four
    tires, engine, and so on. It will also have a relationship with its manufacturer,
    dealership, and owner. ARC uses these relationships to determine when an object
    can be deleted. In Swift, there are three different types of relationships: **strong**,
    **weak**, and **unowned**.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自动引用计数（ARC）的关键是每个对象都与一个或多个变量有关。这可以扩展到所有对象都与其他对象有关的概念。例如，一个汽车对象会包含其四个轮胎、引擎等对象。它还会与制造商、经销商和车主有关。ARC
    使用这些关系来确定何时可以删除对象。在 Swift 中，有三种不同类型的关系：**强引用**、**弱引用**和**非拥有引用**。
- en: Strong
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强大
- en: The first, and default type of relationship is a strong relationship. It says
    that a variable requires the instance it is referring to always exist, as long
    as the variable is still in scope. This is the only behavior available for value
    types. When an instance no longer has any strong relationships to it, it will
    be deleted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种，也是默认类型的关系是强关系。它表示变量需要它所引用的实例始终存在，只要变量仍在作用域内。这是值类型可用的唯一行为。当一个实例不再有任何强关系时，它将被删除。
- en: 'A great example of this type of relationship is with a car that must have a
    steering wheel:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系的一个很好的例子是必须有一个方向盘的汽车：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By default, the `steeringWheel` property has a strong relationship to the `SteeringWheel`
    instance it is initialized with. Conceptually, this means that the car itself
    has a strong relationship to the steering wheel. As long as a car exists, it must
    have a relationship to a steering wheel that exists. Since `steeringWheel` is
    declared as a variable, we could change the steering wheel of the car, which would
    remove the old strong relationship and add a new one, but a strong relationship
    will always exist.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`steeringWheel`属性与它初始化时关联的`SteeringWheel`实例有一个强关系。从概念上讲，这意味着汽车本身与方向盘有一个强关系。只要汽车存在，它就必须与一个存在的方向盘有关联。由于`steeringWheel`被声明为一个变量，我们可以更改汽车的方向盘，这将消除旧的强关系并添加一个新的，但强关系始终存在。
- en: 'If we were to create a new instance of `Car` and store it in a variable, that
    variable would have a strong relationship to the car:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个新的`Car`实例并将其存储在一个变量中，那么这个变量将与汽车有一个强关系：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lets break down all the relationships in this code. First we create the `wheel`
    constant and assign it to a new instance of `SteeringWheel`. This sets up a strong
    relationship from `wheel` to the new instance. We do the same thing with the `car`
    constant, but this time we also pass in the `wheel` constant to the initializer.
    Now, not only does `car` have a strong relationship to the new `Car` instance,
    but the `Car` initializer also creates a strong relationship from the `steeringWheel`
    property to the same instance as the `wheel` constant:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码中的所有关系。首先，我们创建`wheel`常量并将其分配给一个新的`SteeringWheel`实例。这从`wheel`到新实例建立了一个强关系。我们用`car`常量做同样的事情，但这次我们还向初始化器传递了`wheel`常量。现在，不仅`car`与新的`Car`实例有一个强关系，而且`Car`初始化器还从`steeringWheel`属性到与`wheel`常量相同的实例建立了一个强关系：
- en: '![Strong](img/B05103_07_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![强关系](img/B05103_07_08.jpg)'
- en: 'So what does this relationship graph mean for memory management? At this time,
    the `Car` instance has one strong relationship: the `car` constant, and the `SteeringWheel`
    instance has two strong relationships: the `wheel` constant and the `steeringWheel`
    property of the `Car` instance.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这种关系图对内存管理意味着什么呢？此时，`Car`实例有一个强关系：`car`常量，而`SteeringWheel`实例有两个强关系：`wheel`常量和`Car`实例的`steeringWheel`属性。
- en: This means that the `Car` instance will be deleted as soon as the `car` constant
    goes out of scope. On the other hand, the `SteeringWheel` instance will only be
    deleted after both the `wheel` constant goes out of scope and the `Car` instance
    is deleted.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦`car`常量超出作用域，`Car`实例就会被删除。另一方面，`SteeringWheel`实例只有在`wheel`常量超出作用域且`Car`实例被删除之后才会被删除。
- en: You can envision a strong reference counter on every instance in your program.
    Every time a strong relationship is setup to an instance the counter goes up.
    Every time an object strongly referencing it gets deleted, the counter goes down.
    If that counter ever goes back to zero, the instance is deleted.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象在你的程序中的每个实例都有一个强引用计数器。每次设置一个强关系到实例时，计数器就会增加。每次一个强引用对象被删除时，计数器就会减少。如果那个计数器回到零，实例就会被删除。
- en: The other important thing to realize is that all relationships are only in one
    direction. Just because the `Car` instance has a strong relationship to the `SteeringWheel`
    instance does not mean that the `SteeringWheel` instance has any relationship
    back. You could add your own relationship back by adding a car property to the
    `SteeringWheel` class, but you have to be careful when doing this, as we will
    see in the strong reference cycle section coming up.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是，所有关系都是单向的。仅仅因为`Car`实例与`SteeringWheel`实例有一个强关系，并不意味着`SteeringWheel`实例有任何反向关系。你可以通过向`SteeringWheel`类中添加一个汽车属性来添加自己的反向关系，但当你这样做时必须小心，正如我们将在接下来的强引用循环部分中看到的。
- en: Weak
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弱
- en: The next type of relationship in Swift is a weak relationship. It allows one
    object to reference another without enforcing that it always exists. A weak relationship
    does not contribute to the reference counter of an instance, which means that
    the addition of a weak relationship does not increase the counter nor does it
    decrease the counter when removed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的下一种关系类型是弱关系。它允许一个对象引用另一个对象，而不强制要求它始终存在。弱关系不会对实例的引用计数器做出贡献，这意味着弱关系的添加不会增加计数器，也不会在移除时减少计数器。
- en: 'Since a weak relationship cannot guarantee that it will always exist, it must
    always be defined as an optional. A weak relationship is defined using the `weak`
    keyword before the variable declaration:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于弱关系不能保证它始终存在，它必须始终定义为可选的。弱关系是在变量声明前使用`weak`关键字定义的：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This allows a `SteeringWheel` to have a car assigned to it, without enforcing
    that the car never be deleted. The car initializer can then assign this backwards
    reference to itself:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许`SteeringWheel`分配一个汽车，而不强制要求汽车永远不会被删除。然后，汽车初始化器可以将这个反向引用分配给自己：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the car is ever deleted, the car property of `SteeringWheel` will automatically
    be set to nil. This allows us to gracefully handle the scenario that a weak relationship
    refers to an instance that has been deleted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果汽车被删除，`SteeringWheel`的汽车属性将自动设置为nil。这允许我们优雅地处理弱关系引用已删除实例的场景。
- en: Unowned
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无所有者
- en: The final type of relationship is an unowned relationship. This relationship
    is almost identical to a weak relationship. It also allows one object to reference
    another without contributing to the strong reference count. The only difference
    is that an unowned relationship does not need to be declared as optional and it
    uses the `unowned` keyword instead of `weak`. It acts similar to an implicitly
    unwrapped optional. You can interact with an unowned relationship as if it were
    a strong relationship, but if the unowned instance has been deleted and you try
    to access it, your entire program will crash. This means that you should only
    use unowned relationships in scenarios where the unowned object will never actually
    be deleted while the primary object still exists.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种关系类型是无所有者关系。这种关系几乎与弱关系相同。它也允许一个对象引用另一个对象，而不增加强引用计数。唯一的区别是，无所有者关系不需要声明为可选的，并且使用`unowned`关键字而不是`weak`。它类似于隐式展开的可选类型。你可以像对待强关系一样与无所有者关系交互，但如果无所有者实例已被删除而你尝试访问它，你的整个程序将会崩溃。这意味着你应该只在无所有者对象在主要对象仍然存在的情况下永远不会实际被删除的场景中使用无所有者关系。
- en: You may ask then, "Why would we not always use a strong relationship instead?"
    The answer is that sometimes unowned or weak references are needed to break something
    called a **strong reference cycle**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“为什么我们不会总是使用强关系呢？”答案是，有时需要无所有者或弱引用来打破称为**强引用循环**的东西。
- en: Strong reference cycles
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强引用循环
- en: A strong reference cycle is when two instances directly or indirectly hold strong
    references to each other. This means that neither object can ever be deleted,
    because both are ensuring that the other will always exist.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 强引用循环是指两个实例直接或间接持有对彼此的强引用。这意味着两个对象都无法被删除，因为它们都在确保对方将始终存在。
- en: This scenario is our first really bad memory management scenario. It is one
    thing to keep memory around longer than it is needed; it is a whole different
    level to create memory that can never be freed up to be reused again. This type
    of memory problem is called a memory leak, because the computer will slowly leak
    memory until there is no longer any new memory available. This is why you will
    sometimes see a speed improvement after restarting your device. Upon restart,
    all of the memory is freed up again. Modern operating systems will sometimes find
    ways to forcefully free up memory, especially when completely quitting an app,
    but we cannot rely on this as programmers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景是我们遇到的第一种真正糟糕的内存管理场景。保留比所需更长时间的内存是一回事；创建永远无法释放以供再次使用的内存则是完全不同的层次。这种内存问题被称为内存泄漏，因为计算机将逐渐泄漏内存，直到没有更多可用的新内存。这就是为什么你有时会在重启设备后看到速度提升的原因。重启时，所有内存都会再次释放。现代操作系统有时会找到强制释放内存的方法，尤其是在完全退出应用程序时，但我们作为程序员不能依赖这一点。
- en: 'So how can we prevent these strong reference cycles? First, let''s take a look
    at what they look like. There are two main scenarios where these cycles can exist:
    between objects and with closures.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何防止这些强引用循环呢？首先，让我们看看它们是什么样子。这些循环可以存在的两种主要场景是：在对象之间以及与闭包一起。
- en: Between objects
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在对象之间
- en: A strong reference cycle between objects is when two types directly or indirectly
    contain strong references to each other.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对象之间的强引用循环是指两种类型直接或间接包含对彼此的强引用。
- en: Spotting
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现
- en: 'A great example of a strong reference cycle between objects is if we rewrite
    our preceding car example without using a weak reference from `SteeringWheel`
    to `Car`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用从`SteeringWheel`到`Car`的弱引用重写前面的汽车示例，那么这是一个对象之间强引用循环的绝佳例子：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only difference between this code and the preceding code is that the `car`
    property on `SteeringWheel` is no longer declared as weak. This means that when
    a car is created, it will set up a strong relationship to the `SteeringWheel`
    instance and then create a strong reference from the `SteeringWheel` instance
    back to the car:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的代码相比，唯一的区别是`SteeringWheel`上的`car`属性不再声明为弱引用。这意味着当创建一个汽车时，它将设置与`SteeringWheel`实例的强关系，然后从`SteeringWheel`实例创建对汽车的强引用：
- en: '![Spotting](img/B05103_07_09.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Spotting](img/B05103_07_09.jpg)'
- en: This scenario means that the reference count of both instances can never go
    down to zero and therefore they will never be deleted and the memory will be leaked.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景意味着两个实例的引用计数永远不会降到零，因此它们永远不会被删除，内存将会泄漏。
- en: 'Two objects can also indirectly hold strong references to each other through
    one or more third parties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象也可以通过一个或多个第三方间接地相互持有强引用：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have the scenario where a `Car` can have a strong reference to a `SteeringWheel`
    that can have a strong reference to a `Manufacturer` that in turn has a strong
    reference to the original `Car`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个场景，一个`Car`可以有一个对`SteeringWheel`的强引用，而`SteeringWheel`可以有一个对`Manufacturer`的强引用，反过来，`Manufacturer`又有一个对原始`Car`的强引用：
- en: '![Spotting](img/B05103_07_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Spotting](img/B05103_07_10.jpg)'
- en: This is another strong reference cycle and it illustrates two more important
    points. First, optionals, by default, still create strong relationships when not
    nil. Also, the built in container types, such as arrays and dictionaries, also
    create strong relationships.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个强引用循环，它说明了两个更重要的点。首先，默认情况下，可选类型仍然在非nil时创建强关系。此外，内置容器类型，如数组和字典，也会创建强关系。
- en: Clearly strong reference cycles can be difficult to spot, especially because
    they are hard to detect in the first place. An individual memory leak is rarely
    going to be noticeable to a user of your program, but if you continuously leak
    memory over and over again, it can cause their device to feel sluggish or even
    crash.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，强引用循环可能很难被发现，尤其是因为它们一开始就很难检测。单个内存泄漏很少会对你程序的用户明显，但如果你一次又一次地持续泄漏内存，它可能会导致他们的设备运行缓慢甚至崩溃。
- en: The best way as a developer to detect them is to use a tool built into Xcode
    called **Instruments**. Instruments can do many things, but one of those things
    is called **Leaks**. To run this tool you must have an Xcode Project; you cannot
    run it on a Playground. It is run by selecting **Product** | **Profile** from
    the menu bar.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，检测它们最好的方式是使用Xcode内置的工具**Instruments**。Instruments可以执行许多任务，但其中之一被称为**Leaks**。要运行此工具，你必须有一个Xcode项目；你不能在Playground上运行它。它通过从菜单栏中选择**Product**
    | **Profile**来运行。
- en: 'This will build your project and display a series of profiling tools:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建你的项目并显示一系列分析工具：
- en: '![Spotting](img/B05103_07_11.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Spotting](img/B05103_07_11.jpg)'
- en: 'If you select the **Leaks** tool and press the record button in the upper-left
    corner, it will run your program and warn you of memory leaks which it can detect.
    A memory leak will look like a red X icon and will be listed as a leaked object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择**Leaks**工具并按下左上角的记录按钮，它将运行你的程序并警告你内存泄漏，它可以检测到。内存泄漏将看起来像红色的X图标，并将列为泄漏的对象：
- en: '![Spotting](img/B05103_07_12.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Spotting](img/B05103_07_12.jpg)'
- en: 'You can even select the **Cycles & Roots** view for the leaked objects and
    Instruments will show you a visual representation of your strong reference cycle.
    In the following screenshot, you can see that there is a cycle between `SteeringWheel`
    and `Car`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以选择泄漏对象的**Cycles & Roots**视图，Instruments将显示你的强引用循环的视觉表示。在下面的屏幕截图中，你可以看到`SteeringWheel`和`Car`之间存在循环：
- en: '![Spotting](img/B05103_07_13.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Spotting](img/B05103_07_13.jpg)'
- en: Clearly, Leaks is a powerful tool and you should run it periodically on your
    code, but it will not catch all strong reference cycles. The last line of defense
    is going to be you staying vigilant with your code, always thinking about the
    ownership graph.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Leaks是一个强大的工具，你应该定期在你的代码上运行它，但它不会捕获所有的强引用循环。最后的防线将是你保持对代码的警惕，始终思考所有权图。
- en: Of course, spotting cycles is only part of the battle. The other part of the
    battle is fixing them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，检测循环只是战斗的一部分。战斗的另一部分是修复它们。
- en: Fixing
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复
- en: The easiest way to break a strong reference cycle is to simply remove one of
    the relationships completely. However, this is very often not going to be an option.
    A lot of the time, it is important to have a two-way relationship.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 打破强引用循环的最简单方法是简单地完全移除其中一个关系。然而，这通常不是一个选择。很多时候，保持双向关系很重要。
- en: The way we fix cycles without completely removing a relationship is to make
    one or more of the relationships weak or unowned. In fact, this is the main reason
    that these other two types of relationships exist.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复循环的方法是使一个或多个关系变为弱引用或未拥有。实际上，这正是其他两种关系存在的主要原因。
- en: 'We fix the strong reference cycle in our original example by changing the car
    relationship back to weak:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将汽车关系改回弱引用来修复原始示例中的强引用循环：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now `Car` has a strong reference to `SteeringWheel` but there is only a weak
    reference back:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Car`对`SteeringWheel`有强引用，但只有弱引用回传：
- en: '![Fixing](img/B05103_07_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![修复](img/B05103_07_14.jpg)'
- en: How you break any given cycle is going to depend on your implementation. The
    only important part is that somewhere in the cycle of references there is a weak
    or unowned relationship.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何打破任何给定的循环将取决于你的实现。唯一重要的是，在引用循环中某处有一个弱引用或未拥有关系。
- en: 'Unowned relationships are good for scenarios where the connection will never
    be missing. In our example, there are times that a `SteeringWheel` exists without
    a car reference. If we change it so that the `SteeringWheel` is created in the
    `Car` initializer, we could make the reference unowned:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 未拥有关系适用于连接永远不会缺失的场景。在我们的例子中，有时方向盘存在但没有汽车引用。如果我们将其改为在`Car`初始化器中创建`SteeringWheel`，我们可以使引用未拥有：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Also, note that we had to define the `steeringWheel` property as an implicitly
    unwrapped optional. This is because we had to use `self` when initializing it
    but at the same time we cannot use `self` until all the properties have a value.
    Making it optional allows it to be nil while we are using `self` to create the
    steering wheel. This is safe as long as the `SteeringWheel2` initializer doesn't
    try to access the `steeringWheel` property of the passed in car.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们不得不将`steeringWheel`属性定义为隐式展开的可选属性。这是因为我们在初始化它时必须使用`self`，但同时又不能在所有属性都有值之前使用`self`。将其设置为可选属性允许它在使用`self`创建方向盘时为nil。只要`SteeringWheel2`初始化器不尝试访问传入汽车的`steeringWheel`属性，这是安全的。
- en: With closures
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包
- en: As we found out in [Chapter 5](ch05.html "Chapter 5. A Modern Paradigm – Closures
    and Functional Programming"), *A Modern Paradigm – Closures and Functional Programming*,
    closures are just another type of object, so they follow the same ARC rules. However,
    they are subtler than classes because of their ability to capture variables from
    their surrounding scope. These captures create strong references from the closures
    to the captured variable that are often overlooked because capturing variables
    looks so natural compared to conditionals, for loops and other similar syntax.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第5章](ch05.html "第5章。现代范式 – 闭包和函数式编程")中发现的，“现代范式 – 闭包和函数式编程”，闭包只是另一种类型的对象，因此它们遵循相同的ARC规则。然而，由于它们能够捕获其周围作用域中的变量，它们比类更微妙。这些捕获从闭包到捕获变量的强引用往往被忽视，因为与条件、for循环和其他类似语法相比，捕获变量看起来非常自然。
- en: Just as classes can create circular references, so can closures. Something can
    have a strong reference to a closure that directly or indirectly has a strong
    reference back to the original object. Let's take a look at how we can spot that.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如类可以创建循环引用一样，闭包也可以。某个东西可以对一个闭包有强引用，该闭包直接或间接地对原始对象有强引用。让我们看看我们如何发现这一点。
- en: Spotting
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现
- en: 'It is very common to provide closure properties that will be called whenever
    something occurs. These are generally called callbacks. Let''s look at a ball
    class that has a callback for when the ball bounces:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提供将在某些事情发生时被调用的闭包属性是非常常见的。这些通常被称为回调。让我们看看一个球类，它有一个当球弹跳时的回调：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This type of setup makes it easy to inadvertently create a strong reference
    cycle:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置很容易无意中创建强引用循环：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are printing out the location of the ball every time it bounces. However,
    if you consider this carefully, you will see that there is a strong reference
    cycle between the closure and the ball instance. This is because we are capturing
    the ball within the closure. As we have learned already, this creates a strong
    reference from the closure to the ball. The ball also has a strong reference to
    the closure through the `onBounce` property. That is our circle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们每次球弹跳时都会打印出球的位置。然而，如果你仔细考虑，你会看到闭包和球实例之间存在一个强引用循环。这是因为我们在闭包中捕获了球。正如我们已经学到的，这从闭包到球创建了一个强引用。球也通过`onBounce`属性对闭包有一个强引用。这就是我们的循环。
- en: You should always be conscious of what variables are being captured in your
    closures and if that variable directly or indirectly has a strong reference to
    the closure itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终意识到你的闭包中捕获了哪些变量，以及该变量是否直接或间接地有强引用到闭包本身。
- en: Fixing
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复
- en: To fix these types of strong reference cycles with closures we will again need
    to make one part of the circle weak or unowned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这些类型的强引用循环，我们再次需要使循环的一部分弱或无所有者。
- en: Swift does not allow us to make closure references weak, so we have to find
    a way to capture the ball variable weakly instead of strongly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Swift不允许我们使闭包引用弱引用，因此我们必须找到一种方法来弱捕获球变量而不是强引用。
- en: 'To capture a variable weakly, we must use a capture list. Using a capture list,
    we can capture a weak or unowned copy of the original variable. We do so by specifying
    the `weak` or `unowned` variables before the capture list variable name:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要弱捕获一个变量，我们必须使用捕获列表。使用捕获列表，我们可以捕获原始变量的弱或无所有者副本。我们通过在捕获列表变量名之前指定`weak`或`unowned`变量来实现这一点：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By declaring the ball copy as weak, it automatically makes it optional. This
    means that we had to use optional chaining to print out its location. Just like
    with other weak variables, `ball` will be set to nil if the ball is deleted. However,
    based on the nature of the code, we know that this closure will never be called
    if `ball` is deleted, since the closure is stored right on the ball instance.
    In that case, it is probably better to use the `unowned` keyword:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将球副本声明为弱引用，它自动使其成为可选的。这意味着我们必须使用可选链来打印其位置。就像其他弱变量一样，如果球被删除，`ball`将被设置为nil。然而，根据代码的性质，我们知道如果球被删除，这个闭包永远不会被调用，因为闭包存储在球实例上。在这种情况下，可能最好使用`unowned`关键字：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is always nice to clean up your code by removing unnecessary optionals.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总是清理你的代码，通过删除不必要的可选类型，总是很令人愉快。
- en: Lost objects
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 失踪的对象
- en: It is a great idea to always keep strong reference cycles in mind, but if we
    are too aggressive with the use of weak and unowned references, we can run into
    the opposite problem, where an object is deleted before we intended it to be.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住强引用循环是一个好主意，但如果我们在使用弱和无所有者引用时过于激进，我们可能会遇到相反的问题，即对象在我们打算删除它之前被删除。
- en: Between objects
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在对象之间
- en: With an object this will happen if all of the references to the object are weak
    or unowned. This won't be a fatal mistake if we use weak references, but if this
    happens with an unowned reference it will crash your program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的所有引用都是弱引用或无所有者引用时，这种情况会发生。如果我们使用弱引用，这不会是一个致命的错误，但如果这种情况发生在无所有者引用上，程序将会崩溃。
- en: 'For example, let''s look at the preceding example with an extra weak reference:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看前面例子中添加一个额外的弱引用：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code is the same as the preceding one except that both the `car` property
    of `SteeringWheel` and the `steeringWheel` property of `Car` are weak. This means
    that as soon as `wheel` goes out of scope, it will be deleted, resetting the `steeringWheel`
    property of the car to nil. There may be scenarios where you want this behavior,
    but often this will be unintentional and create confusing bugs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与前面的代码相同，除了`SteeringWheel`的`car`属性和`Car`的`steeringWheel`属性都是弱引用。这意味着一旦`wheel`超出作用域，它将被删除，将汽车的`steeringWheel`属性重置为nil。可能存在你想要这种行为的情况，但通常这将是无意中造成的，并产生令人困惑的错误。
- en: The important thing is that you keep in mind all of the relationships an object
    has. There should always be at least one strong reference as long as you still
    want the object around and of course, there should never be a strong reference
    cycle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住对象的所有关系。只要你还想让对象存在，就应该始终至少有一个强引用，当然，永远不应该有强引用循环。
- en: With closures
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在闭包中
- en: 'This actually can''t happen with closures because, as we discussed before,
    you cannot refer to a closure weakly. If you try, the compiler will give you an
    error:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不会发生在闭包中，因为我们之前讨论过，你不能弱引用一个闭包。如果你尝试这样做，编译器会给你一个错误：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Swift saves us from yet another type of bug.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 让我们免于另一种类型的错误。
- en: Structures versus classes
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体与类
- en: Now that we have a good understanding of memory management, we are ready to
    discuss the full trade-offs we make when we choose to design a type as a structure
    or a class. With our ability to extend protocols like we saw in the previous chapter,
    we can achieve very similar functionality to the inheritance we saw with classes
    in [Chapter 3](ch03.html "Chapter 3. One Piece at a Time – Types, Scopes, and
    Projects"), *One Piece at a Time – Types, Scopes, and Projects*. This means that
    we are often choosing between using a structure or a class based on the memory
    implications, or in other words, whether we want our type to be a value type or
    a reference type.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对内存管理有了很好的理解，我们准备讨论当我们选择将类型设计为结构体或类时所做的全部权衡。凭借我们像上一章中看到的那样扩展协议的能力，我们可以实现与第
    3 章中看到的类继承非常相似的功能，即“一次一块——类型、作用域和项目”。这意味着我们通常是在根据内存影响来选择使用结构体还是类，换句话说，我们是否希望我们的类型是值类型还是引用类型。
- en: Value types have an advantage because they are very simple to reason about.
    You don't have to worry about multiple variables referencing the same instance.
    Even better, you don't have to worry about all of the potential problems we have
    discussed with strong reference cycles. However, there is still an advantage to
    reference types.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型有优势，因为它们非常简单，易于推理。你不必担心多个变量引用同一个实例。更好的是，你不必担心我们之前讨论过的所有潜在的问题，即强引用循环。然而，引用类型仍然有优势。
- en: Reference types are advantageous when it really makes sense to share an instance
    between multiple variables. This is especially true when you are representing
    some sort of physical resource that makes no sense to copy like a port on the
    computer or the main window of an application. Also, some will argue that reference
    types use memory more efficiently, because it doesn't take up more memory with
    lots of copies floating around. However, the Swift compiler will actually do a
    lot of optimizing of our code and reduce or eliminate most of the copying that
    actually occurs when possible. For example, if we pass a value type into a function
    that never modifies the value, there is no reason to actually create that copy.
    Ultimately, I don't recommend optimizing for something like that before it becomes
    necessary. Sometimes you will run into memory problems with your application and
    then it can be appropriate to convert large types to classes if they are being
    copied a lot.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当确实有必要在多个变量之间共享一个实例时，引用类型是有优势的。这尤其适用于表示某种物理资源，如计算机上的端口或应用程序的主窗口，这种资源复制是没有意义的。有些人还会争论说，引用类型使用内存更有效率，因为它们不会因为存在大量副本而占用更多内存。然而，Swift
    编译器实际上会对我们的代码进行大量的优化，并在可能的情况下减少或消除大多数实际发生的复制。例如，如果我们将一个值类型传递给一个永远不会修改该值的函数，就没有必要实际创建那个副本。最终，我不建议在它变得必要之前对这种类型进行优化。有时你可能会遇到应用程序的内存问题，这时将大量复制的类型转换为类可能是合适的。
- en: Ultimately, I recommend using structures and protocols as a default, because
    they greatly reduce complexity and fall back to classes only when it is required.
    I even recommend using protocols instead of super classes when possible, because
    they are easier to shift around and make it an easier transition between value
    types and reference types.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我建议将结构体和协议作为默认选项，因为它们大大减少了复杂性，只有在必要时才回退到类。我甚至建议在可能的情况下使用协议而不是超类，因为它们更容易调整，并且使值类型和引用类型之间的过渡更加容易。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Memory management is often considered difficult to understand, but when you
    break it down, you can see that it is relatively straightforward. In this chapter,
    we have seen that all data in a computer is either stored in the file system that
    is a slow permanent storage, or in memory, which is a fast but temporary location.
    The file system is used as a backup to memory, slowing down the computer greatly,
    so we as programmers want to minimize the amount of memory we are ever using at
    one time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理通常被认为难以理解，但当你将其分解时，你会发现它相对简单直接。在本章中，我们了解到计算机中的所有数据要么存储在文件系统中，这是一个缓慢的永久存储，要么存储在内存中，这是一个快速但临时的位置。文件系统用作内存的备份，极大地减慢了计算机的速度，因此我们作为程序员希望最大限度地减少我们一次使用的内存量。
- en: We saw that in Swift there are value types and reference types. These concepts
    are critical to understanding how you can reduce memory usage and eliminate memory
    leaks. Memory leaks are created when an object has a strong reference to itself,
    maybe through a third party, which is called a strong reference cycle. We must
    also be careful that we keep at least one strong reference to every object we
    want to stay around or we may lose it prematurely.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在 Swift 中有值类型和引用类型。这些概念对于理解如何减少内存使用和消除内存泄漏至关重要。当对象对自己有强引用时，就会创建内存泄漏，可能通过第三方，这被称为强引用循环。我们还必须小心，确保我们对我们想要保留的每个对象至少保持一个强引用，否则我们可能会过早地丢失它。
- en: With practice programming, you will get better with both preventing and fixing
    memory problems. You will write streamlined apps that keep your users' computers
    running smoothly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实践编程，你将更好地预防并修复内存问题。你将编写流畅的应用程序，使你的用户的计算机运行顺畅。
- en: We are now ready to move on to the last feature of Swift that we will discuss
    before we get into the more artful side of computer programming called error handling.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续讨论 Swift 的最后一个特性，在我们进入更艺术化的计算机编程领域，即错误处理之前。
