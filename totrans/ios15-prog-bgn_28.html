<html><head></head><body>
		<div><h1 id="_idParaDest-319"><em class="italic"><a id="_idTextAnchor469"/>Chapter 24</em>: Getting Started with Swift Concurrency</h1>
			<p>Apple introduced <strong class="bold">Swift Concurrency</strong> during WWDC2021, which adds support for structured asynchronous and parallel programming to Swift 5.5. This allows you to write concurrent code which is more readable and easier to understand.</p>
			<p>In this chapter, you will learn the basic concepts of Swift Concurrency. Next, you will examine an app without concurrency and explore its issues. After that, you will use <code>RestaurantListViewController</code> class in your <em class="italic">Let's Eat</em> app to use <code>async</code>/<code>await</code> for loading restaurant images.</p>
			<p>By the end of this chapter, you'll have learned the basics on how Swift Concurrency works, and how to update your own apps to use it.</p>
			<p>The following topics will be covered: </p>
			<ul>
				<li>Understanding Swift Concurrency</li>
				<li>Examining an app without concurrency</li>
				<li>Updating the app using <code>async</code>/<code>await</code></li>
				<li>Improving efficiency using <code>async-let</code></li>
				<li>Updating <code>RestaurantListViewController</code> to use async/await</li>
			</ul>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor470"/>Technical requirements</h1>
			<p>You will use a sample app, <em class="italic">BreakfastMaker</em>, to help you understand the concepts of Swift Concurrency. Later in the chapter, you will continue working on the <code>LetsEat</code> project that you modified in <a href="B17469_22_Final_VK_ePub.xhtml#_idTextAnchor431"><em class="italic">Chapter 22</em></a><em class="italic">, Getting Started with Mac Catalyst</em>.</p>
			<p>The completed Xcode project for this chapter is in the <code>Chapter24</code> folder of the code bundle for this book, which can be downloaded here:</p>
			<p><a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a></p>
			<p>Check out the following video to see the code in action:</p>
			<p><a href="https://bit.ly/3d4YWH5">https://bit.ly/3d4YWH5</a></p>
			<p>Let's start by learning about Swift Concurrency in the next section.</p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor471"/>Understanding Swift Concurrency</h1>
			<p>In Swift 5.5, Apple has added support for writing asynchronous and parallel code in a structured way. </p>
			<p>Asynchronous <a id="_idIndexMarker1355"/>code allows your app to suspend and resume code. This allows your app to do things like update the user interface while still performing operations like downloading data from the internet.</p>
			<p>Parallel code allows your app to run multiple pieces of code simultaneously. </p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">You can find links to all of Apple's Swift Concurrency videos during WWDC2021 at <a href="https://developer.apple.com/news/?id=2o3euotz">https://developer.apple.com/news/?id=2o3euotz</a>.</p>
			<p class="callout">You can <a id="_idIndexMarker1356"/>read Apple's Swift Concurrency documentation at <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html">https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html</a>.</p>
			<p>To give you <a id="_idIndexMarker1357"/>an idea of how Swift Concurrency works, imagine that you are making a poached egg sandwich for breakfast. Here is one way of doing it:</p>
			<ol>
				<li>Put two slices of bread into the toaster. </li>
				<li>Wait two minutes until the bread is toasted.</li>
				<li>Put an egg in a bowl with some water and put the bowl into the microwave. </li>
				<li>Wait six minutes until the egg is cooked.</li>
				<li>Make your sandwich.</li>
			</ol>
			<p>This takes eight minutes in total. Now think about this sequence of events. Do you spend that time just staring at the toaster and the microwave? You'll probably be using your phone while the bread is in the toaster and the egg is in the microwave. In other words, you can do other things while the bread and egg are being prepared. So, the sequence of events would be more accurately described as follows:</p>
			<ol>
				<li value="1">Put two slices of bread into the toaster.</li>
				<li>Use your phone for two minutes until the bread is toasted.</li>
				<li>Put an egg in a bowl with some water and put the bowl into the microwave. </li>
				<li>Use your phone for six minutes until the egg is cooked.</li>
				<li>Make your sandwich.</li>
			</ol>
			<p>Here, you can <a id="_idIndexMarker1358"/>see that your interaction with the toaster and microwave can be suspended, then resumed, which means these operations are asynchronous. The operation still takes eight minutes, but you were able to do other things during that time.</p>
			<p>There is another factor to consider. You don't need to wait for the bread to finish toasting before you put the egg in the microwave. This means you could modify the sequence of steps as follows:</p>
			<ol>
				<li value="1">Put two slices of bread into the toaster.</li>
				<li>While the bread is toasting, put an egg in a bowl with some water, and put the bowl into the microwave. </li>
				<li>Use your phone for six minutes until the egg is cooked.</li>
				<li>Make your sandwich.</li>
			</ol>
			<p>Toasting the bread and poaching the egg are now carried out in parallel, which saves you two minutes. Great! Do note however that you have more things to keep track of.</p>
			<p>Now that you understand the concepts of asynchronous and parallel operations, let's study the issues an app that does not have concurrency has in the next section.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor472"/>Examining an app without concurrency</h1>
			<p>You've seen how asynchronous and parallel operations can help you prepare breakfast faster <a id="_idIndexMarker1359"/>and allow you to use your phone while you're doing it. Now let's look at a sample app that simulates the process of preparing breakfast. Initially, this app does not have concurrency implemented, so you can see how that affects the app. Follow these steps: </p>
			<ol>
				<li value="1">If you have not already done so, download the <code>Chapter24</code> folder of the code bundle for this book at this link: <a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a>.</li>
				<li>Open the <code>resources</code> folder in the <code>Chapter24</code> folder, and you'll see two folders, <code>BreakfastMaker-start</code> and <code>BreakfastMaker-complete</code>. The first folder contains the app that you will be modifying in this chapter, and the second contains the completed app.</li>
				<li>Open the <code>BreakfastMaker-start</code> folder and open the <code>BreakfastMaker</code> Xcode project. Click on the <code>Main</code> storyboard file in the Project navigator. You should see four labels and a button in the <strong class="bold">View Controller Scene</strong> as shown:<div><img src="img/Figure_24.01_B17469.jpg" alt="Figure 24.1: Main storyboard file showing the View Controller Scene&#13;&#10;"/></div><p class="figure-caption">Figure 24.1: Main storyboard file showing the View Controller Scene</p><p>The app will display a screen which shows the status of the toast, egg, and sandwich, and the time taken to prepare the sandwich. The app will also display a button you can use to test the responsiveness of the user interface.</p></li>
				<li>Click the <code>ViewController</code> file in the Project navigator. You should see the following <a id="_idIndexMarker1360"/>code in the Editor area:<pre>import UIKit
class ViewController: UIViewController {
   @IBOutlet var toastLabel: UILabel!
   @IBOutlet var eggLabel: UILabel!
   @IBOutlet var sandwichLabel: UILabel!
   @IBOutlet var elapsedTimeLabel: UILabel!
   override func viewDidAppear(_ animated: Bool) {
      super.viewDidAppear(animated)
      let startTime = Date().timeIntervalSince1970
      toastLabel.text = "Making toast..."
      toastLabel.text = makeToast()
      eggLabel.text = "Poaching egg..."
      eggLabel.text = poachEgg()
      sandwichLabel.text = makeSandwich()
      let endTime = Date().timeIntervalSince1970
      elapsedTimeLabel.text = "Elapsed time is 
      \(((endTime - startTime) * 100).rounded() 
      / 100) seconds"
   }
   func makeToast() -&gt; String {
      sleep(2)
      return "Toast done"
   }
   func poachEgg() -&gt; String {
      sleep(6)
      return "Egg done"
   }
   func makeSandwich() -&gt; String {
      return "Sandwich done"
   }
   @IBAction func testButton(_ sender: UIButton) {
      print("Button tapped")
   }
}</pre><p>As you <a id="_idIndexMarker1361"/>can see, this code simulates the process of making breakfast that was described in the previous section. Let's break it down:</p><pre>@IBOutlet var toastLabel: UILabel!
@IBOutlet var eggLabel: UILabel!
@IBOutlet var sandwichLabel: UILabel!
@IBOutlet var elapsedTimeLabel: UILabel!</pre><p>These outlets are linked to four labels in the <code>Main</code> storyboard file. When you run the app, these labels will display the status of the toast, egg, and sandwich, and also show the time taken to complete the process.</p><pre>override  func viewDidAppear(_ animated: Bool) {</pre><p>This method is called when the view controller's view appears on screen.</p><pre>let startTime = Date().timeIntervalSince1970</pre><p>This sets <code>startTime</code> to the current time, so the app can later calculate how long it takes to make the sandwich.</p><pre>toastLabel.text = "Making toast..."</pre><p>This makes <code>toastLabel</code> display the text <code>Making toast...</code>.</p><pre>toastLabel.text = makeToast()</pre><p>This <a id="_idIndexMarker1362"/>calls the <code>makeToast()</code> method, which waits for two seconds to simulate the time taken to make toast, then returns the text <code>Toast done</code>, which will be displayed by <code>toastLabel</code>.</p><pre>eggLabel.text = "Poaching egg..."</pre><p>This makes <code>eggLabel</code> display the text <code>Poaching egg...</code>.</p><pre>eggLabel.text = poachEgg()</pre><p>This calls the <code>poachEgg()</code> method, which waits for six seconds to simulate the time taken to poach an egg, then returns the text <code>Egg done</code>, which will be displayed by <code>eggLabel</code>.</p><pre>sandwichLabel.text = makeSandwich()</pre><p>This calls the <code>makeSandwich()</code> method, which returns the text <code>Sandwich done</code>, which will be displayed by <code>sandwichLabel</code>.</p><pre>let endTime = Date().timeIntervalSince1970</pre><p>This sets <code>endTime</code> to the current time.</p><pre>elapsedTimeLabel.text = "Elapsed time is 
\(((endTime - startTime) * 100).rounded() 
/ 100) seconds"</pre><p>This calculates the elapsed time (approximately eight seconds), which will be displayed by <code>elapsedTimeLabel</code>.</p><pre>@IBAction func testButton(_ sender: UIButton) {
   print("Button tapped")
}</pre><p>This displays <code>Button tapped</code> in the Debug area each time the button on screen is tapped.</p></li>
			</ol>
			<p>Build <a id="_idIndexMarker1363"/>and run the app, and tap the button the moment the user interface appears:</p>
			<div><div><img src="img/Figure_24.02_B17469.jpg" alt="Figure 24.2: iOS Simulator running the BreakfastMaker app showing the button to be tapped&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.2: iOS Simulator running the BreakfastMaker app showing the button to be tapped</p>
			<p>You <a id="_idIndexMarker1364"/>should notice the following issues:</p>
			<ul>
				<li>Tapping the button has no effect initially, and you'll only see <code>Button tapped</code> in the Debug area after approximately eight seconds.</li>
				<li><code>Making toast...</code> and <code>Poaching egg...</code> are never displayed, and <code>Toast done</code> and <code>Egg done</code> only appear after approximately eight seconds.</li>
			</ul>
			<p>The reason why this happens is because your app's code did not update the user interface while the <code>makeToast()</code> and <code>poachEgg()</code> methods are running. Your app did register the button taps, but was only able to process them and update the labels after <code>makeToast()</code> and <code>poachEgg()</code> have completed execution. These issues do not give the user a good experience with your app.</p>
			<p>You have <a id="_idIndexMarker1365"/>now experienced the issues presented by an app that does not have concurrency implemented. In the next section, you'll modify the app using <code>async</code>/<code>await</code> so that it is able to update the user interface while the <code>makeToast()</code> and <code>poachEgg()</code> methods are running.</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor473"/>Updating the app using async/await</h1>
			<p>As you have seen previously, the app is unresponsive when the <code>makeToast()</code> and <code>poachEgg()</code> methods are running. To resolve this, you will use <code>async</code>/<code>await</code> in the app. </p>
			<p>Writing <a id="_idIndexMarker1366"/>the <code>async</code> keyword in the method <a id="_idIndexMarker1367"/>declaration indicates that the method <a id="_idIndexMarker1368"/>is asynchronous. This is what it looks like:</p>
			<pre>func methodName() <strong class="bold">async</strong> -&gt; returnType {</pre>
			<p>Writing the <code>await</code> keyword in front of a method call marks a point where execution may be suspended, thus allowing other operations to run. This is what it looks like:</p>
			<pre><strong class="bold">await</strong> methodName()</pre>
			<p class="callout-heading">Important Information</p>
			<p class="callout">You <a id="_idIndexMarker1369"/>can watch Apple's WWDC2021 video discussing async/await at <a href="https://developer.apple.com/videos/play/wwdc2021/10132/">https://developer.apple.com/videos/play/wwdc2021/10132/</a>.</p>
			<p>You will modify your app to use <code>async</code>/<code>await</code>. This will enable it to suspend the <code>makeToast()</code> and <code>poachEgg()</code> methods to process button taps and update the user interface, then resume execution of both methods afterward. Follow these steps: </p>
			<ol>
				<li value="1">Modify the <code>makeToast()</code> and <code>poachEgg()</code> methods as shown to make the code in their bodies asynchronous:<pre>func makeToast() -&gt;<a id="_idTextAnchor474"/><a id="_idTextAnchor475"/> String {
   <code>Task</code> represents a unit of asynchronous work. <code>Task</code> has a static method, <code>sleep(nanoseconds:)</code>, which <a id="_idIndexMarker1370"/>pauses execution for a specified duration, measured in nanoseconds. Multiplying by 1,000,000,000 converts <a id="_idIndexMarker1371"/>the duration to seconds. The <code>await</code> keyword indicates this code can be suspended to allow other code to run.</p></li>
				<li>Errors <a id="_idIndexMarker1372"/>will appear for both <code>makeToast()</code> and <code>poachEgg()</code>. Click either error icon to display the error message:<div><img src="img/Figure_24.03_B17469.jpg" alt="Figure 24.3: Errors with error icons highlighted&#13;&#10;"/></div><p class="figure-caption">Figure 24.3: Errors with error icons highlighted</p><p>The error is displayed because you're calling an asynchronous method inside a method that does not support concurrency. You will need to add the <code>async</code> keyword to the method declaration to indicate it is asynchronous. </p></li>
				<li>For each <a id="_idIndexMarker1373"/>method, click the <code>async</code> keyword to the method declaration.</li>
				<li>Verify <a id="_idIndexMarker1375"/>that your code looks like this after you're done:<pre>func makeToast() <strong class="bold">async</strong> -&gt; String {
   try! await Task.sleep(nanoseconds: 2 * 1_000_000_000)
   return "Toast done"
}
func poachEgg() <strong class="bold">async</strong> -&gt; String {
   try! await Task.sleep(nanoseconds: 6 * 1_000_000_000)
   return "Egg done"
}</pre></li>
				<li>The errors in the <code>makeToast()</code> and <code>poachEgg()</code> methods should be gone, but new errors will appear in the <code>viewDidAppear()</code> method. Click one of the error icons to see the error message, which will be the same as the message you saw earlier. This is because you're calling an asynchronous method inside a method that does not support concurrency. </li>
				<li>Click the <strong class="bold">Fix</strong> button, and more errors will appear. </li>
				<li>Ignore the one in the method declaration for now and click the one next to the <code>makeToast()</code> method call to see the error message:<div><img src="img/Figure_24.04_B17469.jpg" alt="Figure 24.4: Errors with error icon for makeToast() highlighted&#13;&#10;"/></div><p class="figure-caption">Figure 24.4: Errors with error icon for makeToast() highlighted</p><p>This error message is displayed because you did not use <code>await</code> when calling an asynchronous function.</p></li>
				<li>Click <a id="_idIndexMarker1376"/>the <code>await</code> keyword before the method call.</li>
				<li>Repeat <em class="italic">step 7</em> and <em class="italic">step 8</em> for the error next to the <code>poachEgg()</code> method call. The <code>await</code> keyword <a id="_idIndexMarker1377"/>will be inserted for the <code>poachEgg()</code> method call as well.</li>
				<li>Click <a id="_idIndexMarker1378"/>the error icon in the <code>viewDidLoad()</code> method declaration to see the error message:<div><img src="img/Figure_24.05_B17469.jpg" alt="Figure 24.5: Error with error icon highlighted&#13;&#10;"/></div><p class="figure-caption">Figure 24.5: Error with error icon highlighted</p><p>This error is displayed because you can't use the <code>async</code> keyword to make the <code>viewDidAppear()</code> method asynchronous, as this capability is not present in the superclass.</p></li>
				<li>To resolve this issue, you'll remove the <code>async</code> keyword and enclose all the code after <code>super.viewDidAppear()</code> in a <code>Task</code> block, which will allow it to execute asynchronously in a synchronous method. Modify your code as follows:<pre>override  func viewDidAppear(_ animated: Bool) {
   super.viewDidAppear(animated)
   <strong class="bold">Task {</strong>
      let startTime = Date().timeIntervalSince1970
      toastLabel.text = "Making toast..."
      toastLabel.text = await makeToast() 
      eggLabel.text = "Poaching egg..."
      eggLabel.text = await poachEgg() 
      sandwichLabel.text = makeSandwich()
      let endTime = Date().timeIntervalSince1970
      elapsedTimeLabel.text = "Elapsed time is 
      \(((endTime - startTime) * 100).rounded() 
      / 100) seconds"
   <strong class="bold">}</strong>
}</pre></li>
			</ol>
			<p>Build and <a id="_idIndexMarker1379"/>run the app, and tap the button <a id="_idIndexMarker1380"/>as soon as you see the user interface. Note that <code>Button tapped</code> now appears immediately in the Debug area, and the labels <a id="_idIndexMarker1381"/>update as they should. This is because the app is now able to suspend the <code>makeToast()</code> and <code>poachEgg()</code> methods to respond to taps and update the user interface, and resume them later. Awesome!</p>
			<p>However, if you look at the elapsed time, you'll see that the app takes slightly longer to prepare breakfast than it did before:</p>
			<div><div><img src="img/Figure_24.06_B17469.jpg" alt="Figure 24.6: iOS Simulator running the BreakfastMaker app showing elapsed time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.6: iOS Simulator running the BreakfastMaker app showing elapsed time</p>
			<p>This is <a id="_idIndexMarker1382"/>partly due to the overhead required <a id="_idIndexMarker1383"/>for suspending and resuming methods, but <a id="_idIndexMarker1384"/>there is another factor involved. Even though the <code>makeToast()</code> and <code>poachEgg()</code> methods are now asynchronous, the <code>poachEgg()</code> method only starts execution after the <code>makeToast()</code> method has finished execution. In the next section, you'll see how you can use <code>async-let</code> to run the <code>makeToast()</code> and <code>poachEgg()</code> methods in parallel.</p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor476"/>Improving efficiency using async-let</h1>
			<p>Even though your app is now responsive to button taps and is able to update the user interface <a id="_idIndexMarker1385"/>while the <code>makeToast()</code> and <code>poachEgg()</code> methods are running, both methods still execute sequentially. The solution <a id="_idIndexMarker1386"/>here is to use <code>async-let</code>. Writing <a id="_idIndexMarker1387"/><code>async</code> in front of a <code>let</code> statement <a id="_idIndexMarker1388"/>when you define a constant, and then writing <code>await</code> when you access the constant, allows parallel execution of asynchronous methods:</p>
			<pre><strong class="bold">async</strong> let temporaryConstant1 = methodName1()
<strong class="bold">async</strong> let temporaryConstant2 = methodName2()
<strong class="bold">await</strong> variable1 = temporaryConstant1
<strong class="bold">await</strong> variable2 = temporaryConstant1</pre>
			<p>Here, <code>methodName1()</code> and <code>methodName2()</code> will run in parallel.</p>
			<p>You will <a id="_idIndexMarker1389"/>modify your app to use <code>async-let</code> <a id="_idIndexMarker1390"/>to enable the <code>makeToast()</code> and <code>poachEgg()</code> methods <a id="_idIndexMarker1391"/>run in parallel. In <a id="_idIndexMarker1392"/>the <code>ViewController</code> file, modify the code in the <code>Task</code> block as follows:</p>
			<pre>Task {
   let startTime = Date().timeIntervalSince1970
   toastLa<a id="_idTextAnchor477"/><a id="_idTextAnchor478"/>bel.text = "Making toast..."
   <strong class="bold">async let tempToast = makeToast()</strong>
   eggLa<a id="_idTextAnchor479"/><a id="_idTextAnchor480"/>bel.text = "Poaching egg..."
   <strong class="bold">async let tempEgg = poachEgg()</strong>
<strong class="bold">   await toastLabel.text = tempToast</strong>
<strong class="bold">   await eggLabel.text = tempEgg</strong>
   sandwichLabel.text = makeSandwich()
   let endTime = Date().timeIntervalSince1970
   elapsedTimeLabel.text = "Elapsed time is 
   \(((endTime - startTime) * 100).rounded() 
   / 100) seconds"
}</pre>
			<p>Build and run the app. You'll see that the elapsed time is now less than what it was before:</p>
			<div><div><img src="img/Figure_24.07_B17469.jpg" alt="Figure 24.7: iOS Simulator running the BreakfastMaker app showing elapsed time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.7: iOS Simulator running the BreakfastMaker app showing elapsed time</p>
			<p>This is <a id="_idIndexMarker1393"/>because using <code>async-let</code> allows both <a id="_idIndexMarker1394"/>the <code>makeToast()</code> and <code>poachEgg()</code> methods <a id="_idIndexMarker1395"/>to run in parallel, and <a id="_idIndexMarker1396"/>the <code>poachEgg()</code> method no longer waits for the <code>makeToast()</code> method to complete before starting execution. Cool!</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">There is still lots more to learn about Swift Concurrency, such as structured concurrency and actors, but <a id="_idIndexMarker1397"/>that is beyond the scope of this chapter. You can <a id="_idIndexMarker1398"/>learn more about structured concurrency at <a href="https://developer.apple.com/wwdc21/10134">https://developer.apple.com/wwdc21/10134</a>, and you can learn more about actors at <a href="https://developer.apple.com/wwdc21/10133">https://developer.apple.com/wwdc21/10133</a>.</p>
			<p>In the next section, you'll update the <code>RestaurantListViewController</code> class in the <em class="italic">Let's Eat</em> app to use <code>async</code>/<code>await</code> when getting restaurant images.</p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor481"/>Updating RestaurantListViewController to use async/await</h1>
			<p>When you run your <em class="italic">Let's Eat</em> app, you may notice a delay when the <strong class="bold">Restaurant List</strong> screen <a id="_idIndexMarker1399"/>is displaying <a id="_idIndexMarker1400"/>a list of <a id="_idIndexMarker1401"/>restaurants. This is because the code used to download restaurant images is not asynchronous, and the app is not able to do other work while restaurant images are being downloaded.</p>
			<p>The code that downloads the restaurant image data and converts it into an image is inside the <code>collectionView(_:cellForItemAt:)</code> method in the <code>RestaurantListViewController</code> class definition. You'll modify this code so that it is performed asynchronously. </p>
			<p>Open your <code>LetsEat</code> project that you modified in <a href="B17469_22_Final_VK_ePub.xhtml#_idTextAnchor431"><em class="italic">Chapter 22</em></a><em class="italic">, Getting Started with Mac Catalyst</em>, and open the <code>RestaurantListViewController</code> file (inside the <code>Restaurants</code> folder) in the Project navigator. Update the <code>collectionView(_:cellForItemAt:)</code> method as shown below:</p>
			<pre>   if let imageURL = restaurantItem.imageURL {
     <strong class="bold"> Task {</strong>
<strong class="bold">         guard let url = URL(string: imageURL)</strong>
<strong class="bold">         else {</strong>
<strong class="bold">            return</strong>
<strong class="bold">         }</strong>
<strong class="bold">         let (imageData, response) = try await </strong>
<strong class="bold">         URLSession.shared.data(from: url)</strong>
<strong class="bold">         guard let httpResponse = response as? </strong>
<strong class="bold">         HTTPURLResponse, httpResponse.statusCode </strong>
<strong class="bold">         == 200 else {</strong>
<strong class="bold">            return</strong>
<strong class="bold">         }</strong>
<strong class="bold">         guard let cellImage = UIImage(data: </strong>
<strong class="bold">         imageData) else {</strong>
<strong class="bold">            return</strong>
<strong class="bold">         }</strong>
<strong class="bold">         cell.restaurantImageView.image = cellImage</strong>
<strong class="bold">         }</strong>
<strong class="bold">      }</strong>
   return cell
}</pre>
			<p>Let's break this down:</p>
			<pre>Task {</pre>
			<p>This <a id="_idIndexMarker1402"/>creates a <a id="_idIndexMarker1403"/>unit of asynchronous work.</p>
			<pre>guard let url = URL(string: imageURL)
else {
   return
}</pre>
			<p>This <code>guard</code> statement creates a URL from the <code>RestaurantItem</code> instance's <code>imageURL</code> property <a id="_idIndexMarker1404"/>and assigns it to <code>url</code>, and returns if it is not able to do so.</p>
			<pre>let (imageData, response) = try await 
URLSession.shared.data(from: url)</pre>
			<p>This asynchronously downloads the data from the URL stored in <code>url</code>, and assigns it to <code>imageData</code>. The response from the server is assigned to <code>response</code>.</p>
			<pre>guard let httpResponse = response as? HTTPURLResponse,
httpResponse.statusCode == 200 else {
   return
}</pre>
			<p>This <code>guard</code> statement checks to see if the server response code is <code>200</code> (which means that the download was successful) and returns if it is not.</p>
			<pre>guard let cellImage = UIImage(data: imageData) else {
   return
}</pre>
			<p>This <code>guard</code> statement creates a <code>UIImage</code> instance from the data stored in <code>imageData</code> and <a id="_idIndexMarker1405"/>assigns to <code>cellImage</code>, and returns if it is not able to do so.</p>
			<pre>cell.restaurantImageView.image = cellImage</pre>
			<p>This <a id="_idIndexMarker1406"/>assigns the <code>UIImage</code> stored <a id="_idIndexMarker1407"/>in <code>cellImage</code> to the <code>restaurantCell</code> instance's <code>restaurantImageView</code> property, which will be displayed in the <code>restaurantImageView</code> property will be displayed.</p>
			<pre>return cell</pre>
			<p>This returns the <code>restaurantCell</code> instance.</p>
			<p>Build and run your app. You'll notice that the <strong class="bold">Restaurant List</strong> screen will be more responsive and scroll more smoothly than before:</p>
			<div><div><img src="img/Figure_24.08_B17469.jpg" alt="Figure 24.8: iOS Simulator showing the Restaurant List screen with downloaded images&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.8: iOS Simulator showing the Restaurant List screen with downloaded images</p>
			<p>If <a id="_idIndexMarker1408"/>you disable <a id="_idIndexMarker1409"/>your internet <a id="_idIndexMarker1410"/>connection, the <strong class="bold">Restaurant List</strong> screen will still work but it will display the default placeholder images instead:</p>
			<div><div><img src="img/Figure_24.09_B17469.jpg" alt="Figure 24.9: iOS Simulator showing the Restaurant List screen with default images&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 24.9: iOS Simulator showing the Restaurant List screen with default images</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">You can find more information on how to use async/await with <code>URLSession</code> at <a href="https://developer.apple.com/wwdc21/10095">https://developer.apple.com/wwdc21/10095</a>.</p>
			<p>You <a id="_idIndexMarker1411"/>have successfully <a id="_idIndexMarker1412"/>implemented <a id="_idIndexMarker1413"/>asynchronous code in your app's <code>RestaurantListViewController</code> class. Fantastic! There are still a lot of things to learn about Swift Concurrency, such as structured concurrency and actors, but that is beyond the scope of this chapter.</p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor482"/>Summary</h1>
			<p>In this chapter, you learned about Swift Concurrency, and how to implement it in both the <em class="italic">BreakfastMaker</em> and <em class="italic">Let's Eat</em> apps.</p>
			<p>You started by learning the basic concepts of Swift Concurrency. Next, you examined an app without concurrency and explored its issues. After that, you implemented concurrency in the app using <code>async</code>/<code>await</code>. Next, you made your app more efficient by using <code>async-let</code>. Finally, you updated the <code>RestaurantListViewController</code> class in your <em class="italic">Let's Eat</em> app to use <code>async</code>/<code>await</code> for loading restaurant images.</p>
			<p>You now understand the basics of Swift Concurrency and will now be able to use <code>async</code>/<code>await</code> and <code>async-let</code> in your own apps.</p>
			<p>In the next chapter, you will learn about <strong class="bold">SharePlay</strong>, a great way to share group experiences for users of your app.</p>
		</div>
	</body></html>