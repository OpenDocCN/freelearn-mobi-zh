<html><head></head><body><div><h1 class="header-title">Functions</h1>
                
            
            
                
<p class="mce-root">The following recipes will be covered in this chapter:</p>
<ul>
<li>Specifying default values in functions</li>
<li>Using named arguments in functions</li>
<li>Creating the <kbd>RecyclerView</kbd> Adapter in Kotlin</li>
<li>Creating getter setters in Kotlin</li>
<li>Passing variable arguments to a function</li>
<li>Passing a function as a parameter to another</li>
<li>Declaring a <kbd>static</kbd> function</li>
<li>Using the <kbd>use</kbd> keyword in Kotlin</li>
<li>Working with Closure in Kotlin</li>
<li>Function literals with receivers</li>
<li>Working with anonymous functions</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Functions are the building blocks of any code. They help make our programs more modular, secure, and easy to understand. Functions are crucial in object-oriented programming as they play an important role in abstraction and encapsulation (two very important design principles). Kotlin brings a lot of updates to the way we use functions. It makes functional programming easier with the help of chaining and lambdas. In this chapter, we will learn recipes that will help us work with functions. So let's get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Specifying default values in functions</h1>
                
            
            
                
<p>If you come from the Java world, you might remember that we can't specify a default value to methods. This means that we can't do something like this in Java:</p>
<pre style="padding-left: 60px">public void foo(int a, int b=10){<br/>}</pre>
<p>We need to write two methods for it, and it is known as <em>method overloading:</em></p>
<pre style="padding-left: 60px">public void foo(int a){<br/>}<br/><br/>public void foo(int a, int b){<br/>}</pre>
<p>Also, suppose you have a function with three different kinds of parameters, such as these:</p>
<pre style="padding-left: 60px">public void foo (int a,double b, String c){<br/>}</pre>
<p>Then you'll have seven instances of method overloading:</p>
<pre style="padding-left: 60px">public void foo (int a,double b, String c),<br/>public void foo (int a,double b) ,<br/>public void foo (double b, String c),<br/>public void foo (int a, String c),<br/>public void foo (int a),<br/>public void foo (double b),<br/>public void foo (String c)</pre>
<p>Kotlin provides you with default values in the methods by which you can prevent an insane amount of method overloading. Some people might say, "Hey, why don't we use the builder pattern instead of method overloading?". Those people are right, but Kotlin's way is easier than that. Let's see how!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA to write and execute our code. You can use whatever development environment you are comfortable with.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In Kotlin, parameters of functions can have default values, and they are used when the corresponding argument is omitted. This, in turn, reduces the number of overloads. The preceding example with three different types of parameters can be resolved easily in Kotlin with a lot less code:</p>
<ol>
<li>Let's add the mentioned code in the editor, run it, and check the output:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    foo()    <br/>    foo(1)<br/>    foo(1,0.1)<br/>    foo(1,0.1,"custom string")<br/>}<br/>fun foo(a:Int=0, b: Double =0.0, c:String="some default value"){<br/>    println("a=$a , b=$b ,c = $c")<br/>}</pre>
<p style="padding-left: 60px">If you run the preceding code, you will see the following output:</p>
<pre style="padding-left: 60px">Output:<br/>a=0 , b=0.0 ,c = some default value<br/>a=1 , b=0.0 ,c = some default value<br/>a=1 , b=0.1 ,c = some default value<br/>a=1 , b=0.1 ,c = custom string</pre>
<ol start="2">
<li>As you can see, we didn't have to implement four different methods, and we could map the arguments. The default parameters are used when we don't call the methods by providing explicit parameters, so when you don't pass any parameters, it just uses all the default ones. With the help of named arguments, we can decrease the number of methods even further, but we will cover this in the next recipe.</li>
<li>One thing to note is that default arguments will also work with constructors. So you can have a class declaration as follows:</li>
</ol>
<pre style="padding-left: 60px">data class Event(var eventName: String? = "", var eventSchedule: Date? = Date(), var isPrivate: Boolean = false)</pre>
<p>To learn more about a data class, head on to the <a href="https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e1822868-fcb7-4623-8727-eb961254acdf.xhtml" target="_blank">Chapter 11</a>, <em>How to create data class recipe.</em></p>
<ol start="4">
<li>Then we can declare objects, as shown:</li>
</ol>
<pre style="padding-left: 60px">Event("Celebration")<br/>Event("Ceberation",Date())<br/>Event("Ceberation",Date(),true)</pre>
<p style="padding-left: 60px">As you can see, with the help of default values in the constructors, we are avoiding the need to implement multiple constructors, which we used to do in Java.</p>
<p style="padding-left: 60px">Remember that there is a catch here. We won't be able to do this if you are creating objects in Java. This means that doing things as shown in the following code will not be accepted by Java. Now I know you'll be like "What happened to 100% interoperability with Java ?!":</p>
<pre style="padding-left: 60px">new Event("Celebration")<br/>new Event("Celebration",Date())<br/>new Event("Celebration",Date(),true)</pre>
<ol start="5">
<li>We just need to do a small modification if we want to expose multiple overloads to Java callers, that is—namely adding <kbd>@JvmOverloads</kbd> to the constructors and functions with default values so that the preceding class declaration becomes this:</li>
</ol>
<pre style="padding-left: 60px">data class Event @JvmOverloads constructor (var eventName: String? = "", var date: Date? = Date(), var isPrivate: Boolean = false)</pre>
<ol start="6">
<li>Also, our method becomes this:</li>
</ol>
<pre style="padding-left: 60px">@JvmOverloads fun foo(a:Int=0, b: Double =0.0, c:String="some default value"){<br/> println("a=$a , b=$b ,c = $c")<br/> }</pre>
<p>This is a small price to pay, but the <kbd>@JvmOverloads</kbd> annotation helps our constructors and functions to have default values, called from the Java world too.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If we want our code to work only in the Kotlin world, then we don't need the <kbd>@JvmOverloads</kbd> annotation because Kotlin has its own rules by which it can work with default values in constructors and functions. Adding the <kbd>@JvmOverloads</kbd> annotation creates all the necessary overloads. So if you decompile your Kotlin bytecode, you will see all the overloaded versions of constructors and functions.</p>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using named arguments in functions</h1>
                
            
            
                
<p>This recipe can be thought of as an extension to the previous recipe, <em>Specifying default values in functions</em>. Default parameters and named arguments in the function together can bring down the number of method overloads by a huge amount. We've already seen how to use default parameters in functions; now, let's see how to use name arguments.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA to write and execute our code. You can use whatever development environment you are comfortable with.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Another step forward to reduce the number of overloads and increase code readability is to use named arguments. Let's take look at the following code:</p>
<ol>
<li>Taking the same example of the <kbd>foo</kbd> function, here's how we can use named arguments:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>     foo(b=0.9)<br/>     foo(a=1,c="Custom string")<br/>}<br/> fun foo(a:Int=0, b: Double =0.0, c:String="some default value"){<br/>     println("a=$a , b=$b ,c = $c")<br/>}</pre>
<ol start="2">
<li>This is the output that you will get by running the preceding code:</li>
</ol>
<pre style="padding-left: 60px">Output:<br/>a=0 , b=0.9 ,c = some default value<br/>a=1 , b=0.0 ,c = Custom string</pre>
<ol start="3">
<li>The named arguments prevent us from overloads and also make our code much more readable. Also, we don't need to put in all the arguments. What I mean is, if you just had two parameters—<kbd>a</kbd> and <kbd>c</kbd>—then you would have to do something like this:</li>
</ol>
<pre style="padding-left: 60px">foo(1, 0.0, "Custom string")</pre>
<ol start="4">
<li>You have to add a default value to fill the space between <kbd>a</kbd> and <kbd>c</kbd>. However, with named arguments, you are able to use <kbd>foo(a=1,c="Custom string")</kbd> without needing default arguments in between.</li>
<li>One key thing to note is that when we call a function with both positional and named arguments, we need to place the positional arguments before the first named one. For example, the <kbd>foo(1,b = 0.1)</kbd> call is allowed, but <kbd>foo(a = 1, 0.1)</kbd> is not.</li>
</ol>
<p class="mce-root">The default values and named arguments can bring down the number of overloads needed to a minimum, making the code size small and improving the code's readability.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating the RecyclerView Adapter in Kotlin</h1>
                
            
            
                
<p><kbd>RecyclerView</kbd> is among the most widely used elements in Android development. It is essentially used to display data in a list using an adapter. In this recipe, we will learn how to leverage great things in Kotlin to make <kbd>RecyclerView</kbd> much more efficient. We will also be using <kbd>DiffUtils</kbd>. It is available from 24.02. According to the documentation:</p>
<p>DiffUtil is a utility class that can calculate the difference between two lists and output a list of update operations that converts the first list into the second one.</p>
<p>The definition is self-explainatory. The <kbd>notifyDatasetChanged</kbd><em> </em>is a very expensive operation of the adapter. The <kbd>DiffUtils</kbd> only updates the parts that were changed, unlike <kbd>notifyDatasetChanged</kbd>, which updates the whole list.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new Android project in Android Studio. You can also clone the <a href="https://gitlab.com/aanandshekharroy/kotlin-cookbook">https://gitlab.com/aanandshekharroy/kotlin-cookbook</a> repository and check out the 1-recycler-view-in-kotlin branch.</p>
<p class="mce-root">In this app, we will be creating a simple list of different Android flavors released by Google, something like what's seen here:</p>
<div><img height="1280" width="720" src="img/b54683bd-ccf2-4456-94b3-81583e451185.jpeg"/></div>
<p>As you can see, there is a floating action button; clicking it will update the order of the list. We will be updating the list (<kbd>RecyclerView</kbd>), but we will update it using <kbd>DiffUtils</kbd> instead of the <kbd>notifyDatasetChanged</kbd> method.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>So, let's now follow these steps to create the app we just discussed:</p>
<ol>
<li>First, we need to create a list of Android flavors. So, we will first create a data class that takes in image and name of flavor:</li>
</ol>
<pre style="padding-left: 60px">data class AndroidFlavours (var name:String, val image:Int)</pre>
<p style="padding-left: 60px">We have defined the type of image as <kbd>Int</kbd> because we will be using the IDs of drawable items. In the <kbd>drawable</kbd> folder, we will be keeping all the required images.</p>
<ol start="2">
<li>Next, we will create a list of Android flavors:</li>
</ol>
<pre style="padding-left: 60px">val flavorList= listOf&lt;AndroidFlavours&gt;(<br/>        AndroidFlavours("Cupcake",R.drawable.cupcake),<br/>        AndroidFlavours("Donut",R.drawable.donut),<br/>        AndroidFlavours("Eclair",R.drawable.eclair),<br/>        AndroidFlavours("Froyo",R.drawable.froyo),<br/>        AndroidFlavours("Gingerbread",R.drawable.gingerbread),<br/>        AndroidFlavours("HoneyComb",R.drawable.honeycomb),<br/>        AndroidFlavours("Icecream Sandwich",R.drawable.icecream),<br/>        AndroidFlavours("Jellybean",R.drawable.jellybean),<br/>        AndroidFlavours("KitKat",R.drawable.kitkat),<br/>        AndroidFlavours("Lollipop",R.drawable.lollipop))</pre>
<ol start="3">
<li class="mce-root">Now, we will create an adapter. We will name it <kbd>AndroidFlavourAdapter</kbd>:</li>
</ol>
<pre style="padding-left: 60px">class AndroidFlavourAdapter:RecyclerView.Adapter&lt;AndroidFlavourAdapter.FlavourViewHolder&gt;() {<br/>    var flavourItems:List&lt;AndroidFlavours&gt; by Delegates.observable(emptyList()){<br/>        property, oldValue, newValue -&gt;<br/>        notifyChanges(oldValue,newValue)<br/>    }<br/><br/>    <br/>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): FlavourViewHolder {<br/>        return FlavourViewHolder(parent.inflate(R.layout.flavour_item))<br/>    }<br/><br/>    override fun getItemCount(): Int =flavourItems.size<br/><br/>    override fun onBindViewHolder(holder: FlavourViewHolder, position: Int) {<br/>        holder.name.text=flavourItems.get(holder.adapterPosition).name<br/>        holder.image.loadImage(flavourItems.get(holder.adapterPosition).image)<br/>    }<br/><br/>    inner class FlavourViewHolder(var view: View):RecyclerView.ViewHolder(view){<br/>        var name:TextView = view.findViewById(R.id.textView)<br/>        var image:ImageView = view.findViewById(R.id.imageView)<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The preceding code is quite standard for the general implementation of <kbd>RecyclerView</kbd>, except for the two things.</p>
<p style="padding-left: 60px">One of these is the <kbd>loadImage</kbd> function, which is not a native function but an extension function, whose implementation is this:</p>
<pre style="padding-left: 60px">fun ImageView.loadImage(image: Int) {<br/>    Glide.with(context).load(image).into(this)<br/>}</pre>
<ol start="4">
<li>Another thing is that we have defined the list of <kbd>AndroidFlavours</kbd> in the adapters. The <kbd>flavoursList</kbd> in the adapter is an <kbd>observable</kbd> property. This means the listener gets notified of changes to this property. Hence, we get the following construct:</li>
</ol>
<pre style="padding-left: 60px">var flavourItems:List&lt;AndroidFlavours&gt; by Delegates.observable(emptyList()){<br/>    property, oldValue, newValue -&gt;<br/>    notifyChanges(oldValue,newValue)<br/>}<br/></pre>
<ol start="5">
<li>Now, whenever we try to assign a value to the <kbd>flavourItems</kbd> variable, the construct under the <kbd>{ .. }</kbd> block is run, and we have old and new values to do an operation if we want. In this case, we will do it using the <kbd>notifyChanges</kbd> method. Let's look at the <kbd>notifyChanges</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">private fun notifyChanges(oldValue: List&lt;AndroidFlavours&gt;, newValue: List&lt;AndroidFlavours&gt;) {<br/>    val diff = DiffUtil.calculateDiff(object : DiffUtil.Callback() {<br/>        override fun getChangePayload(oldItemPosition: Int, newItemPosition: Int): Any? {<br/>            val oldFlavor=oldValue.get(oldItemPosition)<br/>            val newFlavor=newValue.get(newItemPosition)<br/>            val bundle=Bundle()<br/>            if(!oldFlavor.name.equals(newFlavor.name)){<br/>                bundle.putString("name",newFlavor.name)<br/>            }<br/>            if(!oldFlavor.image.equals(newFlavor.image)){<br/>                bundle.putInt("image",newFlavor.image)<br/>            }<br/>            if(bundle.size()==0) return null<br/>            return bundle<br/>        }<br/><br/>        override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {<br/>            return oldValue.get(oldItemPosition)==newValue.get(newItemPosition)<br/>        }<br/><br/>        override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {<br/>            return oldValue.get(oldItemPosition).name.equals(newValue.get(newItemPosition).name)&amp;&amp;oldValue.get(oldItemPosition).image.equals(newValue.get(newItemPosition).image)<br/>        }<br/><br/>        override fun getOldListSize() = oldValue.size<br/><br/>        override fun getNewListSize() = newValue.size<br/><br/>    })<br/><br/>    diff.dispatchUpdatesTo(this)<br/>}</pre>
<p style="padding-left: 60px">I will explain the preceding code in the next section.</p>
<ol start="6">
<li>Now, let's set up the adapter:</li>
</ol>
<pre style="padding-left: 60px">mAdapter= AndroidFlavourAdapter()<br/>flavour_list.layoutManager=LinearLayoutManager(this)<br/>flavour_list.adapter=mAdapter<br/>mAdapter.flavourItems=flavorList<br/>shuffle.setOnClickListener {<br/>    mAdapter.flavourItems=flavorList.shuffle()<br/>}</pre>
<ol start="7">
<li>The <kbd>shuffle</kbd> function will just randomize the order of the list of <kbd>AndroidFlavours</kbd>. The <kbd>.shuffle()</kbd> function is not a native function provided by Kotlin or Java, but an extension function:</li>
</ol>
<pre style="padding-left: 60px">fun &lt;E&gt; List&lt;E&gt;.shuffle(): MutableList&lt;E&gt; {<br/>    val list = this.toMutableList()<br/>    Collections.shuffle(list)<br/>    return list<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's dive into the <kbd>DiffUtils</kbd>. The <kbd>DiffUtils</kbd> requires two arrays/lists, one of which should be the old list and the other should be the new list.</p>
<p>There are five main functions:</p>
<ul>
<li><kbd>getNewListSize()</kbd>: This returns the size of the new list.</li>
<li><kbd>getOldListSize()</kbd>: This method returns the size of the old list.</li>
<li><kbd>areItemsTheSame()</kbd>: This method is used to determine whether two objects represent the same item.</li>
<li><kbd>areContentsTheSame()</kbd>: This method is used to determine whether the two objects contain the same data. In our implementation, we are returning true if both objects have the same name and image.</li>
<li><kbd>getChangePayload()</kbd>: When <kbd>areItemsTheSame()</kbd> returns true and <kbd>areContentsTheSame()</kbd> returns false, then <kbd>DiffUtils</kbd> calls this method to get the payload of changes.</li>
</ul>
<p>In our implementation of the preceding method, we are adding the change of name and image in the payload:</p>
<pre style="padding-left: 60px">override fun getChangePayload(oldItemPosition: Int, newItemPosition: Int): Any? {<br/>    val oldFlavor=oldValue.get(oldItemPosition)<br/>    val newFlavor=newValue.get(newItemPosition)<br/>    val bundle=Bundle()<br/>    if(!oldFlavor.name.equals(newFlavor.name)){<br/>        bundle.putString("name",newFlavor.name)<br/>    }<br/>    if(!oldFlavor.image.equals(newFlavor.image)){<br/>        bundle.putInt("image",newFlavor.image)<br/>    }<br/>    if(bundle.size()==0) return null<br/>    return bundle<br/>}</pre>
<p>Finally, after the diff calculation, the <kbd>DiffUtils</kbd> object dispatches the changes to the Adapter. To do that, we call the <kbd>dispatchUpdatesTo</kbd> method:</p>
<pre style="padding-left: 60px">diff.dispatchUpdatesTo(this)</pre>
<p>To update the changes from the data in the payload, you need to override <kbd>onBindViewHolder</kbd> <em>(</em><kbd>holder: FlavourViewHolder</kbd><em>,</em> <kbd>position: Int</kbd><em>,</em> <kbd>payloads: MutableList&lt;Any&gt;?</kbd>):</p>
<pre style="padding-left: 60px">override fun onBindViewHolder(holder: FlavourViewHolder, position: Int, payloads: MutableList&lt;Any&gt;?) {<br/>    if (payloads != null) {<br/>        if (payloads.isEmpty())<br/>            return onBindViewHolder(holder,position)<br/>        else {<br/>            val o = payloads.get(0) as Bundle<br/>            for (key in o.keySet()) {<br/>                if (key == "name") {<br/>                    holder.name.text=o.getString("name")<br/>                } else if (key == "image") {<br/>                    holder.image.loadImage(o.getInt("image"))<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The changes in the payload are dispatched using the <kbd>notifyItemRangeChanged</kbd> method of the adapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The documentation states that the <kbd>DiffUtils</kbd> might take some time to process the diff between two lists if the lists are too big, so this must be calculated on a background thread, for example, using <kbd>RxJava</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating getter setters in Kotlin</h1>
                
            
            
                
<p>If you have worked with Java, you probably know what a <em>getter-setter</em> is. Java has fields and getter-setters are the methods that are used to <strong>access </strong>(getter) and <strong>modify </strong>(setter) member variables. They are an essential part of encapsulation (one of the design principles).</p>
<p>However, in Kotlin, we don't have any fields, but we have <strong>properties</strong> instead. A property can have a custom implementation of an <strong>accessor</strong> and a <strong>mutator.</strong> In this recipe, we will see how we can implement custom accessors and mutators.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA to write and execute our code. You can use whatever development environment you are comfortable with. We will be using examples to understand the custom getter-setters of Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's follow these steps to understand how custom getter-setters work in Kotlin:</p>
<ol>
<li>The syntax of a Kotlin <kbd>property</kbd> looks like this:</li>
</ol>
<pre style="padding-left: 60px">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]  [&lt;getter&gt;]  [&lt;setter&gt;]</pre>
<p style="padding-left: 60px">So if you use something like <kbd>val a =1</kbd>, you get a default <kbd>getter</kbd> and <kbd>setter</kbd>.</p>
<ol start="2">
<li>Now, let's see how we can create a custom <kbd>getter</kbd>. Suppose we have a property whose value depends on another property:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val sample=Sample()<br/>    println(sample.isListBig)<br/>}<br/>class Sample{<br/>    val array= mutableListOf&lt;Int&gt;(1,2,3)<br/>    val isListBig:Boolean<br/>        get()=array.size&gt;2<br/>}</pre>
<p style="padding-left: 60px">If you run the preceding code, you'll see the output in the console as follows:</p>
<div><img height="211" width="590" src="img/03cb3100-9ee4-4b7d-8892-2d2cc59edbf2.png"/></div>
<ol start="3">
<li>As you can see, we can modify the getter in the <kbd>get</kbd> method of the property. If the property type is inferred from the getter, we can also do this:</li>
</ol>
<pre style="padding-left: 60px">val isListBig get()=array.size&gt;2</pre>
<p style="padding-left: 60px">The result will be the same, of course.</p>
<p>Now, let's take a look at accessors:</p>
<ol>
<li>In Java, we used to do something like the following:</li>
</ol>
<pre style="padding-left: 60px">public setIsListBig(boolean isListBig){<br/>    this.isListBig=isListBig<br/>}</pre>
<ol start="2">
<li>If we try to pull this off in Kotlin, it will look something like this:</li>
</ol>
<div><img height="95" width="412" src="img/dce9a56d-ffa5-4a0d-9573-69d304ed95b6.png"/></div>
<ol start="3">
<li>As you can see, we will get a warning from IDE suggesting that it is a recursive call. Why? Because when you are trying to set a value using<kbd>.isListBig</kbd>, you are already using a setter inside a setter, hence the <strong>recursive cycle</strong>.</li>
<li>In order to get away from this recursive call and still implement a setter, you need the <kbd>field</kbd> keyword. So the preceding implementation will look something like this:</li>
</ol>
<pre style="padding-left: 60px">var isListBig :Boolean = false<br/>    set(value) {<br/>        field= array.size&gt;2<br/>    }</pre>
<ol start="5">
<li>When you initialize <kbd>isListBig</kbd> while declaring the property, the value is assigned to the backing field without invoking the setter. The <kbd>field</kbd> keyword is used to access the backing field, and it will be generated for a property if it uses the default implementation of at least one of the accessors, or if a custom accessor references it through the <kbd>field</kbd> identifier.</li>
</ol>
<ol start="6">
<li>If you want to restrict the access of your setter, you can do so with the following:</li>
</ol>
<pre style="padding-left: 60px">var isListBig :Boolean = false<br/>    private set(value) {<br/>        field= array.size&gt;2<br/>    }</pre>
<ol start="7">
<li>Also, suppose you are using some sort of dependency injection. You can do it with this:</li>
</ol>
<pre style="padding-left: 60px">var mPresenter:MainActivityMvpPresenter?=null<br/>    @Inject set</pre>
<ol start="8">
<li>Similar to <kbd>set</kbd>, you can also have a custom implementation of <kbd>get</kbd>.  Let's look at an example:</li>
</ol>
<pre style="padding-left: 60px">class SameClass {<br/>    var name="aanand"<br/>    get() = field.toUpperCase()<br/>}</pre>
<ol start="9">
<li>Now, let's say that we are trying to access the <kbd>name</kbd> property:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var s=SameClass()<br/>    println(s.name)<br/>}</pre>
<p>If you run the preceding code, you'll see this output:</p>
<div><img height="228" width="497" src="img/60f65486-b3f3-440f-aca3-691f96c2f84f.png"/></div>
<p>Note that we have used <kbd>field</kbd> in the <kbd>get()</kbd> method too. It's the same backing field that we explained earlier.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>One thing to note here is that you cannot implement a custom getter or setter for your property in the constructor. You need to declare a property in the body of the class:</p>
<pre style="padding-left: 60px">class Student(val name: String, age: Int) {<br/>  var age: Int = age<br/>      set(value) {<br/>        println("Setting age to $value")<br/>        field = value<br/>  }<br/>}</pre>
<p>One key thing to note here is that you need to keep the visibility of the getter exactly similar to the visibility of the property:</p>
<pre style="padding-left: 60px">protected var name="aanand"<br/>protected get() = field.toUpperCase()</pre>
<p>The preceding code is perfectly valid, though it's redundant to place the same access modifier again, hence it's better to omit it.</p>
<p>The setter, on the other hand, can have an access modifier less permissive than the property. Consider this example:</p>
<pre style="padding-left: 60px">protected var name="aanand"<br/>    private set</pre>
<p>The preceding code is valid because the access modifier of the setter, <kbd>private</kbd>, is less permissive than the property's access modifier:</p>
<pre style="padding-left: 60px">protected var name="aanand"<br/>    public set</pre>
<p>The preceding code, however, is not valid, as <kbd>protected</kbd> is less permissive than <kbd>public</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Passing variable arguments to a function</h1>
                
            
            
                
<p>There are a lot of scenarios in which we need to pass variable arguments to a function. In Kotlin, we can do that using the <kbd>vararg</kbd> modifier. In this recipe, we will go through all the ways of doing that. We will look at a few examples to demonstrate how to use this feature of Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p class="mce-root">You need to install the preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need Kotlin compiler installed, along with JDK. I am using an online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA for your development environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's go through the following steps, where we demonstrate how to pass a variable number of arguments to a function:</p>
<ol>
<li class="mce-root">Using <kbd>vararg</kbd>, we can pass comma-separated arguments to a function, where we have defined the single argument to a method as <kbd>vararg</kbd>, as in the following example:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    someMethod("as","you","know","this","works")<br/>}<br/>fun someMethod(vararg a: String) {<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>}</pre>
<ol start="2">
<li class="mce-root">Also, if you already have an array of values, you can directly pass it using the <kbd>*</kbd> spread operator:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    val list = arrayOf("as","you","know","this","works")<br/>    someMethod(*list)<br/>}<br/>fun someMethod(vararg a: String) {<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>}</pre>
<p style="padding-left: 60px">So basically, <kbd>vararg</kbd> tells the compiler to take the passed arguments and wrap them into an array.</p>
<ol start="3">
<li>The spread operator, on the other hand, simply tells the compiler to unwrap array members and pass them as separate arguments. The spread operator—that is, <kbd>*</kbd>–is put just before the name of the array being passed in.</li>
<li>However, obviously one may always need to pass other arguments, named arguments, and so on.<br/>
In the following example code, we try to pass another argument other than <kbd>vararg</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    val list = arrayOf("as","you","know","this","works")<br/>    someMethod(3, *list)<br/>}<br/>fun someMethod(b: Int, vararg a: String) {<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>}</pre>
<ol start="5">
<li class="mce-root">In the next example, the first argument is similar to the <kbd>vararg</kbd> type, but it works:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    someMethod("3", "as","you","know","this","works")<br/>}<br/>fun someMethod(b: String, vararg a: String) {<br/>    println("b: " + b)<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">The output is as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>b: 3</strong><br/><strong>as</strong><br/><strong>you</strong><br/><strong>know</strong><br/><strong>this</strong><br/><strong>works</strong></pre>
<ol start="6">
<li class="mce-root">So usually, <kbd>vararg</kbd> is the last argument passed, but what if we want to pass other arguments after <kbd>vararg</kbd>? We can, but they have to be named. That is why the following code will not compile:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">// does not compile<br/>fun main(args: Array&lt;String&gt;) {<br/>    someMethod("3", "as","you","know","this","works", "what")<br/>}<br/>fun someMethod(b: String, vararg a: String, c: String) {<br/>    println("b: " + b)<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>    println("c: " + c)<br/>}</pre>
<ol start="7">
<li class="mce-root">It does not compile because the last string passed in it is considered part of <kbd>vararg</kbd>, and the compiler throws an error because we did not pass the value of <kbd>c</kbd>.<br/>
To do it correctly, we need to pass <kbd>c</kbd> as a named argument, just as shown here:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    someMethod("3", "as","you","know","this","works", c = "what")<br/>}<br/>fun someMethod(b: String, vararg a: String, c: String) {<br/>    println("b: " + b)<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>    println("c: " + c)<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">The output is as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>b: 3</strong><br/><strong>as</strong><br/><strong>you</strong><br/><strong>know</strong><br/><strong>this</strong><br/><strong>works</strong><br/><strong>c: what</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">The <kbd>vararg</kbd> modifier tells the compiler to take all comma-separated arguments and wrap them into an array, while <kbd>*</kbd>—that is the spread operator—unwraps elements of the array and passes them as arguments.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p class="mce-root">What if we want the first argument to have a default value, like in this example:</p>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    someMethod("3", "as","you","know","this","works")<br/>}<br/>fun someMethod(b: String = "x", vararg a: String) {<br/>    println("b: " + b)<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>}</pre>
<p class="mce-root">We want all arguments to be considered as part of <kbd>vararg</kbd>, but the compiler reads the first argument as <kbd>b</kbd>. In this case, naming the passed arguments can solve the problem:</p>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    someMethod(a = *arrayOf("3", "as","you","know","this","works"))<br/>}<br/>fun someMethod(b: String = "x", vararg a: String) {<br/>    println("b: " + b)<br/>    for (a_ in a) {<br/>        println(a_)<br/>    }<br/>}</pre>
<p class="mce-root">In the preceding code, the compiler understands that the value of <kbd>b</kbd> is not passed, and it takes the default value. Similarly, if you want to have two <kbd>vararg</kbd> in your function, you will need to pass named arguments.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Passing a function as a parameter to another</h1>
                
            
            
                
<p>Kotlin gives us the power to declare <em>high-order functions</em>. In a high-order function, we can pass and return functions as parameters. This is an extremely useful feature and makes our code much more easy to work with. In fact, many of the Kotlin library’s functions are high order, such as <kbd>map</kbd>. In Kotlin, we can declare functions and function references as values that are then passed in to the function. In this section, we will first understand how to declare lambdas and then how to pass them into a function.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need Kotlin compiler installed, along with JDK. I am using an online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA as the development environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's follow these steps to understand the working of high-order functions:</p>
<ol>
<li>Let's start by understanding how we declare functions as lambdas:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val funcMultiply = {a:Int, b:Int -&gt; a*b}<br/>    println(funcMultiply(4,3))<br/>    val funcSayHi = {name: String -&gt; println("Hi $name")} <br/>    funcSayHi("John")<br/>}</pre>
<ol start="2">
<li>In the preceding code block, we declared two lambdas: one (<kbd>funcMultiply</kbd>) that takes two integers and returns an integer, and another (<kbd>funcSayHi</kbd>) lambda that takes a string and returns a unit—that is, it returns nothing.</li>
<li>Although we did not need to declare the type of arguments and the return type in the preceding example, in some cases we need to explicitly declare the argument types and return types. We do this in the following way:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val funcMultiply : (Int, Int)-&gt;Int = {a:Int, b:Int -&gt; a*b}<br/>    println(funcMultiply(4,3))<br/>    val funcSayHi : (String)-&gt;Unit = {name: String -&gt; println("Hi $name")} <br/>    funcSayHi("John")<br/>}</pre>
<ol start="4">
<li class="mce-root">So now that we have a general idea of how lambdas work, let's try and pass one in another function—that is, we will try a high-order function. Check out this code snippet:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    val funcMultiply : (Int, Int)-&gt;Int = {a:Int, b:Int -&gt; a*b}<br/>    val funcSum : (Int, Int)-&gt;Int = {a:Int, b:Int -&gt; a+b}<br/>    performMath(3,4,funcMultiply)<br/>    performMath(3,4,funcSum)<br/>}<br/>fun performMath(a:Int, b:Int, mathFunc : (Int, Int) -&gt; Int) : Unit {<br/>    println("Value of calculation: ${mathFunc(a,b)}")<br/>}</pre>
<ol start="5">
<li class="mce-root">Yup, it is as simple as that—create a function lambda and pass it into the function. So this is just one aspect of a high-order function—that is, we can pass a function as an argument to the function.</li>
<li class="mce-root">Another use of high-order functions is to return a function. Consider the following example where we need a function that transforms the total price of an order according to certain conditions. Kind of like in an e-commerce site, but way simpler:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    val productPrice1 = 600; // free delivery of order above 499<br/>    val productPrice2 = 300; // not eligible for free deliver<br/>    val totalCost1 = totalCost(productPrice1)<br/>    val totalCost2 = totalCost(productPrice2)<br/> <br/>    println("Total cost for item 1 is ${totalCost1(productPrice1)}")<br/>    println("Total cost for item 2 is ${totalCost2(productPrice2)}")<br/>}<br/>fun totalCost(productCost:Int) : (Int) -&gt; Int{<br/>    if(productCost &gt; 499){<br/>        return { x -&gt; x }<br/>    }<br/>    else {<br/>        return { x -&gt; x + 50 }<br/>    }<br/>}</pre>
<ol start="7">
<li>Note how we need to change functions that we apply based on certain conditions so that we return a function that suits the conditions. We assign the returned function to a variable and then we can just put <kbd>append ()</kbd> in front of the variable to use it as a function, just like we did with the lambdas. This works because the high-order function is essentially returning a lambda.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p class="mce-root">In Kotlin, we can assign a function to a variable, and then we can pass it into a function or return it from a function. This is because it's essentially declared like a variable. This is done using a lambda declaration of functions.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Declaring a static function</h1>
                
            
            
                
<p><strong>Static functions</strong> are very useful as they help us prevent copying the same methods in multiple objects so you can follow the <strong>don't repeat yourself</strong> (<strong>DRY</strong>) rule. They are also useful when you don't need to create an instance of an object. In Kotlin, we don't have static methods/functions and variables, like we did in Java, but we can still achieve the same results. Let's see how!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA to write and execute our code. You can use whatever development environment you are comfortable with. We will be learning about static functions by going through the examples and their workings.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>One of the use cases of static methods is that we can prevent multiple copying of the same methods in different classes, and also that we don't need to create an object of the enclosing class.</p>
<p>Kotlin recommends creating package-level functions. If you are coming from the Java world, this probably won't make any sense to you as this isn't supported in Java. Let's see how it's done in Kotlin:</p>
<ol>
<li>You need to create a Kotlin file with the <kbd>.kt</kbd> extension and just declare the method that you'll be using in many places. I have created a <kbd>SampleClass.kt</kbd> file and have added a method that we will be calling from other classes:</li>
</ol>
<pre style="padding-left: 60px">package packageA<br/>fun foo(){<br/>    println("calling from boo method")<br/>}</pre>
<ol start="2">
<li>Now, I'll call this method from <kbd>HelloWorld.kt</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import packageA.*<br/>fun main(args: Array&lt;String&gt;) {<br/>    foo()<br/>}</pre>
<ol start="3">
<li>Since the function was present in <kbd>packageA</kbd>, we used the <kbd>import</kbd> statement. This way, we followed DRY and didn't need to create an instance of any class.</li>
<li>Another way to do it is by putting methods or variables in an object declaration. So we can modify the <kbd>SameClass.kt</kbd> into the following:</li>
</ol>
<pre style="padding-left: 60px">package packageA<br/>object Foo{<br/>    fun callFoo() = println("Foo")<br/>    var foo="foo"<br/>}</pre>
<ol start="5">
<li>Any method or variable under object declaration will work as a <kbd>static</kbd> method or variable. In order to access it, we can do this:</li>
</ol>
<pre style="padding-left: 60px">Foo.callFoo()</pre>
<p style="padding-left: 60px">This is much like how we call static methods.</p>
<ol start="6">
<li>However, suppose you want the class name as a qualifier and access elements of the class. You can still use it using the <kbd>companion</kbd> keyword. Here's how it will look:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    SampleClass.foo()<br/>}<br/>class SampleClass{<br/>    companion object {<br/>        fun foo()= print("In foo method")<br/>    }<br/>}</pre>
<ol start="7">
<li>If you want to call the method under the <kbd>companion</kbd> object, you'll need to access it like this:</li>
</ol>
<pre style="padding-left: 60px">SampleClass.Companion.foo();</pre>
<ol start="8">
<li>If <kbd>Companion</kbd> seems like an eyesore to you, you can use the <kbd>@JvmStatic</kbd> annotation:</li>
</ol>
<pre style="padding-left: 60px">companion object {<br/>    @JvmStatic<br/>    fun foo()= print("In foo method")<br/>}</pre>
<ol start="9">
<li>Then, you can access it using <kbd>SampleClass.foo()</kbd>, just like you do in a Kotlin class.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the use keyword in Kotlin</h1>
                
            
            
                
<p>There are some situations where if you use a resource (for example, a file) then you have to take care of its lifecycle so that you don't leak resources. For example, if you read from a file, you need to close it after use, or else you'll leave it in an unstable state. Java 7 brought an update that could handle this without a need to handle it explicitly. Kotlin also provides this feature, but in a much easier way. It does so by using the <kbd>use</kbd> method. We will learn about this in the following recipe. So let's get started!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA to write and execute our code. You can use whatever development environment you are comfortable with.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's take the following steps to understand the <kbd>use</kbd> function of Kotlin:</p>
<ol>
<li>To understand the <kbd>use</kbd> keyword, we will need to go back to Java. Prior to Java 7, managing the resources that needed to be closed was a bit cumbersome. For example, look at the following code:</li>
</ol>
<pre style="padding-left: 60px" class="codeBox">private static void printFile() throws IOException {
    InputStream input = null;

    try {
        input = new FileInputStream("sampleFile.txt");
        // Some operation using <strong>input</strong> object
    } finally {
        if(input != null){
            input.close();<br/>        // closing the resource
        }
    }
}</pre>
<ol start="2">
<li>Let's examine the preceding code. We know an exception can be thrown inside the <kbd>try</kbd> block when we use the <kbd>input</kbd> object. However, it can also be thrown in the <kbd>finally</kbd> block, because we are trying to close the <kbd>input</kbd> object. Now, the <kbd>finally</kbd> block will be called whether or not the <kbd>try</kbd> block throws an exception. Suppose both the <kbd>try</kbd> and <kbd>finally</kbd> blocks throw exceptions—which one of the two will propagate? The answer is that the exception will be thrown in the <kbd>finally</kbd> block, even if the exception of <kbd>try</kbd> would make more sense here.</li>
<li>Java 7 brought an update to this problem by introducing the try-with-resource construct, which looks something like this:</li>
</ol>
<pre style="padding-left: 60px" class="codeBox">try(FileInputStream input = new FileInputStream("file.txt")) {
        int data = input.read();
        // operations on input object
    }</pre>
<ol start="4">
<li>When the <kbd>try</kbd> block finishes executing, the <kbd>FileInputStream</kbd> object is closed automatically. Also, if both the operations—<kbd>input.read()</kbd> and the closing of the input object—throw exceptions, the exception thrown by <kbd>input.read()</kbd> will propagate. The <kbd>use</kbd> keyword of Kotlin does the exact same work. In this section, we will see how.</li>
<li>In the preceding example, we saw in Java will look something like the following in Kotlin if we implement the <kbd>use</kbd> keyword:</li>
</ol>
<pre style="padding-left: 60px">FileInputStream("file.txt").use {<br/>    input -&gt;<br/>    var data = input.read()<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>use</kbd> accepts a function literal and is defined as an extension on an instance of closeable. It will close down the resource, just like the try-with-resources construct, after the function <br/>
has completed, whether an exception was raised or not.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with closures</h1>
                
            
            
                
<p>MDN (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a>) says this:</p>
<p>“A closure is a special kind of object that combines two things: a function, and the environment in which that function was created. The environment consists of any local variables that were in-scope at the time the closure was created”</p>
<p><strong>Closures</strong> in functional programming are the functions that are <em>aware</em> of their surroundings. By this, I mean that a closure function has access to the variables and parameters defined in the outer scope. Remember that in Java and traditional procedural programming, the variables were tied to the scope, and as soon as the block got executed, local properties were blown out of the memory. Java 8 lambdas can access outer variables, but can't modify them, and this limits the capabilities if you try to do functional programming in Java 8. Let's take a look at an example where we work with closures in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using IntelliJ IDEA for writing and executing our code. You can use whatever development environment you are comfortable with.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In this example, we will simply create an array of integers and calculate its sum:</p>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var sum=0<br/>    var listOfInteger= arrayOf(0,1,2,3,4,5,6,7)<br/>    listOfInteger.forEach {<br/>        sum+=it<br/>    }<br/>    println(sum)<br/>}</pre>
<p>In the preceding example, the <kbd>sum</kbd> variable is defined in the outer scope; still, we are able to access and modify it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you want to learn more about high-order functions or closures, head on to the <em>Passing a function as a parameter to another</em> recipe of this chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Function literals with receivers</h1>
                
            
            
                
<p>A <strong>Function literal</strong> is a function that is not declared but that is passed in as an expression. Lambdas and anonymous functions are function literals. In Kotlin, we can call a function literal with a receiver object, and we can call methods on the receiver object inside the body of the function literal, quite like extension functions. In this recipe, we will learn how to use function literals with receivers.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need Kotlin compiler installed, along with JDK. I am using an online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA for development environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to understand function literals:</p>
<ol>
<li>Let's start with a simple function literal on a <kbd>String</kbd>, which returns a string added to the receiver string:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var str1 = "The start of a "<br/>    val addStr = fun String.(successor: String): String {<br/>        return this + successor <br/>    }<br/>    str1 = str1.addStr("beautiful day.")<br/>    println(str1)<br/>}</pre>
<p style="padding-left: 60px">A function literal has access to the receiver it has been called on, and it can access methods associated with that receiver.</p>
<ol start="2">
<li>We can also pass the receiver as a parameter in an ordinary function, where the first parameter is for a receiver. This can be useful in scenarios where we need to use an ordinary function.<br/>
So <kbd>String.(String) -&gt; Int</kbd> is similar to <kbd>(String, String) -&gt; Int</kbd> is compatible. Check out the following example :</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var str1 = "The start of a "<br/>    val addStr = fun String.(successor: String): Int {<br/>        return this.length + successor.length<br/>    }<br/>    var x = str1.addStr("beautiful day.")<br/>    println(x)<br/>    fun testIfEqual(op: (String, String) -&gt; Int, a: String, b: String, c: Int) =<br/>    assert(op(a, b) == c)<br/> <br/>    testIfEqual(addStr, "The start of a ", "beautiful day.", str1.length + "beautiful    day.".length) // OK<br/>}</pre>
<p class="mce-root">If the receiver type can be inferred, then lambda can be used as the function literal.</p>
<p class="mce-root">So basically, we can call a function literal on a receiver object, and inside the body of the function, we can access and call methods on a receiver object, similar to an extension function in Kotlin. The following is the syntax for this:</p>
<pre class="mce-root">receiver.functionLliteral(arguments) -&gt; ReturnType</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with anonymous functions</h1>
                
            
            
                
<p>In Kotlin, we can have functions as expressions by creating lambdas. Lambdas are function literals—that is, they are not declared as they are expressions and can be passed as parameters. However, we cannot declare return types in lambdas. Although the return type is inferred automatically by Kotlin compiler in most cases, for cases where it cannot be inferred on its own or it needs to be declared explicitly, we use anonymous functions. In this recipe, we will see how to use anonymous functions.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need Kotlin compiler installed, along with JDK. I am using an online IDE at <a href="https://try.kotlinlang.org/">https://try.kotlinlang.org/</a> to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA for the development environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the following steps, we will learn about anonymous functions with the help of some examples:</p>
<ol>
<li>Let's start by declaring a function as a lambda:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    val funcMultiply = {a:Int, b:Int -&gt; a*b}<br/>    println(funcMultiply(4,3))<br/>    val funcSayHi = {name: String -&gt; println("Hi $name")} <br/>    funcSayHi("John")<br/>}</pre>
<p style="padding-left: 60px">In the preceding code block, we have declared two lambdas: one (<kbd>funcMultiply</kbd>) that takes two integers and returns an integer, and another (<kbd>funcSayHi</kbd>) lambda that takes a string and returns a unit—that is, it returns nothing.</p>
<ol start="2">
<li>Although in the preceding example we did not need to declare the type of arguments and return type, in some cases we need to explicitly declare the argument types and return types. We do that in the following way, by means of an anonymous function:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var funcMultiply = fun (a: Int, b: Int): Int {return a*b}<br/>    println(funcMultiply(4,3))<br/>    fun(name: String): Unit = println("Hi $name")<br/>}</pre>
<ol start="3">
<li class="mce-root">So now we have a general idea of how anonymous functions work. Now, let's try and pass one in another function—that is, we will try a high-order function. Check out this code snippet:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    var funcMultiply = fun(a: Int, b: Int): Int { return a*b }<br/>    var funcSum = fun(a: Int, b: Int): Int { return a+b }<br/>    performMath(3,4,funcMultiply)<br/>    performMath(3,4,funcSum)<br/>}<br/>fun performMath(a:Int, b:Int, mathFunc : (Int, Int) -&gt; Int) : Unit {<br/>    println("Value of calculation: ${mathFunc(a,b)}")<br/>}</pre>
<ol start="4">
<li class="mce-root">So basically, an anonymous function is declared just like a regular function, but without a name. The body can be an expression, as in the following example, or a block, as in the preceding example. One thing to note is that parameters are always passed inside the parentheses in the case of anonymous functions, unlike in lambda expressions:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    performMath(3,4,fun(a: Int, b: Int): Int = a*b )<br/>    performMath(3,4,fun(a: Int, b: Int): Int = a+b )<br/>}<br/>fun performMath(a:Int, b:Int, mathFunc : (Int, Int) -&gt; Int) : Unit {<br/>    println("Value of calculation: ${mathFunc(a,b)}")<br/>}</pre>
<ol start="5">
<li class="mce-root">Another interesting difference between a lambda and an anonymous function is that in a lambda, the return statement returns from the enclosing function, whereas in an anonymous function, it simply returns from the function itself.</li>
<li class="mce-root">One can omit the parameter type and return type from an anonymous function as well if it can be inferred on its own.</li>
<li class="mce-root">Anonymous functions can access and modify variables inside their closures.</li>
</ol>
<p>So basically, one can declare an anonymous function just like a regular function without a name (hence, the name anonymous). It can be an expression or a code block.</p>


            

            
        
    </div>



  </body></html>