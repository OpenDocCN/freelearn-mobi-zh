- en: Chapter 4. Enumerations and Pattern Matching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 枚举和模式匹配
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Functional Programming
    in Swift") , *Getting Started with Functional Programming in Swift*, we were introduced
    to enumerations briefly. In this chapter, we will cover enumerations and algebraic
    data types in detail. Also, we will explore patterns and pattern matching in Swift.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. Swift函数式编程入门")中，我们简要介绍了枚举。在本章中，我们将详细介绍枚举和代数数据类型。此外，我们还将探讨Swift中的模式和模式匹配。
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过代码示例涵盖以下主题：
- en: Defining enumerations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义枚举
- en: Associated values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联值
- en: Raw values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始值
- en: Using enumerations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用枚举
- en: Algebraic data types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数数据类型
- en: Patterns and pattern matching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和模式匹配
- en: Defining enumerations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义枚举
- en: 'In Swift, an enumeration defines a common type for related values and enables
    us to work with those values in a type-safe way. Values provided for each enumeration
    member can be a `String`, `Character`, `Integer`, or any `floating-point` type.
    The following example presents a simple definition of an enumeration:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，枚举定义了一个相关值的公共类型，并使我们能够以类型安全的方式处理这些值。为每个枚举成员提供的值可以是`String`、`Character`、`Integer`或任何`floating-point`类型。以下示例展示了枚举的一个简单定义：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`MLSTeam` `enum` provides us options for MLS teams. We can choose only one
    of the options each time; in our example, `Montreal` is chosen.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`MLSTeam` `enum`为我们提供了选择MLS球队的选择。我们每次只能选择一个选项；在我们的示例中，选择了`Montreal`。'
- en: 'Multiple cases can be defined, separated by a comma on a single line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义多个情况，用单行上的逗号分隔：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The type of `theTeam` is inferred when it is initialized with `MLSTeam.montreal`.
    As `theTeam` is already defined, we can change it with a shorter syntax as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`MLSTeam.montreal`初始化`theTeam`时，其类型被推断为`MLSTeam`。由于`theTeam`已经定义，我们可以使用更短的语法进行更改，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We were able to change `theTeam` with a short syntax because `theTeam` was already
    inferred and was not a constant.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用简短的语法更改`theTeam`，因为`theTeam`已经被推断，并且不是一个常量。
- en: Associated values
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联值
- en: 'Enumerations can store associated values of any given type, and the value types
    can be different for each member of the enumeration if required. Enumerations
    similar to these are known as discriminated unions, tagged unions, or variants
    in other programming languages. The following example presents a simple usage
    of associated values:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举可以存储任何给定类型的关联值，如果需要，枚举的每个成员的值类型可以不同。类似这些的枚举在其他编程语言中被称为有区别的联合、标记联合或变体。以下示例展示了关联值的一个简单用法：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The enumeration type, `Length`, can either take a value of `US` with an associated
    value of the `Double` type or a value of `metric` with an associated value of
    the `Double` type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型`Length`可以取`US`值，其关联值为`Double`类型，或者取`metric`值，其关联值为`Double`类型。
- en: The `lengthMetric` is a variable that gets assigned as a value of `Length.metric`
    with an associated value of `1.6`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`lengthMetric`是一个变量，其值被分配为`Length.metric`，关联值为`1.6`。'
- en: As seen in the preceding example, associated values are set when we create a
    new constant or variable based on one of the enumeration's cases and can be different
    each time we do so.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，当我们基于枚举的某个情况创建新的常量或变量时，会设置关联值，并且每次都可能不同。
- en: Raw values
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始值
- en: 'Enumeration members can come prepopulated with default values (called **raw
    values**), which are all of the same type. The following example presents an incomplete
    `HttpError enum` with raw values:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举成员可以预先填充默认值（称为**原始值**），这些值都是同一类型。以下示例展示了带有原始值的`HttpError`枚举的一个不完整示例：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the raw values for `enum` called `HttpError` are defined
    to be of the `Int` type and are set to some of their integer code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，`enum`名为`HttpError`的原始值被定义为`Int`类型，并设置为一些整数代码。
- en: Raw values can be of `String`, `Character`, `Int`, or any floating number types.
    Each raw value must be unique within its enumeration declaration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值可以是`String`、`Character`、`Int`或任何浮点数类型。每个原始值必须在枚举声明内是唯一的。
- en: Raw values are set to prepopulated values when we first define the enumeration
    such as `HttpError` in the preceding example; therefore, the raw value for an
    enumeration case is always the same and it is not going to change, unlike associated
    values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次定义枚举时，原始值被设置为预填充值，如前例中的`HttpError`；因此，枚举情况的原始值始终相同，并且不会改变，这与关联值不同。
- en: 'If we define an enumeration with a raw-value type, the enumeration automatically
    receives an initializer that takes a value of the raw value''s type and returns
    either an enumeration `case` or `nil`. We can use this initializer to try to create
    a new instance of the enumeration. The following example presents the initialization
    of an `HttpError` instance:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Algebraic data types
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerations in Swift are actually algebraic data types that are types created
    by combining other types. Algebraic data types are essential to many functional
    programming languages such as Haskell.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: An algebraic data type is based on the idea of algebraic structures, which are
    a set of possible values and one or more operators to combine a finite number
    of these values into a single one. A well-known structure, for example, is (`ℤ`,
    `+`, `-`), a set of all integers with the plus and minus operations on them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: So an algebraic data type is a data type that is created by algebraic operations,
    specifically, with sum and product as our operations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, algebraic data types are composite data types that may contain
    multiple values such as a data type with multiple fields, or they may consist
    of variants or multiple finite different values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Simple types
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Boolean` type is a simple algebraic data type as it may take one of two
    values: `true` or `false`. An instance of a `Boolean` type should be either `true`
    or `false`, but the instance cannot be both at once; it has to be one or the other
    unlike the `struct`/`class` properties and variables.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Composite types
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Algebraic data types can also be composite types. For instance, a tuple of two
    `Double` values is a simple algebraic data type. Such a tuple could be expressed
    as having the `(Double, Double)` type, and an example value for this type could
    be `(1.5, 3.2)`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Composite type with variants
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Algebraic data types can be composite types with variants as well. We could
    create an `enum` named `Dimension` to hold the length and width. We can express
    this `enum` in both `us` feet and `metric` meters. In Swift, we can define such
    an `enum` as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we can use the `Dimension` enumeration to create a variable as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The algebra of data types
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that enums in Swift are actually algebraic data types. Let's explore
    some examples to get more familiar with the topic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a simple `enum` `NHLTeam` with different options.
    The `enum` `Team` uses `NHLTeam` along with `MLSTeam` that we have defined before
    to combine `Hockey` and `Soccer` teams. `Team` can be either a `Hockey NHL` team
    or a `Soccer MLS` team:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`MLSTeam` and `NHLTeam` each have six potential values. If we combine them,
    we will have two new types. `Team` can be either `NHLTeam` or `MLSTeam`, so it
    has 12 potential values that is the sum of `NHLTeam` and `MLSTeam` potential values.
    Therefore, the `Team` `enum` is a sum type.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: To have a `HockeyAndSoccerTeams` structure, we need to choose one value for
    `NHLTeam` and one for `MLSTeam` so it has 36 potential values that are the product
    of `NHLTeam` and `MLSTeam` values. Therefore, `HockeyAndSoccerTeams` is a product
    type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, an enumeration''s option can have multiple values. If it happens
    to be the only option, then this enumeration becomes a product type. The following
    example presents an `enum` as a product type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Recursion types are another class of algebraic data types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: A recursive data type is a data type for values that may contain other values
    of the same type. An important application of recursion in computer science is
    in defining dynamic data structures such as arrays. Recursive data structures
    can dynamically grow to a theoretically infinite size in response to runtime requirements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Operations used to do simple integer arithmetic can be modeled with `enums`.
    These operations let us combine simple arithmetic expressions. *The Swift Programming
    Language(3.0)* by *Apple Inc.* provides an example of simple integer arithmetic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of recursive data structures is a Tree that is implemented
    as a recursive data type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Tree` can be empty; it can have a leaf or another `Tree` as `node`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: As the data is nested, the enumeration used to store the data also needs to
    support nesting, which means that the enumeration needs to be recursive.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The compiler has to insert a layer of indirection when it works with recursive
    enumerations. We indicate that an enumeration case is recursive by writing `indirect`
    before it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents the search function on `Tree`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can create `sum`, `product`, or `recursion` types in Swift, we can say
    that Swift has first-class support for algebraic data types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages that support algebraic data types often support a set
    of features to work with fields of composite types or variants of a type. These
    features are essential in defining functions to operate on different fields or
    variants in a type-safe manner.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: One such feature is called **pattern matching** that enables us to define functions
    that operate differently on each of a type's variants and extract individual fields
    from a composite type while maintaining the language's type safety guarantees.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the compilers of many languages with pattern matching will issue warnings
    or errors if we do not handle all of a type's fields or variants properly. These
    warnings help us write safer and more robust code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents simple pattern matching with a switch statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the Swift compiler infers `theTeam` as `MLSTeam`; therefore,
    we do not need to write `MLSTeam` for each case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We use the switch case to match the pattern as it is a basic way of pattern
    matching for enumerations in Swift. This code block will print `Montreal Impact`
    as it matches the `.montreal` case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'To further explore pattern matching, we can look at the other example, the
    `Dimension` enumeration. Using pattern matching, it is easy to write a function,
    `convertDimension`, that will take `Dimension` as a parameter and convert it to
    the other variant (`US` measurements to `Metric` and vice versa):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索模式匹配，我们可以查看其他示例，即 `Dimension` 枚举。使用模式匹配，我们可以轻松编写一个函数 `convertDimension`，它将
    `Dimension` 作为参数并转换为其他变体（`US` 测量单位到 `Metric` 以及反之亦然）：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this function, we check for the dimension type with a `switch` `case` code
    block. We extract the associated values with our `let` statement and use `length`
    and `width` in our `return` statement.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用 `switch` `case` 代码块检查维度类型。我们使用 `let` 语句提取关联的值，并在 `return` 语句中使用
    `length` 和 `width`。
- en: To test our function, we provide a `metric` dimension of `5.0` and `4.0` so
    that the resulting `us length` will be `16.4` and the `us width` will be `13.12`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的函数，我们提供了一个 `metric` 维度为 `5.0` 和 `4.0`，这样最终的 `us length` 将是 `16.4`，而 `us
    width` 将是 `13.12`。
- en: 'Swift requires us to handle all of the cases of an enumerated type; if we do
    not cover all the cases, the Swift compiler will warn us and prevent us from introducing
    runtime errors. For instance, if we remove the second case, the compiler will
    warn us, as shown in the following image:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 要求我们处理枚举类型的所有情况；如果我们没有涵盖所有情况，Swift 编译器将发出警告并阻止我们引入运行时错误。例如，如果我们删除第二个情况，编译器将发出警告，如下面的图像所示：
- en: '![Pattern matching](img/B05092_04_01_new.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![模式匹配](img/B05092_04_01_new.jpg)'
- en: 'In case we have a lot of cases that we want to handle generically, we can use
    the default keyword. As an example, let''s add a default case to our `convertDimension`
    function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有很多想要通用处理的案例，我们可以使用默认关键字。例如，让我们给 `convertDimension` 函数添加一个默认情况：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding example serves only as a default usage example and we should avoid
    a `default` case as much as possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例仅作为默认使用示例，我们应该尽可能避免使用 `default` 情况。
- en: Patterns and pattern matching
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和模式匹配
- en: In the previous section, we looked at simple pattern matching examples for enumerations.
    In this section, we will examine patterns and pattern matching in detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们查看了对枚举的简单模式匹配示例。在本节中，我们将详细探讨模式和模式匹配。
- en: The wildcard pattern
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通配符模式
- en: The wildcard pattern matches and ignores any value. It consists of an underscore,
    `_`. We use a wildcard pattern when we do not care about the values being matched
    against.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式匹配并忽略任何值。它由一个下划线 `_` 组成。当我们不关心匹配的值时，我们使用通配符模式。
- en: 'For instance, the following code example ignores the matched values:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码示例忽略了匹配的值：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use `_` to ignore the value in the iteration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `_` 来忽略迭代中的值。
- en: 'The wildcard pattern can be used with `optionals` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式可以与 `optionals` 结合使用如下：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As seen from the preceding example, we matched an optional by `_?`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们通过 `_?` 匹配了可选值。
- en: 'The wildcard pattern can be used to ignore data that we do not need and values
    that we do not want to match against. The following code example presents the
    way in which we use the wildcard pattern to ignore the data:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符模式可以用来忽略我们不需要的数据以及我们不想匹配的值。以下代码示例展示了我们如何使用通配符模式来忽略数据：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The value-binding pattern
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值绑定模式
- en: 'A value-binding pattern binds matched values to variable or constant names.
    The following example presents the value binding pattern by binding `x` to `5`
    and `y` to `7`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 值绑定模式将匹配的值绑定到变量或常量名称。以下示例通过将 `x` 绑定到 `5` 和 `y` 绑定到 `7` 来展示值绑定模式：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The identifier pattern
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符模式
- en: 'An identifier pattern matches any value and binds the matched value to a variable
    or constant name. For instance, in the following example, `ourConstant` is an
    identifier pattern that matches the value of `7`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符模式匹配任何值并将匹配的值绑定到变量或常量名称。例如，在以下示例中，`ourConstant` 是一个标识符模式，它匹配 `7` 的值：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The identifier pattern is a subpattern of the value-binding pattern.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符模式是值绑定模式的子模式。
- en: The tuple pattern
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组模式
- en: A tuple pattern is a comma-separated list of zero or more patterns, enclosed
    in parentheses. Tuple patterns match values of corresponding tuple types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 元组模式是一个由逗号分隔的零个或多个模式的列表，用括号括起来。元组模式匹配相应元组类型的值。
- en: 'We can constrain a tuple pattern to match certain kinds of tuple types using
    type annotations. For instance, the tuple pattern `(x, y): (Double, Double)` in
    the declaration, `let (x, y): (Double, Double) = (3, 7)`, matches only tuple types
    in which both elements are of the `Double` type.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用类型注解来约束元组模式以匹配某些类型的元组。例如，在声明`let (x, y): (Double, Double) = (3, 7)`中，元组模式`(x,
    y): (Double, Double)`仅匹配两个元素都是`Double`类型的元组类型。'
- en: 'In the following example, we match the pattern by binding the name, checking
    whether age has a value, and finally, if the address is of the `String` type.
    We use only the `name` that we need and, for `age` and `address`, we use the wildcard
    pattern to ignore the values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过绑定名称、检查年龄是否有值，最后如果地址是`String`类型来匹配模式。我们只使用所需的`name`，对于`age`和`address`，我们使用通配符模式来忽略值：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The enumeration case pattern
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举案例模式
- en: An enumeration case pattern matches a `case` of an existing enumeration type.
    Enumeration case patterns appear in a `switch` statement's `case` labels and case
    conditions of `if`, `while`, `guard`, and `for-in` statements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举案例模式匹配现有枚举类型的`case`。枚举案例模式出现在`switch`语句的`case`标签和`if`、`while`、`guard`和`for-in`语句的`case`条件中。
- en: 'If the enumeration `case` that we are trying to match has any associated values,
    the corresponding enumeration case pattern must specify a tuple pattern that contains
    one element for each associated value. The following example presents the enumeration
    case pattern:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图匹配的枚举`case`有任何关联的值，相应的枚举案例模式必须指定一个包含每个关联值的元组模式。以下示例展示了枚举案例模式：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we use tuple pattern for each associated value (`length`
    and `width`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为每个关联值（`length`和`width`）使用元组模式。
- en: The optional pattern
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选模式
- en: 'An optional pattern matches values wrapped in a `Some(Wrapped)` case of an
    `Optional<Wrapped>` or `ImplicitlyUnwrappedOptional<Wrapped>` enumeration. Optional
    patterns consist of an identifier pattern followed immediately by a question mark
    and appear in the same places as enumeration case patterns. The following example
    presents optional pattern matching:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可选模式匹配`Optional<Wrapped>`或`ImplicitlyUnwrappedOptional<Wrapped>`枚举中`Some(Wrapped)`案例的值。可选模式由一个标识符模式后跟一个问号组成，出现在与枚举案例模式相同的位置。以下示例展示了可选模式匹配：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Type casting patterns
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换模式
- en: 'There are two type casting patterns as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型转换模式如下：
- en: '`is`: This matches the type against the right-hand side of the expression'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is`：这会将类型与表达式的右侧进行匹配'
- en: '`as`: This casts the type to the left-hand side of the expression'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as`：这会将类型转换为表达式的左侧'
- en: 'The following example presents the `is` and `as` type casting patterns:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了`is`和`as`类型转换模式：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `anyValue` variable is type of `Any` storing, an `Int` value, then the
    first case is going to be matched but the compiler will complain, as shown in
    the following image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`anyValue`变量是`Any`类型，存储一个`Int`值，那么第一个案例将被匹配，但编译器将报错，如下所示：'
- en: '![Type casting patterns](img/image_04_002.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![类型转换模式](img/image_04_002.jpg)'
- en: We could cast `anyValue` to `Int` with `as!` to resolve the issue.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`as!`将`anyValue`转换为`Int`类型以解决问题。
- en: 'The first case is already matched. The second case will not be reached. Suppose
    that we had a non-matching case as the first case, as shown in the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个案例已经匹配。第二个案例将不会达到。假设我们有一个不匹配的案例作为第一个案例，如下例所示：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this scenario, the second case would be matched and cast `anyValue` to `Int`
    and bind it to `ourValue`, then we will be able to use `ourValue` in our statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第二个案例将被匹配，将`anyValue`转换为`Int`并绑定到`ourValue`，然后我们就能在我们的语句中使用`ourValue`。
- en: The expression pattern
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式模式
- en: An expression pattern represents the value of an expression. Expression patterns
    appear only in a `switch` statement's `case` labels. The expression represented
    by the expression pattern is compared with the value of an input expression using
    the `~=` operator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式模式表示表达式的值。表达式模式仅出现在`switch`语句的`case`标签中。表达式模式所表示的表达式使用`~=`运算符与输入表达式的值进行比较。
- en: 'The matching succeeds if the `~=` operator returns `true`. By default, the
    `~=` operator compares two values of the same type using the `==` operator. The
    following example presents an example of the expression pattern:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`~=`运算符返回`true`，则匹配成功。默认情况下，`~=`运算符使用`==`运算符比较相同类型的两个值。以下示例展示了表达式模式的示例：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can overload the `~=` operator to provide custom expression matching behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重载`~=`运算符以提供自定义的表达式匹配行为。
- en: 'For instance, we can rewrite the preceding example to compare the position
    expression with a `String` representation of positions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以重写前面的示例，将位置表达式与位置的`String`表示形式进行比较：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explained the enumeration definition and usage. We covered associated
    and raw values and an introduction to the concept of algebraic data types. We
    explored some examples to cover the sum, product, and recursion types. We will
    use the concept of algebraic data types in Chapter 8 , *Functional Data Structures*
    when we talk about functional data structures. In this chapter, we explored patterns
    such as wildcard, value-binding, identifier, tuple, enumeration case, optional,
    type casting, and expression along with related pattern matching examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了枚举的定义和用法。我们涵盖了关联值和原始值，以及代数数据类型概念的介绍。我们探讨了几个示例，包括求和、乘积和递归类型。在第八章“函数式数据结构”中，当我们讨论函数式数据结构时，我们将使用代数数据类型的概念。在本章中，我们探讨了诸如通配符、值绑定、标识符、元组、枚举情况、可选、类型转换和表达式等模式，以及相关的模式匹配示例。
- en: The next chapter will cover generics and associated type protocols that are
    very useful tools in functional programming, generic programming, and protocol-oriented
    programming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖泛型和关联类型协议，这些是函数式编程、泛型编程和协议导向编程中非常有用的工具。
