- en: Chapter 4. Enumerations and Pattern Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Functional Programming
    in Swift") , *Getting Started with Functional Programming in Swift*, we were introduced
    to enumerations briefly. In this chapter, we will cover enumerations and algebraic
    data types in detail. Also, we will explore patterns and pattern matching in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associated values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algebraic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, an enumeration defines a common type for related values and enables
    us to work with those values in a type-safe way. Values provided for each enumeration
    member can be a `String`, `Character`, `Integer`, or any `floating-point` type.
    The following example presents a simple definition of an enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`MLSTeam` `enum` provides us options for MLS teams. We can choose only one
    of the options each time; in our example, `Montreal` is chosen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple cases can be defined, separated by a comma on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `theTeam` is inferred when it is initialized with `MLSTeam.montreal`.
    As `theTeam` is already defined, we can change it with a shorter syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We were able to change `theTeam` with a short syntax because `theTeam` was already
    inferred and was not a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Associated values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enumerations can store associated values of any given type, and the value types
    can be different for each member of the enumeration if required. Enumerations
    similar to these are known as discriminated unions, tagged unions, or variants
    in other programming languages. The following example presents a simple usage
    of associated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The enumeration type, `Length`, can either take a value of `US` with an associated
    value of the `Double` type or a value of `metric` with an associated value of
    the `Double` type.
  prefs: []
  type: TYPE_NORMAL
- en: The `lengthMetric` is a variable that gets assigned as a value of `Length.metric`
    with an associated value of `1.6`.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding example, associated values are set when we create a
    new constant or variable based on one of the enumeration's cases and can be different
    each time we do so.
  prefs: []
  type: TYPE_NORMAL
- en: Raw values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enumeration members can come prepopulated with default values (called **raw
    values**), which are all of the same type. The following example presents an incomplete
    `HttpError enum` with raw values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the raw values for `enum` called `HttpError` are defined
    to be of the `Int` type and are set to some of their integer code.
  prefs: []
  type: TYPE_NORMAL
- en: Raw values can be of `String`, `Character`, `Int`, or any floating number types.
    Each raw value must be unique within its enumeration declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Raw values are set to prepopulated values when we first define the enumeration
    such as `HttpError` in the preceding example; therefore, the raw value for an
    enumeration case is always the same and it is not going to change, unlike associated
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we define an enumeration with a raw-value type, the enumeration automatically
    receives an initializer that takes a value of the raw value''s type and returns
    either an enumeration `case` or `nil`. We can use this initializer to try to create
    a new instance of the enumeration. The following example presents the initialization
    of an `HttpError` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Algebraic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerations in Swift are actually algebraic data types that are types created
    by combining other types. Algebraic data types are essential to many functional
    programming languages such as Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: An algebraic data type is based on the idea of algebraic structures, which are
    a set of possible values and one or more operators to combine a finite number
    of these values into a single one. A well-known structure, for example, is (`ℤ`,
    `+`, `-`), a set of all integers with the plus and minus operations on them.
  prefs: []
  type: TYPE_NORMAL
- en: So an algebraic data type is a data type that is created by algebraic operations,
    specifically, with sum and product as our operations.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, algebraic data types are composite data types that may contain
    multiple values such as a data type with multiple fields, or they may consist
    of variants or multiple finite different values.
  prefs: []
  type: TYPE_NORMAL
- en: Simple types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Boolean` type is a simple algebraic data type as it may take one of two
    values: `true` or `false`. An instance of a `Boolean` type should be either `true`
    or `false`, but the instance cannot be both at once; it has to be one or the other
    unlike the `struct`/`class` properties and variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Composite types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Algebraic data types can also be composite types. For instance, a tuple of two
    `Double` values is a simple algebraic data type. Such a tuple could be expressed
    as having the `(Double, Double)` type, and an example value for this type could
    be `(1.5, 3.2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Composite type with variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Algebraic data types can be composite types with variants as well. We could
    create an `enum` named `Dimension` to hold the length and width. We can express
    this `enum` in both `us` feet and `metric` meters. In Swift, we can define such
    an `enum` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use the `Dimension` enumeration to create a variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The algebra of data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that enums in Swift are actually algebraic data types. Let's explore
    some examples to get more familiar with the topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a simple `enum` `NHLTeam` with different options.
    The `enum` `Team` uses `NHLTeam` along with `MLSTeam` that we have defined before
    to combine `Hockey` and `Soccer` teams. `Team` can be either a `Hockey NHL` team
    or a `Soccer MLS` team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`MLSTeam` and `NHLTeam` each have six potential values. If we combine them,
    we will have two new types. `Team` can be either `NHLTeam` or `MLSTeam`, so it
    has 12 potential values that is the sum of `NHLTeam` and `MLSTeam` potential values.
    Therefore, the `Team` `enum` is a sum type.'
  prefs: []
  type: TYPE_NORMAL
- en: To have a `HockeyAndSoccerTeams` structure, we need to choose one value for
    `NHLTeam` and one for `MLSTeam` so it has 36 potential values that are the product
    of `NHLTeam` and `MLSTeam` values. Therefore, `HockeyAndSoccerTeams` is a product
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, an enumeration''s option can have multiple values. If it happens
    to be the only option, then this enumeration becomes a product type. The following
    example presents an `enum` as a product type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Recursion types are another class of algebraic data types.
  prefs: []
  type: TYPE_NORMAL
- en: A recursive data type is a data type for values that may contain other values
    of the same type. An important application of recursion in computer science is
    in defining dynamic data structures such as arrays. Recursive data structures
    can dynamically grow to a theoretically infinite size in response to runtime requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Operations used to do simple integer arithmetic can be modeled with `enums`.
    These operations let us combine simple arithmetic expressions. *The Swift Programming
    Language(3.0)* by *Apple Inc.* provides an example of simple integer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of recursive data structures is a Tree that is implemented
    as a recursive data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Tree` can be empty; it can have a leaf or another `Tree` as `node`.'
  prefs: []
  type: TYPE_NORMAL
- en: As the data is nested, the enumeration used to store the data also needs to
    support nesting, which means that the enumeration needs to be recursive.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler has to insert a layer of indirection when it works with recursive
    enumerations. We indicate that an enumeration case is recursive by writing `indirect`
    before it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents the search function on `Tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can create `sum`, `product`, or `recursion` types in Swift, we can say
    that Swift has first-class support for algebraic data types.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages that support algebraic data types often support a set
    of features to work with fields of composite types or variants of a type. These
    features are essential in defining functions to operate on different fields or
    variants in a type-safe manner.
  prefs: []
  type: TYPE_NORMAL
- en: One such feature is called **pattern matching** that enables us to define functions
    that operate differently on each of a type's variants and extract individual fields
    from a composite type while maintaining the language's type safety guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the compilers of many languages with pattern matching will issue warnings
    or errors if we do not handle all of a type's fields or variants properly. These
    warnings help us write safer and more robust code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents simple pattern matching with a switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the Swift compiler infers `theTeam` as `MLSTeam`; therefore,
    we do not need to write `MLSTeam` for each case.
  prefs: []
  type: TYPE_NORMAL
- en: We use the switch case to match the pattern as it is a basic way of pattern
    matching for enumerations in Swift. This code block will print `Montreal Impact`
    as it matches the `.montreal` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further explore pattern matching, we can look at the other example, the
    `Dimension` enumeration. Using pattern matching, it is easy to write a function,
    `convertDimension`, that will take `Dimension` as a parameter and convert it to
    the other variant (`US` measurements to `Metric` and vice versa):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we check for the dimension type with a `switch` `case` code
    block. We extract the associated values with our `let` statement and use `length`
    and `width` in our `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: To test our function, we provide a `metric` dimension of `5.0` and `4.0` so
    that the resulting `us length` will be `16.4` and the `us width` will be `13.12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift requires us to handle all of the cases of an enumerated type; if we do
    not cover all the cases, the Swift compiler will warn us and prevent us from introducing
    runtime errors. For instance, if we remove the second case, the compiler will
    warn us, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pattern matching](img/B05092_04_01_new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In case we have a lot of cases that we want to handle generically, we can use
    the default keyword. As an example, let''s add a default case to our `convertDimension`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example serves only as a default usage example and we should avoid
    a `default` case as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at simple pattern matching examples for enumerations.
    In this section, we will examine patterns and pattern matching in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The wildcard pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The wildcard pattern matches and ignores any value. It consists of an underscore,
    `_`. We use a wildcard pattern when we do not care about the values being matched
    against.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following code example ignores the matched values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use `_` to ignore the value in the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wildcard pattern can be used with `optionals` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As seen from the preceding example, we matched an optional by `_?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wildcard pattern can be used to ignore data that we do not need and values
    that we do not want to match against. The following code example presents the
    way in which we use the wildcard pattern to ignore the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The value-binding pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A value-binding pattern binds matched values to variable or constant names.
    The following example presents the value binding pattern by binding `x` to `5`
    and `y` to `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The identifier pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An identifier pattern matches any value and binds the matched value to a variable
    or constant name. For instance, in the following example, `ourConstant` is an
    identifier pattern that matches the value of `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The identifier pattern is a subpattern of the value-binding pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The tuple pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple pattern is a comma-separated list of zero or more patterns, enclosed
    in parentheses. Tuple patterns match values of corresponding tuple types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can constrain a tuple pattern to match certain kinds of tuple types using
    type annotations. For instance, the tuple pattern `(x, y): (Double, Double)` in
    the declaration, `let (x, y): (Double, Double) = (3, 7)`, matches only tuple types
    in which both elements are of the `Double` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we match the pattern by binding the name, checking
    whether age has a value, and finally, if the address is of the `String` type.
    We use only the `name` that we need and, for `age` and `address`, we use the wildcard
    pattern to ignore the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The enumeration case pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An enumeration case pattern matches a `case` of an existing enumeration type.
    Enumeration case patterns appear in a `switch` statement's `case` labels and case
    conditions of `if`, `while`, `guard`, and `for-in` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the enumeration `case` that we are trying to match has any associated values,
    the corresponding enumeration case pattern must specify a tuple pattern that contains
    one element for each associated value. The following example presents the enumeration
    case pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use tuple pattern for each associated value (`length`
    and `width`).
  prefs: []
  type: TYPE_NORMAL
- en: The optional pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An optional pattern matches values wrapped in a `Some(Wrapped)` case of an
    `Optional<Wrapped>` or `ImplicitlyUnwrappedOptional<Wrapped>` enumeration. Optional
    patterns consist of an identifier pattern followed immediately by a question mark
    and appear in the same places as enumeration case patterns. The following example
    presents optional pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Type casting patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two type casting patterns as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is`: This matches the type against the right-hand side of the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as`: This casts the type to the left-hand side of the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example presents the `is` and `as` type casting patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `anyValue` variable is type of `Any` storing, an `Int` value, then the
    first case is going to be matched but the compiler will complain, as shown in
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type casting patterns](img/image_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could cast `anyValue` to `Int` with `as!` to resolve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first case is already matched. The second case will not be reached. Suppose
    that we had a non-matching case as the first case, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, the second case would be matched and cast `anyValue` to `Int`
    and bind it to `ourValue`, then we will be able to use `ourValue` in our statement.
  prefs: []
  type: TYPE_NORMAL
- en: The expression pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An expression pattern represents the value of an expression. Expression patterns
    appear only in a `switch` statement's `case` labels. The expression represented
    by the expression pattern is compared with the value of an input expression using
    the `~=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matching succeeds if the `~=` operator returns `true`. By default, the
    `~=` operator compares two values of the same type using the `==` operator. The
    following example presents an example of the expression pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can overload the `~=` operator to provide custom expression matching behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can rewrite the preceding example to compare the position
    expression with a `String` representation of positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the enumeration definition and usage. We covered associated
    and raw values and an introduction to the concept of algebraic data types. We
    explored some examples to cover the sum, product, and recursion types. We will
    use the concept of algebraic data types in Chapter 8 , *Functional Data Structures*
    when we talk about functional data structures. In this chapter, we explored patterns
    such as wildcard, value-binding, identifier, tuple, enumeration case, optional,
    type casting, and expression along with related pattern matching examples.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover generics and associated type protocols that are
    very useful tools in functional programming, generic programming, and protocol-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
