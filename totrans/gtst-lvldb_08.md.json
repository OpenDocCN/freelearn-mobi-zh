["```swift\n@interface GSwLDB06osxAppDelegate: NSObject\n  <NSApplicationDelegate, NSTableViewDataSource,\n   NSTableViewDelegate>\n- (IBAction)viewAllRecords:(id)sender;\n- (IBAction)viewNamesOnly:(id)sender;\n- (IBAction)viewPhonesOnly:(id)sender;\n- (IBAction)viewMatches:(id)sender;\n- (IBAction)newRecord:(id)sender;\n- (IBAction)saveRecord:(id)sender;\n- (IBAction)revertRecord:(id)sender;\n- (IBAction)deleteRecord:(id)sender;\n@property (weak) IBOutlet NSTextField *FirstNameEntry;\n...\n@property (weak) IBOutlet NSTextField *EmailEntry;\n@property (assign) IBOutlet NSWindow *window;\n@property (retain) IBOutlet NSTableView *tableView;\n@end\n```", "```swift\n- (IBAction)viewPhonesOnly:(id)sender {\n  [self.model loadPhones];\n  [self.tableView reloadData];\n  [self loadFieldsForCurrentSelectedRow];  // explicitly reload \n}\n```", "```swift\n- (void)loadAllRecords;\n- (void)loadNames;\n- (void)loadPhones;\n- (void)deleteMatching:(NSString*)key;\n- (NSArray*)fieldsForKey:(NSString*)key;\n- (BOOL)saveRecord:(NSArray*)fields\n    replacingKey:(NSString*)oldKey;\n```", "```swift\n@interface Sample06_Model() {}\n- (NSString*)mainKeyFrom:(NSString*)key;\n- (void)addRecord:(NSArray*)fields \n    indexingPhone:(BOOL)addPhoneKey\n    using:(id<APLevelDBWriteBatch>)batch;\n@property (retain) NSString* lastPrefixUsed;\n@property (nonatomic) BOOL neverLoaded;\n```", "```swift\n- (void)loadPhones {\n  self.rowsForUI = [self.db keysWithPrefix:@\"P~\"\n    strippingFirst:2];\n  self.lastPrefixUsed = @\"P~\";\n}\n\n- (void)loadStartingWith:(NSString*)partialKey {\n  NSString* prefixedKey = [self.lastPrefixUsed \n    stringByAppendingString:partialKey];\n  self.rowsForUI = [self.db keysWithPrefix:prefixedKey \n    strippingFirst: [self.lastPrefixUsed length]];\n}\n```", "```swift\n- (NSArray*)keysWithPrefix:(NSString*)prefix \n    strippingFirst:(int)numCharsToStrip\n{\n  NSMutableArray *keys = [NSMutableArray array];\n  if (numCharsToStrip > 0) {\n    [self enumerateKeysWithPrefix:prefix \n      block:^(NSString* key, BOOL* stop) {\n        [keys addObject:[key substringFromIndex:numCharsToStrip]];\n      }];\n  }\n  else {  // for speed use a different block that copies whole\n    [self enumerateKeysWithPrefix:prefix \n      block:^(NSString* key, BOOL* stop) {\n        [keys addObject:key];\n      }];\n  }\n  return keys;\n}\n```", "```swift\n- (void)loadListForUI {\n  if (self.neverLoaded) {\n    self.neverLoaded = NO;\n    [self loadNames];  // default UI is to give them names first\n  }\n  else if (self.lastPrefixUsed == @\"N~\") \n    [self loadNames];\n  else if (self.lastPrefixUsed == @\"P~\") \n    [self loadPhones];\n  else\n    [self loadAllRecords];\n}\n```", "```swift\n- (NSArray*)fieldsForRow:(NSInteger)index {\n  NSString* key = [self keyForRow:index];\n  return [self fieldsForKey:key];    \n}\n\n- (NSString*) keyForRow:(NSInteger)row {\n  if (self.rowsForUI == nil)\n    [self loadListForUI];\n  return (NSString*)(self.rowsForUI[row]);\n}\n\n- (NSArray*)fieldsForKey:(NSString*)key {\n  NSData* mainRec = [self.db dataForKey:[self mainKeyFrom:key]];\n  NSError* decodeErr;\n  NSArray* fields = [NSJSONSerialization \n    JSONObjectWithData:mainRec options:0 error:&decodeErr];\n  assert(decodeErr == nil);\n  return fields;\n}\n```", "```swift\n- (NSString*)mainKeyFrom:(NSString*)key {\n  if ([key hasPrefix:@\"N~\"])\n    return key;  // original is already prefixed\n  if ([self.lastPrefixUsed isEqualToString:@\"N~\"]) \n    return [@\"N~\" stringByAppendingString:key];\n  if ([self.lastPrefixUsed isEqualToString:@\"P &&\n    ![key hasPrefix:@\"P~\"])\n      key = [@\"P~\" stringByAppendingString:key];\n  // if get here need to translate a Phone key into a main one,\n  // read the main key indexed by phone number\n  return [self.db stringForKey:key];  // read fully prefixed key\n}\n```", "```swift\n- (IBAction)saveRecord:(id)sender {\n  NSArray* fields = [NSArray arrayWithObjects:\n    [self.FirstNameEntry stringValue],\n    ...\n    [self.EmailEntry stringValue],\n    nil\n  ];\n\n  if (self.isNewRecord) {\n    [self.model saveRecord:fields];\n    self.isNewRecord = NO;\n    [self.tableView reloadData];  // list shows new record\n  } else {\n    NSString* origKey = [self.model keyForRow:\n      [self.tableView selectedRow]];\n    if ( [self.model saveRecord:fields replacingKey:origKey] )\n      [self.tableView reloadData]; // list shows new Name/Phone\n  }\n}\n```", "```swift\n- (void)saveRecord:(NSArray*)fields {\n  id<APLevelDBWriteBatch> wb = [self.db beginWriteBatch];  \n  [self addRecord:fields indexingPhone:YES using:wb];\n  [self.db commitWriteBatch:wb];  \n  self.rowsForUI = nil; // force reload when UI refreshes\n  return YES;\n}\n- (void)addRecord:(NSArray*)fields indexingPhone:(BOOL)addPhoneKey \n    using:(id<APLevelDBWriteBatch>)batch\n{\n  NSString* nameKey = nameKeyFromFields(fields); \n  NSError* encErr;\n  NSData* enc = [NSJSONSerialization dataWithJSONObject:fields \n    options:0 error:&encErr];\n  assert(encErr == nil);\n  [batch setData:enc forKey:nameKey];  // main record\n  if (addPhoneKey && [fields[ePhone] length] > 0) {\n    NSString* phoneKey = phoneKeyFromFields(fields);\n    [batch setString:nameKey forKey:phoneKey];  \n  }\n}\n```", "```swift\n- (BOOL)saveRecord:(NSArray*)fields replacingKey:(NSString*)oldKey \n{\n  NSArray* oldRecord = [self fieldsForKey:oldKey];\n  const int numFields = [oldRecord count];\n  bool allSame = true;\n  for (int i=0; i<numFields && allSame; ++i) {\n    allSame = [fields[i] isEqualToString:oldRecord[i]];\n  }\n  if (allSame)\n    return NO;  // so caller knows no change\n\n  id<APLevelDBWriteBatch> wb = [self.db beginWriteBatch];      \n  NSString* keyToUpdate = [self mainKeyFrom:oldKey];\n  NSString* newKey = nameKeyFromFields(fields);\n  BOOL replacePhone = NO;\n  if ( ![newKey isEqualToString:keyToUpdate] ) {\n    [wb removeKey:keyToUpdate];\n    replacePhone = YES; // value (names) of phone record changed \n  }\n  NSString* phoneKey = phoneKeyFromFields(fields);\nNSString* oldPhoneKey = phoneKeyFromFields(oldRecord);\nif ( ![phoneKey isEqualToString:oldPhoneKey] ) {\n  replacePhone = YES;  // key changed\n  [wb removeKey:oldPhoneKey];\n}\n  [self addRecord:fields indexingPhone:replacePhone using:wb];\n  [self.db commitWriteBatch:wb];  \n  self.rowsForUI = nil;  // forced reload when UI refreshes\n  return YES;\n}\n```", "```swift\n- (IBAction)newRecord:(id)sender \n{\n  self.isNewRecord = YES;\n  if ([self.tableView numberOfSelectedRows] == 0)\n    [self clearEntryFields];\n  else  // selecting none will trigger clearEntryFields\n    [self.tableView deselectAll:sender]; \n}\n```", "```swift\n- (IBAction)deleteRecord:(id)sender  {\n  if ([self.tableView numberOfSelectedRows] == 0)\n    return;\n  int row = [self.tableView selectedRow];\n  NSString* originalKey = [self.model keyForRow:row];\n  [self.model deleteMatching:originalKey];\n  [self.tableView reloadData];\n  int lastRow = [self.model countRows] - 1;\n  if (row > lastRow)\n    row = lastRow;\n  // usually select the same row\n  [self.tableView selectRowIndexes:\n    [NSIndexSet indexSetWithIndex:row] \n    byExtendingSelection:NO];\n  [self loadFieldsForCurrentSelectedRow];\n}\n```", "```swift\n- (void)deleteMatching:(NSString*)key \n{\n  NSString* delKey = [self mainKeyFrom:key];\n  NSArray* delRecord = [self fieldsForKey: delKey];\n  NSString* delPhoneKey = phoneKeyFromFields(delRecord);\n  [self.db removeKey:delKey];\n  [self.db removeKey:delPhoneKey];\n  self.rowsForUI = nil;  // force reload when UI refreshes\n}\n```", "```swift\nUsing database with standard BytewiseComparator\nListing the keys in decimal and hex\n 256 ( 100)\n 512 ( 200)\n 768 ( 300)\n   1 (   1)\n 257 ( 101)\n ...\nUsing database with binaryComparator\nListing the keys in decimal and hex\n   1 (   1)\n   2 (   2)\n   3 (   3)\n…\n```", "```swift\n  for (int i=1; i<1000; i+=1) {\n    assert( [db addBinaryKey:&i length:sizeof(i)] );\n  }\n  printStr(@\"Listing the keys in decimal and hex\");\n  [db enumerateBinaryKeys:^(NSData *key, BOOL *stop) {\n    long n;\n    [key getBytes:&n length:sizeof(n)];\n    printStr( [NSString stringWithFormat:@\"%4ld (%4lx)\",n, n] );\n  }];\n```", "```swift\n  for (long i=1; i<1000; i+=1) {\n    long flippedI = htonl(i);\n    assert( [db addBinaryKey:&flippedI length:sizeof(flippedI)] );\n  }\n  printStr(@\"Listing the keys in decimal and hex\");\n  [db enumerateBinaryKeys:^(NSData *key, BOOL *stop) {\n    long n;\n    [key getBytes:&n length:sizeof(n)];\n    n = htonl(n);\n    printStr( [NSString stringWithFormat:@\"%4ld (%4lx)\",n, n] );\n  }];\n```", "```swift\n#ifdef __cplusplus\n  typedef leveldb::Comparator* leveldbComparatorPtr;\n#else\n  typedef void* leveldbComparatorPtr;\n#endif\n...\n@interface APLevelDB : NSObject\n...\n+ (APLevelDB *)levelDBWithPath:(NSString *)path \n    error:(NSError **)errorOut\n    comparator:(leveldbComparatorPtr)adoptedComparator;\n- (leveldbComparatorPtr) getComparator;\n```", "```swift\n@interface APLevelDB () {\n  ...\n leveldbComparatorPtr _comparator;\n}\n- (id)initWithPath:(NSString *)path error:(NSError **)errorOut\n     comparator:(leveldbComparatorPtr)adoptedComparator;\n  ...\n@end\n\n@implementation APLevelDB\n...\n+ (APLevelDB *)levelDBWithPath:(NSString *)path \n  error:(NSError **)errorOut {\n    return [[APLevelDB alloc] initWithPath:path \n      error:errorOut comparator:NULL];\n}\n\n+ (APLevelDB *)levelDBWithPath:(NSString *)path \n  error:(NSError **)errorOut \n  comparator:(leveldbComparatorPtr)adoptedComparator {\n    return [[APLevelDB alloc] initWithPath:path \n      error:errorOut comparator:adoptedComparator];\n}\n\n- (id)initWithPath:(NSString *)path error:(NSError **)errorOut\n  comparator:(leveldbComparatorPtr)adoptedComparator \n{\n  if ((self = [super init])) {\n    _path = path;\n    _comparator = adoptedComparator;  // maybe NULL    \n    leveldb::Options options = [[self class]defaultCreateOptions];\n    if (adoptedComparator != NULL)\n options.comparator = adoptedComparator;\n    leveldb::Status status = leveldb::DB::Open(options, \n      [_path UTF8String], &_db);\n...\n```", "```swift\n  virtual int Compare(const Slice& a, const Slice& b) const {\n    const char* adata = a.data();\n    const char* bdata = b.data();\n    if (adata[0] != bdata[0]) { // check first character\n      if (adata[0] < bdata[0])\n        return -1;\n      return 1;\n    } // 1st char the same, is it a N~ or P~ key?   \n    if (adata[1] != '~' || bdata[1] != '~')  // not special key\n      return BytewiseComparator()->Compare(a, b); // USE DEFAULT\n    if (adata[0] == 'P') // only check digits, skipping any others\n      return ComparePhones(adata+2, bdata+2, \n               a.size()-2, b.size()-2); \n    return CompareCaseInsensitive(adata+2, bdata+2, \n               a.size()-2, b.size()-2);\n  }  \n```", "```swift\n - (void)enumerateKeysWithPrefix:(NSString*)prefix \n         block:(void (^)(NSString* key, BOOL* stop))block\n{\n  BOOL stop = NO;\n  leveldb::Slice prefixSlice = SliceFromString(prefix);\n  std::unique_ptr<leveldb::Iterator> iter( \n    [self getDB]->NewIterator(leveldb::ReadOptions()) );\n  leveldbComparatorPtr customComp = [self getComparator];\n  if (customComp == nullptr) {  // safe to use starts_with\n    for (iter->Seek(prefixSlice); iter->Valid() && \n      iter->key().starts_with(prefixSlice); iter->Next()) {\n      NSString *k = StringFromSlice( iter->key() );\n      block(k, &stop);\n      if (stop)\n        break;\n    }\n  } else {\n    // custom comparator so have to use it to check the prefix\n    const size_t prefixLen = prefixSlice.size();\n    for (iter->Seek(prefixSlice); iter->Valid(); iter->Next()) {\n      leveldb::Slice key(iter->key());\n      leveldb::Slice partKey( key.data(), \n        std::min(key.size(), prefixLen));\n      if (customComp->Compare(partKey, prefixSlice) != 0)\n        break;\n      NSString *k = StringFromSlice( iter->key() );\n      block(k, &stop);\n      if (stop)\n        break;\n    }   \n  }\n}\n```"]