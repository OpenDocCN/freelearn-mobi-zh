["```swift\nprotocol Semigroup {\n    func operation(_ element: Self) -> Self\n}\n\n```", "```swift\nextension Int: Semigroup {\n    func operation(_ element: Int) -> Int {\n        return self + element\n    }\n}\n\n```", "```swift\nlet number: Int = 5\nnumber.operation(3)\n\n```", "```swift\nlet numberA: Int = 3\nlet numberB: Int = 5\nlet numberC: Int = 7\n\nif numberA.operation(numberB.operation(numberC)) == (numberA.operation(\n  numberB)).operation(numberC) {\n    print(\"Operation is associative\")\n}\n\n```", "```swift\ninfix operator <> { associativity left precedence 150 }\n\nfunc <> <S: Semigroup> (x: S, y: S) -> S {\n    return x.operation(y)\n}\n\n```", "```swift\nif numberA <> (numberB <> numberC) == (numberA <> numberB) <> numberC {\n    print(\"Operation is associative\")\n}\n\n```", "```swift\nextension Array: Semigroup {\n    func operation(_ element: Array) -> Array {\n        return self + element\n    }\n}\n\n```", "```swift\nprint([1, 2, 3, 4] <> [5, 6, 7]) // prints \"[1, 2, 3, 4, 5, 6, 7]\"\n\n```", "```swift\nextension String: Semigroup {\n    func operation(_ element: String) -> String {\n        return \"\\(self)\\(element)\"\n    }\n}\n```", "```swift\nfunc sconcat <S: Semigroup> (initial: S, elements: [S]) -> S {\n    return elements.reduce(initial, combine: <>)\n}\n\n```", "```swift\nprint(sconcat(initial: 0, elements:[1, 2, 3])) // 6\nprint(sconcat(initial: \"\", elements: [\"A\", \"B\", \"C\"])) // ABC\nprint(sconcat(initial: [], elements: [[1, 2], [3, 4, 5]])) // [1, 2, 3,\n  4, 5]\n\n```", "```swift\ninfix operator <> { associativity left precedence 150 }\n\nfunc <> <S: Semigroup> (x: S, y: S) -> S {\n    return x.operation(y)\n}\n\nprotocol Semigroup {\n    func operation(_ element: Self) -> Self\n}\n\nextension Int: Semigroup {\n    func operation(_ element: Int) -> Int {\n        return self + element\n    }\n}\n\nextension String : Semigroup {\n    func operation(_ element: String) -> String {\n        return self + element\n    }\n}\n\nextension Array : Semigroup {\n    func operation(_ element: Array) -> Array {\n        return self + element\n    }\n}\n\nfunc sconcat <S: Semigroup> (initial: S, elements: [S]) -> S {\n    return elements.reduce(initial, combine: <>)\n}\n\n```", "```swift\nprotocol Monoid: Semigroup {\n    static func identity() -> Self\n}\n\nextension Int: Monoid {\n    static func identity() -> Int {\n        return 0\n    }\n}\n\nextension String: Monoid {\n    static func identity() -> String {\n        return \"\"\n    }\n}\n\nextension Array: Monoid {\n    static func identity() -> Array {\n        return []\n    }\n}\n\n```", "```swift\nnumberA <> Int.identity() // 3\n\"A\" <> String.identity() // A\n\n```", "```swift\nfunc mconcat <M: Monoid> (_ elements: [M]) -> M {\n    return elements.reduce(M.identity(), combine: <>)\n}\n\n```", "```swift\nprint(mconcat([1, 2, 3])) // 6\nprint(mconcat([\"A\", \"B\", \"C\"])) // ABC\nprint(mconcat([[1, 2], [3, 4, 5]])) // [1, 2, 3, 4, 5]\n\n```", "```swift\nenum Tree<Element: Comparable> {\n    case leaf(Element)\n    indirect case node(lhs: Tree, rhs: Tree)\n}\n\n```", "```swift\nlet functionalTree = Tree.node(lhs: Tree.leaf(\"First\"),\n                               rhs: Tree.node(lhs:\n Tree.leaf(\"Second\"), \n                               rhs: Tree.leaf(\"Third\")))\n```", "```swift\nlet secondFT = Tree.node(lhs: functionalTree, rhs: Tree.node(\n                         lhs: Tree.leaf(\"Fourth\"),\n                         rhs: Tree.leaf(\"Fifth\")))\nlet thirdFT = Tree.node(lhs: Tree.node(lhs: Tree.leaf(\"Fourth\"),\n                        rhs: Tree.leaf(\"Fifth\")),\n                        rhs: functionalTree)\n```", "```swift\nstatic func contains(_ key: Element, tree: Tree<Element>) -> Bool {\n    switch tree {\n    case .leaf(let element):\n        return key == element\n    case node(let lhs, let rhs):\n        return contains(key, tree:lhs) || contains(key, tree:rhs)\n    }\n }\n\n```", "```swift\nlet isFound = Tree.contains(\"First\", tree: functionalTree) // will\n  return true\n```", "```swift\nenum BinarySearchTree<Element: Comparable> {\n    case leaf\n    indirect case node(lhs: BinarySearchTree, element: Element,\n                       rhs: BinarySearchTree)\n}\n\n```", "```swift\nlet functionalBST = BinarySearchTree.node(lhs: BinarySearchTree.node(\n  lhs: BinarySearchTree.leaf, element: 1,\n  rhs: BinarySearchTree.leaf),\n  element: 5, rhs: BinarySearchTree.node(lhs:BinarySearchTree.leaf,\n  element: 9, rhs: BinarySearchTree.leaf))\n```", "```swift\nstatic func contains(_ item: Element, tree: BinarySearchTree<Element>)\n  -> Bool {\n    switch tree {\n    case .leaf:\n        return false\n    case .node(let lhs, let element, let rhs):\n        if item < element {\n            return contains(item, tree: lhs)\n        } else if item > element {\n            return contains(item, tree: rhs)\n        }\n        return true\n    }\n}\n\n```", "```swift\nlet isFound = BinarySearchTree.contains(9, tree: functionalBST)\n\n```", "```swift\nvar size: Int {\n    switch self {\n    case .leaf:\n        return 0\n    case .node(let lhs, _, let rhs):\n        return 1 + lhs.size + rhs.size\n    }\n}\n\n```", "```swift\nprint(functionalBST.size) // prints \"3\"\n\n```", "```swift\nvar elements: [Element] {\n    switch self {\n    case .leaf:\n        return []\n    case .node(let lhs, let element, let rhs):\n        return lhs.elements + [element] + rhs.elements\n    }\n}\n\n```", "```swift\nstatic func empty() -> BinarySearchTree {\n    return .leaf\n}\n\n```", "```swift\nvar isEmpty: Bool {\n    switch self {\n    case .leaf:\n        return true\n    case .node(_, _, _):\n        return false\n    }\n}\n\n```", "```swift\nlet emptyBST = BinarySearchTree<Int>.empty()\nprint(emptyBST.isEmpty)\n\n```", "```swift\nenum BinarySearchTree<Element: Comparable> {\n    case leaf\n    indirect case node(lhs: BinarySearchTree, element: Element,\n                       rhs: BinarySearchTree)\n\n    var size: Int {\n        switch self {\n        case .leaf:\n            return 0\n        case .node(let lhs, _, let rhs):\n            return 1 + lhs.size + rhs.size\n        }\n    }\n\n    var elements: [Element] {\n        switch self {\n        case .leaf:\n            return []\n        case .node(let lhs, let element, let rhs):\n            return lhs.elements + [element] + rhs.elements\n        }\n    }\n\n    var isEmpty: Bool {\n        switch self {\n        case .leaf:\n            return true\n        case .node(_, _, _):\n            return false\n        }\n    }\n\n    init() {\n        self = .leaf\n    }\n\n    static func empty() -> BinarySearchTree {\n        return .leaf\n    }\n\n    init(element: Element) {\n        self = .node(lhs: .leaf, element: element, rhs: .leaf)\n    }\n\n    static func contains(_ item: Element,\n                           tree: BinarySearchTree<Element>)\n      -> Bool {\n        switch tree {\n        case .leaf:\n            return false\n        case .node(let lhs, let element, let rhs):\n            if item < element {\n                return contains(item, tree: lhs)\n            } else if item > element {\n                return contains(item, tree: rhs)\n            }\n            return true\n        }\n    }\n}\n\n```", "```swift\nenum LinkedList<Element: Equatable> {\n    case end\n    indirect case node(data: Element, next: LinkedList<Element>)\n}\n\n```", "```swift\nstatic func empty() -> LinkedList {\n    return .end\n}\n\n```", "```swift\nfunc cons(_ element: Element) -> LinkedList {\n    return .node(data: element, next: self)\n}\n\n```", "```swift\nlet functionalLinkedList = LinkedList<Int>.end.cons(1).cons(2).cons(3)\nprint(functionalLinkedList)\n\n```", "```swift\nnode(3, LinkedList<Swift.Int>.node(2, LinkedList<Swift.Int>.node(\n  1, LinkedList<Swift.Int>.end)))\n```", "```swift\ninfix operator <| { associativity right precedence 100 }\n\nfunc <| <T>(lhs: T, rhs: LinkedList<T>) -> LinkedList<T> {\n    return .node(data: lhs, next: rhs)\n}\n\n```", "```swift\nlet functionalLLWithCons = 3 <| 2 <| 1 <| .end\n\n```", "```swift\nlet secondLL = functionalLinkedList.cons(4)\nlet thirdLL = functionalLinkedList.cons(5)\nlet fourthLL = LinkedList<Int>.node(data: 1, next: secondLL)\n\n```", "```swift\nstatic func contains(_ key: Element, list: LinkedList<Element>) -> Bool {\n    switch list {\n    case .end:\n        return false\n    case .node(let data, let next):\n        if key == data {\n            return true\n        } else {\n            return contains(key, list: next)\n        }\n    }\n}\n\n```", "```swift\nprint(LinkedList.contains(1, list: functionalLinkedList))\n\n```", "```swift\nvar size: Int {\n    switch self {\n    case .node(_, let next):\n        return 1 + next.size\n    case .end:\n        return 0\n    }\n}\n\n```", "```swift\nprint(functionalLinkedList.size)\n\n```", "```swift\nvar elements: [Element] {\n    switch self {\n    case .node(let data, let next):\n        return [data] + next.elements\n    case .end:\n        return []\n    }\n}\n\n```", "```swift\nprint(functionalLinkedList.elements)\n\n```", "```swift\nvar isEmpty: Bool {\n    switch self {\n    case .node(_ , _):\n        return false\n    case .end:\n        return true\n    }\n}\n\n```", "```swift\nlet emptyLL = LinkedList<Int>.end\nprint(emptyLL.isEmpty)\n\nprint(functionalLinkedList.isEmpty)\n\n```", "```swift\nfunc map<T>(_ transform: (Element) -> T) -> LinkedList<T> {\n    switch self {\n    case .end:\n        return .end\n    case .node(let data, let next):\n        return transform(data) <| next.map(transform)\n    }\n}\n\n```", "```swift\nlet mappedFunctionalLL = functionalLinkedList.map { $0 * 2 }\n\n```", "```swift\nnode(6, LinkedList<Swift.Int>.node(4, LinkedList<Swift.Int>.node(\n  2, LinkedList<Swift.Int>.end)))\n```", "```swift\nfunc filter(_ predicate: ((Element) -> Bool)) -> LinkedList<Element> {\n    switch self {\n    case .end:\n        return .end\n    case .node(let data, let next):\n        return predicate(data) ? data <| next.filter(predicate) :\n          next.filter(predicate)\n    }\n}\n\n```", "```swift\nlet filteredFunctionalLL = functionalLinkedList.filter { $0 % 2 == 0 }\n\n```", "```swift\nnode(2, LinkedList<Swift.Int>.end)\n\n```", "```swift\nfunc reduce<Value>(_ initial: Value, combine: (Value, Element) -> Value)\n  -> Value {\n    switch self {\n    case .end:\n        return initial\n    case .node(let data, let next):\n        return next.reduce(combine(initial, data), combine: combine)\n    }\n}\n\n```", "```swift\nlet reducedFunctionalLL = functionalLinkedList.reduce(0) { $0 + $1}\n\n```", "```swift\n/// Operator\ninfix operator <| { associativity right precedence 100 }\n\nfunc <| <T>(lhs: T, rhs: LinkedList<T>) -> LinkedList<T> {\n    return .node(data: lhs, next: rhs)\n}\n\n/// LinkedList\n\nenum LinkedList<Element: Equatable> {\n    case end\n    indirect case node(data: Element, next: LinkedList<Element>)\n\n    var size: Int {\n        switch self {\n        case .node(_, let next):\n            return 1 + next.size\n        case .end:\n            return 0\n        }\n    }\n\n    var elements: [Element] {\n        switch self {\n        case .node(let data, let next):\n            return [data] + next.elements\n        case .end:\n            return []\n        }\n    }\n\n    var isEmpty: Bool {\n        switch self {\n        case .node(_ , _):\n            return false\n        case .end:\n            return true\n        }\n    }\n\n    static func empty() -> LinkedList {\n        return .end\n    }\n\n    func cons(_ element: Element) -> LinkedList {\n        return .node(data: element, next: self)\n    }\n\n    func map<T>(_ transform: (Element) -> T) -> LinkedList<T> {\n        switch self {\n        case .end:\n            return .end\n        case .node(let data, let next):\n            return transform(data) <| next.map(transform)\n        }\n    }\n\n    func filter(_ predicate: ((Element) -> Bool)) -> LinkedList<Element> {\n        switch self {\n        case .end:\n            return .end\n        case .node(let data, let next):\n            return predicate(data) ? data <| next.filter(predicate)\n              : next.filter(predicate)\n        }\n    }\n\n    func reduce<Value>(_ initial: Value, combine: (Value, Element)\n      -> Value) -> Value {\n        switch self {\n        case .end:\n            return initial\n        case .node(let data, let next):\n            return next.reduce(combine(initial, data), combine: combine)\n        }\n    }\n\n    static func contains(_ key: Element, list: LinkedList<Element>)\n      -> Bool {\n        switch list {\n        case .end:\n            return false\n        case .node(let data, let next):\n            if key == data {\n                return true\n            } else {\n                return contains(key, list: next)\n            }\n        }\n    }\n}\n\n```", "```swift\nfunc pop() -> (element: Element, linkedList: LinkedList)? {\n    switch self {\n    case .node(let data, let next):\n        return (data, next)\n    case .end:\n        return nil\n    }\n}\n\n```", "```swift\nif let (element, linkedList) = functionalLinkedList.pop() {\n    print(element)\n    let newLinkedList = linkedList.pop()\n    print(newLinkedList)\n}\n\n```", "```swift\nOptional((2, LinkedList<Swift.Int>.node(1, LinkedList<Swift.Int>.end)))\n\n```", "```swift\nenum LazyList<Element: Equatable> {\n    case end\n    case node(data: Element, next: () -> LazyList<Element>)\n}\n\n```", "```swift\nvar size: Int {\n    switch self {\n    case .node(_, let next):\n        return 1 + next().size\n    case .end:\n        return 0\n    }\n}\n\n```", "```swift\ninfix operator <|| { associativity right precedence 100 }\n\nfunc <|| <T>(lhs: T, rhs: () -> LazyList<T>) -> LazyList<T> {\n    return .node(data: lhs, next: rhs)\n}\n\n```", "```swift\nfunc map<T>(_ transform: (Element) -> T) -> LazyList<T> {\n    switch self {\n    case .end:\n        return .end\n    case .node(let data, let next):\n        return transform(data) <|| next().map(transform)\n    }\n}\n\n```", "```swift\nfunc <|| <T>(lhs: T, rhs: @autoclosure(escaping) () -> LazyList<T>)\n  -> LazyList<T> {\n    return .node(data: lhs, next: rhs)\n}\n\n```", "```swift\nfunc cons(_ element: Element) -> LazyList {\n    return .node(data: element, next: { self })\n}\n\n```", "```swift\nlet ourLazyList = 3 <|| 2 <|| 1 <|| LazyList.end // node(3, (Function))\nprint(ourLazyList.size) // prints 3\n\n```", "```swift\n/// Operator\ninfix operator <|| { associativity right precedence 100 }\n\nfunc <|| <T>(lhs: T, rhs: @autoclosure(escaping) () -> LazyList<T>)\n  -> LazyList<T> {\n    return .node(data: lhs, next: rhs)\n}\n\n/// Lazy List\nenum LazyList<Element: Equatable> {\n    case end\n    case node(data: Element, next: () -> LazyList<Element>)\n\n    var size: Int {\n        switch self {\n        case .node(_, let next):\n            return 1 + next().size\n        case .end:\n            return 0\n        }\n    }\n\n    var elements: [Element] {\n        switch self {\n        case .node(let data, let next):\n            return [data] + next().elements\n        case .end:\n            return []\n        }\n    }\n\n    var isEmpty: Bool {\n        switch self {\n        case .node(_ , _):\n            return false\n        case .end:\n            return true\n        }\n    }\n\n    static func empty() -> LazyList {\n        return .end\n    }\n\n    func cons(_ element: Element) -> LazyList {\n        return .node(data: element, next: { self })\n    }\n\n    func removeLast() -> (element: Element, linkedList: LazyList)? {\n        switch self {\n        case .node(let data, let next):\n            return (data, next())\n        case .end:\n            return nil\n        }\n    }\n\n    func map<T>(_ transform: (Element) -> T) -> LazyList<T> {\n        switch self {\n        case .end:\n            return .end\n        case .node(let data, let next):\n            return transform(data) <|| next().map(transform)\n        }\n    }\n\n    func filter(_ predicate: ((Element) -> Bool)) -> LazyList<Element> {\n        switch self {\n        case .end:\n            return .end\n        case .node(let data, let next):\n            return predicate(data) ? data <|| next().filter(predicate)\n              : next().filter(predicate)\n        }\n    }\n\n    func reduce<Value>(_ initial: Value, combine: (Value, Element)\n      -> Value) -> Value {\n        switch self {\n        case .end:\n            return initial\n        case .node(let data, let next):\n            return next().reduce(combine(initial, data), combine: combine)\n        }\n    }\n\n    static func contains(_ key: Element, list: LazyList<Element>) -> Bool {\n        switch list {\n        case .end:\n            return false\n        case .node(let data, let next):\n            if key == data {\n                return true\n            } else {\n                return contains(key, list: next())\n            }\n        }\n    }\n}\n\n```"]