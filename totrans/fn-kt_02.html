<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Functional Programming</h1>
                </header>
            
            <article>
                
<p class="mce-root">Functional programming has been making big waves in the software industry for the last five years, and everyone wants to jump on the bandwagon. Functional programming is a lot older, starting in the 1950s with <strong>Lisp</strong> being considered the first programming language (or at least, the first one to introduce functional features) which still exists as <strong>Common Lisp,</strong> and other dialects such as <strong>Scheme</strong> and <strong>Clojure</strong>.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>What is functional programming?</li>
<li>Basic concepts</li>
<li>Functional collections</li>
<li>Implementing a functional list</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is functional programming?</h1>
                </header>
            
            <article>
                
<p><strong>Functional programming</strong> is a paradigm (a style of structuring your programs). In essence, the focus is on transforming data with expressions (ideally such expressions should not have side effects). Its name, functional, is based on the concept of a mathematical function (not in sub-routines, methods, or procedures). A mathematical function defines a relation between a set of inputs and outputs. Each input has just one output. For example, given a function, <em>f(x) = X<sup>2</sup>; f(5)</em> is always <em>25</em>.</p>
<p>The way to guarantee, in a programming language, that calling a function with a parameter always returns the same value, is to avoid accessing to mutable state:</p>
<pre><span>fun </span><span>f</span>(<span>x</span>: Long) : Long { <br/>   <span>return </span><span>x </span>* <span>x // no access to external state<br/></span>}</pre>
<p>The <kbd>f</kbd> function doesn't access any external state; therefore, calling <em>f(5)</em> will always return <em>25</em>:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>var </span>i <span>= </span><span>0<br/></span><span><br/></span><span>    </span><span>fun </span><span>g</span><span>(</span>x: <span>Long</span><span>)</span>: <span>Long </span><span>{<br/></span><span>       </span><span>return </span>x <span>* </span><span>i </span><span>// accessing mutable state<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>println</span><span>(</span><span>g</span><span>(</span><span>1</span><span>)) </span><span>//0<br/></span><span>    </span><span>i</span><span>++<br/></span><span>    </span><span>println</span><span>(</span><span>g</span><span>(</span><span>1</span><span>)) </span><span>//1<br/></span><span>    </span><span>i</span><span>++<br/></span><span>    </span><span>println</span><span>(</span><span>g</span><span>(</span><span>1</span><span>)) </span><span>//2<br/></span><span>}</span></pre>
<p>The <kbd>g</kbd> function, on the other hand, depends on mutable state and returns different values for the same.</p>
<p>Now, in a real-life program (a <strong>Content Management System</strong> (<strong>CMS</strong>), shopping cart, or chat), state changes. So, in a functional programming style, state management must be explicit and careful. The techniques to manage state change in functional programming will be covered later. </p>
<p>A functional programming style will provide us with the following benefits:</p>
<ul>
<li><strong>Code is easy to read and test</strong>: Functions that don't depend on external mutable state are more accessible to reason about and to prove<strong><br/></strong></li>
<li><strong>State and side effects are carefully planned</strong>: Limiting state management to individual and specific places in our code makes it easy to maintain and refactor</li>
<li><strong>Concurrency gets safer and more natural</strong>: No mutable state means that concurrency code needs less or no locks around your code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basics concepts</h1>
                </header>
            
            <article>
                
<p>Functional programming is composed of a few well-defined concepts. A short introduction of these concepts will follow and, later on, each concept will be covered in depth, in the next chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First-class and higher-order functions</h1>
                </header>
            
            <article>
                
<p>The most foundational concept of functional programming is <strong>first-class functions</strong>. A programming language with support for first-class functions will treat functions as any other type; such languages will allow you to use functions as variables, parameters, returns, generalization types, and so on. Speaking of parameters and returns, a function that uses or returns other functions is a <strong>higher-order function</strong>.</p>
<p>Kotlin has support for both concepts.</p>
<p>Let's try a simple function (in Kotlin's documentation this kind of function is named lambda):</p>
<pre><span>val </span><span>capitalize </span>= <span>{ </span><span>str</span>: String <span>-&gt; </span><span>str</span>.<span>capitalize</span>() <span>}<br/></span><span><br/></span><span>fun </span><span>main</span>(<span>args</span>: Array&lt;String&gt;) {<br/>   <span>println</span>(<span>capitalize</span>(<span>"hello world!"</span>))<br/>}</pre>
<p>The <kbd>capitalize</kbd> lambda function is of type <kbd>(String) -&gt; String</kbd>; in other words, <kbd>capitalize</kbd> will take <kbd>String</kbd> and return another <kbd>String</kbd>—in this case, a capitalized <kbd>String</kbd>.</p>
<p>As a lambda function, <kbd>capitalize</kbd> can be executed using parentheses with parameters (or no parameters at all, depending on the situation).</p>
<p>But what does the <kbd>(String) -&gt; String</kbd> type mean?</p>
<p><kbd>(String) -&gt; String</kbd> is a shortcut (some could call it syntactic sugar) for <kbd>Function1&lt;String, String&gt;</kbd>, <kbd>Function1&lt;P1, R&gt;</kbd> is an interface defined in the Kotlin standard library. <kbd>Function1&lt;P1, R&gt;</kbd> has a single method, <kbd>invoke(P1): R</kbd>, that is marked as an operator (we'll cover operators later).</p>
<p>Kotlin's compiler can translate the shortcut syntax into a fully fledged function object at compile time (indeed, the compiler will apply many more optimizations) as follows:</p>
<pre><span>val </span>capitalize = <span>{ </span><span>str</span>: String <span>-&gt; </span><span>str</span>.<span>capitalize</span>() }</pre>
<p>It is equivalent to the following code:</p>
<pre><span>val </span><span>capitalize </span>= <span>object </span>: <span>Function1</span>&lt;String<span>, </span>String&gt; {<br/>   <span>override fun </span><span>invoke</span>(<span>p1</span>: String): String {<br/>      <span>return </span><span>p1</span>.<span>capitalize</span>()<br/>   }<br/>}</pre>
<p>As you can see, the <kbd>capitalize</kbd> value's body is located inside the <kbd>invoke</kbd> method.</p>
<p>In Kotlin, lambda functions can be used as parameters in other functions as well.</p>
<p>Let's take a look at the following example:</p>
<pre><span>fun </span><span>transform</span>(<span>str</span>:String<span>, </span><span>fn</span>: (String) -&gt; String): String {<br/>   <span>return </span><span>fn</span>(<span>str</span>)<br/>}</pre>
<p>The <kbd>transform(String, (String) -&gt; String)</kbd> function takes one <kbd>String</kbd> and applies a lambda function to it.</p>
<p>For all intents and purposes, we can generalize <kbd>transform</kbd>:</p>
<pre><span>fun </span>&lt;<span>T</span>&gt; <span>transform</span>(<span>t</span>: <span>T</span><span>, </span><span>fn</span>: (<span>T</span>) -&gt; <span>T</span>): <span>T </span>{<br/>   <span>return </span><span>fn</span>(<span>t</span>)<br/>}</pre>
<p>Using <kbd>transform</kbd> is very simple. Take a look at the following code snippet:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>, </span><span>capitalize</span><span>))<br/></span><span>}</span></pre>
<p>We can pass <kbd>capitalize</kbd> as a parameter directly, great stuff.</p>
<p>There are more ways to call the <kbd>transform</kbd> function. Let's try some more:  </p>
<pre><span>fun </span><span>reverse</span>(<span>str</span>: String): String {<br/>   <span>return </span><span>str</span>.<span>reversed</span>()<br/>}<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>, </span>::reverse<span>))<br/></span><span>}</span></pre>
<p><kbd>reverse</kbd> is a function; we can pass a reference to it using a double colon (<kbd>::</kbd>) as follows:</p>
<pre><span>object </span><span>MyUtils </span>{<br/>   <span>fun </span><span>doNothing</span>(<span>str</span>: String): String {<br/>      <span>return </span><span>str<br/></span><span>   </span>}<br/>}<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>, </span><span>MyUtils</span>::doNothing<span>))<br/></span><span>}</span></pre>
<p><kbd>doNothing</kbd> is an object method, and in this case, we use <kbd>::</kbd> after the <kbd>MyUtils</kbd> object name:</p>
<pre><span>class </span>Transformer {<br/>   <span>fun </span><span>upperCased</span>(<span>str</span>: String): String {<br/>      <span>return </span><span>str</span>.<span>toUpperCase</span>()<br/>   }<br/><br/>   <span>companion object </span>{<br/>      <span>fun </span><span>lowerCased</span>(<span>str</span>: String): String {<br/>         <span>return </span><span>str</span>.<span>toLowerCase</span>()<br/>      }<br/>   }<br/>}<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>transformer <span>= </span><span>Transformer</span><span>()<br/></span><span><br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>, </span>transformer::upperCased<span>))<br/></span><span>    <br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>, </span><span>Transformer</span><span>.</span><span>Companion</span>::lowerCased<span>))<br/></span><span>}</span></pre>
<p>We can also pass references to instances or companion object methods. But probably the most common case is to pass a lambda directly:</p>
<pre><span>fun </span>main<span>(</span>args: Array<span>&lt;</span>String<span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>, </span><span>{ </span>str <span>-&gt; </span>str<span>.</span><span>substring</span><span>(</span><span>0</span><span>..</span><span>1</span><span>) </span><span>}</span><span>))<br/></span><span>}</span></pre>
<p>There is a shorter version of this using the <kbd>it</kbd> <span>implicit parameter as follows:</span></p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>, </span><span>{ </span><span>it</span><span>.</span><span>substring</span><span>(</span><span>0</span><span>..</span><span>1</span><span>) </span><span>}</span><span>))<br/></span><span>}</span></pre>
<p><kbd>it</kbd> is an implicit parameter (you don't declare it explicitly) that can be used in lambdas with just one parameter.</p>
<div class="packt_tip">Although it is tempting to use <kbd>it</kbd> for all cases, once you start using it with successive or nested lambdas, they can be difficult to read. Use it sparingly and when it is clear which type it is (no pun intended).</div>
<p>If a function receives a lambda as the last parameter, the lambda can be passed outside the parentheses:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>transform</span><span>(</span><span>"kotlin"</span><span>) </span><span>{ </span>str <span>-&gt; </span>str<span>.</span><span>substring</span><span>(</span><span>0</span><span>..</span><span>1</span><span>) </span><span>}</span><span>)<br/></span><span>}</span></pre>
<p>This feature opens up the possibility of creating <strong>Domain Specific Language</strong> (<strong>DSL</strong>) with Kotlin.</p>
<p>Do you know about the <kbd>unless</kbd> flow control statement from <strong>Ruby</strong>? <kbd>unless</kbd> is a control statement that executes a block of code if a condition is <kbd>false</kbd>; it's kind of a negated <kbd>if</kbd> condition but without an <kbd>else</kbd> clause.</p>
<p>Let's create a version for Kotlin by executing the following code snippet:</p>
<pre><span>fun </span><span>unless</span>(<span>condition</span>: Boolean<span>, </span><span>block</span>: () -&gt; <span>Unit</span>){<br/>   <span>if </span>(!<span>condition</span>) <span>block</span>()<br/>}<span><br/><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>securityCheck <span>= false </span><span>// some interesting code here<br/></span><span><br/></span><span>    </span><span>unless</span><span>(</span>securityCheck<span>) </span><span>{<br/></span><span>        </span><span>println</span><span>(</span><span>"You can't access this website"</span><span>)<br/></span><span>    </span><span>}<br/></span><span>}<br/></span></pre>
<p><kbd>unless</kbd> receives a condition as a Boolean and blocks to execute as a lambda <kbd>() -&gt; Unit</kbd> (no parameters and no return). When <kbd>unless</kbd> is executed, it looks exactly like any other Kotlin's control flow structure. </p>
<p>Now, type alias can be mixed with functions and used to replace simple interfaces. Let's take the following example, our <kbd>Machine&lt;T&gt;</kbd> <span>interface </span>from <a href="6fd42581-3c3e-4471-b103-22a571a138a4.xhtml">Chapter 1</a>, <em>Kotlin – Data Types, Objects, and Classes</em>:</p>
<pre><span>interface </span><span>Machine</span>&lt;<span>T</span>&gt; {<br/>   <span>fun </span><span>process</span>(<span>product</span>: <span>T</span>)<br/>}<br/><br/><span>fun </span>&lt;<span>T</span>&gt; <span>useMachine</span>(<span>t</span>: <span>T</span><span>, </span><span>machine</span>: <span>Machine</span>&lt;<span>T</span>&gt;) {<br/>   <span>machine</span>.<span>process</span>(<span>t</span>)<br/>}<br/><br/><span>class </span>PrintMachine&lt;<span>T</span>&gt; : <span>Machine</span>&lt;<span>T</span>&gt; {<br/>   <span>override fun </span><span>process</span>(<span>t</span>: <span>T</span>) {<br/>      <span>println</span>(<span>t</span>)<br/>   }<br/>}<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>useMachine</span><span>(</span><span>5</span><span>, </span><span>PrintMachine</span><span>())<br/></span><span><br/></span><span>    </span><span>useMachine</span><span>(</span><span>5</span><span>, </span><span>object </span>: <span>Machine</span><span>&lt;</span><span>Int</span><span>&gt; </span><span>{<br/></span><span>       </span><span>override fun </span><span>process</span><span>(</span>t: <span>Int</span><span>) {<br/></span><span>          </span><span>println</span><span>(</span>t<span>)<br/></span><span>       }<br/></span><span>    })<br/></span><span>}</span></pre>
<p>It can be replaced with a type alias and used with all the function's syntactical features:</p>
<pre><span>typealias </span>Machine&lt;<span>T</span>&gt; = (<span>T</span>) -&gt; <span>Unit<br/><br/></span><span>fun </span>&lt;<span>T</span>&gt; <span>useMachine</span>(<span>t</span>: <span>T</span><span>, </span><span>machine</span>: Machine&lt;<span>T</span>&gt;) {<br/>   <span>machine</span>(<span>t</span>)<br/>}<br/><br/><span>class </span>PrintMachine&lt;<span>T</span>&gt;: Machine&lt;<span>T</span>&gt; {<br/>   <span>override fun </span><span>invoke</span>(<span>p1</span>: <span>T</span>) {<br/>      <span>println</span>(<span>p1</span>)<br/>   }<br/>}<span> <br/><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>useMachine</span><span>(</span><span>5</span><span>, </span><span>PrintMachine</span><span>())<br/></span><span><br/></span><span>    </span><span>useMachine</span><span>(</span><span>5</span><span>, </span>::println<span>)<br/></span><span><br/></span><span>    </span><span>useMachine</span><span>(</span><span>5</span><span>) </span><span>{ </span>i <span>-&gt;<br/></span><span>        </span><span>println</span><span>(</span>i<span>)<br/></span><span>    </span><span>}<br/></span><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pure functions</h1>
                </header>
            
            <article>
                
<p><strong>Pure functions</strong> don't have side effects, nor memory, nor I/O. Pure functions have many properties, including referential transparency, caching (memoization), and others (we'll cover these features in the next chapters).</p>
<p>It is possible to write pure functions in Kotlin, but the compiler doesn't enforce it as in other languages. It is up to you to create pure functions to enjoy its benefits. Because Kotlin doesn't enforce pure functions, many programmers said that Kotlin isn't a real functional programming tool, and maybe they are right. Yes, Kotlin doesn't enforce pure functional programming, and that gives you great flexibility including the ability to write in a purely functional style, if you wish.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recursive functions</h1>
                </header>
            
            <article>
                
<p><strong>Recursive functions</strong> are functions that invoke themselves, with some sort of condition to stop the execution. In Kotlin, a recursive function maintains a stack but can be optimized with a <kbd>tailrec</kbd> modifier.</p>
<p>Let's look at an example, an implementation of a <kbd>factorial</kbd> function.</p>
<p>First, let's take a look at a typical imperative implementation, loops, and state change in the following code snippet:</p>
<pre><span>fun </span><span>factorial</span>(<span>n</span>: Long): Long {<br/>   <span>var </span><span>result </span>= <span>1L<br/></span><span>   </span><span>for </span>(<span>i </span><span>in </span><span>1</span>..<span>n</span>) {<br/>      <span>result </span>*= <span>i<br/></span><span>   </span>}<br/>   <span>return </span><span>result<br/></span>}</pre>
<p>It's nothing fancy nor particularly elegant. Now, let's take a look at a recursive implementation, no loops, and no state change:</p>
<pre><span>fun </span><span>functionalFactorial</span>(<span>n</span>: Long): Long {<br/>   <span>fun </span><span>go</span>(<span>n</span>: Long<span>, </span><span>acc</span>: Long): Long {<br/>      <span>return if </span>(<span>n </span>&lt;= <span>0</span>) {<br/>         <span>acc<br/></span><span>      </span>} <span>else </span>{<br/>         <span>go</span>(<span>n </span>- <span>1</span><span>, </span><span>n </span>* <span>acc</span>)<br/>      }<br/>   }<br/><br/>   <span>return </span><span>go</span>(<span>n</span><span>, </span><span>1</span>)<br/>} </pre>
<p>We use an internal recursive function; the <kbd>go</kbd> function calling itself until a condition is reached. As you can see, we're starting with the last <kbd>n</kbd><span> value</span> and reducing it in each recursive iteration.</p>
<p>An optimized implementation is similar but with a <kbd>tailrec</kbd> modifier:</p>
<pre><span>fun </span><span>tailrecFactorial</span>(<span>n</span>: Long): Long {<br/>   <span>tailrec fun </span><span>go</span>(<span>n</span>: Long<span>, </span><span>acc</span>: Long): Long {<br/>      <span>return if </span>(<span>n </span>&lt;= <span>0</span>) {<br/>         <span>acc<br/></span><span>      </span>} <span>else </span>{<br/>         <span>go</span>(<span>n </span>- <span>1</span><span>, </span><span>n </span>* <span>acc</span>)<br/>      }<br/>   }<br/><br/>   <span>return </span><span>go</span>(<span>n</span><span>, </span><span>1</span>)<br/>}</pre>
<p>To test which implementation is faster, we can write a poor's man profiler function:</p>
<pre><span>fun </span><span>executionTime</span>(<span>body</span>: () -&gt; <span>Unit</span>): Long {<br/>   <span>val </span><span>startTime </span>= System.<span>nanoTime</span>()<br/>   <span>body</span>()<br/>   <span>val </span><span>endTime </span>= System.<span>nanoTime</span>()<br/>   <span>return </span><span>endTime </span>- <span>startTime<br/></span>}</pre>
<p class="mce-root">For our purposes, the <kbd>executionTime</kbd> function is okay, but any serious production code should be profiled with a proper profiling tool, such as <strong>Java Microbenchmark Harness</strong> (<strong>JMH</strong>):</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>"factorial :" </span><span>+ </span><span>executionTime </span><span>{ </span><span>factorial</span><span>(</span><span>20</span><span>) </span><span>}</span><span>)<br/></span><span>    </span><span>println</span><span>(</span><span>"functionalFactorial :" </span><span>+ </span><span>executionTime </span><span>{ </span><span>functionalFactorial</span><span>(</span><span>20</span><span>) </span><span>}</span><span>)<br/></span><span>    </span><span>println</span><span>(</span><span>"tailrecFactorial :" </span><span>+ </span><span>executionTime </span><span>{ </span><span>tailrecFactorial</span><span>(</span><span>20</span><span>) </span><span>}</span><span>)<br/></span><span>}</span></pre>
<p>Here's the output for the preceding code:  </p>
<div class="CDPAlignCenter CDPAlign"><img height="62" width="214" src="assets/509fc2ef-db76-46ac-b62c-801fe5d72a9b.png"/></div>
<p>The <kbd>tailrec</kbd> optimized version is even faster than the normal imperative version. But <kbd>tailrec</kbd> isn't a magic incantation that will make your code run faster. As a general rule, the <kbd>tailrec</kbd> optimized code will run faster than the unoptimized version, but will not always beat a good old imperative code.</p>
<p>Let's explore a Fibonacci implementation, starting with an imperative one as follows:</p>
<pre><span>fun </span><span>fib</span>(<span>n</span>: Long): Long {<br/>   <span>return when </span>(<span>n</span>) {<br/>      <span>0L </span>-&gt; <span>0<br/></span><span>      1L </span>-&gt; <span>1<br/></span><span>      </span><span>else </span>-&gt; {<br/>         <span>var </span><span>a </span>= <span>0L<br/></span><span>         </span><span>var </span><span>b </span>= <span>1L<br/></span><span>         </span><span>var </span><span>c </span>= <span>0L<br/></span><span>         </span><span>for </span>(<span>i </span><span>in </span><span>2</span>..<span>n</span>) {<br/>            <span>c </span>= <span>a </span>+ <span>b<br/></span><span>            a </span>= <span>b<br/></span><span>            b </span>= <span>c<br/></span><span>         </span>}<br/>         <span>c<br/></span><span>      </span>}<br/>   }<br/>}</pre>
<p>Now, let's take a look at a functional recursive implementation:</p>
<pre><span>fun </span><span>functionalFib</span>(<span>n</span>: Long): Long {<br/>   <span>fun </span><span>go</span>(<span>n</span>: Long<span>, </span><span>prev</span>: Long<span>, </span><span>cur</span>: Long): Long {<br/>      <span>return if </span>(<span>n </span>== <span>0L</span>) {<br/>         <span>prev<br/></span><span>      </span>} <span>else </span>{<br/>         <span>go</span>(<span>n </span>- <span>1</span><span>, </span><span>cur</span><span>, </span><span>prev </span>+ <span>cur</span>)<br/>      }<br/>   }<br/><br/>   <span>return </span><span>go</span>(<span>n</span><span>, </span><span>0</span><span>, </span><span>1</span>)<br/>}</pre>
<p>Now let's check with its corresponding <kbd>tailrec</kbd> version, as follows:</p>
<pre><span>fun </span><span>tailrecFib</span>(<span>n</span>: Long): Long {<br/>   <span>tailrec fun </span><span>go</span>(<span>n</span>: Long<span>, </span><span>prev</span>: Long<span>, </span><span>cur</span>: Long): Long {<br/>      <span>return if </span>(<span>n </span>== <span>0L</span>) {<br/>         <span>prev<br/></span><span>      </span>} <span>else </span>{<br/>         <span>go</span>(<span>n </span>- <span>1</span><span>, </span><span>cur</span><span>, </span><span>prev </span>+ <span>cur</span>)<br/>      }<br/>   }<br/><br/>   <span>return </span><span>go</span>(<span>n</span><span>, </span><span>0</span><span>, </span><span>1</span>)<br/>}<br/><br/></pre>
<p class="mce-root">Then again, let's see its profiling with <kbd>executionTime</kbd>:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>println</span><span>(</span><span>"fib :" </span><span>+ </span><span>executionTime </span><span>{ </span><span>fib</span><span>(</span><span>93</span><span>) </span><span>}</span><span>)<br/></span><span>    </span><span>println</span><span>(</span><span>"functionalFib :" </span><span>+ </span><span>executionTime </span><span>{ </span><span>functionalFib</span><span>(</span><span>93</span><span>) </span><span>}</span><span>)<br/></span><span>    </span><span>println</span><span>(</span><span>"tailrecFib :" </span><span>+ </span><span>executionTime </span><span>{ </span><span>tailrecFib</span><span>(</span><span>93</span><span>) </span><span>}</span><span>)<br/></span><span>}</span></pre>
<p>The output will look something like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em" height="57" width="153" src="assets/dbce955f-92b2-4ae5-a35e-4650eedd6043.png"/></div>
<p>The <kbd>tailrec</kbd> implementation is much faster than the recursive version, but not as fast as a normal imperative implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lazy evaluation</h1>
                </header>
            
            <article>
                
<p>Some functional languages provide a <kbd>lazy</kbd> (non-strict) evaluation mode. Kotlin, by default, uses an <em>eager (strict) evaluation</em>.</p>
<p>Kotlin doesn't provide native support for lazy evaluation as part of the language itself, but as part of Kotlin's Standard Library and a language feature named <strong>delegate properties</strong> (we'll cover this in detail in future chapters):</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>i <span>by </span><span>lazy </span><span>{<br/></span><span>        </span><span>println</span><span>(</span><span>"Lazy evaluation"</span><span>)<br/></span><span>        </span><span>1<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>println</span><span>(</span><span>"before using i"</span><span>)<br/></span><span>    </span><span>println</span><span>(</span>i<span>)<br/></span><span>}</span></pre>
<p>The output will look something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="51" width="113" src="assets/0c3a2d43-47e1-40d2-9f6b-79bbaf6f870e.png"/></div>
<p>After the <kbd>by</kbd> reserved word, the <kbd>lazy()</kbd> higher-function receives an <kbd>(() -&gt; T)</kbd> <span>initializer lambda function </span>that will be executed the first time that <kbd>i</kbd> is accessed.</p>
<p>But also a normal lambda function can be used for some lazy use cases:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>size <span>= </span><span>listOf</span><span>(</span><span>2 </span><span>+ </span><span>1</span><span>, </span><span>3 </span><span>* </span><span>2</span><span>, </span><span>1 </span><span>/ </span><span>0</span><span>, </span><span>5 </span><span>- </span><span>4</span><span>).</span>size<br/><span>}</span></pre>
<p>If we try to execute this expression, it will throw an <kbd>ArithmeticException</kbd> exception, as we are dividing by zero:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>size <span>= </span><span>listOf</span><span>(</span><span>{ </span><span>2 </span><span>+ </span><span>1 </span><span>}</span><span>, </span><span>{ </span><span>3 </span><span>* </span><span>2 </span><span>}</span><span>, </span><span>{ </span><span>1 </span><span>/ </span><span>0 </span><span>}</span><span>, </span><span>{ </span><span>5 </span><span>- </span><span>4 </span><span>}</span><span>).</span>size<br/><span>}</span></pre>
<p>There's no problem executing this. The offending code isn't being executed, effectively making it a <kbd>lazy</kbd> evaluation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional collections</h1>
                </header>
            
            <article>
                
<p><strong>Functional collections</strong> are collections that offer a way to interact with its elements through high-order functions. Functional collections have common operations with names such as <kbd>filter</kbd>, <kbd>map</kbd>, and <kbd>fold</kbd>; these names are defined by convention (similar to a design pattern) and are being implemented in several libraries and languages.</p>
<p>Don't get confused with purely functional data structures—a data structure implemented in a pure functional language. A purely functional data structure is immutable and uses the <kbd>lazy</kbd> evaluation and other functional techniques.</p>
<p>Functional collections can but needn't necessarily be purely functional data structures. We have already covered how imperative implementations of algorithms can be faster than functional ones. </p>
<p>Kotlin comes with an excellent functional collection library. Let's have a look at it:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span>&lt;Int&gt; = <span>listOf</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>)</pre>
<p>Our value <kbd>numbers</kbd> as a <kbd>List&lt;Int&gt;</kbd> <span>type.</span> Now, let's print its members as follows:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>for</span><span>(</span>i <span>in </span><span>numbers</span><span>) {<br/></span><span>       </span><span>println</span><span>(</span><span>"i = </span><span>$</span>i<span>"</span><span>)<br/></span><span>    }<br/></span><span>}</span></pre>
<p>So far, so good, but it doesn't look very functional.</p>
<p>Worry no more; Kotlin collections include many functions that receive lambdas to operate on their members. We can replace this loop with a lambda as follows:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>numbers</span><span>.</span><span>forEach </span><span>{ </span>i <span>-&gt; </span><span>println</span><span>(</span><span>"i = </span><span>$</span>i<span>"</span><span>) </span><span>}<br/></span><span>}</span></pre>
<p>Now, let's transform our collection in the following code:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span><span>&lt;</span><span>Int</span><span>&gt; = </span><span>listOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>numbersTwice: <span>List</span><span>&lt;</span><span>Int</span><span>&gt; = </span><span>listOf</span><span>()<br/></span><span><br/></span><span>    </span><span>for </span><span>(</span>i <span>in </span><span>numbers</span><span>) {<br/></span><span>       </span>numbersTwice<span>.</span>add<span>(</span>i <span>* </span><span>2</span><span>) </span><span>//Compilation error: Unresolved reference: add <br/></span><span>    </span><span>}<br/></span><span>}</span></pre>
<p>This code doesn't compile; <kbd>numberTwice</kbd> doesn't have an <kbd>add(T)</kbd> method. <kbd>List&lt;T&gt;</kbd> is an immutable list; it can be modified once it is initialized. To add elements to a list, it must have a different type—<kbd>MutableList&lt;T&gt;</kbd> in our case:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span><span>&lt;</span><span>Int</span><span>&gt; = </span><span>listOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>numbersTwice: <span>MutableList</span><span>&lt;</span><span>Int</span><span>&gt; = </span><span>mutableListOf</span><span>()<br/></span><span><br/></span><span>    </span><span>for </span><span>(</span>i <span>in </span><span>numbers</span><span>) {<br/></span><span>        </span>numbersTwice<span>.</span><span>add</span><span>(</span>i <span>* </span><span>2</span><span>) </span><span>//Nice!<br/></span><span>    </span><span>}<br/></span><span>}</span></pre>
<p><kbd>MutableList&lt;T&gt;</kbd> extends <kbd>List&lt;T&gt;</kbd>; it adds the methods to modify the collection itself, such as <kbd>add(T)</kbd>, <kbd>remove(T)</kbd>, <kbd>clear</kbd>, and others.</p>
<p>All major Kotlin collection types (<kbd>List&lt;T&gt;</kbd>, <kbd>Set&lt;T&gt;</kbd>, and <kbd>Map&lt;K, V&gt;</kbd>) have mutable subtypes (<kbd>MutableList&lt;T&gt;</kbd>, <kbd>MutableSet&lt;T&gt;</kbd>, and <kbd>MutableMap&lt;K, V&gt;</kbd>).</p>
<p>But we can replace this transformation with a single line expression as shown in the following code:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span>&lt;Int&gt; = <span>listOf</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>)<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>numbersTwice: <span>List</span><span>&lt;</span><span>Int</span><span>&gt; = </span><span>numbers</span><span>.</span><span>map </span><span>{ </span>i <span>-&gt; </span>i <span>* </span><span>2 </span><span>}<br/></span><span>}</span></pre>
<p>The <kbd>map</kbd> operation lets you transform (technically mapping a value to another). This code has many advantages and is a lot cleaner, and now the <kbd>numbersTwice</kbd> value is a <kbd>List&lt;Int&gt;</kbd> list, instead of a <kbd>MutableList&lt;T&gt;</kbd> list.</p>
<p>Let's have another couple of examples. We can sum all elements of numbers using a loop:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span><span>&lt;</span><span>Int</span><span>&gt; = </span><span>listOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>var </span>sum <span>= </span><span>0<br/></span><span>    <br/></span><span>    </span><span>for </span><span>(</span>i <span>in </span><span>numbers</span><span>) {<br/></span><span>       </span>sum <span>+= </span>i<br/>    <span>}<br/></span><span>    <br/></span><span>    </span><span>println</span><span>(</span>sum<span>)    <br/></span><span>}</span></pre>
<p>It could be reduced to just one line, with an immutable <kbd>sum</kbd> value as follows:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span>&lt;Int&gt; = <span>listOf</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>)<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>sum <span>= </span><span>numbers</span><span>.</span><span>sum</span><span>()<br/></span><span>    <br/></span><span>    </span><span>println</span><span>(</span>sum<span>)    <br/></span><span>}</span></pre>
<p>Nice, but not interesting, so let's raise the stakes:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span>&lt;Int&gt; = <span>listOf</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>)<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>sum <span>= </span><span>numbers</span><span>.</span><span>fold</span><span>(</span><span>0</span><span>) </span><span>{ </span>acc<span>, </span>i <span>-&gt; </span>acc <span>+ </span>i <span>}<br/></span><span><br/></span><span>    </span><span>println</span><span>(</span>sum<span>)<br/></span><span>}</span></pre>
<p>The <kbd>fold</kbd> method iterates over a collection, keeping an accumulator value. <kbd>fold</kbd> takes a <kbd>T</kbd> value as the initial value; in the first iteration, this initial value will be the accumulator and subsequent iterations will use the lambda's return as the next accumulator value:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span>&lt;Int&gt; = <span>listOf</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>)<br/><br/><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>sum <span>= </span><span>numbers</span><span>.</span><span>fold</span><span>(</span><span>0</span><span>) </span><span>{ </span>acc<span>, </span>i <span>-&gt;<br/></span><span>        </span><span>println</span><span>(</span><span>"acc, i = </span><span>$</span>acc<span>, </span><span>$</span>i<span>"</span><span>)<br/></span><span>        </span>acc <span>+ </span>i<br/>    <span>}<br/></span><span><br/></span><span>    </span><span>println</span><span>(</span>sum<span>)<br/></span><span>}</span></pre>
<p>The output will look something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="83" width="95" src="assets/0a7a4251-1ffb-4166-b1ba-6db828a58893.png"/></div>
<p>Similar to <kbd>fold</kbd>, <kbd>reduce</kbd> iterates over a collection, with an accumulator but without an initial value:</p>
<pre><span>val </span><span>numbers</span>: <span>List</span><span>&lt;</span><span>Int</span><span>&gt; = </span><span>listOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>sum <span>= </span><span>numbers</span><span>.</span><span>reduce </span><span>{ </span>acc<span>, </span>i <span>-&gt;<br/></span><span>        </span><span>println</span><span>(</span><span>"acc, i = </span><span>$</span>acc<span>, </span><span>$</span>i<span>"</span><span>)<br/></span><span>        </span>acc <span>+ </span>i<br/>    <span>}<br/></span><span><br/></span><span>    </span><span>println</span><span>(</span>sum<span>)<br/></span><span>}</span></pre>
<p>The output will look something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="67" width="91" src="assets/df2b6f1c-7909-4232-a5c6-546735c1e5c4.png"/></div>
<p><kbd>fold</kbd> and <kbd>reduce</kbd> have counterparts in <kbd>foldRight</kbd> and <kbd>reduceRight</kbd> that start iterating from the last item to the first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a functional list</h1>
                </header>
            
            <article>
                
<p>With everything that we've learned in the first two chapters, we can implement a pure functional list:</p>
<pre><span>sealed class </span>FunList&lt;<span>out </span><span>T</span>&gt; {<br/>   <span>object Nil</span><span> </span>: FunList&lt;Nothing&gt;()<br/><br/>   <span>data class </span>Cons&lt;<span>out </span><span>T</span>&gt;(<span>val </span><span>head</span>: <span>T</span><span>, val </span><span>tail</span>: FunList&lt;<span>T</span>&gt;) : FunList&lt;<span>T</span>&gt;()<br/>}</pre>
<p>The <kbd>FunList</kbd> class is a sealed class; just two possible subclasses exist—<kbd>Nil</kbd>, an empty list (in other books you can see this defined as <kbd>Null</kbd> or <kbd>Empty</kbd>) and <kbd>Cons</kbd> (a construct, name inherited from Lisp, that holds two values).</p>
<p>The <kbd>T</kbd> <span>type </span>is marked <kbd>out</kbd>; this is for variance, which we'll cover variance in future chapters.</p>
<p><kbd>Nil</kbd> is an object (we don't need different instances of <kbd>Nil</kbd>) extending <kbd>FunList&lt;Nothing&gt;</kbd> (remember that <kbd>Nothing</kbd> is the bottom of Kotlin's type hierarchy).</p>
<p>The <kbd>Cons</kbd> value contains two values—<kbd>head</kbd>, a single <kbd>T</kbd>, and <kbd>tail</kbd>, a <kbd>FunList&lt;T&gt;</kbd>; therefore, it can be a <kbd>Nil</kbd> value or another <kbd>Cons</kbd>.</p>
<p>Let's create a list instance as follows:</p>
<pre><span>import </span>com<span>.</span>packtpub<span>.</span>functionalkotlin<span>.</span>chapter02<span>.</span><span>FunList</span><span>.</span><span>Cons<br/></span><span>import </span>com<span>.</span>packtpub<span>.</span>functionalkotlin<span>.</span>chapter02<span>.</span><span>FunList</span><span>.</span><span>Nil<br/><br/></span><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>numbers <span>= </span><span>Cons</span><span>(</span><span>1</span><span>, </span><span>Cons</span><span>(</span><span>2</span><span>, </span><span>Cons</span><span>(</span><span>3</span><span>, </span><span>Cons</span><span>(</span><span>4</span><span>, </span><span>Nil</span><span>))))<br/></span><span>}</span></pre>
<p>It's functional, but not very readable. We can create a better initialization function:</p>
<pre><span>import com.packtpub.functionalkotlin.chapter02.FunList.Cons<br/>import com.packtpub.functionalkotlin.chapter02.FunList.Nil<br/><br/>fun </span><span>intListOf</span>(<span>vararg </span><span>numbers</span>: Int): FunList&lt;Int&gt; {<br/>   <span>return if </span>(<span>numbers</span>.<span>isEmpty</span>()) {<br/>      <span>Nil<br/></span><span>   </span>} <span>else </span>{<br/>      Cons(<span>numbers</span>.<span>first</span>()<span>, </span><span>intListOf</span>(*<span>numbers</span>.<span>drop</span>(<span>1</span>).<span>toTypedArray</span>().<span>toIntArray</span>()))<br/>   }<br/>}</pre>
<p>There are quite a few new things here. The argument numbers are marked as <kbd>vararg</kbd>, which means that we can invoke this function with as many parameters as we want. For all intents and purposes, <kbd>numbers</kbd> is an <kbd>IntArray</kbd> value (a specialized type of array). If <kbd>numbers</kbd> is empty, we can return <kbd>Nil</kbd>. If not, we can extract the first element as our <kbd>head</kbd> value and recursively invoke <kbd>intLisfOf</kbd> for the <kbd>tail</kbd> value. To extract the <kbd>tail</kbd> value<span>,</span> we use the <kbd>drop</kbd> <span>method </span>and convert its result to an <kbd>IntArray</kbd> value. But we can't directly pass any array as <kbd>vararg</kbd>; therefore, we must use the spread (<kbd>*</kbd>) operator to pass each member of an array individually. </p>
<p>Now, we can create our <kbd>FunList&lt;Int&gt;</kbd> value:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>numbers <span>= </span><span>intListOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)    <br/></span><span>}</span></pre>
<p>Let's implement <kbd>forEach </kbd> as follows:</p>
<pre><span>sealed class </span>FunList&lt;<span>out </span><span>T</span>&gt; {<br/>   <span>object Nil</span><span> </span>: FunList&lt;Nothing&gt;()<br/><br/>   <span>data class </span>Cons&lt;<span>out </span><span>T</span>&gt;(<span>val </span><span>head</span>: <span>T</span><span>, val </span><span>tail</span>: FunList&lt;<span>T</span>&gt;) : FunList&lt;<span>T</span>&gt;()<br/><br/>   <span>fun </span><span>forEach</span>(<span>f</span>: (<span>T</span>) -&gt; <span>Unit</span>) {<br/>      <span>tailrec fun </span><span>go</span>(<span>list</span>: FunList&lt;<span>T</span>&gt;<span>, </span><span>f</span>: (<span>T</span>) -&gt; <span>Unit</span>) {<br/>         <span>when </span>(<span>list</span>) {<br/>            <span>is </span>Cons -&gt; {<br/>               <span>f</span>(<span>list</span>.<span>head</span>)<br/>               <span>go</span>(<span>list</span>.<span>tail</span><span>, </span><span>f</span>)<br/>            }<br/>            <span>is </span><span>Nil </span>-&gt; <span>Unit</span><span>//Do nothing<br/></span><span>         </span>}<br/>      }<br/><br/>      <span>go</span>(<span>this, </span><span>f</span>)<br/>   }<br/><br/>}</pre>
<p>The <kbd>forEach</kbd> implementation is similar to our examples of Factorial and Fibonacci functions in the recursion section, including <kbd>tailrec</kbd>.</p>
<p><kbd>FunList</kbd> is, technically, an <strong>Algebraic Data Type</strong> (<strong>ADT</strong>). <kbd>FunList</kbd> can be either a <kbd>Nil</kbd> or <kbd>Cons</kbd> and nothing else. Kotlin's compiler can use this information to check that both values are evaluated when a <kbd>FunList</kbd> type is used as the argument in a <kbd>when</kbd> control structure:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>numbers <span>= </span><span>intListOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span>    <br/></span><span>    </span>numbers<span>.</span><span>forEach </span><span>{ </span>i <span>-&gt; </span><span>println</span><span>(</span><span>"i = </span><span>$</span>i<span>"</span><span>) </span><span>}<br/></span><span>}</span></pre>
<p>Implementing <kbd>fold</kbd> will be similar to the following code:</p>
<pre><span>sealed class </span><span>FunList</span><span>&lt;out </span><span>T</span><span>&gt; </span><span>{<br/></span><span>   </span><span><br/>  /*Previous code here*/<br/><br/></span><span>   </span><span>fun &lt;</span><span>R</span><span>&gt; </span><span>fold</span><span>(</span>init: <span>R</span><span>, </span>f: <span>(</span><span>R</span><span>, </span><span>T</span><span>) -&gt; </span><span>R</span><span>)</span>: <span>R </span><span>{<br/></span><span>      </span><span>tailrec fun </span><span>go</span><span>(</span>list: <span>FunList</span><span>&lt;</span><span>T</span><span>&gt;</span><span>, </span>init: <span>R</span><span>, </span>f: <span>(</span><span>R</span><span>, </span><span>T</span><span>) -&gt; </span><span>R</span><span>)</span>: <span>R </span><span>= when </span><span>(</span>list<span>) {<br/></span><span>         </span><span>is </span><span>Cons </span><span>-&gt; </span><span>go</span><span>(</span>list<span>.</span>tail<span>, </span><span>f</span><span>(</span>init<span>, </span>list<span>.</span>head<span>), </span>f<span>)<br/></span><span>         </span><span>is </span><span>Nil </span><span>-&gt; </span>init<br/>      <span>}<br/></span><span><br/></span><span>      </span><span>return </span><span>go</span><span>(</span><span>this</span><span>, </span>init<span>, </span>f<span>)<br/></span><span>   }<br/>}<br/></span></pre>
<p>Did you notice that these functions are very easy to implement? Let's have a look at the following code:</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>numbers <span>= </span><span>intListOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span>    <br/></span><span>    </span><span>val </span>sum <span>= </span>numbers<span>.</span><span>fold</span><span>(</span><span>0</span><span>) </span><span>{ </span>acc<span>, </span>i <span>-&gt; </span>acc <span>+ </span>i<span>}<br/></span><span>}</span></pre>
<p>What about a little contest between Kotlin's list and our functional list?</p>
<pre><span>fun </span><span>main</span><span>(</span>args: <span>Array</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) {<br/></span><span>    </span><span>val </span>funList <span>= </span><span>intListOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span>    </span><span>val </span>list <span>= </span><span>listOf</span><span>(</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>)<br/></span><span><br/></span><span>    </span><span>println</span><span>(</span><span>"fold on funList : </span><span>${</span><span>executionTime </span><span>{ </span><span>funList</span><span>.</span><span>fold</span><span>(</span><span>0</span><span>) </span><span>{ </span>acc<span>, </span>i <span>-&gt; </span>acc <span>+ </span>i <span>} }</span><span>}</span><span>"</span><span>)<br/></span><span>    </span><span>println</span><span>(</span><span>"fold on list : </span><span>${</span><span>executionTime </span><span>{ </span><span>list</span><span>.</span><span>fold</span><span>(</span><span>0</span><span>) </span><span>{ </span>acc<span>, </span>i <span>-&gt; </span>acc <span>+ </span>i <span>} }</span><span>}</span><span>"</span><span>)<br/></span><span>}</span></pre>
<p>The output will look something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="39" width="183" src="assets/dd6c4ae9-a493-4e7b-89e5-4ecda3ad2cba.png"/></div>
<p>Ouch! Our implementation is 10 times slower. No worries, Kotlin's implementation is a heavily optimized imperative solution and ours is just to learn and have fun (pun intended).</p>
<p>What about <kbd>map</kbd>? To implement <kbd>map</kbd> in a functional way we need to implement other functions first. Let's start with <kbd>reverse</kbd>.</p>
<p><kbd>reverse</kbd> is a function that returns a list in reverse order:</p>
<pre><span>sealed class </span><span>FunList</span><span>&lt;out </span><span>T</span><span>&gt; </span><span>{<br/></span><span><br/>    /*previous code*/<br/><br/></span><span>    </span><span>fun </span><span>reverse</span><span>()</span>: <span>FunList</span><span>&lt;</span><span>T</span><span>&gt; = </span><span>fold</span><span>(</span><span>Nil </span><span>as </span><span>FunList</span><span>&lt;</span><span>T</span><span>&gt;</span><span>) </span><span>{ </span>acc<span>, </span>i <span>-&gt; </span><span>Cons</span><span>(</span>i<span>, </span>acc<span>) </span><span>}<br/>}<br/></span></pre>
<p>We can reuse <kbd>fold</kbd> and build a new <kbd>Cons</kbd> value in each iteration, using the <kbd>acc</kbd> value as <kbd>tail</kbd>. This is one of the big advantages of functional programming—reusing existing functions.</p>
<p>Now, we can implement <kbd>foldRight</kbd>:</p>
<pre><span>sealed class </span><span>FunList</span><span>&lt;out </span><span>T</span><span>&gt; </span><span>{<br/></span><span><br/>    /*previous code*/<br/><br/>  </span><span>fun </span>&lt;<span>R</span>&gt; <span>foldRight</span>(<span>init</span>: <span>R</span><span>, </span><span>f</span>: (<span>R</span><span>, </span><span>T</span>) -&gt; <span>R</span>): <span>R </span>{<br/>   <span>return this</span>.<span>reverse</span>().<span>fold</span>(<span>init</span><span>, </span><span>f</span>)<br/>  }<br/>}</pre>
<p>Again, we are reusing existing functions. It is time to implement our <kbd>map</kbd> function. At this point, it is not surprising that we'll reuse our existing functions:</p>
<pre><span>sealed class </span><span>FunList</span><span>&lt;out </span><span>T</span><span>&gt; </span><span>{<br/></span><span><br/> /*previous code*<br/><br/> </span><span>fun </span>&lt;<span>R</span>&gt; <span>map</span>(<span>f</span>:(<span>T</span>) -&gt; <span>R</span>): FunList&lt;<span>R</span>&gt; {<br/>   <span>return </span><span>foldRight</span>(<span>Nil </span><span>as </span>FunList&lt;<span>R</span>&gt;)<span>{ </span><span>tail</span><span>, </span><span>head </span><span>-&gt; </span>Cons(<span>f</span>(<span>head</span>)<span>, </span><span>tail</span>) <span>}<br/></span> }<br/>}</pre>
<p><kbd>foldRight</kbd> is all that we need. As you can see, we can implement a complete list using functions and other basic concepts as building blocks. And that is all about functional programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the basics of functional programming, including high-order functions, pure functions, recursion functions, and lazy evaluation. We also covered functional collections and we implemented a functional collection, using a functional programming style.</p>
<p>In the next chapter, we'll cover a foundational stone of functional programming—immutability.</p>


            </article>

            
        </section>
    </body></html>