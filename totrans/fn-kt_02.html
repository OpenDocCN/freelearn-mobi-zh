<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started with Functional Programming</h1>
                
            
            
                
<p class="mce-root">Functional programming has been making big waves in the software industry for the last five years, and everyone wants to jump on the bandwagon. Functional programming is a lot older, starting in the 1950s with <strong>Lisp</strong> being considered the first programming language (or at least, the first one to introduce functional features) which still exists as <strong>Common Lisp,</strong> and other dialects such as <strong>Scheme</strong> and <strong>Clojure</strong>.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>What is functional programming?</li>
<li>Basic concepts</li>
<li>Functional collections</li>
<li>Implementing a functional list</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is functional programming?</h1>
                
            
            
                
<p><strong>Functional programming</strong> is a paradigm (a style of structuring your programs). In essence, the focus is on transforming data with expressions (ideally such expressions should not have side effects). Its name, functional, is based on the concept of a mathematical function (not in sub-routines, methods, or procedures). A mathematical function defines a relation between a set of inputs and outputs. Each input has just one output. For example, given a function, <em>f(x) = X<sup>2</sup>; f(5)</em> is always <em>25</em>.</p>
<p>The way to guarantee, in a programming language, that calling a function with a parameter always returns the same value, is to avoid accessing to mutable state:</p>
<pre>fun f(x: Long) : Long { <br/>   return x * x // no access to external state<br/>}</pre>
<p>The <kbd>f</kbd> function doesn't access any external state; therefore, calling <em>f(5)</em> will always return <em>25</em>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    var i = 0<br/><br/>    fun g(x: Long): Long {<br/>       return x * i // accessing mutable state<br/>    }<br/><br/>    println(g(1)) //0<br/>    i++<br/>    println(g(1)) //1<br/>    i++<br/>    println(g(1)) //2<br/>}</pre>
<p>The <kbd>g</kbd> function, on the other hand, depends on mutable state and returns different values for the same.</p>
<p>Now, in a real-life program (a <strong>Content Management System</strong> (<strong>CMS</strong>), shopping cart, or chat), state changes. So, in a functional programming style, state management must be explicit and careful. The techniques to manage state change in functional programming will be covered later. </p>
<p>A functional programming style will provide us with the following benefits:</p>
<ul>
<li><strong>Code is easy to read and test</strong>: Functions that don't depend on external mutable state are more accessible to reason about and to prove<strong><br/></strong></li>
<li><strong>State and side effects are carefully planned</strong>: Limiting state management to individual and specific places in our code makes it easy to maintain and refactor</li>
<li><strong>Concurrency gets safer and more natural</strong>: No mutable state means that concurrency code needs less or no locks around your code</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Basics concepts</h1>
                
            
            
                
<p>Functional programming is composed of a few well-defined concepts. A short introduction of these concepts will follow and, later on, each concept will be covered in depth, in the next chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">First-class and higher-order functions</h1>
                
            
            
                
<p>The most foundational concept of functional programming is <strong>first-class functions</strong>. A programming language with support for first-class functions will treat functions as any other type; such languages will allow you to use functions as variables, parameters, returns, generalization types, and so on. Speaking of parameters and returns, a function that uses or returns other functions is a <strong>higher-order function</strong>.</p>
<p>Kotlin has support for both concepts.</p>
<p>Let's try a simple function (in Kotlin's documentation this kind of function is named lambda):</p>
<pre>val capitalize = { str: String -&gt; str.capitalize() }<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   println(capitalize("hello world!"))<br/>}</pre>
<p>The <kbd>capitalize</kbd> lambda function is of type <kbd>(String) -&gt; String</kbd>; in other words, <kbd>capitalize</kbd> will take <kbd>String</kbd> and return another <kbd>String</kbd>—in this case, a capitalized <kbd>String</kbd>.</p>
<p>As a lambda function, <kbd>capitalize</kbd> can be executed using parentheses with parameters (or no parameters at all, depending on the situation).</p>
<p>But what does the <kbd>(String) -&gt; String</kbd> type mean?</p>
<p><kbd>(String) -&gt; String</kbd> is a shortcut (some could call it syntactic sugar) for <kbd>Function1&lt;String, String&gt;</kbd>, <kbd>Function1&lt;P1, R&gt;</kbd> is an interface defined in the Kotlin standard library. <kbd>Function1&lt;P1, R&gt;</kbd> has a single method, <kbd>invoke(P1): R</kbd>, that is marked as an operator (we'll cover operators later).</p>
<p>Kotlin's compiler can translate the shortcut syntax into a fully fledged function object at compile time (indeed, the compiler will apply many more optimizations) as follows:</p>
<pre>val capitalize = { str: String -&gt; str.capitalize() }</pre>
<p>It is equivalent to the following code:</p>
<pre>val capitalize = object : Function1&lt;String, String&gt; {<br/>   override fun invoke(p1: String): String {<br/>      return p1.capitalize()<br/>   }<br/>}</pre>
<p>As you can see, the <kbd>capitalize</kbd> value's body is located inside the <kbd>invoke</kbd> method.</p>
<p>In Kotlin, lambda functions can be used as parameters in other functions as well.</p>
<p>Let's take a look at the following example:</p>
<pre>fun transform(str:String, fn: (String) -&gt; String): String {<br/>   return fn(str)<br/>}</pre>
<p>The <kbd>transform(String, (String) -&gt; String)</kbd> function takes one <kbd>String</kbd> and applies a lambda function to it.</p>
<p>For all intents and purposes, we can generalize <kbd>transform</kbd>:</p>
<pre>fun &lt;T&gt; transform(t: T, fn: (T) -&gt; T): T {<br/>   return fn(t)<br/>}</pre>
<p>Using <kbd>transform</kbd> is very simple. Take a look at the following code snippet:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println(transform("kotlin", capitalize))<br/>}</pre>
<p>We can pass <kbd>capitalize</kbd> as a parameter directly, great stuff.</p>
<p>There are more ways to call the <kbd>transform</kbd> function. Let's try some more:  </p>
<pre>fun reverse(str: String): String {<br/>   return str.reversed()<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    println(transform("kotlin", ::reverse))<br/>}</pre>
<p><kbd>reverse</kbd> is a function; we can pass a reference to it using a double colon (<kbd>::</kbd>) as follows:</p>
<pre>object MyUtils {<br/>   fun doNothing(str: String): String {<br/>      return str<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    println(transform("kotlin", MyUtils::doNothing))<br/>}</pre>
<p><kbd>doNothing</kbd> is an object method, and in this case, we use <kbd>::</kbd> after the <kbd>MyUtils</kbd> object name:</p>
<pre>class Transformer {<br/>   fun upperCased(str: String): String {<br/>      return str.toUpperCase()<br/>   }<br/><br/>   companion object {<br/>      fun lowerCased(str: String): String {<br/>         return str.toLowerCase()<br/>      }<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val transformer = Transformer()<br/><br/>    println(transform("kotlin", transformer::upperCased))<br/>    <br/>    println(transform("kotlin", Transformer.Companion::lowerCased))<br/>}</pre>
<p>We can also pass references to instances or companion object methods. But probably the most common case is to pass a lambda directly:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println(transform("kotlin", { str -&gt; str.substring(0..1) }))<br/>}</pre>
<p>There is a shorter version of this using the <kbd>it</kbd> implicit parameter as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println(transform("kotlin", { it.substring(0..1) }))<br/>}</pre>
<p><kbd>it</kbd> is an implicit parameter (you don't declare it explicitly) that can be used in lambdas with just one parameter.</p>
<p>Although it is tempting to use <kbd>it</kbd> for all cases, once you start using it with successive or nested lambdas, they can be difficult to read. Use it sparingly and when it is clear which type it is (no pun intended).</p>
<p>If a function receives a lambda as the last parameter, the lambda can be passed outside the parentheses:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println(transform("kotlin") { str -&gt; str.substring(0..1) })<br/>}</pre>
<p>This feature opens up the possibility of creating <strong>Domain Specific Language</strong> (<strong>DSL</strong>) with Kotlin.</p>
<p>Do you know about the <kbd>unless</kbd> flow control statement from <strong>Ruby</strong>? <kbd>unless</kbd> is a control statement that executes a block of code if a condition is <kbd>false</kbd>; it's kind of a negated <kbd>if</kbd> condition but without an <kbd>else</kbd> clause.</p>
<p>Let's create a version for Kotlin by executing the following code snippet:</p>
<pre>fun unless(condition: Boolean, block: () -&gt; Unit){<br/>   if (!condition) block()<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val securityCheck = false // some interesting code here<br/><br/>    unless(securityCheck) {<br/>        println("You can't access this website")<br/>    }<br/>}<br/></pre>
<p><kbd>unless</kbd> receives a condition as a Boolean and blocks to execute as a lambda <kbd>() -&gt; Unit</kbd> (no parameters and no return). When <kbd>unless</kbd> is executed, it looks exactly like any other Kotlin's control flow structure. </p>
<p>Now, type alias can be mixed with functions and used to replace simple interfaces. Let's take the following example, our <kbd>Machine&lt;T&gt;</kbd> interface from <a href="6fd42581-3c3e-4471-b103-22a571a138a4.xhtml">Chapter 1</a>, <em>Kotlin – Data Types, Objects, and Classes</em>:</p>
<pre>interface Machine&lt;T&gt; {<br/>   fun process(product: T)<br/>}<br/><br/>fun &lt;T&gt; useMachine(t: T, machine: Machine&lt;T&gt;) {<br/>   machine.process(t)<br/>}<br/><br/>class PrintMachine&lt;T&gt; : Machine&lt;T&gt; {<br/>   override fun process(t: T) {<br/>      println(t)<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    useMachine(5, PrintMachine())<br/><br/>    useMachine(5, object : Machine&lt;Int&gt; {<br/>       override fun process(t: Int) {<br/>          println(t)<br/>       }<br/>    })<br/>}</pre>
<p>It can be replaced with a type alias and used with all the function's syntactical features:</p>
<pre>typealias Machine&lt;T&gt; = (T) -&gt; Unit<br/><br/>fun &lt;T&gt; useMachine(t: T, machine: Machine&lt;T&gt;) {<br/>   machine(t)<br/>}<br/><br/>class PrintMachine&lt;T&gt;: Machine&lt;T&gt; {<br/>   override fun invoke(p1: T) {<br/>      println(p1)<br/>   }<br/>} <br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    useMachine(5, PrintMachine())<br/><br/>    useMachine(5, ::println)<br/><br/>    useMachine(5) { i -&gt;<br/>        println(i)<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Pure functions</h1>
                
            
            
                
<p><strong>Pure functions</strong> don't have side effects, nor memory, nor I/O. Pure functions have many properties, including referential transparency, caching (memoization), and others (we'll cover these features in the next chapters).</p>
<p>It is possible to write pure functions in Kotlin, but the compiler doesn't enforce it as in other languages. It is up to you to create pure functions to enjoy its benefits. Because Kotlin doesn't enforce pure functions, many programmers said that Kotlin isn't a real functional programming tool, and maybe they are right. Yes, Kotlin doesn't enforce pure functional programming, and that gives you great flexibility including the ability to write in a purely functional style, if you wish.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Recursive functions</h1>
                
            
            
                
<p><strong>Recursive functions</strong> are functions that invoke themselves, with some sort of condition to stop the execution. In Kotlin, a recursive function maintains a stack but can be optimized with a <kbd>tailrec</kbd> modifier.</p>
<p>Let's look at an example, an implementation of a <kbd>factorial</kbd> function.</p>
<p>First, let's take a look at a typical imperative implementation, loops, and state change in the following code snippet:</p>
<pre>fun factorial(n: Long): Long {<br/>   var result = 1L<br/>   for (i in 1..n) {<br/>      result *= i<br/>   }<br/>   return result<br/>}</pre>
<p>It's nothing fancy nor particularly elegant. Now, let's take a look at a recursive implementation, no loops, and no state change:</p>
<pre>fun functionalFactorial(n: Long): Long {<br/>   fun go(n: Long, acc: Long): Long {<br/>      return if (n &lt;= 0) {<br/>         acc<br/>      } else {<br/>         go(n - 1, n * acc)<br/>      }<br/>   }<br/><br/>   return go(n, 1)<br/>} </pre>
<p>We use an internal recursive function; the <kbd>go</kbd> function calling itself until a condition is reached. As you can see, we're starting with the last <kbd>n</kbd> value and reducing it in each recursive iteration.</p>
<p>An optimized implementation is similar but with a <kbd>tailrec</kbd> modifier:</p>
<pre>fun tailrecFactorial(n: Long): Long {<br/>   tailrec fun go(n: Long, acc: Long): Long {<br/>      return if (n &lt;= 0) {<br/>         acc<br/>      } else {<br/>         go(n - 1, n * acc)<br/>      }<br/>   }<br/><br/>   return go(n, 1)<br/>}</pre>
<p>To test which implementation is faster, we can write a poor's man profiler function:</p>
<pre>fun executionTime(body: () -&gt; Unit): Long {<br/>   val startTime = System.nanoTime()<br/>   body()<br/>   val endTime = System.nanoTime()<br/>   return endTime - startTime<br/>}</pre>
<p class="mce-root">For our purposes, the <kbd>executionTime</kbd> function is okay, but any serious production code should be profiled with a proper profiling tool, such as <strong>Java Microbenchmark Harness</strong> (<strong>JMH</strong>):</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println("factorial :" + executionTime { factorial(20) })<br/>    println("functionalFactorial :" + executionTime { functionalFactorial(20) })<br/>    println("tailrecFactorial :" + executionTime { tailrecFactorial(20) })<br/>}</pre>
<p>Here's the output for the preceding code:  </p>
<div><img height="62" width="214" src="img/509fc2ef-db76-46ac-b62c-801fe5d72a9b.png"/></div>
<p>The <kbd>tailrec</kbd> optimized version is even faster than the normal imperative version. But <kbd>tailrec</kbd> isn't a magic incantation that will make your code run faster. As a general rule, the <kbd>tailrec</kbd> optimized code will run faster than the unoptimized version, but will not always beat a good old imperative code.</p>
<p>Let's explore a Fibonacci implementation, starting with an imperative one as follows:</p>
<pre>fun fib(n: Long): Long {<br/>   return when (n) {<br/>      0L -&gt; 0<br/>      1L -&gt; 1<br/>      else -&gt; {<br/>         var a = 0L<br/>         var b = 1L<br/>         var c = 0L<br/>         for (i in 2..n) {<br/>            c = a + b<br/>            a = b<br/>            b = c<br/>         }<br/>         c<br/>      }<br/>   }<br/>}</pre>
<p>Now, let's take a look at a functional recursive implementation:</p>
<pre>fun functionalFib(n: Long): Long {<br/>   fun go(n: Long, prev: Long, cur: Long): Long {<br/>      return if (n == 0L) {<br/>         prev<br/>      } else {<br/>         go(n - 1, cur, prev + cur)<br/>      }<br/>   }<br/><br/>   return go(n, 0, 1)<br/>}</pre>
<p>Now let's check with its corresponding <kbd>tailrec</kbd> version, as follows:</p>
<pre>fun tailrecFib(n: Long): Long {<br/>   tailrec fun go(n: Long, prev: Long, cur: Long): Long {<br/>      return if (n == 0L) {<br/>         prev<br/>      } else {<br/>         go(n - 1, cur, prev + cur)<br/>      }<br/>   }<br/><br/>   return go(n, 0, 1)<br/>}<br/><br/></pre>
<p class="mce-root">Then again, let's see its profiling with <kbd>executionTime</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println("fib :" + executionTime { fib(93) })<br/>    println("functionalFib :" + executionTime { functionalFib(93) })<br/>    println("tailrecFib :" + executionTime { tailrecFib(93) })<br/>}</pre>
<p>The output will look something like the following:</p>
<div><img style="font-size: 1em" height="57" width="153" src="img/dbce955f-92b2-4ae5-a35e-4650eedd6043.png"/></div>
<p>The <kbd>tailrec</kbd> implementation is much faster than the recursive version, but not as fast as a normal imperative implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lazy evaluation</h1>
                
            
            
                
<p>Some functional languages provide a <kbd>lazy</kbd> (non-strict) evaluation mode. Kotlin, by default, uses an <em>eager (strict) evaluation</em>.</p>
<p>Kotlin doesn't provide native support for lazy evaluation as part of the language itself, but as part of Kotlin's Standard Library and a language feature named <strong>delegate properties</strong> (we'll cover this in detail in future chapters):</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val i by lazy {<br/>        println("Lazy evaluation")<br/>        1<br/>    }<br/><br/>    println("before using i")<br/>    println(i)<br/>}</pre>
<p>The output will look something like the following screenshot:</p>
<div><img height="51" width="113" src="img/0c3a2d43-47e1-40d2-9f6b-79bbaf6f870e.png"/></div>
<p>After the <kbd>by</kbd> reserved word, the <kbd>lazy()</kbd> higher-function receives an <kbd>(() -&gt; T)</kbd> initializer lambda function that will be executed the first time that <kbd>i</kbd> is accessed.</p>
<p>But also a normal lambda function can be used for some lazy use cases:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val size = listOf(2 + 1, 3 * 2, 1 / 0, 5 - 4).size<br/>}</pre>
<p>If we try to execute this expression, it will throw an <kbd>ArithmeticException</kbd> exception, as we are dividing by zero:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val size = listOf({ 2 + 1 }, { 3 * 2 }, { 1 / 0 }, { 5 - 4 }).size<br/>}</pre>
<p>There's no problem executing this. The offending code isn't being executed, effectively making it a <kbd>lazy</kbd> evaluation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functional collections</h1>
                
            
            
                
<p><strong>Functional collections</strong> are collections that offer a way to interact with its elements through high-order functions. Functional collections have common operations with names such as <kbd>filter</kbd>, <kbd>map</kbd>, and <kbd>fold</kbd>; these names are defined by convention (similar to a design pattern) and are being implemented in several libraries and languages.</p>
<p>Don't get confused with purely functional data structures—a data structure implemented in a pure functional language. A purely functional data structure is immutable and uses the <kbd>lazy</kbd> evaluation and other functional techniques.</p>
<p>Functional collections can but needn't necessarily be purely functional data structures. We have already covered how imperative implementations of algorithms can be faster than functional ones. </p>
<p>Kotlin comes with an excellent functional collection library. Let's have a look at it:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)</pre>
<p>Our value <kbd>numbers</kbd> as a <kbd>List&lt;Int&gt;</kbd> type. Now, let's print its members as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    for(i in numbers) {<br/>       println("i = $i")<br/>    }<br/>}</pre>
<p>So far, so good, but it doesn't look very functional.</p>
<p>Worry no more; Kotlin collections include many functions that receive lambdas to operate on their members. We can replace this loop with a lambda as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    numbers.forEach { i -&gt; println("i = $i") }<br/>}</pre>
<p>Now, let's transform our collection in the following code:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val numbersTwice: List&lt;Int&gt; = listOf()<br/><br/>    for (i in numbers) {<br/>       numbersTwice.add(i * 2) //Compilation error: Unresolved reference: add <br/>    }<br/>}</pre>
<p>This code doesn't compile; <kbd>numberTwice</kbd> doesn't have an <kbd>add(T)</kbd> method. <kbd>List&lt;T&gt;</kbd> is an immutable list; it can be modified once it is initialized. To add elements to a list, it must have a different type—<kbd>MutableList&lt;T&gt;</kbd> in our case:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val numbersTwice: MutableList&lt;Int&gt; = mutableListOf()<br/><br/>    for (i in numbers) {<br/>        numbersTwice.add(i * 2) //Nice!<br/>    }<br/>}</pre>
<p><kbd>MutableList&lt;T&gt;</kbd> extends <kbd>List&lt;T&gt;</kbd>; it adds the methods to modify the collection itself, such as <kbd>add(T)</kbd>, <kbd>remove(T)</kbd>, <kbd>clear</kbd>, and others.</p>
<p>All major Kotlin collection types (<kbd>List&lt;T&gt;</kbd>, <kbd>Set&lt;T&gt;</kbd>, and <kbd>Map&lt;K, V&gt;</kbd>) have mutable subtypes (<kbd>MutableList&lt;T&gt;</kbd>, <kbd>MutableSet&lt;T&gt;</kbd>, and <kbd>MutableMap&lt;K, V&gt;</kbd>).</p>
<p>But we can replace this transformation with a single line expression as shown in the following code:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val numbersTwice: List&lt;Int&gt; = numbers.map { i -&gt; i * 2 }<br/>}</pre>
<p>The <kbd>map</kbd> operation lets you transform (technically mapping a value to another). This code has many advantages and is a lot cleaner, and now the <kbd>numbersTwice</kbd> value is a <kbd>List&lt;Int&gt;</kbd> list, instead of a <kbd>MutableList&lt;T&gt;</kbd> list.</p>
<p>Let's have another couple of examples. We can sum all elements of numbers using a loop:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    var sum = 0<br/>    <br/>    for (i in numbers) {<br/>       sum += i<br/>    }<br/>    <br/>    println(sum)    <br/>}</pre>
<p>It could be reduced to just one line, with an immutable <kbd>sum</kbd> value as follows:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val sum = numbers.sum()<br/>    <br/>    println(sum)    <br/>}</pre>
<p>Nice, but not interesting, so let's raise the stakes:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val sum = numbers.fold(0) { acc, i -&gt; acc + i }<br/><br/>    println(sum)<br/>}</pre>
<p>The <kbd>fold</kbd> method iterates over a collection, keeping an accumulator value. <kbd>fold</kbd> takes a <kbd>T</kbd> value as the initial value; in the first iteration, this initial value will be the accumulator and subsequent iterations will use the lambda's return as the next accumulator value:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val sum = numbers.fold(0) { acc, i -&gt;<br/>        println("acc, i = $acc, $i")<br/>        acc + i<br/>    }<br/><br/>    println(sum)<br/>}</pre>
<p>The output will look something like the following screenshot:</p>
<div><img height="83" width="95" src="img/0a7a4251-1ffb-4166-b1ba-6db828a58893.png"/></div>
<p>Similar to <kbd>fold</kbd>, <kbd>reduce</kbd> iterates over a collection, with an accumulator but without an initial value:</p>
<pre>val numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val sum = numbers.reduce { acc, i -&gt;<br/>        println("acc, i = $acc, $i")<br/>        acc + i<br/>    }<br/><br/>    println(sum)<br/>}</pre>
<p>The output will look something like the following screenshot:</p>
<div><img height="67" width="91" src="img/df2b6f1c-7909-4232-a5c6-546735c1e5c4.png"/></div>
<p><kbd>fold</kbd> and <kbd>reduce</kbd> have counterparts in <kbd>foldRight</kbd> and <kbd>reduceRight</kbd> that start iterating from the last item to the first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a functional list</h1>
                
            
            
                
<p>With everything that we've learned in the first two chapters, we can implement a pure functional list:</p>
<pre>sealed class FunList&lt;out T&gt; {<br/>   object Nil : FunList&lt;Nothing&gt;()<br/><br/>   data class Cons&lt;out T&gt;(val head: T, val tail: FunList&lt;T&gt;) : FunList&lt;T&gt;()<br/>}</pre>
<p>The <kbd>FunList</kbd> class is a sealed class; just two possible subclasses exist—<kbd>Nil</kbd>, an empty list (in other books you can see this defined as <kbd>Null</kbd> or <kbd>Empty</kbd>) and <kbd>Cons</kbd> (a construct, name inherited from Lisp, that holds two values).</p>
<p>The <kbd>T</kbd> type is marked <kbd>out</kbd>; this is for variance, which we'll cover variance in future chapters.</p>
<p><kbd>Nil</kbd> is an object (we don't need different instances of <kbd>Nil</kbd>) extending <kbd>FunList&lt;Nothing&gt;</kbd> (remember that <kbd>Nothing</kbd> is the bottom of Kotlin's type hierarchy).</p>
<p>The <kbd>Cons</kbd> value contains two values—<kbd>head</kbd>, a single <kbd>T</kbd>, and <kbd>tail</kbd>, a <kbd>FunList&lt;T&gt;</kbd>; therefore, it can be a <kbd>Nil</kbd> value or another <kbd>Cons</kbd>.</p>
<p>Let's create a list instance as follows:</p>
<pre>import com.packtpub.functionalkotlin.chapter02.FunList.Cons<br/>import com.packtpub.functionalkotlin.chapter02.FunList.Nil<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val numbers = Cons(1, Cons(2, Cons(3, Cons(4, Nil))))<br/>}</pre>
<p>It's functional, but not very readable. We can create a better initialization function:</p>
<pre>import com.packtpub.functionalkotlin.chapter02.FunList.Cons<br/>import com.packtpub.functionalkotlin.chapter02.FunList.Nil<br/><br/>fun intListOf(vararg numbers: Int): FunList&lt;Int&gt; {<br/>   return if (numbers.isEmpty()) {<br/>      Nil<br/>   } else {<br/>      Cons(numbers.first(), intListOf(*numbers.drop(1).toTypedArray().toIntArray()))<br/>   }<br/>}</pre>
<p>There are quite a few new things here. The argument numbers are marked as <kbd>vararg</kbd>, which means that we can invoke this function with as many parameters as we want. For all intents and purposes, <kbd>numbers</kbd> is an <kbd>IntArray</kbd> value (a specialized type of array). If <kbd>numbers</kbd> is empty, we can return <kbd>Nil</kbd>. If not, we can extract the first element as our <kbd>head</kbd> value and recursively invoke <kbd>intLisfOf</kbd> for the <kbd>tail</kbd> value. To extract the <kbd>tail</kbd> value, we use the <kbd>drop</kbd> method and convert its result to an <kbd>IntArray</kbd> value. But we can't directly pass any array as <kbd>vararg</kbd>; therefore, we must use the spread (<kbd>*</kbd>) operator to pass each member of an array individually. </p>
<p>Now, we can create our <kbd>FunList&lt;Int&gt;</kbd> value:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val numbers = intListOf(1, 2, 3, 4)    <br/>}</pre>
<p>Let's implement <kbd>forEach </kbd> as follows:</p>
<pre>sealed class FunList&lt;out T&gt; {<br/>   object Nil : FunList&lt;Nothing&gt;()<br/><br/>   data class Cons&lt;out T&gt;(val head: T, val tail: FunList&lt;T&gt;) : FunList&lt;T&gt;()<br/><br/>   fun forEach(f: (T) -&gt; Unit) {<br/>      tailrec fun go(list: FunList&lt;T&gt;, f: (T) -&gt; Unit) {<br/>         when (list) {<br/>            is Cons -&gt; {<br/>               f(list.head)<br/>               go(list.tail, f)<br/>            }<br/>            is Nil -&gt; Unit//Do nothing<br/>         }<br/>      }<br/><br/>      go(this, f)<br/>   }<br/><br/>}</pre>
<p>The <kbd>forEach</kbd> implementation is similar to our examples of Factorial and Fibonacci functions in the recursion section, including <kbd>tailrec</kbd>.</p>
<p><kbd>FunList</kbd> is, technically, an <strong>Algebraic Data Type</strong> (<strong>ADT</strong>). <kbd>FunList</kbd> can be either a <kbd>Nil</kbd> or <kbd>Cons</kbd> and nothing else. Kotlin's compiler can use this information to check that both values are evaluated when a <kbd>FunList</kbd> type is used as the argument in a <kbd>when</kbd> control structure:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val numbers = intListOf(1, 2, 3, 4)<br/>    <br/>    numbers.forEach { i -&gt; println("i = $i") }<br/>}</pre>
<p>Implementing <kbd>fold</kbd> will be similar to the following code:</p>
<pre>sealed class FunList&lt;out T&gt; {<br/>   <br/>  /*Previous code here*/<br/><br/>   fun &lt;R&gt; fold(init: R, f: (R, T) -&gt; R): R {<br/>      tailrec fun go(list: FunList&lt;T&gt;, init: R, f: (R, T) -&gt; R): R = when (list) {<br/>         is Cons -&gt; go(list.tail, f(init, list.head), f)<br/>         is Nil -&gt; init<br/>      }<br/><br/>      return go(this, init, f)<br/>   }<br/>}<br/></pre>
<p>Did you notice that these functions are very easy to implement? Let's have a look at the following code:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val numbers = intListOf(1, 2, 3, 4)<br/>    <br/>    val sum = numbers.fold(0) { acc, i -&gt; acc + i}<br/>}</pre>
<p>What about a little contest between Kotlin's list and our functional list?</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val funList = intListOf(1, 2, 3, 4)<br/>    val list = listOf(1, 2, 3, 4)<br/><br/>    println("fold on funList : ${executionTime { funList.fold(0) { acc, i -&gt; acc + i } }}")<br/>    println("fold on list : ${executionTime { list.fold(0) { acc, i -&gt; acc + i } }}")<br/>}</pre>
<p>The output will look something like the following screenshot:</p>
<div><img height="39" width="183" src="img/dd6c4ae9-a493-4e7b-89e5-4ecda3ad2cba.png"/></div>
<p>Ouch! Our implementation is 10 times slower. No worries, Kotlin's implementation is a heavily optimized imperative solution and ours is just to learn and have fun (pun intended).</p>
<p>What about <kbd>map</kbd>? To implement <kbd>map</kbd> in a functional way we need to implement other functions first. Let's start with <kbd>reverse</kbd>.</p>
<p><kbd>reverse</kbd> is a function that returns a list in reverse order:</p>
<pre>sealed class FunList&lt;out T&gt; {<br/><br/>    /*previous code*/<br/><br/>    fun reverse(): FunList&lt;T&gt; = fold(Nil as FunList&lt;T&gt;) { acc, i -&gt; Cons(i, acc) }<br/>}<br/></pre>
<p>We can reuse <kbd>fold</kbd> and build a new <kbd>Cons</kbd> value in each iteration, using the <kbd>acc</kbd> value as <kbd>tail</kbd>. This is one of the big advantages of functional programming—reusing existing functions.</p>
<p>Now, we can implement <kbd>foldRight</kbd>:</p>
<pre>sealed class FunList&lt;out T&gt; {<br/><br/>    /*previous code*/<br/><br/>  fun &lt;R&gt; foldRight(init: R, f: (R, T) -&gt; R): R {<br/>   return this.reverse().fold(init, f)<br/>  }<br/>}</pre>
<p>Again, we are reusing existing functions. It is time to implement our <kbd>map</kbd> function. At this point, it is not surprising that we'll reuse our existing functions:</p>
<pre>sealed class FunList&lt;out T&gt; {<br/><br/> /*previous code*<br/><br/> fun &lt;R&gt; map(f:(T) -&gt; R): FunList&lt;R&gt; {<br/>   return foldRight(Nil as FunList&lt;R&gt;){ tail, head -&gt; Cons(f(head), tail) }<br/> }<br/>}</pre>
<p><kbd>foldRight</kbd> is all that we need. As you can see, we can implement a complete list using functions and other basic concepts as building blocks. And that is all about functional programming.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered the basics of functional programming, including high-order functions, pure functions, recursion functions, and lazy evaluation. We also covered functional collections and we implemented a functional collection, using a functional programming style.</p>
<p>In the next chapter, we'll cover a foundational stone of functional programming—immutability.</p>


            

            
        
    </body></html>