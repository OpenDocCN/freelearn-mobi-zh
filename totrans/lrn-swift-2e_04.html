<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. To Be or Not To Be – Optionals</h1></div></div></div><p>As we discussed in <a class="link" href="ch02.html" title="Chapter 2. Building Blocks – Variables, Collections, and Flow Control">Chapter 2</a>, <em>Building Blocks – Variables, Collections, and Flow Control</em>, all variables and constants must always have a value before they are used. This is a great safety feature because it prevents you from creating a scenario where you forget to give a variable an initial value. It may make sense for some number variables, such as the number of sandwiches ordered to start at zero, but it doesn't make sense for all variables. For example, the number of bowling pins standing should start at 10, not zero. In Swift, the compiler forces you to decide what the variable should start at, instead of providing a default value that could be incorrect.</p><p>However, there are other scenarios where you will have to represent the complete absence of a value. A great example is if you have a dictionary of word definitions and you try to lookup a word that isn't in the dictionary. Normally, this will return a String, so you could potentially return an empty String, but what if you also need to represent the idea that a word exists without a definition? Also, for another programmer who is using your dictionary, it will not be immediately obvious what will happen when they look up a word that doesn't exist. To satisfy this need to represent the absence of a value, Swift has a special type called <a class="indexterm" id="id200"/>an <strong>optional</strong>.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining an optional</li><li class="listitem" style="list-style-type: disc">Unwrapping an optional</li><li class="listitem" style="list-style-type: disc">Optional chaining</li><li class="listitem" style="list-style-type: disc">Implicitly unwrapped optionals</li><li class="listitem" style="list-style-type: disc">Debugging optionals</li><li class="listitem" style="list-style-type: disc">The underlying implementation</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Defining an optional</h1></div></div></div><p>So we <a class="indexterm" id="id201"/>know that the purpose of optionals in Swift is to allow the representation of the absence of a value, but what does that look like and how does it work? An optional is a special type that can "wrap" any other type. This means that you can make an optional <code class="literal">String</code>, optional <code class="literal">Array</code>, and so on. You can do this by adding a question mark (<code class="literal">?</code>) to the type name, as shown:</p><div><pre class="programlisting">var possibleString: String?
var possibleArray: [Int]?</pre></div><p>Note that <a class="indexterm" id="id202"/>this code does not specify any initial values. This is because all optionals, by default, are set to no value at all. If we want to provide an initial value we can do so similar to any other variable:</p><div><pre class="programlisting">var possibleInt: Int? = 10</pre></div><p>Also, note that if we left out the type specification (<code class="literal">: Int?</code>), <code class="literal">possibleInt</code> would be inferred to be of type <code class="literal">Int</code> instead of an optional <code class="literal">Int</code>.</p><p>Now, it is pretty verbose to say that a variable lacks a value. Instead, if an optional lacks a variable, we say it is nil. So both <code class="literal">possibleString</code> and <code class="literal">possibleArray</code> are nil, while <code class="literal">possibleInt</code> is <code class="literal">10</code>. However, <code class="literal">possibleInt</code> is not truly <code class="literal">10</code>. It is still wrapped in an optional.</p><p>You can see all the forms a variable can take by putting the following code into a playground:</p><div><pre class="programlisting">var actualInt = 10
var possibleInt: Int? = 10
var nilInt: Int?
print(actualInt) // 10
print(possibleInt) // Optional(10)
print(nilInt) // nil</pre></div><p>As you can see, <code class="literal">actualInt</code> prints out just as we expected, but <code class="literal">possibleInt</code> prints out as an optional that contains the value <code class="literal">10</code> instead of just <code class="literal">10</code>. This is a very important distinction because an optional cannot be used as the value it is wrapping. <code class="literal">nilInt</code> just reports that it is nil. At any point, you can update the value within an optional; this includes assigning it a value for the first time, using the assignment operator (<code class="literal">=</code>):</p><div><pre class="programlisting">nilInt = 2
print(nilInt) // Optional(2)</pre></div><p>You can even remove the value within an optional by assigning it to <code class="literal">nil</code>:</p><div><pre class="programlisting">nilInt = nil
print(nilInt) // nil</pre></div><p>So we have this wrapped form of a variable that may or may not contain a value. What do we do if we need to access the value within an optional? The answer is that we must unwrap it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Unwrapping an optional</h1></div></div></div><p>There are <a class="indexterm" id="id203"/>multiple ways to unwrap an optional. All of them essentially assert that there is truly a value within the optional. This is a wonderful safety feature of Swift. The compiler forces you to consider the possibility that an optional lacks any value at all. In other languages, this is a very commonly overlooked scenario that can cause obscure bugs.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Optional binding</h2></div></div></div><p>The <a class="indexterm" id="id204"/>safest way to unwrap an optional is to use something called <strong>optional binding</strong>. With this technique, you can assign a temporary constant or variable to the value contained within the optional. This process is contained within an <code class="literal">if</code> statement, so that you can use an else statement when there is no value. Optional binding looks similar to the following code:</p><div><pre class="programlisting">if let string = possibleString {
    print("possibleString has a value: \(string)")
}
else {
    print("possibleString has no value")
}</pre></div><p>An optional binding is distinguished from an <code class="literal">if</code> statement primarily by the <code class="literal">if let</code> syntax. Semantically, this code is saying, "if you can let the constant <code class="literal">string</code> be equal to the value within <code class="literal">possibleString</code>, print out its value; otherwise, print that it has no value." The primary purpose of an optional binding is to create a temporary constant that is the normal (non-optional) version of the optional.</p><p>We can also use a temporary variable in an optional binding:</p><div><pre class="programlisting">possibleInt = 10
if var actualInt = possibleInt {
    actualInt *= 2
    print(actualInt) // 20
}
print(possibleInt) // Optional(10)</pre></div><p>Note that an asterisk (<code class="literal">*</code>) is used for multiplication in Swift. You should also notice something important about this code. If you put it into a playground, even though we multiplied the <code class="literal">actualInt</code> by <code class="literal">2</code>, the value within the optional does not change. When we print out <code class="literal">possibleInt</code> later, the value is still <code class="literal">Optional(10)</code>. This is because even though we made <code class="literal">actualInt</code> a variable (otherwise known as mutable), it is simply a temporary copy of the value within <code class="literal">possibleInt</code>. No matter what we do with <code class="literal">actualInt</code>, nothing will get changed about the value within <code class="literal">possibleInt</code>. If we have to update the actual value stored within <code class="literal">possibleInt</code>, we simply assign <code class="literal">possibleInt</code> to <code class="literal">actualInt</code> after we are done modifying it:</p><div><pre class="programlisting">possibleInt = 10
if var actualInt = possibleInt {
   actualInt *= 2
   possibleInt = actualInt
}
print(possibleInt) // Optional(20)</pre></div><p>Now, the <a class="indexterm" id="id205"/>value wrapped inside <code class="literal">possibleInt</code> has actually been updated.</p><p>A common scenario that you will probably come across is the need to unwrap multiple optional values. One option is to simply nest the optional bindings:</p><div><pre class="programlisting">if let actualString = possibleString {
    if let actualArray = possibleArray {
        if let actualInt = possibleInt {
            print(actualString)
            print(actualArray)
            print(actualInt)
        }
    }
}</pre></div><p>However, this can be a pain, as it increases the indentation level each time to keep the code organized. Instead, you can actually list multiple optional bindings into a single statement separated by commas:</p><div><pre class="programlisting">if let actualString = possibleString,
    let actualArray = possibleArray,
    let actualInt = possibleInt
{
    print(actualString)
    print(actualArray)
    print(actualInt)
}</pre></div><p>This generally produces more readable code.</p><p>Another great way to do a concise optional binding within functions is to use the guard statement. This way, you can do a series of unwrapping without increasing the indent level of the code at all:</p><div><pre class="programlisting">func someFunc2() {
    guard let actualString = possibleString,
        let actualArray = possibleArray,
        let actualInt = possibleInt
    else {
        return
    }

    print(actualString)
    print(actualArray)
    print(actualInt)
}</pre></div><p>This <a class="indexterm" id="id206"/>construct allows us to access the unwrapped values after the guard statement, because the guard statement guarantees that we would have exited the function before reaching that code, if the optional value was nil.</p><p>This way of unwrapping is great, but saying that optional binding is the safest way to access the value within an optional, implies that there is an unsafe way to unwrap an optional. This way is called<a class="indexterm" id="id207"/> <strong>forced unwrapping</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Forced unwrapping</h2></div></div></div><p>The <a class="indexterm" id="id208"/>shortest way to unwrap an optional is to use forced unwrapping. It is done using an exclamation mark (<code class="literal">!</code>) after the variable name when being used:</p><div><pre class="programlisting">possibleInt = 10
possibleInt! *= 2
print(possibleInt) // "Optional(20)"</pre></div><p>However, the reason it is considered unsafe is that your entire program will crash if you try to unwrap an optional that is currently nil:</p><div><pre class="programlisting">nilInt! *= 2 // fatal error</pre></div><p>The complete error you get is <strong>unexpectedly found nil while unwrapping an optional value</strong>. This is because the forced unwrapping is essentially your personal guarantee that the optional truly does hold a value. That is why it is called "forced".</p><p>Therefore, forced unwrapping should be used in limited circumstances. It should never be used just to shorten up the code. Instead, it should only be used when you can guarantee from the structure of the code that it cannot be nil, even though it is defined as an optional. Even in that case, you should see if it is possible to use a non-optional variable instead. The only other place you may use it is if your program truly could not recover from an optional being nil. In those circumstances, you should at least consider presenting an error to the user, which is always better than simply having your program crash.</p><p>An example of a scenario where it may be used effectively is with lazily calculated values. A lazily calculated value is the one that is not created until the first time it is accessed. To illustrate this, let's consider a hypothetical class that represents a file system directory. It will have a property listing its contents that is lazily calculated. The code will look similar to the following code:</p><div><pre class="programlisting">class FileSystemItem {}
class File: FileSystemItem {}
class Directory: FileSystemItem {
    private var realContents: [FileSystemItem]?
    var contents: [FileSystemItem] {
        if self.realContents == nil {
            self.realContents = self.loadContents()
        }
        return self.realContents!
    }

    private func loadContents() -&gt; [FileSystemItem] {
        // Do some loading
        return []
    }
}</pre></div><p>Here, we <a class="indexterm" id="id209"/>have defined a superclass called <code class="literal">FileSystemItem</code> that both <code class="literal">File</code> and <code class="literal">Directory</code> inherit from. The content of a directory is a list of <code class="literal">FileSystemItem</code>. We define <code class="literal">contents</code> as a calculated variable and store the real <a class="indexterm" id="id210"/>value within the <code class="literal">realContents</code> property. The calculated property checks if there is a value loaded for <code class="literal">realContents</code>; if there isn't, it loads the contents and puts them into the <code class="literal">realContents</code> property. Based on this logic, we know for 100% certainty that there will be a value within <code class="literal">realContents</code> by the time we get to the return statement, so it is perfectly safe to use forced unwrapping.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Nil coalescing</h2></div></div></div><p>In addition<a class="indexterm" id="id211"/> to optional binding and forced unwrapping, Swift also provides an operator called the <a class="indexterm" id="id212"/>
<strong>nil coalescing operator </strong>to unwrap an optional. This is represented by a double question mark (<code class="literal">??</code>). Basically, this operator lets us provide a default value for a variable or operation result, in case it is nil. This is a safe way to turn an optional value into a non-optional value and it would look similar to the following code:</p><div><pre class="programlisting">var possibleString: String? = "An actual string"
print(possibleString ?? "Default String") // "An Actual String"</pre></div><p>Here, we are asking the program to print out <code class="literal">possibleString</code> unless it is nil; in which case, it will just print <code class="literal">"Default String"</code>. Since we did give it a value, it printed out that value and it is important to note that it printed out as a regular variable, not an optional. This is because one way or another, an actual value was going to be printed.</p><p>This is a great tool for concisely and safely unwrapping an optional when a default value makes sense.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Optional chaining</h1></div></div></div><p>A <a class="indexterm" id="id213"/>common scenario in Swift is to have an optional that you must calculate something from. If the optional has a value, you will want to store the result of the calculation on it, but if it is nil, the result should just be set to nil:</p><div><pre class="programlisting">var invitee: String? = "Sarah"
var uppercaseInvitee: String?
if let actualInvitee = invitee {
    uppercaseInvitee = actualInvitee.uppercaseString
}</pre></div><p>This is pretty verbose. To shorten this up in an unsafe way, we could use forced unwrapping:</p><div><pre class="programlisting">uppercaseInvitee = invitee!.uppercaseString</pre></div><p>However, optional chaining will allow us to do this safely. Essentially, it allows optional operations on an optional. When the operation is called, if the optional is nil, it immediately returns nil; otherwise, it returns the result of performing the operation on the value within the optional:</p><div><pre class="programlisting">uppercaseInvitee = invitee?.uppercaseString</pre></div><p>So in this call, <code class="literal">invitee</code> is an optional. Instead of unwrapping it, we use optional chaining by placing a question mark (<code class="literal">?</code>) after it, followed by the optional operation. In this case, we are asking for the <code class="literal">uppercaseInvitee</code> property on it. If <code class="literal">invitee</code> is nil, <code class="literal">uppercaseInvitee</code> is immediately set to nil without even trying to access <code class="literal">uppercaseString</code>. If it actually does contain a value, <code class="literal">uppercaseInvitee</code> gets set to the <code class="literal">uppercaseString</code> property of the contained value. Note that all optional chains return an optional result.</p><p>You can chain as many calls as you want, both optional and non-optional, together in this way:</p><div><pre class="programlisting">var invitees: [String]? = ["Sarah", "Jamison", "Marcos", "Roana"]
invitees?.first?.uppercaseString.hasPrefix("A")</pre></div><p>This code checks if the first element of the invitees-list starts with the letter <code class="literal">A</code>, even if it is a lowercase <code class="literal">A</code>. First, it uses an optional chain in case <code class="literal">invitees</code> is nil. Then the call to <code class="literal">first</code> uses an additional optional chain because that method returns an optional <code class="literal">String</code>. We then call <code class="literal">uppercaseString</code>, which does not return an optional, allowing us to access <code class="literal">hasPrefix</code> on the result without having to use another optional chain. If at any point any of the optionals are nil, the result will be nil. This can happen for two different reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">invitees is <code class="literal">nil</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">first</code> returns <code class="literal">nil</code> because the array is empty</li></ul></div><p>If the <a class="indexterm" id="id214"/>chain makes it all the way to <code class="literal">uppercaseString</code>, there is no longer a failure path and it will definitely return an actual value. You will notice that there are exactly two question marks being used in this chain and there are two possible failure reasons.</p><p>At first, it can be hard to understand when you should and should not use a question mark to create a chain of calls; the rule is to always use a question mark if the previous element in the chain returns an optional. However, so you are prepared, let's take a look at what happens if you use an optional chain improperly:</p><div><pre class="programlisting">invitees.first // Error</pre></div><p>In this case, we try to call a method directly on an optional without a chain, so we get an error that says <strong>Value of optional type '[String]?' not unwrapped; did you mean to use '!' or '?'?</strong>. Not only does it tell us that the value is not unwrapped, it even suggests two common ways of dealing with the problem: forced unwrapping or optional chaining.</p><p>We also have the case where we try to use an optional chain inappropriately:</p><div><pre class="programlisting">var otherInvitees = ["Kai", "Naya"]
otherInvitees?.first // Error</pre></div><p>Here, we get an error that says <strong>Cannot use optional chaining on non-optional value of type '[String]'</strong>. It is great to have a good sense of the errors you might see when you make mistakes; so that you can correct them quickly because we all make silly mistakes from time-to-time.</p><p>Another great feature of optional chaining is that it can be used for method calls on an optional that does not actually return a value:</p><div><pre class="programlisting">invitees?.removeAll()</pre></div><p>In this case, we only want to call <code class="literal">removeAll</code> if there is truly a value within the optional array. So with this code, if there is a value, all the elements are removed from it; otherwise, it remains nil.</p><p>In the end, option chaining is a great choice for writing a concise code that still remains expressive and understandable.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Implicitly unwrapped optionals</h1></div></div></div><p>There <a class="indexterm" id="id215"/>is a second type of optional called an <strong>implicitly unwrapped optional</strong>. There are really two ways to look at what an implicitly unwrapped optional is; one way is to say that it is a normal variable that can also be nil; the other way is to say that it is an optional that you don't have to unwrap to use. The important thing to understand about them is that, similar to optionals, they can be nil, but you do not have to unwrap them like a normal variable.</p><p>You can <a class="indexterm" id="id216"/>define an implicitly unwrapped optional with an exclamation mark (<code class="literal">!</code>) instead of a question mark (<code class="literal">?</code>) after the type name:</p><div><pre class="programlisting">var name: String!</pre></div><p>Similar to regular optionals, implicitly unwrapped optionals do not need to be given an initial value because they are nil by default.</p><p>At first it may sound like it is the best of both worlds, but in reality it is more like the worst of both worlds. Even though an implicitly unwrapped optional does not have to be unwrapped, it will crash your entire program if it is nil when used:</p><div><pre class="programlisting">name.uppercaseString // Crash</pre></div><p>A great way to think about them is that every time it is used, it is implicitly doing a forced unwrapping. The exclamation mark is placed in its type declaration, instead of each time it is used. This can be problematic because it appears the same as any other variable except for how it is declared. That means it is very unsafe to use, unlike a normal optional.</p><p>So if the implicitly unwrapped optionals are the worst of both worlds and are so unsafe, why do they even exist? The reality is that in rare circumstances, they are necessary. They are used in circumstances where a variable is not truly optional, but you also cannot give an initial value to it. This is almost always the case for custom types that have a member variable that is non-optional but cannot be set during initialization.</p><p>A rare example of this is with a view in iOS. UIKit, as we discussed before, is the framework Apple provides for iOS development. In it, Apple has a class called <code class="literal">UIView</code> that is used to display content on the screen. Apple also provides a tool in Xcode called Interface Builder that lets you design these views in a visual editor instead of in code. Many views designed in this way will need references to other views that can be accessed later, programmatically. When one of these views is loaded, it is initialized without anything connected and then all the connections are made. Once all of the connections are made, a function called <code class="literal">awakeFromNib</code> is called on the view. This means that these connections are not available to be used during initialization but are available once <code class="literal">awakeFromNib</code> is called. This order of operations also ensures that <code class="literal">awakeFromNib</code> is always called before anything actually uses the view. This is a circumstance where it is necessary to use an implicitly unwrapped optional. A member variable may not be able to be defined until after the view is initialized, when it is completely loaded:</p><div><pre class="programlisting">Import UIKit
class MyView: UIView {
    @IBOutlet var button: UIButton!
    var buttonOriginalWidth: CGFloat!

    override func awakeFromNib() {
        self.buttonOriginalWidth = self.button.frame.size.width
    }
}</pre></div><p>Notice that <a class="indexterm" id="id217"/>we have actually declared two implicitly unwrapped optionals. The first is a connection to a button. We know that this is a connection because it is preceded by <code class="literal">@IBOutlet</code>. This is declared as an implicitly unwrapped optional because connections are not set up until after initialization, but they are still guaranteed to be set up before any other methods are called on the view.</p><p>This then leads us to unwrapping our second variable, <code class="literal">buttonOriginalWidth</code>, implicitly because we need to wait until the connection is made before we can determine the width of the button. After <code class="literal">awakeFromNib</code> is called, it is safe to treat both <code class="literal">button</code> and <code class="literal">buttonOriginalWidth</code> as non-optional.</p><p>You may have noticed that we had to dive pretty deep into app development to find a valid use case for implicitly unwrapped optionals and this is arguably only because UIKit is implemented in Objective-C, as we will learn more about in <a class="link" href="ch10.html" title="Chapter 10. Harnessing the Past – Understanding and Translating Objective-C">Chapter 10</a>, <em>Harnessing the Past – Understanding and Translating Objective-C</em>. This is another testament to the fact that they should be used sparingly.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Debugging optionals</h1></div></div></div><p>We have <a class="indexterm" id="id218"/>already seen a couple of the compiler errors we will commonly see because of optionals. If we try to call a method on an optional that we intended to call on the wrapped value, we will get an error. If we try to unwrap a value that is not actually optional, we will also get an error. We also need to be prepared for the runtime errors that optionals can cause.</p><p>As we have discussed, optionals cause runtime errors that are also referred to as crashes, if you try to forcefully unwrap one that is nil. This can happen with both explicit and implicitly forced unwrapping. If you have followed my advice so far in this chapter, this should be a rare occurrence. However, we all end up working with a third party code and maybe they were lazy or maybe they use forced unwrapping to enforce their expectations about how their code should be used.</p><p>Also, we all suffer from being lazy from time to time. It can be exhausting or discouraging to worry about all the edge cases when you are excited about programming the core functionality of your app. We may use forced unwrapping temporarily while we worry about that main functionality and plan to come back to handle it later. After all, during development it is better to have a forced unwrapping crash the development version of your app than it is for it to fail silently if you have not yet handled that edge case. We may even decide that an edge case is not worth the development effort of handling because everything about developing an app is a trade off. Either way, we need to recognize a crash from forced unwrapping quickly so we don't waste extra time trying to figure out what went wrong.</p><p>When an <a class="indexterm" id="id219"/>app tries to unwrap a nil value, if you are currently debugging the app, Xcode will show you the line that is trying to do the unwrapping. The line will report that there was an <strong>EXC_BAD_INSTRUCTION</strong> error and you will also get a message in the console saying <strong>fatal error: unexpectedly found nil while unwrapping an Optional value</strong>:</p><div><img alt="Debugging optionals" src="img/B05103_04_01.jpg"/></div><p>You will also sometimes have to look at what code is currently calling the code that failed. To do that, you can use the call stack in Xcode. The call stack is the full path of all function calls that got to this location. So, if you have <code class="literal">function1</code> call <code class="literal">function2</code>, which then calls <code class="literal">function3</code>, <code class="literal">function3</code> will be at the top and <code class="literal">function1</code> will be at the bottom. Once the execution exits <code class="literal">function3</code>, it will be removed from the stack so you will just have <code class="literal">function2</code> on top of <code class="literal">function1</code>.</p><p>When your program crashes, Xcode will automatically display the call stack, but you can also manually show it by navigating to <strong>View</strong> | <strong>Navigators</strong> | <strong>Show Debug Navigator</strong>. It will look similar to the following screenshot:</p><div><img alt="Debugging optionals" src="img/B05103_04_02.jpg"/></div><p>Here, you <a class="indexterm" id="id220"/>can click around different levels of code to see the state of things. This will become even more important if the program is crashing within one of Apple's framework, where you do not have access to the code. In that case, you will want to move up the call stack to the point where your code called into the framework. You may also be able to look at the names of the functions to help you figure out what may have gone wrong.</p><p>Anywhere on the call stack, you can look at the state of the variables in the debugger, as shown:</p><div><img alt="Debugging optionals" src="img/B05103_04_03.jpg"/></div><p>If you do not see this variable's view, you can display it by clicking on the button in the bottom-right corner of the screen, second from the right that will be grayed out. Here, you can see that <code class="literal">invitee</code> is indeed nil, which is what caused the crash.</p><p>As powerful as <a class="indexterm" id="id221"/>the debugger is, if you find that it isn't helping you find the problem, you can always put <code class="literal">print</code> statements in important parts of the code. It is always safe to print out an optional, as long as you don't forcefully unwrap it as shown in the preceding example. As we have seen before, when an optional is printed, it will print <strong>nil</strong> if it doesn't have a value, or it will print <strong>Optional(&lt;value&gt;)</strong> if it has a value.</p><p>Debugging is an extremely important part of becoming a productive developer because we all make mistakes and create bugs. Being a great developer means that you can identify problems quickly and understand how to fix them soon after that. This will largely come from practice, but it will also come from having a firm grasp of what is really happening with your code versus simply adapting some code you find online to fit your needs through trial and error.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>The underlying implementation</h1></div></div></div><p>At this <a class="indexterm" id="id222"/>point, you should have a pretty strong grasp of what an optional is and how to use and debug it, but it will be valuable to look a little deeper at optionals to see how they actually work.</p><p>In reality, the question mark syntax for optionals is just special shorthand. Writing <code class="literal">String?</code> is equivalent to writing <code class="literal">Optional&lt;String&gt;</code>. Writing <code class="literal">String!</code> is equivalent to writing <code class="literal">ImplicitlyUnwrappedOptional&lt;String&gt;</code>. The Swift compiler has the shorthand versions because they are so commonly used. This allows the code to be more concise and readable.</p><p>If you declare an optional using the long form, you can see Swift's implementation by holding <em>Command</em> and clicking on the word <strong>Optional</strong>. Here, you can see that <code class="literal">Optional</code> is implemented as an enumeration. Simplifying the code a little, we have:</p><div><pre class="programlisting">enum Optional&lt;T&gt; {
    case None
    case Some(T)
}</pre></div><p>So we can see that an optional really has two cases: <code class="literal">None</code> and <code class="literal">Some</code>. <code class="literal">None</code> stands for the nil case, while the <code class="literal">Some</code> case has an associated value, which is the value wrapped inside the optional. Unwrapping is the process of retrieving the associated value out of the <code class="literal">Some</code> case.</p><p>The one part of this that you have not seen yet is the angled bracket syntax (<code class="literal">&lt;T&gt;</code>). This is called a <strong>generic</strong> and<a class="indexterm" id="id223"/> it essentially allows the enumeration to have an associated value of any type. We will cover generics in-depth in <a class="link" href="ch06.html" title="Chapter 6. Make Swift Work For You – Protocols and Generics">Chapter 6</a>, <em>Make Swift Work For You – Protocols and Generics</em>.</p><p>Realizing that optionals are simply enumerations will help you understand how to use them. It also gives you some insight into how concepts are built on top of other concepts. Optionals seem <a class="indexterm" id="id224"/>really complex until you realize that they are just a two case enumeration. Once you understand enumerations, you can pretty easily understand optionals as well.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Summary</h1></div></div></div><p>We have only covered a single concept, optionals, in this chapter, but we have seen that this is a pretty dense topic. We have seen that at the surface level, optionals are pretty straightforward. They are a way to represent a variable that has no value. However, there are multiple ways to get access to the value wrapped within an optional that have very specific use cases. Optional binding is always preferred, as it is the safest method, but we can also use forced unwrapping if we are confident that an optional is not nil. We also have a type called implicitly unwrapped optional, to delay the assigning of a variable that is not intended to be optional; however, we should use it sparingly because there is almost always a better alternative.</p><p>Now that we have a firm understanding of optionals, we can begin to look at something else that may appear minor on the surface but actually opens up a whole world of possibilities. All functions in Swift are actually variables or constants themselves. We will explore what this means in the next chapter.</p></div></body></html>