- en: Chapter 1. Exploring Swift's Power and Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 探索 Swift 的功能和性能
- en: In the 2014, Apple released a new programming language, called Swift. Swift
    has been designed from scratch with many powerful features. It is statically typed
    and very safe. It has a clean and nice syntax, it's fast, it's flexible, and it
    has many other advantages that you will learn later in the book. Swift seems to
    be very powerful and it has big potential. Apple has set big expectations for
    Swift, and their main goal for Swift is that it should be a replacement for Objective-C,
    which is going to happen in the near future.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2014 年，苹果发布了一种新的编程语言，名为 Swift。Swift 是从头开始设计的，具有许多强大的功能。它是静态类型的，非常安全。它拥有简洁且优美的语法，运行速度快，灵活，并且还有许多其他优点，你将在本书后面的章节中了解到。Swift
    看起来非常强大，具有巨大的潜力。苹果对 Swift 设定了很高的期望，他们的主要目标是让 Swift 成为 Objective-C 的替代品，这将在不久的将来实现。
- en: In this chapter, you will become familiar with the Swift programming language,
    what it was made for, and what its advantages and features are. We will also make
    our first Swift application and see how easy it is to integrate with existing
    Objective-C code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将熟悉 Swift 编程语言，了解它是为什么而设计的，以及它的优势和功能。我们还将制作我们的第一个 Swift 应用程序，并看看它如何容易地与现有的
    Objective-C 代码集成。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Welcome to Swift
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎来到 Swift
- en: Writing swift code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Swift 代码
- en: Swift interoperability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 互操作性
- en: The importance of performance and performance key metrics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和性能关键指标的重要性
- en: Swift speed
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 极速
- en: I can guess you opened this book because you are interested in speed and are
    probably wondering, "How fast can Swift be?" Before you even start learning Swift
    and discovering all the good things about it, let's answer it right here and right
    now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以猜到你打开这本书是因为你对速度感兴趣，可能正在想，“Swift 能有多快？”在你开始学习 Swift 并发现它的所有优点之前，让我们在这里立即回答这个问题。
- en: Let's take an array of 100,000 random numbers; sort it in Swift, Objective-C,
    and C using the standard `sort` function from `stdlib` (`sort` in Swift, `qsort`
    in C, and `compare` in Objective-C); and measure how much time each would take.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个包含 100,000 个随机数的数组为例；使用 `stdlib` 中的标准 `sort` 函数（在 Swift 中是 `sort`，在 C
    中是 `qsort`，在 Objective-C 中是 `compare`）在 Swift、Objective-C 和 C 中对其进行排序，并测量每个操作所需的时间。
- en: 'Sorting an array with 100,000 integer elements gives us this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对包含 100,000 个整数元素的数组进行排序，我们得到以下结果：
- en: '| Technology | Time taken |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 技术 | 耗时 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Swift | 0.00600 sec |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Swift | 0.00600 秒 |'
- en: '| C | 0.01396 sec |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| C | 0.01396 秒 |'
- en: '| Objective-C | 0.08705 sec |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Objective-C | 0.08705 秒 |'
- en: And the winner is, Swift! Swift is **14.5** times faster than Objective-C and
    **2.3** times faster than C.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 而赢家是，Swift！Swift 比 Objective-C 快 **14.5** 倍，比 C 快 **2.3** 倍。
- en: In other examples and experiments, C is usually faster than Swift and Swift
    is way faster than Objective-C. These measurements were done with Xcode 7.0 beta
    6 and Swift 2.0\. It's important to highlight that the improvements in Swift 2.0
    were mainly focused on making it cleaner, more powerful, safer, and more stable,
    and preparing it for open sourcing. Swift's performance hasn't reached its full
    potential yet, and the future is so exciting!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他示例和实验中，C 通常比 Swift 快，而 Swift 比 Objective-C 快得多。这些测量是在 Xcode 7.0 beta 6 和
    Swift 2.0 下进行的。重要的是要强调，Swift 2.0 的改进主要集中在使其更简洁、更强大、更安全、更稳定，并为开源做准备。Swift 的性能尚未达到其全部潜力，未来非常令人兴奋！
- en: Welcome to Swift
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到 Swift
- en: The Swift programming language has been designed by Apple from the ground up.
    It was released with the slogan *Objective-C without the C*. The meaning of this
    phrase is that Swift doesn't have any limitation of backward compatibilities.
    It's totally new and with no old baggage. Before you start learning all the power
    of Swift, I think it would be useful to answer a few questions about why should
    you learn it, and if you have any doubts about that, I should dispel them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 编程语言是由苹果从头开始设计的。它的口号是“没有 C 的 Objective-C”。这个短语的意思是 Swift 没有任何向后兼容性的限制。它是全新的，没有任何旧的重负。在你开始学习
    Swift 的全部力量之前，我认为回答一些关于为什么你应该学习它的问题会有所帮助，如果你对此有任何疑问，我应该消除它们。
- en: Why should I learn Swift?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我应该学习 Swift？
- en: 'Swift is a very new programming language but it has become very popular and
    has gained huge traction. However, many iOS and OS X developers ask these questions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种非常新的编程语言，但它已经变得非常流行，并获得了巨大的关注。然而，许多 iOS 和 OS X 开发者提出了这些问题：
- en: Should I learn Swift?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该学习 Swift 吗？
- en: What should I learn, Swift or Objective-C?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该学习 Swift 还是 Objective-C？
- en: Is Objective-C going to stay or die?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C 会继续存在还是消亡？
- en: Is Swift ready for production apps?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 是否准备好用于生产应用程序？
- en: Is Swift faster than Objective-C or C?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 比 Objective-C 或 C 快吗？
- en: What applications can I write using Swift?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以用 Swift 编写哪些应用程序？
- en: My answer is, "Yes. Definitely!" You should learn Swift. It doesn't matter whether
    you are a new iOS and OS X developer or you have some Objective-C background;
    you should definitely learn Swift.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我的回答是，“是的，绝对！”你应该学习 Swift。无论你是新的 iOS 和 OS X 开发者，还是有一些 Objective-C 的背景，你都应该学习
    Swift。
- en: If you are new developer, then it's really useful to start with Swift, because
    you will learn programming basics and techniques in Swift, and further Swift learning
    would be much easier. Although it would definitely useful to learn Objective-C
    as well, I would recommend learning Swift first so that you build your programming
    mindset on Swift.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名新开发者，那么从 Swift 开始是非常有用的，因为你在 Swift 中将学习编程基础和技术，进一步学习 Swift 会更容易。尽管学习 Objective-C
    也绝对有用，但我建议先学习 Swift，这样你就可以在 Swift 上建立你的编程思维。
- en: If you already have some experience in Objective-C, then you should try Swift
    as soon as possible. It will not only give you the knowledge of a new programming
    language, but also open the door to new ideas and ways of solving problems in
    Objective-C. We can see that Objective-C has started evolving right now because
    of Swift.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一些 Objective-C 的经验，那么你应该尽快尝试 Swift。它不仅会给你带来一门新编程语言的知识，还会打开在 Objective-C
    中解决问题的新思路和方法。我们可以看到，由于 Swift 的出现，Objective-C 已经开始进化。
- en: Objective-C has many limitations because of its backward capabilities with C.
    It was created 23 years ago, in 1983, but it will die much sooner than Swift.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与 C 的向后兼容性，Objective-C 有很多限制。它是在 23 年前，即 1983 年创建的，但它会比 Swift 更早消亡。
- en: After the release of Swift version 1.0, in only a year's time we have seen many
    Swift applications successfully developed and released on the App Store. In this
    time period, many Swift tools and open source libraries that increase development
    productivity have been created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 1.0 版本发布后，仅仅一年时间，我们就看到了许多 Swift 应用程序在 App Store 上成功开发和发布。在这个时间段内，许多提高开发生产力的
    Swift 工具和开源库也被创建。
- en: During WWDC 2015, Apple announced that Swift will be made open source. This
    means that Swift can be used to write any software and not only iOS or OS X apps.
    You can write a piece of server-side code or web app in Swift. This is one more
    reason you should learn it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2015 年的 WWDC 上，苹果宣布 Swift 将开源。这意味着 Swift 可以用来编写任何软件，而不仅仅是 iOS 或 OS X 应用程序。你可以用
    Swift 编写一段服务器端代码或网络应用程序。这是你应该学习 Swift 的另一个原因。
- en: On the other hand, we see that Swift is under constant development. There were
    many changes and improvements in version 1.2, and there were even more changes
    in version 2.0\. Although it's very easy to upgrade to the newer Swift version
    with the Xcode migrator, it's something you should think about.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们看到 Swift 正在持续发展中。在 1.2 版本中有很多变化和改进，在 2.0 版本中变化更多。尽管使用 Xcode 迁移器升级到新的
    Swift 版本非常容易，但这仍然是你需要考虑的事情。
- en: Swift has some promising performance characteristics. We have seen a huge performance
    improvement in the Swift 1.2 release, and some improvements in Swift 2.0 as well.
    You have seen from the previous example how fast Swift is, and in general, Swift
    has more potential to achieve high performance than Objective-C.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有一些有前景的性能特性。我们在 Swift 1.2 的发布中看到了巨大的性能提升，Swift 2.0 也有一些改进。你从之前的例子中已经看到了
    Swift 的速度有多快，总的来说，Swift 比 Objective-C 有更多的潜力实现高性能。
- en: 'Finally, I want to mention a phrase I really like, by Bryan Irace:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想提到一个我非常喜欢的，由 Bryan Irace 提出的短语：
- en: '*When the iOS SDK says "Jump", ask "How High?"*'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当 iOS SDK 说“跳”，你问“多高”？*'
- en: Don't wait, learn Swift!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不要等待，学习 Swift！
- en: Swift's features and benefits
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 的特性和优势
- en: 'At this point, you know that you should learn Swift, and you shouldn''t have
    any doubts. Let''s take a look what makes Swift so amazing and powerful. Here
    is a list of a few important features that we are going to cover:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你知道你应该学习 Swift，而且不应该有任何疑虑。让我们看看是什么让 Swift 如此神奇和强大。以下是我们将要介绍的一些重要特性列表：
- en: Clean and beautiful syntax
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰美观的语法
- en: Type-safe
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全
- en: Reach types system
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可达的类型系统
- en: Powerful value types
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的值类型
- en: A multiparadigm language—object-oriented, protocol-oriented, and functional
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多范式语言——面向对象、协议导向和函数式
- en: Generic purpose
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用目的
- en: Fast
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: Safe
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Clean and beautiful
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰美观
- en: Powerful features and performance are important, but I think that cleanness
    and beauty are no less important. You write and read code everyday, and it has
    to be clean and beautiful so that you can enjoy it. Swift is very clean and beautiful,
    and the following are the main features that make it so.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的功能和性能很重要，但我认为整洁和美观同样重要。你每天都会编写和阅读代码，它必须整洁美观，这样你才能享受它。Swift 非常整洁美观，以下是一些使其如此的主要特性。
- en: No semicolons
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无分号
- en: 'Semicolons were created for the compiler. They help the compiler understand
    the source code and split it into commands and instructions. But the source code
    is written for people, and we should probably get rid of the compiler instructions
    from it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 分号是为了编译器而创建的。它们帮助编译器理解源代码并将其拆分为命令和指令。但源代码是为人类编写的，我们可能应该从其中去除编译器指令：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There is no need for a semicolon (;) at the end of every instruction. It may
    seem like a very small feature, but it makes code so much nicer and easier to
    write and read. You can, however, put semicolons if you want. A semicolon is required
    when you have two instructions on the same line. There are also some exceptions
    when you have to use semicolons, a `for` loop as an example (`for var i = 0; i
    < 10; i++`), but in that context, they are used for a different purpose.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令的末尾不需要分号 (;)。这看起来可能是一个非常小的特性，但它使得代码更加美观，更容易编写和阅读。然而，如果你想的话，可以添加分号。当同一行有两个指令时，需要分号。还有一些情况下必须使用分号，例如
    `for` 循环（`for var i = 0; i < 10; i++`），但在这个上下文中，它们用于不同的目的。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I strongly recommend not using semicolons, and avoid using more than one instruction
    in the same line.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议不要使用分号，并避免在同一行中使用多个指令。
- en: Type inference
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'With type inference, you don''t need to specify the types of variables and
    constants. Swift automatically detects the correct type from the context. Sometimes,
    however, you have to specify the type explicitly and provide type annotation.
    When there is no value assigned to the variable, Swift can''t predict what type
    that variable should be:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断，你不需要指定变量和常量的类型。Swift 会自动从上下文中检测正确的类型。有时，你不得不显式指定类型并提供类型注解。当变量没有赋值时，Swift
    无法预测该变量的类型：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In most cases, Swift can understand a variable's type from the value assigned
    to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Swift 可以从分配给变量的值中理解变量的类型。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't use type annotation if it's not required. Giving your variables descriptive
    names should be enough. This makes your code clean and nice to read.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要，不要使用类型注解。给变量起有描述性的名字应该足够了。这使得你的代码整洁且易于阅读。
- en: Other clean code Swift features
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他干净的 Swift 代码特性
- en: 'The list of all of Swift''s clean code features is very long; here are few
    of them: closure syntax, functions'' default parameter values, functions'' external
    parameter names, default initializers, subscripts, and operators:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 所有干净代码特性的列表非常长；这里列举其中一些：闭包语法、函数的默认参数值、函数的外部参数名称、默认初始化器、下标和运算符：
- en: '**Clean closure syntax**: A closure is a standalone block of code that can
    be treated as a light unnamed function. It has the same functionality as a function
    but has a cleaner syntax. You can assign it to a variable, call it, or pass it
    as an argument to a function. For example, `{ $0 + 10 }` is a closure:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**干净的闭包语法**：闭包是一个独立的代码块，可以被视为一个轻量级的无名称函数。它具有与函数相同的功能，但语法更简洁。你可以将其分配给变量，调用它，或将它作为参数传递给函数。例如，`{
    $0 + 10 }` 是一个闭包：'
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Default parameter values and external names**: While declaring a function,
    you can define default values for parameters and give them different external
    names, which are used when you call that function. With default parameters, you
    can define one function but call it with different arguments. This reduces the
    need for creating unnecessary functions:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认参数值和外部名称**：在声明函数时，你可以为参数定义默认值，并给它们不同的外部名称，这些名称在调用该函数时使用。使用默认参数，你可以定义一个函数，但可以用不同的参数来调用它。这减少了创建不必要的函数的需求：'
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Default and memberwise initializers**: Swift can create initializers for
    struct and base classes in some scenarios for you. Less code, better code:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认和成员初始化器**：Swift 在某些情况下可以为你创建结构体和基类的初始化器。代码更少，代码质量更高：'
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Subscripts**: This is a nice way of accessing the member elements of a collection.
    You can use any type as a key:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下标**：这是访问集合成员元素的一种好方法。你可以使用任何类型作为键：'
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also define a subscript operator for your own types or extend existing
    types by adding own subscript operator to them in an extension:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以为您的自定义类型定义下标运算符，或者通过向它们添加自己的下标运算符来扩展现有类型：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Operators**: These are symbols that represent functionality, for example,
    the `+` operator. You can extend your types to support standard operators or create
    your own custom operators:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运算符**：这些是表示功能的符号，例如，`+` 运算符。您可以通过扩展您的类型来支持标准运算符或创建自己的自定义运算符：'
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Define your custom operators carefully. They can make code cleaner, but they
    can also bring much more complexity into the code and make it hard to understand.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仔细定义您的自定义运算符。它们可以使代码更简洁，但它们也可能给代码带来更多的复杂性，并使其难以理解。
- en: '**guard**: The `guard` statement is used to check whether a condition is met
    before continuing to execute the code. If the condition isn''t met, it must exit
    the scope. The `guard` statement removes nested conditional statements and the
    Pyramid of Doom problem:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**guard**：`guard` 语句用于在继续执行代码之前检查条件是否满足。如果条件不满足，它必须退出作用域。`guard` 语句消除了嵌套条件语句和“死亡金字塔”问题：'
- en: Note
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Read more about the Pyramid of Doom at [https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)](https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)).
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于“死亡金字塔”（编程）的信息，请参阅[https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)](https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming))。
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A clean code summary
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清洁代码总结
- en: As you can see, Swift is very clean and nice. The best way to show how clean
    and beautiful Swift is is by trying to implement the same functionality in Swift
    and Objective-C.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Swift 非常干净、漂亮。展示 Swift 如何干净和美丽最好的方式是尝试在 Swift 和 Objective-C 中实现相同的功能。
- en: Let's say we have a list of people and we need to find the people with a certain
    age criteria and make their names lowercase.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个人的列表，我们需要找到符合特定年龄标准的人，并将他们的名字转换为小写。
- en: 'This is what the Swift version of this code will look like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这段代码的 Swift 版本将看起来像什么：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is what the Objective-C version of this code will look like:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将此代码转换为 Objective-C 版本的内容：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The results are quite astonishing. The Swift code has 14 lines, whereas the
    Objective-C code has 40 lines, with `.h` and `.m` files. Now you see the difference.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相当惊人。Swift 代码有 14 行，而 Objective-C 代码有 40 行，包括 `.h` 和 `.m` 文件。现在您可以看到差异了。
- en: Safe
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全
- en: Swift is a very safe programming language, and it does a lot of security checks
    at compile time. The goal is to catch as many issues as possible during compiling
    and not when you run an application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种非常安全的编程语言，它在编译时进行大量的安全检查。目标是尽可能在编译时而不是在运行应用程序时捕获尽可能多的问题。
- en: 'Swift is a type-safe programming language. If you made any mistakes with a
    type, such as trying to add an `Int` and a `String` or passing the wrong argument
    to a function, you will get an error:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种类型安全的编程语言。如果您在类型上犯了错误，例如尝试将 `Int` 和 `String` 相加或向函数传递错误的参数，您将得到一个错误：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Swift doesn't do any typecasting for you; you have to do it explicitly, and
    this makes Swift even safer. In this example, we had to cast an `Int` number to
    the `Double` type before adding it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 不会为您做任何类型转换；您必须显式地进行，这使得 Swift 更加安全。在这个例子中，我们在添加之前必须将一个 `Int` 数字转换为 `Double`
    类型。
- en: Optionals
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选
- en: 'A very important safe type that was introduced in Swift is an **optional**.
    An optional is a way of representing the absence of a value—`nil`. You can''t
    assign `nil` to a variable with the `String` type. Instead, you must declare that
    this variable can be `nil` by making it the optional `String?` type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中引入的一个非常重要的安全类型是 **可选**。可选是一种表示值不存在的方式——`nil`。您不能将 `nil` 分配给具有 `String`
    类型的变量。相反，您必须通过将其声明为可选的 `String?` 类型来表明这个变量可以是 `nil`：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To make a type an optional type, you must put a question mark (`?`) after the
    type, for example, `Int?`, `String?`, and `Person?`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个类型转换为可选类型，您必须在类型后放置一个问号（`?`），例如，`Int?`、`String?` 和 `Person?`。
- en: 'You can also declare an optional type using the `Optional` keyword, `Optional<String>`,
    but the shorter way with using `?` is preferred:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `Optional` 关键字声明可选类型，例如 `Optional<String>`，但使用 `?` 的简短方式更受欢迎：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Optionals are like a box that contains some value or nothing. Before using
    the value, you need to unwrap it first. This technique is called unwrapping optionals,
    or optional binding if you assign an unwrapped value to a constant:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可选就像一个包含某些值或无物的盒子。在使用值之前，您需要先解包它。这种技术称为解包可选，或者如果您将解包的值分配给一个常量，则称为可选绑定：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You must always check whether an optional has a value before accessing it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问可选值之前，你必须始终检查它是否有值。
- en: Error handling
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Swift 2.0 has powerful and very simple-to-use error handling. Its syntax is
    very similar to the exception handling syntax in other languages, but it works
    in a different way. It has the `throw`, `catch`, and `try` keywords. Swift error
    handling consists of a few components, explained as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2.0具有强大且非常易于使用的错误处理。其语法与其他语言的异常处理语法非常相似，但工作方式不同。它有`throw`、`catch`和`try`关键字。Swift错误处理由以下组件组成，如下所述：
- en: 'An error object represents an error, and it must conform to the `ErrorType`
    protocol:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误对象表示一个错误，并且它必须符合`ErrorType`协议：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Swift enumerations fit best for representing a group of related error objects.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Swift枚举最适合表示一组相关的错误对象。
- en: 'Every function that can throw an error must be declared using the `throws`
    keyword after its parameters'' list:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个可能抛出错误的函数都必须在参数列表之后使用`throws`关键字进行声明：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To throw an error, use the `throw` keyword:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要抛出一个错误，请使用`throw`关键字：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you are calling a function that can throw an error, you must use the `try`
    keyword. This indicates that a function can fail and further code will not be
    executed:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你调用一个可能抛出错误的函数时，你必须使用`try`关键字。这表示函数可能会失败，并且后续代码将不会执行：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If an error occurs, it must be caught and handled with the `do` and `try` keywords
    or thrown further by declaring that function with `throws`:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生错误，必须使用`do`和`try`关键字来捕获和处理，或者通过声明该函数为`throws`来进一步抛出：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s take a look at a code example that shows how to work with exceptions
    in Swift:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例，展示如何在Swift中处理异常：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are many other safety features in Swift:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Swift还有许多其他安全特性：
- en: Memory safety ensures that values are initialized before use.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存安全性确保在使用之前初始化值。
- en: Two-phase initialization process with security checks
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有安全检查的两阶段初始化过程
- en: Required method overriding and many others
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须的方法重写和许多其他功能
- en: Rich type system
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丰富的类型系统
- en: 'Swift has the following powerful types:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Swift有以下强大的类型：
- en: '**Structures** are flexible building blocks that can hold data and methods
    to manipulate that data. Structures are very similar to classes but they are value
    type:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构体**是灵活的构建块，可以存储数据以及操作这些数据的方法。结构体与类非常相似，但它们是值类型：'
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Tuples** are a way of grouping multiple values into one type. Values inside
    a tuple can have different types. Tuples are very useful for returning multiple
    values from a function. You can access values inside a tuple by either index or
    name if the tuple has named elements; or you can assign each item in the tuple
    to a constant or a variable:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**是将多个值组合成一个类型的一种方式。元组内的值可以有不同的类型。元组对于从函数中返回多个值非常有用。如果元组有命名元素，你可以通过索引或名称访问元组内的值；或者你可以将元组中的每个项分配给一个常量或变量：'
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Range** represents a range of numbers from *x* to *y*. There are also two
    range operators that help create ranges: closed range operator and half-open range
    operator:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Range**表示从*x*到*y*的数字范围。还有两个范围运算符可以帮助创建范围：闭合范围运算符和半开范围运算符：'
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Enumeration** represents a group of common related values. An enumeration''s
    member can be empty, have a raw value, or have an associated value of any type.
    Enumerations are first-class types; they can have methods, computed properties,
    initializer, and other features. They are great for type-safe coding:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枚举**表示一组相关的常见值。枚举的成员可以是空的，有原始值，或者有任何类型的关联值。枚举是一等类型；它们可以有方法、计算属性、初始化器和其他功能。它们非常适合类型安全的编码：'
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Powerful value types
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强大的值类型
- en: 'There are two very powerful value types in Swift: `struct` and `enum`. Almost
    all types in the Swift standard library are implemented as immutable value types
    using `struct` or `enum`, for example, `Range`, `String`, `Array`, `Int`, `Dictionary`,
    `Optionals`, and others.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有两种非常强大的值类型：`struct`和`enum`。Swift标准库中的几乎所有类型都是使用`struct`或`enum`实现的不可变值类型，例如`Range`、`String`、`Array`、`Int`、`Dictionary`、`Optionals`等。
- en: 'Value types have four big advantages over reference types, they are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型相对于引用类型有四个主要优势，它们是：
- en: Immutable
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变
- en: Thread safe
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全
- en: Single owned
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一所有者
- en: Allocated on the stack memory
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈内存上分配
- en: 'Value types are immutable and only have a single owner. The value data is copied
    on assignment and when passing it as an argument to a function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型是不可变的，并且只有一个所有者。值数据在赋值和将值作为函数参数传递时被复制：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift is smart enough to perform value copying only if the value is mutated.
    Value copying doesn't happen on an assignment, that is `str2 = str`, but on value
    mutation, that is `str += ":)"`. If you remove that line of code, `str` and `str2`
    would share the same immutable data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 足够智能，只有在值被修改时才会执行值复制。赋值操作不会发生值复制，即 `str2 = str`，而是在值修改时，即 `str += ":)"`。如果你删除那行代码，`str`
    和 `str2` 将会共享相同的不可变数据。
- en: A multiparadigm language
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多范式语言
- en: Swift is a multiparadigm programming language. It supports many different programming
    styles, such as object-oriented, protocol-oriented, functional, generic, block-structured,
    imperative, and declarative programming. Let's take a look at a few of them in
    more detail here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种多范式编程语言。它支持许多不同的编程风格，例如面向对象、协议导向、函数式、泛型、块结构化、命令式和声明式编程。让我们在这里更详细地看看其中的一些。
- en: Object oriented
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象
- en: Swift supports the object-oriented programming style. It has classes with the
    single inheritance model, the ability to conform to protocols, access control,
    nested types and initializers, properties with observers, and other features of
    OOP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 支持面向对象的编程风格。它具有单继承模型的类，能够遵守协议，访问控制，嵌套类型和初始化器，具有观察者的属性，以及其他面向对象的特性。
- en: Protocol oriented
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议导向
- en: The concept of protocols and protocol-oriented programming is not new, but Swift
    protocols have some powerful features that make them special. The general idea
    of protocol-oriented programming is to use protocols instead of types. In this
    way, we can create a very flexible system with weak binding to concrete types.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 协议和协议导向编程的概念并不新鲜，但 Swift 协议拥有一些强大的特性，使它们变得特别。协议导向编程的一般思想是使用协议而不是类型。这样，我们可以创建一个非常灵活的系统，具有对具体类型的弱绑定。
- en: 'In Swift, you can extend protocols and provide a method''s default implementation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以扩展协议并提供方法的默认实现：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, every type that implements `CollectionType` has a `findFirst` method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个实现了 `CollectionType` 的类型都有一个 `findFirst` 方法：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'One big advantage of using protocol-oriented programming is that we can add
    methods to related types and use the dot (`.`) syntax for method chaining instead
    of using free functions and passing arguments:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议导向编程的一个主要优势是，我们可以向相关类型添加方法，并使用点（`.`）语法进行方法链式调用，而不是使用自由函数和传递参数：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Functional
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式
- en: Swift also supports the functional programming style. In functional languages,
    a function is a type and it is treated in the same way as other types, such as
    `Int`; also, it is called a **first class function**. Functions can be assigned
    to a variable and passed as an argument to other functions. This really helps
    to decouple your code and makes it more reusable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还支持函数式编程风格。在函数式语言中，函数是一种类型，它被以与其他类型相同的方式处理，例如 `Int`；它也被称作 **一等函数**。函数可以被分配给变量，并作为参数传递给其他函数。这实际上有助于解耦你的代码，并使其更具可重用性。
- en: 'A great example is a `filter` function of an array. It takes a function that
    performs the actual filtering logic, and it gives us so much flexibility:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是数组的 `filter` 函数。它接受一个执行实际过滤逻辑的函数，并给我们提供了如此多的灵活性：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Generic purpose
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用目的
- en: 'Swift has a very powerful feature called **generics**. Generics allow you to
    write generic code without mentioning a specific type that it should work with.
    Generics are very useful for building algorithms, reusable code, and frameworks.
    The best way to explain generics is by showing an example. Let''s create a `minimum`
    function that will return a smaller value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有一个非常强大的功能，称为 **泛型**。泛型允许你编写不提及特定类型的泛型代码。泛型对于构建算法、可重用代码和框架非常有用。解释泛型最好的方式是通过示例。让我们创建一个
    `minimum` 函数，它将返回较小的值：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function has a limitation; it will work only with integers. However, the
    logic of getting a smaller value is the same for all types—compare them and return
    the smaller value. This is very generic code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个限制；它只能与整数一起工作。然而，获取较小值的逻辑对所有类型都是相同的——比较它们并返回较小的值。这是一段非常通用的代码。
- en: 'Let''s make our `minimum` function generic and work with different types:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的 `minimum` 函数变得通用，并支持不同的类型：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Swift standard library has already implemented a generic `min` function.
    Use that instead.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的标准库已经实现了通用的 `min` 函数。请使用它而不是自己实现。
- en: Fast
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速
- en: 'Swift is designed to be fast and have high performance, and this is achieved
    with the following techniques:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 被设计成快速且性能高，这是通过以下技术实现的：
- en: Compile-time method binding
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时方法绑定
- en: Strong typing and compile time optimization
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型和编译时优化
- en: Memory layout optimization
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存布局优化
- en: Later, we will cover in more detail how Swift uses these techniques to improve
    performance.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将更详细地介绍 Swift 如何使用这些技术来提高性能。
- en: Swift interoperability
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 互操作性
- en: 'There are two main points that Apple thought of when introducing Swift:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当苹果公司引入 Swift 时，他们考虑了两个主要点：
- en: The usage of the Cocoa framework and established Cocoa patterns
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cocoa 框架和建立的 Cocoa 模式
- en: Easy to adopt and migrate
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于采用和迁移
- en: Apple understood that and took it very seriously while working on Swift. They
    made Swift work seamlessly with Objective-C and Cocoa. You can use all Objective-C
    code in Swift, and you can even use Swift in Objective-C.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司理解这一点，并在开发 Swift 时非常重视。他们使 Swift 与 Objective-C 和 Cocoa 无缝协作。你可以在 Swift 中使用所有
    Objective-C 代码，甚至可以在 Objective-C 中使用 Swift。
- en: It's very crucial to be able to use the Cocoa framework. All of the code that
    is written in Objective-C is available for use in Swift, both Apple frameworks
    and third-party libraries as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用 Cocoa 框架非常重要。所有用 Objective-C 编写的代码都可以在 Swift 中使用，包括苹果框架和第三方库。
- en: Using Objective-C in Swift
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Swift 中使用 Objective-C
- en: 'All the Cocoa frameworks written in Objective-C are available in Swift by default.
    You just need to import them and then use them. Swift doesn''t have header files;
    instead, you need to use a module name. You can also include your own Swift frameworks
    in the same way:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有用 Objective-C 编写的 Cocoa 框架都在 Swift 中可用。你只需导入它们并使用它们。Swift 没有头文件；相反，你需要使用模块名称。你还可以以相同的方式包含你自己的
    Swift 框架：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Setup
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: To include your own Objective-C source files, you need to do a small setup first.
    The process is a bit different for the application target and framework target.
    The main idea is the same—to import the Objective-C header files.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含你自己的 Objective-C 源文件，你首先需要进行一些小的设置。对于应用程序目标和框架目标，这个过程略有不同。主要思想是相同的——导入 Objective-C
    头文件。
- en: The application target
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用程序目标
- en: For the application target, you need to create a bridging header. A bridging
    header is a plain Objective-C header file in which you specify the Objective-C
    `import` statements.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序目标，你需要创建一个桥接头。桥接头是一个普通的 Objective-C 头文件，在其中你指定 Objective-C 的 `import`
    语句。
- en: Xcode will show a popup, offering to create, and set up a bridging header for
    you when you add the Objective-C file to a Swift project, or vice versa for the
    first time. This is the best and the most convenient way to add it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次将 Objective-C 文件添加到 Swift 项目中，或者相反，Xcode 将会弹出一个提示，为你创建并设置桥接头。这是添加桥接头的最佳和最便捷的方式。
- en: '![The application target](img/00002.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序目标](img/00002.jpeg)'
- en: 'If you decline the Xcode help, you can create a bridging header yourself anytime.
    To do that, you need to follow these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拒绝了 Xcode 的帮助，你可以在任何时候自己创建桥接头。为此，你需要遵循以下步骤：
- en: Add a new header file to the project.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的头文件。
- en: Go to **Target** | **Build Settings**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **目标** | **构建设置**。
- en: Search for `Objective-C Bridging Header` and specify the path to the bridging
    header file created in step 1.![The application target](img/00003.jpeg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `Objective-C Bridging Header` 并指定步骤 1 中创建的桥接头文件路径。![应用程序目标](img/00003.jpeg)
- en: 'Onceyou set up bridging header, the next step is to add `import` statements
    to it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了桥接头，下一步就是向其中添加 `import` 语句：
- en: '`Bridging.h`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bridging.h`'
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The framework target
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 框架目标
- en: 'For the framework target, you simply need to import the `.h` Objective-C header
    files to the framework''s umbrella header. The Objective-C header files must be
    marked as public. The umbrella header is the header in which you specify your
    publicly available API. Usually, it looks like this—the `ExampleFramework.h` umbrella
    header:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于框架目标，你只需将 `.h` Objective-C 头文件导入到框架的伞形头文件中。Objective-C 头文件必须标记为公开。伞形头文件是你指定公开
    API 的头文件。通常，它看起来像这样——`ExampleFramework.h` 伞形头文件：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Calling Objective-C code
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用 Objective-C 代码
- en: 'Once you are done with the setup, you can use all Objective-C APIs in Swift.
    You can create instances, call methods, inherit from Objective-C classes, conform
    to protocols, and do other things that you can do in Objective-C. In this example,
    we will use the `Foundation` classes, but the rules are the same for third-party
    code as well:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成设置后，你就可以在 Swift 中使用所有 Objective-C API。你可以创建实例、调用方法、从 Objective-C 类继承、遵守协议，以及执行你在
    Objective-C 中能做的其他操作。在这个例子中，我们将使用 `Foundation` 类，但对于第三方代码，规则也是相同的：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Inherit from Objective-C classes only if you need it. This can have a negative
    impact on performance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你需要时才从 Objective-C 类继承。这可能会对性能产生负面影响。
- en: 'There is free bridging between Swift types and Objective-C Foundation types.
    Automatic bridging happens on assignment and when you pass it as an argument to
    a function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 类型与 Objective-C Foundation 类型之间存在免费桥接。自动桥接发生在赋值时，以及当你将其作为参数传递给函数时：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Converting from Objective-C to a Swift type requires explicit type casting.
    There are two types of casting: downcasting and upcasting. Casting is usually
    an unsafe operation, which could fail, and that''s why it returns an optional
    type:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Objective-C 转换到 Swift 类型需要显式的类型转换。有两种类型的转换：向下转换和向上转换。转换通常是一个不安全的操作，可能会失败，这就是为什么它返回一个可选类型：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `String` type has gone one step even further. You can invoke the Objective-C
    foundation methods on the Swift `String` type without any type casting:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类型又向前迈进了一步。你可以在 Swift 的 `String` 类型上调用 Objective-C 基础方法，而无需任何类型转换：'
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Swift made a small improvement to Objective-C code so that it looks more Swift-style.
    The biggest change is made to instance creation and the style of the initialization
    code. The `init`, the `initWith`, and other factory methods are transformed into
    Swift initializers:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 对 Objective-C 代码进行了一些小的改进，使其看起来更像 Swift 风格。最大的变化是在实例创建和初始化代码的风格上。`init`、`initWith`
    和其他工厂方法被转换成了 Swift 初始化器：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The other change is made to `NS_ENUM` and `NS_OPTIONS`. They become native
    Swift types: `enum` and `RawOptionSetType`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项更改是针对 `NS_ENUM` 和 `NS_OPTIONS`。它们变成了 Swift 的原生类型：`enum` 和 `RawOptionSetType`。
- en: As you can see, the API looks a bit different. Because Swift strives for cleanliness,
    it removes word duplications from the API nomenclature. The other method calls,
    properties, and names, are the same as they were in Objective-C, so it should
    be easy to find and understand them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，API 看起来略有不同。因为 Swift 追求简洁，它从 API 命名法中删除了单词重复。其他方法调用、属性和名称与 Objective-C
    中的相同，所以应该很容易找到并理解它们。
- en: What is happening behind the scenes is that Swift is generating special interface
    files to interact with Objective-C. You can see these Swift interface files by
    holding down the *command* key and clicking on the type, `NSDate` and `UIColor`
    in our example.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 背后的操作是 Swift 生成特殊的接口文件来与 Objective-C 交互。你可以在我们的示例中通过按住 *command* 键并单击类型，例如 `NSDate`
    和 `UIColor`，来查看这些 Swift 接口文件。
- en: Using Swift in Objective-C
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Objective-C 中使用 Swift
- en: It is also possible to use Swift in Objective-C. It makes Swift very easy to
    adapt to an existing project. You can start by adding one Swift file, and move
    more functionality to Swift over time.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 Swift 在 Objective-C 中。这使得 Swift 很容易适应现有的项目。你可以从添加一个 Swift 文件开始，然后随着时间的推移将更多功能转移到
    Swift。
- en: The setup process is much easier than that for including Objective-C in Swift.
    All you need to do is import Swift's autogenerated header to Objective-C. The
    naming convention of the files for application targets is `ProductModuleName +
    -Swift.h`, and for frameworks, it is `<ProductName/ProductModuleName + -Swift.h>`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 设置过程比在 Swift 中包含 Objective-C 要简单得多。你所需要做的就是导入 Swift 的自动生成的头文件到 Objective-C。对于应用程序目标，文件命名约定是
    `ProductModuleName + -Swift.h`，而对于框架，则是 `<ProductName/ProductModuleName + -Swift.h>`。
- en: 'Take a look at the following examples:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can inspect the content of that autogenerated file by holding down the
    *command* key and clicking on it. By default, Swift classes aren''t exposed for
    use in Objective-C. There are two ways of making Swift classes available in Objective-C:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按住 *command* 键并单击来自检自动生成的文件的内容。默认情况下，Swift 类不公开用于 Objective-C。有两种方法可以使
    Swift 类在 Objective-C 中可用：
- en: Mark the Swift class, protocol, or enumeration with the `@objc` attribute.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@objc` 属性标记 Swift 类、协议或枚举。
- en: 'You can mark classes, methods, protocols, and enumerations with the `@objc`
    attribute. The `@objc` attribute also accepts the alternative name that is used
    for Objective-C. When you expose a Swift class by marking it with the `@objc`
    attribute, it has to inherit from the Objective-C class, and the enumeration must
    have a raw `Int` value:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 `@objc` 属性来标记类、方法、协议和枚举。`@objc` 属性还接受 Objective-C 中使用的替代名称。当你通过标记 `@objc`
    属性来暴露 Swift 类时，它必须继承自 Objective-C 类，并且枚举必须有一个原始的 `Int` 值：
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, the `KOKPerson` class with the `isMan` method is available for use in Objective-C.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，带有 `isMan` 方法的 `KOKPerson` 类可以在 Objective-C 中使用。
- en: 'Inherit from an Objective-C class, `NSObject` for example:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Objective-C 类，例如 `NSObject` 继承：
- en: 'When you inherit from an Objective-C class, your Swift class automatically
    becomes available in Objective-C. You don''t need to perform any extra steps in
    such cases. You can also mark it with the `@objc` attribute and provide an alternative
    name:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你从Objective-C类继承时，你的Swift类会自动在Objective-C中可用。在这种情况下，你不需要执行任何额外步骤。你还可以使用`@objc`属性标记它，并提供一个替代名称：
- en: '[PRE42]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Features of Swift that are not available in Objective-C
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift中不可用的功能
- en: 'There are some features of Swift that are not available in Objective-C, so
    if you plan to use Swift code from Objective-C, you should avoid using them. Here
    is the complete list of these features:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Swift有一些功能在Objective-C中不可用，所以如果你计划从Objective-C中使用Swift代码，你应该避免使用它们。以下是这些功能的完整列表：
- en: Structures
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Generics
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Tuples
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Enumerations
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Type aliases
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名
- en: Top-level functions
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级函数
- en: Curried functions
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏函数
- en: Global variables
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量
- en: Swift-style variadic parameters
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift风格的变长参数
- en: Nested types
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: Performance – meaning and key metrics
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能——含义和关键指标
- en: 'There are two key characteristics of code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有两个关键特性：
- en: '**Code quality**: It has to be solid and flexible and have a good architecture'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码质量**：它必须坚固、灵活，并且具有良好的架构'
- en: '**Code performance**: It has to be fast'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码性能**：它必须快速'
- en: 'Making the code architecture very solid and stable is the most important task,
    but we shouldn''t forget about making it fast as well. Achieving high performance
    can be a tricky and dangerous task. Here are a few things that you should keep
    in mind while working on performance improvement:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使代码架构非常坚固和稳定是最重要的任务，但我们也不应该忘记让它变得快速。实现高性能可能是一个棘手且危险的任务。以下是一些你在进行性能改进时应该记住的几点：
- en: Don't optimize your code upfront
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要一开始就优化你的代码
- en: 'There are many articles about this topic, why it''s dangerous, and why you
    shouldn''t do it. Just don''t do it, and as Donald Knut says:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于这个话题有很多文章，讨论了它的危险性和为什么你不应该这样做。只是不要这样做，正如唐纳德·克努特所说：
- en: '*"Premature optimization is the root of all evil"*'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"过早优化是万恶之源"*'
- en: Measure first
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先测量
- en: Firstly, don't optimize upfront, and secondly, measure first. Measure the code's
    performance characteristics and optimize only those parts that are slow. Almost
    95 percent of code doesn't require performance optimization.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，不要一开始就优化，其次，先测量。测量代码的性能特征，只优化那些慢的部分。几乎95%的代码不需要性能优化。
- en: I totally agree with these points, but there is another type of performance
    optimization that we should think of upfront.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我完全同意这些观点，但我们应该提前考虑另一种类型的性能优化。
- en: Everyday code performance
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每日代码性能
- en: 'The small decisions that we make every day include the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天所做的微小决定包括以下内容：
- en: What type should it be, `Int` or `String`?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是什么类型，`Int`还是`String`？
- en: Should I create a new class for a new functionality or add to an existing one?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该为新的功能创建一个新的类，还是添加到现有的类中？
- en: Use an array? Or maybe a set?
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组？或者也许是一个集合？
- en: It seems as if these don't have any impact on the application's performance,
    and in most cases, they don't. However, making the right decision not only improves
    an application's speed, but also makes it more stable. This gives higher performance
    in application development. The small changes that we make every day make a big
    impact at the end of the year.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这些似乎对应用程序的性能没有影响，在大多数情况下，它们确实没有。然而，做出正确的决定不仅可以提高应用程序的速度，还可以使其更加稳定。这为应用程序开发提供了更高的性能。我们每天所做的微小改变，到年底时会产生重大影响。
- en: The importance of performance
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能的重要性
- en: High performance is very crucial. The performance of an app is directly related
    to user experience. Users want to get results immediately; they don't want to
    wait for the view to load, see a long **Loading** indicator, or see a lagging
    animation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能非常重要。应用程序的性能直接关系到用户体验。用户希望立即得到结果；他们不希望等待视图加载，看到长时间的**加载**指示器，或者看到卡顿的动画。
- en: Every year, our computers and devices become more and more powerful, with more
    CPU speed, memory, storage, and storage speed. Performance problems could seem
    irrelevant because of this, but the software complexity increases as well. We
    have more complex data to store and process. We need to show animations and do
    a lot of other things.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，我们的计算机和设备变得越来越强大，拥有更快的CPU速度、更多的内存、更多的存储和更快的存储速度。由于这一点，性能问题可能看起来并不相关，但软件的复杂性也在增加。我们需要存储和处理更复杂的数据。我们需要显示动画和做很多其他事情。
- en: The first way of solving a performance problem is by adding more power. We can
    add more servers to handle data, but we can't update our clients' PC and mobile
    devices. Also, adding more power doesn't solve the code performance issue itself,
    but just delays it for some time.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 解决性能问题的第一种方法是通过增加更多功率。我们可以添加更多服务器来处理数据，但我们无法更新客户的 PC 和移动设备。此外，增加更多功率并不能解决代码性能问题本身，而只是暂时推迟了它。
- en: The second, and correct, solution is to remove the issue that causes the performance
    problem. For that, we need to identify the problem, the slow piece of the code,
    and improve it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，也是正确的解决方案，是移除导致性能问题的原因。为此，我们需要识别问题，找出代码中的慢速部分，并对其进行改进。
- en: The key metrics
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键指标
- en: 'There are many things that impact an application''s performance and user experience.
    We will cover the following key metrics:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多因素会影响应用程序的性能和用户体验。我们将涵盖以下关键指标：
- en: Operations' performance speed
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作的性能速度
- en: Memory usage
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用
- en: Disk space usage
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘空间使用
- en: The most important of these and the one that has the biggest impact is the **operations'
    performance speed**. It tells us how fast a particular task can be performed,
    for example, creating a new user, reading from a file, downloading an image, searching
    for a person with a particular name, and so on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最重要的是**操作的性能速度**，它告诉我们特定任务可以执行得多快，例如，创建新用户、从文件中读取、下载图片、搜索具有特定名称的人等等。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Swift is a powerful and fast programming language. In this chapter, you learned
    about many powerful features of Swift and how easy it is to start coding in Swift
    and integrate it into existing projects. We also covered why performance is important
    and what you should be thinking about when working with it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种强大且快速的编程语言。在本章中，你了解了 Swift 的许多强大功能，以及如何轻松地在 Swift 中开始编码并将其集成到现有项目中。我们还讨论了为什么性能很重要，以及在使用它时应考虑哪些因素。
- en: In the next chapter, we will do more coding in Swift, and you will learn how
    to use all the features of Swift to make a good application architecture.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Swift 进行更多编码，你将学习如何使用 Swift 的所有功能来构建良好的应用程序架构。
