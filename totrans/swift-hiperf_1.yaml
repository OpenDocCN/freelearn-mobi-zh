- en: Chapter 1. Exploring Swift's Power and Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the 2014, Apple released a new programming language, called Swift. Swift
    has been designed from scratch with many powerful features. It is statically typed
    and very safe. It has a clean and nice syntax, it's fast, it's flexible, and it
    has many other advantages that you will learn later in the book. Swift seems to
    be very powerful and it has big potential. Apple has set big expectations for
    Swift, and their main goal for Swift is that it should be a replacement for Objective-C,
    which is going to happen in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will become familiar with the Swift programming language,
    what it was made for, and what its advantages and features are. We will also make
    our first Swift application and see how easy it is to integrate with existing
    Objective-C code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing swift code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of performance and performance key metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I can guess you opened this book because you are interested in speed and are
    probably wondering, "How fast can Swift be?" Before you even start learning Swift
    and discovering all the good things about it, let's answer it right here and right
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an array of 100,000 random numbers; sort it in Swift, Objective-C,
    and C using the standard `sort` function from `stdlib` (`sort` in Swift, `qsort`
    in C, and `compare` in Objective-C); and measure how much time each would take.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting an array with 100,000 integer elements gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Technology | Time taken |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Swift | 0.00600 sec |'
  prefs: []
  type: TYPE_TB
- en: '| C | 0.01396 sec |'
  prefs: []
  type: TYPE_TB
- en: '| Objective-C | 0.08705 sec |'
  prefs: []
  type: TYPE_TB
- en: And the winner is, Swift! Swift is **14.5** times faster than Objective-C and
    **2.3** times faster than C.
  prefs: []
  type: TYPE_NORMAL
- en: In other examples and experiments, C is usually faster than Swift and Swift
    is way faster than Objective-C. These measurements were done with Xcode 7.0 beta
    6 and Swift 2.0\. It's important to highlight that the improvements in Swift 2.0
    were mainly focused on making it cleaner, more powerful, safer, and more stable,
    and preparing it for open sourcing. Swift's performance hasn't reached its full
    potential yet, and the future is so exciting!
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swift programming language has been designed by Apple from the ground up.
    It was released with the slogan *Objective-C without the C*. The meaning of this
    phrase is that Swift doesn't have any limitation of backward compatibilities.
    It's totally new and with no old baggage. Before you start learning all the power
    of Swift, I think it would be useful to answer a few questions about why should
    you learn it, and if you have any doubts about that, I should dispel them.
  prefs: []
  type: TYPE_NORMAL
- en: Why should I learn Swift?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift is a very new programming language but it has become very popular and
    has gained huge traction. However, many iOS and OS X developers ask these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Should I learn Swift?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What should I learn, Swift or Objective-C?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Objective-C going to stay or die?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Swift ready for production apps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Swift faster than Objective-C or C?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What applications can I write using Swift?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My answer is, "Yes. Definitely!" You should learn Swift. It doesn't matter whether
    you are a new iOS and OS X developer or you have some Objective-C background;
    you should definitely learn Swift.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new developer, then it's really useful to start with Swift, because
    you will learn programming basics and techniques in Swift, and further Swift learning
    would be much easier. Although it would definitely useful to learn Objective-C
    as well, I would recommend learning Swift first so that you build your programming
    mindset on Swift.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have some experience in Objective-C, then you should try Swift
    as soon as possible. It will not only give you the knowledge of a new programming
    language, but also open the door to new ideas and ways of solving problems in
    Objective-C. We can see that Objective-C has started evolving right now because
    of Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C has many limitations because of its backward capabilities with C.
    It was created 23 years ago, in 1983, but it will die much sooner than Swift.
  prefs: []
  type: TYPE_NORMAL
- en: After the release of Swift version 1.0, in only a year's time we have seen many
    Swift applications successfully developed and released on the App Store. In this
    time period, many Swift tools and open source libraries that increase development
    productivity have been created.
  prefs: []
  type: TYPE_NORMAL
- en: During WWDC 2015, Apple announced that Swift will be made open source. This
    means that Swift can be used to write any software and not only iOS or OS X apps.
    You can write a piece of server-side code or web app in Swift. This is one more
    reason you should learn it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we see that Swift is under constant development. There were
    many changes and improvements in version 1.2, and there were even more changes
    in version 2.0\. Although it's very easy to upgrade to the newer Swift version
    with the Xcode migrator, it's something you should think about.
  prefs: []
  type: TYPE_NORMAL
- en: Swift has some promising performance characteristics. We have seen a huge performance
    improvement in the Swift 1.2 release, and some improvements in Swift 2.0 as well.
    You have seen from the previous example how fast Swift is, and in general, Swift
    has more potential to achieve high performance than Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I want to mention a phrase I really like, by Bryan Irace:'
  prefs: []
  type: TYPE_NORMAL
- en: '*When the iOS SDK says "Jump", ask "How High?"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don't wait, learn Swift!
  prefs: []
  type: TYPE_NORMAL
- en: Swift's features and benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you know that you should learn Swift, and you shouldn''t have
    any doubts. Let''s take a look what makes Swift so amazing and powerful. Here
    is a list of a few important features that we are going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean and beautiful syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reach types system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A multiparadigm language—object-oriented, protocol-oriented, and functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean and beautiful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Powerful features and performance are important, but I think that cleanness
    and beauty are no less important. You write and read code everyday, and it has
    to be clean and beautiful so that you can enjoy it. Swift is very clean and beautiful,
    and the following are the main features that make it so.
  prefs: []
  type: TYPE_NORMAL
- en: No semicolons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Semicolons were created for the compiler. They help the compiler understand
    the source code and split it into commands and instructions. But the source code
    is written for people, and we should probably get rid of the compiler instructions
    from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There is no need for a semicolon (;) at the end of every instruction. It may
    seem like a very small feature, but it makes code so much nicer and easier to
    write and read. You can, however, put semicolons if you want. A semicolon is required
    when you have two instructions on the same line. There are also some exceptions
    when you have to use semicolons, a `for` loop as an example (`for var i = 0; i
    < 10; i++`), but in that context, they are used for a different purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I strongly recommend not using semicolons, and avoid using more than one instruction
    in the same line.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With type inference, you don''t need to specify the types of variables and
    constants. Swift automatically detects the correct type from the context. Sometimes,
    however, you have to specify the type explicitly and provide type annotation.
    When there is no value assigned to the variable, Swift can''t predict what type
    that variable should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, Swift can understand a variable's type from the value assigned
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't use type annotation if it's not required. Giving your variables descriptive
    names should be enough. This makes your code clean and nice to read.
  prefs: []
  type: TYPE_NORMAL
- en: Other clean code Swift features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The list of all of Swift''s clean code features is very long; here are few
    of them: closure syntax, functions'' default parameter values, functions'' external
    parameter names, default initializers, subscripts, and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clean closure syntax**: A closure is a standalone block of code that can
    be treated as a light unnamed function. It has the same functionality as a function
    but has a cleaner syntax. You can assign it to a variable, call it, or pass it
    as an argument to a function. For example, `{ $0 + 10 }` is a closure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Default parameter values and external names**: While declaring a function,
    you can define default values for parameters and give them different external
    names, which are used when you call that function. With default parameters, you
    can define one function but call it with different arguments. This reduces the
    need for creating unnecessary functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Default and memberwise initializers**: Swift can create initializers for
    struct and base classes in some scenarios for you. Less code, better code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Subscripts**: This is a nice way of accessing the member elements of a collection.
    You can use any type as a key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also define a subscript operator for your own types or extend existing
    types by adding own subscript operator to them in an extension:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Operators**: These are symbols that represent functionality, for example,
    the `+` operator. You can extend your types to support standard operators or create
    your own custom operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Define your custom operators carefully. They can make code cleaner, but they
    can also bring much more complexity into the code and make it hard to understand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**guard**: The `guard` statement is used to check whether a condition is met
    before continuing to execute the code. If the condition isn''t met, it must exit
    the scope. The `guard` statement removes nested conditional statements and the
    Pyramid of Doom problem:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Read more about the Pyramid of Doom at [https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)](https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A clean code summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, Swift is very clean and nice. The best way to show how clean
    and beautiful Swift is is by trying to implement the same functionality in Swift
    and Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have a list of people and we need to find the people with a certain
    age criteria and make their names lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the Swift version of this code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what the Objective-C version of this code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The results are quite astonishing. The Swift code has 14 lines, whereas the
    Objective-C code has 40 lines, with `.h` and `.m` files. Now you see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Safe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift is a very safe programming language, and it does a lot of security checks
    at compile time. The goal is to catch as many issues as possible during compiling
    and not when you run an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift is a type-safe programming language. If you made any mistakes with a
    type, such as trying to add an `Int` and a `String` or passing the wrong argument
    to a function, you will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Swift doesn't do any typecasting for you; you have to do it explicitly, and
    this makes Swift even safer. In this example, we had to cast an `Int` number to
    the `Double` type before adding it.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very important safe type that was introduced in Swift is an **optional**.
    An optional is a way of representing the absence of a value—`nil`. You can''t
    assign `nil` to a variable with the `String` type. Instead, you must declare that
    this variable can be `nil` by making it the optional `String?` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To make a type an optional type, you must put a question mark (`?`) after the
    type, for example, `Int?`, `String?`, and `Person?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare an optional type using the `Optional` keyword, `Optional<String>`,
    but the shorter way with using `?` is preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionals are like a box that contains some value or nothing. Before using
    the value, you need to unwrap it first. This technique is called unwrapping optionals,
    or optional binding if you assign an unwrapped value to a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must always check whether an optional has a value before accessing it.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift 2.0 has powerful and very simple-to-use error handling. Its syntax is
    very similar to the exception handling syntax in other languages, but it works
    in a different way. It has the `throw`, `catch`, and `try` keywords. Swift error
    handling consists of a few components, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An error object represents an error, and it must conform to the `ErrorType`
    protocol:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift enumerations fit best for representing a group of related error objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Every function that can throw an error must be declared using the `throws`
    keyword after its parameters'' list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To throw an error, use the `throw` keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you are calling a function that can throw an error, you must use the `try`
    keyword. This indicates that a function can fail and further code will not be
    executed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If an error occurs, it must be caught and handled with the `do` and `try` keywords
    or thrown further by declaring that function with `throws`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at a code example that shows how to work with exceptions
    in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other safety features in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory safety ensures that values are initialized before use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-phase initialization process with security checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required method overriding and many others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich type system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift has the following powerful types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structures** are flexible building blocks that can hold data and methods
    to manipulate that data. Structures are very similar to classes but they are value
    type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Tuples** are a way of grouping multiple values into one type. Values inside
    a tuple can have different types. Tuples are very useful for returning multiple
    values from a function. You can access values inside a tuple by either index or
    name if the tuple has named elements; or you can assign each item in the tuple
    to a constant or a variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Range** represents a range of numbers from *x* to *y*. There are also two
    range operators that help create ranges: closed range operator and half-open range
    operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Enumeration** represents a group of common related values. An enumeration''s
    member can be empty, have a raw value, or have an associated value of any type.
    Enumerations are first-class types; they can have methods, computed properties,
    initializer, and other features. They are great for type-safe coding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Powerful value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two very powerful value types in Swift: `struct` and `enum`. Almost
    all types in the Swift standard library are implemented as immutable value types
    using `struct` or `enum`, for example, `Range`, `String`, `Array`, `Int`, `Dictionary`,
    `Optionals`, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types have four big advantages over reference types, they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single owned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocated on the stack memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value types are immutable and only have a single owner. The value data is copied
    on assignment and when passing it as an argument to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift is smart enough to perform value copying only if the value is mutated.
    Value copying doesn't happen on an assignment, that is `str2 = str`, but on value
    mutation, that is `str += ":)"`. If you remove that line of code, `str` and `str2`
    would share the same immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: A multiparadigm language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift is a multiparadigm programming language. It supports many different programming
    styles, such as object-oriented, protocol-oriented, functional, generic, block-structured,
    imperative, and declarative programming. Let's take a look at a few of them in
    more detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Object oriented
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift supports the object-oriented programming style. It has classes with the
    single inheritance model, the ability to conform to protocols, access control,
    nested types and initializers, properties with observers, and other features of
    OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol oriented
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of protocols and protocol-oriented programming is not new, but Swift
    protocols have some powerful features that make them special. The general idea
    of protocol-oriented programming is to use protocols instead of types. In this
    way, we can create a very flexible system with weak binding to concrete types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, you can extend protocols and provide a method''s default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every type that implements `CollectionType` has a `findFirst` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'One big advantage of using protocol-oriented programming is that we can add
    methods to related types and use the dot (`.`) syntax for method chaining instead
    of using free functions and passing arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Functional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift also supports the functional programming style. In functional languages,
    a function is a type and it is treated in the same way as other types, such as
    `Int`; also, it is called a **first class function**. Functions can be assigned
    to a variable and passed as an argument to other functions. This really helps
    to decouple your code and makes it more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example is a `filter` function of an array. It takes a function that
    performs the actual filtering logic, and it gives us so much flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Generic purpose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift has a very powerful feature called **generics**. Generics allow you to
    write generic code without mentioning a specific type that it should work with.
    Generics are very useful for building algorithms, reusable code, and frameworks.
    The best way to explain generics is by showing an example. Let''s create a `minimum`
    function that will return a smaller value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function has a limitation; it will work only with integers. However, the
    logic of getting a smaller value is the same for all types—compare them and return
    the smaller value. This is very generic code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our `minimum` function generic and work with different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Swift standard library has already implemented a generic `min` function.
    Use that instead.
  prefs: []
  type: TYPE_NORMAL
- en: Fast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift is designed to be fast and have high performance, and this is achieved
    with the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time method binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong typing and compile time optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory layout optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, we will cover in more detail how Swift uses these techniques to improve
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Swift interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main points that Apple thought of when introducing Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: The usage of the Cocoa framework and established Cocoa patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to adopt and migrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple understood that and took it very seriously while working on Swift. They
    made Swift work seamlessly with Objective-C and Cocoa. You can use all Objective-C
    code in Swift, and you can even use Swift in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: It's very crucial to be able to use the Cocoa framework. All of the code that
    is written in Objective-C is available for use in Swift, both Apple frameworks
    and third-party libraries as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using Objective-C in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the Cocoa frameworks written in Objective-C are available in Swift by default.
    You just need to import them and then use them. Swift doesn''t have header files;
    instead, you need to use a module name. You can also include your own Swift frameworks
    in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To include your own Objective-C source files, you need to do a small setup first.
    The process is a bit different for the application target and framework target.
    The main idea is the same—to import the Objective-C header files.
  prefs: []
  type: TYPE_NORMAL
- en: The application target
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the application target, you need to create a bridging header. A bridging
    header is a plain Objective-C header file in which you specify the Objective-C
    `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will show a popup, offering to create, and set up a bridging header for
    you when you add the Objective-C file to a Swift project, or vice versa for the
    first time. This is the best and the most convenient way to add it.
  prefs: []
  type: TYPE_NORMAL
- en: '![The application target](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you decline the Xcode help, you can create a bridging header yourself anytime.
    To do that, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new header file to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Target** | **Build Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Objective-C Bridging Header` and specify the path to the bridging
    header file created in step 1.![The application target](img/00003.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Onceyou set up bridging header, the next step is to add `import` statements
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bridging.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The framework target
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the framework target, you simply need to import the `.h` Objective-C header
    files to the framework''s umbrella header. The Objective-C header files must be
    marked as public. The umbrella header is the header in which you specify your
    publicly available API. Usually, it looks like this—the `ExampleFramework.h` umbrella
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Calling Objective-C code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you are done with the setup, you can use all Objective-C APIs in Swift.
    You can create instances, call methods, inherit from Objective-C classes, conform
    to protocols, and do other things that you can do in Objective-C. In this example,
    we will use the `Foundation` classes, but the rules are the same for third-party
    code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inherit from Objective-C classes only if you need it. This can have a negative
    impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is free bridging between Swift types and Objective-C Foundation types.
    Automatic bridging happens on assignment and when you pass it as an argument to
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting from Objective-C to a Swift type requires explicit type casting.
    There are two types of casting: downcasting and upcasting. Casting is usually
    an unsafe operation, which could fail, and that''s why it returns an optional
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `String` type has gone one step even further. You can invoke the Objective-C
    foundation methods on the Swift `String` type without any type casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift made a small improvement to Objective-C code so that it looks more Swift-style.
    The biggest change is made to instance creation and the style of the initialization
    code. The `init`, the `initWith`, and other factory methods are transformed into
    Swift initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The other change is made to `NS_ENUM` and `NS_OPTIONS`. They become native
    Swift types: `enum` and `RawOptionSetType`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the API looks a bit different. Because Swift strives for cleanliness,
    it removes word duplications from the API nomenclature. The other method calls,
    properties, and names, are the same as they were in Objective-C, so it should
    be easy to find and understand them.
  prefs: []
  type: TYPE_NORMAL
- en: What is happening behind the scenes is that Swift is generating special interface
    files to interact with Objective-C. You can see these Swift interface files by
    holding down the *command* key and clicking on the type, `NSDate` and `UIColor`
    in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Using Swift in Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to use Swift in Objective-C. It makes Swift very easy to
    adapt to an existing project. You can start by adding one Swift file, and move
    more functionality to Swift over time.
  prefs: []
  type: TYPE_NORMAL
- en: The setup process is much easier than that for including Objective-C in Swift.
    All you need to do is import Swift's autogenerated header to Objective-C. The
    naming convention of the files for application targets is `ProductModuleName +
    -Swift.h`, and for frameworks, it is `<ProductName/ProductModuleName + -Swift.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can inspect the content of that autogenerated file by holding down the
    *command* key and clicking on it. By default, Swift classes aren''t exposed for
    use in Objective-C. There are two ways of making Swift classes available in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark the Swift class, protocol, or enumeration with the `@objc` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can mark classes, methods, protocols, and enumerations with the `@objc`
    attribute. The `@objc` attribute also accepts the alternative name that is used
    for Objective-C. When you expose a Swift class by marking it with the `@objc`
    attribute, it has to inherit from the Objective-C class, and the enumeration must
    have a raw `Int` value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the `KOKPerson` class with the `isMan` method is available for use in Objective-C.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inherit from an Objective-C class, `NSObject` for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you inherit from an Objective-C class, your Swift class automatically
    becomes available in Objective-C. You don''t need to perform any extra steps in
    such cases. You can also mark it with the `@objc` attribute and provide an alternative
    name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Features of Swift that are not available in Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some features of Swift that are not available in Objective-C, so
    if you plan to use Swift code from Objective-C, you should avoid using them. Here
    is the complete list of these features:'
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-level functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curried functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift-style variadic parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance – meaning and key metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two key characteristics of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code quality**: It has to be solid and flexible and have a good architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code performance**: It has to be fast'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Making the code architecture very solid and stable is the most important task,
    but we shouldn''t forget about making it fast as well. Achieving high performance
    can be a tricky and dangerous task. Here are a few things that you should keep
    in mind while working on performance improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't optimize your code upfront
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many articles about this topic, why it''s dangerous, and why you
    shouldn''t do it. Just don''t do it, and as Donald Knut says:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*"Premature optimization is the root of all evil"*'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Measure first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firstly, don't optimize upfront, and secondly, measure first. Measure the code's
    performance characteristics and optimize only those parts that are slow. Almost
    95 percent of code doesn't require performance optimization.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I totally agree with these points, but there is another type of performance
    optimization that we should think of upfront.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Everyday code performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The small decisions that we make every day include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What type should it be, `Int` or `String`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should I create a new class for a new functionality or add to an existing one?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an array? Or maybe a set?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It seems as if these don't have any impact on the application's performance,
    and in most cases, they don't. However, making the right decision not only improves
    an application's speed, but also makes it more stable. This gives higher performance
    in application development. The small changes that we make every day make a big
    impact at the end of the year.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: High performance is very crucial. The performance of an app is directly related
    to user experience. Users want to get results immediately; they don't want to
    wait for the view to load, see a long **Loading** indicator, or see a lagging
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: Every year, our computers and devices become more and more powerful, with more
    CPU speed, memory, storage, and storage speed. Performance problems could seem
    irrelevant because of this, but the software complexity increases as well. We
    have more complex data to store and process. We need to show animations and do
    a lot of other things.
  prefs: []
  type: TYPE_NORMAL
- en: The first way of solving a performance problem is by adding more power. We can
    add more servers to handle data, but we can't update our clients' PC and mobile
    devices. Also, adding more power doesn't solve the code performance issue itself,
    but just delays it for some time.
  prefs: []
  type: TYPE_NORMAL
- en: The second, and correct, solution is to remove the issue that causes the performance
    problem. For that, we need to identify the problem, the slow piece of the code,
    and improve it.
  prefs: []
  type: TYPE_NORMAL
- en: The key metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many things that impact an application''s performance and user experience.
    We will cover the following key metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: Operations' performance speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk space usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important of these and the one that has the biggest impact is the **operations'
    performance speed**. It tells us how fast a particular task can be performed,
    for example, creating a new user, reading from a file, downloading an image, searching
    for a person with a particular name, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is a powerful and fast programming language. In this chapter, you learned
    about many powerful features of Swift and how easy it is to start coding in Swift
    and integrate it into existing projects. We also covered why performance is important
    and what you should be thinking about when working with it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will do more coding in Swift, and you will learn how
    to use all the features of Swift to make a good application architecture.
  prefs: []
  type: TYPE_NORMAL
