- en: Expressive Functions and Adjustable Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring adjustable functions with default parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring interfaces containing default implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending functionalities of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning multiple data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inlining parameters of closure type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infix notations for functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart types checking with generic reified parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloading operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on exploring a number of Kotlin features that can help
    to write functions and interfaces that are robust, flexible, and clean. After
    reading the following recipes, you will understand the language-specific support
    and approach for boilerplate code reduction and runtime performance improvements.
    You will also understand the way functions of the standard library are implemented
    under the hood and how to work with them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring adjustable functions with default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating new functions, we often need to allow some of their parameters
    to be optional. This forces us to use method overloading to create multiple function
    declarations with the same name but different sets of arguments related to different
    use cases and scenarios. Usually, under the hood, each variant of the function
    is calling the base function with the default implementation. Let''s consider
    a simple example of a function that calculates a displacement of an object moving
    with a constant acceleration rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We might also need to provide a displacement calculation for the scenario where
    the initial speed of the object is always equal to zero. In such a case, we would
    end up with overloading the basic function in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Kotlin allows you to reduce multiple declarations and to handle a
    number of different use cases with a single function having optional parameters.
    In this recipe, we are going to design an adjustable version of the `calculateDisplacement()`function
    with an optional `initialSpeed: Float`parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s declare the basic implementation for the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's declare a default value for the `initialSpeed` parameter*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve declared a default value for the `initialSpeed`parameter, equal to `0`.
    Once we have a default value assigned, the `initialSpeed`parameter becomes an
    optional one. We can now omit it while invoking the function, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, if we are omitting some of the parameters and using their default
    values, we have to specify the values of the other parameters together with their
    names explicitly. This allows the compiler to map the values to the specific parameters.
    Of course, we are able to override the default value using the standard way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin makes it possible to declare interfaces containing default function implementations.
    You can learn more about this feature in the *Declaring interfaces containing
    default implementations* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring interfaces containing default implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin makes the interface a powerful language element by offering the possibility
    to declare default implementations for its functions and to define default values
    of its properties. Those features bring the interface to a whole new level, allowing
    you to use it for more advanced applications than simple contract declarations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to define a reusable interface responsible for
    validating email address values entered by a user into the input field in an abstract
    registration form. The interface will provide two functions. The first one is
    responsible for parsing the email address and deciding if the given value is a
    valid email address, and the second one responsible for extracting a user's login
    from the email text entered into the form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The declaration of an interface with a default function implementation is easy.
    Instead of declaring the function header, we need to include its body too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare a new interface called `EmailValidator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a string property responsible for holding the current text input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `isEmailValid()` function to the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `getUserLogin()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s give it a try and take a look at how we can use the `EmailValidator`
    interface in action. Let''s assume we have a `RegistrationForm` class containing
    a hook method that is invoked every time the input text is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To make use of our `EmailValidator` interface, we need to declare a class that
    is implementing it. We can modify the `RegistrationForm` class to implement the `EmailValidator` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time the `onInputUpdated()` function is invoked, we are updating the
    `input: String` property declared in the `EmailValidator` interface. Once it is
    up to date, we are using the `EmailValidator` interface functions `isEmailValid()`
    and `getUserLogin()` values. Extracting the function implementations to the interface
    makes it possible to reuse them and integrate them easily in a number of classes.
    The only part that needs an actual implementation is the `input` property of the
    `EmailValidator` interface, which holds the current state of the text inserted
    by the user. The smooth way of integrating the `EmailValidator` interface makes
    it great when it comes to reusability and versatility of the application in different
    scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to keep in mind that, although we can define a default function
    implementation in the interface, we are not able to instantiate default values
    for interface properties. Unlike the class properties, properties of an interface
    are abstract. They don't have backing fields that could hold a current value (state).
    If we declare a property inside an interface, we need to implement it in the class
    or object that implements this interface. This is the main difference between
    interfaces and abstract classes. Abstract classes can have constructors and can
    store properties along with their implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Java, we can''t extend multiple classes; however, we can implement
    multiple interfaces. When we have a class implementing multiple interfaces containing
    default implementations, we are at risk of dealing with conflicts caused by functions
    having the same signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we need to override the `foo()` function explicitly to resolve
    the conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we would get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A similar feature of Kotlin is the ability to declare default values of functions'
    parameters. You can learn more about it in the *Declaring adjustable functions
    with default parameters *recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending functionalities of classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on implementing new features or refactoring of existing code,
    we often end up extracting some part of the code to functions in order to reuse
    them in different places. If the extracted function is atomic enough, we often
    end up exporting it to external utility classes whose primary purpose is to extend
    functionalities of existing classes. Kotlin provides an interesting alternative
    to the utility classes. It offers a built-in feature allowing us to extend functionalities
    of other classes with *extension functions* and *extension properties*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to extend the functionality of the `Array<T>`
    classand add a `swap(a:T, b: T)`extension function to it, which is responsible
    for changing places of a two given elements of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can declare extension functions and extension properties inside any file
    in the project. However, to keep them well organized, it's better to put them
    in dedicated files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for extension functions is very similar to the one of the standard
    function. We just need to add information about the type that is being extended
    with the new function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file, `Extensions.kt`, to store the extension function definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `swap()` function inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a result, we are able to call the `swap` function on any instance of the
    `Array` class. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in printing the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can access the current instance of the class inside the extension
    function using the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from extension functions, Kotlin also offers an extension properties
    feature. For example, we can declare a property for the `List<T>` class that will
    hold information about the last element index value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Extensions are a widely used pattern across Kotlin standard library classes.
    They work seamlessly with Java, Kotlin, JavaScript, and native classes defined
    within the project and in external dependencies as well.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is often practical to convert a single object of a complex type into a number
    of variables. This allows you to provide proper naming for the variables and simplifies
    the code. Kotlin provides an easy, built-in way to achieve this with a feature
    called *destructuring*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, this piece of code would print the following message to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty awesome! Destructuring is available for data classes out of the box.
    The Kotlin standard library provides this feature for many common types as well.
    However, destructuring is not available explicitly whenever we are dealing with
    custom, non-data classes. Especially, while working with classes from external
    libraries written in other languages such as Java, we need to define the destructuring
    mechanism manually. In this recipe, we are going to implement destructuring for
    a Java class defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Destructuring declarations in Kotlin are position-based, opposed to property
    name-based declarations available in other languages. This means the Kotlin compiler
    decides which class property is linked to which variable based on the order of
    the properties. In order to allow custom class destructuring, we need to add implementations
    of the functions called `componentN`*, *where *N* refers to the component number marked
    with the `operator` keyword to allow using them in a destructuring declaration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare an extension function returning the `id` property of the `LightBulb`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another extension `componentN` function responsible for returning the `turnedOn`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we declare proper `componentN`functions, we can benefit from destructuring
    of the `LightBulb` type objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code would print the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `component1()` function was assigned to the first variable
    of the destructured declaration—`id`. Similarly, the second `turnedOn` variable
    was assigned with the result of the `component2()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because of the fact that properties in destructured object assignments are
    position-based, sometimes we are forced to declare more variables than we want
    to use. We can use an underscore if we don''t need to use a certain value, avoiding
    the compiler hint indicating an unused variable and simplifying the code a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring is also available for function return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is going to return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use destructured declarations with lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful application of destructured declarations is an iteration. For
    example, we can use this feature to traverse through map entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Returning multiple data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Kotlin doesn't provide a multiple return feature, thanks to data classes
    and destructuring declarations, it is quite convenient to write functions that
    return a number of values of different types. In this recipe, we are going to
    implement a function returning the result of dividing two numbers. The result
    is going to contain the quotient and remainder values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with declaring a data class for the return type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `divide()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see the `divide()` function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is going to print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the fact that we are returning a data class instance, the `DivisionResult` class,
    we can benefit from the destructuring feature and assign the result to a set of
    separate variables.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin standard library provides ready to use `Pair` and `Triple` classes.
    We can use them to return two and three values of any type. This eliminates the
    need to create a dedicated data classes for the return type. On the other hand,
    using data classes gives us the ability to operate on more meaningful names, which
    adds more clarity to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates using the `Pair` class to return two objects
    at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you'd like to get more familiar with destructuring declarations, you can
    take a look at the *Destructuring types *recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inlining parameters of closure type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage of higher-order functions can lead to a decrease of runtime performance.
    Memory allocations of the functions passed as lambda arguments and their virtual
    calls in a function body lead to runtime overhead. However, in many cases, we
    can eliminate this type of overhead by inlining the lambda expression parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to implement the `lock()` function that will automate
    work with the Java `java.util.concurrent.locks.Lock` interface. The function will
    take two arguments—an instance of the `Lock` interface and the function that should
    be invoked after the lock is acquired. Finally, our `lock()` function should release
    the lock. We also want to allow making the function parameter inlined.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To declare an inline function, we simply need to add the `inline` modifier in
    front of the function header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s declare a `lock()` function with two arguments—an instance of the `Lock`
    interface and the function to be invoked after the lock is acquired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `performHavingLock()` function allows us to provide synchronization for
    the function passed to it as the `task` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the `performHavingLock()` function is going to print the following
    output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, the inline modifier affects both the function itself and the
    lambda expressions passed to it. They are all going to be inlined in the underlying
    generated bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If we did not use the `inline` modifier, the compiler would create a separate
    instance of the `Function0` type in order to pass the lambda argument to the `performHavingLock()`
    function. Inlining lambdas may cause the generated code to grow. However, if we
    do it in a reasonable way (that is, avoiding inlining large functions), it will
    pay off in performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want only some of the lambdas passed to the function to be inlined,
    you can mark some of the function parameters with the `noinline` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin also allows declaring inline class properties. The `inline` modifier
    can be used with getter and setter methods of properties that don''t have a backing
    field. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also annotate an entire property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the inlined getters and setters are going to be represented in
    the same way as the regular inline functions.
  prefs: []
  type: TYPE_NORMAL
- en: Infix notations for functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To bring our code closer to the natural language, Kotlin provides infix notations
    for the functions containing a single parameter. This way, we can invoke the function
    without using brackets. In this recipe, we are going to learn how to design an
    infix extension function for the `String` type, named `concat()`, which is responsible
    for the concatenation of two string values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to enable an infix notation for the function, we simply need to add
    the `infix` keyword before the function header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare the `concat()` extension function and implement its body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test the `concat()` function by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We have just printed out the following text to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kotlin standard library uses the infix notation extensively. You can benefit
    from infix functions to shape your code the clean way. One infix function worth
    noting is the `to()` extension function provided for the `Map.Entry<K, V>` class,
    which allows you to declare map entries in a minimalistic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `to()` extension function is declared for a generic type `A` and generic
    argument of type `B`, which returns an instance of a `Pair<A, B>` class.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of other functions supporting infix notations available in
    the standard library. If you check the implementation of the ones you are using
    on a daily basis, it may turn out they are available in the infix form too.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can learn about another cool feature that helps to shape the code to be
    more natural to read in the *Overloading operators *recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart types checking with generic reified parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While implementing functions that support generic type arguments, we often
    deal with the need to provide additional information about object types at runtime.
    On the JVM platform, types have their representations in the `Class<T>` class
    instances. For example, we can face such a need while parsing JSON formatted data
    to the Kotlin class instances using the `Gson` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, we can''t access the generic type argument at runtime because of
    a JVM types erasure. However, Kotlin allows you to overcome this limitation because it
    preserves the type argument at runtime. In this recipe, we are going to tune up
    Gson''s `fromJson(json: String, Class<T>)` function to get rid of the additional
    type argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure you have the Gson dependency included in your project ([https://github.com/google/gson](https://github.com/google/gson)).
    If you are using Gradle, build script that you can fetch it with the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In order to make a type argument accessible at runtime, we need to mark it with
    the `reified` modifier and mark the function as `inline`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file where we will put an extension function implementation (for
    example, `GsonExtensions.kt`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the file, declare an extension function for the `Gson` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented an extension function for the `Gson` type. Thanks to adding
    the `reified` modifier, we can access the generic type argument at runtime and
    pass it to the original `fromGson()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we are able to use the more elegant version of the `fromGson()`
    function in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also benefit from Kotlin smart casting and omit the explicit type
    declaration from the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Overloading operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin language provides a set of operators which have their own symbol (for
    example, `+`, `-`, `*`,  or `/`) and a priority defined. At the time of compilation,
    the Kotlin compiler transforms them into associated function calls or even more
    complex statements. We are also able to override an operator and declare its custom
    underlying implementation for a specified type. This implementation would be applied
    to the instances of the specified type the operator was used with.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to define a class called `Position`, representing
    the current coordinates of the point in a three-dimensional space. Then, we are
    going to implement custom `plus` and `minus` operators for our class to provide
    a simple way of applying a geometric transformation to its instances. As a result,
    we want to be able to update the coordinates of the point represented by the `Position` class
    using the `+` and `-` operator symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to overload the operator for the specific type, we need to provide
    a member function or an extension function with a fixed name corresponding to
    the operator. Additionally, functions that overload operators need to be marked
    with the `operator` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following tables, you can find grouped sets of operators available in
    the language with their corresponding expressions to which they are translated
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unary prefix**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `+a` | `a.unaryPlus()` |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | `a.unaryMinus()` |'
  prefs: []
  type: TYPE_TB
- en: '| `!a` | `a.not()` |'
  prefs: []
  type: TYPE_TB
- en: '**Incrementation and decrementation**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a++` | `a.inc()` |'
  prefs: []
  type: TYPE_TB
- en: '| `a--` | `a.dec()` |'
  prefs: []
  type: TYPE_TB
- en: '**Arithmetic**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a` `+` `b` | `a.plus(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a` `-` `b` | `a.minus(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a` `*` `b`  | `a.times(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a` `/` `b` | `a.div(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a` `%` `b` | `a.rem(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a..b` | `a.rangeTo(b)` |'
  prefs: []
  type: TYPE_TB
- en: '**Inoperator**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a` `in` `b` | `b.contains(a)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a` `!in` `b` | `!b.contains(a)` |'
  prefs: []
  type: TYPE_TB
- en: '**Indexed access**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i]` | `a.get(i)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i, j]` | `a.get(i, j)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i_1, ..., i_n]` | `a.get(i_1, ..., i_n)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i] = b` | `a.set(i, b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i, j] = b` | `a.set(i, j, b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i_1, ..., i_n] = b` | `a.set(i_1, ..., i_n, b)` |'
  prefs: []
  type: TYPE_TB
- en: '**Invoke operator**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a()` | `a.invoke()` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(i)` | `a.invoke(i)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(i, j)` | `a.invoke(i, j)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(i_1, ..., i_n)` | `a.invoke(i_1, ..., i_n)` |'
  prefs: []
  type: TYPE_TB
- en: '**Augmented assignment**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a += b` | `a.plusAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a -= b ` | `a.minusAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a *= b` | `a.timesAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a /= b` | `a.divAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a %= b` | `a.remAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '**Equality and comparison**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a == b` | `a?.equals(b) ?: (b === null)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a != b` | `!(a?.equals(b) ?: (b === null))` |'
  prefs: []
  type: TYPE_TB
- en: '| `a > b` | `a.comareTo(b) > 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `a < b` | `a.compareTo(b) < 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `a >= b` | `a.compareTo(b) >= 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `a <= b` | `a.compareTo(b) <= 0` |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declare the `Position` data class with `x`, `y`, `z`  properties related to
    the current position in the Cartesian coordinates system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `plus` operator implementation for the `Position` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Overload the `minus` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can use the `Position` class together with `plus` and `minus` operators.
    Let''s try using the minus operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. The preceding code is going to print the following result to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the operators have their corresponding compound *assign *operators
    defined. Once we have overloaded the `plus` and `minus`operators, we can use the `plusAssign
    (+=)` and `minusAssign (-=)`operators automatically. For example, we can use the `plusAssign`operator
    to update the `Position`instance state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we will get the `position`variable with the following state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the *assign *operator returns the `Unit`*.* This
    makes it a better choice than an original basic operator (for example, `plus`or `minus`)
    in terms of memory allocations efficiency when updating an instance. In contrast,
    the base operators are returning new instances every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to know that Kotlin offers operators overloading for Java classes
    as well. To overload the operator, we just need to add a proper method to the
    class that has the name of the operator and the `public` visibility modifier.
    Here is what the Java version of the `Position` class with the overloaded `plus`operator
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is how it could be used in Kotlin code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kotlin standard library also contains predefined implementations of different
    operators. One that you should use on a daily basis is the `plus` operator for
    a `MutableCollection` type. This allows for adding new elements to the collection
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the preceding code will print the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
