["```java\n    #version 300 es             \n    in vec4     VertexPosition;     \n    in vec4     VertexColor;        \n    uniform float  RadianAngle;\n\n    out vec4     TriangleColor;     \n    mat2 rotation = mat2(cos(RadianAngle),sin(RadianAngle),\n                        -sin(RadianAngle),cos(RadianAngle));\n    void main() {\n      gl_Position = mat4(rotation)*VertexPosition;\n      TriangleColor = VertexColor;\n    }\n    ```", "```java\n    #version 300 es         \n    precision mediump float;\n    in vec4   TriangleColor;  \n    out vec4  FragColor;     \n    void main() {           \n      FragColor = TriangleColor;\n    };\n    ```", "```java\n    GLuint loadAndCompileShader(GLenum shaderType, const char* sourceCode) {\n         // Create the shader\n      GLuint shader = glCreateShader(shaderType);\n      if ( shader ) {\n         // Pass the shader source code\n         glShaderSource(shader, 1, &sourceCode, NULL);\n\n         // Compile the shader source code\n         glCompileShader(shader);\n\n         // Check the status of compilation\n         GLint compiled = 0;\n         glGetShaderiv(shader,GL_COMPILE_STATUS,&compiled);\n         if (!compiled) {\n\n          // Get the info log for compilation failure\n           GLint infoLen = 0;\n           glGetShaderiv(shader,GL_INFO_LOG_LENGTH, &infoLen);\n           if (infoLen) {\n              char* buf = (char*) malloc(infoLen);\n              if (buf) {\n                glGetShaderInfoLog(shader, infoLen, NULL, buf);\n                printf(\"Could not compile shader %s:\" buf);\n                free(buf);\n              }\n\n          // Delete the shader program\n              glDeleteShader(shader);\n              shader = 0;\n           }\n        }\n      }\n      return shader;\n    }\n    ```", "```java\n        GLuint glCreateShader(  Glenum shaderType);\n        ```", "```java\n        // Create the shader object\n        GLuint shader = glCreateShader(shaderType);\n        ```", "```java\n        // Load the shader source code\n        glShaderSource(shader, 1, &sourceCode, NULL);\n        ```", "```java\n        void glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length);\n        ```", "```java\n           glCompileShader(shader);    // Compile the shader\n    ```", "```java\n        void glCompileShader (GLuint shader);\n        ```", "```java\n         GLint compiled = 0;    // Check compilation status\n         glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n    ```", "```java\n        void glGetShaderiv(GLuint shader, GLenum pname, GLint *params);\n        ```", "```java\n               if (!compiled) {      // Handle Errors\n                  GLint infoLen = 0; // Check error string length\n                  glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);\n                  . . . . .\n               }\n        ```", "```java\n        void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei*length, GLchar* infoLog);\n        ```", "```java\n        void glDeleteShader(GLuint shader);\n        ```", "```java\n    return shader; // Return the shader object ID\n    ```", "```java\nstatic void printGLString(const char *name, GLenum s) {\n    printf(\"GL %s = %s\\n\", name, (const char *) glGetString(s));\n}\n// Print the OpenGL ES system metrics\nvoid printOpenGLESInfo(){\n   printGLString(\"Version\",    GL_VERSION);\n   printGLString(\"Vendor\",    GL_VENDOR);\n   printGLString(\"Renderer\",    GL_RENDERER);\n   printGLString(\"Extensions\",    GL_EXTENSIONS);\n   printGLString(\"GLSL version\",  GL_SHADING_LANGUAGE_VERSION);\n}\n```", "```java\n    GLuint linkShader(GLuint vertShaderID,GLuint fragShaderID){\n        if (!vertShaderID || !fragShaderID){ // Fails! return\n       return 0; \n     }\n\n       // Create an empty program object\n        GLuint program = glCreateProgram();\n        if (program) {\n       // Attach vertex and fragment shader to it\n          glAttachShader(program, vertShaderID);\n          glAttachShader(program, fragShaderID);\n\n       // Link the program\n    glLinkProgram(program);\n          GLint linkStatus = GL_FALSE;\n          glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);\n\n          if (linkStatus != GL_TRUE) {\n              GLint bufLength = 0;\n              glGetProgramiv(program, GL_INFO_LOG_LENGTH,\n              &bufLength);\n              if (bufLength) {\n                 char* buf = (char*) malloc(bufLength);\n    if(buf) { glGetProgramInfoLog(program,bufLength,NULL,buf);\n              printf(\"Could not link program:\\n%s\\n\", buf);\n                free(buf);\n                }\n             }\n              glDeleteProgram(program);\n              program = 0;\n          }\n      }\n      return program;\n    }\n    ```", "```java\n    GLuint program = glCreateProgram(); //Create shader program\n    ```", "```java\n        GLint glCreateProgram( void);\n        ```", "```java\n     // Attach the vertex and fragment shader\n     glAttachShader(program, vertShaderID);\n     glAttachShader(program, fragShaderID);\n    ```", "```java\n        void glAttachShader(GLuint program, GLuint shader);\n        ```", "```java\n    glLinkProgram(program); // Link the shader program\n    ```", "```java\n        void glGetProgramiv(GLuint program, GLenum pname, GLint *params);\n        ```", "```java\n        void glDeleteProgram(Glint program);\n        ```", "```java\nstatic void checkGlError(const char* op) {\n     for(GLint error = glGetError(); error; error= glGetError()){\n        printf(\"after %s() glError (0x%x)\\n\", op, error);\n     }\n}\n```", "```java\nGLenum glGetError(void);\n```", "```java\n// Gives a GL_INVALID_ENUM error\nglEnable(GL_TRIANGLES);\n\n// Gives a GL_INVALID_VALUE\n// when attribID >= GL_MAX_VERTEX_ATTRIBS\nglEnableVertexAttribArray(attribID);\n```", "```java\n// Incoming vertex info from program to vertex shader\nin vec4  VertexPosition;\nin vec4  VertexColor;\n```", "```java\n    GLuint positionAttribHandle;\n    GLuint colorAttribHandle;\n    ```", "```java\n    positionAttribHandle = glGetAttribLocation\n    (programID, \"VertexPosition\");\n    colorAttribHandle    = glGetAttribLocation\n    (programID, \"VertexColor\");\n    ```", "```java\n        GLint glGetAttribLocation(GLuint program, const GLchar *name);\n        ```", "```java\n    // Send data to shader using queried attrib location\n    glVertexAttribPointer(positionAttribHandle, 2, GL_FLOAT,\n          GL_FALSE, 0, gTriangleVertices);\n    glVertexAttribPointer(colorAttribHandle, 3, GL_FLOAT, GL_FALSE, 0, gTriangleColors);\n    ```", "```java\n        void glVertexAttribPointer(GLuint index, GLint size, GLenum type,  GLboolean normalized, GLsizei stride, const GLvoid * pointer);\n        ```", "```java\n        // Enable vertex position attribute\n        glEnableVertexAttribArray(positionAttribHandle);\n        glEnableVertexAttribArray(colorAttribHandle);\n    ```", "```java\n        void glEnableVertexAttribArray(GLuint index);\n        ```", "```java\n    in vec4 VertexColor; // Incoming data from CPU\n    . . .\n    out vec4 TriangleColor; // Outgoing to next stage\n    void main() {\n          . . . \n          TriangleColor = VertexColor;\n    }\n    ```", "```java\n    in vec4   TriangleColor; // Incoming from vertex shader\n    out vec4   FragColor;     // The fragment color\n    void main() {           \n          FragColor = TriangleColor;\n    };\n    ```", "```java\n// Uniform variable for rotating triangle\nuniform float  RadianAngle;\n```", "```java\n    GLuint radianAngle;\n    ```", "```java\n    radianAngle=glGetUniformLocation(programID,\"RadianAngle\");\n    ```", "```java\n        GLint glGetUniformLocation(GLuint program,const GLchar *name)\n        ```", "```java\n    float degree = 0; // Global degree variable\n    float radian;     // Global radian variable\n\n    // Update angle and convert it into radian\n    radian = degree++/57.2957795; \n    // Send updated data in the vertex shader uniform \n    glUniform1f(radianAngle, radian);\n    ```", "```java\n        void glUniform1f(GLint location, GLfloat v0);\n        ```", "```java\n    . . . . \n    uniform float  RadianAngle;\n    mat2 rotation = mat2(cos(RadianAngle),sin(RadianAngle),\n                        -sin(RadianAngle),cos(RadianAngle));\n    void main() {\n      gl_Position = mat4(rotation)*VertexPosition;\n      . . . . .\n    }\n    ```", "```java\nmat2 rotation = mat2(cos(RadianAngle),sin(RadianAngle),\n              -sin(RadianAngle),cos(RadianAngle));\n```", "```java\n    GLuint createProgramExec(const char* vertexSource, const\n                                       char* fragmentSource) {\n    GLuint vsID = loadAndCompileShader(GL_VERTEX_SHADER,\n    vertexSource);\n    GLuint fsID = loadAndCompileShader(GL_FRAGMENT_SHADER, \n    fragmentSource);\n       return linkShader(vsID, fsID);\n    }\n    ```", "```java\n    GLuint programID; // Global shader program handler\n    bool GraphicsInit(){\n\n    // Print GLES3.0 system metrics\n    printOpenGLESInfo();\n\n    // Create program object and cache the ID\n    programID = createProgramExec(vertexShader,\n    fragmentShader);\n        if (!programID) { // Failure !!! return \n           printf(\"Could not create program.\"); return false;\n        }\n        checkGlError(\"GraphicsInit\"); // Check for errors\n    }\n    ```", "```java\n    // Set viewing window dimensions \n    bool GraphicsResize( int width, int height ){\n        glViewport(0, 0, width, height);\n    }\n    ```", "```java\n        void glViewport( GLint x, GLint y, GLsizei width, GLsizei height);\n        ```", "```java\n    GLfloat gTriangleVertices[] = { \n    { 0.0f,  0.5f}, // Vertex 0\n    {-0.5f, -0.5f}, // Vertex 1\n    { 0.5f, -0.5f}  // Vertex 2\n    }; // Triangle vertices\n    ```", "```java\n    bool GraphicsRender(){\n        // Which buffer to clear? â€“ color buffer\n        glClear( GL_COLOR_BUFFER_BIT );\n\n        // Clear color with black color\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n\n        // Use shader program and apply \n        glUseProgram( programID );\n        radian = degree++/57.2957795;\n\n    // Query and send the uniform variable.    \n    radianAngle = glGetUniformLocation(programID, \"RadianAngle\");\n        glUniform1f(radianAngle, radian);\n\n        // Query 'VertexPosition' from vertex shader\n        positionAttribHandle = glGetAttribLocation\n                                (programID, \"VertexPosition\");\n        colorAttribHandle    = glGetAttribLocation\n                                 (programID, \"VertexColor\");\n\n        // Send data to shader using queried attribute\n        glVertexAttribPointer(positionAttribHandle, 2, \n                   GL_FLOAT, GL_FALSE, 0, gTriangleVertices);\n        glVertexAttribPointer(colorAttribHandle, 3, \n                  GL_FLOAT, GL_FALSE, 0, gTriangleColors);\n\n        // Enable vertex position attribute\n        glEnableVertexAttribArray(positionAttribHandle);\n        glEnableVertexAttribArray(colorAttribHandle);\n\n        // Draw 3 triangle vertices from 0th index\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n    }\n    ```", "```java\n        void glClear( GLbitfield mask )\n        ```", "```java\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n        ```", "```java\n        void glUseProgram(GLuint program);\n        ```", "```java\n    // Query attribute location & send data using them\n    positionAttribHandle = glGetAttribLocation\n                             (programID, \"VertexPosition\");\n    colorAttribHandle = glGetAttribLocation\n                             (programID, \"VertexColor\");\n    glVertexAttribPointer(positionAttribHandle, 2, GL_FLOAT,\n    GL_FALSE, 0, gTriangleVertices);\n    glVertexAttribPointer(colorAttribHandle, 3, GL_FLOAT, \n                             GL_FALSE, 0, gTriangleColors);\n    ```", "```java\n    glEnableVertexAttribArray(positionAttribHandle);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n    ```", "```java\n    package com.cookbookgles;\n\n    import android.os.Bundle;\n    import android.widget.TextView;\n    import android.app.Activity;\n\n    public class NativeDevActivity extends Activity {\n\n       static {\n         //Comment #1\n         // \"jniNativeDev.dll\" in Windows.\n         System.loadLibrary(\"jniNativeDev\");\n       }\n\n         //Comment #2\n         // Native method that returns a Java String\n         // to be displayed on the TextView\n         public native String getMessage();\n\n         @Override\n         public void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n\n         //Comment #3\n         // Create a TextView widget.\n         TextView textView = new TextView(this);\n\n         //Comment #4\n         // Retrieve the text from native method\n         // getMessage() and set as text to be displayed\n         textView.setText(getMessage());\n         setContentView(textView);\n       }\n    }\n    ```", "```java\n        #ifndef _Included_com_cookbook_JNIActivity\n        #define _Included_com_cookbook_JNIActivity\n        #include <jni.h>\n\n        JNIEXPORT jstring JNICALL Java_com_cookbookgles_ NativeDevActivity_getMessage(JNIEnv *, jobject);\n\n        #endif\n        ```", "```java\n        #include \"include/HelloCookbookJNI.h\"\n\n        JNIEXPORT jstring JNICALL Java_com_cookbookgles_ NativeDevActivity_getMessage(JNIEnv *env, jobject thisObj){\n            return (*env)->NewStringUTF(env, \n                       \"Hello from Cookbook native code.\");\n        }\n\n        ```", "```java\n    JNIEXPORT <return type> JNICALL <static function name> (JNIEnv *, jobject);\n    ```", "```java\n        com.cookbookgles -> NativeDevActivity.java -> getMessage()\n    ```", "```java\n    Java_com_cookbookgles_NativeDevActivity_getMessage\n    ```", "```java\n    JNIEXPORT jstring JNICALL Java_com_cookbookgles_NativeDevActivity_getMessage (JNIEnv *, jobject);\n    ```", "```java\n    // Android.mk\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LOCAL_MODULE    := JNINativeDev\n    LOCAL_SRC_FILES := HelloCookbookJNI.c\n\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```java\n    System.loadLibrary(\"jniNativeDev\");\n    ```", "```java\n        private static double glVersion = 3.0;\n        int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, (int) glVersion, EGL10.EGL_NONE };\n        EGLContext context = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT,  attrib_list);\n        ```", "```java\n    //AppDelegate.h\n    #import <UIKit/UIKit.h>\n\n    @class ViewController;\n    @interface AppDelegate : UIResponder <UIApplicationDelegate>\n    @property (strong, nonatomic) UIWindow *window;\n    @property (strong, nonatomic) ViewController *viewController;\n    @end\n    ```", "```java\n// AppDelegate.m\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\nself.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen]  bounds]] autorelease];\n// Override point for customization after application launch.\nself.viewController = [[[ViewController alloc] initWithNibName:@\"ViewController\" bundle:nil] autorelease];\nself.window.rootViewController = self.viewController;\n[self.window makeKeyAndVisible];\nreturn YES;\n}\n```", "```java\n//  ViewController.mm\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n\n  self.context = [[[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3] autorelease];\n  if (!self.context) {\n    NSLog(@\"Failed to create ES context\");\n  }\n\n  GLKView *view = (GLKView *)self.view;\n  view.context = self.context;\n  view.drawableDepthFormat = GLKViewDrawableDepthFormat24;\n\n  [self setupGL];\n}\n```", "```java\n//  ViewController.mm\n- (void)setupGL\n{\n  [EAGLContext setCurrentContext:self.context];\n  GLint defaultFBO, defaultRBO;\n\n  glGetIntegerv(GL_FRAMEBUFFER_BINDING &defaultFBO);\n  glGetIntegerv(GL_RENDERBUFFER_BINDING, &defaultRBO);\n  glBindFramebuffer( GL_FRAMEBUFFER, defaultFBO );\n  glBindRenderbuffer( GL_RENDERBUFFER, defaultRBO );\n\n  setupGraphics(self.view.bounds.size.width,\n  self.view.bounds.size.height);\n\n}\n```", "```java\n//  ViewController.mm\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect\n{\n    renderFrame();\n}\n```"]