<html><head></head><body>
<div id="_idContainer080" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor067" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-62" class="calibre6"><a id="_idTextAnchor068" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Architect Your App</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.3.1">The process of developing apps needs to be scalable in such a way that you can maintain the app over a long time and easily hand over the development of it to other developers or teams. </span><span class="kobospan" id="kobo.3.2">To be able to do this, we need to properly think about the architecture of our apps. </span><span class="kobospan" id="kobo.3.3">We will be looking at how to build our apps in </span><span><span class="kobospan" id="kobo.4.1">this chapter.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.5.1">In this chapter, we will build on what we’ve learned from the previous chapters. </span><span class="kobospan" id="kobo.5.2">We are going to look at the different architectures available for Android projects. </span><span class="kobospan" id="kobo.5.3">We’ll dive deep into </span><strong class="bold"><span class="kobospan" id="kobo.6.1">MVVM architecture</span></strong><span class="kobospan" id="kobo.7.1"> and its different layers and how to use some of the Jetpack libraries within their architecture. </span><span class="kobospan" id="kobo.7.2">Additionally, we’ll learn how to use advanced architecture features, such as dependency injection and Kotlin Gradle DSL, as well as version catalogs to </span><span><span class="kobospan" id="kobo.8.1">define dependencies.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.9.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.10.1">main topics:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.11.1">Introduction to </span><span><span class="kobospan" id="kobo.12.1">app architecture</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.13.1">MVVM </span><span><span class="kobospan" id="kobo.14.1">deep dive</span></span></li>
<li class="calibre15"><span><span class="kobospan" id="kobo.15.1">Jetpack libraries</span></span></li>
<li class="calibre15"><span><span class="kobospan" id="kobo.16.1">Dependency injection</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.17.1">Migrating to Kotlin Gradle DSL and using </span><span><span class="kobospan" id="kobo.18.1">version catalogs</span></span></li>
</ul>
<h1 id="_idParaDest-63" class="calibre6"><a id="_idTextAnchor069" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.19.1">Technical Requirements</span></h1>
<p class="calibre4"><a id="_idTextAnchor070" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.20.1">To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (</span><a href="https://developer.android.com/studio" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.21.1">https://developer.android.com/studio</span></a><span class="kobospan" id="kobo.22.1">) downloaded. </span></p>
<p class="calibre4"><span class="kobospan" id="kobo.23.1">You can find the code for this chapter </span><span><span class="kobospan" id="kobo.24.1">at </span></span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive" class="calibre3 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.25.1">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfive</span></span></a><span><span class="kobospan" id="kobo.26.1">.</span></span></p>
<h1 id="_idParaDest-64" class="calibre6"><a id="_idTextAnchor071" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.27.1">Introduction to app architecture</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.28.1">So far, we have learned how to create apps and designed beautiful UIs with Material 3 and Jetpack Compose. </span><span class="kobospan" id="kobo.28.2">We haven’t yet started adopting any architecture for our apps. </span><span class="kobospan" id="kobo.28.3">In this section, we will look at some of the app architectures that we can use to build our apps. </span><span class="kobospan" id="kobo.28.4">We will also look at some of the best practices that we can follow when building our apps. </span><span class="kobospan" id="kobo.28.5">First, let’s see some of the benefits of using an </span><span><span class="kobospan" id="kobo.29.1">app architecture:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.30.1">Separation of concerns</span></strong><span class="kobospan" id="kobo.31.1">: Using an architecture allows us to separate our code into different layers. </span><span class="kobospan" id="kobo.31.2">Each</span><a id="_idIndexMarker207" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.32.1"> layer only does one thing. </span><span class="kobospan" id="kobo.32.2">This makes it easy to separate and group our code into different layers. </span><span class="kobospan" id="kobo.32.3">Each layer has its responsibility. </span><span class="kobospan" id="kobo.32.4">This prevents things from being mixed up and makes it easier to maintain </span><span><span class="kobospan" id="kobo.33.1">our code.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.34.1">Easy testing</span></strong><span class="kobospan" id="kobo.35.1">: Using an architecture makes it easy to test our code. </span><span class="kobospan" id="kobo.35.2">We can easily test each layer of our code in isolation since things are not </span><span><span class="kobospan" id="kobo.36.1">tightly coupled.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.37.1">Easy to maintain</span></strong><span class="kobospan" id="kobo.38.1">: Using an architecture makes it easy to maintain our code. </span><span class="kobospan" id="kobo.38.2">We can easily make changes to our code without affecting other parts of our code. </span><span class="kobospan" id="kobo.38.3">This makes it easy to maintain our code over the long term. </span><span class="kobospan" id="kobo.38.4">We can also swap in and out different parts of the code, and since we have tests, we can test the different implementations and ensure that </span><span><span class="kobospan" id="kobo.39.1">nothing breaks.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.40.1">Easy to scale</span></strong><span class="kobospan" id="kobo.41.1">: Using an architecture makes it easy to scale our code. </span><span class="kobospan" id="kobo.41.2">We can easily add new features to our code without affecting other parts of </span><span><span class="kobospan" id="kobo.42.1">our code.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.43.1">Easy to work in teams</span></strong><span class="kobospan" id="kobo.44.1">: Using an architecture makes it easy to work in teams. </span><span class="kobospan" id="kobo.44.2">Each team member or team can work on a different layer of the code. </span><span class="kobospan" id="kobo.44.3">It makes it possible to work concurrently on different parts of </span><span><span class="kobospan" id="kobo.45.1">the codebase.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.46.1">Promotes reusability</span></strong><span class="kobospan" id="kobo.47.1">: Over time, we can place some of the commonly used code across the projects in common packages or modules, which can then be re-used across the project without having to repeat </span><span><span class="kobospan" id="kobo.48.1">the code.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.49.1">When it comes to choosing an architecture for our apps, there are a lot of options that we can choose from. </span><span class="kobospan" id="kobo.49.2">There isn’t a particular architecture that fits all the use cases, so it’s always recommended that we discuss things with our teams and see which architecture fits the use case. </span><span class="kobospan" id="kobo.49.3">Each architecture has its pros and cons, and we or the whole team have to evaluate which one</span><a id="_idIndexMarker208" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.50.1"> has more pros than cons. </span><span class="kobospan" id="kobo.50.2">We can architect our app either by feature or by layers. </span><span class="kobospan" id="kobo.50.3">When we architect by feature, we have layers that represent a feature. </span><span class="kobospan" id="kobo.50.4">When we architect by layers, we have layers that represent a layer of our app. </span><span class="kobospan" id="kobo.50.5">An example of architecting by feature is shown in the </span><span><span class="kobospan" id="kobo.51.1">following points:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span><span class="kobospan" id="kobo.52.1">Home feature</span></span></li>
<li class="calibre15"><span><span class="kobospan" id="kobo.53.1">Profile feature</span></span></li>
<li class="calibre15"><span><span class="kobospan" id="kobo.54.1">Settings feature</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.55.1">The preceding example shows how we can architect our app by feature. </span><span class="kobospan" id="kobo.55.2">We have the </span><strong class="bold"><span class="kobospan" id="kobo.56.1">Home</span></strong><span class="kobospan" id="kobo.57.1">, </span><strong class="bold"><span class="kobospan" id="kobo.58.1">Profile</span></strong><span class="kobospan" id="kobo.59.1">, and </span><strong class="bold"><span class="kobospan" id="kobo.60.1">Settings</span></strong><span class="kobospan" id="kobo.61.1"> features. </span><span class="kobospan" id="kobo.61.2">Each feature has its layers and all the code related to </span><span><span class="kobospan" id="kobo.62.1">that feature.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.63.1">Some of the architectures that we can use to build our apps are </span><span><span class="kobospan" id="kobo.64.1">the following:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.65.1">Model, View, and ViewModel</span></strong><span class="kobospan" id="kobo.66.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.67.1">MVVM</span></strong><span class="kobospan" id="kobo.68.1">): This is the most commonly used architecture and is even </span><a id="_idIndexMarker209" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.69.1">recommended by Google to use with our apps. </span><span class="kobospan" id="kobo.69.2">The app has the </span><strong class="bold"><span class="kobospan" id="kobo.70.1">Model</span></strong> <strong class="bold"><span class="kobospan" id="kobo.71.1">View</span></strong><span class="kobospan" id="kobo.72.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.73.1">ViewModel</span></strong><span class="kobospan" id="kobo.74.1"> layers. </span><span class="kobospan" id="kobo.74.2">The Model layer is responsible for holding the data. </span><span class="kobospan" id="kobo.74.3">The View layer is responsible for displaying the data. </span><span class="kobospan" id="kobo.74.4">The ViewModel layer is responsible for holding the state of the data. </span><span class="kobospan" id="kobo.74.5">It is also responsible for communicating with the </span><a id="_idIndexMarker210" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.75.1">Model and View layers. </span><span class="kobospan" id="kobo.75.2">MMVM promotes the clear separation of concerns between the different layers. </span><span class="kobospan" id="kobo.75.3">It also </span><a id="_idIndexMarker211" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.76.1">supports </span><strong class="bold"><span class="kobospan" id="kobo.77.1">data binding</span></strong><span class="kobospan" id="kobo.78.1">, which makes it easy to update the UI when the data change. </span><span class="kobospan" id="kobo.78.2">It also supports testing since the different layers are not tightly coupled. </span><span class="kobospan" id="kobo.78.3">It also has less boilerplate code when compared to other architectures. </span><span class="kobospan" id="kobo.78.4">However, it has its downsides, one of them being a large learning curve at times and this can become complex very easily, especially with lots </span><span><span class="kobospan" id="kobo.79.1">of features.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.80.1">Model View Intent</span></strong><span class="kobospan" id="kobo.81.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.82.1">MVI</span></strong><span class="kobospan" id="kobo.83.1">): This has three key layers. </span><span class="kobospan" id="kobo.83.2">The </span><strong class="bold"><span class="kobospan" id="kobo.84.1">Model</span></strong><span class="kobospan" id="kobo.85.1"> layer is responsible for holding the data. </span><span class="kobospan" id="kobo.85.2">The </span><strong class="bold"><span class="kobospan" id="kobo.86.1">View</span></strong><span class="kobospan" id="kobo.87.1"> layer is responsible for displaying the data. </span><span class="kobospan" id="kobo.87.2">The </span><strong class="bold"><span class="kobospan" id="kobo.88.1">Intent</span></strong><span class="kobospan" id="kobo.89.1"> layer represents </span><a id="_idIndexMarker212" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.90.1">user actions or events that are dispatched to</span><a id="_idIndexMarker213" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.91.1"> the model to update a state. </span><span class="kobospan" id="kobo.91.2">MVI promotes unidirectional </span><strong class="bold"><span class="kobospan" id="kobo.92.1">data flow</span></strong><span class="kobospan" id="kobo.93.1">, where data flow in the </span><span><span class="kobospan" id="kobo.94.1">same direction.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.95.1">Model View Controller</span></strong><span class="kobospan" id="kobo.96.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.97.1">MVC</span></strong><span class="kobospan" id="kobo.98.1">): This architecture has three layers. </span><span class="kobospan" id="kobo.98.2">The </span><strong class="bold"><span class="kobospan" id="kobo.99.1">Model</span></strong><span class="kobospan" id="kobo.100.1"> layer represents the business logic and holds the data. </span><span class="kobospan" id="kobo.100.2">The </span><strong class="bold"><span class="kobospan" id="kobo.101.1">View</span></strong><span class="kobospan" id="kobo.102.1"> layer is responsible for displaying the data. </span><span class="kobospan" id="kobo.102.2">The </span><strong class="bold"><span class="kobospan" id="kobo.103.1">Controller</span></strong><span class="kobospan" id="kobo.104.1"> layer is responsible for and acts as an intermediary</span><a id="_idIndexMarker214" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.105.1"> between the model and the view. </span><span class="kobospan" id="kobo.105.2">It takes care of the user input and updates the view and the model. </span><span class="kobospan" id="kobo.105.3">MVC is very straightforward, especially when starting out, and enables quick iterations and a showcase of app architecture. </span><span class="kobospan" id="kobo.105.4">Its only problem is that it has a tight coupling between the layers, making it hard to test </span><span><span class="kobospan" id="kobo.106.1">and scale.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.107.1">Model View Presenter</span></strong><span class="kobospan" id="kobo.108.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.109.1">MVP</span></strong><span class="kobospan" id="kobo.110.1">): This architecture has three layers. </span><span class="kobospan" id="kobo.110.2">The </span><strong class="bold"><span class="kobospan" id="kobo.111.1">Model</span></strong><span class="kobospan" id="kobo.112.1"> layer represents the business logic and holds the data. </span><span class="kobospan" id="kobo.112.2">The </span><strong class="bold"><span class="kobospan" id="kobo.113.1">View</span></strong><span class="kobospan" id="kobo.114.1"> layer displays the data and UI components</span><a id="_idIndexMarker215" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.115.1"> and observes user interactions. </span><span class="kobospan" id="kobo.115.2">The views delegate all UI-related logic to the presenters. </span><span class="kobospan" id="kobo.115.3">The </span><strong class="bold"><span class="kobospan" id="kobo.116.1">Presenter</span></strong><span class="kobospan" id="kobo.117.1"> layer contains presentation logic and acts as an intermediary between the</span><a id="_idIndexMarker216" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.118.1"> model and the view. </span><span class="kobospan" id="kobo.118.2">It processes the user input and updates the view and the model. </span><span class="kobospan" id="kobo.118.3">MVP has a good separation of concerns, and the code is easily testable. </span><span class="kobospan" id="kobo.118.4">However, it has a lot of boilerplate code since every view must have its own presenter. </span><span class="kobospan" id="kobo.118.5">It also has a large learning curve and can become complex </span><span><span class="kobospan" id="kobo.119.1">very easily.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.120.1">Now that we understand the different architectures, let us look at MVVM and how we can use it in </span><span><span class="kobospan" id="kobo.121.1">our apps.</span></span></p>
<h1 id="_idParaDest-65" class="calibre6"><a id="_idTextAnchor072" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.122.1">Deep Diving into MVVM</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.123.1">We have already seen the MVVM layers and their pros and cons. </span><span class="kobospan" id="kobo.123.2">In this section, we are going to implement the MMVM architecture in our app step by step. </span><span class="kobospan" id="kobo.123.3">We will start with the model layer, going upwards. </span><span class="kobospan" id="kobo.123.4">Since we all love to have the company of our pets, we are going to use different </span><a id="_idIndexMarker217" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.124.1">types of pets as </span><span><span class="kobospan" id="kobo.125.1">our data.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.126.1">Let us start by creating a </span><strong class="bold"><span class="kobospan" id="kobo.127.1">data</span></strong><span class="kobospan" id="kobo.128.1"> package for our project. </span><span class="kobospan" id="kobo.128.2">We’ll do this by right-clicking the </span><strong class="source-inline"><span class="kobospan" id="kobo.129.1">com.packt.chapterfive</span></strong><span class="kobospan" id="kobo.130.1"> package; then, we select </span><strong class="bold"><span class="kobospan" id="kobo.131.1">New | Package</span></strong><span class="kobospan" id="kobo.132.1"> and name it </span><strong class="source-inline"><span class="kobospan" id="kobo.133.1">data</span></strong><span class="kobospan" id="kobo.134.1">. </span><span class="kobospan" id="kobo.134.2">Inside this </span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">data</span></strong><span class="kobospan" id="kobo.136.1"> package, let us create a </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">Pet</span></strong><span class="kobospan" id="kobo.138.1"> data class that will represent </span><span><span class="kobospan" id="kobo.139.1">our pets:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.140.1">
data class Pet(
    val id: Int,
    val name: String,
    val species: String
)</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.141.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.142.1">Pet</span></strong><span class="kobospan" id="kobo.143.1"> data class holds all the data for our pets. </span><span class="kobospan" id="kobo.143.2">Next, we will create a repository interface and its implementation that allows us to get these pets. </span><span class="kobospan" id="kobo.143.3">Create a new file named </span><strong class="source-inline"><span class="kobospan" id="kobo.144.1">PetsRepository</span></strong><span class="kobospan" id="kobo.145.1"> inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.146.1">data</span></strong><span class="kobospan" id="kobo.147.1"> package with the </span><span><span class="kobospan" id="kobo.148.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.149.1">
interface PetsRepository {
    fun getPets(): List&lt;Pet&gt;
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.150.1">This is an interface with one method that returns </span><strong class="source-inline"><span class="kobospan" id="kobo.151.1">List&lt;Pet&gt;</span></strong><span class="kobospan" id="kobo.152.1">. </span><span class="kobospan" id="kobo.152.2">Next, let us create the implementation class for our interface. </span><span class="kobospan" id="kobo.152.3">While still inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.153.1">data</span></strong><span class="kobospan" id="kobo.154.1"> package, create a new file named </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">PetsRepositoryImpl</span></strong><span class="kobospan" id="kobo.156.1"> with the </span><span><span class="kobospan" id="kobo.157.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.158.1">
class PetsRepositoryImpl: PetsRepository {
    override fun getPets(): List&lt;Pet&gt; {
        return listOf(
            Pet(1, "Bella", "Dog"),
            Pet(2, "Luna", "Cat"),
            Pet(3, "Charlie", "Dog"),
            Pet(4, "Lucy", "Cat"),
            Pet(5, "Cooper", "Dog"),
            Pet(6, "Max", "Cat"),
            Pet(7, "Bailey", "Dog"),
            Pet(8, "Daisy", "Cat"),
            Pet(9, "Sadie", "Dog"),
            Pet(10, "Lily", "Cat"),
        )
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.159.1">To explain what the preceding</span><a id="_idIndexMarker218" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.160.1"> code does, please see </span><span><span class="kobospan" id="kobo.161.1">the following:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.162.1">We created a class named </span><strong class="source-inline1"><span class="kobospan" id="kobo.163.1">PetsRepositoryImpl</span></strong><span class="kobospan" id="kobo.164.1">, which implements the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.165.1">PetsRepository</span></strong></span><span><span class="kobospan" id="kobo.166.1"> interface</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.167.1">We override the </span><strong class="source-inline1"><span class="kobospan" id="kobo.168.1">getPets()</span></strong><span class="kobospan" id="kobo.169.1"> method and return a list of pets. </span><span class="kobospan" id="kobo.169.2">Our list has 10 pets with </span><strong class="bold"><span class="kobospan" id="kobo.170.1">ID</span></strong><span class="kobospan" id="kobo.171.1">, </span><strong class="bold"><span class="kobospan" id="kobo.172.1">name</span></strong><span class="kobospan" id="kobo.173.1">, </span><span><span class="kobospan" id="kobo.174.1">and </span></span><span><strong class="bold"><span class="kobospan" id="kobo.175.1">species</span></strong></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.176.1">We have used a pattern </span><a id="_idIndexMarker219" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.177.1">called the </span><strong class="bold"><span class="kobospan" id="kobo.178.1">repository pattern</span></strong><span class="kobospan" id="kobo.179.1"> to get our pets. </span><span class="kobospan" id="kobo.179.2">The repository pattern is a pattern that allows us to abstract the data layer from the rest of the app. </span><span class="kobospan" id="kobo.179.3">It allows us to get data from different sources without affecting the rest of the app. </span><span class="kobospan" id="kobo.179.4">For example, we can get data from a local database or a remote server. </span><span class="kobospan" id="kobo.179.5">The class is responsible for merging the data from the two sources and maintaining the source of truth for our data. </span><span class="kobospan" id="kobo.179.6">The repository pattern also allows us to easily test our code since we can easily mock the repository and test the different layers of our app in isolation. </span><span class="kobospan" id="kobo.179.7">Since our app is very simple at the moment, we have already completed the data/model layer of </span><span><span class="kobospan" id="kobo.180.1">our architecture.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.181.1">Let us now create a </span><strong class="source-inline"><span class="kobospan" id="kobo.182.1">ViewModel</span></strong><span class="kobospan" id="kobo.183.1"> class for our </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">ViewModel</span></strong><span class="kobospan" id="kobo.185.1"> layer. </span><span class="kobospan" id="kobo.185.2">Start by creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">ViewModel</span></strong><span class="kobospan" id="kobo.187.1"> package inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">com.packt.chapterfive</span></strong><span class="kobospan" id="kobo.189.1"> package. </span><span class="kobospan" id="kobo.189.2">Inside this </span><strong class="source-inline"><span class="kobospan" id="kobo.190.1">ViewModel</span></strong><span class="kobospan" id="kobo.191.1"> package, create a </span><a id="_idIndexMarker220" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.192.1">new file named </span><strong class="source-inline"><span class="kobospan" id="kobo.193.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.194.1"> with the </span><span><span class="kobospan" id="kobo.195.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.196.1">
class PetsViewModel: ViewModel() {
    private val petsRepository: PetsRepository = PetsRepositoryImpl()
    fun getPets() = petsRepository.getPets()
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.197.1">To explain what the preceding code does, please see </span><span><span class="kobospan" id="kobo.198.1">the following:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.199.1">We created a class named </span><strong class="source-inline1"><span class="kobospan" id="kobo.200.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.201.1"> that extends the </span><strong class="source-inline1"><span class="kobospan" id="kobo.202.1">ViewModel</span></strong><span class="kobospan" id="kobo.203.1"> class. </span><span class="kobospan" id="kobo.203.2">This is a class </span><a id="_idIndexMarker221" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.204.1">from the </span><strong class="bold"><span class="kobospan" id="kobo.205.1">Jetpack libraries</span></strong><span class="kobospan" id="kobo.206.1">. </span><span class="kobospan" id="kobo.206.2">It helps data persist across configuration changes. </span><span class="kobospan" id="kobo.206.3">It also acts as the intermediary between the View and the Model layers. </span><span class="kobospan" id="kobo.206.4">We use it to expose data to our views, act on user interactions, and update the data in the </span><span><span class="kobospan" id="kobo.207.1">Model layer.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.208.1">We created a private property named </span><strong class="source-inline1"><span class="kobospan" id="kobo.209.1">petsRepository</span></strong><span class="kobospan" id="kobo.210.1"> of type </span><strong class="source-inline1"><span class="kobospan" id="kobo.211.1">PetsRepository</span></strong><span class="kobospan" id="kobo.212.1"> and initialized it with an instance of </span><strong class="source-inline1"><span class="kobospan" id="kobo.213.1">PetsRepositoryImpl</span></strong><span class="kobospan" id="kobo.214.1">. </span><span class="kobospan" id="kobo.214.2">This is the repository we </span><span><span class="kobospan" id="kobo.215.1">created earlier.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.216.1">We created a method named </span><strong class="source-inline1"><span class="kobospan" id="kobo.217.1">getPets()</span></strong><span class="kobospan" id="kobo.218.1"> that returns a list of pets. </span><span class="kobospan" id="kobo.218.2">We called the </span><strong class="source-inline1"><span class="kobospan" id="kobo.219.1">getPets()</span></strong><span class="kobospan" id="kobo.220.1"> method from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.221.1">petsRepository</span></strong><span class="kobospan" id="kobo.222.1"> property and returned </span><span><span class="kobospan" id="kobo.223.1">the result.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.224.1">With this, our </span><strong class="source-inline"><span class="kobospan" id="kobo.225.1">ViewModel</span></strong><span class="kobospan" id="kobo.226.1"> layer is ready to expose data to our views. </span><span class="kobospan" id="kobo.226.2">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.227.1">getPets()</span></strong><span class="kobospan" id="kobo.228.1"> method returns a list of pets. </span><span class="kobospan" id="kobo.228.2">To </span><a id="_idIndexMarker222" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.229.1">display the list in </span><strong class="bold"><span class="kobospan" id="kobo.230.1">Jetpack Compose</span></strong><span class="kobospan" id="kobo.231.1">, we use a </span><strong class="source-inline"><span class="kobospan" id="kobo.232.1">LazyColumn</span></strong><span class="kobospan" id="kobo.233.1"> composable. </span><strong class="source-inline"><span class="kobospan" id="kobo.234.1">LazyColumn</span></strong><span class="kobospan" id="kobo.235.1"> follows a lazy-loading approach, meaning that only the items currently visible</span><a id="_idIndexMarker223" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.236.1"> on the screen are actively composed, reducing resource usage and improving performance. </span><span class="kobospan" id="kobo.236.2">Let us see how a </span><strong class="source-inline"><span class="kobospan" id="kobo.237.1">LazyColumn</span></strong><span class="kobospan" id="kobo.238.1"> works under </span><span><span class="kobospan" id="kobo.239.1">the hood.</span></span></p>
<h2 id="_idParaDest-66" class="calibre7"><a id="_idTextAnchor073" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.240.1">How LazyColumn works</span></h2>
<p class="calibre4"><span class="kobospan" id="kobo.241.1">This is how a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.242.1">LazyColumn</span></strong></span><span><span class="kobospan" id="kobo.243.1"> works:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.244.1">On-demand composing</span></strong><span class="kobospan" id="kobo.245.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.246.1">LazyColumn</span></strong><span class="kobospan" id="kobo.247.1"> composes only the visible items on the screen. </span><span class="kobospan" id="kobo.247.2">As the user</span><a id="_idIndexMarker224" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.248.1"> scrolls, it dynamically composes and recomposes items, ensuring that only the necessary elements </span><a id="_idIndexMarker225" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.249.1">are rendered at any </span><span><span class="kobospan" id="kobo.250.1">given time.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.251.1">Recycling items</span></strong><span class="kobospan" id="kobo.252.1">: Similar to the recycling mechanism in </span><strong class="source-inline1"><span class="kobospan" id="kobo.253.1">RecyclerView</span></strong><span class="kobospan" id="kobo.254.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.255.1">LazyColumn</span></strong><span class="kobospan" id="kobo.256.1"> reuses composables that move in and out of the viewport, minimizing memory usage and preventing </span><span><span class="kobospan" id="kobo.257.1">unnecessary recomposition.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.258.1">Optimized for performance</span></strong><span class="kobospan" id="kobo.259.1">: By lazily loading and recycling items, </span><strong class="source-inline1"><span class="kobospan" id="kobo.260.1">LazyColumn</span></strong><span class="kobospan" id="kobo.261.1"> optimizes the rendering process, making it well-suited for displaying large datasets without consuming </span><span><span class="kobospan" id="kobo.262.1">excessive resources.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.263.1">Now that we know how </span><strong class="source-inline"><span class="kobospan" id="kobo.264.1">LazyColumn</span></strong><span class="kobospan" id="kobo.265.1"> works, let’s see the benefits of </span><span><span class="kobospan" id="kobo.266.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.267.1">LazyColumn</span></strong></span><span><span class="kobospan" id="kobo.268.1">.</span></span></p>
<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor074" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.269.1">Benefits of LazyColumn</span></h2>
<p class="calibre4"><span class="kobospan" id="kobo.270.1">Some of the </span><a id="_idIndexMarker226" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.271.1">benefits of </span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">LazyColumn</span></strong><span class="kobospan" id="kobo.273.1"> are </span><span><span class="kobospan" id="kobo.274.1">the following:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.275.1">Efficient memory usage</span></strong><span class="kobospan" id="kobo.276.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.277.1">LazyColumn</span></strong><span class="kobospan" id="kobo.278.1"> efficiently manages memory by composing only the visible items, ensuring that the app does not unnecessarily store and render all items in a list at once. </span><span class="kobospan" id="kobo.278.2">This is particularly beneficial for long lists or lists with complex </span><span><span class="kobospan" id="kobo.279.1">UI elements.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.280.1">Improved rendering performance</span></strong><span class="kobospan" id="kobo.281.1">: The lazy-loading mechanism significantly improves rendering performance, especially when dealing with extensive datasets. </span><span class="kobospan" id="kobo.281.2">It avoids the overhead of rendering and managing all items simultaneously, resulting in smoother scrolling and </span><span><span class="kobospan" id="kobo.282.1">reduced lag.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.283.1">Simplified UI code</span></strong><span class="kobospan" id="kobo.284.1">: The declarative nature of Jetpack Compose, coupled with </span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">LazyColumn</span></strong><span class="kobospan" id="kobo.286.1">, allows us to express UI logic concisely. </span><span class="kobospan" id="kobo.286.2">The code to create and manage large lists becomes </span><a id="_idIndexMarker227" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.287.1">more straightforward and readable compared to traditional Android </span><span><span class="kobospan" id="kobo.288.1">View approaches.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.289.1">Automatic recomposition</span></strong><span class="kobospan" id="kobo.290.1">: As the data source changes, </span><strong class="source-inline1"><span class="kobospan" id="kobo.291.1">LazyColumn</span></strong><span class="kobospan" id="kobo.292.1"> automatically recomposes only the affected items, reducing the need for manual interventions to update </span><span><span class="kobospan" id="kobo.293.1">the UI.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.294.1">Adaptable for various screen sizes</span></strong><span class="kobospan" id="kobo.295.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.296.1">LazyColumn</span></strong><span class="kobospan" id="kobo.297.1"> adapts well to different screen sizes and resolutions, offering a consistent and responsive user experience across </span><span><span class="kobospan" id="kobo.298.1">various devices.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.299.1">Now, we’re going to create a composable that </span><span><span class="kobospan" id="kobo.300.1">displays pets.</span></span></p>
<h2 id="_idParaDest-68" class="calibre7"><a id="_idTextAnchor075" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.301.1">Creating a composable</span></h2>
<p class="calibre4"><span class="kobospan" id="kobo.302.1">Follow these steps to </span><a id="_idIndexMarker228" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.303.1">create </span><span><span class="kobospan" id="kobo.304.1">a composable:</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.305.1">Create a new</span><a id="_idIndexMarker229" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.306.1"> package named </span><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">views</span></strong><span class="kobospan" id="kobo.308.1"> inside the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.309.1">com.packt.chapterfive</span></strong></span><span><span class="kobospan" id="kobo.310.1"> package.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.311.1">Inside this </span><strong class="source-inline1"><span class="kobospan" id="kobo.312.1">views</span></strong><span class="kobospan" id="kobo.313.1"> package, create a new file named </span><strong class="source-inline1"><span class="kobospan" id="kobo.314.1">PetsList</span></strong><span class="kobospan" id="kobo.315.1"> with the </span><span><span class="kobospan" id="kobo.316.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.317.1">
@Composable
fun PetList(modifier: Modifier) {
    val petsViewModel: PetsViewModel = viewModel()
    LazyColumn(
        modifier = modifier
    ) {
        items(petsViewModel.getPets()) { pet -&gt;
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(10.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(text = "Name: ${pet.name}")
                Text(text = "Species: ${pet.species}")
            }
        }
    }
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.318.1">Here, we have created a composable named </span><strong class="source-inline"><span class="kobospan" id="kobo.319.1">PetList</span></strong><span class="kobospan" id="kobo.320.1"> that takes a modifier as a parameter. </span><span class="kobospan" id="kobo.320.2">We then </span><a id="_idIndexMarker230" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.321.1">create an instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.322.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.323.1"> using the </span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">viewModel()</span></strong><span class="kobospan" id="kobo.325.1"> function from the lifecycle utility library for </span><strong class="source-inline"><span class="kobospan" id="kobo.326.1">ViewModel</span></strong><span class="kobospan" id="kobo.327.1"> in compose. </span><span class="kobospan" id="kobo.327.2">It helps us easily </span><a id="_idIndexMarker231" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.328.1">create an instance of our </span><strong class="source-inline"><span class="kobospan" id="kobo.329.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.330.1">. </span><span class="kobospan" id="kobo.330.2">We then use the </span><strong class="source-inline"><span class="kobospan" id="kobo.331.1">LazyColumn</span></strong><span class="kobospan" id="kobo.332.1"> composable to display the pets. </span><span class="kobospan" id="kobo.332.2">We pass the list of pets from the </span><strong class="source-inline"><span class="kobospan" id="kobo.333.1">ViewModel</span></strong><span class="kobospan" id="kobo.334.1"> to the </span><strong class="source-inline"><span class="kobospan" id="kobo.335.1">items</span></strong><span class="kobospan" id="kobo.336.1"> parameter of the </span><strong class="source-inline"><span class="kobospan" id="kobo.337.1">LazyColumn</span></strong><span class="kobospan" id="kobo.338.1">. </span><span class="kobospan" id="kobo.338.2">We then use the </span><strong class="source-inline"><span class="kobospan" id="kobo.339.1">Row</span></strong><span class="kobospan" id="kobo.340.1"> composable to display the name and species of each pet. </span><span class="kobospan" id="kobo.340.2">We have now completed the view layer of </span><span><span class="kobospan" id="kobo.341.1">our architecture.</span></span></p></li> <li class="calibre15"><span class="kobospan" id="kobo.342.1">To finally display our pets, we need to call our </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">PetList</span></strong><span class="kobospan" id="kobo.344.1"> composable inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.345.1">setContent</span></strong><span class="kobospan" id="kobo.346.1"> block</span><a id="_idIndexMarker232" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.347.1"> of our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">MainActivity</span></strong></span><span><span class="kobospan" id="kobo.349.1"> class:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.350.1">
ChapterFiveTheme {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                   Text(text = "Pets")
                },
                colors =  TopAppBarDefaults.smallTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                )
            )
        },
        content =  { paddingValues -&gt;
            PetList(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
            )
        }
    )
}</span></pre><p class="calibre4"><span class="kobospan" id="kobo.351.1">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.352.1">Scaffold</span></strong><span class="kobospan" id="kobo.353.1"> composable, which we are already familiar with. </span><span class="kobospan" id="kobo.353.2">In our </span><strong class="source-inline"><span class="kobospan" id="kobo.354.1">Scaffold</span></strong><span class="kobospan" id="kobo.355.1">, we are passing</span><a id="_idIndexMarker233" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.356.1"> in a </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">TopAppBar</span></strong><span class="kobospan" id="kobo.358.1"> and our </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">PetList</span></strong><span class="kobospan" id="kobo.360.1"> composable. </span><span class="kobospan" id="kobo.360.2">We are also passing in </span><strong class="source-inline"><span class="kobospan" id="kobo.361.1">paddingValues</span></strong><span class="kobospan" id="kobo.362.1"> to our </span><strong class="source-inline"><span class="kobospan" id="kobo.363.1">PetList</span></strong><span class="kobospan" id="kobo.364.1"> composable. </span><span class="kobospan" id="kobo.364.2">This is because we are using </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">paddingValues</span></strong><span class="kobospan" id="kobo.366.1"> to add padding to our </span><strong class="source-inline"><span class="kobospan" id="kobo.367.1">PetList</span></strong><span class="kobospan" id="kobo.368.1"> composable. </span><span class="kobospan" id="kobo.368.2">We</span><a id="_idIndexMarker234" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.369.1"> have now completed the MVVM architecture in our app. </span><span class="kobospan" id="kobo.369.2">Let’s run the app and see </span><span><span class="kobospan" id="kobo.370.1">the result:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer079">
<span class="kobospan" id="kobo.371.1"><img alt="Figure 5.1 – Pet list" src="image/B19779_05_01.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.372.1">Figure 5.1 – Pet list</span></p>
<p class="calibre4"><span class="kobospan" id="kobo.373.1">As seen from the preceding image, we have our list of pets with their name and species displayed in </span><span><span class="kobospan" id="kobo.374.1">a list.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.375.1">We have mentioned </span><strong class="bold"><span class="kobospan" id="kobo.376.1">Jetpack libraries</span></strong><span class="kobospan" id="kobo.377.1"> a lot in this</span><a id="_idIndexMarker235" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.378.1"> section but have not explained what they are. </span><span class="kobospan" id="kobo.378.2">In the next section, we are going to look at Jetpack libraries </span><span><span class="kobospan" id="kobo.379.1">in detail.</span></span></p>
<h1 id="_idParaDest-69" class="calibre6"><a id="_idTextAnchor076" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.380.1">Jetpack libraries</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.381.1">Jetpack Libraries are a collection of libraries and APIs from Google that help us developers create better apps using less code. </span><span class="kobospan" id="kobo.381.2">They are normally created to address some pain points we, as </span><a id="_idIndexMarker236" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.382.1">developers, face while creating our apps. </span><span class="kobospan" id="kobo.382.2">Let’s look at some of these pain points and some of the Jetpack libraries that were created to </span><span><span class="kobospan" id="kobo.383.1">address them:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.384.1">Storing data locally and observing changes to the data</span></strong><span class="kobospan" id="kobo.385.1">: We had to use </span><strong class="bold"><span class="kobospan" id="kobo.386.1">SQLite</span></strong><span class="kobospan" id="kobo.387.1"> to store data locally. </span><span class="kobospan" id="kobo.387.2">Even for simple </span><strong class="bold"><span class="kobospan" id="kobo.388.1">Create</span></strong><span class="kobospan" id="kobo.389.1">, </span><strong class="bold"><span class="kobospan" id="kobo.390.1">Read</span></strong><span class="kobospan" id="kobo.391.1">, </span><strong class="bold"><span class="kobospan" id="kobo.392.1">Update</span></strong><span class="kobospan" id="kobo.393.1">, and </span><strong class="bold"><span class="kobospan" id="kobo.394.1">Delete</span></strong><span class="kobospan" id="kobo.395.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.396.1">CRUD</span></strong><span class="kobospan" id="kobo.397.1">) operations, we had to write a lot of boilerplate code. </span><span class="kobospan" id="kobo.397.2">We also had to write a lot of code to</span><a id="_idIndexMarker237" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.398.1"> observe changes to the data. </span><span class="kobospan" id="kobo.398.2">This is </span><a id="_idIndexMarker238" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.399.1">a lot of work for a simple task. </span><span class="kobospan" id="kobo.399.2">Jetpack libraries, such as </span><strong class="bold"><span class="kobospan" id="kobo.400.1">Room</span></strong><span class="kobospan" id="kobo.401.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.402.1">LiveData</span></strong><span class="kobospan" id="kobo.403.1">, were created to address this pain point. </span><span class="kobospan" id="kobo.403.2">Room is a library that allows us to easily store data locally. </span><span class="kobospan" id="kobo.403.3">It also allows us to easily observe changes to the data. </span><span class="kobospan" id="kobo.403.4">LiveData is a library that allows us to observe changes to data easily. </span><span class="kobospan" id="kobo.403.5">It is also lifecycle-aware. </span><span class="kobospan" id="kobo.403.6">This means it automatically stops observing data changes when the lifecycle of the component observing the data ends. </span><span class="kobospan" id="kobo.403.7">This helps us avoid memory leaks in our apps. </span><span class="kobospan" id="kobo.403.8">Room</span><a id="_idIndexMarker239" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.404.1"> also has support for </span><strong class="bold"><span class="kobospan" id="kobo.405.1">Kotlin Coroutines</span></strong><span class="kobospan" id="kobo.406.1">, which we will be looking at deeply in </span><a href="B19779_06.xhtml#_idTextAnchor084" class="calibre3 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.407.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.408.1">. </span><span class="kobospan" id="kobo.408.2">This makes it easy to store and access data locally with less </span><span><span class="kobospan" id="kobo.409.1">boilerplate code.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.410.1">Navigation was a challenging thing to achieve perfectly in our apps</span></strong><span class="kobospan" id="kobo.411.1">: Lots of open-source libraries were created to solve this pain point. </span><span class="kobospan" id="kobo.411.2">It also required a lot of boilerplate code to navigate between activities and fragments and maintain consistent and predictable</span><a id="_idIndexMarker240" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.412.1"> back behavior. </span><strong class="bold"><span class="kobospan" id="kobo.413.1">Jetpack Navigation</span></strong><span class="kobospan" id="kobo.414.1"> was created to address this pain point. </span><span class="kobospan" id="kobo.414.2">It allows us to navigate between screens in our app easily. </span><span class="kobospan" id="kobo.414.3">It also allows us to easily maintain consistent and predictable back behavior. </span><span class="kobospan" id="kobo.414.4">It also allows us to pass data between screens in our app. </span><span class="kobospan" id="kobo.414.5">It also has support for Jetpack </span><a id="_idIndexMarker241" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.415.1">Compose and functions, such as deep links, which are supposed to open a specific screen in our app when a user clicks on </span><span><span class="kobospan" id="kobo.416.1">a link.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.417.1">Handling lifecycle in activities and fragments</span></strong><span class="kobospan" id="kobo.418.1">: In Android, both activities and fragments have their own lifecycle, and it is particularly important for us to be aware of these lifecycles so that we can be able to do operations in the right lifecycle. </span><span class="kobospan" id="kobo.418.2">For example, we should be observing data in our views when the lifecycle is in the started state and free up resources when the lifecycle is either in the stopped or destroyed state. </span><span class="kobospan" id="kobo.418.3">Doing this was harder and required a lot of code, which could be bug-prone. </span><span class="kobospan" id="kobo.418.4">The team at Google came up with the </span><strong class="bold"><span class="kobospan" id="kobo.419.1">lifecycle</span></strong><span class="kobospan" id="kobo.420.1"> library to help us manage lifecycles in our activities and fragments. </span><span class="kobospan" id="kobo.420.2">Additionally, we have classes, such as the </span><strong class="bold"><span class="kobospan" id="kobo.421.1">ViewModel</span></strong><span class="kobospan" id="kobo.422.1">, which we created earlier on, that allow your data to persist across configuration changes. </span><span class="kobospan" id="kobo.422.2">Most of the Jetpack libraries are also lifecycle-aware, which makes it easy to use them in our apps. </span><span class="kobospan" id="kobo.422.3">Taking the ViewModel as an example, it survives beyond the lifecycle of the activity or fragment that created it. </span><span class="kobospan" id="kobo.422.4">This makes it easy for data to persist across configuration changes. </span><span class="kobospan" id="kobo.422.5">It also makes it easy to share data between fragments </span><span><span class="kobospan" id="kobo.423.1">and activities.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.424.1">Loading infinite lists</span></strong><span class="kobospan" id="kobo.425.1">: Most apps that we developers work on have a list of items that we want to show to our users. </span><span class="kobospan" id="kobo.425.2">Often, this list of items can be large, and we cannot display all of them at once. </span><span class="kobospan" id="kobo.425.3">We are supposed to display them in batches, which is called </span><strong class="bold"><span class="kobospan" id="kobo.426.1">pagination</span></strong><span class="kobospan" id="kobo.427.1">. </span><span class="kobospan" id="kobo.427.2">To achieve this by ourselves, we had to do several workarounds, such as</span><a id="_idIndexMarker242" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.428.1"> observing the scroll position and fetching the next or previous batch of items when a user reaches the top or bottom of the list. </span><span class="kobospan" id="kobo.428.2">Again, this was quite a bit of work, and the team at Google introduced the </span><strong class="bold"><span class="kobospan" id="kobo.429.1">Paging</span></strong><span class="kobospan" id="kobo.430.1"> library to </span><a id="_idIndexMarker243" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.431.1">help us achieve this. </span><span class="kobospan" id="kobo.431.2">It allows us to load data in batches easily and display it to our users. </span><span class="kobospan" id="kobo.431.3">It also has support for Jetpack Compose and Kotlin Coroutines. </span><span class="kobospan" id="kobo.431.4">It makes it easy to display infinite lists in </span><span><span class="kobospan" id="kobo.432.1">our apps.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.433.1">Handling background jobs</span></strong><span class="kobospan" id="kobo.434.1">: Performing lengthy background tasks for apps proved to be somewhat challenging. </span><span class="kobospan" id="kobo.434.2">The common issue was that some of the background jobs did </span><a id="_idIndexMarker244" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.435.1">not run due to the different restrictions that phone manufacturers add to the phones to improve their performance of the phone. </span><span class="kobospan" id="kobo.435.2">The team at Google introduced the </span><strong class="bold"><span class="kobospan" id="kobo.436.1">WorkManager</span></strong><span class="kobospan" id="kobo.437.1"> library to</span><a id="_idIndexMarker245" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.438.1"> help us achieve this. </span><span class="kobospan" id="kobo.438.2">It allows us to schedule background jobs in our apps easily. </span><span class="kobospan" id="kobo.438.3">It also supports periodic background jobs and ensures that our jobs run irrespective of the phone brand that the user </span><span><span class="kobospan" id="kobo.439.1">is using.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.440.1">Performance</span></strong><span class="kobospan" id="kobo.441.1">: There was no clear guidance on how best we developers can improve the performance of our apps. </span><span class="kobospan" id="kobo.441.2">That is not the case anymore; we have several Jetpack libraries to help us detect performance issues and improve the performance of our apps. </span><span class="kobospan" id="kobo.441.3">A good</span><a id="_idIndexMarker246" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.442.1"> example of this is the </span><strong class="bold"><span class="kobospan" id="kobo.443.1">baseline profiles</span></strong><span class="kobospan" id="kobo.444.1">, which help improve app start-up time and make app interactions </span><span><span class="kobospan" id="kobo.445.1">much smoother.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.446.1">There are a lot of Jetpack libraries. </span><span class="kobospan" id="kobo.446.2">You can explore all the available Jetpack libraries here: </span><a href="https://developer.android.com/jetpack/androidx/explorer" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.447.1">https://developer.android.com/jetpack/androidx/explorer</span></a><span class="kobospan" id="kobo.448.1">. </span><span class="kobospan" id="kobo.448.2">The following are some of the benefits of using </span><span><span class="kobospan" id="kobo.449.1">Jetpack libraries:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.450.1">We can follow the </span><span><span class="kobospan" id="kobo.451.1">best practices</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.452.1">We can write less </span><span><span class="kobospan" id="kobo.453.1">boilerplate code</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.454.1">We </span><span><span class="kobospan" id="kobo.455.1">reduce fragmentation</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.456.1">The APIs work </span><span><span class="kobospan" id="kobo.457.1">well together</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.458.1">We have already seen how to use a </span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">ViewModel</span></strong><span class="kobospan" id="kobo.460.1"> class in this chapter. </span><span class="kobospan" id="kobo.460.2">We will also be using other Jetpack libraries in the later chapters of </span><span><span class="kobospan" id="kobo.461.1">this book.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.462.1">We have looked at how the Jetpack Libraries fit in with the different layers of our architecture. </span><span class="kobospan" id="kobo.462.2">In the next section, we </span><a id="_idIndexMarker247" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.463.1">are looking at an important topic in architecture, which is </span><span><strong class="bold"><span class="kobospan" id="kobo.464.1">dependency injection</span></strong></span><span><span class="kobospan" id="kobo.465.1">.</span></span></p>
<h1 id="_idParaDest-70" class="calibre6"><a id="_idTextAnchor077" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.466.1">Dependency injection</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.467.1">Dependency injection is a </span><a id="_idIndexMarker248" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.468.1">way for us to manage and provide dependencies that a class needs to do its work without the class having to create the dependencies itself. </span><span class="kobospan" id="kobo.468.2">In this book, we will be using Koin (</span><a href="https://insert-koin.io/" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.469.1">https://insert-koin.io/</span></a><span class="kobospan" id="kobo.470.1">) as our dependency </span><span><span class="kobospan" id="kobo.471.1">injection library.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.472.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.473.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.474.1"> class creates the </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">PetsRepository</span></strong><span class="kobospan" id="kobo.476.1"> class by itself. </span><span class="kobospan" id="kobo.476.2">This is a suitable candidate for dependency injection. </span><span class="kobospan" id="kobo.476.3">We will be refactoring this to use dependency injection. </span><span class="kobospan" id="kobo.476.4">Let’s start by adding the Koin dependency to our app. </span><span class="kobospan" id="kobo.476.5">Open the </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">build.gradle</span></strong><span class="kobospan" id="kobo.478.1"> file for the app module and add the </span><span><span class="kobospan" id="kobo.479.1">following dependency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.480.1">
implementation 'io.insert-koin:koin-core:3.4.3'
implementation 'io.insert-koin:koin-android:3.4.3'
implementation 'io.insert-koin:koin-androidx-compose:3.4.6'</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.481.1">We are adding the Koin </span><strong class="source-inline"><span class="kobospan" id="kobo.482.1">core</span></strong><span class="kobospan" id="kobo.483.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.484.1">android,</span></strong><span class="kobospan" id="kobo.485.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.486.1">compose</span></strong><span class="kobospan" id="kobo.487.1"> dependencies as well, which will be used in our project to provide </span><span><span class="kobospan" id="kobo.488.1">the dependencies.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.489.1">After adding this to our project and syncing</span><a id="_idIndexMarker249" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.490.1"> the project, we need to create Koin </span><strong class="bold"><span class="kobospan" id="kobo.491.1">modules</span></strong><span class="kobospan" id="kobo.492.1"> for our dependencies. </span><span class="kobospan" id="kobo.492.2">Modules are used to declare dependencies. </span><span class="kobospan" id="kobo.492.3">We will create a module for our </span><strong class="source-inline"><span class="kobospan" id="kobo.493.1">PetsRepository</span></strong><span class="kobospan" id="kobo.494.1"> class. </span><span class="kobospan" id="kobo.494.2">Create a new package named </span><strong class="source-inline"><span class="kobospan" id="kobo.495.1">di</span></strong><span class="kobospan" id="kobo.496.1"> inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.497.1">com.packt.chapterfive</span></strong><span class="kobospan" id="kobo.498.1"> package. </span><span class="kobospan" id="kobo.498.2">Inside this </span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">di</span></strong><span class="kobospan" id="kobo.500.1"> package, create a new file named </span><strong class="source-inline"><span class="kobospan" id="kobo.501.1">Modules</span></strong><span class="kobospan" id="kobo.502.1"> and add the </span><span><span class="kobospan" id="kobo.503.1">follo</span><a id="_idTextAnchor078" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.504.1">wing code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.505.1">
val appModules = module {
    single&lt;PetsRepository&gt; { PetsRepositoryImpl() }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.506.1">In the preceding code above, we are creating a new variable named </span><strong class="source-inline"><span class="kobospan" id="kobo.507.1">appModules</span></strong><span class="kobospan" id="kobo.508.1"> of the type module. </span><span class="kobospan" id="kobo.508.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.509.1">module</span></strong><span class="kobospan" id="kobo.510.1"> function from the Koin library to create a module. </span><span class="kobospan" id="kobo.510.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.511.1">single</span></strong><span class="kobospan" id="kobo.512.1"> function to create a single instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">PetsRepository</span></strong><span class="kobospan" id="kobo.514.1"> class. </span><span class="kobospan" id="kobo.514.2">Koin has dependency injection scopes, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">single</span></strong><span class="kobospan" id="kobo.516.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">factory</span></strong><span class="kobospan" id="kobo.518.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">scoped</span></strong><span class="kobospan" id="kobo.520.1">, that govern the lifecycle and visibility of dependency instances within the container. </span><span class="kobospan" id="kobo.520.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.521.1">single</span></strong><span class="kobospan" id="kobo.522.1"> scope creates singleton instances that persist throughout the entire application, making it suitable for objects requiring a globally shared state, such as database instances. </span><strong class="source-inline"><span class="kobospan" id="kobo.523.1">Factory</span></strong><span class="kobospan" id="kobo.524.1"> scope generates new instances each time they are requested, fitting stateless utility classes or objects that don’t need to maintain a persistent state. </span><span class="kobospan" id="kobo.524.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.525.1">scoped</span></strong><span class="kobospan" id="kobo.526.1"> scope ties instances to specific contexts, such as activity or fragment lifecycles, allowing them to be shared within a designated scope but recreated for different contexts. </span><span class="kobospan" id="kobo.526.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.527.1">single</span></strong><span class="kobospan" id="kobo.528.1"> scope is particularly useful for managing global or long-lived dependencies efficiently, ensuring a single instance is shared consistently across various components of the application, thereby optimizing resource usage and</span><a id="_idIndexMarker250" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.529.1"> maintaining a unified state. </span><span class="kobospan" id="kobo.529.2">This is why we are using </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">single</span></strong><span class="kobospan" id="kobo.531.1"> to create an instance of our </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">PetsRepository</span></strong><span class="kobospan" id="kobo.533.1"> class. </span><span class="kobospan" id="kobo.533.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.534.1">PetsRepositoryImpl</span></strong><span class="kobospan" id="kobo.535.1"> class as the implementation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">PetsRepository</span></strong></span><span><span class="kobospan" id="kobo.537.1"> interface.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.538.1">Next, we will refactor our </span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.540.1"> class to use dependency injection. </span><span class="kobospan" id="kobo.540.2">Open the </span><strong class="source-inline"><span class="kobospan" id="kobo.541.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.542.1"> class and update it as shown in the following </span><span><span class="kobospan" id="kobo.543.1">code snippet:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.544.1">
class PetsViewModel(
    private val petsRepository: PetsRepository
): ViewModel() {
    fun getPets() = petsRepository.getPets()
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.545.1">In the preceding code, we have removed the instantiation of the </span><strong class="source-inline"><span class="kobospan" id="kobo.546.1">PetsRepository</span></strong><span class="kobospan" id="kobo.547.1"> class from the </span><strong class="source-inline"><span class="kobospan" id="kobo.548.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.549.1"> class. </span><span class="kobospan" id="kobo.549.2">We have, instead, added a </span><strong class="source-inline"><span class="kobospan" id="kobo.550.1">constructor</span></strong><span class="kobospan" id="kobo.551.1"> that takes a </span><strong class="source-inline"><span class="kobospan" id="kobo.552.1">PetsRepository</span></strong><span class="kobospan" id="kobo.553.1"> parameter. </span><span class="kobospan" id="kobo.553.2">We also need to create a new dependency for </span><strong class="source-inline"><span class="kobospan" id="kobo.554.1">ViewModel</span></strong><span class="kobospan" id="kobo.555.1">, just below the </span><strong class="source-inline"><span class="kobospan" id="kobo.556.1">PetsRepository</span></strong><span class="kobospan" id="kobo.557.1"> dependency in our </span><strong class="source-inline"><span class="kobospan" id="kobo.558.1">appModules</span></strong><span class="kobospan" id="kobo.559.1"> variable. </span><span class="kobospan" id="kobo.559.2">Let us add the </span><span><span class="kobospan" id="kobo.560.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.561.1">
single { PetsViewModel(get()) }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.562.1">Here, we are creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">single</span></strong><span class="kobospan" id="kobo.564.1"> instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.565.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.566.1"> class. </span><span class="kobospan" id="kobo.566.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">get()</span></strong><span class="kobospan" id="kobo.568.1"> function to get the </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">PetsRepository</span></strong><span class="kobospan" id="kobo.570.1"> dependency. </span><span class="kobospan" id="kobo.570.2">We are passing it to the constructor of the </span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.572.1"> class. </span><span class="kobospan" id="kobo.572.2">With this, our app is ready to use these dependencies. </span><span class="kobospan" id="kobo.572.3">We will also change the way we create the </span><strong class="source-inline"><span class="kobospan" id="kobo.573.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.574.1"> instance in our </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">PetList</span></strong><span class="kobospan" id="kobo.576.1"> composable. </span><span class="kobospan" id="kobo.576.2">Open the </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">PetList</span></strong><span class="kobospan" id="kobo.578.1"> composable and update the initialization of </span><strong class="source-inline"><span class="kobospan" id="kobo.579.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.580.1">, as </span><span><span class="kobospan" id="kobo.581.1">shown here:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.582.1">
val petsViewModel: PetsViewModel = koinViewModel()</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.583.1">Instead of using the </span><strong class="source-inline"><span class="kobospan" id="kobo.584.1">ViewModel()</span></strong><span class="kobospan" id="kobo.585.1"> function from the lifecycle library, we are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.586.1">koinViewModel()</span></strong><span class="kobospan" id="kobo.587.1"> function from the Koin library. </span><span class="kobospan" id="kobo.587.2">This function helps us create an instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.588.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.589.1"> class. </span><span class="kobospan" id="kobo.589.2">This now returns an instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">PetsViewModel</span></strong><span class="kobospan" id="kobo.591.1"> that has the </span><strong class="source-inline"><span class="kobospan" id="kobo.592.1">PetsRepository</span></strong> <span><span class="kobospan" id="kobo.593.1">dependency injected.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.594.1">The last step in ensuring our </span><a id="_idIndexMarker251" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.595.1">app has dependency injection setup is to initialize Koin in our app. </span><span class="kobospan" id="kobo.595.2">We will create a class that extends the </span><strong class="source-inline"><span class="kobospan" id="kobo.596.1">Application</span></strong><span class="kobospan" id="kobo.597.1"> class and initialize Koin in the </span><strong class="source-inline"><span class="kobospan" id="kobo.598.1">onCreate()</span></strong><span class="kobospan" id="kobo.599.1"> method. </span><span class="kobospan" id="kobo.599.2">Create a new file named </span><strong class="source-inline"><span class="kobospan" id="kobo.600.1">ChapterFiveApplication</span></strong><span class="kobospan" id="kobo.601.1"> and add the </span><span><span class="kobospan" id="kobo.602.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.603.1">
class ChapterFiveApplication: Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            modules(appModules)
        }
    }
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.604.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.605.1">ChapterFiveApplication</span></strong><span class="kobospan" id="kobo.606.1"> class extends the </span><strong class="source-inline"><span class="kobospan" id="kobo.607.1">Application</span></strong><span class="kobospan" id="kobo.608.1"> class. </span><span class="kobospan" id="kobo.608.2">We are overriding the </span><strong class="source-inline"><span class="kobospan" id="kobo.609.1">onCreate()</span></strong><span class="kobospan" id="kobo.610.1"> method and calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.611.1">startKoin()</span></strong><span class="kobospan" id="kobo.612.1"> function. </span><span class="kobospan" id="kobo.612.2">We are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.613.1">modules</span></strong><span class="kobospan" id="kobo.614.1"> parameter to pass in the </span><strong class="source-inline"><span class="kobospan" id="kobo.615.1">appModules</span></strong><span class="kobospan" id="kobo.616.1"> variable that we created earlier on. </span><span class="kobospan" id="kobo.616.2">This initializes Koin in our app. </span><span class="kobospan" id="kobo.616.3">We also need to update the </span><strong class="source-inline"><span class="kobospan" id="kobo.617.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.618.1"> file to use our </span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">ChapterFiveApplication</span></strong><span class="kobospan" id="kobo.620.1"> class. </span><span class="kobospan" id="kobo.620.2">Open the </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.622.1"> file and update the application tag with the name attribute, as </span><span><span class="kobospan" id="kobo.623.1">shown here:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.624.1">
android:name=".ChapterFiveApplication"</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.625.1">We are passing the name of our </span><strong class="source-inline"><span class="kobospan" id="kobo.626.1">ChapterFiveApplication</span></strong><span class="kobospan" id="kobo.627.1"> class to the name attribute. </span><span class="kobospan" id="kobo.627.2">Now, if you run </span><a id="_idIndexMarker252" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.628.1">the app, it still runs as before, but this time, it uses </span><span><span class="kobospan" id="kobo.629.1">dependency injection.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.630.1">Now that we understand what dependency injection is and how to use it in our apps, let us look at </span><strong class="bold"><span class="kobospan" id="kobo.631.1">Kotlin Gradle DSL</span></strong><span class="kobospan" id="kobo.632.1"> and how we can use </span><strong class="bold"><span class="kobospan" id="kobo.633.1">version catalogs</span></strong><span class="kobospan" id="kobo.634.1"> to manage </span><span><span class="kobospan" id="kobo.635.1">our dependencies.</span></span></p>
<h1 id="_idParaDest-71" class="calibre6"><a id="_idTextAnchor079" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.636.1">Migrating to Kotlin Gradle DSL and using version catalogs</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.637.1">In </span><a href="B19779_01.xhtml#_idTextAnchor015" class="calibre3 pcalibre pcalibre1"><span><em class="italic"><span class="kobospan" id="kobo.638.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.639.1">, one of the</span><a id="_idIndexMarker253" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.640.1"> advantages of using Kotlin that we listed is that we can also write our Gradle files in Kotlin. </span><span class="kobospan" id="kobo.640.2">In this section, we will look at how we can migrate our Gradle files to Kotlin Gradle DSL. </span><span class="kobospan" id="kobo.640.3">We will also look at how we can use a version catalog to manage </span><span><span class="kobospan" id="kobo.641.1">our dependencies.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.642.1">Before we migrate, let’s see some of the benefits we get from using Kotlin </span><span><span class="kobospan" id="kobo.643.1">Gradle DSL:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.644.1">Code autocompletion</span></strong><span class="kobospan" id="kobo.645.1">: We</span><a id="_idIndexMarker254" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.646.1"> get hints about the completion of our code in Gradle files as we are </span><span><span class="kobospan" id="kobo.647.1">using Kotlin.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.648.1">Type safety</span></strong><span class="kobospan" id="kobo.649.1">: We get compile time errors when we make mistakes in our </span><span><span class="kobospan" id="kobo.650.1">Gradle files.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.651.1">Function calls and variable assignments</span></strong><span class="kobospan" id="kobo.652.1">: We can use functions and variables in our Gradle files the same way we use them in our Kotlin code. </span><span class="kobospan" id="kobo.652.2">It makes it even easier for us to write </span><span><span class="kobospan" id="kobo.653.1">and understand.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.654.1">Compile time errors</span></strong><span class="kobospan" id="kobo.655.1">: We get errors at compile time when we make mistakes in our Gradle files. </span><span class="kobospan" id="kobo.655.2">This helps us avoid runtime errors when building </span><span><span class="kobospan" id="kobo.656.1">our apps.</span></span></li>
<li class="calibre15"><strong class="bold"><span class="kobospan" id="kobo.657.1">Official Android Studio Support</span></strong><span class="kobospan" id="kobo.658.1">: From Android Studio Giraffe onwards, Kotlin Gradle DSL is the recommended way of creating our Gradle files. </span><span class="kobospan" id="kobo.658.2">It is also the default way of </span><a id="_idIndexMarker255" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.659.1">creating our Gradle files in Android Studio </span><span><span class="kobospan" id="kobo.660.1">Giraffe onwards.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.661.1">So many benefits, right? </span><span class="kobospan" id="kobo.661.2">Let’s now migrate our app so as to use Kotlin </span><span><span class="kobospan" id="kobo.662.1">Gradle DSL.</span></span></p>
<h2 id="_idParaDest-72" class="calibre7"><a id="_idTextAnchor080" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.663.1">Migrating our app to Kotlin Gradle DSL</span></h2>
<p class="callout-heading"><span class="kobospan" id="kobo.664.1">Important note</span></p>
<p class="callout"><span class="kobospan" id="kobo.665.1">If your apps already use Kotlin Gradle DSL, you can skip </span><span><span class="kobospan" id="kobo.666.1">this section.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.667.1">Follow these steps to </span><a id="_idIndexMarker256" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.668.1">migrate your app to Kotlin </span><span><span class="kobospan" id="kobo.669.1">Gradle DSL:</span></span></p>
<ol class="calibre14">
<li class="calibre15"><span class="kobospan" id="kobo.670.1">First, we have to rename all our Gradle files to have a </span><strong class="source-inline1"><span class="kobospan" id="kobo.671.1">.kts</span></strong><span class="kobospan" id="kobo.672.1"> extension, which allows our IDE to recognize them as Kotlin Gradle files. </span><span class="kobospan" id="kobo.672.2">Rename the </span><strong class="source-inline1"><span class="kobospan" id="kobo.673.1">build.gradle(Project : chapterfive)</span></strong><span class="kobospan" id="kobo.674.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.675.1">build.gradle(Module: app)</span></strong><span class="kobospan" id="kobo.676.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.677.1">settings.gradle</span></strong><span class="kobospan" id="kobo.678.1"> files to </span><strong class="source-inline1"><span class="kobospan" id="kobo.679.1">build.gradle.kts(Project: chapterfive)</span></strong><span class="kobospan" id="kobo.680.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.681.1">build.gradle.kts(Module: app)</span></strong><span class="kobospan" id="kobo.682.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.683.1">settings.gradle.kts</span></strong><span class="kobospan" id="kobo.684.1">, respectively. </span><span class="kobospan" id="kobo.684.2">This allows us to use Kotlin in our Gradle </span><span><span class="kobospan" id="kobo.685.1">files now.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.686.1">After renaming the files, we have to update their content to use Kotlin Gradle DSL. </span><span class="kobospan" id="kobo.686.2">Let’s start with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">settings.gradle.kts</span></strong><span class="kobospan" id="kobo.688.1"> file. </span><span class="kobospan" id="kobo.688.2">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.689.1">settings.gradle.kts</span></strong><span class="kobospan" id="kobo.690.1"> file and update it, as shown in the </span><span><span class="kobospan" id="kobo.691.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.692.1">
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "chapterfive"
include(":app")</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.693.1">Next, update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">build.gradle.kts(Module: app)</span></strong><span class="kobospan" id="kobo.695.1"> file, as shown in the </span><span><span class="kobospan" id="kobo.696.1">following </span></span><span><a id="_idIndexMarker257" class="calibre3 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.697.1">code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.698.1">
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}
android {
    namespace = "com.packt.chapterfive"
    compileSdk = 33
    defaultConfig {
        applicationId = "com.packt.chapterfive"
        minSdk = 24
        targetSdk = 33
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }
    buildTypes {
        release {
            isMinifyEnabled = false
            setProguardFiles(
                listOf(
                    getDefaultProguardFile("proguard-android.txt"),
                    "proguard-rules.pro"
                )
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.4.6"
    }
    packagingOptions {
        resources {
            pickFirsts.add("META-INF/AL2.0")
            pickFirsts.add("META-INF/LGPL2.1")
        }
    }
}
dependencies {
    implementation("androidx.core:core-ktx:1.10.1")
    implementation(platform("org.jetbrains.kotlin:kotlin-bom:1.8.0"))
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.1")
    implementation("androidx.activity:activity-compose:1.7.2")
    implementation(platform("androidx.compose:compose-bom:2022.10.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose")
    implementation("io.insert-koin:koin-core:3.4.3")
    implementation("io.insert-koin:koin-android:3.4.3")
    implementation("io.insert-koin:koin-androidx-compose:3.4.6")
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2022.10.00"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}</span></pre></li> <li class="calibre15"><span class="kobospan" id="kobo.699.1">Lastly, update the </span><strong class="source-inline1"><span class="kobospan" id="kobo.700.1">build.gradle.kts(Project: chapterfive)</span></strong><span class="kobospan" id="kobo.701.1"> file, as shown in the </span><span><span class="kobospan" id="kobo.702.1">following snippet:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.703.1">
plugins {
    id("com.android.application") version "8.1.0" apply false
    id("com.android.library") version "8.1.0" apply false
    id("org.jetbrains.kotlin.android") version "1.8.20" apply false
}</span></pre></li> </ol>
<p class="calibre4"><span class="kobospan" id="kobo.704.1">After updating the files, we have to sync the project. </span><span class="kobospan" id="kobo.704.2">We can do this by clicking on the Sync prompt that appears in the top right corner of the IDE. </span><span class="kobospan" id="kobo.704.3">After syncing the project, we can now run the app, and it should run as before. </span><span class="kobospan" id="kobo.704.4">We have now successfully migrated our app to use Kotlin</span><a id="_idIndexMarker258" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.705.1"> Gradle DSL. </span><span class="kobospan" id="kobo.705.2">You can also see that the syntax highlighting and the colors of the functions, methods, and variables change to reflect the Kotlin syntax. </span><span class="kobospan" id="kobo.705.3">Some key changes about this migration to highlight are </span><span><span class="kobospan" id="kobo.706.1">the following:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.707.1">To assign values to properties, we have to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.708.1">=</span></strong><span class="kobospan" id="kobo.709.1"> operator specifically. </span><span class="kobospan" id="kobo.709.2">For example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.710.1">minSdk 24</span></strong><span class="kobospan" id="kobo.711.1"> changes to </span><strong class="source-inline1"><span class="kobospan" id="kobo.712.1">minSdk = </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.713.1">24</span></strong></span><span><span class="kobospan" id="kobo.714.1">.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.715.1">In our </span><strong class="source-inline1"><span class="kobospan" id="kobo.716.1">android</span></strong><span class="kobospan" id="kobo.717.1"> config block, </span><strong class="source-inline1"><span class="kobospan" id="kobo.718.1">namespace 'com.packt.chapterfive'</span></strong><span class="kobospan" id="kobo.719.1"> changes to  </span><strong class="source-inline1"><span class="kobospan" id="kobo.720.1">namespace = "com.packt.chapterfive"</span></strong><span class="kobospan" id="kobo.721.1">. </span><span class="kobospan" id="kobo.721.2">In Kotlin, we define strings using double quotes; that’s why we have to change the single quotes to double quotes in all the places we </span><span><span class="kobospan" id="kobo.722.1">have strings.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.723.1">In defining our dependencies, we have to use double quotes too. </span><span class="kobospan" id="kobo.723.2">For example,  </span><strong class="source-inline1"><span class="kobospan" id="kobo.724.1">implementation 'androidx.activity:activity-compose:1.7.2'</span></strong><span class="kobospan" id="kobo.725.1">  changes </span><span><span class="kobospan" id="kobo.726.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.727.1">implementation("androidx.activity:activity-compose:1.7.2")</span></strong></span><span><span class="kobospan" id="kobo.728.1">.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.729.1">Similarly, defining our plugins in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.730.1">plugins</span></strong><span class="kobospan" id="kobo.731.1"> block changes. </span><span class="kobospan" id="kobo.731.2">For example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.732.1">id 'org.jetbrains.kotlin.android'</span></strong><span class="kobospan" id="kobo.733.1"> changes </span><span><span class="kobospan" id="kobo.734.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.735.1">id("org.jetbrains.kotlin.android")</span></strong></span><span><span class="kobospan" id="kobo.736.1">.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.737.1">Our project had minimal Gradle configurations, so if you have a complex project, you might need to do </span><a id="_idIndexMarker259" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.738.1">more migration; you can have a look at the Migrate to Kotlin DSL official documentation (</span><a href="https://developer.android.com/build/migrate-to-kotlin-dsl" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.739.1">https://developer.android.com/build/migrate-to-kotlin-dsl</span></a><span class="kobospan" id="kobo.740.1">) for </span><span><span class="kobospan" id="kobo.741.1">more examples.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.742.1">We have now migrated our app to use Kotlin Gradle DSL. </span><span class="kobospan" id="kobo.742.2">In the next subsection, let’s look at how we can use a </span><strong class="bold"><span class="kobospan" id="kobo.743.1">versions catalog</span></strong><span class="kobospan" id="kobo.744.1"> to manage </span><span><span class="kobospan" id="kobo.745.1">our dependencies.</span></span></p>
<h2 id="_idParaDest-73" class="calibre7"><a id="_idTextAnchor081" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.746.1">Using a versions catalog</span></h2>
<p class="calibre4"><span class="kobospan" id="kobo.747.1">Quoting from the official documentation (</span><a href="https://docs.gradle.org/current/userguide/platforms.html" class="calibre3 pcalibre pcalibre1"><span class="kobospan" id="kobo.748.1">https://docs.gradle.org/current/userguide/platforms.html</span></a><span class="kobospan" id="kobo.749.1">), a version catalog is a list of dependencies, represented as dependency co-ordinates, that a user can pick from when declaring</span><a id="_idIndexMarker260" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.750.1"> dependencies in a build script. </span><span class="kobospan" id="kobo.750.2">It helps us easily manage our </span><a id="_idIndexMarker261" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.751.1">dependencies and their versions in one central place. </span><span class="kobospan" id="kobo.751.2">Currently, you can see that we define all our dependencies and their versions in our app-level </span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.753.1"> file. </span><span class="kobospan" id="kobo.753.2">Over time, and as you add more modules to your app, it becomes hard to share these dependencies, and we can find ourselves in situations where different modules have different versions of a similar dependency. </span><span class="kobospan" id="kobo.753.3">This is where version catalogs come in to help us. </span><span class="kobospan" id="kobo.753.4">Let’s see all the benefits that </span><span><span class="kobospan" id="kobo.754.1">they offer:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.755.1">They provide a central place to manage all our dependencies and their versions. </span><span class="kobospan" id="kobo.755.2">They make it easier to share the dependencies across </span><span><span class="kobospan" id="kobo.756.1">the project</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.757.1">They have a simple and </span><span><span class="kobospan" id="kobo.758.1">easy-to-use syntax</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.759.1">They show hints for dependencies that need to </span><span><span class="kobospan" id="kobo.760.1">be updated</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.761.1">They make it easier to make changes, and these changes do not recompile the whole project, meaning the builds </span><span><span class="kobospan" id="kobo.762.1">are faster</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.763.1">We can bundle dependencies together and share them across </span><span><span class="kobospan" id="kobo.764.1">the project</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.765.1">They have official support and are recommended by Google to be used from Android Studio Giraffe </span><span><span class="kobospan" id="kobo.766.1">going forward</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.767.1">Let’s now see how we can use a version catalog in our app. </span><span class="kobospan" id="kobo.767.2">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.768.1">gradle</span></strong><span class="kobospan" id="kobo.769.1"> folder, create a new file named </span><strong class="source-inline"><span class="kobospan" id="kobo.770.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.771.1">. </span><span class="kobospan" id="kobo.771.2">In this file, here are some basic rules that we </span><span><span class="kobospan" id="kobo.772.1">will follow:</span></span></p>
<ul class="calibre16">
<li class="calibre15"><span class="kobospan" id="kobo.773.1">We can use separators, such as -, _v, and . </span><span class="kobospan" id="kobo.773.2">, that will be normalized by Gradle to “.” </span><span class="kobospan" id="kobo.773.3">in the Catalog, allowing</span><a id="_idIndexMarker262" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.774.1"> us to </span><span><span class="kobospan" id="kobo.775.1">create subsections.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.776.1">We define variables </span><span><span class="kobospan" id="kobo.777.1">using **CamelCase**.</span></span></li>
<li class="calibre15"><span class="kobospan" id="kobo.778.1">For libraries, we normally check if we can add them to any existing bundles. </span><span class="kobospan" id="kobo.778.2">For new libraries that are </span><a id="_idIndexMarker263" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.779.1">normally used together, we can create a new bundle </span><span><span class="kobospan" id="kobo.780.1">for them.</span></span></li>
</ul>
<p class="calibre4"><span class="kobospan" id="kobo.781.1">We will start by defining the versions for our dependencies </span><span><span class="kobospan" id="kobo.782.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.783.1">
[versions]
coreKtx = "1.10.1"
lifecycle = "2.6.1"
activity = "1.7.2"
composeBom = "2022.10.00"
koin = "3.4.3"
koinCompose = "3.4.6"
junit = "4.13.2"
junitExt = "1.1.5"
espresso = "3.5.1"</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.784.1">Here, we are defining all the versions for the libraries that are in our app. </span><span class="kobospan" id="kobo.784.2">We use the </span><strong class="bold"><span class="kobospan" id="kobo.785.1">versions</span></strong><span class="kobospan" id="kobo.786.1"> keyword to define the</span><a id="_idIndexMarker264" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.787.1"> versions. </span><span class="kobospan" id="kobo.787.2">We then define the versions for each library. </span><span class="kobospan" id="kobo.787.3">As we edit this file, you will notice that the IDE prompts you to do a Gradle sync for our changes to be added to the project. </span><span class="kobospan" id="kobo.787.4">For now, we can ignore this and continue editing the file. </span><span class="kobospan" id="kobo.787.5">Next, we will </span><a id="_idIndexMarker265" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.788.1">define the bundles for </span><span><span class="kobospan" id="kobo.789.1">our</span></span><span><a id="_idIndexMarker266" class="calibre3 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.790.1"> dependencies:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.791.1">
[libraries]
core-ktx = { module = "androidx.core:core-ktx", version.ref = "coreKtx" }
lifecycle = { module = "androidx.lifecycle:lifecycle-runtime-ktx", version.ref = "lifecycle" }
activity-compose = { module = "androidx.activity:activity-compose", version.ref = "activity" }
compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
compose-ui = { group = "androidx.compose.ui", name = "ui" }
compose-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
compose-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
compose-material3 = { group = "androidx.compose.material3", name = "material3" }
compose-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
compose-viewmodel = { module = "androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycle" }
koin-core = { module = "io.insert-koin:koin-core", version.ref = "koin" }
koin-android = { module = "io.insert-koin:koin-android", version.ref = "koin" }
koin-android-compose = { module = "io.insert-koin:koin-androidx-compose", version.ref = "koinCompose" }
test-junit = { module = "junit:junit", version.ref = "junit" }
test-junitExt = { module = "androidx.test.ext:junit", version.ref = "junitExt" }
test-espresso = { module = "androidx.test.espresso:espresso-core", version.ref = "espresso" }
test-compose-junit4 = { group = "androidx.compose.ui:ui-test-junit4", name = "ui-test-junit4" }</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.792.1">Here, we </span><a id="_idTextAnchor082" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.793.1">have defined all the </span><a id="_idIndexMarker267" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.794.1">dependencies in our project using</span><a id="_idIndexMarker268" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.795.1"> the </span><span><strong class="bold"><span class="kobospan" id="kobo.796.1">libraries</span></strong></span><span><span class="kobospan" id="kobo.797.1"> keyword.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.798.1">Next, let’s use the </span><strong class="bold"><span class="kobospan" id="kobo.799.1">bundles</span></strong><span class="kobospan" id="kobo.800.1"> keyword to </span><a id="_idIndexMarker269" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.801.1">create a bundle for Koin and compose dependencies </span><span><span class="kobospan" id="kobo.802.1">as</span></span><span><a id="_idIndexMarker270" class="calibre3 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.803.1"> follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.804.1">
[bundles]
compose = ["compose.ui", "compose.ui.graphics", "compose.ui.tooling", "compose.material3", "compose.viewmodel"]
koin = ["koin-core", "koin-android", "koin-android-compose"]</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.805.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.806.1">bundles</span></strong><span class="kobospan" id="kobo.807.1"> keyword allows us to group dependencies and use them as one. </span><span class="kobospan" id="kobo.807.2">Now, we can sync the project. </span><span class="kobospan" id="kobo.807.3">The last step is to update our app-level </span><strong class="source-inline"><span class="kobospan" id="kobo.808.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.809.1"> file to use the version catalog. </span><span class="kobospan" id="kobo.809.2">Open the app-level </span><strong class="source-inline"><span class="kobospan" id="kobo.810.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.811.1"> file and update the dependencies block </span><span><span class="kobospan" id="kobo.812.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.813.1">
dependencies {
    implementation(libs.core.ktx)
    implementation(libs.lifecycle)
    implementation(libs.activity.compose)
    implementation(platform(libs.compose.bom))
    implementation(libs.bundles.compose)
    implementation(libs.bundles.koin)
    testImplementation(libs.test.junit)
    androidTestImplementation(libs.test.junitExt)
    androidTestImplementation(libs.test.espresso)
    androidTestImplementation(platform(libs.compose.bom))
    androidTestImplementation(libs.test.compose.junit4)
    debugImplementation(libs.compose.ui.tooling)
    debugImplementation(libs.compose.manifest)
}</span></pre> <p class="calibre4"><span class="kobospan" id="kobo.814.1">We can now access the </span><a id="_idIndexMarker271" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.815.1">dependencies from our versions catalog file. </span><span class="kobospan" id="kobo.815.2">Notice we must start with the </span><strong class="bold"><span class="kobospan" id="kobo.816.1">libs</span></strong><span class="kobospan" id="kobo.817.1"> keyword, and the next part is the names of the bundles or the dependencies, as per</span><a id="_idIndexMarker272" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.818.1"> our version </span><a id="_idIndexMarker273" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.819.1">catalog. </span><span class="kobospan" id="kobo.819.2">After adding these changes, we can now do Gradle sync. </span><span class="kobospan" id="kobo.819.3">Build and run the app. </span><span class="kobospan" id="kobo.819.4">The app displays a list of pets, as before, and nothing changes since we were only refactoring </span><span><span class="kobospan" id="kobo.820.1">the dependencies.</span></span></p>
<h1 id="_idParaDest-74" class="calibre6"><a id="_idTextAnchor083" class="calibre3 pcalibre pcalibre1"/><span class="kobospan" id="kobo.821.1">Summary</span></h1>
<p class="calibre4"><span class="kobospan" id="kobo.822.1">In this chapter, we have built on what we learned from the previous chapters. </span><span class="kobospan" id="kobo.822.2">We looked at the different architectures available for Android projects. </span><span class="kobospan" id="kobo.822.3">We dived deep into MVVM architecture and its different layers and how to use some of the Jetpack libraries in this architecture. </span><span class="kobospan" id="kobo.822.4">Additionally, we learned how to use advanced architecture features such as dependency injection and Kotlin Gradle DSL, as well as using Gradle version catalogs to define </span><span><span class="kobospan" id="kobo.823.1">our dependencies.</span></span></p>
<p class="calibre4"><span class="kobospan" id="kobo.824.1">As we were creating the MVVM architecture, we used dummy pet data for our data layer. </span><span class="kobospan" id="kobo.824.2">In the next chapter, we are going to learn how to make network calls to fetch data and display it in </span><span><span class="kobospan" id="kobo.825.1">our app.</span></span></p>
</div>
</body></html>