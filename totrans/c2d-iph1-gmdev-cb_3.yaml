- en: Chapter 3. Files and Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 文件和数据
- en: 'In this chapter, we will cover the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下要点：
- en: Reading PLIST data files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 PLIST 数据文件
- en: Reading JSON data files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 JSON 数据文件
- en: Reading XML data files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 XML 数据文件
- en: Saving simple data using NSUserDefaults
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NSUserDefaults 保存简单数据
- en: Archiving objects into archive files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象存档到存档文件中
- en: Mutating nested metadata
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改嵌套元数据
- en: Saving data into a PLIST file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到 PLIST 文件中
- en: Saving data into a SQLite database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到 SQLite 数据库中
- en: Saving data using Core Data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Core Data 保存数据
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Both simple and complex games **process and persist data**. This includes hi-scores,
    player profiles, and saved game sessions to name a few. In this chapter, we will
    use a number of varied techniques to read and write data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简单和复杂游戏都会**处理和持久化数据**。这包括高分、玩家资料和保存的游戏会话等。在本章中，我们将使用多种不同的技术来读取和写入数据。
- en: Reading PLIST data files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取 PLIST 数据文件
- en: This recipe, along with the other two that follow, shows us how to **read and
    parse** simple data into Cocos2d scenes. Here we read a **PLIST** file to create
    a scene that depicts a desert with a few cacti.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱以及随后的两个菜谱展示了如何将简单数据**读取和解析**到 Cocos2d 场景中。在这里，我们读取一个 **PLIST** 文件来创建一个描绘沙漠和几株仙人掌的场景。
- en: '![Reading PLIST data files](img/4002_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![读取 PLIST 数据文件](img/4002_03_01.jpg)'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Loading data from a PLIST file is a seamless way to create a complex structure
    of data in the memory of your program. Here we load `scene1.plist`, which contains
    an array of dictionaries. This translates to an `NSArray` of `NSDictionary` values.
    Inside each dictionary we have a string value with a key of ''type''. This tells
    the application what kind of node it is looking at. The PLIST data format can
    house an infinitely deep combination of arrays and dictionaries that ultimately
    contain primitive data types including Boolean, Data, Date, Number, and String.
    Each one is easily converted into `NSNumber, NSData, NSDate`, or `NSString`. Here
    is what our PLIST file looks like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PLIST 文件中加载数据是一种在程序内存中创建复杂数据结构的无缝方式。在这里，我们加载 `scene1.plist`，它包含一个字典数组。这相当于一个
    `NSArray` 的 `NSDictionary` 值数组。在每一个字典中，我们有一个键为 'type' 的字符串值。这告诉应用程序它在查看什么类型的节点。PLIST
    数据格式可以容纳无限深的数组和字典组合，最终包含包括布尔值、数据、日期、数字和字符串在内的原始数据类型。每一个都可以轻松转换为 `NSNumber`、`NSData`、`NSDate`
    或 `NSString`。以下是我们的 PLIST 文件看起来像：
- en: '![How it works...](img/4002_03_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4002_03_02.jpg)'
- en: A PLIST file is merely an XML file parsed using specific conventions. The previous
    figure is a graphical representation of the XML data. As you'll see in later examples,
    combinations of arrays and dictionaries are the standard for storing data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PLIST 文件仅是一个使用特定约定解析的 XML 文件。前面的图是 XML 数据的图形表示。您将在后面的示例中看到，数组和字典的组合是存储数据的标准。它们最终包含包括布尔值、数据、日期、数字和字符串在内的原始数据类型。每一个都可以轻松转换为
    `NSNumber`、`NSData`、`NSDate` 或 `NSString`。以下是我们的 PLIST 文件看起来像：
- en: Using `getActualPath:`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `getActualPath:`
- en: The `getActualPath:` method provides a shortcut to obtaining the full file path
    of a bundle resource. This allows classes that require exact paths to manipulate
    files in the filesystem.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getActualPath:` 方法提供了一个快速获取包资源完整文件路径的途径。这允许需要精确路径的类在文件系统中操作文件。'
- en: 'Isometric scenes:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等距场景：
- en: As you can see, our scene has some depth and shadow. This technique is simulated
    isometric projection. This is simulated 3D space with no vanishing point. It is
    used in countless 2D games and will be a primary feature of many more recipes
    in this book.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们的场景有一些深度和阴影。这种技术是等距投影的模拟。这是一个没有消失点的模拟 3D 空间。它被用于无数 2D 游戏，并将成为本书中更多菜谱的主要特性。
- en: Reading JSON data files
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取 JSON 数据文件
- en: '**JSON** stands for **JavaScript Object Notation**. It is a very light and
    easily consumable way of packing your data. Thanks to the `CJSONDeserializer`
    library, reading in JSON files is as simple as reading in PLIST files. In the
    following scene, we see a grassy field with a cat and a few trees:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON** 代表 **JavaScript 对象表示法**。它是一种非常轻量且易于消费的数据打包方式。多亏了 `CJSONDeserializer`
    库，读取 JSON 文件就像读取 PLIST 文件一样简单。在下面的场景中，我们看到一个有猫和几棵树的草地：'
- en: '![Reading JSON data files](img/4002_03_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![读取 JSON 数据文件](img/4002_03_03.jpg)'
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Loading JSON into a read-only NSDictionary is fairly straightforward. Here
    is our JSON file with some lines omitted:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 加载到只读 `NSDictionary` 中相当直接。以下是我们的 JSON 文件，其中省略了一些行：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see the JSON format is very succinct. At a glance, it is much easier
    to understand than XML.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，JSON 格式非常简洁。一眼看去，它比 XML 更容易理解。
- en: Reading XML data files
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取 XML 数据文件
- en: 'Finally, we have everyone''s favorite data format: basic unadulterated XML.
    For this recipe, we will use Google''s **GDataXML** library to read and parse
    a simple XML document. In the following scene, we see rocky terrain with some
    boulders and weeds:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了大家最喜欢的数据格式：基本的未加工 XML。对于这个菜谱，我们将使用 Google 的 **GDataXML** 库来读取和解析一个简单的
    XML 文档。在下面的场景中，我们看到有岩石地形和一些巨石和杂草：
- en: '![Reading XML data files](img/4002_03_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![读取 XML 数据文件](img/4002_03_04.jpg)'
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first thing we need to do is integrate Google''s GData XML tools:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是集成 Google 的 GData XML 工具：
- en: 'Download and unzip the `gdata-objectivec-client` from here: [http://code.google.com/p/gdata-objectivec-client/downloads/list](http://code.google.com/p/gdata-objectivec-client/downloads/list)'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里下载并解压 `gdata-objectivec-client`：[http://code.google.com/p/gdata-objectivec-client/downloads/list](http://code.google.com/p/gdata-objectivec-client/downloads/list)
- en: In the folder `Source\XMLSupport` find the files `GDataXMLNode.h` and `GDataXMLNode.m`
    and add them to your project.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Source\XMLSupport` 文件夹中找到 `GDataXMLNode.h` 和 `GDataXMLNode.m` 文件，并将它们添加到你的项目中。
- en: In your **Project Navigator** click on your **Project**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 **Project Navigator** 中点击你的 **Project**。
- en: To the right of this, click on your **Target**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此右侧，点击你的**目标**。
- en: Go to the **Build Settings** tab.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Build Settings** 选项卡。
- en: Find the **Search Paths\Header Search Paths** setting.![How to do it...](img/4002_03_05.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 **Search Paths\Header Search Paths** 设置。![如何操作...](img/4002_03_05.jpg)
- en: Add `/usr/include/libxml2` to the list.![How to do it...](img/4002_03_06.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `/usr/include/libxml2` 添加到列表中。![如何操作...](img/4002_03_06.jpg)
- en: Find the **Linking\Other Linker Flags** section.![How to do it...](img/4002_03_07.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 **Linking\Other Linker Flags** 部分。![如何操作...](img/4002_03_07.jpg)
- en: Add `-lxml2` to the list.![How to do it...](img/4002_03_08.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `-lxml2` 添加到列表中。![如何操作...](img/4002_03_08.jpg)
- en: Import `GDataXMLNode.h` into your code. If it compiles and runs, then you've
    integrated GDataXML successfully.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GDataXMLNode.h` 导入到你的代码中。如果它能编译并运行，那么你就已成功集成了 GDataXML。
- en: 'Now, execute the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下代码：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Reading and processing XML files is not too different from processing PLIST
    and JSON files. In this case, we use the classes `GDataXMLDocument` and `GDataXMLElement`.
    The latter implements the method `(NSString*)stringValue`, which other values
    can be parsed out of. Here is an excerpt of the XML document we are working with:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和处理 XML 文件与处理 PLIST 和 JSON 文件没有太大区别。在这种情况下，我们使用 `GDataXMLDocument` 和 `GDataXMLElement`
    类。后者实现了 `(NSString*)stringValue` 方法，可以从其他值中解析出来。以下是我们在处理的 XML 文档的摘录：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Pure XML is harder to read than a PLIST file and contains more markup language
    fluff than JSON. However, XML allows the use of two features missing from JSON:
    **Attributes** and **Namespaces**. Attributes can be used to provide additional
    information about an **Element**. Namespaces can be used to help reduce the ambiguity
    between Elements.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 XML 比PLIST文件更难阅读，并且比 JSON 包含更多的标记语言冗余。然而，XML 允许使用 JSON 中缺失的两个功能：**属性**和**命名空间**。属性可以用来提供有关
    **元素** 的额外信息。命名空间可以用来帮助减少元素之间的歧义。
- en: See also...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关信息...
- en: 'More information about the XML specification can be found at: [http://www.w3.org/TR/xml/](http://www.w3.org/TR/xml/)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 XML 规范的信息可以在：[http://www.w3.org/TR/xml/](http://www.w3.org/TR/xml/) 找到
- en: Saving simple data using NSUserDefaults
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NSUserDefaults 保存简单数据
- en: For the persistence of user settings and other small bits of data, the iOS framework
    provides the `NSUserDefaults` class. In this example, we are saving the default
    difficulty level for our game.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化用户设置和其他一些小数据，iOS 框架提供了 `NSUserDefaults` 类。在这个例子中，我们正在保存我们游戏的默认难度级别。
- en: '![Saving simple data using NSUserDefaults](img/4002_03_09.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用 NSUserDefaults 保存简单数据](img/4002_03_09.jpg)'
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `NSUserDefaults` class uses a format that is similar to PLIST. It can accept
    the same type of objects including `NSString, NSData, NSNumber`, and others. It
    can also accept arrays and dictionaries.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSUserDefaults` 类使用与 PLIST 类似的格式。它可以接受包括 `NSString, NSData, NSNumber` 以及其他类型的对象。它也可以接受数组和字典。'
- en: 'Loading data:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载数据：
- en: 'These are the crucial lines to remember when loading `NSUserDefaults` data:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当加载 `NSUserDefaults` 数据时，以下这些关键行需要记住：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `if` statement does a simple check to see if that entry exists yet.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if` 语句简单地检查该条目是否已经存在。'
- en: 'Saving data:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存数据：
- en: 'The procedure for saving data is also fairly straightforward:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存数据的过程也非常直接：
- en: '[PRE7]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also...
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见...
- en: We took a brief look at menu customization in this recipe. We will talk about
    this topic at length in [Chapter 4](ch04.html "Chapter 4. Physics"),
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们简要地看了菜单自定义。我们将在 [第 4 章](ch04.html "第 4 章。物理") 中详细讨论这个主题。
- en: Archiving objects into archive files
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象归档到归档文件中
- en: The classes `NSKeyedArchiver` and `NSKeyedUnarchiver` allow us to persist data
    in a very **Object-oriented** way. By conforming to the `NSCoding` protocol, we
    can tell the archiver how to pack and unpack any of our classes. In this recipe,
    we will be packing up a character who has a number of Dungeons and Dragons style
    attributes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `NSKeyedArchiver` 和 `NSKeyedUnarchiver` 允许我们以非常 **面向对象** 的方式持久化数据。通过遵守 `NSCoding`
    协议，我们可以告诉归档器如何打包和解包我们任何类。在这个菜谱中，我们将打包一个具有许多龙与地下城风格属性的角色的数据。
- en: '![Archiving objects into archive files](img/4002_03_10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![将对象归档到归档文件中](img/4002_03_10.jpg)'
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。同时请注意，为了简洁，以下代码中省略了一些部分。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Execute the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Properly **archiving** an object requires a few steps.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地 **归档** 一个对象需要几个步骤。
- en: 'Conforming to the `NSCoding` protocol:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵守 `NSCoding` 协议：
- en: 'The `NSCoding` protocol requires that we implement the following two methods:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NSCoding` 协议要求我们实现以下两个方法：'
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One method packs data into the `NSCoder` object and the other unpacks data out
    of it.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个方法将数据打包到 `NSCoder` 对象中，另一个方法从它解包数据。
- en: 'Using the `Documents` directory:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Documents` 目录：
- en: 'Your app has write access to areas specified by the iOS framework. These include
    the `Documents` and the `Library` directories. In this and future examples, we
    may read from a number of locations within the app bundle but we will usually
    only write to the `Documents` directory. Unlike other areas on the disk, files
    saved here will be maintained when an app is upgraded. Typically, we save pre-made
    templates in a read-only section, copy them into the `Documents` directory, load
    them into memory, and then save modified versions in the `Documents` directory.
    We usually locate a file inside the `Documents` directory with the following code:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的应用程序对 iOS 框架指定的区域有写访问权限。这些包括 `Documents` 和 `Library` 目录。在本例和未来的示例中，我们可能会从应用程序包内的多个位置读取，但我们通常只会写入
    `Documents` 目录。与磁盘上的其他区域不同，在此处保存的文件在应用程序升级时将得到保留。通常，我们会在以下代码中定位 `Documents` 目录内的文件：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This returns the absolute file path.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回绝对文件路径。
- en: Using `NSFileManager:`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 `NSFileManager`: '
- en: We also use `NSFileManager` to determine whether a file exists and also to remove
    files as necessary.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还使用 `NSFileManager` 来确定文件是否存在，并在必要时删除文件。
- en: '[PRE11]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using `NSKeyedArchiver` and `NSKeyedUnarchiver:`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 `NSKeyedArchiver` 和 `NSKeyedUnarchiver`:'
- en: 'Finally, with all these tools at hand we can archive and unarchive objects
    using the classes `NSKeyedArchiver` and `NSKeyedUnarchiver`:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，有了这些工具在手，我们可以使用 `NSKeyedArchiver` 和 `NSKeyedUnarchiver` 类来归档和解档对象：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Mutating nested metadata
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改嵌套元数据
- en: Data from data files is often loaded into a non-mutable, 'nested' structure
    of arrays and dictionaries. This non-mutable structure leaves the data un-editable.
    In this recipe, we will read in a nested JSON data structure and then recursively
    re-create the data using mutable data structures to allow the data to be edited.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 数据文件中的数据通常被加载到一个不可变的、嵌套的数组和大字典结构中。这个不可变结构使得数据不可编辑。在这个菜谱中，我们将读取一个嵌套的 JSON 数据结构，然后使用可变数据结构递归地重新创建数据，以便允许编辑数据。
- en: '![Mutating nested metadata](img/4002_03_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![修改嵌套元数据](img/4002_03_11.jpg)'
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目*RecipeCollection01*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Just like in the previous section, *Reading JSON data files*, here we first
    read in data from a JSON file. The data consists of a `NSDictionary` object with
    nested arrays, dictionaries, and, finally, strings. To create a ''deep'' mutable
    copy, we call the following method in our `GameHelper` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前一节中，*读取JSON数据文件*，我们首先从JSON文件中读取数据。数据由一个嵌套数组、字典和字符串的`NSDictionary`对象组成。为了创建一个“深层”可变副本，我们在`GameHelper`类中调用以下方法：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method assumes that the root node is a dictionary.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法假设根节点是一个字典。
- en: 'The `makeRecMutableCopy` method:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeRecMutableCopy`方法：'
- en: In this recipe, we've spared the gruesome details of this method. Put simply,
    it recursively goes through the nested structure turning `NSDictionary` objects
    into `NSMutableDictionary` objects and `NSArray` objects into `NSMutableArray`
    objects.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们省略了此方法的恐怖细节。简单地说，它递归地遍历嵌套结构，将`NSDictionary`对象转换为`NSMutableDictionary`对象，将`NSArray`对象转换为`NSMutableArray`对象。
- en: 'Modifying the data tree:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改数据树：
- en: Once we have a nested mutable structure, we can access it and modify elements
    as necessary. Click the **Randomize Data** button to randomly change some data
    in the structure.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们有一个嵌套的可变结构，我们就可以访问它并根据需要修改元素。点击**随机化数据**按钮以随机更改结构中的某些数据。
- en: Saving data into a PLIST file
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据保存到PLIST文件中
- en: For the next three recipes, we have three small games that need to have their
    hi-scores persisted. In this recipe, we see a whack-a-mole game that will use
    a PLIST file to maintain a list of hi-scores.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的三个菜谱，我们有三个需要持久化其最高分的小游戏。在这个菜谱中，我们看到了一个打地鼠游戏，它将使用PLIST文件来维护一个最高分列表。
- en: '![Saving data into a PLIST file](img/4002_03_12.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![将数据保存到PLIST文件中](img/4002_03_12.jpg)'
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity all game logic has been omitted from the following
    code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目*RecipeCollection01*以获取此菜谱的完整工作代码。为了简洁起见，以下代码中省略了所有游戏逻辑。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing we do is check the `Documents` directory for `whackamole.plist`
    and we load that data into the `fileDict dictionary`. If we don''t find that file
    we open `whackamole_template.plist` from the `Resources/Data` folder. It looks
    like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是检查`Documents`目录中的`whackamole.plist`文件，并将该数据加载到`fileDict`字典中。如果我们找不到该文件，我们将从`Resources/Data`文件夹中打开`whackamole_template.plist`。它看起来像这样：
- en: '![How it works...](img/4002_03_13.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4002_03_13.jpg)'
- en: 'Whichever file we load, the loading line looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们加载哪个文件，加载行看起来都像这样：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After modifying the `fileDict` dictionary we save it to `whackamole.plist`
    in the `Documents` directory:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改`fileDict`字典后，我们将它保存到`Documents`目录下的`whackamole.plist`中：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All things considered, this is a very simple way to persist data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有因素，这是一个非常简单的方式来持久化数据。
- en: Saving data into an SQLite database
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据保存到SQLite数据库中
- en: The second game we have is a "skeet shooting" game where discs are fired in
    the air and the goal is to shoot as many down as possible within a certain time
    limit. For this game, we will persist hi-score data using a SQLite database. We
    will be using the **FMDB Objective-C SQLite wrapper** to access the SQLite database
    within our code and the **Firefox plugin SQLite Manager** to create an initial
    database file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第二个游戏是一个“飞碟射击”游戏，飞碟被射入空中，目标是尽可能在规定时间内射下尽可能多的飞碟。对于这个游戏，我们将使用SQLite数据库来持久化最高分数据。我们将使用**FMDB
    Objective-C SQLite包装器**来访问代码中的SQLite数据库，并使用**Firefox插件SQLite Manager**来创建初始数据库文件。
- en: '![Saving data into an SQLite database](img/4002_03_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![将数据保存到SQLite数据库中](img/4002_03_14.jpg)'
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity, all game logic has been omitted from the following
    code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目*RecipeCollection01*以获取此菜谱的完整工作代码。为了简洁起见，以下代码中省略了所有游戏逻辑。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To use SQLite we first need to do a few things:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SQLite，我们首先需要做一些事情：
- en: First we need to add the `libsqlite3.0.dylib` framework. You can do this by
    right clicking on your project and going to **Add > Existing Frameworks** and
    then, under **iOS 4.x SDK**, selecting `libsqlite3.0.dylib`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加`libsqlite3.0.dylib`框架。你可以通过右键单击你的项目，然后转到**添加 > 已存在的框架**，然后在**iOS 4.x
    SDK**下选择`libsqlite3.0.dylib`。
- en: 'Next, we need to add the FMDB Objective-C SQLite wrapper to our project. FMDB
    can be downloaded here: [https://github.com/ccgus/fmdb](http://https://github.com/ccgus/fmdb).'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 FMDB Objective-C SQLite 包装器添加到我们的项目中。FMDB 可以从这里下载：[https://github.com/ccgus/fmdb](http://https://github.com/ccgus/fmdb)。
- en: 'Download and install the Firefox plugin SQLite Manager from here: [https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/](http://https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/)'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里下载并安装 Firefox 插件 SQLite Manager：[https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/](http://https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/)
- en: Now we need to create a new SQLite database as our default database template.
    Go into **SQLite Manager** and go to **Database > New Database**. For our project
    we created `skeetshooter_template.sqlite` with a **hiscores** table that has the
    fields **name** and **score:**
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个新的 SQLite 数据库作为我们的默认数据库模板。进入 **SQLite Manager** 并转到 **数据库 > 新数据库**。对于我们的项目，我们创建了
    `skeetshooter_template.sqlite`，其中包含一个名为 **hiscores** 的表，该表具有 **name** 和 **score**
    字段：
- en: '![How to do it...](img/4002_03_15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/4002_03_15.jpg)'
- en: 'Once we have our database template, execute the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了数据库模板，执行以下代码：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Saving and loading to a SQLite database is a little different than using a
    PLIST file. The main way to read and write to a SQLite database is through the
    following method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据保存到 SQLite 数据库与使用 PLIST 文件略有不同。读取和写入 SQLite 数据库的主要方式是通过以下方法：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns a `FMResultSet` object which can then be iterated through:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个 `FMResultSet` 对象，然后可以遍历：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be sure to iterate through each `FMResultSet` object you create and also call
    `[rs close]` as well as SQLite will throw errors if you don't follow through each
    time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 确保迭代你创建的每个 `FMResultSet` 对象，并调用 `[rs close]`，否则 SQLite 将会抛出错误。
- en: 'Querying your SQLite database:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询你的 SQLite 数据库：
- en: Using this simple but powerful interface you can perform any type of query normally
    allowed on a SQLite database. In this recipe, we have one table with two values.
    Feel free to experiment with more complex data models.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个简单但强大的界面，你可以执行在 SQLite 数据库上通常允许的任何类型的查询。在这个菜谱中，我们有一个包含两个值的表。请随意尝试更复杂的数据模型。
- en: Saving data using Core Data
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Core Data 保存数据
- en: Our third game is a memory card game where you must flip over sets of cards.
    Flip over two matching cards and you get a point. Flip over two that don't match
    and you get a strike. Three strikes and you're out. For this game we persist hi-score
    data using Apple's **Core Data** model pattern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个游戏是一个记忆卡牌游戏，你必须翻过一组组卡片。翻到两张匹配的卡片，你得到一分。翻到两张不匹配的卡片，你得到一次失误。三次失误，你就出局了。对于这个游戏，我们使用苹果的
    **Core Data** 模式来持久化高分数据。
- en: '![Saving data using Core Data](img/4002_03_16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Core Data 保存数据](img/4002_03_16.jpg)'
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity all game logic has been omitted from the following
    code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。为了简洁起见，以下代码中省略了所有游戏逻辑。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Setting up our Core Data based recipe requires a number of steps.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 设置基于 Core Data 的菜谱需要多个步骤。
- en: First we need to add the CoreData framework. You can do this by right clicking
    on your project and going to **Add > Existing Frameworks** and then, under **iOS
    4.x SDK**, select `CoreData.framework`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加 CoreData 框架。你可以通过在项目上右键单击并选择 **添加 > 已存在框架** 来完成此操作，然后在 **iOS 4.x SDK**
    下选择 `CoreData.framework`。
- en: Create a new folder inside your resources entitled `Data Model`. Inside this
    folder, create a class entitled `Hiscore`, which derives from `ManagedObject:`
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的资源中创建一个名为 `Data Model` 的新文件夹。在这个文件夹内，创建一个名为 `Hiscore` 的类，它继承自 `ManagedObject:`。
- en: '[PRE21]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After adding this class right click on your project and select **Add > New File**.
    Under **iOS** and under **Resource** select and create a new **Data Model**.![How
    to do it...](img/4002_03_17.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此类后，右键单击项目并选择 **添加 > 新文件**。在 **iOS** 和 **资源** 下选择并创建一个新的 **数据模型**。![如何操作...](img/4002_03_17.jpg)
- en: Name this data model `hiscore` and add your existing `Hiscore` class to this
    data model when you are prompted.![How to do it...](img/4002_03_18.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此数据模型命名为 `hiscore`，并在提示时将现有的 `Hiscore` 类添加到该数据模型中。![如何操作...](img/4002_03_18.jpg)
- en: 'Click on `hiscores.xcdatamodel` in XCode. Click on the `Hiscore` entity and
    then add two new properties to it which correspond to the two properties in your
    `Hiscore` class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XCode 中单击 `hiscores.xcdatamodel`。单击 `Hiscore` 实体，然后向其中添加两个新属性，这两个属性对应于 `Hiscore`
    类中的两个属性：
- en: '![How to do it...](img/4002_03_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/4002_03_19.jpg)'
- en: 'Now we''re ready to get down to some code. Execute the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始编写代码。执行以下操作：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After some complex initialization, we are able to manipulate a simple array
    of `Hiscore` objects using the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些复杂的初始化后，我们可以使用以下代码来操作一个简单的`Hiscore`对象数组：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After modifying any of these objects we can save them all with the following
    line:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这些对象中的任何一个后，我们可以使用以下行将它们全部保存：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'New entries can be added using the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码添加新条目：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A more complex use or explanation of Core Data is outside the scope of this
    book. This example serves merely as a working introduction to using Core Data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data的更复杂的使用或解释超出了本书的范围。本例仅作为使用Core Data的工作介绍。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Getting Core Data to work properly in XCode can sometimes be somewhat tricky.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在XCode中正确配置Core Data有时可能有些棘手。
- en: 'SQLite database creation errors:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite数据库创建错误：
- en: Depending on the circumstances, Core Data may fail to create a SQLite database
    from the model you've created. To fix this problem make sure your xcdatamodel
    files and your NSManagedObject classes are located in the same folder on the disk
    as well as in the same XCode group. If this doesn't fix the problem delete these
    files from the project but not the disk then re-add them. If that doesn't work
    you can also create a SQLite database manually. This requires you to follow Core
    Data conventions. To help with this process, I've included the file memory_template.sqlite.
    This file has the correct Core Data database structure. The recipe will also use
    this file if it fails to create the SQLite database.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据情况，Core Data可能无法从您创建的模型中创建SQLite数据库。要解决这个问题，请确保您的`xcdatamodel`文件和您的`NSManagedObject`类在磁盘上以及在同一XCode组中位于相同的文件夹。如果这不能解决问题，请从项目中删除这些文件，但不要从磁盘上删除，然后重新添加它们。如果这还不行，您还可以手动创建一个SQLite数据库。这需要您遵循Core
    Data约定。为了帮助这个过程，我包括了`memory_template.sqlite`文件。此文件具有正确的Core Data数据库结构。如果它无法创建SQLite数据库，食谱也将使用此文件。
- en: 'Handling errors:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误：
- en: 'In a number of examples we specify error:nil. To actually handle any of these
    errors do the following:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在许多示例中，我们指定了`error:nil`。要实际处理这些错误，请执行以下操作：
- en: '[PRE26]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using Core Data can often seem like overkill. However, applications with complex
    underlying data structures
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Core Data有时可能显得有些过度。然而，具有复杂底层数据结构的应用程序
