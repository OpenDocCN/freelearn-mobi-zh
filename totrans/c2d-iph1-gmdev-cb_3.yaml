- en: Chapter 3. Files and Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Reading PLIST data files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading JSON data files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading XML data files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving simple data using NSUserDefaults
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving objects into archive files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating nested metadata
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data into a PLIST file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data into a SQLite database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data using Core Data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both simple and complex games **process and persist data**. This includes hi-scores,
    player profiles, and saved game sessions to name a few. In this chapter, we will
    use a number of varied techniques to read and write data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Reading PLIST data files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe, along with the other two that follow, shows us how to **read and
    parse** simple data into Cocos2d scenes. Here we read a **PLIST** file to create
    a scene that depicts a desert with a few cacti.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading PLIST data files](img/4002_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loading data from a PLIST file is a seamless way to create a complex structure
    of data in the memory of your program. Here we load `scene1.plist`, which contains
    an array of dictionaries. This translates to an `NSArray` of `NSDictionary` values.
    Inside each dictionary we have a string value with a key of ''type''. This tells
    the application what kind of node it is looking at. The PLIST data format can
    house an infinitely deep combination of arrays and dictionaries that ultimately
    contain primitive data types including Boolean, Data, Date, Number, and String.
    Each one is easily converted into `NSNumber, NSData, NSDate`, or `NSString`. Here
    is what our PLIST file looks like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4002_03_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: A PLIST file is merely an XML file parsed using specific conventions. The previous
    figure is a graphical representation of the XML data. As you'll see in later examples,
    combinations of arrays and dictionaries are the standard for storing data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Using `getActualPath:`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getActualPath:` method provides a shortcut to obtaining the full file path
    of a bundle resource. This allows classes that require exact paths to manipulate
    files in the filesystem.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Isometric scenes:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, our scene has some depth and shadow. This technique is simulated
    isometric projection. This is simulated 3D space with no vanishing point. It is
    used in countless 2D games and will be a primary feature of many more recipes
    in this book.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading JSON data files
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**. It is a very light and
    easily consumable way of packing your data. Thanks to the `CJSONDeserializer`
    library, reading in JSON files is as simple as reading in PLIST files. In the
    following scene, we see a grassy field with a cat and a few trees:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading JSON data files](img/4002_03_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loading JSON into a read-only NSDictionary is fairly straightforward. Here
    is our JSON file with some lines omitted:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see the JSON format is very succinct. At a glance, it is much easier
    to understand than XML.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Reading XML data files
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we have everyone''s favorite data format: basic unadulterated XML.
    For this recipe, we will use Google''s **GDataXML** library to read and parse
    a simple XML document. In the following scene, we see rocky terrain with some
    boulders and weeds:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading XML data files](img/4002_03_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is integrate Google''s GData XML tools:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and unzip the `gdata-objectivec-client` from here: [http://code.google.com/p/gdata-objectivec-client/downloads/list](http://code.google.com/p/gdata-objectivec-client/downloads/list)'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `Source\XMLSupport` find the files `GDataXMLNode.h` and `GDataXMLNode.m`
    and add them to your project.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your **Project Navigator** click on your **Project**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the right of this, click on your **Target**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Build Settings** tab.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Search Paths\Header Search Paths** setting.![How to do it...](img/4002_03_05.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `/usr/include/libxml2` to the list.![How to do it...](img/4002_03_06.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Linking\Other Linker Flags** section.![How to do it...](img/4002_03_07.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `-lxml2` to the list.![How to do it...](img/4002_03_08.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `GDataXMLNode.h` into your code. If it compiles and runs, then you've
    integrated GDataXML successfully.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, execute the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading and processing XML files is not too different from processing PLIST
    and JSON files. In this case, we use the classes `GDataXMLDocument` and `GDataXMLElement`.
    The latter implements the method `(NSString*)stringValue`, which other values
    can be parsed out of. Here is an excerpt of the XML document we are working with:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Pure XML is harder to read than a PLIST file and contains more markup language
    fluff than JSON. However, XML allows the use of two features missing from JSON:
    **Attributes** and **Namespaces**. Attributes can be used to provide additional
    information about an **Element**. Namespaces can be used to help reduce the ambiguity
    between Elements.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More information about the XML specification can be found at: [http://www.w3.org/TR/xml/](http://www.w3.org/TR/xml/)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Saving simple data using NSUserDefaults
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the persistence of user settings and other small bits of data, the iOS framework
    provides the `NSUserDefaults` class. In this example, we are saving the default
    difficulty level for our game.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving simple data using NSUserDefaults](img/4002_03_09.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSUserDefaults` class uses a format that is similar to PLIST. It can accept
    the same type of objects including `NSString, NSData, NSNumber`, and others. It
    can also accept arrays and dictionaries.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading data:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the crucial lines to remember when loading `NSUserDefaults` data:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `if` statement does a simple check to see if that entry exists yet.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Saving data:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The procedure for saving data is also fairly straightforward:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also...
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We took a brief look at menu customization in this recipe. We will talk about
    this topic at length in [Chapter 4](ch04.html "Chapter 4. Physics"),
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Archiving objects into archive files
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes `NSKeyedArchiver` and `NSKeyedUnarchiver` allow us to persist data
    in a very **Object-oriented** way. By conforming to the `NSCoding` protocol, we
    can tell the archiver how to pack and unpack any of our classes. In this recipe,
    we will be packing up a character who has a number of Dungeons and Dragons style
    attributes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Archiving objects into archive files](img/4002_03_10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properly **archiving** an object requires a few steps.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Conforming to the `NSCoding` protocol:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `NSCoding` protocol requires that we implement the following two methods:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One method packs data into the `NSCoder` object and the other unpacks data out
    of it.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the `Documents` directory:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your app has write access to areas specified by the iOS framework. These include
    the `Documents` and the `Library` directories. In this and future examples, we
    may read from a number of locations within the app bundle but we will usually
    only write to the `Documents` directory. Unlike other areas on the disk, files
    saved here will be maintained when an app is upgraded. Typically, we save pre-made
    templates in a read-only section, copy them into the `Documents` directory, load
    them into memory, and then save modified versions in the `Documents` directory.
    We usually locate a file inside the `Documents` directory with the following code:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This returns the absolute file path.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `NSFileManager:`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also use `NSFileManager` to determine whether a file exists and also to remove
    files as necessary.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using `NSKeyedArchiver` and `NSKeyedUnarchiver:`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, with all these tools at hand we can archive and unarchive objects
    using the classes `NSKeyedArchiver` and `NSKeyedUnarchiver`:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Mutating nested metadata
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data from data files is often loaded into a non-mutable, 'nested' structure
    of arrays and dictionaries. This non-mutable structure leaves the data un-editable.
    In this recipe, we will read in a nested JSON data structure and then recursively
    re-create the data using mutable data structures to allow the data to be edited.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Mutating nested metadata](img/4002_03_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like in the previous section, *Reading JSON data files*, here we first
    read in data from a JSON file. The data consists of a `NSDictionary` object with
    nested arrays, dictionaries, and, finally, strings. To create a ''deep'' mutable
    copy, we call the following method in our `GameHelper` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method assumes that the root node is a dictionary.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The `makeRecMutableCopy` method:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we've spared the gruesome details of this method. Put simply,
    it recursively goes through the nested structure turning `NSDictionary` objects
    into `NSMutableDictionary` objects and `NSArray` objects into `NSMutableArray`
    objects.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modifying the data tree:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have a nested mutable structure, we can access it and modify elements
    as necessary. Click the **Randomize Data** button to randomly change some data
    in the structure.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Saving data into a PLIST file
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next three recipes, we have three small games that need to have their
    hi-scores persisted. In this recipe, we see a whack-a-mole game that will use
    a PLIST file to maintain a list of hi-scores.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data into a PLIST file](img/4002_03_12.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity all game logic has been omitted from the following
    code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we do is check the `Documents` directory for `whackamole.plist`
    and we load that data into the `fileDict dictionary`. If we don''t find that file
    we open `whackamole_template.plist` from the `Resources/Data` folder. It looks
    like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4002_03_13.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Whichever file we load, the loading line looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After modifying the `fileDict` dictionary we save it to `whackamole.plist`
    in the `Documents` directory:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All things considered, this is a very simple way to persist data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Saving data into an SQLite database
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second game we have is a "skeet shooting" game where discs are fired in
    the air and the goal is to shoot as many down as possible within a certain time
    limit. For this game, we will persist hi-score data using a SQLite database. We
    will be using the **FMDB Objective-C SQLite wrapper** to access the SQLite database
    within our code and the **Firefox plugin SQLite Manager** to create an initial
    database file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data into an SQLite database](img/4002_03_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity, all game logic has been omitted from the following
    code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use SQLite we first need to do a few things:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: First we need to add the `libsqlite3.0.dylib` framework. You can do this by
    right clicking on your project and going to **Add > Existing Frameworks** and
    then, under **iOS 4.x SDK**, selecting `libsqlite3.0.dylib`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add the FMDB Objective-C SQLite wrapper to our project. FMDB
    can be downloaded here: [https://github.com/ccgus/fmdb](http://https://github.com/ccgus/fmdb).'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download and install the Firefox plugin SQLite Manager from here: [https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/](http://https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/)'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to create a new SQLite database as our default database template.
    Go into **SQLite Manager** and go to **Database > New Database**. For our project
    we created `skeetshooter_template.sqlite` with a **hiscores** table that has the
    fields **name** and **score:**
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4002_03_15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'Once we have our database template, execute the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Saving and loading to a SQLite database is a little different than using a
    PLIST file. The main way to read and write to a SQLite database is through the
    following method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns a `FMResultSet` object which can then be iterated through:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be sure to iterate through each `FMResultSet` object you create and also call
    `[rs close]` as well as SQLite will throw errors if you don't follow through each
    time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying your SQLite database:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this simple but powerful interface you can perform any type of query normally
    allowed on a SQLite database. In this recipe, we have one table with two values.
    Feel free to experiment with more complex data models.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Saving data using Core Data
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our third game is a memory card game where you must flip over sets of cards.
    Flip over two matching cards and you get a point. Flip over two that don't match
    and you get a strike. Three strikes and you're out. For this game we persist hi-score
    data using Apple's **Core Data** model pattern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data using Core Data](img/4002_03_16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity all game logic has been omitted from the following
    code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up our Core Data based recipe requires a number of steps.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: First we need to add the CoreData framework. You can do this by right clicking
    on your project and going to **Add > Existing Frameworks** and then, under **iOS
    4.x SDK**, select `CoreData.framework`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder inside your resources entitled `Data Model`. Inside this
    folder, create a class entitled `Hiscore`, which derives from `ManagedObject:`
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After adding this class right click on your project and select **Add > New File**.
    Under **iOS** and under **Resource** select and create a new **Data Model**.![How
    to do it...](img/4002_03_17.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this data model `hiscore` and add your existing `Hiscore` class to this
    data model when you are prompted.![How to do it...](img/4002_03_18.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on `hiscores.xcdatamodel` in XCode. Click on the `Hiscore` entity and
    then add two new properties to it which correspond to the two properties in your
    `Hiscore` class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/4002_03_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Now we''re ready to get down to some code. Execute the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始编写代码。执行以下操作：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After some complex initialization, we are able to manipulate a simple array
    of `Hiscore` objects using the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些复杂的初始化后，我们可以使用以下代码来操作一个简单的`Hiscore`对象数组：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After modifying any of these objects we can save them all with the following
    line:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这些对象中的任何一个后，我们可以使用以下行将它们全部保存：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'New entries can be added using the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码添加新条目：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A more complex use or explanation of Core Data is outside the scope of this
    book. This example serves merely as a working introduction to using Core Data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data的更复杂的使用或解释超出了本书的范围。本例仅作为使用Core Data的工作介绍。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Getting Core Data to work properly in XCode can sometimes be somewhat tricky.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在XCode中正确配置Core Data有时可能有些棘手。
- en: 'SQLite database creation errors:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite数据库创建错误：
- en: Depending on the circumstances, Core Data may fail to create a SQLite database
    from the model you've created. To fix this problem make sure your xcdatamodel
    files and your NSManagedObject classes are located in the same folder on the disk
    as well as in the same XCode group. If this doesn't fix the problem delete these
    files from the project but not the disk then re-add them. If that doesn't work
    you can also create a SQLite database manually. This requires you to follow Core
    Data conventions. To help with this process, I've included the file memory_template.sqlite.
    This file has the correct Core Data database structure. The recipe will also use
    this file if it fails to create the SQLite database.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据情况，Core Data可能无法从您创建的模型中创建SQLite数据库。要解决这个问题，请确保您的`xcdatamodel`文件和您的`NSManagedObject`类在磁盘上以及在同一XCode组中位于相同的文件夹。如果这不能解决问题，请从项目中删除这些文件，但不要从磁盘上删除，然后重新添加它们。如果这还不行，您还可以手动创建一个SQLite数据库。这需要您遵循Core
    Data约定。为了帮助这个过程，我包括了`memory_template.sqlite`文件。此文件具有正确的Core Data数据库结构。如果它无法创建SQLite数据库，食谱也将使用此文件。
- en: 'Handling errors:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误：
- en: 'In a number of examples we specify error:nil. To actually handle any of these
    errors do the following:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在许多示例中，我们指定了`error:nil`。要实际处理这些错误，请执行以下操作：
- en: '[PRE26]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using Core Data can often seem like overkill. However, applications with complex
    underlying data structures
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Core Data有时可能显得有些过度。然而，具有复杂底层数据结构的应用程序
