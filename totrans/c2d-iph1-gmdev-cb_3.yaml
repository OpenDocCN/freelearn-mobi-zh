- en: Chapter 3. Files and Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading PLIST data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading JSON data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading XML data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving simple data using NSUserDefaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving objects into archive files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating nested metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data into a PLIST file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data into a SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data using Core Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both simple and complex games **process and persist data**. This includes hi-scores,
    player profiles, and saved game sessions to name a few. In this chapter, we will
    use a number of varied techniques to read and write data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading PLIST data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe, along with the other two that follow, shows us how to **read and
    parse** simple data into Cocos2d scenes. Here we read a **PLIST** file to create
    a scene that depicts a desert with a few cacti.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading PLIST data files](img/4002_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loading data from a PLIST file is a seamless way to create a complex structure
    of data in the memory of your program. Here we load `scene1.plist`, which contains
    an array of dictionaries. This translates to an `NSArray` of `NSDictionary` values.
    Inside each dictionary we have a string value with a key of ''type''. This tells
    the application what kind of node it is looking at. The PLIST data format can
    house an infinitely deep combination of arrays and dictionaries that ultimately
    contain primitive data types including Boolean, Data, Date, Number, and String.
    Each one is easily converted into `NSNumber, NSData, NSDate`, or `NSString`. Here
    is what our PLIST file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4002_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A PLIST file is merely an XML file parsed using specific conventions. The previous
    figure is a graphical representation of the XML data. As you'll see in later examples,
    combinations of arrays and dictionaries are the standard for storing data.
  prefs: []
  type: TYPE_NORMAL
- en: Using `getActualPath:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getActualPath:` method provides a shortcut to obtaining the full file path
    of a bundle resource. This allows classes that require exact paths to manipulate
    files in the filesystem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Isometric scenes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, our scene has some depth and shadow. This technique is simulated
    isometric projection. This is simulated 3D space with no vanishing point. It is
    used in countless 2D games and will be a primary feature of many more recipes
    in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading JSON data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**. It is a very light and
    easily consumable way of packing your data. Thanks to the `CJSONDeserializer`
    library, reading in JSON files is as simple as reading in PLIST files. In the
    following scene, we see a grassy field with a cat and a few trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading JSON data files](img/4002_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loading JSON into a read-only NSDictionary is fairly straightforward. Here
    is our JSON file with some lines omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the JSON format is very succinct. At a glance, it is much easier
    to understand than XML.
  prefs: []
  type: TYPE_NORMAL
- en: Reading XML data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we have everyone''s favorite data format: basic unadulterated XML.
    For this recipe, we will use Google''s **GDataXML** library to read and parse
    a simple XML document. In the following scene, we see rocky terrain with some
    boulders and weeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading XML data files](img/4002_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is integrate Google''s GData XML tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and unzip the `gdata-objectivec-client` from here: [http://code.google.com/p/gdata-objectivec-client/downloads/list](http://code.google.com/p/gdata-objectivec-client/downloads/list)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `Source\XMLSupport` find the files `GDataXMLNode.h` and `GDataXMLNode.m`
    and add them to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your **Project Navigator** click on your **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the right of this, click on your **Target**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Build Settings** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Search Paths\Header Search Paths** setting.![How to do it...](img/4002_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `/usr/include/libxml2` to the list.![How to do it...](img/4002_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Linking\Other Linker Flags** section.![How to do it...](img/4002_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `-lxml2` to the list.![How to do it...](img/4002_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `GDataXMLNode.h` into your code. If it compiles and runs, then you've
    integrated GDataXML successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading and processing XML files is not too different from processing PLIST
    and JSON files. In this case, we use the classes `GDataXMLDocument` and `GDataXMLElement`.
    The latter implements the method `(NSString*)stringValue`, which other values
    can be parsed out of. Here is an excerpt of the XML document we are working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Pure XML is harder to read than a PLIST file and contains more markup language
    fluff than JSON. However, XML allows the use of two features missing from JSON:
    **Attributes** and **Namespaces**. Attributes can be used to provide additional
    information about an **Element**. Namespaces can be used to help reduce the ambiguity
    between Elements.'
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More information about the XML specification can be found at: [http://www.w3.org/TR/xml/](http://www.w3.org/TR/xml/)'
  prefs: []
  type: TYPE_NORMAL
- en: Saving simple data using NSUserDefaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the persistence of user settings and other small bits of data, the iOS framework
    provides the `NSUserDefaults` class. In this example, we are saving the default
    difficulty level for our game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving simple data using NSUserDefaults](img/4002_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSUserDefaults` class uses a format that is similar to PLIST. It can accept
    the same type of objects including `NSString, NSData, NSNumber`, and others. It
    can also accept arrays and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the crucial lines to remember when loading `NSUserDefaults` data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `if` statement does a simple check to see if that entry exists yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Saving data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The procedure for saving data is also fairly straightforward:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We took a brief look at menu customization in this recipe. We will talk about
    this topic at length in [Chapter 4](ch04.html "Chapter 4. Physics"),
  prefs: []
  type: TYPE_NORMAL
- en: Archiving objects into archive files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes `NSKeyedArchiver` and `NSKeyedUnarchiver` allow us to persist data
    in a very **Object-oriented** way. By conforming to the `NSCoding` protocol, we
    can tell the archiver how to pack and unpack any of our classes. In this recipe,
    we will be packing up a character who has a number of Dungeons and Dragons style
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Archiving objects into archive files](img/4002_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properly **archiving** an object requires a few steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conforming to the `NSCoding` protocol:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `NSCoding` protocol requires that we implement the following two methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One method packs data into the `NSCoder` object and the other unpacks data out
    of it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the `Documents` directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your app has write access to areas specified by the iOS framework. These include
    the `Documents` and the `Library` directories. In this and future examples, we
    may read from a number of locations within the app bundle but we will usually
    only write to the `Documents` directory. Unlike other areas on the disk, files
    saved here will be maintained when an app is upgraded. Typically, we save pre-made
    templates in a read-only section, copy them into the `Documents` directory, load
    them into memory, and then save modified versions in the `Documents` directory.
    We usually locate a file inside the `Documents` directory with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This returns the absolute file path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `NSFileManager:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also use `NSFileManager` to determine whether a file exists and also to remove
    files as necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `NSKeyedArchiver` and `NSKeyedUnarchiver:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, with all these tools at hand we can archive and unarchive objects
    using the classes `NSKeyedArchiver` and `NSKeyedUnarchiver`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Mutating nested metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data from data files is often loaded into a non-mutable, 'nested' structure
    of arrays and dictionaries. This non-mutable structure leaves the data un-editable.
    In this recipe, we will read in a nested JSON data structure and then recursively
    re-create the data using mutable data structures to allow the data to be edited.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mutating nested metadata](img/4002_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like in the previous section, *Reading JSON data files*, here we first
    read in data from a JSON file. The data consists of a `NSDictionary` object with
    nested arrays, dictionaries, and, finally, strings. To create a ''deep'' mutable
    copy, we call the following method in our `GameHelper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method assumes that the root node is a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `makeRecMutableCopy` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we've spared the gruesome details of this method. Put simply,
    it recursively goes through the nested structure turning `NSDictionary` objects
    into `NSMutableDictionary` objects and `NSArray` objects into `NSMutableArray`
    objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modifying the data tree:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have a nested mutable structure, we can access it and modify elements
    as necessary. Click the **Randomize Data** button to randomly change some data
    in the structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Saving data into a PLIST file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next three recipes, we have three small games that need to have their
    hi-scores persisted. In this recipe, we see a whack-a-mole game that will use
    a PLIST file to maintain a list of hi-scores.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data into a PLIST file](img/4002_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity all game logic has been omitted from the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we do is check the `Documents` directory for `whackamole.plist`
    and we load that data into the `fileDict dictionary`. If we don''t find that file
    we open `whackamole_template.plist` from the `Resources/Data` folder. It looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4002_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Whichever file we load, the loading line looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After modifying the `fileDict` dictionary we save it to `whackamole.plist`
    in the `Documents` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All things considered, this is a very simple way to persist data.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data into an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second game we have is a "skeet shooting" game where discs are fired in
    the air and the goal is to shoot as many down as possible within a certain time
    limit. For this game, we will persist hi-score data using a SQLite database. We
    will be using the **FMDB Objective-C SQLite wrapper** to access the SQLite database
    within our code and the **Firefox plugin SQLite Manager** to create an initial
    database file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data into an SQLite database](img/4002_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity, all game logic has been omitted from the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use SQLite we first need to do a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: First we need to add the `libsqlite3.0.dylib` framework. You can do this by
    right clicking on your project and going to **Add > Existing Frameworks** and
    then, under **iOS 4.x SDK**, selecting `libsqlite3.0.dylib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add the FMDB Objective-C SQLite wrapper to our project. FMDB
    can be downloaded here: [https://github.com/ccgus/fmdb](http://https://github.com/ccgus/fmdb).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download and install the Firefox plugin SQLite Manager from here: [https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/](http://https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to create a new SQLite database as our default database template.
    Go into **SQLite Manager** and go to **Database > New Database**. For our project
    we created `skeetshooter_template.sqlite` with a **hiscores** table that has the
    fields **name** and **score:**
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4002_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have our database template, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Saving and loading to a SQLite database is a little different than using a
    PLIST file. The main way to read and write to a SQLite database is through the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a `FMResultSet` object which can then be iterated through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to iterate through each `FMResultSet` object you create and also call
    `[rs close]` as well as SQLite will throw errors if you don't follow through each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying your SQLite database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this simple but powerful interface you can perform any type of query normally
    allowed on a SQLite database. In this recipe, we have one table with two values.
    Feel free to experiment with more complex data models.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Saving data using Core Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our third game is a memory card game where you must flip over sets of cards.
    Flip over two matching cards and you get a point. Flip over two that don't match
    and you get a strike. Three strikes and you're out. For this game we persist hi-score
    data using Apple's **Core Data** model pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data using Core Data](img/4002_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. For the sake of brevity all game logic has been omitted from the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up our Core Data based recipe requires a number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to add the CoreData framework. You can do this by right clicking
    on your project and going to **Add > Existing Frameworks** and then, under **iOS
    4.x SDK**, select `CoreData.framework`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder inside your resources entitled `Data Model`. Inside this
    folder, create a class entitled `Hiscore`, which derives from `ManagedObject:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After adding this class right click on your project and select **Add > New File**.
    Under **iOS** and under **Resource** select and create a new **Data Model**.![How
    to do it...](img/4002_03_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this data model `hiscore` and add your existing `Hiscore` class to this
    data model when you are prompted.![How to do it...](img/4002_03_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on `hiscores.xcdatamodel` in XCode. Click on the `Hiscore` entity and
    then add two new properties to it which correspond to the two properties in your
    `Hiscore` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/4002_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we''re ready to get down to some code. Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After some complex initialization, we are able to manipulate a simple array
    of `Hiscore` objects using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After modifying any of these objects we can save them all with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'New entries can be added using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A more complex use or explanation of Core Data is outside the scope of this
    book. This example serves merely as a working introduction to using Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting Core Data to work properly in XCode can sometimes be somewhat tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite database creation errors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the circumstances, Core Data may fail to create a SQLite database
    from the model you've created. To fix this problem make sure your xcdatamodel
    files and your NSManagedObject classes are located in the same folder on the disk
    as well as in the same XCode group. If this doesn't fix the problem delete these
    files from the project but not the disk then re-add them. If that doesn't work
    you can also create a SQLite database manually. This requires you to follow Core
    Data conventions. To help with this process, I've included the file memory_template.sqlite.
    This file has the correct Core Data database structure. The recipe will also use
    this file if it fails to create the SQLite database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Handling errors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a number of examples we specify error:nil. To actually handle any of these
    errors do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Core Data can often seem like overkill. However, applications with complex
    underlying data structures
  prefs: []
  type: TYPE_NORMAL
