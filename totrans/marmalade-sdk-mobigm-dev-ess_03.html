<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;User Input"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. User Input</h1></div></div></div><p>A video game<a id="id312" class="indexterm"/> is not going to be a whole lot of fun to play if the user has no way of controlling the events that happen, so in this chapter we will be looking at the various ways in which we can add interactivity to our programs by using Marmalade. By the end of this chapter you will know how to detect the following types of input:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Key presses</li><li class="listitem" style="list-style-type: disc">Touch screen and pointer inputs</li><li class="listitem" style="list-style-type: disc">Detection of gestures such as swipes and pinches</li><li class="listitem" style="list-style-type: disc">Changes in device orientation using accelerometers</li></ul></div><div class="section" title="Detecting key input"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Detecting key input</h1></div></div></div><p>We'll start our journey<a id="id313" class="indexterm"/> into the world of player input methods with the simplest method possible—pressing keys, which we detect by using the<a id="id314" class="indexterm"/> s3eKeyboard API. To use these functions in our code, we just need to include the<a id="id315" class="indexterm"/> <code class="literal">s3eKeyboard.h</code> file.</p><p>While the touch screen may now rule supreme as the primary method of interacting with many modern devices, it is still worthwhile to know how to detect key presses. Android devices, in particular, have keys that are intended to be used for quick access to menus and for navigation around a program. Quite often these are not even physical buttons, just an area at the bottom of the touch screen, but they are still reported as key presses.</p><p>Key press detection <a id="id316" class="indexterm"/>is also extremely useful when debugging your code in the Windows simulator, as Marmalade allows full access to your computer's keyboard too. This makes it really easy to add a debugging functionality triggered by a key press.</p><p>The s3eKeyboard API allows us to detect key input either by key state or by character input. It also provides functionality that allows us to determine what kind of keyboard support the device we are running on has available.</p><div class="section" title="Initialization and update of key information"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Initialization and update of key information</h2></div></div></div><p>There is a function called <code class="literal">s3eKeyboardGetInt</code> <a id="id317" class="indexterm"/>that allows us to find out what kind of keyboard our device has. We can use this information to provide<a id="id318" class="indexterm"/>
<a id="id319" class="indexterm"/> different input methods to our program should we want to. For example, entering a user's name on a high score might allow the user to enter their name directly if the device has a full alphabetic keyboard, but could fall back to a method using arrow keys to cycle through characters if the device does not feature a full keyboard.</p><p>The <code class="literal">s3eKeyboardGetInt</code> function call takes a single parameter from the<a id="id320" class="indexterm"/> <code class="literal">s3eKeyboardProperty</code> enumeration, and returns an integer value. Details of the available properties are provided in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEYBOARD_HAS_NUMPAD</code>
<a id="id321" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <code class="literal">1</code> if the device has a numeric keypad, otherwise returns <code class="literal">0</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEYBOARD_HAS_ALPHA</code>
<a id="id322" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <code class="literal">1</code> if the device has an alphabetic keypad, otherwise returns <code class="literal">0</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEYBOARD_HAS_DIRECTION</code>
<a id="id323" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <code class="literal">1</code> if the device has directional controls (up, down, left, right, and a <span class="strong"><strong>Select</strong></span> or <span class="strong"><strong>OK</strong></span> button), otherwise returns <code class="literal">0</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEYBOARD_NUMPAD_ORIENTATION</code>
<a id="id324" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>If the device has a numeric keypad, this property will return the orientation of the keypad relative to how the user is holding the device (if this is possible to detect).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEYBOARD_GET_CHAR</code>
<a id="id325" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <code class="literal">1</code> if the device supports the character code input method or <code class="literal">0</code> if it does not.</p>
</td></tr></tbody></table></div><p>The final value in this table can also be used with the function<a id="id326" class="indexterm"/> <code class="literal">s3eKeyboardSetInt</code> to show and hide the virtual keyboard on Android and iOS devices, which will then allow us to use the character code input method on these types of devices. The following function call will display the virtual keyboard:</p><div class="informalexample"><pre class="programlisting">s3eKeyboardSetInt(S3E_KEYBOARD_GET_CHAR, 1);</pre></div><p>To hide the virtual keyboard, pass in <code class="literal">0</code> instead of <code class="literal">1</code>.</p><p>Given that this feature is limited to just Android and iOS, and there is no way of determining whether the functionality is supported at runtime, this approach is probably best avoided if you intend to support a wide range of devices.</p><p>In order for our <a id="id327" class="indexterm"/>
<a id="id328" class="indexterm"/>program to keep receiving updates on key presses, we must call the function <code class="literal">s3eKeyboardUpdate</code> <a id="id329" class="indexterm"/>in our code, once per game frame. The s3eKeyboard API keeps its own internal cache of the current key press states, which is updated when calling this function; so if we don't call <code class="literal">s3eKeyboardUpdate</code> frequently, we risk missing key press events.</p></div><div class="section" title="Detecting key state"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Detecting key state</h2></div></div></div><p>The most useful <a id="id330" class="indexterm"/>method of key detection for most arcade style games is to be able to discover the up or down state of any key on the device. The s3eKeyboard API provides two ways in which we can do this, these being polling the current key state and by registering a callback function.</p><div class="section" title="Detecting key state changes using polling"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec26"/>Detecting key state changes using polling</h3></div></div></div><p>We'll start with the<a id="id331" class="indexterm"/>
<a id="id332" class="indexterm"/> simplest approach of polling for the current state of a key. It may be the simplest approach, but in most cases it is also the best approach as far as game coding is concerned, since often all we want to know is whether a key is currently pressed or released so that we can update our game state accordingly.</p><p>To detect the current state of any key on our device we make a call to <code class="literal">s3eKeyboardGetState</code>, which takes a value from the <code class="literal">s3eKey</code> enumeration (take a look at the <code class="literal">s3eKeyboard.h</code> file for a full list, but you can normally guess the name of the enumeration fairly easily—for example, <code class="literal">s3eKeyUp</code> is the up arrow key, <code class="literal">s3eKey4</code> is the number <span class="emphasis"><em>4</em></span> key, and so on) to identify the key we are interested in. The function returns an integer value that is a bit mask representing the current state of that key. The following key states can be detected by performing a bitwise AND operation on the return value:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Bit mask name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEY_STATE_DOWN</code>
<a id="id333" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The key is currently being held down.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEY_STATE_PRESSED</code>
<a id="id334" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The key went from being up to down in the last call to <code class="literal">s3eKeyboardUpdate</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_KEY_STATE_RELEASED</code>
<a id="id335" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The key went from being down to up in the last call to <code class="literal">s3eKeyboardUpdate</code>.</p>
</td></tr></tbody></table></div><p>If the value returned from the function is zero, then the key can be assumed to currently be in the up position (that is, not being held) and has not just been released either. </p><p>The following code <a id="id336" class="indexterm"/>
<a id="id337" class="indexterm"/>snippet shows how we would detect whether the number <span class="emphasis"><em>3</em></span> key has just been pressed:</p><div class="informalexample"><pre class="programlisting">if ((s3eKeyboardGetState(s3eKey3) &amp; S3E_KEY_STATE_PRESSED) != 0)
{
  // Number 3 key has just been pressed!
}</pre></div></div><div class="section" title="Detecting key state changes using callbacks"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec27"/>Detecting key state changes using callbacks</h3></div></div></div><p>It is also possible <a id="id338" class="indexterm"/>to be informed whenever a key is pressed or released by using a callback function. Callbacks are preferred by many coders since they force us into writing smaller, more manageable functions that often yield a more concise and reusable solution. The polled approach to key detection may seem easier at first glance but it is easy to end up with a codebase that has key state checking logic spread across many source files. Using the callback approach will tend to ensure key handling code is implemented in a more structured way.</p><p>To set up a callback <a id="id339" class="indexterm"/>function that detects key state changes, we use the<a id="id340" class="indexterm"/> <code class="literal">s3eKeyboardRegister</code> function. We provide this function with the enumeration value <code class="literal">S3E_KEYBOARD_KEY_EVENT</code> <a id="id341" class="indexterm"/>to identify the type of callback we are setting up, a pointer to a function that will be the callback, and a void pointer that can be used to pass in our own custom data to the callback function.</p><p>When a key is pressed or released, the function we specified will be called. The callback function is passed a pointer to an <code class="literal">s3eKeyboardEvent</code> structure, which details the key press or release and is also provided with the custom data pointer we specified when registering the callback.</p><p>When we no longer wish to receive key state notifications, we can call <code class="literal">s3eKeyboardUnRegister</code> to disable the callback mechanism. We just need to pass the <code class="literal">S3E_KEYBOARD_KEY_EVENT</code> enumeration and the pointer to our callback method to stop the callbacks from occurring any more.</p><p>Here's a code snippet to illustrate how we might detect state changes to the number <span class="emphasis"><em>3</em></span> key:</p><div class="informalexample"><pre class="programlisting">// Callback function that will receive key state notifications
int32 KeyStateCallback(s3eKeyboardEvent* apKeyEvent,
                       void* apUserData)
{
  if (apKeyEvent-&gt;m_Key == s3eKey3)
  {
    if (apKeyEvent-&gt;m_Pressed)
    {
      // Number 3 key has just been pressed
    }
    else
    {
      // Number 3 key has just been released
    }
  }
}

// We use this to register the callback function…
s3eKeyboardRegister(S3E_KEYBOARD_KEY_EVENT,
                    (s3eCallback) KeyStateCallback, NULL);

// …and this to cancel notifications
s3eKeyboardUnRegister(S3E_KEYBOARD_KEY_EVENT,
                      (s3eCallback) KeyStateCallback);</pre></div><p>The method <a id="id342" class="indexterm"/>of key press detection to be used is really down to project requirements and personal preference. Since a call to <code class="literal">s3eKeyboardUpdate</code> will cache the state of every key for us, a polled approach may be best if we need to<a id="id343" class="indexterm"/> detect the current state of several keys at any time. A callback approach may be better if we just want to respond immediately to a key press and are less interested in tracking the key's state beyond this.</p></div></div><div class="section" title="Detecting character code input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Detecting character code input</h2></div></div></div><p>The s3eKeyboard API <a id="id344" class="indexterm"/>also provides support for reading character codes from the keyboard. With this approach, we don't receive any notification of when a key was pressed or released. Instead, we receive a stream of character codes which automatically take into account any special modifier keys; so if a user pressed the <span class="emphasis"><em>Shift</em></span> key, followed by the <span class="emphasis"><em>A</em></span> key, then released both these keys, we would only receive the character code for a capital letter A.</p><p>This approach is probably less useful for most games due to it not being an immediate form of notification, especially since fewer and fewer devices now feature physical keys that can be pressed.</p><p>Not all devices support this input method, so you should use a call to <code class="literal">s3eKeyboardGetInt(S3E_KEYBOARD_GET_CHAR)</code> <a id="id345" class="indexterm"/>to determine if it can be used.</p><p>For the sake of completeness though, let us look at how we can receive character codes using either polling or callbacks.</p><div class="section" title="Detecting character code input using polling"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec28"/>Detecting character code input using polling</h3></div></div></div><p>To find out if a key <a id="id346" class="indexterm"/>that generates a character code has been pressed, all we have to do is call the following function:</p><div class="informalexample"><pre class="programlisting">s3eWChar lCharCode = s3eKeyboardGetChar();</pre></div><p>The <code class="literal">s3eWChar</code> type is just an alternate type definition for the standard C++ type <code class="literal">wchar_t</code>, a wide <a id="id347" class="indexterm"/>character. While this type can vary in size, it is assumed to be a 16-bit value in Marmalade. When a key is pressed, its character code will be added to the back of a queue. Calling this function will return the character to the front of the queue, or <code class="literal">S3E_WEOF</code> if the queue is empty. We often call this function in a loop in order to try and keep the queue empty and not risk losing key presses.</p><p>The character codes returned will depend on the device you are running on, but in most cases the standard alphabet A through Z, numbers, and punctuation characters will be ASCII codes, just stored in a 16-bit value.</p></div><div class="section" title="Detecting character code input using callbacks"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec29"/>Detecting character code input using callbacks</h3></div></div></div><p>Using the callback method of <a id="id348" class="indexterm"/>receiving <a id="id349" class="indexterm"/>character codes takes the same approach as the callback method for receiving key state changes.</p><p>We again use <code class="literal">s3eKeyboardRegister</code> and <code class="literal">s3eKeyboardUnRegister</code> to start and stop notifications from occurring, but we use the enumeration value <code class="literal">S3E_KEYBOARD_CHAR_EVENT</code> to indicate that it is a character code event we want to receive.</p><p>The callback function we provide will now be sent a pointer to an <code class="literal">s3eKeyboardCharEvent</code> structure that contains a single member of type <code class="literal">s3eWChar</code> named <code class="literal">m_Char</code>. This member will contain the character code that was generated by the user.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Character code input<a id="id350" class="indexterm"/> is really only recommended if you are running on a device with a physical keyboard, as using virtual keyboards on touch screen devices can be unreliable with many key presses going unnoticed, particularly when characters outside the normal ASCII character set are entered (for example, Chinese or Japanese text entry).</p></div></div></div></div><div class="section" title="Inputting strings"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Inputting strings</h2></div></div></div><p>We've already seen how we can use the s3eKeyboard functionality to read character codes, but if we want to allow the user to enter a string and we don't mind our program forsaking its own user interface in favor of a standard modal string entry dialog, then we have a shortcut available to us.</p><p>The <code class="literal">s3eOSReadString</code> API<a id="id351" class="indexterm"/> makes string entry really simple; but it is not actually supported on every platform. To use this API we include the file <code class="literal">s3eOSReadString.h</code>, and then make a call to the function <code class="literal">s3eOSReadStringAvailable</code> to see if string entry functionality is available for use.</p><p>If we are able to use the API, then<a id="id352" class="indexterm"/>
<a id="id353" class="indexterm"/> we have two functions at our disposal. The first is <code class="literal">s3eOSReadStringUTF8</code>, which will display a string entry dialog and return a UTF-8 encoded string as a <code class="literal">const char</code> pointer. The second method is <code class="literal">s3eOSReadStringUTF8WithDefault</code>, which allows us to also specify a UTF-8 string that will be used to populate the string dialog when it appears.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>UTF-8<a id="id354" class="indexterm"/> is a widely used character format that allows full multilingual character support. It is often used when memory concerns are foremost, as single-byte characters such as the standard ASCII character set can still be represented in a single byte. Characters from outside the ASCII set (for example, Japanese Kanji) are encoded with two, three, or more bytes of information. One big advantage of UTF-8 <a id="id355" class="indexterm"/>is that you can continue to use null-terminated strings since it is guaranteed that a zero byte will never form part of a valid character code.</p></div></div><p>Both functions otherwise work in the same way. They both return a pointer to the string entered by the user (the API will take care of freeing this memory), or NULL if the user canceled the dialog.</p><p>They both also take an optional last parameter that can customize the layout of the string entry dialog. If the parameter is omitted or the value zero is passed, no restrictions are applied. The following table shows the other values that can be used:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_OSREADSTRING_FLAG_EMAIL</code>
<a id="id356" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that we are expecting an e-mail address to be entered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_OSREADSTRING_FLAG_NUMBER</code>
<a id="id357" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that we are expecting a numeric value to be entered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_OSREADSTRING_FLAG_PASSWORD</code>
<a id="id358" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that the application will use the OS method for entering a password, possibly hiding characters as they are entered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_OSREADSTRING_FLAG_URL</code>
<a id="id359" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that we are expecting a URL to be entered.</p>
</td></tr></tbody></table></div><p>When using these <a id="id360" class="indexterm"/>
<a id="id361" class="indexterm"/>functions in an application, it is possible that the user may enter characters that we are then unable to process or display; this should be kept in mind, as generic string input may not always be a good choice (for example, you may be unable to display every possible character that can be entered using your game's font!).</p><p>Using this API will also likely break the look and feel of the game as its super whizzy UI is suddenly overlaid or replaced by a drab and boring system dialog.</p><p>These reasons, combined with the fact that it is not supported by all platforms, may mean that it is a better decision to implement our own in-game string entry routines. That being said, it is still a useful API to know about, if only for debugging purposes.</p></div></div></div>
<div class="section" title="Detecting touch screen and pointer input"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Detecting touch screen and pointer input</h1></div></div></div><p>There aren't many devices released these days that don't feature a touch screen<a id="id362" class="indexterm"/>. Most new devices have adopted this as the primary input method and have dropped physical buttons almost entirely.</p><p>In Marmalade we detect touch screen events using the <a id="id363" class="indexterm"/>
<span class="strong"><strong>s3ePointer</strong></span> API, which I have to admit is perhaps not the most obvious name for an API that handles touch screen input. To use this API in our own program we just need to include the <code class="literal">s3ePointer.h</code> file.</p><p>The reason for this<a id="id364" class="indexterm"/>
<a id="id365" class="indexterm"/> slightly bizarre naming is that when this API was first developed, touch screens were not commonplace. Instead, some devices had little joystick-style nubs that were able to move a pointer around the screen, much like a mouse on a computer.</p><p>Due to the fact that touch screen input is primarily concerned with a screen coordinate and that it was unlikely that a device would arrive that had both touch screen and pointer inputs, the Marmalade SDK simply adapted the existing s3ePointer API to accommodate touch screens as well, since your finger or stylus is effectively a pointer anyway.</p><p>For the purpose of this chapter, whenever we talk about a position being "pointed at", we mean either an on-screen cursor has been moved to that position or a touch screen has had a contact made at that position. Positions are always returned as pixel positions relative to the top-left corner of the screen, as shown in the following diagram that shows what to expect on a device with a portrait HVGA screen size, such as a<a id="id366" class="indexterm"/> non-retina display iPhone:</p><div class="mediaobject"><img src="graphics/3363_03_01.jpg" alt="Detecting touch screen and pointer input"/></div><p>In the following <a id="id367" class="indexterm"/>
<a id="id368" class="indexterm"/>sections, we will learn how to discover the capabilities available for use on the device we are running on and how to handle both single and multi-touch screens.</p><div class="section" title="Determining available pointer functionality"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Determining available pointer functionality</h2></div></div></div><p>We use the function <code class="literal">s3ePointerGetInt</code> <a id="id369" class="indexterm"/>to determine the properties of the <a id="id370" class="indexterm"/>hardware we are running on. We pass in one of the values in the following table, and we can then use the result to tailor our input methodology accordingly.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_AVAILABLE</code>
<a id="id371" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns <code class="literal">1</code> if we can use the s3ePointer API on the device, or <code class="literal">0</code> if we can't.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_HIDE_CURSOR</code>
<a id="id372" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>If the system has some kind of mouse pointer-like cursor displayed on screen, this property will return 1 if the pointer is currently visible, otherwise it returns <code class="literal">0</code>. This property can also be used in the <code class="literal">s3ePointerSetInt</code> function to show and hide the cursor.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_TYPE</code>
<a id="id373" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This will return the type of pointer we have at our disposal. See the next sub-section for more information on this.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_STYLUS_TYPE</code>
<a id="id374" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This will return the type of stylus our device uses. See the next sub-section for more information on this.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_MULTI_TOUCH_AVAILABLE</code>
<a id="id375" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>If the device supports multi-touch (being able to detect more than one press on the touch screen at a time) the value <code class="literal">1</code> will be returned. Single touch devices will return <code class="literal">0</code>.</p>
</td></tr></tbody></table></div><p>For most game code, it is usually enough to first use the<a id="id376" class="indexterm"/> <code class="literal">S3E_POINTER_AVAILABLE</code> property to see if we have pointer capability available and the <code class="literal">S3E_POINTER_MULTI_TOUCH_AVAILABLE</code> property to configure our input <a id="id377" class="indexterm"/>methodology appropriately.</p><div class="section" title="Determining the type of pointer input"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec30"/>Determining the type of pointer input</h3></div></div></div><p>When supplying <a id="id378" class="indexterm"/>
<a id="id379" class="indexterm"/>the property type <code class="literal">S3E_POINTER_TYPE</code> to <code class="literal">s3ePointerGetInt</code>, the return value is one from the <code class="literal">s3ePointerType</code> enumeration.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Return Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_TYPE_INVALID</code>
<a id="id380" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Invalid request. The most likely cause is that the s3ePointer API is not available on this device.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_TYPE_MOUSE</code>
<a id="id381" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Pointer input is coming from a device that features an on-screen cursor to indicate position. The cursor may be controlled by a mouse or some other input device, such as a joystick.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_TYPE_STYLUS</code>
<a id="id382" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Pointer input is from a stylus-based input method, most likely a touch screen of some sort.</p>
</td></tr></tbody></table></div><p>In the majority of cases this distinction is not normally that important, but it might be relevant if you need to track the movement of the pointer.</p><p>With a mouse, our code will receive events whenever the pointer is moved across the screen, whether a mouse button is held or not. On a touch screen, we will obviously only receive movement <a id="id383" class="indexterm"/>
<a id="id384" class="indexterm"/>events when the screen is being touched.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>This is most notable when running on the simulator, as we will receive pointer events whenever the mouse pointer is moved within the bounds of the simulator window.</p></div></div></div><div class="section" title="Determining the type of stylus input"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec31"/>Determining the type of stylus input</h3></div></div></div><p>If we <a id="id385" class="indexterm"/>
<a id="id386" class="indexterm"/>use <code class="literal">s3ePointerGetInt</code> with the property <code class="literal">S3E_POINTER_TYPE</code> and get the return type <code class="literal">S3E_POINTER_TYPE_STYLUS</code>, we can interrogate a little further to find out what type of stylus we will be using by calling <code class="literal">s3ePointerGetInt</code> again with the property <code class="literal">S3E_POINTER_STYLUS_TYPE</code>. The return values possible are in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Return Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_STYLUS_TYPE_INVALID</code>
<a id="id387" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Call was invalid; most likely because we are not running on a hardware that uses a stylus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_STYLUS_TYPE_STYLUS</code>
<a id="id388" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Inputs are made by touching a stylus to the input surface.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_STYLUS_TYPE_FINGER</code>
<a id="id389" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Inputs are made by touching a finger to the input surface.</p>
</td></tr></tbody></table></div><p>This is probably not a distinction that we will need to worry about in most cases, but it might be useful to know so that games can be made more forgiving about inputs when they are made with a finger, since a stylus has a much smaller contact surface and should therefore allow for a far more accurate input.</p></div></div><div class="section" title="Updating current pointer input status"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Updating current pointer input status</h2></div></div></div><p>In order to keep the<a id="id390" class="indexterm"/> s3ePointer API up-to-date with current touch screen inputs, it is necessary to call the <code class="literal">s3ePointerUpdate</code> function<a id="id391" class="indexterm"/> once per frame. This will update the cache of the current pointer status that is maintained within the s3ePointer API.</p></div><div class="section" title="Detecting single touch input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Detecting single touch input</h2></div></div></div><p>If the s3ePointer <a id="id392" class="indexterm"/>API is available on our device, we are guaranteed to be able to detect and respond to the user touching the screen and moving their stylus or finger about, or moving an on-screen cursor around and pressing some kind of selection button.</p><p>Even if our hardware supports multi-touch, we can still make use of single touch input if our game has no need to know about multiple simultaneous touch points. This may make it a little simpler to code our game, as we don't need to worry about issues such as two buttons on our user interface being pressed at the same time.</p><p>As with key input, we can choose to use either a polled or callback-based approach.</p><div class="section" title="Detecting single touch input using polling"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec32"/>Detecting single touch input using polling</h3></div></div></div><p>We can determine the <a id="id393" class="indexterm"/>
<a id="id394" class="indexterm"/>current on-screen position being pointed at (either by the on-screen cursor or a touch on the screen) by using the <code class="literal">s3ePointerGetX</code> and <code class="literal">s3ePointerGetY</code> functions, which will return the current horizontal and vertical pixel positions being pointed at.</p><p>In the case of a touch screen, the current position returned by these functions will be the last known position pointed at if the user is not currently making an input. The default value before any touches have been made will be (0,0)—the top-left corner of the screen.</p><p>To determine whether an input is currently in progress, we can use the function <code class="literal">s3ePointerGetState</code>, which takes an element from the <code class="literal">s3ePointerButton</code> enumeration and returns a value from the <code class="literal">s3ePointerState</code> enumeration. The following table shows the values that make up the <code class="literal">s3ePointerButton</code> enumeration:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_BUTTON_SELECT</code>
<a id="id395" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the status of either the left mouse button or a touch screen tap.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_BUTTON_LEFTMOUSE</code>
<a id="id396" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>An alternative name for <code class="literal">S3E_POINTER_BUTTON_SELECT</code>, which you may prefer to use if detecting other mouse buttons as well.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_BUTTON_RIGHTMOUSE</code>
<a id="id397" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the status of the right mouse button.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_BUTTON_MIDDLEMOUSE</code>
<a id="id398" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the status of the middle mouse button.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_BUTTON_MOUSEWHEELUP</code>
<a id="id399" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Used to determine if the user has scrolled the mouse wheel upwards.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_BUTTON_MOUSEWHEELDOWN</code>
<a id="id400" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Used to determine if the user has scrolled the mouse wheel downwards.</p>
</td></tr></tbody></table></div><p>The next table <a id="id401" class="indexterm"/>
<a id="id402" class="indexterm"/>shows the members of the <code class="literal">s3ePointerState</code> enumeration, which indicate the current status of the requested pointer button or touch screen tap:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_STATE_UP</code>
<a id="id403" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The button is not depressed or contact is not currently made with the touch screen.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_STATE_DOWN</code>
<a id="id404" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The button is being held down or contact has been made with the touch screen.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_STATE_PRESSED</code>
<a id="id405" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The button or touch screen has just been pressed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_STATE_RELEASED</code>
<a id="id406" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The button or touch screen has just been released.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">S3E_POINTER_STATE_UNKNOWN</code>
<a id="id407" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Current status of this button is not known. For example, the middle mouse button status was requested but there is no middle mouse button present on the hardware.</p>
</td></tr></tbody></table></div><p>With this information we now have the ability to track the pointer or touch screen position and determine when the user has touched or released the touch screen or pressed a mouse <a id="id408" class="indexterm"/>
<a id="id409" class="indexterm"/>button.</p></div><div class="section" title="Detecting single touch input using callbacks"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec33"/>Detecting single touch input using callbacks</h3></div></div></div><p>It is also possible to<a id="id410" class="indexterm"/>
<a id="id411" class="indexterm"/> keep track of pointer events using a callback-based system. For single touch input, there are two event types that we can register callback functions for; these are button and motion events.</p><p>We can start receiving pointer events by calling the<a id="id412" class="indexterm"/> <code class="literal">s3ePointerRegister</code> function, and we can stop them by calling <code class="literal">s3ePointerUnRegister</code>. Both functions take a value to identify the type of event we are concerned with, and a pointer to a callback function.</p><p>When registering a callback function, we can also provide a pointer to our own custom data structure that will be passed into the callback function whenever an event occurs.</p><p>The following code snippet shows how we can register a callback function that will be executed whenever the touch screen or a mouse button is pressed or released:</p><div class="informalexample"><pre class="programlisting">// Callback function that will receive pointer button notifications
int32 ButtonEventCallback(s3ePointerEvent* apButtonEvent,
                          void* apUserData)
{
  if (apButtonEvent-&gt;m_Button == S3E_POINTER_BUTTON_SELECT)
  {
    if (apButtonEvent-&gt;m_Pressed)
    {
      // Left mouse button or touch screen pressed
    }
    else
    {
      // Left mouse button or touch screen released
    }
  }
  return 0;
}

// We use this to register the callback function…
s3ePointerRegister(S3E_POINTER_BUTTON_EVENT,
                   (s3eCallback) ButtonEventCallback, NULL);

// …and this to cancel notifications
s3ePointerUnRegister(S3E_POINTER_BUTTON_EVENT,
                     (s3eCallback) ButtonEventCallback);</pre></div><p>The button event callback's first parameter is a pointer to an <code class="literal">s3ePointerEvent</code> structure that contains four members. The button that was pressed is stored in a member called <code class="literal">m_Button</code> that is of the type <code class="literal">s3ePointerButton</code> (see the table in the <span class="emphasis"><em>Detecting single touch input using polling</em></span> section earlier in this chapter for more details on this enumerated type).</p><p>The <code class="literal">m_Pressed</code> member will be <code class="literal">0</code> if the button was released and <code class="literal">1</code> if it was pressed. You might expect this to be of type <code class="literal">bool</code> rather than an integer but it isn't, because this is a C-based API, not C++-based and <code class="literal">bool</code> is not a part of the standard C language.</p><p>We can also discover the screen position where the event occurred by using the structure's <code class="literal">m_x</code> and <code class="literal">m_y</code> members.</p><p>It is also possible to register a callback that will inform us when the user has performed a pointer motion. We again use the <code class="literal">s3ePointerRegister</code>/<code class="literal">s3ePointerUnRegister</code> functions, but this time use <code class="literal">S3E_POINTER_MOTION_EVENT</code> as the callback type.</p><p>The callback <a id="id413" class="indexterm"/>
<a id="id414" class="indexterm"/>function we register will be passed a pointer to an <code class="literal">s3ePointerMotionEvent</code> structure that consists of just <code class="literal">m_x</code> and <code class="literal">m_y</code> members containing the screen coordinate that is now being pointed at.</p></div></div><div class="section" title="Detecting multi-touch input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Detecting multi-touch input</h2></div></div></div><p>A multi-touch <a id="id415" class="indexterm"/>capable display allows us to detect more than one touched point on the screen at a time. Every time the screen is touched, the device's OS will assign that touch point an ID number. As the user moves their finger around the screen, the coordinates associated with that ID number will be updated until the user removes their finger from the screen, whereupon that touch will become inactive and the ID number becomes invalid.</p><p>While Marmalade does provide a polling-based approach to handling multi-touch events, the callback approach is possibly the better choice as it leads to slightly more elegant code and is a little more efficient.</p><div class="section" title="Detecting multi-touch input using polling"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec34"/>Detecting multi-touch input using polling</h3></div></div></div><p>Marmalade provides us <a id="id416" class="indexterm"/>
<a id="id417" class="indexterm"/>with a set of functions to allow multi-touch detection. The functions<a id="id418" class="indexterm"/> <code class="literal">s3ePointerGetTouchState</code>,<a id="id419" class="indexterm"/> <code class="literal">s3ePointerGetTouchX</code>, and <code class="literal">s3ePointerGetTouchY</code> <a id="id420" class="indexterm"/>are equivalent to the single touch functions<a id="id421" class="indexterm"/> <code class="literal">s3ePointerGetState</code>,<a id="id422" class="indexterm"/> <code class="literal">s3ePointerGetX</code>, and<a id="id423" class="indexterm"/> <code class="literal">s3ePointerGetY</code>, except that the multi-touch versions take a single parameter—the touch ID number.</p><p>The s3ePointer API also declares a preprocessor define <code class="literal">S3E_POINTER_TOUCH_MAX</code> that indicates the maximum possible value for the touch ID number (plus one!). As the user touches and releases the display, the touch ID numbers will be re-used. It is important to bear this in mind.</p><p>The following code <a id="id424" class="indexterm"/>
<a id="id425" class="indexterm"/>snippet shows a loop that will allow us to process the currently active touch points:</p><div class="informalexample"><pre class="programlisting">for (uint32 i = 0; i &lt; S3E_POINTER_TOUCH_MAX; i++)
{
  // Find position of this touch id.  Position is only valid if the
  // state for the touch ID is not S3E_POINTER_STATE_UNKNOWN or
  // S3E_POINTER_STATE_UP
  int32 x = s3ePointerGetTouchX(i);
  int32 y = s3ePointerGetTouchY(i);

  switch(s3ePointerGetTouchState(i))
  {
    case S3E_POINTER_STATE_RELEASED:
     // User just released the screen at x,y
     break;
    case S3E_POINTER_STATE_DOWN:
     // User just pressed or moved their finger to x,y
     // We need to know if we've already been tracking this
     // touch ID to tell whether this is a new press or a move
     break;
    default:
     // This touch ID is not currently active
     break;
  }
}</pre></div><p>The biggest issue with this approach is that Marmalade never sends us an explicit notification that a touch event has just occurred. The <code class="literal">s3ePointerGetTouchState</code> function<a id="id426" class="indexterm"/> never returns <code class="literal">S3E_POINTER_STATE_PRESSED</code>, so instead we need to keep track of all touch IDs we have seen active so far when handling <code class="literal">S3E_POINTER_STATE_DOWN</code>. If a new touch ID is seen, we have detected the just-pressed condition.</p><p>While this code will work, I hope you will find that the callback-based approach that we are about to consider leads to a slightly more elegant solution.</p></div><div class="section" title="Multi-touch input using callbacks"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec35"/>Multi-touch input using callbacks</h3></div></div></div><p>As with the polling <a id="id427" class="indexterm"/>
<a id="id428" class="indexterm"/>approach, multi-touch detection using callbacks is almost exactly the same as the single touch callback method. We still use <code class="literal">s3ePointerRegister</code> and <code class="literal">s3ePointerUnRegister</code> to start and stop events being sent to our code, but instead we use <code class="literal">S3E_POINTER_TOUCH_EVENT</code> to receive notifications of the user pressing or releasing the screen, and <code class="literal">S3E_POINTER_TOUCH_MOTION_EVENT</code> to find out when the user has dragged their finger across the screen.</p><p>The callback function registered to <code class="literal">S3E_POINTER_TOUCH_EVENT</code> will be sent a pointer to an <code class="literal">s3ePointerTouchEvent</code> structure. This structure contains the screen coordinates where the event occurred (the <code class="literal">m_x</code> and <code class="literal">m_y</code> members), whether the screen was touched or released (the <code class="literal">m_Pressed</code> member, which will be set to <code class="literal">1</code> if the screen was touched), and most importantly the ID number for this touch event (the <code class="literal">m_TouchID</code> member), which we can use to keep track of this touch as the user moves their finger around the display.</p><p>The <code class="literal">S3E_POINTER_TOUCH_MOTION_EVENT</code> callback will receive a pointer to an <code class="literal">s3ePointerTouchMotionEvent</code> structure. This structure contains the ID number of the touch event that has been updated and the new screen coordinate values. These structure members have the same names as their equivalent members in the <code class="literal">s3ePointerTouchEvent</code> structure.</p><p>Marmalade provides us with no way of adjusting the frequency of touch events. Instead, it is really just dependant on how often the underlying operating system code dispatches such events.</p><p>Hopefully you can see that the callback-based method is a little neater than the polled method. Firstly, we can say goodbye to the truly nasty loop needed in the polled method to detect all currently active touches.</p><p>Secondly, with careful coding we can use the same code path to handle both single and multi-touch input. If we code first for multi-touch input, then making single touch work is simply a case of adding a fake touch ID to incoming single touch events and passing them through to the multi-touch code.</p></div></div><div class="section" title="Recognizing gesture inputs"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Recognizing gesture inputs</h2></div></div></div><p>The arrival of the<a id="id429" class="indexterm"/> touch screen to mobile devices brought with it a new set of terminology related to making inputs to our programs. For years we have been using a mouse, clicking and dragging to interact with programs, and now with touch screens we have quickly become comfortable with the idea of swiping and pinching.</p><p>These methods of interaction have become known as <span class="strong"><strong>gestures</strong></span>
<a id="id430" class="indexterm"/> and users have become so used to them now that if your application doesn't respond as they expect, they may get quickly frustrated with your application.</p><p>Unfortunately, Marmalade <a id="id431" class="indexterm"/>does not provide any support for detecting these gestures, so instead we have to code for them ourselves. The following sections aim to provide some guidance on how to easily detect both swipes and pinches.</p><div class="section" title="Detecting a swipe gesture"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec36"/>Detecting a swipe gesture</h3></div></div></div><p>A swipe<a id="id432" class="indexterm"/> occurs when the user touches the screen and then slides that touch point quickly across the screen before releasing the screen.</p><p>To detect a <a id="id433" class="indexterm"/>swipe we must therefore first keep track of the screen coordinates where the user touched the screen and the time at which this occurred. When this touch event comes to an end due to the user releasing the screen, we first check the time it lasted for. If the length of time is not too long (say less than a quarter of a second), we check the distance between the start and end points. If this distance is large enough (perhaps a hundred pixels in length, or a fraction of the screen display size), then we have detected a swipe.</p><p>Often we <a id="id434" class="indexterm"/>only want to respond to a swipe if it is in a certain direction. We can determine this by using the dot product, the formula for which is shown in the following diagram:</p><div class="mediaobject"><img src="graphics/3363_03_02.jpg" alt="Detecting a swipe gesture"/></div><p>The dot product is calculated by multiplying the x and y components of the two vectors together and summing the results, or by multiplying the length of the two vectors together and then multiplying by the cosine of the angle between the two vectors.</p><p>To check if the user's swipe lies in a particular direction, we first make the direction of the swipe into a unit vector, then dot product this with a unit vector in the desired swipe direction. By using unit vectors we reduce the formula on the left-hand side of the previous diagram to just the cosine of the angle between the vectors, so it is now very simple to see if our swipe lies along the desired direction.</p><p>If the dot product <a id="id435" class="indexterm"/>value is very close to 1, then our two direction vectors are close to being parallel, since <span class="emphasis"><em>cos(0°) = 1</em></span>, and we've detected a swipe in the required direction. Similarly, if the dot product is close to -1, we've detected a swipe in the opposite direction, as <span class="emphasis"><em>cos(180°) = -1</em></span>.</p></div><div class="section" title="Detecting a pinch gesture"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec37"/>Detecting a pinch gesture</h3></div></div></div><p>Pinch gestures <a id="id436" class="indexterm"/>can only be used on devices featuring multi-touch displays, since they require two simultaneous touch points. A pinch gesture is often used to allow zooming in and out to occur and is performed by placing two fingers on the screen and then moving them together or apart. This is most easily achieved using the thumb and index finger.</p><p>Detecting a pinch<a id="id437" class="indexterm"/> gesture in code is actually quite simple. As soon as we have detected two touch points on the screen, we calculate a vector from one point to the other and find the distance of this vector. This is stored as the initial distance and will represent no zooming.</p><p>As the user moves their fingers around the screen, we just keep calculating the new distance between the two touch points, and then divide this distance by the original distance. The end result of this calculation is a zoom scale factor. If the user moves their fingers together, the zoom factor will be less than one; if they move them apart, the zoom value will be greater than one.</p><p>The pinch gesture is complete once the user removes at least one finger from the display.</p></div></div></div>
<div class="section" title="Detecting accelerometer input"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Detecting accelerometer input</h1></div></div></div><p>The final input method we will be considering in this chapter is the <a id="id438" class="indexterm"/>
<span class="strong"><strong>accelerometer</strong></span>, which allows us to detect the orientation that the user is currently holding the device at. An accelerometer is a sensor that can measure the forces applied to a device, be they static forces such as gravity, or dynamic forces generated by waving the device around.</p><p>Most devices will have<a id="id439" class="indexterm"/> three accelerometers aligned perpendicularly to each other, as shown in the following diagram. This configuration allows us to discover exactly how the user is holding the device at any time and so provides a method of controlling our game.</p><div class="mediaobject"><img src="graphics/3363_03_03.jpg" alt="Detecting accelerometer input"/></div><p>The directions of the arrows in the previous diagram show the directions in which acceleration will yield a positive value. This means that if you hold the device level with the display upwards in front of you, tipping it to the right will yield a positive value on the x axis accelerometer, tipping it away from you will generate positive y axis values and moving the device vertically upwards will generate a positive z axis value.</p><p>The Marmalade SDK <a id="id440" class="indexterm"/>provides us with access to the accelerometers of a device using the s3eAccelerometer API, which we can use in our code by including the <code class="literal">s3eAccelerometer.h</code> file.</p><div class="section" title="Starting and stopping accelerometer input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Starting and stopping accelerometer input</h2></div></div></div><p>Before attempting to use <a id="id441" class="indexterm"/>the accelerometer in our program, we must first check to see if accelerometer input is available on our device. If support is available, then we can start receiving accelerometer input. We do this with the following check:</p><div class="informalexample"><pre class="programlisting">if (s3eAccelerometerGetInt(S3E_ACCELEROMETER_AVAILABLE) != 0)
{
  // Accelerometer is available!  Start receiving input.
  s3eAccelerometerStart();
}</pre></div><p>When we have <a id="id442" class="indexterm"/>finished using the accelerometers, we just make a call to <code class="literal">s3eAccelerometerStop</code> and we will receive no further inputs.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>It is good practice on mobile devices to ensure that we only enable parts of the hardware when we are actually using them, since this helps to conserve battery power. In the case of accelerometers, the power use is probably so small that it is insignificant, but this is an area of mobile game programming that is always worth keeping in mind.</p></div></div></div><div class="section" title="Reading accelerometer input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Reading accelerometer input</h2></div></div></div><p>Finding the<a id="id443" class="indexterm"/> current accelerometer input values is really very simple. Marmalade provides three functions which return the current accelerometer value for each axis. These functions are called<a id="id444" class="indexterm"/> <code class="literal">s3eAccelerometerGetX</code>,<a id="id445" class="indexterm"/> <code class="literal">s3eAccelerometerGetY</code>, and<a id="id446" class="indexterm"/> <code class="literal">s3eAccelerometerGetZ</code>. Unsurprisingly, they return the current value of the accelerometer for the specified axis.</p><p>The values returned by these functions use a value of 1000 (though we should use the handy definition <code class="literal">S3E_ACCELEROMETER_1G</code> to avoid magic numbers in our code!) to represent an acceleration equivalent to normal Earth gravity.</p><p>When a sharp, quick movement is made to the device, the forces being applied to it will be greater than the normal gravitational force. In this case, the magnitude of the vector formed from the accelerometer values will be greater than <code class="literal">S3E_ACCELEROMETER_1G</code>. This can be a useful way of detecting whether the user has been shaking the device.</p><p>If the device were to be horizontally on a table, we should get a value of <code class="literal">0</code> returned for both the X and Y axes, and <code class="literal">-1000</code> for the z axis, since gravity acts downwards! As we rotate the device, the values returned will form a vector showing the direction in which gravity is acting, and we can then use this to determine the orientation of the device.</p><p>Using some trigonometry, we can work out the angle of tip around the x axis (forward/backward) and Y-axis (left/right). The angle around the X-axis can be found by taking the arc tan of the Y-accelerometer value divided by the Z value.</p><p>The angle around the y axis is a little trickier. First we have to find the length of the accelerometer vector projected onto the YZ plane, then we can find the arc tan of the X-accelerometer value divided by the projected length.</p><p>If all this sounds like too much scary math, the following code snippet does it all for us. Note than when calculating the rotation around the x axis using the <code class="literal">IwGeomAtan2</code> function, we negate both the Y- and Z-accelerometer values in order to yield a more usable result range, with 0 degrees returned when the device is level and increasing values when tipped away from the user.</p><div class="informalexample"><pre class="programlisting">iwangle xAngle = IwGeomAtan2(-accY, -accZ);
int32 lYZProjection = (int32) sqrtf((float) ((accY * accY) +
                                             (accZ * accZ)));
iwangle yAngle = IwGeomAtan2(accX, lYZProjection);</pre></div></div><div class="section" title="Smoothing accelerometer input"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Smoothing accelerometer input</h2></div></div></div><p>One problem we will encounter when using the<a id="id447" class="indexterm"/> accelerometer for input is that the values returned from it tend to be a bit "jumpy". Even the steadiest hand will be unable to hold the device still enough to see a steady value being returned from the accelerometer. This can cause your game to register movements when you don't want it to.</p><p>A common approach for solving this problem is to smooth the accelerometer values by combining the current readings with the previous readings. The easiest way of doing this is shown in the following code:</p><div class="informalexample"><pre class="programlisting">int32 accX = 0, accY = 0, accZ = 0;
int32 lSmoothFactor = IW_GEOM_ONE / 4;
// The following loop shows how we generate the smoothed accelerometer
// inputs.  In a real application the code within the loop would be called once
// per game frame.
while (TRUE)
{
  int32 deltaX = s3eAccelerometerGetX() - accX;
  int32 deltaY = s3eAccelerometerGetY() - accY;
  int32 deltaZ = s3eAccelerometerGetZ() - accZ;
  accX += IW_FIXED_MUL(lSmoothFactor, deltaX);
  accY += IW_FIXED_MUL(lSmoothFactor, deltaY);
  accZ += IW_FIXED_MUL(lSmoothFactor, deltaZ);
}</pre></div><p>The variables <code class="literal">accX</code>, <code class="literal">accY</code>, and <code class="literal">accZ</code> are the smoothed accelerometer values that we will use in our program for input. The <code class="literal">lSmoothFactor</code> value determines how much smoothing we are applying to the inputs. If it is set to <code class="literal">IW_GEOM_ONE</code>, no smoothing will be applied and the results will be exactly what is coming in from the accelerometers.</p><p>Lower values for the smoothing factor will generate less jittery input values, but this will be at the expense of adding a certain amount of lag to the inputs. The degree of lag depends on how often the smoothing code is executed, which in turn depends on the frame rate of your game.</p><p>Working out a good value to use for the smoothing factor is really just a case of trial and error. You just need to keep tweaking the value until you achieve a suitable result.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>
<code class="literal">IW_FIXED_MUL</code> <a id="id448" class="indexterm"/>is a useful function provided by Marmalade for doing fixed point multiplication where <code class="literal">IW_GEOM_ONE</code> (4096) is equivalent to one. It multiplies the two parameters together and then shifts the result back down to be in the correct range.</p></div></div></div><div class="section" title="Testing accelerometer input on the Windows simulator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Testing accelerometer input on the Windows simulator</h2></div></div></div><p>Given that computers don't <a id="id449" class="indexterm"/>
<a id="id450" class="indexterm"/>tend to feature accelerometer inputs of any kind, testing this form of input in the Windows simulator may appear to be impossible. Fortunately, Marmalade does provide us with a way of doing so.</p><p>When running an application in the simulator, select the menu item <span class="strong"><strong>Configuration</strong></span> | <span class="strong"><strong>Accelerometer…</strong></span> and a window showing a small 3D representation of a mobile device will be displayed:</p><div class="mediaobject"><img src="graphics/3363_03_04.jpg" alt="Testing accelerometer input on the Windows simulator"/></div><p>By clicking and dragging on this virtual device, we can alter the accelerometer inputs being fed into the simulator. It's a little tricky to use for playing a game but it normally suffices, so you can at least test applications that rely solely on accelerometer inputs.</p><p>The window <a id="id451" class="indexterm"/>
<a id="id452" class="indexterm"/>also provides some edit boxes that show the current values of the accelerometer inputs as you rotate the 3D device about. These can also be used to enter exact values should you have need to do so.</p></div></div>
<div class="section" title="Example code"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Example code</h1></div></div></div><p>The code package for this chapter contains three projects that demonstrate the things we've learnt in this chapter.</p><div class="section" title="The Gesture project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>The Gesture project</h2></div></div></div><p>This <a id="id453" class="indexterm"/>project demonstrates the use of the s3ePointer API by showing the screen coordinates pointed at by the user. If a multi-touch display is available, it will show multiple touch points.</p><p>The project also demonstrates a simple approach for detecting swipes and pinches and how it is possible to use the same gesture detection code with both single- and multi-touch capable displays.</p></div><div class="section" title="The Slide project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>The Slide project</h2></div></div></div><p>The <a id="id454" class="indexterm"/>Slide project shows how to use the s3eAccelerometer API to read the current accelerometer values, apply a smoothing algorithm to them, and generate the angles of tip around the X- and Y-axes.</p><p>It also demonstrates something a little more game-like by allowing you to move a little red box around the screen by tipping the device.</p></div><div class="section" title="The Skiing project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>The Skiing project</h2></div></div></div><p>Our skiing game <a id="id455" class="indexterm"/>becomes interactive in this chapter, allowing you to rotate the skier left and right and have him move across the screen and affect the speed of scrolling. The skier can be controlled either by key presses and touch screen or accelerometer input.</p><p>We also have more of a game-like flow with the addition of a title screen mode that allows the input method to be selected, and a game over mode, which is triggered when the player goes into the trees at the edge of the game world.</p><p>The following sections highlight some of the new classes added to the project.</p><div class="section" title="Player rotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec38"/>Player rotation</h3></div></div></div><p>Rotation of the <a id="id456" class="indexterm"/>player has been achieved by including a number of different animation frames, each showing the player at a different angle of rotation. This makes it easy to slot into our existing <code class="literal">GameObject</code> code, which expects to draw a square image that is not rotated.</p><p>While this solution is very simple, it is perhaps not the best option. We could instead have extended <code class="literal">GameObject</code> to support rotated images, which would have both saved memory (we would not have needed to store all the extra animation frames) and yielded smoother rotation results, as the skier currently steps between frames at 10-degree rotation increments. </p></div><div class="section" title="The ModeTitle and ModeGameOver classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec39"/>The ModeTitle and ModeGameOver classes</h3></div></div></div><p>These <a id="id457" class="indexterm"/>classes<a id="id458" class="indexterm"/> implement the title screen and game over modes of the game. These have been added to make the project feel a little more like a game, although <a id="id459" class="indexterm"/>
<a id="id460" class="indexterm"/>they are very basic to look at.</p><p>More importantly, these classes show how we can switch between game modes by making them active and visible. Take particular note of the<a id="id461" class="indexterm"/> <code class="literal">ModeGameOver</code> class, which stops the normal game mode from updating, but still allows it to render so we can see the game world along with the game over message.</p></div><div class="section" title="The Camera class"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec40"/>The Camera class</h3></div></div></div><p>The <code class="literal">Camera</code> class<a id="id462" class="indexterm"/>
<a id="id463" class="indexterm"/> has been added to the project to allow us to specify a viewing point in the world. When rendering, we now use the camera position as the origin's location on the screen. So when we move the camera, the entire screen display will move relative to it. This makes it possible to do a horizontal scrolling effect without having to update the x coordinate of everything in the game world.</p><p>Another reason for making this change is to make our life easier when we upgrade the game to use 3D models in the next chapter, since this is closer to the way 3D graphics are rendered.</p></div><div class="section" title="The Input Manager classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec41"/>The Input Manager classes</h3></div></div></div><p>Three new singleton<a id="id464" class="indexterm"/>
<a id="id465" class="indexterm"/> classes have also been added to the project to make access to key, touch screen, and accelerometer inputs a little tidier. They are called<a id="id466" class="indexterm"/> <code class="literal">KeyManager</code>,<a id="id467" class="indexterm"/> <code class="literal">TouchManager</code>, and<a id="id468" class="indexterm"/> <code class="literal">AccelerometerManager</code> respectively.</p><p>These classes wrap the functionality provided by Marmalade into a simpler interface, which makes our game code easier to read. It also means that we can make changes to the inputs at a later date without having to change the game code. For example, the <code class="literal">KeyManager</code> class<a id="id469" class="indexterm"/> provides methods to indicate if the left or right arrow keys have been held. If we want to remap those keys or provide alternate possible keys, we can do so in the <code class="literal">KeyManager</code> code and our game code will work just fine.</p></div><div class="section" title="The SkierController class"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec42"/>The SkierController class</h3></div></div></div><p>In order to add a layer of abstraction between the <code class="literal">Skier</code> class and the various input managers, the <code class="literal">SkierController</code> class<a id="id470" class="indexterm"/> has been added. This class provides a "steering" value, which is an integer number ranging from—<code class="literal">IW_GEOM_ONE</code> to +<code class="literal">IW_GEOM_ONE</code> that indicates how much the user is attempting to steer left (a negative value) or <a id="id471" class="indexterm"/>right (a positive value). The <code class="literal">Skier</code> class<a id="id472" class="indexterm"/> can just use this value to rotate the skier without needing to consider how this value is derived.</p><p>Internally, the <code class="literal">SkierController</code> class generates the steering value using the selected input method from the title screen.</p><p>For keyboard input, the left and right arrow keys modify the current steering value a little bit each frame.</p><p>Touch screen input uses the horizontal position of the player's finger on the screen to generate the value; so it is -1 when the player is touching the left-hand side of the screen and +1 when they are touching the right-hand side.</p><p>Finally, accelerometer input just scales the x axis accelerometer value into the required range.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we've covered how to make our programs interactive by detecting key and touch screen presses and by using the accelerometers of modern mobile devices. We've also seen how we can build on the basic functionality provided in order to detect swipe and pinch gestures.</p><p>In the next chapter, we'll be returning to things more graphical by showing how we can use Marmalade to render 3D graphics in our games.</p></div></body></html>