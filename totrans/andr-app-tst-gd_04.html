<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Test Driven Development</h1></div></div></div><p>This chapter introduces the Test Driven Development discipline. We will start with a general revision and later on move to the concepts and techniques closely related to the Android platform.<a class="indexterm" id="id201"/>
</p><p>This is a code intensive chapter, so be prepared to type as you read, which would be the best way to seize the examples provided.</p><p>In this chapter, we:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduce and explain Test Driven Development</li><li class="listitem" style="list-style-type: disc">Analyze its advantages</li><li class="listitem" style="list-style-type: disc">Introduce a potential real life example</li><li class="listitem" style="list-style-type: disc">Understand requirements by writing the tests</li><li class="listitem" style="list-style-type: disc">Evolve through the project by applying TDD</li><li class="listitem" style="list-style-type: disc">Get the application that fully complies with the requirements</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Getting started with TDD</h1></div></div></div><p>Briefly, Test Driven Development is the strategy of writing tests along the development process. These test cases are written in advance of the code that is supposed to satisfy them.<a class="indexterm" id="id202"/>
</p><p>A single test is added, then the code needed to satisfy the compilation of this test and finally the full set of test cases is run to verify their results.</p><p>This contrasts with other approaches to the development process where the tests are written at the end when all the coding has been done.</p><p>Writing the tests in advance of the code that satisfies them has several advantages. First, is that the tests are written in one way or another, while if the tests are left till the end it is highly probable that they are never written. Second, developers take more responsibility for the quality of their work.</p><p>Design decisions are taken in single steps and finally the code satisfying the tests is improved by refactoring it.<a class="indexterm" id="id203"/>
</p><p>This UML activity diagram depicts the Test Driven Development to help us understand the process:<a class="indexterm" id="id204"/>
</p><div><img alt="Getting started with TDD" src="img/3500OS_04_01.jpg"/></div><p>The following sections explain the individual activities depicted in this activity diagram.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec01"/>Writing a test case</h2></div></div></div><p>We start our development process with writing a test case. This apparently simple process will put some machinery to work inside our heads. After all, it is not possible to write some code, test it or not, if we don't have a clear understanding of the problem domain and its details. Usually, this step will get you face to face with the aspects of the problem you don't understand, and you need to grasp if you want to model and write the code.<a class="indexterm" id="id205"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec02"/>Running all tests</h2></div></div></div><p>Once the test is written the obvious following step is to run it, altogether with other tests we have written so far. Here, the importance of an IDE with built-in support of the testing environment is perhaps more evident than in other situations and this could cut the development time by a good fraction. It is expected that firstly, our test fails as we still haven't written any code!<a class="indexterm" id="id206"/>
</p><p>To be able to complete our test, we usually write additional code and take design decisions. The additional code written is the minimum possible to get our test to compile. Consider here that not compiling is failing.</p><p>When we get the test to compile and run, if the test fails then we try to write the minimum amount of code necessary to make the test succeed. This may sound awkward at this point but the following code example in this chapter will help you understand the process.</p><p>Optionally, instead of running all tests again you can just run the newly added test first to save some time as sometimes running the tests on the emulator could be rather slow. Then run the whole test suite to verify that everything is still working properly. We don't want to add a new feature by breaking an existing one.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec03"/>Refactoring the code</h2></div></div></div><p>When the test succeeds, we refactor the code added to keep it tidy, clean, and minimal.<a class="indexterm" id="id207"/>
</p><p>We run all the tests again, to verify that our refactoring has not broken anything and if the tests are again satisfied, and no more refactoring is needed we finish our task.</p><p>Running the tests after refactoring is an incredible safety net which has been put in place by this methodology. If we made a mistake refactoring an algorithm, extracting variables, introducing parameters, changing signatures or whatever your refactoring is composed of, this testing infrastructure will detect the problem. Furthermore, if some refactoring or optimization could not be valid for every possible case we can verify it for every case used by the application and expressed as a test case.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec04"/>What is the advantage?</h2></div></div></div><p>Personally, the main advantage I've seen so far is that you focus your destination quickly and is much difficult to divert implementing options in your software that will never be used. This implementation of unneeded features is a wasting of your precious development time and effort. And as you may already know, judiciously administering these resources may be the difference between successfully reaching the end of the project or not. Probably, Test Driven Development could not be indiscriminately applied to any project. I think that, as well as any other technique, you should use your judgment and expertise to recognize where it can be applied and where not. But keep this in mind:<strong> there are no silver bullets</strong>.<a class="indexterm" id="id208"/>
</p><p>The other advantage is that you always have a safety net for your changes. Every time you change a piece of code, you can be absolutely sure that other parts of the system are not affected as long as there are tests verifying that the conditions haven't changed.<a class="indexterm" id="id209"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec05"/>Understanding the requirements</h2></div></div></div><p>To be able to write a test about any subject, we should first understand the Subject under test.<a class="indexterm" id="id210"/>
</p><p>We also mentioned that one of the advantages is that you focus your destination quickly instead of revolving around the requirements.</p><p>Translating requirements into tests and cross referencing them is perhaps the best way to understand the requirements, and be sure that there is always an implementation and verification for all of them. Also, when the requirements change (something that is very frequent in software development projects), we can change the tests verifying these requirements and then change the implementation to be sure that everything was correctly understood and mapped to code.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Creating a sample project—the Temperature Converter</h1></div></div></div><p>Our examples will revolve around an extremely simple Android sample project. It doesn't try to show all the fancy Android features but focuses on testing and gradually building the application from the test, applying the concepts learned before.<a class="indexterm" id="id211"/>
</p><p>Let's pretend that we have received a list of requirements to develop an Android temperature converter application. Though oversimplified, we will be following the steps you normally would to develop such an application. However, in this case we will introduce the Test Driven Development techniques in the process.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec06"/>The list of requirements</h2></div></div></div><p>Most usual than not, the list of requirements is very vague and there is a high number of details not fully covered.<a class="indexterm" id="id212"/>
</p><p>As an example, let's pretend that we receive this list from the project owner:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application converts temperatures from Celsius to Fahrenheit and vice-versa</li><li class="listitem" style="list-style-type: disc">The user interface presents two fields to enter the temperatures, one for Celsius other for Fahrenheit</li><li class="listitem" style="list-style-type: disc">When one temperature is entered in one field the other one is automatically updated with the conversion</li><li class="listitem" style="list-style-type: disc">If there are errors, they should be displayed to the user, possibly using the same fields<a class="indexterm" id="id213"/></li><li class="listitem" style="list-style-type: disc">Some space in the user interface should be reserved for the on screen keyboard to ease the application operation when several conversions are entered</li><li class="listitem" style="list-style-type: disc">Entry fields should start empty</li><li class="listitem" style="list-style-type: disc">Values entered are decimal values with two digits after the point</li><li class="listitem" style="list-style-type: disc">Digits are right aligned</li><li class="listitem" style="list-style-type: disc">Last entered values should be retained even after the application is paused</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec07"/>User interface concept design</h2></div></div></div><p>Let's assume that we receive this conceptual user interface design from the User Interface Design team:<a class="indexterm" id="id214"/>
</p><div><img alt="User interface concept design" src="img/3500_04_02.jpg"/></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Creating the projects</h3></div></div></div><p>Our first step is to create the project. As we mentioned earlier, we are creating a main and a test project. The following screenshot shows the creation of the<code class="literal"> TemperatureConverter</code> project (all values are typical Android project values):<a class="indexterm" id="id215"/>
</p><div><img alt="Creating the projects" src="img/3500_04_03.jpg"/></div><p>When you are ready to continue you should press the<strong> Next &gt;</strong> button in order to create the related test project.</p><p>The creation of the test project is displayed in this screenshot. All values will be selected for you based on your previous entries:<a class="indexterm" id="id216"/>
</p><div><img alt="Creating the projects" src="img/3500_04_04.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Creating the TemperatureConverterActivityTests project</h1></div></div></div><p>We only have some templates in our<strong> main project</strong> created by the Android ADT plugin, such as:<a class="indexterm" id="id217"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TemperatureConverterActivity</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">main.xml</code> layout</li><li class="listitem" style="list-style-type: disc"><code class="literal">strings.xml</code> resources</li><li class="listitem" style="list-style-type: disc">Other resources, like icons</li></ul></div><p>Additionally, we have some templates created in our<strong> test project</strong>. The corresponding test packages to keep our tests separated from the main package are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">main.xml</code> layout</li><li class="listitem" style="list-style-type: disc"><code class="literal">strings.xml</code> resources</li><li class="listitem" style="list-style-type: disc">Other resources, like icons</li></ul></div><div><h3 class="title"><a id="note09"/>Note</h3><p>Be very cautious and don't let the template files fool you. There's little or no use of these resources in the test project so to avoid confusion, you should delete them. If later on you discover that some tests require specific resources, you can add only the needed ones.</p></div><p>Proceed with creating the first test by selecting the main test package name<strong> com.example.aatg.tc.test</strong> in Eclipse's<strong> Package Explorer</strong>, and then right-click on it. Select<strong> New | JUnit Test Case</strong>.</p><p>You should have a dialog like this:</p><div><img alt="Creating the TemperatureConverterActivityTests project" src="img/3500_04_05.jpg"/></div><p>Here, you need to enter the following:<a class="indexterm" id="id218"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Field</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>New JUnit 3 test</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>JUnit 3 is the version supported by Android. Always use this option.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Source folder:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The default source folder for the tests. The default value should be fine.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Package:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The default package for the tests. This is usually the default package name for your main project followed by the subpackage test.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Name:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The name of the class for this test. The best practice here is to use the same class name of the class under test followed by the word Tests, in plural because most probably we will be hosting several tests in it.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Superclass:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>We should select our superclass depending on what and how we are going to test. In <a class="link" href="ch03.html" title="Chapter 3. Building Blocks on the Android SDK">Chapter 3</a>, <em>Building Blocks on the Android SDK</em>, we reviewed the available alternatives. Use it as a reference when you try to decide what superclass to use.</p>
<p>In this particular case and because we are testing a single <code class="literal">Activity</code> and using the system infrastructure we use <code class="literal">ActivityInstrumentationTestCase2</code>. Also note that as <code class="literal">ActivityInstrumentationTestCase2</code> is a generic class, we need the template parameter as well. This is the <code class="literal">Activity</code> under test which in our case is <code class="literal">TemperatureConverterActivity</code>.</p>
<p>We can ignore the warning indicating that the superclass does not exist for now; we will be fixing the imports soon.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Method stubs</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>Select the method stubs you want created. If at this point you are not sure what you would need, then select them all, as default stubs will be invoking their super counterparts.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Do you want to add comments?</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>Generates Javadoc comments for the stub test method.</p>
<p>Usually, unless you have changed the default template in Code Templates, the generated comments will be:</p>
<p>
</p><div><pre class="programlisting">
/**
* Test method for {@link method()}.
*/
</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Class under test:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the class we are testing - <code class="literal">TemperatureConverterActivity</code> in this case. This is the most useful in other situations where the class under test has been implemented already and we would be able to select the list of methods we would like to test. Remember that in our case we haven't implemented the class yet so we will be presented with the only method that is in the Android ADT plugin template, which is <code class="literal">onCreate</code>.</p>
</td></tr></tbody></table></div><p>This situation, where the class under test has not been implemented yet and only the method created by the Android ADT is available, is better understood pressing<strong> Next &gt;</strong>. Here, the list of methods available to test is presented, and in our case we don't have any methods implemented yet other than<code class="literal"> onCreate</code> and the inherited methods from Activity.<a class="indexterm" id="id219"/>
</p><div><img alt="Creating the TemperatureConverterActivityTests project" src="img/3500_04_06.jpg"/></div><p>This dialog has the following components:<a class="indexterm" id="id220"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Field</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>Available methods:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the list of all the methods we may want to test.</p>
<p>When methods are overloaded, test names are generated accordingly to cope with the situation and parameter names are mangled into the test name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Create final method stubs</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>Convenience set to add the final modifier to stub methods.</p>
<p>The final modifier prevents these methods from being overridden by a subclass.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Create tasks for generated test methods</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates a TODO comment in the test case.</p>
</td></tr></tbody></table></div><p>Either way, we may select<code class="literal"> onCreate(Bundle)</code> to generate the<code class="literal"> testOnCreateBundle</code> method for us, but we are leaving the selection list empty for now to avoid extra complexity of this simple demonstration application.</p><p>We now notice that our automatically generated class has some errors we need to fix before running. Otherwise the errors will prevent the test from running.<a class="indexterm" id="id221"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First we should add the missing imports, using the shortcut<em> Shift+Ctrl+O</em>.</li><li class="listitem" style="list-style-type: disc">Second, the problem we need to fix has been described before in<a class="link" href="ch03.html" title="Chapter 3. Building Blocks on the Android SDK"> Chapter 3</a>,<em> Building Blocks on the Android SDK</em> under the section<em> The no-argument constructor</em>. As this pattern dictates, we need to implement it:<div><pre class="programlisting">public TemperatureConverterActivityTests() {
this("TemperatureConverterActivityTests");
}
public TemperatureConverterActivityTests(String name) {
super(TemperatureConverterActivity.class);
setName(name);
}
</pre></div></li><li class="listitem" style="list-style-type: disc">We added the no argument constructor<code class="literal"> TemperatureConverterActivityTests()</code>. From this constructor, we invoke the constructor that takes a name as a parameter.</li><li class="listitem" style="list-style-type: disc">Finally, in this given name constructor, we invoke the super constructor and set the name.</li></ul></div><p>To verify that everything has been set up in place, you may run the tests by using<strong> Run as | Android JUnit Test</strong>. There are no tests to run yet but at least we can verify that the infrastructure supporting our tests is already in place.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec08"/>Creating the fixture</h2></div></div></div><p>We can start creating our test fixture by populating the<code class="literal"> setUp</code> method with the elements we need in our tests. Almost unavoidable, in this case, is the use of the<code class="literal"> Activity</code> under test, so let's prepare for the situation and add it to the fixture:<a class="indexterm" id="id222"/>
</p><div><pre class="programlisting">protected void setUp() throws Exception {
super.setUp();
mActivity = getActivity();
}
</pre></div><p>Let's create the<code class="literal"> mActivity</code> field as well as the one proposed by Eclipse.</p><p>The<code class="literal"> ActivityInstrumentationTestCase2.getActivity()</code> method has a side effect. If the<code class="literal"> Activity</code> under test is not running, it is started. This may change the intention of a test if we use<code class="literal"> getActivity()</code> as a simple accessor several times in a test and for some reason the<code class="literal"> Activity</code> finishes or crashes before test completion. We will be inadvertently restarting the<code class="literal"> Activity</code>, that is why in our tests we discourage the use of<code class="literal"> getActivity()</code> in favor of having it in the fixture.<a class="indexterm" id="id223"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec09"/>Test preconditions</h2></div></div></div><p>We mentioned this before and this can be identified as another pattern. It's very useful to test all the preconditions and be sure that our fixture has been created correctly.<a class="indexterm" id="id224"/>
</p><div><pre class="programlisting">public final void testPreconditions() {
assertNotNull(mActivity);
}
</pre></div><p>That is, let's check that our fixture is composed by "not null" values.</p><p>We can run the tests to verify that everything is correct and green as shown in this screenshot:</p><div><img alt="Test preconditions" src="img/3500_04_07.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec10"/>Creating the user interface</h2></div></div></div><p>Back to our Test Driven Development track, we need from our concise list of requirements that there be two entries for Celsius and Fahrenheit temperatures respectively. So let's add them to our test fixture.<a class="indexterm" id="id225"/>
</p><p>They don't exist yet, and we haven't even started designing the user interface layout, but we know that there should be two entries like these for sure.</p><p>This is the code you should add to the<code class="literal"> setUp()</code> method:</p><div><pre class="programlisting">mCelsius = (EditText)
mActivity.findViewById(com.example.aatg.tc.R.id.celsius);
mFahrenheit = (EditText) mActivity.findViewById(com.example.aatg.tc.R.id.fahrenheit);
</pre></div><p>There are some important things to notice:<a class="indexterm" id="id226"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We define the fields for our fixture using<code class="literal"> EditText</code> that we should import</li><li class="listitem" style="list-style-type: disc">We use previously created<code class="literal"> mActivity</code> to find the<code class="literal"> Views</code> by ID</li><li class="listitem" style="list-style-type: disc">We use the R class for the main project, not the one in the test project</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Testing the existence of the user interface components</h2></div></div></div><p>Once we have added them to the<code class="literal"> setUp()</code> method, as indicated in the previous section, we can check their existence in a specific test:<a class="indexterm" id="id227"/>
</p><div><pre class="programlisting">public final void testHasInputFields() {
assertNotNull(mCelsius);
assertNotNull(mFahrenheit);
}
</pre></div><p>We are not able to run the tests yet because we must fix some compilation problems first. We should fix the missing IDs in the R class.</p><p>Having created our test fixture that references elements and IDs in the user interface that we don't have yet, it's mandated by the Test Driven Development paradigm that we add the needed code to satisfy our tests. The first thing we should do is get it to compile at least, so if we have some tests testing unimplemented features they will fail.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Getting the IDs defined</h2></div></div></div><p>Our first stop would be to have the IDs for the user interface elements defined in the<code class="literal"> R</code> class so the errors generated by referencing undefined constants<code class="literal"> com.example.aatg.tc.R.id.celsius</code> and<code class="literal"> com.example.aatg.tc.R.id.fahrenheit</code> go away.<a class="indexterm" id="id228"/>
</p><p>You, as an experienced Android developer, know how to do it. I'll give you a refresher anyway. Open the<code class="literal"> main.xml</code> layout in the layout editor and add the required user interface components to get something that resembles the design previously introduced in the section<em> User Interface concept design</em>.</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout

android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="fill_parent"&gt;<strong>
&lt;TextView
android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:text="@string/message" /&gt;
&lt;TextView
android:id="@+id/celsius_label"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="@string/celsius" /&gt;
&lt;EditText
android:id="@+id/celsius"
android:layout_height="wrap_content"
android:layout_width="wrap_content"
android:text="EditText" /&gt;
&lt;TextView
android:id="@+id/fahrenheit_label"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:text="@string/fahrenheit" /&gt;
&lt;EditText
android:id="@+id/fahrenheit"
android:layout_height="wrap_content"
android:layout_width="wrap_content"
android:text="EditText" /&gt;</strong>
&lt;/LinearLayout&gt;
</pre></div><p>Doing so we get our tests to compile. Running them we get the following results:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testPreconditions</code> succeeded</li><li class="listitem" style="list-style-type: disc"><code class="literal">testHasInputFields</code> succeeded</li><li class="listitem" style="list-style-type: disc">Everything is green now</li></ul></div><p>This clearly means that we are on track with applying TDD.</p><p>You may also have noticed that we added some decorative and non functional items to our user interface that we are not testing, mainly to keep our example as simple as possible. In a real case scenario you may want to add tests for these elements too.<a class="indexterm" id="id229"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Translating requirements to tests</h2></div></div></div><p>Tests have a double feature. They verify the correctness of our code but sometimes, and more prominently in TDD, they help us understand the design and digest what we are implementing. To be able to create the tests, we need to understand the problem we are dealing with and if we don't, we should at least have a rough understanding of the problem to allow us to handle it.<a class="indexterm" id="id230"/>
</p><p>Many times, the requirements behind the user interface are not clearly expressed and you should be able to understand them from the schematic UI design. If we pretend that this is the case, then we can grasp it by writing our tests first.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Empty fields</h3></div></div></div><p>From one of our requirements, we get: Entry fields should start empty.<a class="indexterm" id="id231"/>
</p><p>To express this in a test we can write:</p><div><pre class="programlisting">public final void testFieldsShouldStartEmpty() {
assertEquals("", mCelsius.getText().toString());
assertEquals("", mFahrenheit.getText().toString());
}
</pre></div><p>Here, we simply compare the initial contents of the fields against the empty string.</p><p>Not very surprisingly, we find that the test fails on execution. We forgot to clear the initial contents of the fields and they are not empty. Even though we haven't added any value to the<code class="literal"> android:text</code> property of these fields, the ADT plugin layout editor adds some default values. Thus removing the default values from<code class="literal"> android:text="@~+id/EditText01"</code> and<code class="literal"> android:text="@+id/EditText02"</code> will force starting with empty temperature fields. These values may have been added by the ADT plugin itself or maybe by you when entering properties.</p><p>On running the test again, we find that it passes. We successfully converted one requirement to a test and validated it by obtaining the test results.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>View properties</h3></div></div></div><p>Identically, we can verify other properties of the<code class="literal"> Views</code> composing our layout. Among other things we can verify:<a class="indexterm" id="id232"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fields appear on the screen as expected</li><li class="listitem" style="list-style-type: disc">Font sizes</li><li class="listitem" style="list-style-type: disc">Margins</li><li class="listitem" style="list-style-type: disc">Screen alignment</li></ul></div><p>Let's start verifying that the fields are on the screen:</p><div><pre class="programlisting">public final void testFieldsOnScreen() {
final Window window = mActivity.getWindow();
final View origin = window.getDecorView();
assertOnScreen(origin, mCelsius);
assertOnScreen(origin, mFahrenheit);
}
</pre></div><p>As explained before, we use an assert form here:<code class="literal"> ViewAsserts: assertOnScreen</code>.</p><div><h3 class="title"><a id="note10"/>Note</h3><p>Static imports and how to add them to Eclipse's Content Assist was explained in<a class="link" href="ch03.html" title="Chapter 3. Building Blocks on the Android SDK"> Chapter 3</a>,<em> Building Blocks on the Android SDK</em>. If you haven't done it before, now is the time.</p></div><p>The<code class="literal"> assertOnScreen</code> method needs an origin to start looking for the other<code class="literal"> Views</code>. In this case, because we want to start from the top most level, we use<code class="literal"> getDecorView(),</code> which retrieves the top-level window decor view containing the standard window frame and decorations, and the client's content inside.</p><p>By running this test, we can ensure that the entry fields are on the screen as the UI design dictates. In some way we already knew that some Views with these specific IDs existed. That is, we made the fixture compile by adding the Views to the main layout, but we were not sure they were appearing on the screen at all. So, nothing else is needed but the sole presence of this test to ensure that the condition is not changed in the future. If we remove one of the fields for some reason, this test will tell us that it is missing and not complying with the UI design.<a class="indexterm" id="id233"/>
</p><p>Following with our list of requirements, we should test that the<code class="literal"> Views</code> are aligned in the layout as we expect:</p><div><pre class="programlisting">public final void testAlignment() {
assertLeftAligned(mCelsiusLabel, mCelsius);
assertLeftAligned(mFahrenheitLabel, mFahrenheit);
assertLeftAligned(mCelsius, mFahrenheit);
assertRightAligned(mCelsius, mFahrenheit);
}
</pre></div><p>We continue using asserts from<code class="literal"> ViewAssert</code>—in this case,<code class="literal"> assertLeftAligned</code> and<code class="literal"> assertRightAligned</code>. These methods verify the alignment of the specified<code class="literal"> Views</code>.</p><p>The<code class="literal"> LinearLayout</code> we are using by default arranges the fields in the way we are expecting them. Again, while we don't need to add anything to the layout, to satisfy the test, this will act as a guard condition.</p><p>Once we've verified that they are correctly aligned, we should verify that they are covering the whole screen width as specified by the schematic drawing. In this example, it's sufficient to verify the<code class="literal"> LayoutParams</code> having the correct values:<a class="indexterm" id="id234"/>
</p><div><pre class="programlisting">public final void testCelsiusInputFieldCoverEntireScreen() {
final int expected = LayoutParams.MATCH_PARENT;
final LayoutParams lp = mCelsius.getLayoutParams();
assertEquals("mCelsius layout width is not MATCH_PARENT", expected, lp.width);
}
public final void testFahrenheitInputFieldCoverEntireScreen() {
final int expected = LayoutParams.MATCH_PARENT;
final LayoutParams lp = mFahrenheit.getLayoutParams();
assertEquals("mFahrenheit layout width is not MATCH_PARENT", expected, lp.width);
}
</pre></div><p>We used a custom message to easily identify the problem in case the test fails.</p><p>By running this test, we obtain the following message indicating that the test failed:</p><p>
<strong>junit.framework.AssertionFailedError: mCelsius layout width is not MATCH_PARENT expected:&lt;-1&gt; but was:&lt;-2&gt;</strong>
</p><p>This leads us to the layout definition. We must change<code class="literal"> layout_width</code> to be<code class="literal"> match_parent</code> for Celsius and Fahrenheit fields:</p><div><pre class="programlisting">&lt;EditText android:layout_height="wrap_content"
android:id="@+id/celsius" android:layout_width="match_parent"
/&gt;
</pre></div><p>Same for Fahrenheit—after the change is done, we repeat the cycle and by running the test again, we can verify that it is now successful.</p><p>Our method is starting to appear. We create the test to verify a condition described in the requirements. If it's not met, we change the cause of the problem and running the tests again we verify that the latest change solves the problem, and what is perhaps more important is that the change doesn't break the exiting code.</p><p>Next, let's verify that font sizes are as defined in our requirements:</p><div><pre class="programlisting">public final void testFontSizes() {
final float expected = 24.0f;
assertEquals(expected, mCelsiusLabel.getTextSize());
assertEquals(expected, mFahrenheitLabel.getTextSize());
}
</pre></div><p>Retrieving the font size used by the field is enough in this case.</p><p>The default font size is not<code class="literal"> 24px</code>, so we need to add this to our layout. It's a good practice to add the corresponding dimension to a resource file and then use it where it's needed in the layout. So, let's add<code class="literal"> label_text_size</code> to<code class="literal"> res/values/dimens.xml</code> with a value of<code class="literal"> 24px</code>. Then reference it in the<code class="literal"> Text size</code> property of both labels,<code class="literal"> celsius_label</code> and<code class="literal"> fahrenheit_label</code>.</p><p>Now the test is passed.</p><p>Finally, let's verify that margins are interpreted as described in the user interface design:<a class="indexterm" id="id235"/>
</p><div><pre class="programlisting">public final void testMargins() {
LinearLayout.LayoutParams lp;
final int expected = 6;
lp = (LinearLayout.LayoutParams) mCelsius.getLayoutParams();
assertEquals(expected, lp.leftMargin);
assertEquals(expected, lp.rightMargin);
lp = (LinearLayout.LayoutParams) mFahrenheit.getLayoutParams();
assertEquals(expected, lp.leftMargin);
assertEquals(expected, lp.rightMargin);
}
</pre></div><p>This is a similar case as before. We need to add this to our layout. Let's add the margin dimension to the resource file and then use it where it's needed in the layout. Set the<code class="literal"> margin</code> dimension in<code class="literal"> res/values/dimens.xml</code> to a value of<code class="literal"> 6px</code>. Then reference it in the<code class="literal"> Margin</code> property of both fields,<code class="literal"> celsius</code> and<code class="literal"> fahrenheit</code>, and in the<code class="literal"> Left margin</code> of the labels.</p><p>One more thing that is left is the verification of the justification of the entered values. We will validate input shortly to allow only the permitted values but for now let's just pay attention to the justification. The intention is to have values that are smaller than the whole field justified to the right and vertically centered:</p><div><pre class="programlisting">public final void testJustification() {
final int expected = Gravity.RIGHT|Gravity.CENTER_VERTICAL;
int actual = mCelsius.getGravity();
assertEquals(String.format("Expected 0x%02x but was 0x%02x", expected, actual), expected, actual);
actual = mFahrenheit.getGravity();
assertEquals(String.format("Expected 0x%02x but was 0x%02x", expected, actual), expected, actual);
}
</pre></div><p>Here we verify the gravity values as usual. However, we are using a custom message to help us identify the values that could be wrong. As<code class="literal"> Gravity</code> class defines several constants whose values are better identified if expressed in hexadecimal, we are converting the values to this base in the message.</p><p>If this test is failing due to the default gravity used for the fields, then what is only left is to change it. Go to the layout definition and alter these gravity values so that the test succeeds.</p><p>This is precisely what we need to add:</p><div><pre class="programlisting">android:gravity="right|center_vertical"
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Screen layout</h2></div></div></div><p>We now want to verify that the requirement specifying that enough screen space should be reserved to display the keyboard is actually fulfilled.<a class="indexterm" id="id236"/>
</p><p>We can write a test like this:</p><div><pre class="programlisting">public final void testVirtualKeyboardSpaceReserved() {
final int expected = 280;
final int actual = mFahrenheit.getBottom();
assertTrue(actual &lt;= expected);
}
</pre></div><p>This verifies that the actual position of the last field in the screen, which is<code class="literal"> mFahrenheit</code>, is not lower than a suggested value.</p><p>We can run the tests again verifying that everything is green again.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Adding functionality</h1></div></div></div><p>The user interface is in place. Now we start adding some basic functionality.<a class="indexterm" id="id237"/>
</p><p>This functionality will include the code to handle the actual temperature conversion.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Temperature conversion</h2></div></div></div><p>From the list of requirements we can obtain this statement: When one temperature is entered in one field the other one is automatically updated with the conversion.<a class="indexterm" id="id238"/>
</p><p>Following our plan we must implement this as a test to verify that the correct functionality is there. Our test would look something like this:</p><div><pre class="programlisting">@UiThreadTest
public final void testFahrenheitToCelsiusConversion() {<strong>
mCelsius.clear();
mFahrenheit.clear();</strong>
final double f = 32.5;
mFahrenheit.requestFocus();<strong>
mFahrenheit.setNumber(f);</strong>
mCelsius.requestFocus();<strong>
final double expectedC =
TemperatureConverter.fahrenheitToCelsius(f);
final double actualC = mCelsius.getNumber();</strong>
final double delta = Math.abs(expectedC - actualC);
final String msg = "" + f + "F -&gt; " + expectedC + "C but was " + actualC + "C (delta " + delta + ")";
final String msg = "" + f + "F -&gt; " + expectedC + "C but was " + actualC + "C (delta " + delta + ")";
assertTrue(msg, delta &lt; 0.005);
}
</pre></div><p>Firstly, as we already know, to interact with the UI changing its values we should run the test on the UI thread and thus is annotated with<code class="literal"> @UiThreadTest</code>.</p><p>Secondly, we are using a specialized class to replace<code class="literal"> EditText</code> providing some convenience methods like<code class="literal"> clear()</code> or<code class="literal"> setNumber()</code>. This would improve our application design.</p><p>Next, we invoke a converter, named<code class="literal"> TemperatureConverter</code>, a utility class providing the different methods to convert between different temperature units and using different types for the temperature values.</p><p>Finally, as we will be truncating the results to provide them in a suitable format presented in the user interface we should compare against a delta to assert the value of the conversion.</p><p>Creating the test as it is will force us to follow the planned path. Our first objective is to add the needed code to get the test to compile and then to satisfy the test's needs.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec16"/>The EditNumber class</h2></div></div></div><p>In our main project, not in the tests one, we should create the class<code class="literal"> EditNumber</code> extending<code class="literal"> EditText</code> as we need to extend its functionality.<a class="indexterm" id="id239"/>
</p><p>We use Eclipse's help to create this class using<strong> File | New | Class</strong> or its shortcut in the Toolbars.</p><p>This screenshot shows the window that appears after using this shortcut:</p><div><img alt="The EditNumber class" src="img/3500_04_08.jpg"/></div><p>The following table describes the most important fields and their meaning in the previous screen:<a class="indexterm" id="id240"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Field</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>Source folder:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The source folder for the newly-created class. In this case the default location is fine.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Package:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The package where the new class is created. In this case the default package<code class="literal"> com.example.aatg.tc</code> is fine too.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Name:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The name of the class. In this case we use<code class="literal"> EditNumber</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Modifiers:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>Modifiers for the class. In this particular case we are creating a public class.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Superclass:</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The superclass for the newly-created type. We are creating a custom<code class="literal"> View</code> and extending the behavior of<code class="literal"> EditText</code>, so this is precisely the class we select for the supertype.</p>
<p>Remember to use<strong> Browse..</strong>. to find the correct package.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Which method stubs would you like to create?</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>These are the method stubs we want Eclipse to create for us. Selecting<strong> Constructors from superclass</strong> and<strong> Inherited abstract methods</strong> would be of great help.</p>
<p>As we are creating a custom View we should provide the constructors that are used in different situations, for example when the custom View is used inside an XML layout.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Do you want to add comments?</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>Some comments are added automatically when this option is selected. You can configure Eclipse to personalize these comments.</p>
</td></tr></tbody></table></div><p>Once the class is created we need to change the type of the fields first in our test:</p><div><pre class="programlisting">public class TemperatureConverterActivityTests extends
ActivityInstrumentationTestCase2&lt;TemperatureConverterActivity&gt; {
private TemperatureConverterActivity mActivity;<strong>
private EditNumber mCelsius;
private EditNumber mFahrenheit;</strong>
private TextView mCelsiusLabel;
private TextView mFahrenheitLabel;
…
</pre></div><p>Then change any cast that is present in the tests. Eclipse will help you do that.</p><p>If everything goes well, there are still two problems we need to fix before being able to compile the test:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We still don't have the methods<code class="literal"> clear()</code> and<code class="literal"> setNumber()</code> in<code class="literal"> EditNumber</code></li><li class="listitem" style="list-style-type: disc">We don't have the<code class="literal"> TemperatureConverter</code> utility class</li></ul></div><p>To create the methods we are using Eclipse's helpful actions. Let's choose<strong> Create method clear() in type EditNumber</strong>.<a class="indexterm" id="id241"/>
</p><p>Same for<code class="literal"> setNumber()</code> and<code class="literal"> getNumber().</code>
</p><p>Finally, we must create the<code class="literal"> TemperatureConverter</code> class.</p><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Be sure to create it in the main project and not in the test project.</p></div><div><img alt="The EditNumber class" src="img/3500_04_09.jpg"/></div><p>Having done this, in our test select<strong> Create method fahrenheitToCelsius in type TemperatureConverter</strong>.</p><p>This fixes our last problem and leads us to a test that we can now compile and run.<a class="indexterm" id="id242"/>
</p><p>Surprisingly, or not, when we run the tests, they will fail with an exception:</p><p>
<strong>09-06 13:22:36.927: INFO/TestRunner(348): java.lang.ClassCastException: android.widget.EditText</strong>
</p><p>
<strong>09-06 13:22:36.927: INFO/TestRunner(348): at com.example.aatg.tc.test.TemperatureConverterActivityTests.setUp(TemperatureConverterActivityTests.java:41)</strong>
</p><p>
<strong>09-06 13:22:36.927: INFO/TestRunner(348): at junit.framework.TestCase.runBare(TestCase.java:125)</strong>
</p><p>That is because we updated all of our Java files to include our newly-created<code class="literal"> EditNumber</code> class but forgot to change the XMLs, and this could only be detected at runtime.<a class="indexterm" id="id243"/>
</p><p>Let's proceed to update our UI definition:</p><div><pre class="programlisting"><strong>&lt;com.example.aatg.tc.EditNumber</strong>
android:layout_height="wrap_content"
android:id="@+id/celsius"
android:layout_width="match_parent"
android:layout_margin="@dimen/margin"
android:gravity="right|center_vertical"
android:saveEnabled="true" /&gt;
</pre></div><p>That is, we replace the original<code class="literal"> EditText</code> by<code class="literal"> com.example.aatg.tc.EditNumber</code> which is a<code class="literal"> View</code> extending the original<code class="literal"> EditText</code>.</p><p>Now we run the tests again and we discover that all tests pass.</p><p>But wait a minute, we haven't implemented any conversion or any handling of values in the new<code class="literal"> EditNumber</code> class and all tests passed with no problem. Yes, they passed because we don't have enough restrictions in our system and the ones in place simply cancel themselves.</p><p>Before going further, let's analyze what just happened. Our test invoked the<code class="literal"> mFahrenheit.setNumber(f)</code> method to set the temperature entered in the<strong> Fahrenheit</strong> field, but<code class="literal"> setNumber()</code> is not implemented and it is an empty method as generated by Eclipse and does nothing at all. So the field remains empty.</p><p>Next, the value for<code class="literal"> expectedC</code>—the expected temperature in Celsius is calculated invoking<code class="literal"> TemperatureConverter.fahrenheitToCelsius(f)</code>, but this is also an empty method as generated by Eclipse. In this case, because Eclipse knows about the return type it returns a constant 0. So<code class="literal"> expectedC</code> becomes 0.</p><p>Then the actual value for the conversion is obtained from the UI. In this case invoking<code class="literal"> getNumber()</code> from<code class="literal"> EditNumber</code>. But once again this method was automatically generated by Eclipse and to satisfy the restriction imposed by its signature, it must return a value that Eclipse fills with 0.</p><p>The delta value is again 0, as calculated by<code class="literal"> Math.abs(expectedC actualC)</code>.</p><p>And finally our assertion<code class="literal"> assertTrue(msg, delta &lt; 0.005)</code> is true because<code class="literal"> delta=0</code> satisfies the condition, and the test passes.</p><p>So, is our methodology flawed as it cannot detect a simple situation like this?</p><p>No, not at all. The problem here is that we don't have enough restrictions and they are satisfied by the default values used by Eclipse to complete auto-generated methods. One alternative could be to throw exceptions at all of the auto-generated methods, something like<code class="literal"> RuntimeException("not yet implemented")</code> to detect its use when not implemented. But we will be adding enough restrictions in our system to easily trap this condition.<a class="indexterm" id="id244"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>TemperatureConverter unit tests</h2></div></div></div><p>It seems, from our previous experience, that the default conversion implemented by Eclipse always returns 0, so we need something more robust. Otherwise this will be only returning a valid result when the parameter takes the value of 32F.<a class="indexterm" id="id245"/>
</p><p>The<code class="literal"> TemperatureConverter</code> is a utility class not related with the Android infrastructure, so a standard unit test will be enough to test it.</p><p>We create our tests using Eclipse's<strong> File | New | JUnit Test Case</strong>, filling in some appropriate values, and selecting the method to generate a test as shown in the next screenshot.</p><p>Firstly, we create the unit test by extending<code class="literal"> junit.framework.TestCase</code> and selecting<code class="literal"> com.example.aatg.tc.TemperatureConverter</code> as the class under test:</p><div><img alt="TemperatureConverter unit tests" src="img/3500_04_10.jpg"/></div><p>Then by pressing the<strong> Next &gt;</strong> button we can obtain the list of methods we may want to test:<a class="indexterm" id="id246"/>
</p><div><img alt="TemperatureConverter unit tests" src="img/3500_04_11.jpg"/></div><p>We have implemented only one method in<code class="literal"> TemperatureConverter</code>, so it's the only one appearing in the list. Other classes implementing more methods will display all the options here.<a class="indexterm" id="id247"/>
</p><p>It's good to note that even if the test method is auto-generated by Eclipse it won't pass. It will fail with the message<em> Not yet implemented</em> to remind us that something is missing.</p><p>Let's start by changing this:</p><div><pre class="programlisting">/**
* Test method for {@link com.example.aatg.tc. TemperatureConverter#fahrenheitToCelsius(double)}.
*/
public final void testFahrenheitToCelsius() {<strong>
for (double c: conversionTableDouble.keySet()) {
final double f = conversionTableDouble.get(c);
final double ca = TemperatureConverter.fahrenheitToCelsius(f);
final double delta = Math.abs(ca - c);
final String msg = "" + f + "F -&gt; " + c + "C but is " + ca + " (delta " + delta + ")";
assertTrue(msg, delta &lt; 0.0001);
}</strong>
}
</pre></div><p>Creating a conversion table with values for different temperature conversion we know from other sources would be a good way to drive this test.<a class="indexterm" id="id248"/>
</p><div><pre class="programlisting">private static final HashMap&lt;Double, Double&gt; conversionTableDouble = new HashMap&lt;Double, Double&gt;();
static {
// initialize (c, f) pairs
conversionTableDouble.put(0.0, 32.0);
conversionTableDouble.put(100.0, 212.0);
conversionTableDouble.put(-1.0, 30.20);
conversionTableDouble.put(-100.0, -148.0);
conversionTableDouble.put(32.0, 89.60);
conversionTableDouble.put(-40.0, -40.0);
conversionTableDouble.put(-273.0, -459.40);
}
</pre></div><p>We may just run this test to verify that it fails, giving us this trace:</p><p>
<strong>junit.framework.AssertionFailedError: -40.0F -&gt; -40.0C but is 0.0 (delta 40.0)</strong>
</p><p>
<strong>at com.example.aatg.tc.test.TemperatureConverterTests.testFahrenheitToCelsius(TemperatureConverterTests.java:62)</strong>
</p><p>
<strong>at java.lang.reflect.Method.invokeNative(Native Method)</strong>
</p><p>
<strong>at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)</strong>
</p><p>
<strong>at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)</strong>
</p><p>
<strong>at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:520)</strong>
</p><p>
<strong>at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)</strong>
</p><p>Well, this was something we were expecting as our conversion always returns 0. Implementing our conversion, we discover that we need some<code class="literal"> ABSOLUTE_ZERO_F</code> constant:</p><div><pre class="programlisting">public class TemperatureConverter {
public static final double ABSOLUTE_ZERO_C = -273.15d;
public static final double ABSOLUTE_ZERO_F = -459.67d;
private static final String ERROR_MESSAGE_BELOW_ZERO_FMT =
"Invalid temperature: %.2f%c below absolute zero";
public static double fahrenheitToCelsius(double f) {
if (f &lt; ABSOLUTE_ZERO_F) {
throw new InvalidTemperatureException(
String.format(ERROR_MESSAGE_BELOW_ZERO_FMT, f, 'F'));
}
return ((f - 32) / 1.8d);
}
}
</pre></div><p>Absolute zero is the theoretical temperature at which entropy would reach its minimum value. To be able to reach this absolute zero state, according to the laws of thermodynamics, the system should be isolated from the rest of the universe. Thus it is an unreachable state. However, by international agreement, absolute zero is defined as 0K on the Kelvin scale and as -273.15°C on the Celsius scale or to -459.67°F on the Fahrenheit scale.<a class="indexterm" id="id249"/>
</p><p>We are creating a custom exception,<code class="literal"> InvalidTemperatureException</code>, to indicate a failure providing a valid temperature to the conversion method. This exception is created simply by extending<code class="literal"> RuntimeException:</code>
</p><div><pre class="programlisting">public class InvalidTemperatureException extends RuntimeException {
public InvalidTemperatureException(String msg) {
super(msg);
}
}
</pre></div><p>Running the tests again we now discover that<code class="literal"> testFahrenheitToCelsiusConversion</code> test fails, however<code class="literal"> testFahrenheitToCelsius</code> succeeds. This tells us that now conversions are correctly handled by the converter class but there are still some problems with the UI handling this conversion.</p><p>A closer look at the failure trace reveals that there's something still returning 0 when it shouldn't.</p><p>This reminds us that we are still lacking a proper<code class="literal"> EditNumber</code> implementation. Before proceeding to implement the mentioned methods, let's create the corresponding tests to verify what we are implementing is correct.<a class="indexterm" id="id250"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>The EditNumber tests</h2></div></div></div><p>From the previous chapter, we can now determine that the best base class for our custom<code class="literal"> View</code> tests is<code class="literal"> AndroidTestCase</code>, as we need a mock<code class="literal"> Context</code> to create the custom<code class="literal"> View</code> but we don't need system infrastructure.<a class="indexterm" id="id251"/>
</p><p>This is the dialog we have to complete to create the tests. In this case using<code class="literal"> android.test.AndroidTestCase</code> as the base class and<code class="literal"> com.example.aatg.tc.EditNumber</code> as the class under test:</p><div><img alt="The EditNumber tests" src="img/3500_04_12.jpg"/></div><p>After pressing<strong> Next &gt;</strong>, we select the methods for which stubs are created:<a class="indexterm" id="id252"/>
</p><div><img alt="The EditNumber tests" src="img/3500_04_13.jpg"/></div><p>We need to update the auto-generated constructor to reflect the pattern we identified before, the given name pattern:<a class="indexterm" id="id253"/>
</p><div><pre class="programlisting"><strong>/**
* Constructor
*/
public EditNumberTests() {
this("EditNumberTests");
}</strong>
/**
* @param name
*/
public EditNumberTests(String name) {
setName(name);
}
</pre></div><p>The next step is to create the fixture. In this case this is a simple<code class="literal"> EditNumber</code> which we will be testing:<a class="indexterm" id="id254"/>
</p><div><pre class="programlisting">/* (non-Javadoc)
* @see junit.framework.TestCase#setUp()
*/
protected void setUp() throws Exception {
super.setUp();
mEditNumber = new EditNumber(mContext);
mEditNumber.setFocusable(true);
}
</pre></div><p>The mock context is obtained from the protected field mContext (<a class="ulink" href="http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext">http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext</a>) available in the<code class="literal"> AndroidTestCase</code> class.</p><p>At the end of the test we set<code class="literal"> mEditNumber</code> as a focusable<code class="literal"> View</code>, that is it will be able to gain focus, as it will be participating in a bunch of tests simulating UIs that may need to request its focus explicitly.</p><p>Next, we test that the required<code class="literal"> clear()</code> functionality is implemented correctly in the<code class="literal"> testClear()</code> method:</p><div><pre class="programlisting">/**
* Test method for {@link com.example.aatg.tc.EditNumber#clear()}.
*/
public final void testClear() {
final String value = "123.45";
mEditNumber.setText(value);
mEditNumber.clear();
String expectedString = "";
String actualString = mEditNumber.getText().toString();
assertEquals(expectedString, actualString);
}
</pre></div><p>Running the test we verify that it fails:</p><p>
<strong>junit.framework.ComparisonFailure: expected:&lt;&gt; but was:&lt;123.45&gt;</strong>
</p><p>
<strong>at com.example.aatg.tc.test.EditNumberTests.testClear(EditNumberTests.java:62)</strong>
</p><p>
<strong>at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)</strong>
</p><p>
<strong>at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)</strong>
</p><p>
<strong>at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:529)</strong>
</p><p>
<strong>at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)</strong>
</p><p>We need to implement<code class="literal"> EditNumber.clear()</code> correctly.<a class="indexterm" id="id255"/>
</p><p>This is a simple case, so just by adding this implementation to<code class="literal"> EditNumber</code> we satisfy the test:</p><div><pre class="programlisting">public void clear() {
setText("");
}
</pre></div><p>Run the test and proceed. Now let's complete the<code class="literal"> testSetNumber()</code> implementation:</p><div><pre class="programlisting">/**
* Test method for {@link com.example.aatg.tc.EditNumber#setNumber(double)}.
*/
public final void testSetNumber() {
mEditNumber.setNumber(123.45);
final String expected = "123.45";
final String actual = mEditNumber.getText().toString();
assertEquals(expected, actual);
}
</pre></div><p>Which fails unless we implement<code class="literal"> EditNumber.setNumber()</code>, similar to this implementation:</p><div><pre class="programlisting">private static final String DEFAULT_FORMAT = "%.2f";
public void setNumber(double f) {super.setText( String.format(DEFAULT_FORMAT, f));
}
</pre></div><p>We are using a constant,<code class="literal"> DEFAULT_FORMAT</code>, to hold the desired format to convert the numbers. This can be later converted to a property that could also be specified in the<code class="literal"> xml</code> layout definition of the field.</p><p>The same goes for the<code class="literal"> testGetNumber()</code> and<code class="literal"> getNumber()</code> pair:</p><div><pre class="programlisting">/**
* Test method for {@link com.example.aatg.tc.EditNumber#getNumber()}.
*/
public final void testGetNumber() {
mEditNumber.setNumber(123.45);
final double expected = 123.45;
final double actual = mEditNumber.getNumber();
assertEquals(expected, actual);
}
</pre></div><p>And:</p><div><pre class="programlisting">public double getNumber() {
Log.d("EditNumber", "getNumber() returning value of '" + getText().toString() + "'");
return Double.valueOf(getText().toString());
}
</pre></div><p>Surprisingly these tests succeed. But now there's a test that was passing that started to fail:<code class="literal"> testFahrenheitToCelsiusConversion()</code>. The reason is that now that we have implemented<code class="literal"> EditNumber.setNumber()</code> and<code class="literal"> EditNumber.getNumber()</code> correctly, some values are returned differently and this test method was relying on spurious values.<a class="indexterm" id="id256"/>
</p><p>This is a screenshot of the results obtained after running the tests:</p><div><img alt="The EditNumber tests" src="img/3500_04_14.jpg"/></div><p>If you closely analyze the case, you can discover where the problem is.</p><p>Got it ?</p><p>Our test method is expecting the conversion to be realized automatically when the focus changes, as was specified in our list of requirements: when one temperature is entered in one field the other one is automatically updated with the conversion.<a class="indexterm" id="id257"/>
</p><p>Remember, we don't have buttons or anything else to convert temperature values, so the conversion is expected to be done automatically once the values are entered.</p><p>This leads us again to the<code class="literal"> TemperatureConverterActivity</code> and the way it handles the conversions.<a class="indexterm" id="id258"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>The TemperatureChangeWatcher class</h2></div></div></div><p>One way of implementing the required behavior of constantly updating the other temperature value once one has changed is through a<code class="literal"> TextWatcher</code>. From the documentation we can understand that a<code class="literal"> TextWatcher</code> is an object of a type that is attached to an<code class="literal"> Editable</code>; its methods will be called when the text is changed (<a class="ulink" href="http://developer.android.com/intl/de/reference/android/text/TextWatcher.html">http://developer.android.com/intl/de/reference/android/text/TextWatcher.html</a>).<a class="indexterm" id="id259"/>
</p><p>It seems that is what we need.</p><p>We implement this class as an inner class of<code class="literal"> TemperatureConverterActivity</code>. This is the screenshot of the New Java Class in Eclipse:</p><div><img alt="The TemperatureChangeWatcher class" src="img/3500_04_15.jpg"/></div><p>And this is our code after some additions to the recently created class.</p><div><pre class="programlisting">/**
* Changes fields values when text changes applying the corresponding method.
*
*/
public class TemperatureChangedWatcher implements TextWatcher {
private final EditNumber mSource;
private final EditNumber mDest;
private OP mOp;
/**
* @param mDest
* @param convert
* @throws NoSuchMethodException
* @throws SecurityException
*/
public TemperatureChangedWatcher(TemperatureConverter.OP op) {
if ( op == OP.C2F ) {
this.mSource = mCelsius;
this.mDest = mFahrenheit;
}
else {
this.mSource = mFahrenheit;
this.mDest = mCelsius;
}
this.mOp = op;
}
/* (non-Javadoc)
* @see android.text.TextWatcher#afterTextChanged( android.text.Editable)
*/
public void afterTextChanged(Editable s) {
// TODO Auto-generated method stub
}
/* (non-Javadoc)
* @see android.text.TextWatcher#beforeTextChanged( java.lang.CharSequence, int, int, int)
*/
public void beforeTextChanged( CharSequence s, int start, int count, int after) {
// TODO Auto-generated method stub
}
/* (non-Javadoc)
* @see android.text.TextWatcher#onTextChanged( java.lang.CharSequence, int, int, int)
*/
public void onTextChanged(CharSequence s, int start, int before, int count) {
if (!mDest.hasWindowFocus() || mDest.hasFocus() || s == null )
{
return;
}
final String str = s.toString();
if ( "".equals(str) ) {
mDest.setText("");
return;
}
try {
final double temp = Double.parseDouble(str);
final double result = (mOp == OP.C2F) ? TemperatureConverter.celsiusToFahrenheit(temp) :
TemperatureConverter.fahrenheitToCelsius(temp);
final String resultString = String.format("%.2f", result);
mDest.setNumber(result);
mDest.setSelection(resultString.length());
} catch (NumberFormatException e) {
// WARNING
// this is generated while a number is entered,
// for example just a '-'
// so we don't want to show the error
} catch (Exception e) {
mSource.setError("ERROR: " + e.getLocalizedMessage());
}
}
}
</pre></div><p>We implement extending<code class="literal"> TextWatcher</code> and overriding the unimplemented methods.<a class="indexterm" id="id261"/>
</p><p>Because we will be using the same<code class="literal"> TemperatureChangeWatcher</code> implementation for both fields, Celsius and Fahrenheit, we keep a reference to the fields used as source and destination as well as the operation needed to update their values. To specify this operation we are introducing an<code class="literal"> enum</code> to the<code class="literal"> TemperatureConverter</code> class.</p><div><pre class="programlisting">/**
* C2F: celsiusToFahrenheit
* F2C: fahrenheitToCelsius
*/
public static enum OP { C2F, F2C };
</pre></div><p>This operation is specified in the constructor and the destination and source<code class="literal"> EditNumber</code> are selected accordingly. This way we can use the same watcher for different conversions.</p><p>The method of the<code class="literal"> TextWatcher</code> interface we are mainly interested in is<code class="literal"> onTextChanged</code>, that will be called any time the text changes. At the beginning we avoid potential loops, checking who has focus and returning if the conditions are not met.<a class="indexterm" id="id262"/>
</p><p>We also set the destination field as an empty<code class="literal"> String</code> if the source is empty.</p><p>Finally, we try to set the resulting value of invoking the corresponding conversion method to set the destination field. We flag the error as necessary, avoiding showing premature errors when the conversion was invoked with a partially entered number.</p><p>We need to set the listener on the fields in<code class="literal"> TemperatureConverterActivity.onCreate():</code>
</p><div><pre class="programlisting">/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
mCelsius = (EditNumber) findViewById(R.id.celsius);
mFahrenheit = (EditNumber) findViewById(R.id.fahrenheit);<strong>
mCelsius.addTextChangedListener(
new TemperatureChangedWatcher(OP.C2F));
mFahrenheit.addTextChangedListener(
new TemperatureChangedWatcher(OP.F2C));</strong>
}
</pre></div><p>To be able to run the tests we should compile them. To compile we need at least to define the<code class="literal"> celsiusToFahrenheit</code>, which is not yet defined.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>More TemperatureConverter tests</h2></div></div></div><p>We need to implement<code class="literal"> celsiusToFahrenheit</code> and as usual we start from the test.<a class="indexterm" id="id263"/>
</p><p>This is fairly equivalent to the other conversion method<code class="literal"> fahrenheitToCelsius</code> and we can use the infrastructure we devised while creating this test:</p><div><pre class="programlisting">/**
* Test method for {@link com.example.aatg.tc.TemperatureConverter#celsiusToFahrenheit(double)}.
*/
public final void testCelsiusToFahrenheit() {
for (double c: conversionTableDouble.keySet()) {
final double f = conversionTableDouble.get(c);
final double fa = TemperatureConverter.celsiusToFahrenheit(c);
final double delta = Math.abs(fa - f);
final String msg = "" + c + "C -&gt; " + f + "F but is " + fa + " (delta " + delta + ")";
assertTrue(msg, delta &lt; 0.0001);
}
}
</pre></div><p>We use the conversion table to exercise the method through different conversions and we verify that the error is less than a predefined delta.<a class="indexterm" id="id264"/>
</p><p>Then, the correspondent conversion implementation in<code class="literal"> TemperatureConverter</code> class is:</p><div><pre class="programlisting">public static double celsiusToFahrenheit(double c) {
if (c &lt; ABSOLUTE_ZERO_C) {
throw new InvalidTemperatureException(
String.format(ERROR_MESSAGE_BELOW_ZERO_FMT, c, 'C'));
}
return (c * 1.8d + 32);
}
</pre></div><p>Now all the tests are passing but we are still not testing all the common conditions. You should check if errors and exceptions are correctly generated, besides all the normal cases we created so far.</p><p>This is the test we create to check the correct generation of exceptions when a temperature below absolute zero is used in a conversion:</p><div><pre class="programlisting">public final void testExceptionForLessThanAbsoluteZeroF() {
try {
TemperatureConverter.fahrenheitToCelsius( TemperatureConverter.ABSOLUTE_ZERO_F-1);
fail();
}
catch (InvalidTemperatureException ex) {
// do nothing
}
}
</pre></div><p>In this test we decrement the absolute zero temperature to obtain an even smaller value and then we attempt the conversion. We check for the correct exception being caught and finally we assert this condition:</p><div><pre class="programlisting">public final void testExceptionForLessThanAbsoluteZeroC() {
try {
TemperatureConverter.celsiusToFahrenheit( TemperatureConverter.ABSOLUTE_ZERO_C-1);
fail();
}
catch (InvalidTemperatureException ex) {
// do nothing
}
}
</pre></div><p>In a similar manner we test for the exception being thrown when the attempted conversion involves a temperature in Celsius which is lower than the absolute zero.<a class="indexterm" id="id265"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>The InputFilter tests</h2></div></div></div><p>We want to filter the input that is received by the conversion utility so no garbage reaches this point.<a class="indexterm" id="id266"/>
</p><p>The<code class="literal"> EditNumber</code> class already filters valid input and generates exceptions otherwise. We can verify this condition by generating some new tests in<code class="literal"> TemperatureConverterActivityTests</code>. We choose this class because we are sending keys to the entry fields, just as a real user would do:</p><div><pre class="programlisting">public void testInputFilter() throws Throwable {
runTestOnUiThread(new Runnable() {
@Override
public void run() {
mCelsius.requestFocus();
}
});
final Double n = -1.234d;
sendKeys("MINUS 1 PERIOD 2 PERIOD 3 PERIOD 4");
Object nr = null;
try {
nr = mCelsius.getNumber();
}
catch (NumberFormatException e) {
nr = mCelsius.getText();
}
final String msg = "-1.2.3.4 should be filtered to " + n +
" but is " + nr;
assertEquals(msg, n, nr);
}
</pre></div><p>This test requests the focus to the Celsius field using the pattern we have reviewed before to run parts of a test in the UI thread, and then send some keys. The keys sent are an invalid sequence containing more than one period, which is not accepted for a well formed decimal number. It is expected that when the filter is in place, this sequence will be filtered and only the valid characters reach the field. We use the possibly generated<code class="literal"> NumberFormatException</code> to detect the error and then we assert that the value returned by<code class="literal"> mCelsius.getNumber()</code> is what we are expecting after filtering.</p><p>To implement this filter, we need to add an<code class="literal"> InputFilter</code> to<code class="literal"> EditNumber</code>. Because this should be added to all of the constructors we create an additional method<code class="literal"> init()</code> which we invoke from them. To achieve our goal we use an instance of<code class="literal"> DigitsKeyListener</code> accepting digits, signs, and decimal points.<a class="indexterm" id="id267"/>
</p><div><pre class="programlisting">/**
* Initialization.
* Set filter.
*
*/
private void init() {
// DigistKeyListener.getInstance(true, true) returns an
// instance that accepts digits, sign and decimal point
final InputFilter[] filters = new InputFilter[] { DigitsKeyListener.getInstance(true, true) };
setFilters(filters);
}
Then from the constructors we should invoke this method:
/**
* @param context
* @param attrs
*/
public EditNumber(Context context, AttributeSet attrs) {
super(context, attrs);
<strong>init();&gt;</strong>
}
</pre></div><p>This<code class="literal"> init</code> method is factored and invoked from different constructors.</p><p>Running the tests again we can verify that all have passed and now everything is green again.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Viewing our final application</h1></div></div></div><p>This is our final application which satisfies all the requirements.<a class="indexterm" id="id268"/>
</p><p>In the following screenshot we are showing one of these requirements, which is the detection of an attempt to convert a temperature below the absolute zero temperature in Celsius (-1000.00C):</p><div><img alt="Viewing our final application" src="img/3500_04_16.jpg"/></div><p>The UI respects the guidelines provided; the temperatures can be converted by entering them in the corresponding unit field.<a class="indexterm" id="id269"/>
</p><p>To recap, this was the list of requirements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application converts temperatures from Celsius to Fahrenheit and vice versa</li><li class="listitem" style="list-style-type: disc">The user interface presents two fields to enter the temperatures, one for Celsius and the other for Fahrenheit</li><li class="listitem" style="list-style-type: disc">When one temperature is entered in one field the other one is automatically updated with the conversion</li><li class="listitem" style="list-style-type: disc">If there are errors, they should be displayed to the user, possibly using the same fields</li><li class="listitem" style="list-style-type: disc">Some space in the user interface should be reserved for the on-screen keyboard to ease the application operation when several conversions are entered</li><li class="listitem" style="list-style-type: disc">Entry fields should start empty</li><li class="listitem" style="list-style-type: disc">Values entered are decimal values with two digits after the point</li><li class="listitem" style="list-style-type: disc">Digits are right aligned</li></ul></div><p>But what is perhaps more important is that we can assure that the application not only satisfies the requirements but also has no evident problems or bugs because we took every step by analyzing the test results and fixing the problems at their first appearance. This will ensure that the same bug, once discovered, will not resurface again.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Summary</h1></div></div></div><p>We presented Test Driven Development introducing its concepts and later on applying them step-by-step in a potential real-life problem.</p><p>We started with a concise list of requirement describing the Temperature Converter application.</p><p>Then, we implemented every test followed by the code that satisfies it. In this manner we implemented the application behavior as well as its presentation, conducting tests to verify that the UI we designed follows the specifications.</p><p>Having the tests in place lead us to analyze the different possibilities we have in running them and the next chapter will focus on the Testing Environment.</p></div></body></html>