<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Handling Multiple Scenes and Levels"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Handling Multiple Scenes and Levels</h1></div></div></div><p>In the previous chapter, we discussed a very significant topic of Sprite Kit, that is, particle effects and shaders. We also discussed about the <code class="literal">SKEmitterNode</code> object and the <code class="literal">SKShader</code> object. We also implemented them in our <span class="emphasis"><em>Platformer</em></span> game. Implementation of shaders in our game was the most fun part.</p><p>In this chapter, we are going to discuss a very important aspect of a game, that is, the addition of multiple levels. Having various levels in a game makes the game more exciting as incrementing levels increases the complexity of the game, making it more difficult to play. As various levels are added to the game, it also becomes important to add a pause button, which will enable the game to pause whenever required.</p><div class="section" title="Optimizing game levels"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Optimizing game levels</h1></div></div></div><p>A game continuously running at the same difficulty will become monotonous, and soon the user will lose interest in it. So, how can you make your game interesting, exciting, and challenging? If your game<a id="id450" class="indexterm"/> keeps on increasing its difficulty and adds new challenges for the user, it will remain interesting till the end.</p><p>Different levels in a game are nothing but sections or parts of the game. Normally, in most of the games, the game scenes are divided into multiple levels. Levels divide a game into small excerpts and only one level is loaded at a time. In a game, levels can be denoted by different names, such as rounds, stages, chapters, acts, maps, worlds, and so on. Different levels can be represented via names or numbers. In case of representing a level by a numbering system, it is a clear analogy that the higher the number, the greater the level.</p><p>The names of the levels are the first impressions of a game's level; it is advisable to give a brief thought to this. Let's<a id="id451" class="indexterm"/> discuss about the naming of levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Utilitarian</strong></span>: This mostly comprises of a number system or any other similar analogy. This system gives an idea <a id="id452" class="indexterm"/>to the player about their progress.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Location</strong></span>: This requires<a id="id453" class="indexterm"/> using the location of the level as the level name, such as city, village, town, and so on. It gives an idea to the player about what he/she will be seeing.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Descriptive</strong></span>: These <a id="id454" class="indexterm"/>seem more like being chapters of a book. This includes names such as airship fortress, green hill zone, pillar of autumn, and so on.</li></ul></div><p>These are the three main ways in which you can name your game's level. Apart from this, one more method can be to have puny names for the levels. It all depends on you to name your level.</p><p>To complete a game level, the user has to pass through some constraints or difficulties, such as reaching a certain score point or performing a specific task to reach the next level. This is commonly known as game progression.</p><p>Programmers usually create different levels in one of the following two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A new scene for a new level</strong></span>: In this<a id="id455" class="indexterm"/> method, there is a new scene created for each new level.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Multiple levels in a single scene</strong></span>: If the new level does not have much changes in the sprites or other game elements, we can also have the facility of multiple levels in a single scene. For the games which preferably have just one or two elements altered in each new level, single scene can be a good option.</li></ul></div><div class="section" title="A strategy for multiple levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec74"/>A strategy for multiple levels</h2></div></div></div><p>The different levels in the game<a id="id456" class="indexterm"/> define the difficulty of the game, or some hold the point at which the user currently should be, in the game.</p><p>In most games, level 1 will be the name of the first <code class="literal">SKScene</code> class for your first level. There are also a number of good transitions to choose from when transiting from one level to another or depicting any other effect, animation or information, as the level increases.</p><p>We can either use an array or a dictionary to store player data, such as items, health, levels achieved, and so on. Unless you have large amounts of data to be saved, <code class="literal">NSUserDefaults</code> can<a id="id457" class="indexterm"/> be the best option.</p><div class="section" title="Core Data"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec07"/>Core Data</h3></div></div></div><p>For the larger data storage requirement of a game, we can use separate data files. For such types of requirements, Apple <a id="id458" class="indexterm"/>provides a powerful tool, that is, Core Data. This tool is very useful for storing level information, user information, and so on.</p><p>What is Core Data? It's a<a id="id459" class="indexterm"/> framework by Apple that acts as a bridge between your game and SQLite and other storage environments. Just like SQL, you can have tables, relationships, and queries. The advantages of Core Data over SQLite are that it requires no syntax and represents objects and classes unlike in a relational database.</p><div class="mediaobject"><img src="graphics/4201_08_05.jpg" alt="Core Data"/></div><p>The important terms in Core Data are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Managed object model</strong></span>: It is a tool that allows you to model classes (entities), relationships, and <a id="id460" class="indexterm"/>queries. (This is used by the Core Data framework).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Managed objects [each row will be one object]</strong></span>: This refers to the objects that are created in<a id="id461" class="indexterm"/> your game. These are your data classes, such as, player information, level information, and so on. Each managed object represents a row in your table (entity).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Managed object context</strong></span>: This is an important object, since it manages all the relationships<a id="id462" class="indexterm"/> between the context objects that are defined in the model. It also keeps track of the status of the context objects. All interactions with the underlying database are done through <a id="id463" class="indexterm"/>context. The managed object context requests the persistent coordinator for data and tells it to save data when necessary.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Persistent store coordinator</strong></span>: Through<a id="id464" class="indexterm"/> the persistent store coordinator, we provide a location on the device for data storage.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Persistent object store</strong></span>: This is<a id="id465" class="indexterm"/> a data storage environment on the device.</li></ul></div></div></div></div></div>
<div class="section" title="Adding levels in our Platformer game"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Adding levels in our Platformer game</h1></div></div></div><p>Let's add levels in our <span class="emphasis"><em>Platformer</em></span> game. We are going to add the levels in a single scene. For the change in difficulty of the level, we can increase the speed of the player that is running and we <a id="id466" class="indexterm"/>can specify a distance after which the level will be increased.</p><p>Now, before we dive into adding<a id="id467" class="indexterm"/> levels in the game, first of all, we should know the current level being played. Hence, we are going to add the <span class="strong"><strong>Level</strong></span> label in the game scene, so that the user can know about the current level being played.</p><div class="section" title="Adding the Level label"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec75"/>Adding the Level label</h2></div></div></div><p>The <span class="strong"><strong>Level</strong></span> label is a simple text that<a id="id468" class="indexterm"/> will be displayed on the game scene and will act as a bit of information to recognize the level which is being played. As discussed earlier, you can have the name of the level as a number, location, or description. A number, as a level identifier, is the most common etymology in games. In our <span class="emphasis"><em>Platformer</em></span> game, we are using numbers as level labels.</p><p>Add the following code in the <code class="literal">GameScene.swift</code> file. This code will add the <code class="literal">level</code> label functionality in our game:</p><div class="informalexample"><pre class="programlisting">func addLevelLabel()
   {
       self.levelLabel.text = "Level: 1"
       self.levelLabel.fontSize = 30
       self.levelLabel.zPosition = 3
       self.levelLabel.position = CGPointMake(CGRectGetMidX(self.frame) + scoreText.frame.width , CGRectGetMidY(self.frame) + levelLabel.frame.height * 4.2)
       self.addChild(self.levelLabel)
   }

// ADDING LEVELS
   let levelLabel = SKLabelNode(fontNamed: "Chalkduster")
   var level = 1
addLevelLabel()</pre></div><p>In the preceding <a id="id469" class="indexterm"/>code, we are adding the <code class="literal">level</code> label using <code class="literal">SKLabelNode</code> and applying the font, <code class="literal">chalkduster</code>. The initial level is set to <code class="literal">1</code> and from there, it progresses.</p><p>This is how the game will look after adding the <code class="literal">label</code> to identify the <span class="strong"><strong>Level: l</strong></span>:</p><div class="mediaobject"><img src="graphics/4201_08_01.jpg" alt="Adding the Level label"/></div></div><div class="section" title="Adding levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec76"/>Adding levels</h2></div></div></div><p>As the game progresses, the<a id="id470" class="indexterm"/> difficulty level increases. Increase of the difficulty level can be done based on any number of factors; we can increment the level when a player crosses a specific number of blocks, or when the score reaches a certain limit, or when the time increases.</p><p>In our <span class="emphasis"><em>Platformer</em></span> game, we are going to increase difficulty levels based on the number of blocks crossed. As a game progresses, we are going to identify the need for a next level as shown as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Level 1</strong></span>: This level loads up at the start of the game</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Level 2</strong></span>: When the player jumps from the fifth block, we are going to start the second level</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Level 3</strong></span>: When the player jumps from the tenth block, we are going to start the third level</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Last level</strong></span>: When the player has jumped from 20 blocks, we are going to introduce the last level of the <span class="emphasis"><em>Platformer</em></span> game</li></ul></div><p>With every increase in level, we will also increase the difficulty of the game. In our game, we are going to increase ground speed, which will make the game more difficult to play.</p><p>The functionality to add levels is to be added in the <code class="literal">blockRunner</code> method in the <code class="literal">GameScene.swift</code> file. Following<a id="id471" class="indexterm"/> is the method with the functionality added:</p><div class="informalexample"><pre class="programlisting">func blockRunner()
   {
       // LOOP FOR THE DICTIONARY TO GET BLOCKS
       for(block, blockStatus) in self.blockStatuses
       {
           var thisBlock = self.childNodeWithName(block)!
           if blockStatus.shouldRunBlock()
           {
               blockStatus.timeGapForNextRun = random()
               blockStatus.currentInterval = 0
               blockStatus.isRunning = true
           }

           if blockStatus.isRunning
           {

               if thisBlock.position.x &gt; blockMaxX      // IF IT IS POSITIVE (KEEP MOVING BLOCKS FROM RIGHT TO LEFT)
               {
                   thisBlock.position.x -= CGFloat(self.groundSpeed)

               }
               else                                 // #1
               {
                   thisBlock.position.x = self.origBlockPositionX
                   blockStatus.isRunning = false
                   self.numberOfBlocksCrosssed += 1
                    self.levelLabel.text = "Level: \(String(self.level))"
                   if self.numberOfBlocksCrosssed == 5
                   {
                       self.level = level + 1
                       self.groundSpeed = self.groundSpeed + 7
                   }
                   else if self.numberOfBlocksCrosssed == 10
                   {
                       self.level = level + 1
                       self.groundSpeed = self.groundSpeed + 9
                   }
                   else if self.numberOfBlocksCrosssed == 20
                   {
                       self.level = level + 1
                       self.groundSpeed = self.groundSpeed + 12
                   }
                   else if self.numberOfBlocksCrosssed &gt; 20
                   {
                       println("Final Level")
                   }
               }
                      }
           else
           {
               blockStatus.currentInterval++
           }

       }

   }</pre></div><p>In the preceding code, inside the <code class="literal">else</code> statement marked <code class="literal">#1</code>, the code to increase the level is added. The code<a id="id472" class="indexterm"/> has a nested <code class="literal">if</code>, <code class="literal">else if</code> condition where we have checked the number of blocks crossed, and based on that, we have increased the level and the ground speed of the game.</p><p>There are four statements in the preceding code depicting the level and ground speed increase. The second level starts once the player crosses 5 blocks, and the ground speed also increases. Similarly, the level and ground speed increases after 10 and 20 blocks.</p><p>Now, we have successfully added the functionality to increase the level once a certain number of blocks are crossed.</p><p>Following is how the <span class="strong"><strong>Level: 2</strong></span> label will look when the player crosses five blocks:</p><div class="mediaobject"><img src="graphics/4201_08_04.jpg" alt="Adding levels"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>For games with a higher number of levels, it is advisable to make a separate file for the level logic code. For example, if we had 10 different levels in our game, then we too would <a id="id473" class="indexterm"/>have created a separate file.</p></div></div></div></div>
<div class="section" title="Adding the pause functionality"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Adding the pause functionality</h1></div></div></div><p>To pause a game during gameplay is an important functionality. Our game will benefit from the <code class="literal">pause</code>
<a id="id474" class="indexterm"/> functionality; it will allow the player to continue from where they left off previously.</p><p>Let's add the <code class="literal">pause</code> functionality:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Primarily, we'll create a <span class="strong"><strong>Play</strong></span>/<span class="strong"><strong>Pause</strong></span> button for <code class="literal">GameScene</code> and configure the position and image for the button. We will add the following lines of code inside the <code class="literal">GameScene.swift</code> class:<div class="informalexample"><pre class="programlisting">var pauseBtn:SKSpriteNode = SKSpriteNode(imageNamed: "PLAY-PAUSE")</pre></div></li><li class="listitem">Set the attributes of the <code class="literal">pauseBtn</code> label, such as <code class="literal">size</code>, <code class="literal">position</code>, and so on, as we did earlier for the other labels in the <code class="literal">addPlayPauseButton()</code> method. This is how it will look:<div class="informalexample"><pre class="programlisting">func addPlayPauseButton()
   {
       //self.runAction(sound)
       self.pauseBtn.name = "PAUSE"
       self.pauseBtn.zPosition = 3
       self.pauseBtn.position = CGPointMake(CGRectGetMaxX(self.frame) - pauseBtn.frame.width/2 , CGRectGetMaxY(self.frame) - pauseBtn.frame.height/2)
       self.addChild(pauseBtn)

   }</pre></div><p>Please make sure that you call it from the <code class="literal">didMoveToView()</code> method also.</p></li><li class="listitem">Now, we have<a id="id475" class="indexterm"/> to add the functionality to actually pause the game. We do this by adding the following code in the <code class="literal">touchesBegan()</code> method:<div class="informalexample"><pre class="programlisting">if self.pauseBtn.containsPoint(location)
           {
               if(self.view?.paused == false)
               {
                   println("Game Scene is Paused")
                   self.view?.paused = true

               }
               else
               {
                   println("Game Scene is Resumed")
                   self.view?.paused = false
               }
           }</pre></div><p>The preceding code will pause the game when the button is pressed, and if the button is pressed again, the game will be resumed.</p></li></ol></div><p>The following screenshot shows how the game will look after adding the <code class="literal">pause</code> functionality; a pause button appears in the top right corner of the screenshot:</p><div class="mediaobject"><img src="graphics/4201_08_02.jpg" alt="Adding the pause functionality"/><div class="caption"><p>Notice the pause button in the top right corner; tapping this button will pause the game.</p></div></div></div>
<div class="section" title="Adding the NODE MENU button"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Adding the NODE MENU button</h1></div></div></div><p>We have created a node menu scene that displays examples of the nodes in a game. We are now going to add a<a id="id476" class="indexterm"/> button on the main menu, which will allow users to access the node menu scene:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Firstly, we have to create an instance of <code class="literal">NodeMenuScene</code> in the beginning with the following line of code:<div class="informalexample"><pre class="programlisting">var nodeMenuSceneInstance : NodeMenuScene?</pre></div></li><li class="listitem">Now, we have to set attributes of the <span class="strong"><strong>NODE MENU</strong></span> button label, as we did for the <span class="strong"><strong>Level:</strong></span> label earlier. For this, add the following code in the <code class="literal">addNodeMenuSceneBtn()</code> method and call it from the <code class="literal">didMoveToView()</code> method also:<div class="informalexample"><pre class="programlisting">func addNodeMenuSceneBtn()
   {
       var backbutton = SKLabelNode(fontNamed: "Chalkduster")
       backbutton.fontColor = UIColor.cyanColor()
       backbutton.name = "NODEMENU"
       backbutton.text = "NODE MENU"
       backbutton.position = CGPointMake(CGRectGetMaxX(self.frame) - backbutton.frame.width/2 , CGRectGetMaxY(self.frame) - backbutton.frame.width/8)
       backbutton.zPosition = 3
       self.addChild(backbutton)
   }</pre></div></li><li class="listitem">Now, add the following code in the <code class="literal">touchesBegan()</code> method to move for the node menu scene with a tap of the <code class="literal">NODEMENU</code> button we have just created:<div class="informalexample"><pre class="programlisting">else if node.name == "NODEMENU"
           {
               goToNodeMenuScene()

           }</pre></div></li><li class="listitem">Create a transition<a id="id477" class="indexterm"/> from our present scene using the following code:<div class="informalexample"><pre class="programlisting">func goToNodeMenuScene()
   {
       let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
       nodeMenuSceneInstance = NodeMenuScene(size: self.size)
       nodeMenuSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
       self.view?.presentScene(nodeMenuSceneInstance , transition:transitionEffect)
   }</pre></div></li></ol></div><p>In the preceding code, we created the method, <code class="literal">goToNodeMenuScene()</code>, and added a transition effect for the scene to go from one to another with the effect of flipping horizontally.</p><p>The following screenshot shows how the main menu will look, after the button to the access node menu scene is created:</p><div class="mediaobject"><img src="graphics/4201_08_03.jpg" alt="Adding the NODE MENU button"/></div><p>When someone<a id="id478" class="indexterm"/> taps on the button, <span class="strong"><strong>NODE MENU</strong></span>, the node menu scene will open on the screen.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Summary</h1></div></div></div><p>In this chapter, we added difficulty levels in our <span class="emphasis"><em>Platformer</em></span> game. We updated our game by creating a level label and level increment functionality. An important feature, <span class="emphasis"><em>PAUSE</em></span>, is now provided. Also, we learned how to add a scene in our game by integrating node menu scene through the <span class="strong"><strong>NODE MENU</strong></span> button.</p><p>In the next chapter, we are going to discuss about performance enhancement techniques, along with some important extras that are going to be added in our <span class="emphasis"><em>Platformer</em></span> game.</p></div></body></html>