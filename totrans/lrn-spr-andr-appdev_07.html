<html><head></head><body>
        

                            
                    <h1 class="header-title">Concurrency</h1>
                
            
            
                
<p><strong>Concurrency</strong> is the ability of a program or algorithm to be divided into parts that can be executed out of order without affecting the results. This approach allows for parallel execution in a multi-core environment, which can significantly improve the performance. It's important to understand the difference between <em>concurrency</em> and <em>parallelism</em>. Parallelism assumes that a program is implemented in a concurrent way, but concurrency doesn't mean that the program is executed in parallel.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Coroutines</li>
<li>Sequential operations</li>
<li>Callback hell</li>
<li>Thread pools</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>To run the code in this chapter, you will need to integrate the <kbd>coroutines-core</kbd> library. To do this, you should add the following line to the <kbd>repositories</kbd> block of the <kbd>build.gradle</kbd> file:</p>
<pre>jcenter()</pre>
<p>You should also add the following line to the <kbd>dependencies</kbd> block:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.30.2'</pre>
<p>Add the following line to integrate the <kbd>kotlinx-coroutines-android</kbd> library:</p>
<pre>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:0.30.2'</pre>
<p class="mce-root"/>
<p>If you are using a Kotlin version lower than 1.3, you should also add the following lines to the <kbd>build.gradle</kbd> file:</p>
<pre>kotlin {<br/>    experimental {<br/>        coroutines "enable"<br/>    }<br/>}</pre>
<p>To integrate Spring for the Android library, you should add the following lines:</p>
<pre>implementation 'org.springframework.android:spring-android-rest-template:2.0.0.M3'<br/>implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.8.6'</pre>
<p>You should also add the <kbd>repositories</kbd> block, as follows:</p>
<pre>repositories {<br/>    maven {<br/>        url 'https://repo.spring.io/libs-milestone'<br/>    }<br/>}</pre>
<p>This chapter will also work with the <a href="https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-">JSON to Kotlin Class</a> plugin. To install this plugin, open the Preferences window and select the Plugins section.</p>
<p>Press the Install button and restart Android Studio.<br/>
<br/>
The source code for this chapter, with examples, is available on GitHub, at the following link: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coroutines</h1>
                
            
            
                
<p>A<strong> coroutine</strong> is a powerful feature of the Kotlin programming language. Its main objective is to allow for suspending a function while it waits for the result of another function that invokes a long-term operation. This feature allows us to write asynchronous code without callbacks in a sequential way.</p>
<p class="mce-root"/>
<p>This section will cover the following topics:</p>
<ul>
<li>Coroutine basics</li>
<li>Call stacks</li>
<li>Coroutine testing</li>
<li>Coroutine scope</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Coroutine basics</h1>
                
            
            
                
<p>If you are familiar with the concept of threads, you will know that each thread has its own call stack. We will cover the thread's call stack topic in the next section. The creation of a new thread is a complex operation that takes about two megabytes of memory. Coroutines use a thread pool under the hood, and only require the creation of several additional methods and classes. That is why you can consider coroutines as lightweight threads.</p>
<p>Let's imagine that we have a long-term operation, as shown in the following code:</p>
<pre>class Image<br/><br/>fun loadImage() : Image {<br/>    Thread.sleep(3000)<br/>    return Image()<br/>}</pre>
<p>The <kbd>loadImage</kbd> function takes three seconds and returns an instance of the <kbd>Image</kbd> class. We also have the <kbd>showImages</kbd> function that takes three instances of the <kbd>Image</kbd> class, and looks as follows:</p>
<pre>fun showImages(image1: Image, image2: Image, image3: Image) {<br/>    // .......<br/>}</pre>
<p>So, we have three independent tasks that can be executed in parallel. We can create three coroutines here, each of which will execute the <kbd>loadImage</kbd> function. To create a new coroutine, we can use one of the functions called a <strong>coroutine builder</strong>, such as <kbd>async</kbd> or <kbd>launch</kbd>:</p>
<pre>val subTask1 = GlobalScope.async { loadImage() }<br/>val subTask2 = GlobalScope.async { loadImage() }<br/>val subTask3 = GlobalScope.async { loadImage() }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>async</kbd> function returns an instance of <kbd>Deferred</kbd>. This class encapsulates a task that will return the result in the future. A <kbd>caller</kbd> function suspends when it invokes the <kbd>await</kbd> function of an instance of the <kbd>Deferred</kbd> class. This means that a thread that has a call stack with this function is not blocked, but is just suspended. The following snippet shows how this may look:</p>
<pre>showImages(subTask1.await(), subTask2.await(), subTask3.await())</pre>
<p>When we call the <kbd>await</kbd> function, we suspend invoking the current function. In addition, the <kbd>showImages</kbd> function will be called when all of the subtasks return the result.</p>
<p>The following diagram shows how these functions can be executed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e1ced344-a7f6-459e-8c71-1b78d8e748a0.png" style="width:42.17em;height:16.33em;"/></p>
<p>This diagram shows that three tasks can be executed almost in parallel, depending on whether the distribution of the load between cores and the <kbd>showImages</kbd> function is invoked when all three of the images are loaded.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Call stacks</h1>
                
            
            
                
<p>Each coroutine and thread has its own call stack. This means that a coroutine or a thread is created along with its call stack. A <strong>call stack</strong> contains something like blocks for each function that is invoked using a context of this thread or coroutine. This block represents a memory space that contains metadata, primitive local variables, and local references to objects in the heap. You can consider a call stack a part of the memory that is allocated for a thread or coroutine.</p>
<p>The following diagram shows how a <strong>Call stack</strong> looks when a thread or coroutine is created:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/773c3374-c203-4743-b6ec-0c93eae00e7d.png" style="width:13.58em;height:10.08em;"/></p>
<p>If the <kbd>main()</kbd> function invokes another function, a new block is added to the call stack. This looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/69a8993c-a7d7-4d62-a1ff-f1c0c4f4b654.png" style="width:13.67em;height:14.42em;"/></p>
<p>When the <kbd>loadImage</kbd> function returns a value to the <kbd>main</kbd> function, the block of the <kbd>loadImage</kbd> function is removed from the stack.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coroutine testing</h1>
                
            
            
                
<p>The <kbd>runBlocking</kbd> coroutine builder can be used for testing. This creates a coroutine that uses a current thread. The test within the JUnit framework may look as follows:</p>
<pre>class ExampleUnitTest {<br/><br/>    @Test<br/>    fun comicLoading() = runBlocking {<br/>        val image = async { loadImage() }.await()<br/>        assertNotNull(image)<br/>    }<br/>}</pre>
<p>This snippet loads an image using the <kbd>async</kbd> coroutine builder, and checks that the <kbd>image</kbd> is not null. The source code of the <kbd>runBlocking</kbd> function looks as follows:</p>
<pre>@Throws(InterruptedException::class)<br/>public fun &lt;T&gt; runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -&gt; T): T {<br/>    val currentThread = Thread.currentThread()<br/>    val contextInterceptor = context[ContinuationInterceptor]<br/>    val privateEventLoop = contextInterceptor == null // create private event loop if no dispatcher is specified<br/>    val eventLoop = if (privateEventLoop) BlockingEventLoop(currentThread) else contextInterceptor as? EventLoop<br/>    val newContext = GlobalScope.newCoroutineContext(<br/>        if (privateEventLoop) context + (eventLoop as ContinuationInterceptor) else context<br/>    )<br/>    val coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop, privateEventLoop)<br/>    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)<br/>    return coroutine.joinBlocking()<br/>}</pre>
<p>As you can see, the <kbd>runBlocking</kbd> coroutine builder uses the <kbd>currentThread</kbd> function to obtain an instance of the <kbd>Thread</kbd> class. When you run this test, you will see the following window:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5d9cb3cd-6dd4-4904-a018-691dcfe118e8.png"/></p>
<p>This window shows that the test has passed successfully.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coroutine scope</h1>
                
            
            
                
<p>With the release of version 0.26.0 of coroutines, a new, important feature was introduced—coroutine scope. All of the coroutine builders from the <kbd>coroutines-core</kbd> library are extension functions of the <kbd>CoroutineScope</kbd> interface.</p>
<p>The <kbd>CoroutineScope</kbd> interface looks as follows:</p>
<pre>public interface CoroutineScope {<br/>   <br/>    @Deprecated(level = DeprecationLevel.HIDDEN, message = "Deprecated in favor of top-level extension property")<br/>    public val isActive: Boolean<br/>        get() = coroutineContext[Job]?.isActive ?: true<br/><br/>    public val coroutineContext: CoroutineContext<br/>}</pre>
<p>We need the coroutine scope to provide a proper cancellation mechanism for the coroutines that we launch in our application. Modern frameworks, such as Android SDK or React Native, are built in such a way that all components, and the application itself, have a life cycle. In Android SDK, this can be an activity or a fragment, and in React Native, it can be a component.</p>
<p>The coroutine scope represents a scope of an object that has a life cycle, such as an activity or a component. The <kbd>coroutines-core</kbd> library provides a scope for an entire application, and we can use it if we want to launch a coroutine that works as long as an application runs. The scope of the entire application is represented by the <kbd>GlobalScope</kbd> object, and looks as follows:</p>
<pre>object GlobalScope : CoroutineScope {<br/>   <br/>    @Deprecated(level = DeprecationLevel.HIDDEN, message = "Deprecated in favor of top-level extension property")<br/>    override val isActive: Boolean<br/>        get() = true<br/><br/>    override val coroutineContext: CoroutineContext<br/>        get() = EmptyCoroutineContext<br/>}</pre>
<p>Let's create a new activity with its own coroutine scope. The easiest way to do this is to call the context menu of a package and choose the New section, which looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5d113bb9-4172-43f7-bfcb-4d51ded36812.png" style="width:14.17em;height:45.17em;"/></p>
<p>Then, choose the Empty Activity option in the Activity subsection, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ecbe43be-f3ac-4252-9288-2ffb8221f3f1.png" style="width:23.17em;height:19.67em;"/></p>
<p>Android Studio will open the Configure Activity window, where you can change a configuration of Activity and press the Finish button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b2b48a4f-65d3-424e-9985-5b29100b93db.png" style="width:35.83em;height:30.17em;"/></p>
<p class="mce-root"/>
<p>A newly created <kbd>XKCDActivity</kbd> class will look as follows:</p>
<pre>class XKCDActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_xkcd)<br/>    }<br/>}</pre>
<p>If we want to launch a life cycle aware coroutine from this class, we should implement the <kbd>CoroutineScope</kbd> interface, as follows:</p>
<pre>class XKCDActivity : AppCompatActivity(), CoroutineScope {<br/>    override val coroutineContext: CoroutineContext<br/>        get() = Dispatchers.Main<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_xkcd)<br/>    }<br/>}</pre>
<p>The <kbd>CoroutineScope</kbd> interface looks as follows:</p>
<pre>public interface CoroutineScope {<br/>  <br/>    @Deprecated(level = DeprecationLevel.HIDDEN, message = "Deprecated in favor of top-level extension property")<br/>    public val isActive: Boolean<br/>        get() = coroutineContext[Job]?.isActive ?: true<br/><br/>    public val coroutineContext: CoroutineContext<br/>}</pre>
<p>The <kbd>XKCDActivity</kbd> class implements the <kbd>CoroutineScope</kbd> interface and overrides the <kbd>coroutineContext</kbd> property. The overridden <kbd>coroutineContext</kbd> property contains a getter that returns <kbd>Dispatchers.Main</kbd>.</p>
<p>The <kbd>Dispatchers</kbd> is an object from the <kbd>coroutines-core</kbd> library, which contains the following dispatchers:</p>
<ul>
<li><kbd>Default</kbd> is used by all standard coroutine builders, such as <kbd>launch</kbd> or <kbd>async</kbd></li>
<li><kbd>Main</kbd> is used to run a coroutine on the main thread</li>
<li><kbd>Unconfident</kbd> invokes a coroutine immediately, on the first available thread</li>
<li><kbd>IO</kbd> is used to run coroutines that perform input/output operations</li>
</ul>
<p class="mce-root"/>
<p>Since a getter of the overridden <kbd>coroutineContext</kbd> property returns the <kbd>Main</kbd> dispatcher, all coroutine builders from this class will launch coroutines that work on the main thread.</p>
<p>The <kbd>XKCDActivity</kbd> has its own coroutine scope, but it is not life cycle aware. This means that a coroutine launched in a scope of this activity will not be destroyed if the activity is destroyed. We can fix this in the following way:</p>
<pre>class XKCDActivity : AppCompatActivity(), CoroutineScope {<br/>    private lateinit var lifecycleAwareJob: Job<br/>    override val coroutineContext: CoroutineContext<br/>        get() = Dispatchers.Main + lifecycleAwareJob<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_xkcd)<br/>        lifecycleAwareJob = Job()<br/>    }<br/><br/>    override fun onDestroy() {<br/>        super.onDestroy()<br/>        lifecycleAwareJob.cancel()<br/>    }<br/>}</pre>
<p>The <kbd>lifecycleAwareJob</kbd> will be used as a parent for all coroutines, and will cancel all child coroutines when an activity is destroyed. The following example code shows how to use this approach:</p>
<pre>override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.activity_xkcd)<br/>    lifecycleAwareJob = Job()<br/>    launch {<br/>        val image = async(Dispatchers.IO) { loadImage() }.await()<br/>        showImage(image)<br/>    }<br/>}</pre>
<p>The launch coroutine builder creates a coroutine that works on the main thread, and the async coroutine builder creates a coroutine that works on the input/output thread. When the <kbd>image</kbd> is ready, it will be shown on the main thread of the application. If we press the back button, the coroutines will be destroyed, along with <kbd>XKCDActivity</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Channels</h1>
                
            
            
                
<p>The <kbd>async</kbd> function returns an instance of the <kbd>Deferred</kbd> class that allows us to compute a single value. If we need to transfer a sequence of values between coroutines, we can use channels.</p>
<p>A channel is an interface that looks as follows:</p>
<pre>public interface Channel&lt;E&gt; : SendChannel&lt;E&gt;, ReceiveChannel&lt;E&gt; {<br/>    //.....<br/>}</pre>
<p>The <kbd>SendChannel</kbd> interface looks as follows:</p>
<pre>public interface SendChannel&lt;in E&gt; {<br/>  <br/>    @ExperimentalCoroutinesApi<br/>    public val isClosedForSend: Boolean<br/>    <br/>    @ExperimentalCoroutinesApi<br/>    public val isFull: Boolean<br/>    <br/>    public suspend fun send(element: E)<br/>    <br/>    public val onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;<br/>    <br/>    public fun offer(element: E): Boolean<br/>    <br/>    public fun close(cause: Throwable? = null): Boolean<br/>    <br/>    @ExperimentalCoroutinesApi<br/>    public fun invokeOnClose(handler: (cause: Throwable?) -&gt; Unit)<br/>}</pre>
<p>The <kbd>SendChannel</kbd> interface contains the <kbd>send</kbd> method that takes a parameter and adds it to this channel. The <kbd>isFull</kbd> property is <kbd>true</kbd> if this channel already contains a value. In this case, the <kbd>send</kbd> function suspends the caller until the contained value is not consumed.</p>
<p>A channel can be closed by invoking the <kbd>close</kbd> method. In this case, the <kbd>isClosedForSend</kbd> property is <kbd>true</kbd>, and the <kbd>send</kbd> method throws an exception.</p>
<p>While the <kbd>SendChannel</kbd> interface allows us to put a value into a channel, the <kbd>ReceiveChannel</kbd> interface allows us to get the value from the channel. The <kbd>ReceiveChannel</kbd> interface looks as follows:</p>
<pre>public interface ReceiveChannel&lt;out E&gt; {<br/><br/>    @ExperimentalCoroutinesApi<br/>    public val isClosedForReceive: Boolean<br/>    <br/>    @ExperimentalCoroutinesApi<br/>    public val isEmpty: Boolean<br/>    <br/>    public suspend fun receive(): E<br/>    <br/>    public val onReceive: SelectClause1&lt;E&gt;<br/>    <br/>    @ExperimentalCoroutinesApi<br/>    public suspend fun receiveOrNull(): E?<br/><br/>    @ExperimentalCoroutinesApi<br/>    public val onReceiveOrNull: SelectClause1&lt;E?&gt;<br/>    <br/>    public fun poll(): E?<br/>    <br/>    public operator fun iterator(): ChannelIterator&lt;E&gt;<br/>    <br/>    public fun cancel(): Boolean<br/>    <br/>    @ExperimentalCoroutinesApi<br/>    public fun cancel(cause: Throwable? = null): Boolean<br/>}</pre>
<p>The <kbd>receiveOrNull()</kbd> method returns and removes an element from this channel, or returns null if the <kbd>isClosedForReceive</kbd> property is <kbd>true</kbd>. The <kbd>ReceiveChannel</kbd> contains the <kbd>iterator</kbd> method, and can be used in the <kbd>for</kbd> loop.</p>
<p>Let's look at the following example code:</p>
<pre>fun channelBasics() = runBlocking&lt;Unit&gt; {<br/>    val channel = Channel&lt;Int&gt;()<br/>    launch {<br/>        println("send 0 ${Date().toGMTString()}")<br/>        channel.send(0)<br/>        delay(1000)<br/>        println("send 1 ${Date().toGMTString()}")<br/>        channel.send(1)<br/>    }<br/>    delay(3000)<br/>    val theFirstElement = channel.receive()<br/>    println("receive $theFirstElement ${Date().toGMTString()}")<br/>    delay(4000)<br/>    val theSecondElement = channel.receive()<br/>    println("receive $theSecondElement ${Date().toGMTString()}")<br/>}</pre>
<p>In the preceding example, we sent two values by a channel and received those values. We also used the <kbd>delay</kbd> function to show that an operation takes some time.</p>
<p>The output looks as follows:</p>
<pre>send 0 21 Oct 2018 13:30:12 GMT<br/> receive 0 21 Oct 2018 13:30:15 GMT<br/> send 1 21 Oct 2018 13:30:16 GMT<br/> receive 1 21 Oct 2018 13:30:19 GMT</pre>
<p>This output shows that the <kbd>send</kbd> function suspends a coroutine until a value is consumed.</p>
<p class="mce-root"/>
<p>We can use the <kbd>for</kbd> loop to receive values from a channel, as follows:</p>
<pre>fun channelIterator() = runBlocking&lt;Unit&gt; {<br/>    val channel = Channel&lt;Int&gt;()<br/>    launch {<br/>        (0..5).forEach {<br/>            channel.send(it)<br/>        }<br/>    }<br/>    for (value in channel) {<br/>        println(value)<br/>    }<br/>}</pre>
<p>The output looks as follows:</p>
<pre> 0<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The producer function</h1>
                
            
            
                
<p>The <kbd>producer</kbd> function is called a <strong>channel builder</strong>, and it returns an instance of the <kbd>ReceiveChannel</kbd> class. This function looks as follows:</p>
<pre>@ExperimentalCoroutinesApi<br/>public fun &lt;E&gt; CoroutineScope.produce(<br/>    context: CoroutineContext = EmptyCoroutineContext,<br/>    capacity: Int = 0,<br/>    block: suspend ProducerScope&lt;E&gt;.() -&gt; Unit<br/>): ReceiveChannel&lt;E&gt; {<br/>    val channel = Channel&lt;E&gt;(capacity)<br/>    val newContext = newCoroutineContext(context)<br/>    val coroutine = ProducerCoroutine(newContext, channel)<br/>    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)<br/>    return coroutine<br/>}</pre>
<p>As you can see in the preceding snippet, the <kbd>produce</kbd> function contains a receiver parameter of the <kbd>ProducerScope</kbd> type. The <kbd>ProducerScope</kbd> interface looks as follows:</p>
<pre>public interface ProducerScope&lt;in E&gt; : CoroutineScope, SendChannel&lt;E&gt; {<br/>    val channel: SendChannel&lt;E&gt;<br/>}</pre>
<p>As you can see, the <kbd>ProducerScope</kbd> interface extends the <kbd>SendChannel</kbd> interface. This means that we can use the <kbd>send</kbd> method inside a lambda that we pass to the <kbd>producer</kbd> function.</p>
<p>An example of using the  <kbd>producer</kbd> function may look as follows:</p>
<pre>suspend fun numbersProduce(): ReceiveChannel&lt;Int&gt; = GlobalScope.produce {<br/>    launch {<br/>        (0..10).forEach {<br/>            send(it)<br/>        }<br/>    }<br/>}</pre>
<p>We can use the <kbd>numbersProduce</kbd> function in the following way:</p>
<pre>fun producerExample() = runBlocking&lt;Unit&gt; {<br/>    val numbers = numbersProduce()<br/>    for (value in numbers) {<br/>        println(value)<br/>    }<br/>}<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The actor function</h1>
                
            
            
                
<p>The <kbd>actor</kbd> function contains a receiver parameter of the <kbd>ActorScope</kbd> type. The source code of the <kbd>actor</kbd> function looks as follows:</p>
<pre>public fun &lt;E&gt; CoroutineScope.actor(<br/>    context: CoroutineContext = EmptyCoroutineContext,<br/>    capacity: Int = 0,<br/>    start: CoroutineStart = CoroutineStart.DEFAULT,<br/>    onCompletion: CompletionHandler? = null,<br/>    block: suspend ActorScope&lt;E&gt;.() -&gt; Unit<br/>): SendChannel&lt;E&gt; {<br/>    val newContext = newCoroutineContext(context)<br/>    val channel = Channel&lt;E&gt;(capacity)<br/>    val coroutine = if (start.isLazy)<br/>        LazyActorCoroutine(newContext, channel, block) else<br/>        ActorCoroutine(newContext, channel, active = true)<br/>    if (onCompletion != null) coroutine.invokeOnCompletion(handler = onCompletion)<br/>    coroutine.start(start, coroutine, block)<br/>    return coroutine<br/>}</pre>
<p class="mce-root"/>
<p>The <kbd>ActorScope</kbd> interface looks similar to the <kbd>ProducerScope</kbd> interface, but implements the <kbd>ReceiveChannel</kbd> interface:</p>
<pre>public interface ActorScope&lt;E&gt; : CoroutineScope, ReceiveChannel&lt;E&gt; {<br/>    val channel: Channel&lt;E&gt;<br/>}</pre>
<p>As you probably know, it is not a good idea to access mutable data from different coroutines. To deal with this, we can use channels and the <kbd>actor</kbd> function, in the following way:</p>
<pre>suspend fun numberConsumer() = GlobalScope.actor&lt;Int&gt; {<br/>    var counter = 0<br/>    for (value in channel) {<br/>        counter += value<br/>        println(counter)<br/>    }<br/>}</pre>
<p>The preceding snippet contains a mutable variable named <kbd>counter</kbd>. We change the value of the <kbd>counter</kbd> variable when a channel receives a new value. Since a channel suspends the caller until a consumer finishes processing the current value, we can be sure that the <kbd>counter</kbd> variable will be modified in the right way.</p>
<p>The <kbd>numbersCounter</kbd> function can be used as follows:</p>
<pre>@Test<br/>fun actorExample() = runBlocking&lt;Unit&gt; {<br/>    val actor = numberConsumer()<br/>    (0..10).forEach {<br/>        launch {<br/>            actor.send(it)<br/>        }<br/>    }<br/>}</pre>
<p>The preceding snippet launches ten coroutines that send a value to an actor in parallel.</p>
<p class="mce-root">The output looks as follows:</p>
<pre> 0<br/> 1<br/> 3<br/> 6<br/> 10<br/> 15<br/> 21<br/> 28<br/> 36<br/> 45<br/> 55</pre>
<p>The output shows that the <kbd>counter</kbd> variable is modified in the right way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sequential operations</h1>
                
            
            
                
<p>One of the most important benefits of the coroutines approach is a guarantee that functions are invoked in the same order in which they are written. The order of the operations is a very important nuance when we execute concurrent code in a multithreaded environment. </p>
<p>Let's imagine that we have to load a user's details, using the following function:</p>
<pre>suspend fun loadUserDetails(): User {<br/>    delay(3000)<br/>    return User(0, "avatar")<br/>}</pre>
<p>The <kbd>loadUserDetails</kbd> function invokes the <kbd>delay</kbd> function from the <kbd>coroutines-core</kbd> library and returns an instance of the <kbd>User</kbd> class. The <kbd>delay</kbd> function suspends the invocation of the current coroutine. When a user is ready, we have to pass a value of the <kbd>avatar</kbd> property to the <kbd>loadImage</kbd> function:</p>
<pre>suspend fun loadImage(avatar: String): Image {<br/>    delay(3000)<br/>    return Image()<br/>}</pre>
<p>The <kbd>loadImage</kbd> function also invokes the <kbd>delay</kbd> function, and returns an instance of the <kbd>Image</kbd> class. We should then pass the received instance of the <kbd>Image</kbd> class to the <kbd>showImage</kbd> function.</p>
<p>The following code shows how to execute these functions sequentially, using coroutines:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>    val user = async { loadUserDetails() }.await()<br/>    val image = async { loadImage(user.avatar) }.await()<br/>    showImage(image)<br/>}</pre>
<p class="mce-root"/>
<p>The preceding snippet invokes all three functions that use different coroutines, sequentially. The following diagram shows a sequence of functions invoking:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/59bdd6ea-201a-4037-b020-8cd4eb7b0f1c.png" style="width:42.92em;height:18.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Callback hell</h1>
                
            
            
                
<p>One of the main reasons that you should use coroutines is to avoid callback hell.</p>
<p>This section will cover the following topics:</p>
<ul>
<li>What is a callback?</li>
<li>Wrapping callbacks</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a callback?</h1>
                
            
            
                
<p>A <strong>callback</strong> is a pattern that is used to retrieve the results of an asynchronous task. This approach assumes that we pass a reference to a function that should be invoked when an asynchronous operation is done. </p>
<p>By <em>synchronous operations</em>, we mean that the tasks are executed one after another. The asynchronous approach assumes that several tasks can be performed in parallel. </p>
<p class="mce-root"/>
<p>The <kbd>loadImage</kbd> function in the following example code uses a callback to return the result:</p>
<pre>fun loadImage(callback: (Image) -&gt; Unit) {<br/>    executor.submit {<br/>        Thread.sleep(3000)<br/>        callback(Image())<br/>    }<br/>}</pre>
<p>The preceding code snippet shows the simplest example of how to create an asynchronous function that returns the results using the callback. In our case, the callback is a lambda that takes an instance of the <kbd>Image</kbd> class and returns <kbd>Unit</kbd>. The following diagram shows how this sequence works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/acb5e395-a5e2-4e4d-9d5b-8870aa6d5e9b.png" style="width:31.33em;height:25.42em;"/></p>
<p>This function can be used as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    loadImage { image -&gt;<br/>        showImage(image)<br/>    }<br/>}</pre>
<p>The preceding snippet shows that it is easy to use a callback to deal with asynchronous code. We just implement and pass a lambda that is invoked when an image is ready.</p>
<p>The following diagram shows how to implement this approach:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/038b56be-f66c-423a-b5e8-b1382b5b4889.png" style="width:42.67em;height:23.17em;"/></p>
<p>Let's imagine that we are requesting a list of users from the server. After that, we send another request to get detailed information about a user, and then, we load an avatar. In code, this may look as follows:</p>
<pre>fun loadListOfFriends(callback: (List&lt;ShortUser&gt;) -&gt; Unit) {<br/>    executor.submit {<br/>        Thread.sleep(3000)<br/>        callback(listOf(ShortUser(0), ShortUser(1)))<br/>    }<br/>}</pre>
<p>The <kbd>loadListOfFriends</kbd> function takes a lambda that takes a list of instances of the <kbd>ShortUser</kbd> class, as follows:</p>
<pre>fun loadUserDetails(id: Int, callback: (User) -&gt; Unit) {<br/>    executor.submit {<br/>        Thread.sleep(3000)<br/>        callback(User(id, "avatar"))<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>The <kbd>loadUserDetails</kbd> function takes a lambda and an identifier of a user, as follows:</p>
<pre>fun loadImage(avatar: String, callback: (Image) -&gt; Unit) {<br/>    executor.submit {<br/>        Thread.sleep(3000)<br/>        callback(Image())<br/>    }<br/>}<br/></pre>
<p>The <kbd>loadImage</kbd> function takes a path to the avatar and lambda. The following example code demonstrates the most common problem that occurs when we use an approach with callbacks. We encounter the problem of code complexity and readability when concurrent tasks have to pass data to each other:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    loadListOfFriends {users -&gt;<br/>        loadUserDetails(users.first().id) {user -&gt;<br/>            loadImage(user.avatar) {image -&gt;<br/>                showImage(image)<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The preceding snippet demonstrates what callback hell is. We have a lot of nested functions, and it is hard to maintain this code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread pools</h1>
                
            
            
                
<p>The creation of a new thread is a complex operation that takes up a lot of resources. In the <em>Call stacks</em> section, we covered how memory is allocated for a new thread. When the lower block of a function is removed from a stack, the thread is destroyed. To avoid constantly creating new threads, we can use thread pools. There is no logic in creating a new thread for invoking each short-term operation, because this operation and switching the program flow to a created context can take more time than executing the task itself. The thread-pool pattern assumes a class that contains a set of threads that are waiting for a new task, and a queue that holds the tasks.</p>
<p>The following diagram shows how this works:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/db9a7a3b-2431-4f93-800b-8fa72ef48a5c.png" style="width:38.08em;height:18.33em;"/></p>
<p>The preceding diagram shows that a pool contains a queue that holds tasks submitted by producers. The threads from the pool take tasks from the queue and execute them.</p>
<p>Coroutines use thread pools under the hood. The <kbd>java.util.concurrent</kbd> package provides the functionality to create your own thread pools. The <kbd>Executers</kbd> class contains a lot of static factory functions to create a pool, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/effab500-87c7-40bb-a20d-81aadad70026.png"/><br/></p>
<p>The following example code demonstrates how to create and use a single-threaded executor:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val executor = Executors.newSingleThreadExecutor()<br/>    executor.submit { loadImage() }<br/>    executor.submit { loadImage() }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the preceding snippet, we instantiated the <kbd>executor</kbd> variable and used the <kbd>submit</kbd> method to add a task to the queue.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at concurrency and the problems that can arise in a multithreaded environment. We introduced and looked at the most common examples of coroutine usage. We also familiarized ourselves with patterns, such as thread pools and callbacks, and how to use them. Furthermore, we covered synchronous and asynchronous programming, and the problems related to these topics.</p>
<p>In the next chapter, we will look at an overview of reactive programming, which is useful when we want to process asynchronous actions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<div><ul>
<li>What is a call stack?</li>
<li>What is a thread pool?</li>
<li>What is a callback?</li>
<li>Why are coroutines called lightweight threads?</li>
</ul>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p><em>Mastering High Performance with Kotlin</em> (<a href="https://www.packtpub.com/application-development/mastering-high-performance-kotlin">https://www.packtpub.com/application-development/mastering-high-performance-kotlin</a>) by Igor Kucherenko, published by Packt Publishing.</p>


            

            
        
    </body></html>