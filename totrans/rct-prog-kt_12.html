<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Reactive Kotlin and Android</h1>
                </header>
            
            <article>
                
<p>So, our learning about reactive programming in Kotlin is almost complete. We have arrived at the last, but probably the most important, chapter of this book. Android is probably the biggest platform for Kotlin. During the last Google IO—Google IO 17, Google announced official support for Kotlin and added Kotlin as a first-class citizen of the Android application development. Kotlin is now the only officially supported Android application development language other than Java.</p>
<p>Reactive programming is already there in Android—most of the top libraries in Android support reactiveness. So, it is quite obvious that in a book titled <em>Reactive Programming in Kotlin</em>, we must cover Android as well.</p>
<p>Teaching you Android development from scratch is beyond the scope of this book, as it's a vast topic. You can find many books out there if you would like to learn Android development from scratch. This book assumes you have some basic knowledge in Android application development and can work with <kbd>RecyclerView</kbd>, <kbd>Adapter</kbd>, <kbd>Activity</kbd>, Fragment, CardView, AsyncTask, and more. If you are not familiar with any of the topics mentioned, you can read <em>Expert Android Programming</em> by <em>Prajyot Mainkar</em>.</p>
<p>So, are you wondering what this chapter has for you? Take a look at the following list of the topics we will cover:</p>
<ul>
<li>Setting up Kotlin in Android Studio 2.3.3 and 3.0</li>
<li>Getting started with <kbd>ToDoApp</kbd> in Android and Kotlin</li>
<li>API calls with Retrofit 2</li>
<li>Setting up RxAndroid and RxKotlin</li>
<li>Using RxKotlin with Retrofit 2</li>
<li>Developing our app</li>
<li>A brief introduction to RxBinding</li>
</ul>
<p>So, let's get started with setting up Kotlin in Android Studio.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Kotlin in Android Studio</h1>
                </header>
            
            <article>
                
<p>We strongly encourage you to use Android Studio 3.0 for Android development, irrespective of whether you're using Kotlin or not. Android Studio 3.0 is the latest version of Android Studio, with a lot of bug fixes, new features, and improved Gradle build time.</p>
<p>For Android Studio 3.0, you don't need to do any setup to use Kotlin for Android development. You just need to select <span class="packt_screen">Include Kotlin support</span> while creating a new project. Here is a screenshot for your reference:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/522fe92a-f72c-4e55-a816-7b254c3fed99.jpg"/></div>
<p>We've highlighted the <span class="packt_screen">Include Kotlin support</span> section of the Android Studio—<span class="packt_screen">Create Android Project</span> dialog.</p>
<p>However, if you're using Android Studio 2.3.3, then follow these steps:</p>
<ol>
<li>Go to <span class="packt_screen">Android Studio</span> | <span class="packt_screen">Settings</span> | <span class="packt_screen">Plugins</span>.</li>
<li>Search for <kbd>Kotlin</kbd> (take a look at the following screenshot) and install that plugin as follows:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;color: black;font-size: 1em" src="assets/deb76a4a-bd0c-427a-afd6-19311956e6b4.jpg"/></div>
<ol start="3">
<li>Start a new Android project.</li>
<li>To apply the Kotlin plugin to the project, open the project level <kbd>build.gradle</kbd> and modify the content, as shown here:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="text-align: center;color: black;font-size: 1em" src="assets/68e6de34-8c0a-43a0-8f44-b674e9e0a53d.jpg"/></div>
<ol start="5">
<li>Open the <kbd>build.gradle</kbd> in your module (or we might say, app level <kbd>build.gradle</kbd>) and add the following <kbd>dependencies</kbd>:</li>
</ol>
<pre>      compile "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version" </pre>
<p>You are now all set to start writing Kotlin code in Android Studio.</p>
<p>However, before starting with the Kotlin code, let's first review our <kbd>build.gradle</kbd>. The preceding code that I showed for Android Studio 2.3.3 is valid for Android Studio 3.0 as well, you just don't have to manually add this as Android Studio 3.0 automatically adds it for you. However, what is the purpose of those lines? Let's inspect them.</p>
<p>In the project level <kbd>build.gradle</kbd> file, the <kbd>ext.kotlin_version = "1.1.51"</kbd> line creates a variable in Gradle with the name of <kbd>kotlin_version</kbd>; this variable will hold a <kbd>String</kbd> value, <kbd>1.1.51</kbd> (which is the latest version of Kotlin at the time of writing this book). We are writing this in a variable, as this version is required in a number of places in the project level and app level <kbd>build.gradle</kbd> file. If we declare it once and use it in multiple places, then there will be consistency, and there won't be any chance for human mistakes.</p>
<p>Then, on the same file (project level <kbd>build.gradle</kbd>), we will add <kbd>classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</kbd>. This will define a classpath used by Gradle to search for <kbd>kotlin-jre</kbd> when we add them as a dependency.</p>
<p>Inside the app level <kbd>build.gradle</kbd> file, we will write <kbd>implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"</kbd>.</p>
<p>So, let's get started with the Kotlin code. As we mentioned in the previous chapter, we will create a <kbd>ToDoApp</kbd>. There will be three screens, one for the <kbd>ToDo List</kbd>, one to create a <kbd>ToDo</kbd>, and one to edit/delete <kbd>ToDo</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with ToDoApp on Android</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, we are using Android Studio 3.0 (stable) for this project. The following screenshot depicts the project structure that we're using:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="412" width="304" src="assets/71882bb0-c011-4d63-b1db-f39e50862a2e.jpg"/></div>
<p>In this project, we are using package-by features, and I do prefer to use package-by for Android development, mainly for its scalability and maintainability. Also, note that it is best practice to use package-by feature in Android; although, you can obviously use your preferred model. You can read more about the package-by feature at <a href="https://hackernoon.com/package-by-features-not-layers-2d076df1964d"><span class="URLPACKT">https://hackernoon.com/package-by-features-not-layers-2d076df1964d</span></a>.</p>
<p>Now, let's understand the package structure used in this application. The root package here is <kbd>com.rivuchk.todoapplication</kbd>, the package for the application, identical with the <kbd>applicationId</kbd>. The root package contains two classes—<kbd>ToDoApp</kbd> and <kbd>BaseActivity</kbd>. The <kbd>ToDoApp</kbd> class extends <kbd>android.app.Application</kbd> so that we can have our own implementation of the <kbd>Application</kbd> class. Now, what is <kbd>BaseActivity</kbd>? <kbd>BaseActivity</kbd> is an abstract class created within this project, and all activities in this project should extend <kbd>BaseActivity</kbd>; so, if we want to implement something throughout all the activities in this project, we can write the code in <kbd>BaseActivity</kbd> and rest assured that all activities will now implement the same.</p>
<p>Next, we have an <kbd>apis</kbd> package for the classes and files related to the API calls (we will use Retrofit) and <kbd>datamodels</kbd> for models (POJO) classes.</p>
<p>We have the <kbd>Utils</kbd> package for <kbd>CommonFunctions</kbd> and <kbd>Constants</kbd> (a singleton <kbd>Object</kbd> to hold constant variables such as <kbd>BASE_URL</kbd> and others).</p>
<p>The <kbd>addtodo</kbd>, <kbd>tododetails</kbd>, and <kbd>todolist</kbd> are three feature-based packages. The <kbd>todolist</kbd> package contains <kbd>Activity</kbd> and <kbd>Adapter</kbd> for displaying the list of todos. The <kbd>tododetails</kbd> package contains the <kbd>Activity</kbd> responsible to display the details of todo. We will use the same <kbd>Activity</kbd> to edit as well. The <kbd>addtodo</kbd> package holds the <kbd>Activity</kbd> that will be used to accomplish the functionality of adding a todo.</p>
<p>Before starting with the activities and layouts, I want you to take a look inside <kbd>BaseActivity</kbd> and <kbd>ToDoApp</kbd>, so here is the code inside the <kbd>ToDoApp.kt</kbd> file:</p>
<pre>    class ToDoApp:Application() { 
      override fun onCreate() { 
        super.onCreate() 
        instance = this 
      } 
 
      companion object { 
        var instance:ToDoApp? = null 
      } 
    } </pre>
<p>A small class indeed; it contains only a <kbd>companion object</kbd> to provide us with the instance. This class will grow as we move ahead with this chapter. We declared <kbd>ToDoApp</kbd> as the <kbd>application</kbd> class for this project in the manifest, as shown here:</p>
<pre>    &lt;application 
      android:allowBackup="true" 
      android:icon="@mipmap/ic_launcher" 
      android:label="@string/app_name" 
      android:roundIcon="@mipmap/ic_launcher_round" 
      android:supportsRtl="true" 
      android:theme="@style/AppTheme" 
<strong>      android:name=".ToDoApp"&gt;</strong> 
      .... 
    &lt;/application&gt; </pre>
<p>The <kbd>BaseActivity</kbd> is also now small. As with the <kbd>ToDoApp</kbd>, it'll also grow over the course of this chapter:</p>
<pre>    abstract class BaseActivity : AppCompatActivity() { 
 <strong>      final override fun onCreate(savedInstanceState: Bundle?) {</strong> 
        super.onCreate(savedInstanceState) 
        onCreateBaseActivity(savedInstanceState) 
       } 
<strong>      abstract fun onCreateBaseActivity(savedInstanceState: Bundle?)</strong> 
    } </pre>
<p>For now, <kbd>BaseActivity</kbd> only hides the <kbd>onCreate</kbd> method from the <kbd>Activity</kbd> class, and provides a new abstract method—<kbd>onCreateBaseActivity</kbd>. This class also mandates that we override <kbd>onCreateBaseActivity</kbd> in child classes so that if there's anything we need to implement inside the <kbd>onCreate</kbd> method, of all activities, we can do that inside the <kbd>onCreate</kbd> method of <kbd>BaseActivity</kbd>, and forget the rest.</p>
<p>So, let's get started with the <kbd>todolist</kbd>. This package contains all the sources required to display the list of todos. If you look at the previous screenshot carefully, you should notice that the package contains two classes—<kbd>TodoListActivity</kbd> and <kbd>ToDoAdapter</kbd>.</p>
<p>So, let's start with the design of <kbd>TodoListActivity</kbd>; when completed, this <kbd>Activity</kbd> should look like the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="450" width="254" src="assets/ae96f7fb-8770-4d9a-b0c0-0af6aac2131e.jpg"/></div>
<p>As the screenshot depicts, we will need a <kbd>FloatingActionButton</kbd> and a <kbd>RecyclerView</kbd> for this <kbd>Activity</kbd>, so here is the XML layout for this example—<kbd>activity_todo_list.xml</kbd>:</p>
<pre><span>    &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>    </span>&lt;android.support.design.widget.CoordinatorLayout <br/>      
      
      
     android:layout_width="match_parent" 
     android:layout_height="match_parent" 
     tools:context="com.rivuchk.todoapplication.<br/>     todolist.TodoListActivity"&gt; 
 
     &lt;android.support.design.widget.AppBarLayout 
       android:layout_width="match_parent" 
       android:layout_height="wrap_content" 
       android:theme="@style/AppTheme.AppBarOverlay"&gt; 
 
     &lt;android.support.v7.widget.Toolbar 
       android:id="@+id/toolbar" 
       android:layout_width="match_parent" 
       android:layout_height="?attr/actionBarSize" 
       android:background="?attr/colorPrimary" 
       app:popupTheme="@style/AppTheme.PopupOverlay" /&gt; 
 
     &lt;/android.support.design.widget.AppBarLayout&gt; 
 
<strong>     &lt;android.support.v7.widget.RecyclerView</strong><strong>       <br/>       android:id="@+id/rvToDoList"</strong> 
       android:layout_width="match_parent" 
       android:layout_height="match_parent" 
       app:layoutManager="LinearLayoutManager" 
       android:orientation="vertical" 
       app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt; 
 
<strong>     &lt;android.support.design.widget.FloatingActionButton</strong><strong>       <br/>       android:id="@+id/fabAddTodo"</strong> 
       android:layout_width="wrap_content" 
       android:layout_height="wrap_content" 
       android:layout_gravity="bottom|end" 
       android:layout_margin="@dimen/fab_margin" 
       app:srcCompat="@drawable/ic_add" /&gt; 
 
    &lt;/android.support.design.widget.CoordinatorLayout&gt; </pre>
<p>Take a look at the preceding layout. In the declaration of <kbd>RecyclerView</kbd>, we set <kbd>layoutManager</kbd> to <kbd>LinearLayoutManager</kbd> and orientation to vertical-all from the layout itself, so we would not need to worry about setting it inside the code.</p>
<p>We used a <kbd>FloatingActionButton</kbd> to add new todos. We also used <kbd>AppBarLayout</kbd> as an action bar.</p>
<p>It's time to move ahead and take a look inside the <kbd>onCreateBaseActivity</kbd> method of the <kbd>TodoListActivity</kbd>, as shown here:</p>
<pre>    lateinit var adapter: ToDoAdapter 
 
    private val INTENT_EDIT_TODO: Int = 100 
 
    private val INTENT_ADD_TODO: Int = 101 
 
    override fun onCreateBaseActivity(savedInstanceState: Bundle?) { 
      setContentView(R.layout.activity_todo_list) 
      setSupportActionBar(toolbar) 
 
      fabAddTodo.setOnClickListener { _ -&gt; 
         startActivityForResult(intentFor&lt;AddTodoActivity&gt;<br/>         (),INTENT_ADD_TODO) 
      } 
 
      adapter = ToDoAdapter(this,{ 
       todoItem-&gt; 
       startActivityForResult(intentFor&lt;TodoDetailsActivity&gt;<br/>       (Pair(Constants.INTENT_TODOITEM,todoItem)),INTENT_EDIT_TODO) 
      }) 
      rvToDoList.adapter = adapter 
 
      fetchTodoList() 
    } </pre>
<p>In the preceding program, we created an instance of <kbd>ToDoAdapter</kbd> to set it as the adapter of <kbd>rvToDoList</kbd>, the <kbd>RecyclerView</kbd> where we will display the list of todos. While creating the instance of <kbd>ToDoAdapter</kbd>, we passed a <kbd>lambda</kbd>; this <kbd>lambda</kbd> should be called when an item from the <kbd>rvToDoList</kbd> is clicked.</p>
<p>We also called a <kbd>fetchTodoList()</kbd>function at the end of the <kbd>onCreateBaseActivity</kbd> method. As the name indicates, it is responsible to fetch the todo list from the REST API. We will see the definition and go into the details of this method later, but, for now, let's take a look at <kbd>Adapter</kbd>:</p>
<pre>    class ToDoAdapter( 
<strong>      private val context:Context, //(1)</strong><strong>   <br/>      val onItemClick:(ToDoModel?)-&gt;Unit = {}//(2)</strong> 
      ):RecyclerView.Adapter&lt;ToDoAdapter.ToDoViewHolder&gt;() { 
<strong>      private val inflater:LayoutInflater =  <br/>      LayoutInflater.from(context)//(3)</strong><strong>    private val   <br/>      todoList:ArrayList&lt;ToDoModel&gt; = arrayListOf()//(4)</strong><strong>    fun<br/>      setDataset(list:List&lt;ToDoModel&gt;) {//(5)</strong> 
        todoList.clear() 
        todoList.addAll(list) 
        notifyDataSetChanged() 
      } 
   
      override fun getItemCount(): Int = todoList.size 
 
      override fun onBindViewHolder(holder: ToDoViewHolder?,<br/>      position: Int) { 
        holder?.bindView(todoList[position]) 
      } 
 
      override fun onCreateViewHolder<br/>      (parent: ViewGroup?, viewType: Int): ToDoViewHolder { 
        return ToDoViewHolder<br/>        (inflater.inflate(R.layout.item_todo,parent,false)) 
      } 
 
      inner class ToDoViewHolder(itemView:View):<br/>      RecyclerView.ViewHolder(itemView) { 
        fun bindView(todoItem:ToDoModel?) { 
<strong>          with(itemView) {//(6)</strong> 
             txtID.text = todoItem?.id?.toString() 
             txtDesc.text = todoItem?.todoDescription 
             txtStatus.text = todoItem?.status 
             txtDate.text = todoItem?.todoTargetDate 
 
             onClick { 
<strong>                this@ToDoAdapter.onItemClick(todoItem)//(7)</strong> 
             } 
          } 
        } 
      } 
    } </pre>
<p>Study the preceding code carefully. It's the complete <kbd>ToDoAdapter</kbd> class. We took an instance of <kbd>context</kbd> as a comment <kbd>(1)</kbd> constructor parameter. We used that <kbd>context</kbd> to get an instance of <kbd>Inflater</kbd>, which in turn was used to inflate the layouts inside the <kbd>onCreateViewHolder</kbd> method. We created a blank <kbd>ArrayList</kbd> of <kbd>ToDoModel</kbd>. We used that list to get item counts of the adapter <kbd>getItemCount()</kbd> function, and inside the <kbd>onBindViewHolder</kbd> function, to pass it to the <kbd>ViewHolder</kbd> instance.</p>
<p>We also took a lambda as a <kbd>val</kbd> parameter inside the constructor of <kbd>ToDoAdapter</kbd>—<kbd>onItemClick</kbd> (comment <kbd>(2)</kbd>). That lambda should receive an instance of <kbd>ToDoModel</kbd> as a parameter and should return unit.</p>
<p>We used that lambda at <kbd>bindView</kbd> of <kbd>ToDoViewHolder</kbd>, inside <kbd>onClick</kbd> (comment <kbd>(7)</kbd>) of <kbd>itemView</kbd> (the view for that item in the list). So, whenever we click on an item, the <kbd>onItemClick</kbd> lambda will be called, which is passed from the <kbd>TodoListActivity</kbd>.</p>
<p>Now, focus on comment <kbd>(5)</kbd>—<kbd>setDataset()</kbd> method. This method is used to assign a new list to the adapter. It will clear the <kbd>ArrayList</kbd><span>—</span><kbd>TodoList</kbd> and add all items from the passed list to it. This method, <kbd>setDataset</kbd>, should be called by the <kbd>fetchTodoList()</kbd> method in <kbd>TodoListActivity</kbd>. That <kbd>fetchTodoList()</kbd> method is responsible for fetching the list from the REST API, and it will pass that list to the adapter.</p>
<p>We will look inside the <kbd>fetchTodoList()</kbd> method later, but let's concentrate on the REST API and Retrofit 2 for API calls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrofit 2 for API calls</h1>
                </header>
            
            <article>
                
<p>Retrofit by Square is one of the most famous and widely used REST clients for Android. It internally uses OkHTTP for HTTP and network calls. The word REST client makes it different from other networking libraries in Android. While most of the networking libraries (Volley, OkHTTP, and others) focus on synchronous/asynchronous requests, prioritization, ordered requests, concurrent/parallel requests, caching, and more. Retrofit gives more attention to making network calls and parsing data more like method calls. It simply turns your HTTP API into a Java interface. And it doesn't even try to solve network problems by itself, but delegates this to OkHTTP internally.</p>
<p>So, how does it transform an HTTP API into a Java interfaces? Retrofit simply uses a converter to serialize/deserialize <strong>POJO</strong> (<strong>plain old Java object</strong>) classes into/from JSON or XML. Now, what is a converter? Converters are those helper classes that parse JSON/XML for you. A converter generally uses the <kbd>Serializable</kbd> interface internally to convert to/from JSON/XML and POJO classes (data classes in Kotlin). It being pluggable gives you many choices of converters, such as the following:</p>
<ul>
<li>Gson</li>
<li>Jackson</li>
<li>Guava</li>
<li>Moshi</li>
<li>Java 8 converter</li>
<li>Wire</li>
<li>Protobuf</li>
<li>SimpleXML</li>
</ul>
<p>We will use Gson for our book. To work with Retrofit, you'll need the following three classes:</p>
<ul>
<li>A <kbd>Model</kbd> class (POJO or data class)</li>
<li>A class to provide you with the Retrofit client instance with the help of <kbd>Retrofit.Builder()</kbd></li>
<li>An <kbd>Interface</kbd> that defines possible HTTP operations, including the request type (GET or POST), parameters/request body/query strings, and finally the response type</li>
</ul>
<p>So, let's get started with the <kbd>Model</kbd> class.</p>
<p>Before creating the class, we need to know the structure of the JSON response first. We all saw JSON responses in the previous chapter, but, as a quick recap, here is the JSON response for the <kbd>GET_TODO_LIST</kbd> API:</p>
<pre>    { 
      "error_code": 0, 
      "error_message": "", 
      "data": [ 
       { 
         "id": 1, 
         "todoDescription": "Lorem ipsum dolor sit amet, consectetur <br/>          adipiscing elit. Integer tincidunt quis lorem id rhoncus. Sed <br/>          tristique arcu non sapien consequat commodo. Nulla dolor <br/>          tellus, molestie nec ipsum at, eleifend bibendum quam.", 
          "todoTargetDate": "2017/11/18", 
          "status": "complete" 
        } 
       ] 
    } </pre>
<p>The <kbd>error_code</kbd> denotes whether there are any errors. If <kbd>error_code</kbd> is a non-zero value, then there must be an error. If it's zero, then there is no error, and you can proceed with parsing the data.</p>
<p>The <kbd>error_message</kbd> will contain information for you if there's an error. If the <kbd>error_code</kbd> is zero, the <kbd>error_message</kbd> will be blank.</p>
<p>The <kbd>data</kbd> key will hold a JSON array for the list of todos.</p>
<p>One thing to note here is that <kbd>error_code</kbd> and <kbd>error_message</kbd> will be consistent for all APIs in our project, so it will be better if we create a base class for all the APIs, and then we extend that class for each API when required.</p>
<p>This is our <kbd>BaseAPIResponse</kbd> class:</p>
<pre>    open class BaseAPIResponse ( 
      @SerializedName("error_code") 
      val errorCode:Int, 
      @SerializedName("error_message") 
      val errorMessage:String): Serializable </pre>
<p>We have two <kbd>val</kbd> properties in this class—<kbd>errorCode</kbd> and <kbd>errorMessage</kbd>; note the annotations <kbd>@SerializedName</kbd>. This annotation is used by Gson to declare the serialized name for a property; the serialized name should be the same as the JSON response. You can easily avoid this annotation if you have the same variable name as the JSON response. If the variable name is different, the serialized name is used to match the JSON response.</p>
<p>Let's now move ahead with <kbd>GetToDoListAPIResponse</kbd>; the following is the class definition:</p>
<pre>    open class GetToDoListAPIResponse( 
      errorCode:Int, 
      errorMessage:String, 
      val data:ArrayList&lt;ToDoModel&gt; 
    ):BaseAPIResponse(errorCode,errorMessage) </pre>
<p>Here, we skipped the <kbd>@Serialized</kbd> annotation for <kbd>data</kbd>, as we are using the same name as the JSON response. The remaining two properties are declared by the <kbd>BaseAPIResponse</kbd> class.</p>
<p>For data, we are using an <kbd>ArrayList</kbd> of <kbd>ToDoModel</kbd>; <kbd>Gson</kbd> will take care of the rest to convert a JSON array to an <kbd>ArrayList</kbd>.</p>
<p>Let's now take a look at the <kbd>ToDoModel</kbd> class:</p>
<pre>    data class ToDoModel ( 
      val id:Int, 
      var todoDescription:String, 
      var todoTargetDate:String, 
      var status:String 
    ):Serializable </pre>
<p>The <kbd>builder</kbd> class for Retrofit is simple, as shown here:</p>
<pre>    class APIClient { 
      private var retrofit: Retrofit? = null 
      fun getClient(): Retrofit { 
         
        if(null == retrofit) { 
 
          val client = OkHttpClient.Builder().connectTimeout(3,<br/>          TimeUnit.MINUTES) 
          .writeTimeout(3, TimeUnit.MINUTES) 
          .readTimeout(3,<br/>          TimeUnit.MINUTES).addInterceptor(interceptor).build() 
 
           retrofit = Retrofit.Builder() 
             .baseUrl(Constants.BASE_URL) 
             .addConverterFactory(GsonConverterFactory.create()) 
             .client(client) 
             .build() 
          } 
 
          return retrofit!! 
         } 
 
         fun getAPIService() =<br/>         getClient().create(APIService::class.java) 
    } </pre>
<p>The <kbd>getClient()</kbd> function is responsible to create and provide you with a Retrofit client. The <kbd>getAPIService()</kbd> function helps you with pairing the Retrofit client with your defined HTTP operations and create an instance of the interface.</p>
<div class="packt_infobox">We used <kbd>OkHttpClient</kbd> and <kbd>Retrofit.Builder()</kbd> to create the <kbd>Retrofit</kbd> instance. If you're not familiar with them, you may visit <a href="http://www.vogella.com/tutorials/Retrofit/article.html"><span class="URLPACKT">http://www.vogella.com/tutorials/Retrofit/article.html</span></a>.</div>
<p>Let's now create the interface for the HTTP operations—<kbd>APIService</kbd>—as follows:</p>
<pre>    interface APIService { 
      @POST(Constants.GET_TODO_LIST) 
      fun getToDoList(): Call&lt;GetToDoListAPIResponse&gt; 
 
      @FormUrlEncoded 
      @POST(Constants.EDIT_TODO) 
      fun editTodo( 
            @Field("todo_id") todoID:String, 
            @Field("todo") todo:String 
      ): Call&lt;BaseAPIResponse&gt; 
 
      @FormUrlEncoded 
      @POST(Constants.ADD_TODO) 
      fun addTodo(@Field("newtodo") todo:String): Call&lt;BaseAPIResponse&gt; 
     } </pre>
<p>We have created API interfaces for all our APIs. Note the return types of the functions. They return a <kbd>Call</kbd> instance that encapsulates the actual expected response.</p>
<p>Now, what is <kbd>Call</kbd> instance? And what is the purpose of using it?</p>
<p>The <kbd>Call</kbd> instance is an invocation of a Retrofit method that sends a request to a webserver and returns a response. Each call yields its own HTTP request and response pair. What to do with the <kbd>Call&lt;T&gt;</kbd> instance? We have to <kbd>enqueue</kbd> it with a <kbd>Callback&lt;T&gt;</kbd> instance.</p>
<p>So, the same pull mechanism, same callback hell. However, we should be reactive, shouldn't we? Let's do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RxKotlin with Retrofit</h1>
                </header>
            
            <article>
                
<p>In Android, we can use RxAndroid in addition to RxKotlin for added Android flavors and benefits, and Retrofit supports them as well.</p>
<p>So, let's start by modifying our <kbd>build.gradle</kbd> in favor of ReactiveX. Add the following dependencies to the app level <kbd>build.gradle</kbd>:</p>
<pre>    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0 ' 
    implementation 'io.reactivex.rxjava2:rxandroid:2.0.1' 
    implementation 'io.reactivex.rxjava2:rxkotlin:2.1.0' </pre>
<p>The first one will provide Retrofit 2 Adapters for RxJava 2, while the following two add RxAndroid and RxKotlin to the project.</p>
<div class="packt_infobox">Note that RxKotlin is a wrapper on top of RxJava, so adapters for RxJava 2 will work perfectly with RxKotlin 2.</div>
<p>Now that we have added the dependencies, let's move on by modifying our code to work with <kbd>Observable</kbd>/<kbd>Flowable</kbd> instead of <kbd>Call</kbd>.</p>
<p>This is the modified <kbd>APIClient.kt</kbd> file:</p>
<pre>    class APIClient { 
      private var retrofit: Retrofit? = null 
      enum class LogLevel { 
        LOG_NOT_NEEDED, 
        LOG_REQ_RES, 
        LOG_REQ_RES_BODY_HEADERS, 
        LOG_REQ_RES_HEADERS_ONLY 
      }  
      /** 
       * Returns Retrofit builder to create 
       * @param logLevel - to print the log of Request-Response 
       * @return retrofit 
       */ 
      fun getClient(logLevel: Int): Retrofit { 
 
        val interceptor = HttpLoggingInterceptor() 
        when(logLevel) { 
            LogLevel.LOG_NOT_NEEDED -&gt; 
                interceptor.level = HttpLoggingInterceptor.Level.NONE 
            LogLevel.LOG_REQ_RES -&gt; 
                interceptor.level = HttpLoggingInterceptor.Level.BASIC 
            LogLevel.LOG_REQ_RES_BODY_HEADERS -&gt; 
                interceptor.level = HttpLoggingInterceptor.Level.BODY 
            LogLevel.LOG_REQ_RES_HEADERS_ONLY -&gt; 
                interceptor.level =<br/>            HttpLoggingInterceptor.Level.HEADERS 
         }  
 
        val client = OkHttpClient.Builder().connectTimeout(3, <br/>        TimeUnit.MINUTES) 
          .writeTimeout(3, TimeUnit.MINUTES) 
          .readTimeout(3,<br/>          TimeUnit.MINUTES).addInterceptor(interceptor).build() 
 
          if(null == retrofit) { 
            retrofit = Retrofit.Builder() 
              .baseUrl(Constants.BASE_URL) 
              .addConverterFactory(GsonConverterFactory.create()) 
<strong>                   <br/>              .addCallAdapterFactory<br/>              (RxJava2CallAdapterFactory.create())</strong> 
              .client(client) 
              .build() 
           } 
 
           return retrofit!! 
         } 
 
         fun getAPIService(logLevel: LogLevel =   <br/>         LogLevel.LOG_REQ_RES_BODY_HEADERS) = <br/>         getClient(logLevel).create(APIService::class.java)  
    } </pre>
<p>This time, we added an OkHttp Logging interceptor (<kbd>HttpLoggingInterceptor</kbd>) along with an RxJava adapter. This OkHttp Logging interceptor will help us log requests and responses. Coming back to the RxJava adapters, look at the highlighted code—we added <kbd>RxJava2CallAdapterFactory</kbd> as the <kbd>CallAdapterFactory</kbd> of the Retrofit client.</p>
<p>We will need to modify the <kbd>APIService.kt</kbd> file as well, to make the functions return <kbd>Observable</kbd> instead of <kbd>Call</kbd>, as shown here:</p>
<pre>    interface APIService { 
      @POST(Constants.GET_TODO_LIST) 
      fun getToDoList(): Observable&lt;GetToDoListAPIResponse&gt; 
 
      @POST(Constants.EDIT_TODO) 
      fun editTodo( 
            @Body todo:String 
      ): Observable&lt;BaseAPIResponse&gt; 
 
      @POST(Constants.ADD_TODO) 
      fun addTodo(@Body todo:String): Observable&lt;BaseAPIResponse&gt; 
    }  </pre>
<p>All the APIs now return <kbd>Observable</kbd> instead of <kbd>Call</kbd>. Finally, we are all set to look inside the <kbd>fetchTodoList()</kbd> function from <kbd>TodoListActivity</kbd>.</p>
<pre>    private fun fetchTodoList() { 
      APIClient() 
      .getAPIService() 
      .getToDoList() 
<strong>      .subscribeOn(Schedulers.computation())<br/></strong><strong>      .observeOn(AndroidSchedulers.mainThread())</strong> 
      .subscribeBy( 
         onNext = { response -&gt; 
                    adapter.setDataset(response.data) 
                  }, 
         onError = { 
                     e-&gt; e.printStackTrace() 
                   } 
       ) 
    } </pre>
<p>The function does a simple task; it subscribes to the API (<kbd>Observable</kbd> from the API) and sets the data to the adapter when it arrives. You should consider adding logic to check the error code before setting the data here, but for now it works quite well. The screenshot of this activity is already shown at the beginning of this chapter, so we will omit it here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making Android events reactive</h1>
                </header>
            
            <article>
                
<p>We have made our API calls reactive, but what about our events? Remember the <kbd>ToDoAdapter</kbd>; we took a lambda, used it inside <kbd>ToDoViewHolder</kbd>, and created and passed the lambda at <kbd>TodoListActivity</kbd>. Quite messy. This should be reactive as well, shouldn't it? So, let's make the events reactive as well.</p>
<p><kbd>Subject</kbd> plays an awesome role in making events reactive. As <kbd>Subject</kbd> is a great combination of <kbd>Observable</kbd> and <kbd>Observer</kbd>, we can use them as <kbd>Observer</kbd> inside <kbd>Adapter</kbd> and as <kbd>Observable</kbd> inside <kbd>Activity</kbd>, thus making passing events easy.</p>
<p>So, let's modify the <kbd>ToDoAdapter</kbd> as follows:</p>
<pre>    class ToDoAdapter( 
      private val context:Context, //(1) 
      val onClickTodoSubject:Subject&lt;Pair&lt;View,ToDoModel?&gt;&gt;//(2) 
      ):RecyclerView.Adapter&lt;ToDoAdapter.ToDoViewHolder&gt;() { 
      private val inflater:LayoutInflater = <br/>      LayoutInflater.from(context)//(3) 
      private val todoList:ArrayList&lt;ToDoModel&gt; = arrayListOf()//(4) 
 
      fun setDataset(list:List&lt;ToDoModel&gt;) {//(5) 
        todoList.clear() 
        todoList.addAll(list) 
        notifyDataSetChanged() 
      } 
 
      override fun getItemCount(): Int = todoList.size 
 
      override fun onBindViewHolder(holder: ToDoViewHolder?,<br/>      position: Int) { 
        holder?.bindView(todoList[position]) 
      } 
 
      override fun onCreateViewHolder<br/>      (parent: ViewGroup?, viewType: Int): ToDoViewHolder { 
        return ToDoViewHolder(inflater.inflate<br/>        (R.layout.item_todo,parent,false)) 
      } 
 
     inner class ToDoViewHolder(itemView:View):<br/>     RecyclerView.ViewHolder(itemView) { 
       fun bindView(todoItem:ToDoModel?) { 
         with(itemView) {//(6) 
           txtID.text = todoItem?.id?.toString() 
           txtDesc.text = todoItem?.todoDescription 
           txtStatus.text = todoItem?.status 
           txtDate.text = todoItem?.todoTargetDate 
 
           onClick { 
             onClickTodoSubject.onNext(Pair<br/>            (itemView,todoItem))//(7) 
          } 
         } 
       } 
     } 
   } </pre>
<p>The adapter looks cleaner now. We've got a <kbd>Subject</kbd> instance in the constructor, and when the <kbd>itemView</kbd> is clicked, we call the <kbd>onNext</kbd> event of the <kbd>Subject</kbd> and pass both the <kbd>itemView</kbd> and <kbd>ToDoModel</kbd> instance with help of <kbd>Pair</kbd>.</p>
<p>However, it still looks like something is missing. The <kbd>onClick</kbd> method is still a callback; can't we make it reactive as well? Let's do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing RxBinding in Android</h1>
                </header>
            
            <article>
                
<p>To aid us Android developers, Jake Wharton created the RxBinding library, which helps you get Android events in a reactive way. You can find them at <a href="https://github.com/JakeWharton/RxBinding"><span class="URLPACKT">https://github.com/JakeWharton/RxBinding</span></a>. Let's get started by adding it to the project.</p>
<p>Add the following dependency to the app level <kbd>build.gradle</kbd> file:</p>
<pre>    implementation 'com.jakewharton.rxbinding2:rxbinding-kotlin:2.0.0' </pre>
<p>Then we can replace <kbd>onClick</kbd> inside <kbd>ToDoViewHolder</kbd> with the following line of code:</p>
<pre>    itemView.clicks() 
    .subscribeBy { 
       onClickTodoSubject.onNext(Pair(itemView,todoItem)) 
    }</pre>
<p>It's that easy. However, you're probably thinking, what's the benefit of making them reactive? The implementation here was simple enough, but think of a situation where you've tons of logic. You can easily divide the logic into operators, especially <kbd>map</kbd> and <kbd>filter</kbd> could be of great help to you. Not only that, but RxBindings provides you with consistency. For example, when we need to observe text changes on an <kbd>EditText</kbd>, we generally end up writing lines of code in a <kbd>TextWatcher</kbd> instance, but if you use RxBindings, it will let you do that as follows:</p>
<pre>    textview.textChanges().subscribeBy {  
      changedText-&gt;Log.d("Text Changed",changedText) 
    } </pre>
<p>Yes, it's really that simple and that easy. RxBinding provides you with a lot more benefits as well. You can take a look at <a href="https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals"><span class="URLPACKT">https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals</span></a> and <a href="http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html"><span class="URLPACKT">http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html</span></a>.</p>
<p>So now, thanks to Jake Wharton, we can make our views and events reactive as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kotlin extensions</h1>
                </header>
            
            <article>
                
<p>At the end of this chapter, I would like to introduce you to the Kotlin extensions. No, not exactly the Kotlin extensions functions, although they are very much related to the Kotlin extension functions. Kotlin extensions is a curated list of the most commonly used extension functions in Android.</p>
<p>For example, if you want an extension function to create a bitmap from a <kbd>View</kbd>/<kbd>ViewGroup</kbd> instance (especially useful while adding Markers in MapFragment), you can copy and paste the following extension function from there:</p>
<pre>    fun View.getBitmap(): Bitmap { 
      val bmp = Bitmap.createBitmap(width, height,<br/>      Bitmap.Config.ARGB_8888) 
      val canvas = Canvas(bmp) 
      draw(canvas) 
      canvas.save() 
      return bmp 
    } </pre>
<p>Or, a more common case, when you need to hide your keyboard, the following extension function will help you:</p>
<pre>    fun Activity.hideSoftKeyboard() { 
      if (currentFocus != null) { 
        val inputMethodManager = getSystemService(Context 
          .INPUT_METHOD_SERVICE) as InputMethodManager 
        inputMethodManager.hideSoftInputFromWindow<br/>        (currentFocus!!.windowToken, 0) 
      } 
    } </pre>
<p>This online listing has a lot more extension functions for you, which are maintained by Ravindra Kumar (Twitter, GitHub—<kbd>@ravidsrk</kbd>). So, the next time you need an extension function, take a look at <span class="URLPACKT"><a href="http://kotlinextensions.com/">http://kotlinextensions.com/</a> </span>before writing your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We are done with the final chapter of the book. In this chapter, we learned how to configure Retrofit for RxKotlin and RxAndroid. We learned how to make our Android views and events as well as our custom views reactive.</p>
<p>We learned how to use RxJava2Adapter for Retrofit and how to use <kbd>Subject</kbd> for event passing. We also learned how to use RxBindings.</p>
<p>Throughout this book, we tried to go to the depth of reactive programming and cover every possible concept, and we tried to make all our code reactive.</p>
<div class="packt_tip">If you find any questions, or if you get any concerns regarding this book, feel free to drop a email at <a href="mailto:rivu.chakraborty6174@gmail.com"><span class="EmailPACKT">rivu.chakraborty6174@gmail.com</span></a> and mention <kbd>Book Query - Reactive Programming in Kotlin</kbd> in the subject line of the email. You can also check out Rivu Chakraborty's website (<a href="http://www.rivuchk.com"><span class="URLPACKT">http://www.rivuchk.com</span></a>) as he regularly posts there about Kotlin, Google Developer Group Kolkata, and Kotlin Kolkata User Group Meetups. He also writes tutorials and blogs there as well as writes introductions to Android Plugins developed by him. Also, when he writes blogs and articles elsewhere, he posts URLs to them on his site.</div>
<p>Thank you for reading this book. Happy reactive programming in Kotlin.</p>


            </article>

            
        </section>
    </body></html>