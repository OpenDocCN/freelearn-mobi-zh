<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Improving Code Performance</h1></div></div></div><p class="calibre8">Achieving good code performance is an important and desirable task. Everyone would like to have applications that perform well. In this chapter we are going to cover these performance topics:</p><div><ul class="itemizedlist"><li class="listitem">Understanding performance optimization</li><li class="listitem">Optimization checklist</li><li class="listitem">Constants and variables</li><li class="listitem">Method calls</li><li class="listitem">Intelligent code</li><li class="listitem">Value objects and reference objects</li><li class="listitem">Swift arrays and unsafe C arrays</li><li class="listitem">Avoiding Objective-C</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec32" class="calibre1"/>Understanding performance optimization</h1></div></div></div><p class="calibre8">The first rule of <a id="id228" class="calibre1"/>optimization is—don't optimize. You should always remember this phrase by Donald Knut:</p><div><blockquote class="blockquote1"><p class="calibre23"><em class="calibre10">Premature optimization is the root of all evil</em></p></blockquote></div><p class="calibre8">This is a very true and correct statement. You should start doing performance optimization only when you see a performance problem and you have found what is causing it.</p><p class="calibre8">There are two types <a id="id229" class="calibre1"/>of performance optimization:</p><div><ul class="itemizedlist"><li class="listitem">Explicit</li><li class="listitem">Implicit</li></ul></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec37" class="calibre1"/>Explicit</h2></div></div></div><p class="calibre8">Explicit performance<a id="id230" class="calibre1"/> optimization is a technique that is directed at a specific slow piece of code. This type of optimization requires significant code<a id="id231" class="calibre1"/> changes that could worsen code readability. You do explicit performance optimization by changing the algorithm to a more effective one. Using more memory for the cache could also increase performance.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec38" class="calibre1"/>Implicit</h2></div></div></div><p class="calibre8">Implicit performance<a id="id232" class="calibre1"/> optimization is the technique of applying language-specific, in our case Swift-specific, features that lead to better performance. Implicit<a id="id233" class="calibre1"/> code performance doesn't require significant code changes. It doesn't have any negative impact on the code readability and sometimes makes it better. I call it implicit because you can apply it everywhere in the code and it becomes invisible to you after some time.</p><p class="calibre8">Explicit performance optimization is a very popular and broad topic that is covered in many books about algorithms and data structures. Implicit on other hand is directly related to the Swift programming language and is a very interesting topic we are going to have a look at.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Optimization checklist</h1></div></div></div><p class="calibre8">Before doing any <a id="id234" class="calibre1"/>optimization and performance measurement, you<a id="id235" class="calibre1"/> should follow these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Enable the <strong class="calibre9">Release</strong> mode: The Swift compiler does a lot of code optimization and improves performance in the <strong class="calibre9">Release</strong> mode. To enable the <strong class="calibre9">Release</strong> mode go to <strong class="calibre9">Product</strong> | <strong class="calibre9">Scheme</strong> | <strong class="calibre9">Edit Scheme</strong> | <strong class="calibre9">Run</strong>, select the <strong class="calibre9">Info</strong> tab, and select <strong class="calibre9">Release</strong> in the <strong class="calibre9">Build Configuration</strong> setting.</li><li class="listitem" value="2">Disable safety checks: Disabling safety checks could improve application performance; but as its name suggests, it affects safety and disabling is not 100-percent safe and should be applied carefully. An example of a safety check Swift does is checking array bounds before accessing the memory. If you disable safety checks Swift won't do that.<p class="calibre24">Disabling safety checks is a <strong class="calibre9">Swift Compiler – Code Generation</strong> setting that is available in the target <strong class="calibre9">Build Settings</strong>. To disable safety checks select <strong class="calibre9">Project</strong> | <strong class="calibre9">Build Settings</strong>, then search for the <strong class="calibre9">Disable Safety Checks</strong> setting and set it to <strong class="calibre9">Yes</strong> for the <strong class="calibre9">Release</strong> mode.</p></li><li class="listitem" value="3">Enable the <strong class="calibre9">Fast, Whole Module Optimization</strong> level: By default, the Swift compiler does optimization only to one file at a time. It does it as though in sandbox environment for every file. The optimization of one file has no effect on the other files.</li></ol><div></div><p class="calibre8">
<strong class="calibre9">Whole Module Optimization</strong> enables optimization for all the source files in the module at once. All the source<a id="id236" class="calibre1"/> files are evaluated and optimized together. It is very useful because we often declare a type in one file and use it in another. One of the optimizations that <strong class="calibre9">Whole Module Optimization</strong> does is searching for declarations with the <code class="literal">internal</code> type that aren't overridden anywhere and adding the <code class="literal">final</code> declaration optimization for them.</p><p class="calibre8">To enable <strong class="calibre9">Whole Module Optimization</strong>, select <strong class="calibre9">Optimization Level</strong> for the Swift compiler in <strong class="calibre9">Build Setting</strong> and select the <strong class="calibre9">Fast, Whole Module Optimization [-O -whole-module-optimization]</strong> option for the <strong class="calibre9">Release</strong> mode.</p><p class="calibre8">Enabling this setting increases build time. You should use it for release builds and performance testing. While developing and debugging, it would be better to disable this setting to speed up the compiling time.</p><p class="calibre8">There are two different types of Optimization Level settings available in Xcode with different purposes and options:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Apple LLVM - Code Generation</strong></li><li class="listitem"><strong class="calibre9">Swift Compiler – Code Generation</strong></li></ul></div><p class="calibre8">If you select the <strong class="calibre9">Optimization Level</strong> setting, you can see all the available options with a detailed description in the <strong class="calibre9">Quick Help</strong> section in the <strong class="calibre9">Utilities</strong> panel.</p><div><img src="img/00018.jpeg" alt="Optimization checklist" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">By default in the <strong class="calibre9">Release</strong> mode Xcode uses these settings:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Apple LLVM, GCC_OPTIMIZATION_LEVEL</strong>: <strong class="calibre9">Fastest, Smallest [-Os]</strong></li><li class="listitem"><strong class="calibre9">Swift Compiler, SWIFT_OPTIMIZATION_LEVEL</strong>: <strong class="calibre9">Fastest [-O]</strong></li></ul></div><p class="calibre8">You can try enabling other optimization settings. For example using <strong class="calibre9">Fastest, Aggressive Optimizations:[-Ofast]</strong> could improve<a id="id237" class="calibre1"/> application performance.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Swift code compilation</h1></div></div></div><p class="calibre8">The LLVM first turns your source code into pseudocode. In the next step it gets optimized and <a id="id238" class="calibre1"/>compiled into Assembly code.</p><p class="calibre8">You can perform these code-processing steps manually from the command line by using <code class="literal">swiftc</code> in the Swift compiler. To see all available options for the Swift compiler, open <code class="literal">Terminal.app</code> and execute the <code class="literal">--help</code> command:</p><div><pre class="programlisting">
<strong class="calibre9">xcrun swiftc --help</strong>
</pre></div><p class="calibre8">You will see the available compilation modes and options. The ones we are looking for are:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">-emit-assembly</code></li><li class="listitem"><code class="literal">-emit-ir</code></li><li class="listitem"><code class="literal">-emit-silgen</code></li><li class="listitem"><code class="literal">-emit-sil</code></li></ul></div><p class="calibre8">These compilation modes allow you to apply different compilation steps to the Swift source file. As an example, we could emit <code class="literal">sourceFile.swift</code> into the canonical SIL representation and write the result to the <code class="literal">outputFile</code> with this command:</p><div><pre class="programlisting">
<strong class="calibre9">swiftc -emit-sil sourceFile.swift -o outputFile</strong>
</pre></div><p class="calibre8">We will cover the compilation process in greater detail in <a class="calibre1" title="Chapter 8. Discovering All the Underlying Swift Power" href="part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0">Chapter 8</a>, <em class="calibre10">Discovering All the Underlying Swift Power</em>.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Constants and variables</h1></div></div></div><p class="calibre8">Using constant has <a id="id239" class="calibre1"/>an impact on code readability. It makes code clearer and safer. Using constants instead of variables could also have performance benefits. When you use a constant you <a id="id240" class="calibre1"/>give the compiler a clear hint that this value won't be changed. The Swift compiler can apply inline optimization to use a value of that constant and not allocate memory for it.</p><p class="calibre8">In simple examples, the Swift compiler could do the same optimization for variables as well. Let's analyze the result for this simple example of iterating and calculating a sum. The performance is the same for variables and constants in this example.</p><div><pre class="programlisting">var result = 0
for _ in 0...10000000 {
  let a = Int(arc4random())
  result += a
}
// Average Time - 0.162666518447804

var result = 0
for _ in 0...10000000 {
  var a = Int(arc4random())
  result += a
}
// Average Time - 0.160957522349781</pre></div><p class="calibre8">If we look at a more <a id="id241" class="calibre1"/>complex example, we will see that constants perform the same as, or even better than, variables. It might seem as if a version using variables should<a id="id242" class="calibre1"/> perform faster, because there is no need to allocate memory for new constants on every operation, but the Swift compiler is smart enough to perform intelligent optimization so that they behave the same.</p><div><pre class="programlisting">var result = 0
for _ in 0...100000000 {
  let a = Int(arc4random_uniform(10))
  let b = a + Int(arc4random_uniform(10))
  let c = b * Int(arc4random_uniform(10))
 
  result += c
}
// Average Time - 12.6813167635002

var result = 0
for _ in 0...100000000 {
  var a = Int(arc4random_uniform(10))
  a += Int(arc4random_uniform(10))
  a *= Int(arc4random_uniform(10))
  result += a
}
// Average Time - 12.6813167635102</pre></div><p class="calibre8">So the general advice is: Prefer using constants. They make the code safer and clearer and also have a positive impact on performance. Variables in some situations could also improve code readability, as in the example earlier where we had to do some math calculations and changing the value in the variable actually made the code clearer.</p><p class="calibre8">Constants are so much better than variables that Xcode shows a warning when it detects a variable that was never mutated and suggests you change it to a constant.</p><div><img src="img/00019.jpeg" alt="Constants and variables" class="calibre11"/></div><p class="calibre12"> </p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec36" class="calibre1"/>Method calls</h1></div></div></div><p class="calibre8">Before discussing Swift method calls optimization, it would be very useful to have a look at different types of<a id="id243" class="calibre1"/> method call implementation.</p><p class="calibre8">There are two main types of method call:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Static</strong>: Static method <a id="id244" class="calibre1"/>binding means that, when you call a method on the object, the compiler knows that you are calling exactly this method on exactly this class. C is an example of a language with static method binding.</li><li class="listitem"><strong class="calibre9">Dynamic</strong>: On other <a id="id245" class="calibre1"/>hand, dynamic has a weak binding between the method and the object. When you call a method on the object there is no guarantee that an object can handle this method call. Objective-C has a dynamic method binding. That's why you can see the <code class="literal">object does not respond to selector</code> error in Objective-C.</li></ul></div><p class="calibre8">Objective-C is a dynamic-type language and it has a dynamic runtime. Calling a method is called <a id="id246" class="calibre1"/>
<strong class="calibre9">message sending</strong>. You send a message to the target.</p><div><pre class="programlisting">[dog bark] // dog is a target and bark is a message</pre></div><p class="calibre8">This looks like a normal method call, but after compilation it would actually look like:</p><div><pre class="programlisting">objc_msgSend(dog, @selector(bark))</pre></div><p class="calibre8">Objective-C uses dynamic method binding. It means that the message and the receiver are stored separately. When you send a <code class="literal">bark </code>message to the <code class="literal">dog </code>object, the dog class has to look up if it has a bark method and if it can handle it. This process is called dynamic method binding. The implementation would look like this:</p><div><pre class="programlisting">id objc_msgSend ( id obj, SEL _cmd, ... )
{
    Class c = object_getClass(obj);
    IMP imp = CacheLookup(c, _cmd);
    if (!imp) {
        imp = class_getMethodImplementation(c, _cmd);
    }
    jump imp(obj, op, ...);
}</pre></div><p class="calibre8">Swift uses a static method binding. It uses a vtable—Virtual Method Table—for storing methods. Vtable is an array of function pointers. That means that a class has a list of its methods with the memory address of that method implementation. When you call a method in Swift, you<a id="id247" class="calibre1"/> are calling it on the specific type. The binding between the method and the object you are calling this method on is very strong and done at compile time.</p><p class="calibre8">Let's have a look how the same code would behave in Swift:</p><div><pre class="programlisting">dog.bark()</pre></div><p class="calibre8">Because Swift knows that you want to call a bark method on the <code class="literal">Dog</code> class, it doesn't need to do any extra lookup for the method information. It will get the function address and call it:</p><div><pre class="programlisting">methodImplementation = dog-&gt;class.vtable[indexOfBark] methodImplementation()</pre></div><p class="calibre8">Swift can do even more complex optimization to method calls. If the method is not overridden, it means that call to the <code class="literal">bark</code> method will always resolve to the same function call. The Swift compiler can skip the function lookup in the vtable and inline direct function call:</p><div><pre class="programlisting">_TFC12methodsCalls3Dog4barkfS0_FT_T_()
//this method is equal to- methodsCalls.Dog.bark()</pre></div><div><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">This is the mangled name of the <code class="literal">bark</code> method. We will learn more about this in <a class="calibre1" title="Chapter 8. Discovering All the Underlying Swift Power" href="part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0">Chapter 8</a>, <em class="calibre10">Discovering All the Underlying Swift Power</em>.</p></div><p class="calibre8">The <code class="literal">_TFC12methodsCalls3Dog4barkfS0_FT_T_()</code> direct function call in the assembly code is translated into a simple command. Here is how the assembly pseudo code looks:</p><div><pre class="programlisting">rbx = __TFC11Performance3DogCfMS0_FT_S0_(); // Create dog instance
r15 = *(*rbx + 0x48); //get the location of bark method
(r15)(rbx); // call the method</pre></div><p class="calibre8">Let's compare the performance of Swift static method calls with the Objective-C dynamic method call to the see the performance difference. Let's make a simple <code class="literal">Number</code> class with an <code class="literal">add</code> method that will add two numbers (a Swift solution):</p><div><pre class="programlisting">class Number {

  func add(x: Int, y: Int) -&gt; Int {
    return x + y
  }
}</pre></div><p class="calibre8">For time measurement we are using our <code class="literal">measure </code>function from the previous chapter:</p><div><pre class="programlisting">let number = Number()
measure("Sum", times: 20) {
  var result: Int = 0
  for i in 0...1000000000 {
    result += number.add(i, y: i + 1)
  }
  print(result)
}</pre></div><p class="calibre8">The result: <code class="literal">Average Time - 1.45391867654989</code>.</p><p class="calibre8">Let's see the <a id="id248" class="calibre1"/>Objective-C solution:</p><div><pre class="programlisting">//  KKNumber.h
@import Foundation;

@interface KKNumber : NSObject

- (NSInteger)add:(NSInteger)num number:(NSInteger)num2;

@end

//  KKNumber.m
#import "KKNumber.h"

@implementation KKNumber

- (NSInteger)add:(NSInteger)num number:(NSInteger)num2 {
  return num + num2;
}

@end

KKNumber *number = [[KKNumber alloc] init];

[Measure measure:20 call:^{
  NSInteger result = 0;
  for (int i  = 0; i &lt; 1000000000; ++i) {
    result += [number add:i number:i + 1];
  }
  NSLog(@"Result %ld", (long)result);
}];</pre></div><p class="calibre8">The result: <code class="literal">Average Time - 2.974986</code>.</p><p class="calibre8">As you can see, even a very simple function call is twice as fast in Swift. Now you know the details of <a id="id249" class="calibre1"/>Swift method and functions call implementation, it's time to jump to more practical examples.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec39" class="calibre1"/>Functions and methods</h2></div></div></div><p class="calibre8">You can make code<a id="id250" class="calibre1"/> reusable by making a function or a<a id="id251" class="calibre1"/> method in four different ways:</p><div><ul class="itemizedlist"><li class="listitem">Global functions</li><li class="listitem">Type methods</li><li class="listitem">Static and final methods</li><li class="listitem">Instance methods</li></ul></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec26" class="calibre1"/>Global functions</h3></div></div></div><p class="calibre8">Global functions are<a id="id252" class="calibre1"/> the simplest ones. They cannot be overridden and changed. Global functions are stored as named pointers in memory. When you call a global function it is translated to the direct memory call without any lookup in the vtable. This should be the fastest way. The assembly code for calling a global function is:</p><div><pre class="programlisting">call       __TZFC4test3Dog5speakfMS0_FT_T_</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec27" class="calibre1"/>Type methods</h3></div></div></div><p class="calibre8">Type methods <a id="id253" class="calibre1"/>operate on the type and not instances of that type. Class methods are stored in the vtable for that class. The class method can be overridden by subclass. Because class methods can be overridden, the Swift compiler sometimes can't optimize class method calls to a direct function call as for global functions. For a better understanding of why, let's have a look at this simple example of an overridden class method:</p><div><pre class="programlisting">class Dog {
  class func bark() {
    print("Bark")
  }
}

class BigDog: Dog {
  override class func bark() {
    print("big loud BARK")
  }
}

func getDog() -&gt; Dog.Type {
  return arc4random() % 2 == 0 ? Dog.self : BigDog.self
}

let dog = getDog()
dog.bark()</pre></div><p class="calibre8">We have made two simple classes: <code class="literal">Dog</code> and <code class="literal">BigDog</code>. The function <code class="literal">getDog</code> returns a <code class="literal">Dog.Type</code> class type, but it can also return <code class="literal">BigDog.Type</code>. The <code class="literal">dog</code> variable can be either a <code class="literal">Dog.Type</code> or a <code class="literal">BigDog.Type</code>. Because of that, the Swift compiler can't do direct function calls inline. It has<a id="id254" class="calibre1"/> to do a lookup for the function pointer in the vtable and that is a very cheap operation. The pseudo assembly code for this would look like:</p><div><pre class="programlisting">rax = __TF4test6getDogFT_MCS_3Dog(); // call getDog()
*__Tv4test3dogMCS_3Dog = rax;    // convert result to Dog.Type.
(*(rax + 0x48))(rax);         // call bark method, vtable lookup</pre></div><p class="calibre8">The Swift compiler can do direct function calls inline for overridden methods when you specify a type explicitly. In this example we call the <code class="literal">bark</code> method on the <code class="literal">Dog</code> class and the Swift compiler skips the vtable lookup:</p><div><pre class="programlisting">Dog.bark()

// Pseudo assembly code
__TTSf4d___TZFC4test3Dog4barkfMS0_FT_T_</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec28" class="calibre1"/>Static methods</h3></div></div></div><p class="calibre8">You can declare a static type<a id="id255" class="calibre1"/> method in classes, structures and enumerations. In classes declaring a type method, using the <code class="literal">static</code> keyword is the same as using the <code class="literal">final class</code> keywords. Those two method declarations are equivalents:</p><div><pre class="programlisting">static func speak() {}
final class func speak() {}</pre></div><p class="calibre8">Static methods can't be overridden in the subclasses. Because they can't be overridden they don't need to be stored in the vtable. The implementation details of a static method are very similar to a global function. In the assembly code it will be translated to a direct function call, the same as for global functions. Let's add a static function to our dog class and explore how it translates to the assembly code:</p><div><pre class="programlisting">class Dog {

  static func speak() {
    print("I don't speak")
  }
}

Dog.speak()
BigDog.speak()</pre></div><p class="calibre8">Both calls to the<a id="id256" class="calibre1"/> <code class="literal">speak</code> method in <code class="literal">Dog</code> and the <code class="literal">BigDog</code> class are translated to a one-line assembly instruction.</p><div><pre class="programlisting">call       __TZFC4test3Dog5speakfMS0_FT_T_</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec29" class="calibre1"/>Instance methods</h3></div></div></div><p class="calibre8">The main difference<a id="id257" class="calibre1"/> between type methods and instance methods is that instance methods can operate with instance constants and variables. Instance methods can be overridden and they need to be stored in the vtable. Let's add a name variable to our <code class="literal">Dog</code> class and a <code class="literal">changeName</code> instance method:</p><div><pre class="programlisting">class Dog {
  var name = ""

func changeName(name: String) {
    self.name = name
  }
}

let someDog = Dog()
someDog.changeName("Cocoa")</pre></div><p class="calibre8">The <code class="literal">changeName</code> method will be translated to this assembly code. Get the method address from the vtable and call it with passing parameters:</p><div><pre class="programlisting">rbx = __TFC4test3DogCfMS0_FT_S0_(); // Create Dog()
*__Tv4test7someDogCS_3Dog = rbx;  //Assign Dog instance to a someDog variable
r15 = *(*rbx + 0x68);    // Get changeName method, vtable lookup
(r15)("Coca", 0x4, 0x0, rbx); // call method and pass arguments</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec30" class="calibre1"/>Comparing function speed</h3></div></div></div><p class="calibre8">Now you know how<a id="id258" class="calibre1"/> functions and methods are implemented and how they work. Let's compare the performance speed of those global function and the different method types. For the test we will use a simple <code class="literal">add</code> function. We will implement it as a global function, static, class type, and instance and override them in the subclass:</p><div><pre class="programlisting">func add(x: Int, y: Int) -&gt; Int {
  return x + y
}

class NumOperation {

  func addI(x: Int, y: Int) -&gt; Int
  class func addC(x: Int, y: Int) -&gt; Int
  static func addS(x: Int, y: Int) -&gt; Int
}

class BigNumOperation: NumOperation {

  override func addI(x: Int, y: Int) -&gt; Int
  override class func addC(x: Int, y: Int) -&gt; Int
}</pre></div><p class="calibre8">For the measurement and code analysis, we use a simple loop where we call those different methods:</p><div><pre class="programlisting">measure("addC") {
  var result = 0
  for i in 0...2000000000 {
    result += NumOperation.addC(i, y: i + 1)
    // result += test different method
  }
  print(result)
}</pre></div><p class="calibre8">Results:</p><p class="calibre8">All these methods <a id="id259" class="calibre1"/>perform in exactly the same way. Furthermore, their assembly code looks exactly the same, except the name of the function call:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Global function</strong>: <code class="literal">add(10, y: 11)</code></li><li class="listitem"><strong class="calibre9">Static</strong>: <code class="literal">NumOperation.addS(10, y: 11)</code></li><li class="listitem"><strong class="calibre9">Class</strong>: <code class="literal">NumOperation.addC(10, y: 11)</code></li><li class="listitem"><strong class="calibre9">Subclass Static</strong>: <code class="literal">BigNumOperation.addS(10, y: 11)</code></li><li class="listitem"><strong class="calibre9">Subclass overridden class</strong>: <code class="literal">BigNumOperation.addC(10, y: 11)</code></li></ul></div><p class="calibre8">The assembly pseudocode for those functions looks likes this:</p><div><pre class="programlisting">r14 = 0x0;
do {
  rbx = "Function name Here"(r14 + 0x1, r14) + rbx;
  r14 = r14 + 0x1;
} while (r14 != 0x3ea);</pre></div><p class="calibre8">Even though the <code class="literal">BigNumOperation</code> <code class="literal">addC</code> class function overrides the <code class="literal">NumOperation</code> <code class="literal">addC</code> function when you call it directly, there is no need for a vtable lookup.</p><p class="calibre8">The instance method <a id="id260" class="calibre1"/>call looks a bit different.</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Instance</strong>:<div><pre class="programlisting">  let num = NumOperation()
  num.addI(10, y: 11)</pre></div></li><li class="listitem"><strong class="calibre9">Subclass overridden instance</strong>:<div><pre class="programlisting">  let bigNum = BigNumOperation()
  bigNum.addI()</pre></div></li></ul></div><p class="calibre8">The one difference is that they need to initialize a class and create an instance of the object. In our example this is not such an expensive operation because we do it outside the loop and it happens only once:</p><div><pre class="programlisting">if (rax == 0x0) {
  rax = _swift_getInitializedObjCClass (
    objc_class__TtC4test12NumOperation);
  *__TMLC4test12NumOperation = rax;
}
var_78 = _swift_allocObject(rax, 0x10, 0x7);</pre></div><p class="calibre8">The loop with the calling instance method looks exactly the same so we will not list it again.</p><p class="calibre8">As you have seen there is almost no difference between global functions and static and class methods. Instance methods look a bit different but it doesn't have a big impact on performance. Though this is true for simple use cases, there is a difference between them in more complex examples. Let's have a look at this one:</p><div><pre class="programlisting">let baseNumType = arc4random_uniform(2) == 1 ? 
  BigNumOperation.self : NumOperation.self

  for i in 0...loopCount {
    result += baseNumType.addC(i, y: i + 1)
  }
  print(result)</pre></div><p class="calibre8">The only difference here is that, instead of specifying the <code class="literal">NumOperation</code> class type at compile time, we randomly return it at runtime. And because of this, the Swift compiler doesn't know which method should be called—<code class="literal">BigNumOperation.addC</code> or <code class="literal">NumOperation.addC</code>—at compile time. This small change has an impact on the generated assembly code and the performance.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec40" class="calibre1"/>Functions and methods usage summary</h2></div></div></div><p class="calibre8">Global functions are the simplest ones and provide the best performance. Having too many global functions makes code hard to read and follow.</p><p class="calibre8">Static type methods<a id="id261" class="calibre1"/> that can't be overridden have the same performance as global functions but they also provide a namespace (type <code class="literal">name</code>), so our code looks clearer and without any loss in performance.</p><p class="calibre8">Class methods that can be overridden could lead to a performance loss and should be used when you need class inheritance. In other cases, static methods are preferred.</p><p class="calibre8">Instance methods operate on the instance of the object. Use instance methods when you need to operate on the data of that instance.</p><p class="calibre8">Make methods final when you don't need to override them. This tells the compiler that optimization and performance could be increased because of that.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec37" class="calibre1"/>Intelligent code</h1></div></div></div><p class="calibre8">Because Swift is a<a id="id262" class="calibre1"/> static and strongly typed language it can read, understand, and optimize code very well. Swift tries to remove the execution of all unnecessary code. For a better explanation let's have a look at a simple example:</p><div><pre class="programlisting">class Object {
 
  func nothing() {  
  }
}

let object = Object()
object.nothing()
object.nothing()</pre></div><p class="calibre8">We create an instance of the <code class="literal">Object</code> class and call a <code class="literal">nothing</code> method. The <code class="literal">nothing </code>method is empty <a id="id263" class="calibre1"/>and calling it does nothing. The Swift compiler understands that and removes those method calls. After this we have only one line of code:</p><div><pre class="programlisting">let object = Object()</pre></div><p class="calibre8">The Swift compiler can also obviate the creation of objects that are never used. It reduces memory usage and unnecessary function calls, which also reduces CPU usage. In our example the <code class="literal">object</code> instance is not used after removing the <code class="literal">nothing</code> method call and the creation of <code class="literal">Object</code> can be dispensed with as well. This way, Swift removes all three lines of code and we end up with no code to execute at all.</p><p class="calibre8">Objective-C, can't do this optimization. Because it has a dynamic runtime, the <code class="literal">nothing</code> method implementation could be changed to do some work at runtime. That's why Objective-C can't remove empty method calls.</p><p class="calibre8">This optimization <a id="id264" class="calibre1"/>might not seem to amount to much but let's have a look at another, slightly more complex example that uses more memory:</p><div><pre class="programlisting">class Object {
  let x: Int
  let y: Int
  let z: Int

  init(x: Int) {
    self.x = x
    self.y = x * 2
    self.z = y * 2
  }

  func nothing() {
  }
}</pre></div><p class="calibre8">We have added some <code class="literal">Int</code> data to our <code class="literal">Object</code> class to increase memory usage. Now the <code class="literal">Object</code> instance uses at least 24 bytes (3 * <code class="literal">Int</code> size; <code class="literal">Int</code> uses four bytes in 64-bit architecture). Let's also try to increases CPU usage by adding more instructions via a loop:</p><div><pre class="programlisting">for i in 0...1_000_000 {
  let object = Object(x: i)
  object.nothing()
  object.nothing()
}
print("Done")</pre></div><div><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre8">Integer literals can use underscores (<code class="literal">_</code>) to improve readability. 1_000_000_000 is the same as 1000000000</p></div><p class="calibre8">Now we have three<a id="id265" class="calibre1"/> million instructions and we use 24 million bytes, about 24 MB. This is quite a lot for the type of operation that actually doesn't do anything. As you can see, we don't use the result of the loop body. For the loop body Swift does the same optimization as in the previous example and we end up with an empty loop:</p><div><pre class="programlisting">for i in 0...1_000_000 {
}</pre></div><p class="calibre8">The empty loop can be skipped as well. As a result, we have saved 24 MB of memory usage and three million method calls.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec41" class="calibre1"/>Dangerous functions</h2></div></div></div><p class="calibre8">There are some<a id="id266" class="calibre1"/> functions and instructions that sometimes don't provide any value for the application but the Swift compiler can't skip them and they<a id="id267" class="calibre1"/> could have a very negative impact on performance.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec31" class="calibre1"/>Console print</h3></div></div></div><p class="calibre8">Printing a statement to<a id="id268" class="calibre1"/> the console is usually used for debug purposes. The <code class="literal">print</code> and <code class="literal">debugPrint</code> instructions aren't removed from the application in the Release mode. Let's explore this code:</p><div><pre class="programlisting">for i in 0...1_000_000 {
  print(i)
}</pre></div><p class="calibre8">The Swift compiler treats <code class="literal">print</code> and <code class="literal">debugPrint</code> as a valid and important instruction that can't be skipped. Even though this code does nothing, it can't be optimized because Swift doesn't remove the <code class="literal">print</code> statement. And as a result we have one million unnecessary instructions. The assembly code for this is:</p><div><pre class="programlisting">mov        qword [ss:rbp+var_20], rbx                 
inc        rbx                //increase i
mov        rdi, r14          // save stack state for function call                  
mov        rsi, r15                                   
call       __TFSs5printurFq_T_   //call print
cmp        rbx, 0xf4241      // check loop condition i &gt; 1_000_000
jne        0x100155fb0      // continue loop if condition is true</pre></div><p class="calibre8">As you can see even very simple code that uses the <code class="literal">print </code>statement can decrease application performance very dramatically. The loop with the 1_000_000 <code class="literal">print</code> statement takes five seconds and that's a lot. It's even worse if you run it in Xcode; it will take up to 50 seconds.</p><p class="calibre8">It gets even worse if you add a <code class="literal">print</code> instruction to the <code class="literal">nothing</code> method of an <code class="literal">Object</code> class from the previous example:</p><div><pre class="programlisting">func nothing() {
  print(x + y + z)
}</pre></div><p class="calibre8">In that case, a loop where we create an instance of <code class="literal">Object</code> and call <code class="literal">nothing</code> can't be eliminated because of the <code class="literal">print </code>instruction. Even though Swift can't eliminate execution of that code completely it does the optimization by removing the creation instance of <code class="literal">Object</code> and calling the <code class="literal">nothing </code>method, and turns it into a simple loop operation. The compiled code after optimization will look like this:</p><div><pre class="programlisting">// Initial Source Code
for i in 0...1_000 {
  let object = Object(x: i)
  object.nothing()
  object.nothing()
}

// Optimized Code
var x = 0, y = 0, z = 0
for i in 0...1_000_000 {
 
  x = i
  y = x * 2
  z = y * 2
 
  print(x + y + z)
  print(x + y + z)
}</pre></div><p class="calibre8">As you can see<a id="id269" class="calibre1"/>, this code is far from perfect and supplies a lot of instructions that actually don't give us any value. There is a way to improve this code so the Swift compiler would perform the optimal code optimisation.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec32" class="calibre1"/>Removing print logs</h3></div></div></div><p class="calibre8">To solve this<a id="id270" class="calibre1"/> performance problem we have to remove<a id="id271" class="calibre1"/> the <code class="literal">print</code> statements from the code before compiling it. There are a few ways to do that.</p><div><div><div><div><h4 class="title3"><a id="ch04lvl4sec04" class="calibre1"/>Comment out</h4></div></div></div><p class="calibre8">The first idea is to comment out <a id="id272" class="calibre1"/>all <code class="literal">print</code> statements in the code in the Release mode.</p><div><pre class="programlisting">//print("A")</pre></div><p class="calibre8">This would work but the next time you want to enable logs, you would need to uncomment that code. This is a very bad and painful practice. There is a better solution.</p><div><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre8">Commented code is bad practice in general. You should be using a source code version control system, such as Git, instead. This way you can safely remove unnecessary code and find it in history if you need it someday.</p></div></div><div><div><div><div><h4 class="title3"><a id="ch04lvl4sec05" class="calibre1"/>Using build configurations</h4></div></div></div><p class="calibre8">We can enable <code class="literal">print</code> only in the <strong class="calibre9">Debug</strong> mode. To do this, we will use a build configuration to <a id="id273" class="calibre1"/>conditionally exclude some code. First we need to add a Swift compiler custom flag. To do that:</p><p class="calibre8">Select a Project target— <strong class="calibre9">Build Settings</strong> – <strong class="calibre9">Other Swift flags</strong> setting in the <strong class="calibre9">Swift Compiler – Custom Flags</strong> section and add the <strong class="calibre9">–D DEBUG</strong> flag for the <strong class="calibre9">Debug</strong> mode:</p><div><img src="img/00020.jpeg" alt="Using build configurations" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">After this you can use the <code class="literal">DEBUG</code> configuration flag to enable code only in the Debug mode. We will define our own <code class="literal">print</code> function that will generate print statement only in debug mode. In the Release mode, that function would be empty and the Swift compiler will successfully eliminate it:</p><div><pre class="programlisting">func D_print(items: Any..., separator: String = " ", terminator: String = "\n") {
  #if DEBUG
    print(items, separator: separator, terminator: terminator)
  #endif
}</pre></div><p class="calibre8">Everywhere instead of <code class="literal">print</code> we will now use <code class="literal">D_print</code>:</p><div><pre class="programlisting">func nothing() {
  D_print(x + y + z)
}</pre></div><div><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre8">You can also create a similar <code class="literal">D_debugPrint</code> function.</p></div><p class="calibre8">Swift is very smart and does a lot of optimization but we also have to make code clear for people to read and for the compiler to optimize.</p><div><h3 class="title2"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre8">Using a preprocessor adds complexity to the code. Use this wisely and only in those situations when normal <code class="literal">if</code> conditions won't work, like in our <code class="literal">D_print</code> example.</p></div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec42" class="calibre1"/>Using nonoptimizable constants</h2></div></div></div><p class="calibre8">Some types can't be<a id="id274" class="calibre1"/> optimized as well as others and using constants of that type can't prevent the code from being eliminated by the Swift compiler.</p><p class="calibre8">Let's have a look at this simple example:</p><div><pre class="programlisting">class Optimizable {
  let x = 10
}

// Use-case
let o = Optimizable()</pre></div><p class="calibre8">The Swift compiler can eliminate this code. Let's have a look at a more complex example:</p><div><pre class="programlisting">class Optimizable {
  let x = 10
  let a = ""
}

// Use-case
let o = Optimizable()</pre></div><p class="calibre8">This code can't be completely eliminated by the Swift compiler. By adding a very simple <code class="literal">String</code> constant, we have added much more complexity to the source-code. To understand why it happened we need to explore the assembly code:</p><div><pre class="programlisting">if (*__TMLC4test11Optimizable == 0x0) {
  *__TMLC4test11Optimizable = _swift_getInitializedObjCClass();
  // Initialize objc_class__TtC4test11Optimizable
}
rax = _swift_allocObject();
*(rax + 0x10) = 0xa;
*(rax + 0x18) = "";</pre></div><p class="calibre8">From the name of the <code class="literal">getInitializedObjCClass</code> we could make an assumption that this method does some Objective-C class type initialization. It might seem very strange because we haven't used any Objective-C types in our code. We have added a simple empty string constant: <code class="literal">let a = ""</code>.</p><p class="calibre8">The thing is that the Swift <code class="literal">String</code> provides seamless interoperability with the Objective-C <code class="literal">NSString</code> type. Because of this, when we use a Swift <code class="literal">String</code> it allocates some additional data to perform bridging to <code class="literal">NSString</code>. Here is how that metadata <code class="literal">objc_class__TtC4test11Optimizable</code> looks:</p><div><pre class="programlisting">objc_class__TtC4test11Optimizable:
dq         __TMmC4test11Optimizable; metaclass,
dq         _OBJC_CLASS_$_SwiftObject; superclass
dq         __objc_empty_cache; cache
dq         __objc_empty_vtable; vtable
dq         0x1001bf7e1; data (Swift class)</pre></div><p class="calibre8">There are more types that can't simply be eliminated by the Swift compiler when they are used with simple constants:</p><div><ul class="itemizedlist"><li class="listitem">String</li><li class="listitem">Array</li><li class="listitem">Custom Class objects</li><li class="listitem">Closures</li><li class="listitem">Set</li><li class="listitem">Dictionary<div><pre class="programlisting">class NotOptimizableTypes {

  let a: String = ""
  let b: String? = nil
  let c: Array&lt;Int&gt; = [1]
  let obj = Object()
  let d: Int -&gt; Int = { $0 + 1 }

  let e: Set&lt;Int&gt; = [1]
  let f: Dictionary&lt;Int, Int&gt; = [1 : 1]
}</pre></div></li></ul></div><p class="calibre8">The interesting behavior happens if we try to use those types in a structure instead of a class. We see different behavior because Swift structures aren't exposed for use in Objective-C. That's why the Swift compiler can eliminate many of them: String, Array, Class, and Closures. Set and Dictionary aren't eliminated even if they are used in the structure.</p><div><pre class="programlisting">struct NotOptimizableInStruct {

  let a: String = ""
  let b: Array&lt;Int&gt; = [1]
  let obj = Object()
  let c: Int -&gt; Int = { $0 + 1 }
}</pre></div><p class="calibre8">Moving those constant to the initializer doesn't solve the problem.</p><p class="calibre8">The solution to that issue is that you shouldn't use any constants that aren't used and don't provide any value for the application.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec38" class="calibre1"/>Improving speed</h1></div></div></div><p class="calibre8">There are a few<a id="id275" class="calibre1"/> techniques that can simply improve code performance. Let's jump directly to the first one.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec43" class="calibre1"/>Final</h2></div></div></div><p class="calibre8">You can make a <a id="id276" class="calibre1"/>function and property declaration with the <code class="literal">final</code> attribute. Adding the <code class="literal">final</code> attribute makes it nonoverridable. Subclasses can't override that method or property. When you make a method nonoverridable there is no need to store it in the vtable and the call to that function can be performed directly without any function address lookup in the vtable:</p><div><pre class="programlisting">class Animal {

  final var name: String  = ""
  final func feed() {
  }
}</pre></div><p class="calibre8">As you have seen, the <code class="literal">final</code> method performs faster than nonfinal. Even so small an optimization can improve application performance. It not only improves performance but also makes the code more secure. This way you disable the method from being overridden and prevent unexpected and incorrect behavior.</p><p class="calibre8">Enabling the <strong class="calibre9">Whole Module Optimization</strong> setting achieves very similar optimization results but it's better to mark a function and property declaration explicitly as <code class="literal">final</code>: This reduces compiler work and speeds up compilation time. The compilation time for big projects with <strong class="calibre9">Whole Module Optimization</strong> can take up to five minutes in Xcode 7 Beta 6.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec44" class="calibre1"/>Inline functions</h2></div></div></div><p class="calibre8">As you have seen <a id="id277" class="calibre1"/>Swift can do optimization and make some function calls inline. This way there is no performance penalty for calling a function. You can manually enable or disable inline functions with the <code class="literal">@inline</code> attribute:</p><div><pre class="programlisting">@inline(__always) func someFunc () {
}

@inline(never) func someFunc () {
}</pre></div><p class="calibre8">Even though you can manually control inline functions it's usually better to leave it to the Swift compiler to do that. Depending on different optimization settings, the Swift compiler applies a different inlining technique.</p><p class="calibre8">The use case for <code class="literal">@inline(__always)</code> is a very simple one-line function that you want always to be<a id="id278" class="calibre1"/> inlined.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec39" class="calibre1"/>Value objects and reference objects</h1></div></div></div><p class="calibre8">In the previous chapter, you learned the<a id="id279" class="calibre1"/> benefits of using immutable value objects. Value objects not only make code safer and clearer, they also make it faster. Value objects<a id="id280" class="calibre1"/> have better speed performance than reference objects and here is why. As an example of a value object, we will use structures in this chapter.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec45" class="calibre1"/>Memory allocation</h2></div></div></div><p class="calibre8">Value objects can be <a id="id281" class="calibre1"/>allocated on the stack memory instead of the heap memory. Reference objects need to be allocated on the heap memory because<a id="id282" class="calibre1"/> they can be shared between many owners. Because value objects have only one owner they can be safely allocated on the stack. Stack memory is way faster that heap memory.</p><p class="calibre8">The second advantage is that value objects don't need reference counting memory management. As they can<a id="id283" class="calibre1"/> have only one owner, there is no such thing as reference counting for value objects. With <strong class="calibre9">ARC</strong> (<strong class="calibre9">Automatic Reference Counting</strong>), we don't need to think so much about memory management and it mostly looks transparent for us. Even though using reference-object and value-object code looks the same, ARC adds extra retain and release method calls for reference objects. Let's look at a very simple example of a structure and class that represent a number:</p><div><pre class="programlisting">struct NumberValue {
  let x: Int
}

class NumberReference {
  let x: Int
  init(x: Int) {
    self.x = x
  }
}</pre></div><p class="calibre8">As an example we will write exactly the same code using <code class="literal">NumberValue</code> and <code class="literal">NumberReference</code> and compare the generated assembly code:</p><div><pre class="programlisting">var x = NumberValue(x: 1)
var xres = x.x
x = NumberValue(x: 2)
xres += x.x

var y = NumberReference(x: 10)
var yres = y.x
y = NumberReference(x: 20)
yres += y.x</pre></div><p class="calibre8">The two lines of code for creating and using the <code class="literal">NumberValue</code> structure look very simple. In the assembly, it has<a id="id284" class="calibre1"/> three lines of code that do the following:</p><div><ul class="itemizedlist"><li class="listitem">Create the <code class="literal">NumberValue</code> object</li><li class="listitem">Assign it to <code class="literal">x</code> variables</li><li class="listitem">Save <code class="literal">x</code> number to the <code class="literal">xres</code> variable<div><pre class="programlisting">rax = __TFV4test11NumberValueCfMS0_FT1xSi_S0_(0x1);
*__Tv4test1xVS_11NumberValue = rax;
*__Tv4test4xresSi = rax;

// NumberValue(x: 2)
rax = __TFV4test11NumberValueCfMS0_FT1xSi_S0_(0x2);
*__Tv4test1xVS_11NumberValue = rax;
*__Tv4test4xresSi = *__Tv4test4xresSi + rax;</pre></div></li></ul></div><p class="calibre8">As you can see<a id="id285" class="calibre1"/> the code for creating the first number object and the second one looks exactly the same. Now let's have a look the assembly code for the <code class="literal">NumberReference </code>objects:</p><div><pre class="programlisting">rax = __TFC4test15NumberReferenceCfMS0_FT1xSi_S0_(0xa);
*__Tv4test1yCS_15NumberReference = rax;
*__Tv4test4yresSi = *(rax + 0x10);</pre></div><p class="calibre8">As you can see the first three lines look almost the same. It creates an instance of <code class="literal">NumberReference</code>, assigns it to the variable, gets the x number, and saves it to the <code class="literal">yres</code> variable. The code for creating second instance is more interesting:</p><div><pre class="programlisting">// NumberReference(x: 10)
rax = __TFC4test15NumberReferenceCfMS0_FT1xSi_S0_(0x14);
rdi = *__Tv4test1yCS_15NumberReference;
*__Tv4test1yCS_15NumberReference = rax;
_swift_release(rdi, r14);
rax = *__Tv4test1yCS_15NumberReference;
*__Tv4test4yresSi = *__Tv4test4yresSi + *(rax + 0x10);</pre></div><p class="calibre8">As you can see it has three lines more than <code class="literal">NumberValue</code>. We have assigned a new instance to the <code class="literal">y</code> variable; the old <code class="literal">NumberReference</code> got out of a scope and needs to be released. Those three lines are related to the <code class="literal">_swift_release</code> function. If you further analyze the assembly code for working with reference objects, you will also discover another ARC function: <code class="literal">_swift_retain;</code>.</p><p class="calibre8">Now you know the main performance difference between value types and reference types, let's see how they <a id="id286" class="calibre1"/>perform. For that, let's use the number<a id="id287" class="calibre1"/> type and perform some calculations in the loop.</p><div><pre class="programlisting">var result = NumberValue(x: 0)
for i in 0...1_000 {
  var x = NumberValue(x: result.x + i)
  result = x
}

print(result)

var refResult = NumberReference(x: 0)
for i in 0...1_000 {
  var x = NumberReference(x: refResult.x + i)
  refResult = x
}
print(refResult)</pre></div><p class="calibre8">Output:</p><div><pre class="programlisting">
<strong class="calibre9">NumberValue: 500500</strong>
<strong class="calibre9">NumberReference: 500500</strong>
</pre></div><p class="calibre8">The first loop with the <code class="literal">NumberValue</code> structure is completely eliminated by the Swift compiler at compile time. The calculating loop is turned into a simple integer result; 500500 in hexadecimal equals 0x7a314. Here is the assembly pseudocode for the first loop:</p><div><pre class="programlisting">var_30 = 0x7a314;                          // save 500500
__TFSs5printU__FQ_T_(var_30, 0x1001ba538); // call print</pre></div><p class="calibre8">As you can see there no loop execution, the result is evaluated at the compile time.</p><p class="calibre8">The second loop using the <code class="literal">NumberReference</code> reference objects can't be eliminated at compile time. The assembly pseudocode structure looks exactly the same as the source code:</p><div><pre class="programlisting">if (r14 == 0x0) {
  r14 = _swift_getInitializedObjCClass();
  *__TMLC4test15NumberReference = r14;
}
r15 = _swift_allocObject();
*(r15 + 0x10) = 0x0;
rbx = 0x0;
do {
  r13 = rbx + 0x1;
  rbx = rbx + *(r15 + 0x10);
  r12 = _swift_allocObject();
  *(r12 + 0x10) = rbx;
  _swift_release(r15, 0x18);
  r15 = r12;
  rbx = r13;
} while (r13 != 0x3e9);
var_38 = r12;
__TFSs5printU__FQ_T_(var_38, r14);</pre></div><p class="calibre8">As you see, using the value object gives a much bigger performance win. As an example, let's measure the<a id="id288" class="calibre1"/> performance for that operation but increase the loop iterations to 1_00_000_000:</p><div><pre class="programlisting">NumberValue Time - 0.000438838000263786
NumberReference Time - 8.49874957299835</pre></div><p class="calibre8">This is not really a fair performance measurement because the variant with the value object actually<a id="id289" class="calibre1"/> doesn't do any execution. To compare the actual execution speed let's run this code in debug mode:</p><div><h3 class="title2"><a id="tip27" class="calibre1"/>Tip</h3><p class="calibre8">You shouldn't measure performance in the Debug mode.</p></div><p class="calibre8">The results are:</p><div><pre class="programlisting">
<strong class="calibre9">NumberValue Time - 4.31753185200068</strong>
<strong class="calibre9">NumberReference Time - 15.4483174900015</strong>
</pre></div><p class="calibre8">The difference is still impressive; Value objects perform up to four times faster</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec40" class="calibre1"/>Swift arrays and unsafe C arrays</h1></div></div></div><p class="calibre8">Everyone knows that<a id="id290" class="calibre1"/> C is a super-fast programming language and when you hit a performance problem people go to C for help. In Objective-C, it is very easy to use C functions and types; its name says it all—C with Objects.</p><p class="calibre8">Swift also has support for interacting with C types and pointers. Even though it's available, it's considered as<a id="id291" class="calibre1"/> a dangerous operation because you need to do memory management manually. You need to allocate and destroy memory. Those types are called <strong class="calibre9">Unsafe</strong> in Swift and start with the <code class="literal">Unsafe</code> prefix—for example:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">UnsafePointer</code></li><li class="listitem"><code class="literal">UnsafeMutablePointer</code></li><li class="listitem"><code class="literal">UnsafeBufferPointer</code><div><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre8">Avoid using C pointers in Swift. It adds a lot of complexity to the code.</p></div></li></ul></div><p class="calibre8">There are three main use<a id="id292" class="calibre1"/> scenarios for <code class="literal">UnsafePointers</code>:</p><div><ul class="itemizedlist"><li class="listitem">Function parameters</li><li class="listitem">Creating a pointer to an existing variable</li><li class="listitem">Allocating memory for the pointer</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec46" class="calibre1"/>Function parameters</h2></div></div></div><p class="calibre8">First let's learn how to use pointers. When designing your API in Swift, you shouldn't use <code class="literal">UnsafePointers</code>, but you can find a<a id="id293" class="calibre1"/> situation when you need to interact with the C API: a Core Foundation, for example. C pointers would be exposed to Swift as:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">const Int *</code> as <code class="literal">UnsafePointer&lt;Int&gt;</code></li><li class="listitem"><code class="literal">Int *</code> as <code class="literal">UnsafeMutablePointer&lt;Int&gt;</code></li></ul></div><p class="calibre8">When you call a function in Swift with the <code class="literal">UnsafePointer</code> parameter, you can pass a variable of the same type as an in-out argument, by using the <code class="literal">&amp;</code> sign or an array:</p><div><pre class="programlisting">var num = 10
var ar = [1, 2]

func printNumber(x: UnsafePointer&lt;Int&gt;) {
  x.memory
}

printNumber(&amp;num)
printNumber(ar)</pre></div><p class="calibre8">It is also possible to pass <code class="literal">nil</code>, but in that case our function would have a null pointer as an argument and accessing its memory would crash the application:</p><div><pre class="programlisting">printNumber(nil)</pre></div><p class="calibre8">You will see the following on the screen:</p><div><pre class="programlisting">
<strong class="calibre9">Execution was interrupted, reason: EXC_BAD_ACCESS (code=1, address=0x0).</strong>
</pre></div><p class="calibre8">Using <code class="literal">UnsafeMutablePointer</code> is very similar. The main difference between <code class="literal">UnsafeMutablePointer</code> and<code class="literal"> UnsafePointer</code> is that a mutable pointer can mutate the value of the variable it points to. When using arrays as an argument for a function with the <code class="literal">UnsafeMutablePointer</code> parameter, they also need to <a id="id294" class="calibre1"/>be passed as in-out parameters.</p><div><pre class="programlisting">func changeNumber(x: UnsafeMutablePointer&lt;Int&gt;) {
  x.memory = 9901
}

changeNumber(&amp;num)
changeNumber(&amp;ar)
num // 9901
ar // [9901, 2]</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec47" class="calibre1"/>Creating a pointer to an existing variable</h2></div></div></div><p class="calibre8">When you create a <a id="id295" class="calibre1"/>pointer you can connect it to an existing variable with the <code class="literal">initialize </code>method. The <code class="literal">initialize</code> method would return a<a id="id296" class="calibre1"/> function that could be used to set a new value for that variable.</p><div><pre class="programlisting">var num = 10
var ar = [1, 2]

var numPtr = UnsafeMutablePointer&lt;Int&gt;.initialize(&amp;num)
numPtr(10)
num //10

var numArPtr = UnsafeMutablePointer&lt;[Int]&gt;.initialize(&amp;ar)
numArPtr([1])
ar  //[1]</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec48" class="calibre1"/>Allocating memory for the pointer</h2></div></div></div><p class="calibre8">The other way to<a id="id297" class="calibre1"/> work with pointers is to allocate a memory for them. The <code class="literal">alloc</code> method has one parameter: the number of objects it will allocate <a id="id298" class="calibre1"/>memory for. After allocating a memory for the pointer you can use it. Finally, you need to deallocate the memory used by the pointer.</p><div><pre class="programlisting">var numberPtr = UnsafeMutablePointer&lt;Int&gt;.alloc(1)
numberPtr.memory = 20
numberPtr.memory // 20
numberPtr.dealloc(1)</pre></div><p class="calibre8">
<code class="literal">UnsafeMutablePointer</code> has many useful methods that you can use, such as the <code class="literal">successor</code> and <code class="literal">predecessor</code> methods for moving pointers forward and backward, <code class="literal">subscript</code> for accessing random pointer indices, and many others.</p><p class="calibre8">You can read more about<a id="id299" class="calibre1"/> interacting with C pointers at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html</a>.</p><p class="calibre8">Now you have<a id="id300" class="calibre1"/> learned how to work with C pointers in Swift let's jump to our main goal: measuring how fast it would be to work with pointer <a id="id301" class="calibre1"/>arrays.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec49" class="calibre1"/>Comparing Swift arrays with unsafe C arrays</h2></div></div></div><p class="calibre8">For comparison, we will <a id="id302" class="calibre1"/>make an array of random numbers and sort them. The main goal is not to find the most efficient way to sort numbers in the <a id="id303" class="calibre1"/>array but to compare performance when working with C <code class="literal">UnsafePointers</code> and Swift array types.</p><p class="calibre8">First let's make a C-style variant with <code class="literal">UnsafeMutablePointer</code>:</p><div><pre class="programlisting">let count = 3_000_0
measure("C Arrays") {
  let array = UnsafeMutablePointer&lt;Int&gt;.alloc(count)
  for a in 0..&lt;count {
    array[a] = Int(arc4random())
  }
 
  // Sort
  for _ in 0..&lt;count {
    for j in 0..&lt;count - 1 {
      if array[j] &gt; array[j + 1] {
        swap(&amp;array[j], &amp;array[j + 1])
      }
    }
  }
  array.dealloc(count)
}</pre></div><p class="calibre8">The result is: <code class="literal">Average Time - 1.31680929350041</code>.</p><p class="calibre8">Now let's make the same solution by using Swift arrays:</p><div><pre class="programlisting">let count = 3_000_0
measure("Swift Arrays") {
  var array = Array(count: count, repeatedValue: 0)
 
  for i in 0..&lt;count {
    array[i] = Int(arc4random())
  }
 
  // Sort
  for _ in 0..&lt;count {
    for j in 0..&lt;count - 1 {
      if array[j] &gt; array[j + 1] {
        swap(&amp;array[j], &amp;array[j + 1])
      }
    }
  }
}</pre></div><p class="calibre8">The result is: <code class="literal">Average Time - 1.30709397329978</code>.</p><p class="calibre8">The Swift arrays have the same performance as when working with <code class="literal">UnsafePointers</code>.</p><p class="calibre8">As you can see the code looks very similar. The initialization of arrays and sort algorithms looks <a id="id304" class="calibre1"/>exactly the same in both variants. It's <a id="id305" class="calibre1"/>because both <code class="literal">Array</code> and <code class="literal">UnsafeMutablePointer</code> have a subscript method.  The only difference is in the way we create arrays:</p><p class="calibre8">For <code class="literal">UnsafeMutablePointer</code>:</p><div><pre class="programlisting">let array = UnsafeMutablePointer&lt;Int&gt;.alloc(count)
...
array.dealloc(count)</pre></div><p class="calibre8">For Swift array:</p><div><pre class="programlisting">  var array = Array(count: count, repeatedValue: 0)</pre></div><p class="calibre8">In general, Swift Array provides more functionality and it's much easier to work with. As an example, Array has sort, filter and many other methods but <code class="literal">UnsafeMutablePointer</code> doesn't.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec33" class="calibre1"/>A summary of working with pointers</h3></div></div></div><p class="calibre8">To keep it <a id="id306" class="calibre1"/>short— Swift arrays are preferred, and here is why.</p><p class="calibre8">Working with <a id="id307" class="calibre1"/>pointers is an unsafe and dangerous operation. You need to manually allocate and release memory. Accessing memory with pointers is also very dangerous because you can access other memory that doesn't belong to you.</p><p class="calibre8">UnsafePointers and Swift arrays have the same performance characteristics.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec41" class="calibre1"/>Avoiding Objective-C</h1></div></div></div><p class="calibre8">You have<a id="id308" class="calibre1"/> learned that Objective-C (with its dynamic runtime) in most cases performs more slowly than Swift. Interoperability between Swift and Objective-C is done so seamlessly that sometimes we can use Objective-C types and its runtime in the Swift code without knowing that.</p><p class="calibre8">When you use Objective-C types in Swift code, Swift is actually using the Objective-C runtime for method dispatch. Because of that, Swift can't do the same optimization as for pure Swift types. Let's have a look at a simple example:</p><div><pre class="programlisting">  for _ in 0...100 {
    _ = NSObject()
  }</pre></div><p class="calibre8">Let's read this code and make some assumptions about how the Swift compiler would optimize that code. The <code class="literal">NSObject</code> instance is never used in the loop body, so we could eliminate creating an object. After that we would have an empty loop that could also be eliminated. So we would remove all the code from execution.</p><p class="calibre8">Let's see what is happening in reality by looking at generated assembly pseudocode:</p><div><pre class="programlisting">rbx = 0x65;
  do {
    rax = [_OBJC_CLASS_$_NSObject allocWithZone:0x0];
    rax = [rax init];
    [rax release];
    rbx = rbx - 0x1;
    COND = rbx != 0x0;
  } while (COND);</pre></div><p class="calibre8">As you can see no code gets eliminated. This is happening because Objective-C types use the dynamic runtime dispatch method, called message sending.</p><p class="calibre8">All the standard Frameworks such as Foundation and UIKit are written in Objective-C and all the types—such as NSDate, NSURL, UIView, and UITableView—use the Objective-C runtime. They don't perform as fast as Swift types but we get all those frameworks available for use in Swift and this is great.</p><p class="calibre8">There is no way to remove the Objective-C dynamic runtime dispatch from the Objective-C types in Swift, so the only thing we can do is to learn how to use them wisely.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec50" class="calibre1"/>Avoiding exposing Swift to Objective-C</h2></div></div></div><p class="calibre8">We can't remove<a id="id309" class="calibre1"/> runtime behavior from Objective-C types but we can stop Swift types from using the Objective-C runtime.</p><p class="calibre8">When a Swift class inherits from an Objective-C class it also inherits its dynamic runtime behavior. This also makes it available for usage in Objective-C code. Because it inherits its dynamic behavior the Swift compiler can't perform optimal optimization (as shown in the earlier example with <code class="literal">NSObject</code> inside a loop). Let's make a simple class that inherits from Objective-C and explore its behavior:</p><div><pre class="programlisting">class MyNSObject: NSObject {
}

for _ in 0...100 {
  _ = MyNSObject()
}</pre></div><p class="calibre8">This code can't be eliminated and its assembly code looks very similar to that shown in the earlier example. We<a id="id310" class="calibre1"/> could improve that behavior very simply by removing the <code class="literal">NSObject</code> inheritance. We can do that in this example because we don't use any features from <code class="literal">NSObject</code>.</p><div><pre class="programlisting">class MyObject {
}

for _ in 0...100 {
  _ = MyObject()
}</pre></div><p class="calibre8">In that case, the Swift compiler is able to perform optimal optimization and eliminates all the code from execution. It removes the creation of the MyObject inside the loop and eliminates the empty loop afterwards.</p><p class="calibre8">As you have seen, using Objective-C classes in Swift makes the Swift compiler less powerful. Inherit and use Objective-C classes only if it's required in these cases:</p><div><ul class="itemizedlist"><li class="listitem">Expose Swift types to Objective-C</li><li class="listitem">Need to subclass from Objective-C class, such as UIView, UIViewController and so on. Subclass only when it's really required</li></ul></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec34" class="calibre1"/>Dynamic</h3></div></div></div><p class="calibre8">There is one more dangerous attribute that adds Objective-C dynamic runtime behavior to your type: the <a id="id311" class="calibre1"/>
<code class="literal">dynamic</code>
<strong class="calibre9"> </strong>keyword. When you make a member declaration with the <code class="literal">dynamic</code> modifier it adds the Objective-C runtime to the class. The access to that member will never be statically inlined and will be always dispatched dynamically by using the Objective-C Target-Action mechanism. Let's examine this simple example:</p><div><pre class="programlisting">class MyObject {
  dynamic func getName() -&gt; String {
    return "Name"
  }

  dynamic var fullName: String {
    return "Full Name"
  }
}

let object = MyObject()
object.fullName
object.getName()</pre></div><p class="calibre8">Even such a small example does quite a lot of work. Applying the <code class="literal">dynamic</code> keyword causes many issues:</p><div><ul class="itemizedlist"><li class="listitem">Dynamic message <a id="id312" class="calibre1"/>sending with <code class="literal">_objc_msgSend</code></li><li class="listitem">Type casting</li><li class="listitem">Because we <a id="id313" class="calibre1"/>use the Objective-C dynamic dispatch method, we need to convert our "Name" Swift string type into NSString; when we get a result from that function call back into Swift code we need to do one more conversion from NSString back to Swift String</li><li class="listitem">No optimization and function call inlining</li><li class="listitem">Because methods are always dispatched dynamically, the Swift compiler can't do inline optimization or eliminate empty methods</li></ul></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec51" class="calibre1"/>A summary of avoiding Objective-C</h2></div></div></div><p class="calibre8">You should <a id="id314" class="calibre1"/>avoid using Objective-C and its runtime behavior for achieving high performance.</p><p class="calibre8">You should avoid using the <code class="literal">dynamic</code>
<strong class="calibre9"> </strong>keyword at any price. You should almost never use it.</p><p class="calibre8">Inherit from a Objective-C class only when you need that class behavior, as for UIView. Use the <code class="literal">@objc</code> attribute only when you need to expose your type to Objective-C.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec42" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we have covered many topics related to Swift performance.  First we need to understand what we need to improve and enable optimization settings to get the best performance.</p><p class="calibre8">Memory usage is very important for achieving high performance. First, we covered how using constants can have a positive impact on performance. The second and more important example reflects how using value types and structures reduces memory usage and also improves performance by using fast stack memory.</p><p class="calibre8">The third important topic we have covered is dispatching methods. We have analyzed and compared both Objective-C dynamic dispatch and Swift static dispatch. By looking at the assembly code we have seen how Swift actually performs method dispatch and how it can benefit performance.</p><p class="calibre8">We have also covered some dangerous operations that could decrease performance and that should be avoided.</p><p class="calibre8">In the next chapter, we will learn more about different data structures: their differences and performance characteristics.</p></div></body></html>