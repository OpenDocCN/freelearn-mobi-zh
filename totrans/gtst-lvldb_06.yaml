- en: Chapter 6. Integrating with a Cocoa UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。与 Cocoa UI 集成
- en: 'The emphasis upto this point has been on how to program the database calls
    in C++ or Objective-C with as little user interface as possible. Now we will see
    some simple approaches to presenting that data in Cocoa applications, sufficient
    to build a full application. For the first time, our sample code will be an application
    driven by the user rather than just a series of test functions. These discussions
    assume you''re comfortable using Xcode to edit interfaces, including making connections
    to `IBOutlets` and `IBActions`. See the references at the end of this chapter
    (section: *Recommended Xcode books*) for help with Xcode.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，重点一直是如何用尽可能少的用户界面用 C++ 或 Objective-C 编程数据库调用。现在我们将看到一些在 Cocoa 应用程序中展示这些数据的一些简单方法，足以构建一个完整的应用程序。第一次，我们的示例代码将是一个由用户驱动的应用程序，而不仅仅是测试函数的一系列。这些讨论假设你熟悉使用
    Xcode 编辑界面，包括连接到 `IBOutlets` 和 `IBActions`。请参阅本章末尾的参考文献（部分：*推荐 Xcode 书籍*）以获取 Xcode
    的帮助。
- en: Meeting the data source needs with LevelDB
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LevelDB 满足数据源需求
- en: 'The problem with presenting lists of data in either `NSTableView` or `UITableView`
    is that they expect an array-like data model with two characteristics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NSTableView` 或 `UITableView` 中展示数据列表的问题在于，它们期望一个类似数组的模型，具有两个特性：
- en: The number of rows is known
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行数是已知的
- en: Row contents can be retrieved at arbitrary indexes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在任意索引处检索行内容
- en: This is not a great fit with LevelDB which doesn't know the total number of
    keys, and can only get the tenth key by stepping through the nine others before.
    The typical solution, which we use in these samples, is to copy from the database
    into an `NSArray` class, to fill the table view. This performs well for usable
    data quantities in a single scrolling table. I tested with 50,000 records like
    the 500 bundled here and it's still fast and usable on an iPhone4.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 LevelDB 不太匹配，因为 LevelDB 不了解键的总数，只能通过遍历其他九个键来获取第十个键。典型的解决方案，我们在这些示例中使用，是将数据库中的内容复制到
    `NSArray` 类中，以填充表格视图。对于单个滚动表格中的可用数据量，这表现良好。我用像这里捆绑的 50,000 条记录进行了测试，它仍然在 iPhone4
    上快速且可用。
- en: To get the full details of data associated with a given row, when the row is
    selected, you need to be able to map from a row number to a position in the data
    source. This is complicated if you allow resorting of the table by clicking headers
    or dragging and dropping new content. We will not go into a great level of detail
    with this example but the usual technique is to use an `NSMutableArray` subclass
    so that cells can be moved.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与给定行相关联的数据的完整详细信息，当行被选中时，你需要能够从行号映射到数据源中的位置。如果你允许通过点击标题或拖放新内容来重新排序表格，这将会变得复杂。在这个示例中，我们将不会深入探讨细节，但通常的技术是使用
    `NSMutableArray` 的子类，以便单元格可以被移动。
- en: While the discussion following is all about the OS X app, the iOS version is
    included online and is nearly identical, substituting `UITableview` for `NSTableview`.
    The other major difference is where to put the controller logic. In simple OS
    X apps, the `AppDelegate` is used where you would use the `ViewController` class
    in iOS apps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然接下来的讨论都是关于 OS X 应用程序的，但 iOS 版本已在线上提供，几乎完全相同，用 `UITableView` 替换了 `NSTableview`。另一个主要区别是控制器逻辑的位置。在简单的
    OS X 应用程序中，使用 `AppDelegate` 的地方，在 iOS 应用程序中你会使用 `ViewController` 类。
- en: Creating the OS X GUI
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 OS X 图形用户界面
- en: The OS X UI combines a searchable list of records with an adjacent data entry
    form to see and change the details of a record, including creating new records.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OS X 用户界面结合了一个可搜索的记录列表和一个相邻的数据输入表单，以查看和更改记录的详细信息，包括创建新记录。
- en: '![Creating the OS X GUI](img/1015OS_06_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![创建 OS X 图形用户界面](img/1015OS_06_01.jpg)'
- en: OS X sample app showing list with search results and record details
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OS X 示例应用程序显示带有搜索结果和记录详细信息的列表
- en: 'The OS X app is a single window `MainMenu06.xib` with:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OS X 应用程序是一个包含以下内容的单个窗口 `MainMenu06.xib`：
- en: An `NSTableView` class for listing records
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于列出记录的 `NSTableView` 类
- en: An `NSSearchField` class to enter searches, that triggers as you type
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `NSSearchField` 类，用于输入搜索，随着你输入而触发
- en: A series of `NSTextField` fields for editing the individual parts of the record
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列 `NSTextField` 字段，用于编辑记录的各个部分
- en: Two `NSButtons` for issuing the commands, **Save** and **New**
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 `NSButtons` 用于发出命令，**保存** 和 **新建**
- en: A menu bar with the same commands as the buttons (for example, **File** | **Save**)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个菜单栏，包含与按钮相同的命令（例如，**文件** | **保存**）
- en: It was created using the Xcode template for a new Cocoa app, not checking the
    **Document-based** option.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它是使用 Xcode 模板创建的新 Cocoa 应用程序，没有检查 **基于文档** 选项。
- en: Connecting the database to the NSTableView
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库连接到 `NSTableView`
- en: All these interface methods and outlets are in `GSwLDB06osxAppDelegate`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些界面方法和输出都在 `GSwLDB06osxAppDelegate` 中。
- en: Live searching as you type occurs automatically because the action of the `NSSearchField`
    object is connected to the `IBActionviewMatches`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入时自动进行实时搜索，因为 `NSSearchField` 对象的操作连接到 `IBActionviewMatches`
- en: The `datasource` and `delegate` outlets of the `NSTableView` class are connected
    to `GSwLDB06osxAppDelegate`, which has a corresponding outlet `tableView` referencing
    the `NSTableView` class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSTableView` 类的 `datasource` 和 `delegate` 输出连接到 `GSwLDB06osxAppDelegate`，它有一个相应的输出
    `tableView`，引用 `NSTableView` 类'
- en: 'In order to support table operations, two independent protocols were added
    to the object. `NSTableViewDelegate` is about table behaviour, responding to events
    such as editing and dragging items. The vital two methods supplying displayed
    data to the table are provided by the `NSTableViewDataSource` protocol. It is
    common, but not mandatory, for these two protocols to be satisfied by one object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持表格操作，向对象添加了两个独立的协议。`NSTableViewDelegate` 是关于表格行为，响应诸如编辑和拖动项等事件。提供显示数据的两个关键方法由
    `NSTableViewDataSource` 协议提供。这两个协议通常由一个对象满足，但这不是强制性的：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is a clear separation between this GUI delegate and a `Model` class which
    is responsible for managing a data selection and is reused in the iOS app. As
    an `NSTableViewDataSource` protocol, the delegate asks the model for data. The
    GUI knows nothing about LevelDB.The table-related methods in `GSwLDB06osxAppDelegate`
    are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 GUI 代理和负责管理数据选择并重用于 iOS 应用中的 `Model` 类之间存在明显的分离。作为一个 `NSTableViewDataSource`
    协议，代理向模型请求数据。GUI 对 LevelDB 一无所知。《GSwLDB06osxAppDelegate》中的表格相关方法包括：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The public interface of the Model is in `Sample06_Model.h`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的公共接口在 `Sample06_Model.h` 中：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Private methods and properties are added by a class extension in `Sample06_Model.m`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Sample06_Model.m` 中通过类扩展添加了私有方法和属性：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's a consistent pattern assuming that `loadListForUI` might need to be
    called at any time. Although it's just one line, it's separated out into a method
    so later code can be smarter about loading the list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `loadListForUI` 可能需要在任何时候调用。虽然它只是一行，但它被分离成一个方法，以便后续代码可以更智能地加载列表。
- en: Connecting record details to the editing form
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将记录详细信息连接到编辑表单
- en: 'The editing GUI displays details of a record next to the table, based on the
    current selection in the table. We can change records and save them back, or click
    on a different row without warning of losing our changes. The simplest editing
    behaviours are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 GUI 根据表格中的当前选择显示记录的详细信息。我们可以更改记录并保存它们，或者在不警告丢失更改的情况下点击不同的行。最简单的编辑行为包括：
- en: '**Respond** to changing table selection by displaying the details'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应** 表格选择的变化，显示详细信息'
- en: '**Save** to copy the details entered back to the database'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存** 将输入的详细信息复制回数据库'
- en: '**New** to clear the entry fields so a record can be added'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新建** 清除输入字段，以便可以添加记录'
- en: The record details are presented by the model as an `NSArray` class of `NSString`
    values, indexed by the enum `fieldOffsets`. You could think of this as a horizontal
    array, in contrast to the vertical array of keys displayed in the table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模型将记录详细信息呈现为 `NSString` 值的 `NSArray` 类，通过枚举 `fieldOffsets` 索引。你可以将其视为一个水平数组，与在表格中显示的键的垂直数组形成对比。
- en: 'Allowing and responding to **selection** changes is simple. The two selection-related
    methods declared by the protocol `NSTableViewDelegate` are also used:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 允许并响应 **选择** 变化很简单。由协议 `NSTableViewDelegate` 声明的两个选择相关方法也被使用：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Sample06_Model.m` support for the GUI knows how to map a row number from
    the GUI to a database key, as we saw, used to provide the tableview contents.
    Similar logic provides the key we now use to retrieve a database record:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample06_Model.m` 对 GUI 的支持知道如何将 GUI 中的行号映射到数据库键，正如我们所见，这用于提供表视图内容。类似的逻辑提供了我们现在用来检索数据库记录的键：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That takes care of data loading. To save we will need to send an array of fields
    back to the model and update the database. This starts with `(IBAction)saveRecord`
    in `GSwLDB06osxAppDelegate`. It calls the model''s `saveRecord` method which in
    turn uses `addRecord` to save a key of combined names with JSON for the body:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了数据加载。为了保存，我们需要将字段数组发送回模型并更新数据库。这从 `GSwLDB06osxAppDelegate` 中的 `(IBAction)saveRecord`
    开始。它调用模型的 `saveRecord` 方法，该方法反过来使用 `addRecord` 保存一个包含名称的键和 JSON 体的键：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A new action is just a GUI action clearing all the entry fields. It sets a property
    of the delegate `isNewRecord`, as you saw, used in the preceding code in `saveRecord`,
    but has no effect on the Model or leveldb. Only if you save a new record will
    the database be used.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 新的动作只是一个清除所有输入字段的 GUI 动作。它设置了代理的属性 `isNewRecord`，正如你在 `saveRecord` 中的前述代码中所见，但它对模型或
    leveldb 没有影响。只有当你保存新记录时，数据库才会被使用。
- en: Recommended Xcode books
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐的 Xcode 书籍
- en: 'The following Packt books are very straightforward with good examples walking
    you through the Xcode interface editor and explaining the table classes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Packt 出版的书籍在介绍 Xcode 界面编辑器和解释表格类时非常直接，并配有良好的示例：
- en: '*Cocoa and Objective-C Cookbook*, *Jeff Hawkins*, *Packt Publishing* for `NSTableView`
    on OS X'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Cocoa 和 Objective-C 烹饪书》*，*Jeff Hawkins*，*Packt 出版公司*，针对 OS X 上的 `NSTableView`'
- en: '*Xcode 4 Cookbook*, *Steven F Daniel*, *Packt Publishing*, for `UITableView`
    on iOS'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Xcode 4 烹饪书》*，*Steven F Daniel*，*Packt 出版公司*，针对 iOS 上的 `UITableView`'
- en: Summary
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have a good start on a real database app with a separation between the
    GUI and data model. Your understanding of adding data and searching was used in
    the model layer. We covered the needs of loading lists of records and how to show
    detailed data based on our selection. Now that we have a more complex application,
    the next chapter will show us how to use some debugging techniques to see data
    changes. After that we'll come back to `Sample06` and add a secondary index, delete,
    and more complex data updates.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经对具有 GUI 和数据模型分离的真实数据库应用程序有了良好的开端。你在模型层中使用了添加数据和搜索的理解。我们涵盖了加载记录列表的需求以及如何根据我们的选择显示详细数据。现在我们有一个更复杂的应用程序，下一章将展示我们如何使用一些调试技术来查看数据变化。之后，我们将回到
    `Sample06` 并添加二级索引、删除以及更复杂的数据更新。
