- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Beyond Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越架构
- en: In this chapter, we are going to go through a few topics that will help engineers
    build better software. Some of the topics may not be related to software architecture,
    but consideration of their usage will support and enhance better architectures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨一些有助于工程师构建更好软件的主题。其中一些主题可能不直接与软件架构相关，但考虑它们的用法将支持和增强更好的架构。
- en: After reading this chapter, engineers should be equipped with a few tricks up
    their sleeves to boost their productivity and remove impediments when implementing
    software with a certain architecture style in mind. These tools are Kotlin-related
    if implemented in code; otherwise, some of them are general engineering utilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，工程师应该掌握一些技巧，以提高他们的生产力，并在考虑特定架构风格实现软件时消除障碍。这些工具如果以代码形式实现，则与Kotlin相关；否则，其中一些是通用的工程工具。
- en: Hopefully, the conceptual understanding of all the architectural topics in previous
    chapters can be translated into practical and pragmatic solutions, with the aid
    of the toolkit in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在前几章中所有建筑主题的概念理解能够通过本章的工具箱转化为实际和实用的解决方案。
- en: 'We are going to cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Powered by Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Kotlin驱动
- en: Transitioning from Java
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java过渡
- en: Continuous integration and delivery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成和交付
- en: Developer experience matters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者体验很重要
- en: Final thoughts on software architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于软件架构的最终思考
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的所有代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15)
- en: Powered by Kotlin
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由Kotlin驱动
- en: Kotlin as a programming language has provided a lot of syntactic support for
    engineers to concisely express the intent of their code. Moreover, some of the
    features allow engineers to separate concerns and organize the code to be more
    manageable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种编程语言，Kotlin为工程师提供了大量的语法支持，使他们能够简洁地表达代码的意图。此外，一些特性允许工程师分离关注点并组织代码，使其更易于管理。
- en: Extension functions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展函数
- en: 'Kotlin extension functions allow adding extra functionalities to an existing
    class without modifying its source code. This feature is useful and even mandatory
    for the following use cases:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin扩展函数允许在不修改其源代码的情况下向现有类添加额外功能。这个特性对于以下用例非常有用，甚至可以说是必需的：
- en: 'Add more functions to a class from an external library, or a final class. For
    example, we want to extract the first letter of each word and join them by a dot,
    so `Sam Payne` would become `S.P`. The Kotlin String does not provide a function
    for this, so we can write an extension function instead:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向来自外部库或最终类的类添加更多函数。例如，我们想要提取每个单词的首字母并用点连接起来，所以`Sam Payne`将变成`S.P`。Kotlin字符串不提供这样的函数，因此我们可以编写一个扩展函数来代替：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Enhance a class to fit in certain Kotlin language features, such as operator
    override (`+`, `-`, `in`, etc.). The use of operator override will be discussed
    in detail in coming sections.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强一个类以适应某些Kotlin语言特性，例如操作符重载（`+`、`-`、`in`等）。操作符重载的使用将在后续章节中详细讨论。
- en: 'Add null safety functions to handle situations such as trying to concatenate
    a nullable list of strings. Having a nullable receiver as `List<String>?` in the
    extension function ensures that a string will be created, whether the list is
    null or not. The implementation is shown here:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向处理诸如尝试连接一个可空字符串列表等场景的函数添加空安全功能。在扩展函数中将接收者作为`List<String>?`确保，无论列表是否为空，都会创建一个字符串。实现方式如下：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, there is also a use case that would support better architecture. Extension
    functions can be used to separate concerns of a class by isolating its functions
    in a different package with non-public visibility.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在一种用例可以支持更好的架构。扩展函数可以通过将类的函数隔离到具有非公开可见性的不同包中来分离类的关注点。
- en: For example, we have the `Name` data class from the previous example. This data
    class is a domain entity that needs to be converted to different formats, depending
    on the operation’s context.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个来自上一个示例的`Name`数据类。这个数据类是一个域实体，需要根据操作上下文转换为不同的格式。
- en: 'Given that an object of the `Name` class needs to be converted to a JSON string,
    there are a few common function signature styles:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Name` 类的对象需要转换为 JSON 字符串，因此存在几种常见的函数签名样式：
- en: '`Name` class has exposed the JSON representation of the object to all usages:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name` 类已将对象的 JSON 表示暴露给所有使用场景：'
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, not all usages need this function. Business logic is unlikely to need
    the JSON representation of the object. This approach mixes up the concerns of
    business logic and external representation, and worse, this external representation
    does not apply to all situations either.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，并非所有使用场景都需要这个功能。业务逻辑不太可能需要对象的 JSON 表示。这种方法将业务逻辑和外部表示的关注点混合在一起，而且更糟糕的是，这种外部表示也不适用于所有情况。
- en: '`toJson` is now public to all projects that have access to the `Name` class:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toJson` 现在对所有可以访问 `Name` 类的项目都是公开的：'
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is functionally equivalent to the **non-local extension function** implementation;
    the difference is that the extension function moves the parameter to the function
    receiver:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它在功能上等同于**非局部扩展函数**实现；区别在于扩展函数将参数移动到函数接收者：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The vanilla function implementation creates noise when an engineer searches
    for functions whose names start with `to`, especially in an IDE and if all data
    classes have separate `toJson` functions. This phenomenon is called **scope pollution**
    as we expose functions more than necessary. A quick workaround to this is to have
    a class or a singleton Kotlin object with a member function for this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师搜索以 `to` 开头的函数名称时，原始函数实现会创建噪声，尤其是在 IDE 中，如果所有数据类都有单独的 `toJson` 函数。这种现象被称为**作用域污染**，因为我们暴露了比必要的更多函数。一个快速的解决方案是有一个类或
    Kotlin 单例对象，其中包含一个成员函数用于此目的：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, if the JSON transformation is only required for external integration,
    then it may be possible to locate the transformation functions together with the
    external integration code, and the function can be private as a **local** **extension
    function**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 JSON 转换仅适用于外部集成，那么将转换函数与外部集成代码一起定位可能是有可能的，并且函数可以作为**局部****扩展函数**是私有的：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This approach allows engineers to extend the functionality of a class while
    restricting the usage only under the context that is within the same file. In
    other words, different concerns around an entity can be separated by having local
    extension functions grouped by files in the source base.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许工程师在仅限于同一文件上下文的情况下扩展类的功能。换句话说，可以通过将源库中的本地扩展函数按文件分组来分离实体周围的不同关注点。
- en: 'This is nothing new, as a private visibility modifier to a function does exactly
    that. Nonetheless, the ability to put the data class as the receiver of a function
    and extend its behaviors brings several benefits:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是什么新东西，因为私有可见性修饰符对函数确实如此。尽管如此，将数据类作为函数的接收者并扩展其行为的能力带来了几个好处：
- en: One fewer parameter in the list
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中的参数少一个
- en: Focus on the entity as it becomes the receiver
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于实体，因为它成为接收者
- en: Call the function as if it were a member of the class
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数就像它是类的一个成员一样
- en: No need for inheritance
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需继承
- en: Fluent call chaining with other functions that are either member functions or
    extension functions
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与成员函数或扩展函数的流畅调用链
- en: Kotlin extension functions enhance the flexibility and readability of your code,
    by allowing engineers to add new functionalities to existing classes in a modular
    way. Meanwhile, there is a way to restrict the usage to avoid scope pollution
    and to separate concerns. After all, Kotlin extension functions promote better
    coding practices and make code easier to understand and maintain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 扩展函数通过允许工程师以模块化方式向现有类添加新功能，增强了代码的灵活性和可读性。同时，有一种方法可以限制使用以避免作用域污染并分离关注点。毕竟，Kotlin
    扩展函数促进了更好的编码实践，并使代码更容易理解和维护。
- en: Infix modifier
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Infix 修饰符
- en: 'A Kotlin infix modifier is another way to create more readable and expressive
    code. We discussed `When` here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的 infix 修饰符是创建更易读和更具表现力的代码的另一种方式。我们在这里讨论了 `When`：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let us define a `PreCondition` class and an `Action` class related to integer
    (`Int`) as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个与整数（`Int`）相关的 `PreCondition` 类和一个 `Action` 类，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Type aliases** in Kotlin allow engineers to create a new name for an existing
    type. They also allow engineers to quickly map a name to a function type. The
    type alias for a function type is especially beneficial in declaring interfaces
    of a single function, which helps engineers implement code that conforms to the
    **single-responsibility principle** (**SRP**), as discussed in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型别名**在 Kotlin 中允许工程师为现有类型创建新名称。它们还允许工程师快速将名称映射到函数类型。对于函数类型，类型别名在声明单个函数的接口时特别有益，这有助于工程师实现符合**单一职责原则**（**SRP**）的代码，如在第
    [*2章*](B21737_02.xhtml#_idTextAnchor045) 中讨论的。'
- en: 'It may still seem puzzling how they can look like Gherkin language for the
    BDD test scenario at this point. When we add `infix` functions, the code will
    start to support natural language:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它们看起来像 BDD 测试场景的 Gherkin 语言可能仍然令人困惑。当我们添加`infix`函数时，代码将开始支持自然语言：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`PreCondition` here is used as a return type and the receiver of another function.
    We need an implementation of `Action` and a function to verify the result to complete
    a simple test scenario:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PreCondition`用作返回类型和另一个函数的接收者。我们需要实现`Action`并有一个函数来验证结果，以完成一个简单的测试场景：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Putting them all together, we can produce a test scenario like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们全部放在一起，我们可以生成如下测试场景：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When running this line, it should throw an exception with the following message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此行时，它应该抛出一个包含以下消息的异常：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The exciting part of this example is that the infix feature from Kotlin lets
    us omit the dots for function invocation and the brackets for the single parameter
    for each infix function. So, the code becomes remarkably close to natural language
    and the Gherkin language syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例令人兴奋的部分是，Kotlin 的中缀特性让我们可以省略函数调用的点和中缀函数单个参数的括号。因此，代码变得非常接近自然语言和 Gherkin
    语言语法：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, it would take a long time to have a fully-fledged Gherkin-style code
    for BDD test scenarios from this point beyond. However, this example has demonstrated
    how Kotlin infix functions can make the code readable and expressive.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从这个点开始，要有一个完整的 Gherkin 风格的 BDD 测试场景代码将需要很长时间。然而，这个例子已经展示了 Kotlin 中缀函数如何使代码可读和表达。
- en: 'There are some ground rules for having an infix function in Kotlin to follow:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中拥有中缀函数有一些基本规则需要遵循：
- en: It is either a member function of a class or an extension function with a receiver
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是类的一个成员函数或一个带有接收者的扩展函数
- en: There can only be one parameter
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能有一个参数
- en: Infix functions are usually used in building intuitive and readable **domain-specific
    languages** (**DSLs**). They are used a lot in chaining operations, such as the
    example we have just demonstrated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 中缀函数通常用于构建直观和可读的**领域特定语言**（**DSL**）。它们在链式操作中用得很多，例如我们刚刚演示的例子。
- en: Operator override
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符重载
- en: 'The operator override is another way to make your code readable and intuitive.
    It allows engineers to define custom behaviors for operators such as `+`, `-`,
    and so on. The syntax was already shown previously when we discussed extension
    functions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符重载是使您的代码可读性和直观性的另一种方法。它允许工程师为`+`、`-`等运算符定义自定义行为。当我们在讨论扩展函数时，已经展示了语法：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `operator` modifier before the `fun` keyword indicates the intention to
    override a built-in operator. The return type needs to be the same as the receiver
    or the belonging class. All operators that can be overridden are listed in *Table
    15.1*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fun`关键字之前使用`operator`修饰符表示要重载内置运算符。返回类型需要与接收者或所属类相同。所有可以重载的运算符都列在*表 15.1*中：
- en: '| **Operator** | **Function name** | **Example** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **函数名** | **示例** |'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE49]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE50]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE53]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE55]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE56]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 15.1 – Kotlin operators that can be overridden
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.1 – Kotlin 可以重载的运算符
- en: It is important that operators are overridden with compatible semantics. For
    example, the `+` operator should create a new instance of the type with the two
    objects of the same type combined. If the `plus` function has side effects such
    as updating the value of an existing object, then it is not appropriate to override
    the operator.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符的重载需要具有兼容的语义。例如，`+`运算符应该创建一个新实例，该实例由相同类型的两个对象组合而成。如果`plus`函数有副作用，例如更新现有对象的值，那么重载运算符是不合适的。
- en: Scoping functions
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域函数
- en: Scoping functions in Kotlin execute a block of code within the context of an
    object. A scope starts with an opening curly bracket, `{`, and ends with a closing
    curly bracket, `}`, which is already natural to programming languages. We already
    have class scopes, function scopes, and lambda scopes, all of which use curly
    brackets to indicate the boundaries. Also, the inner scopes have visibility and
    access to the declared values and functions from the enclosing scopes. For example,
    a member function has access to other functions from its encompassing class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的作用域函数在对象的上下文中执行代码块。作用域从开括号 `{` 开始，以闭括号 `}` 结束，这对编程语言来说已经很自然了。我们已经有类作用域、函数作用域和
    lambda 作用域，所有这些作用域都使用括号来表示边界。此外，内部作用域可以访问外部作用域中声明的值和函数。例如，成员函数可以访问其包含类中的其他函数。
- en: Built-in scoping functions
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置作用域函数
- en: 'Scoping functions in Kotlin provide another means to have a confined scope
    that focuses on a context object. There are five scoping functions provided, as
    shown in *Figure 15**.1*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的作用域函数提供了另一种拥有有限作用域的方法，该作用域专注于上下文对象。提供了五个作用域函数，如图 *图15.1* 所示：
- en: '![Figure 15.1 – Kotlin built-in scoping functions](img/B21737_15_1.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – Kotlin 内置作用域函数](img/B21737_15_1.jpg)'
- en: Figure 15.1 – Kotlin built-in scoping functions
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – Kotlin 内置作用域函数
- en: Each of the five scoping functions (`let`, `apply`, `run`, `with`, and `also`)
    has its own use case and behavior. There are two main differences among them.
    The first difference is whether the context object is `it` or `this`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 五个作用域函数（`let`、`apply`、`run`、`with` 和 `also`）各有其用途和行为。它们之间有两个主要区别。第一个区别是上下文对象是
    `it` 还是 `this`。
- en: 'The following three statements return the same result of `"35"`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个语句返回相同的 `"35"` 结果：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `let` function uses `it` as the context object, while `run` and `with` use
    `this` as the context object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 函数使用 `it` 作为上下文对象，而 `run` 和 `with` 使用 `this` 作为上下文对象。'
- en: It is also noticeable that `run` and `with` are functionally equivalent, but
    the syntax is different. The `run` function is an extension function, while `with`
    is a top-level function. Engineers can make use of the difference to communicate
    the intent of the usage. Typically, the context object is the focus of the operation
    when using the `run` function. If another object is the focus of the operation,
    the `with` function can be used instead.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，`run` 和 `with` 在功能上是等价的，但语法不同。`run` 函数是一个扩展函数，而 `with` 是一个顶层函数。工程师可以利用这种差异来传达使用意图。通常，当使用
    `run` 函数时，上下文对象是操作的重点。如果另一个对象是操作的重点，则可以使用 `with` 函数。
- en: 'The second difference is whether the result of the lambda or the receiver is
    returned. This is like a peeking function where engineers want to insert an extra
    operation but do not want to alter the result. The following two statements return
    the same result of `"3"`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是 lambda 或接收者的结果是否返回。这就像是一个窥视函数，工程师想要插入一个额外的操作，但不想改变结果。以下两个语句返回相同的 `"3"`
    结果：
- en: '[PRE58]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Any output evaluated in the lambda expressions is not used as return values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lambda 表达式中评估的任何输出都不用作返回值。
- en: Custom scoping functions
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义作用域函数
- en: Writing your own scoping functions can bring powerful features to your system.
    It is particularly useful in building up a result within a predefined scope. It
    is often that a system is required to perform a full validation on an incoming
    request and report all validation failures in the response.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自己的作用域函数可以为您的系统带来强大的功能。这在构建预定义作用域内的结果时尤其有用。通常情况下，系统需要在一个传入请求上执行全面验证，并在响应中报告所有验证失败。
- en: 'We need a builder class that can accumulate validation errors, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个可以累积验证错误的构建器类，如下所示：
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `ValidationBuilder` class uses a mutable list of String to collect all
    validation errors found in the process. Then, we can define a custom scoping function
    that defines the start and the end of the validation, and validation is performed
    within the scope:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationBuilder` 类使用可变字符串列表来收集在过程中找到的所有验证错误。然后，我们可以定义一个自定义作用域函数，该函数定义验证的开始和结束，并在作用域内执行验证：'
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This scoping function is an extension function using a generic type as the receiver,
    so the `validate` function can be invoked on any object. It takes a lambda expression
    as a parameter, in which an instance of `ValidationBuilder` is passed as a context
    object identified by `this`. At the end of the `validate` function, all errors
    collected are returned as an immutable `List`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此作用域函数是一个使用泛型类型作为接收器的扩展函数，因此可以在任何对象上调用`validate`函数。它接受一个lambda表达式作为参数，其中将`ValidationBuilder`实例作为通过`this`标识的上下文对象传递。在`validate`函数的末尾，所有收集的错误都作为不可变的`List`返回。
- en: 'An example usage can look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例用法可能如下所示：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is a simple validation on a `String` object with two rules:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对`String`对象进行的简单验证，包含两个规则：
- en: Must be less than 20 characters
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须少于20个字符
- en: Must not contain the percent sign, `%`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能包含百分号，`%`
- en: 'The validation starts with the `String` object with the `validate` extension
    function. Inside the lambda scope, the `evaluate` function is called twice with
    the evaluations and the error messages. `ValidationBuilder` collects error messages
    if the evaluation has failed. A list of validation errors is returned and printed
    to the console. The console should have the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 验证从具有`validate`扩展函数的`String`对象开始。在lambda作用域内，`evaluate`函数被调用两次，用于评估和错误消息。如果评估失败，`ValidationBuilder`会收集错误消息。返回一个验证错误列表并打印到控制台。控制台应该有如下输出：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The output has shown how full validation can be performed on a string with the
    custom scoping function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了如何使用自定义作用域函数对字符串执行完整验证。
- en: 'Custom scoping functions are also popular with complex object building, such
    as a large domain object. In fact, it is used in the popular framework **Ktor**
    to build the server-side routing configuration:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义作用域函数在构建复杂对象，如大型域对象时也很受欢迎。实际上，它在流行的框架**Ktor**中用于构建服务器端路由配置：
- en: '[PRE63]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We have demonstrated the use of a custom scoping function to perform full validation
    and collect all validation errors. Custom scoping functions are particularly useful
    in collecting elements within the scope, with the builder passed in as a context
    object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了使用自定义作用域函数来执行完整验证并收集所有验证错误的方法。自定义作用域函数在收集作用域内的元素时特别有用，其中传递给构建器的对象作为上下文对象。
- en: We are going to cover the topic of transitioning from Java to Kotlin in the
    next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍从Java过渡到Kotlin的主题。
- en: Transitioning from Java
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Java过渡
- en: Kotlin as a programming language was developed by JetBrains, a software company
    known for software development tools such as IntelliJ IDEA. The project started
    in 2010 and it aimed to create a language that is compatible with Java but with
    improvements over some of the drawbacks of Java. The name *Kotlin* comes from
    Kotlin Island in the Baltic Sea near St. Petersburg, Russia.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种编程语言，Kotlin由JetBrains开发，这是一家以IntelliJ IDEA等软件开发工具而闻名的软件公司。该项目始于2010年，旨在创建一种与Java兼容但改进了Java一些缺点的新语言。名称*Kotlin*来自俄罗斯圣彼得堡附近波罗的海的科特林岛。
- en: Kotlin 1.0 was released in July 2011 with features such as null safety, static
    typing, and type inference. It started to gain popularity in 2016 when it introduced
    features such as 100% Java interoperability, extension functions, lambda expressions,
    and higher-order functions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 1.0于2011年7月发布，具有null安全、静态类型和类型推断等功能。它在2016年引入了100% Java互操作性、扩展函数、lambda表达式和高级函数等特性后开始流行。
- en: In 2017, Google announced official support for Kotlin on Android. Google’s collaboration
    with JetBrains on Kotlin supporting Android has made Kotlin a popular choice for
    Android developers. In 2018, JetBrains introduced Kotlin Multiplatform, which
    enables Kotlin code to be translated and compiled to run in Android, iOS, and
    web applications. Around the same time, Kotlin for backend services gained more
    and more attention from backend engineers, especially those with a Java background.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，谷歌宣布正式支持Kotlin在Android上的使用。谷歌与JetBrains合作支持Kotlin在Android上的使用，使Kotlin成为Android开发者的热门选择。2018年，JetBrains推出了Kotlin
    Multiplatform，它使得Kotlin代码可以翻译和编译为在Android、iOS和Web应用程序中运行。大约在同一时间，Kotlin后端服务开始受到越来越多的后端工程师的关注，尤其是那些有Java背景的工程师。
- en: The 100% Java interoperability has enabled many Java engineers to smoothly transition
    to writing Kotlin code for commercial applications. There are a few tools and
    tips that we are going to share with you.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 100%的Java互操作性使得许多Java工程师能够顺利过渡到为商业应用编写Kotlin代码。我们将与您分享一些工具和技巧。
- en: The IntelliJ IDEs from JetBrains have provided a tool to convert a Java file
    code to a Kotlin file code. It might sound magical, but the reality is that there
    are still a couple more adjustments needed to be truly idiomatic Kotlin.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains的IntelliJ IDEs提供了一个工具，可以将Java文件代码转换为Kotlin文件代码。这听起来可能很神奇，但现实是，仍然需要做一些调整才能使Kotlin代码真正符合规范。
- en: Enabling Kotlin in a Java project
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java项目中启用Kotlin
- en: Given that there is a Java project already, we need to set up the project to
    compile Kotlin source code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经有一个Java项目，我们需要设置项目以编译Kotlin源代码。
- en: 'If the project uses Gradle, adding a Kotlin plugin is sufficient, such as the
    following code with Gradle Kotlin DSL:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目使用Gradle，添加Kotlin插件就足够了，例如以下使用Gradle Kotlin DSL的代码：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is the equivalent of the setting with Gradle Groovy:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Gradle Groovy的设置等效：
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Projects using Maven would require the following changes in `pom.xml`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven的项目需要在`pom.xml`中进行以下更改：
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding configuration defines the Kotlin version as `2.0.20`. Also, it
    imports a plugin that enables the compilation of Kotlin source code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置将Kotlin版本定义为`2.0.20`。它还导入了一个插件，该插件启用了对Kotlin源代码的编译。
- en: Converting Java files and moving them to Kotlin folders
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换Java文件并将它们移动到Kotlin文件夹
- en: Kotlin files can be located under the `src/main/java` and `src/test/java` folders,
    but it is recommended to have them stored under `src/main/kotlin` and `src/test/kotlin`,
    respectively.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin文件可以位于`src/main/java`和`src/test/java`文件夹下，但建议分别存储在`src/main/kotlin`和`src/test/kotlin`。
- en: 'Let us convert the following Java class to Kotlin, using IntelliJ’s conversion
    tool:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用IntelliJ的转换工具将以下Java类转换为Kotlin：
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This Java class is immutable, so all fields are private, and the list is not
    exposed in the getter for immutability. As you convert the Java file using the
    conversion tool, IntelliJ reminds you that some corrections still need to be made.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Java类是不可变的，所以所有字段都是私有的，列表在getter中也没有暴露以保证不可变性。当你使用转换工具转换Java文件时，IntelliJ会提醒你还需要进行一些修正。
- en: 'This is the Kotlin class after conversion by the tool (in IntelliJ, right-click
    the Java file and choose **Convert Java File to** **Kotlin File**):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是工具转换后的Kotlin类（在IntelliJ中，右键单击Java文件并选择**Convert Java File to** **Kotlin File**）：
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There are some immediate changes to be made to become an idiomatic Kotiln class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成为一个符合规范的Kotlin类，有一些立即需要做出的更改：
- en: Update to a Kotlin data class since this class is intended to be an entity class.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新为Kotlin数据类，因为这个类打算作为一个实体类。
- en: Replace the `init` block with a constructor as much as possible. Only true initialization
    logic should remain in the `init` block.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能地将`init`块替换为构造函数。只有真正的初始化逻辑应该保留在`init`块中。
- en: Use Kotlin’s immutable `List` interface as a member field. The same should apply
    to other `Collection` interfaces. Using Kotlin’s collection interfaces closes
    off the risks of the collection being mutated.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Kotlin的不可变`List`接口作为成员字段。同样的规则也应该适用于其他`Collection`接口。使用Kotlin的集合接口可以消除集合被修改的风险。
- en: Remove the `getMembers` getter function as there is no need to return a new
    copy of the list due to the immutable `List` interface.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于不可变的`List`接口，不需要返回列表的新副本，因此可以移除`getMembers`getter函数。
- en: Remove the nullable symbol (`?`) unless there is a reason to expect nullable
    values. This is an opportunity for engineers to eliminate null checks that become
    unnecessary after converting to Kotlin.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非有理由预期可能为null的值，否则请移除可空符号（`?`）。这是工程师们消除在转换为Kotlin后变得不必要的null检查的机会。
- en: 'This is the result of the conversion, which started with the tool and ended
    with some manual corrections:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是转换的结果，它从工具开始，以一些手动修正结束：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the Java entity class was using an external library such as Lombok ([https://projectlombok.org/](https://projectlombok.org/))
    to auto-generate setter and getter functions, then we would need to remove the
    Lombok annotations, too.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Java实体类使用了像Lombok([https://projectlombok.org/](https://projectlombok.org/))这样的外部库来自动生成setter和getter函数，那么我们也需要移除Lombok注解。
- en: 'Java 14 has introduced a new feature called **record classes** that work like
    Kotlin data classes. An example of a Java record class is shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Java 14引入了一个名为**record classes**的新特性，它的工作方式类似于Kotlin数据类。这里展示了一个Java记录类的示例：
- en: '[PRE70]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Converting it to Kotlin is relatively straightforward, but there is a `JvmRecord`
    annotation that remains:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为Kotlin相对简单，但有一个`JvmRecord`注解保留了下来：
- en: '[PRE71]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The annotation is only there to preserve some of the function names such as
    `account.getNumber()` for backward compatibility reasons. If this is not a concern,
    we can remove this annotation and let users of this class use `account.number`
    instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注释仅用于保留一些函数名称，例如 `account.getNumber()` 以便向后兼容。如果这不是一个关注点，我们可以删除这个注释，并让这个类的用户使用
    `account.number` 代替。
- en: Idiomatic expressions, code styling, and conventions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惯用表达式、代码风格和约定
- en: 'Converting a Java file to a Kotlin file is a great opportunity for engineers
    to start adopting Kotlin’s idiomatic expressions and conventions. It is highly
    recommended that the engineers pick a lint tool to unify the Kotlin style from
    the beginning:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 文件转换为 Kotlin 文件是工程师开始采用 Kotlin 的惯用表达式和约定的绝佳机会。强烈建议工程师从开始就选择一个 lint 工具来统一
    Kotlin 风格：
- en: Ktlint ([https://github.com/pinterest/ktlint](https://github.com/pinterest/ktlint))
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ktlint ([https://github.com/pinterest/ktlint](https://github.com/pinterest/ktlint))
- en: KtFmtFormat ([https://github.com/facebook/ktfmt](https://github.com/facebook/ktfmt))
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KtFmtFormat ([https://github.com/facebook/ktfmt](https://github.com/facebook/ktfmt))
- en: Detekt ([https://github.com/detekt/detekt](https://github.com/detekt/detekt))
    – also a static code analysis tool
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Detekt ([https://github.com/detekt/detekt](https://github.com/detekt/detekt))
    – 同样也是一个静态代码分析工具
- en: Spotless ([https://github.com/diffplug/spotless](https://github.com/diffplug/spotless))
    – also supports other languages
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spotless ([https://github.com/diffplug/spotless](https://github.com/diffplug/spotless))
    – 也支持其他语言
- en: Picking the “best” code style is the least concern to engineering quality, but
    having a unified style is important for the team to focus on more important aspects
    such as correctness and responsiveness.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“最佳”代码风格对工程质量的关注最少，但拥有统一风格对于团队集中精力在更重要方面（如正确性和响应性）非常重要。
- en: Sequence of conversion
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换顺序
- en: 'Given an existing Java project, it is also recommended to convert Java classes
    in the following sequence:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有的 Java 项目，也建议按以下顺序转换 Java 类：
- en: Test classes as these represent the lowest risk. This is a safe space for engineers
    to learn Kotlin and make mistakes with a low impact.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试类，因为这些代表最低风险。这是一个工程师学习 Kotlin 和犯错误影响较低的安全空间。
- en: Top-level classes that no other classes depend on.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有其他类依赖的顶层类。
- en: If the application uses layered architectures, as covered in [*Chapter 7*](B21737_07.xhtml#_idTextAnchor255),
    classes in the outer layers (i.e., adapters, imperative shells, frameworks, and
    drivers) should be converted first, then go inward until reaching the code. The
    Kotlin interoperability with Java is smoother when Kotlin code calls Java code
    than vice versa.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序使用分层架构，如第 [*第 7 章*](B21737_07.xhtml#_idTextAnchor255) 中所述，则应首先转换外层（即适配器、命令壳、框架和驱动器）中的类，然后向内转换，直到达到代码。当
    Kotlin 代码调用 Java 代码时，与 Java 的 Kotlin 兼容性比反过来更平滑。
- en: During the conversion, engineers often start looking to replace frameworks in
    Java with equivalent libraries in Kotlin; we are going to discuss these in the
    next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换过程中，工程师通常会开始寻找用 Kotlin 中的等效库替换 Java 中的框架；我们将在下一节讨论这些内容。
- en: Framework replacement
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架替换
- en: 'During the conversion journey, it is inevitable that someone will bring up
    the discussion of whether a Java library should be replaced by another library
    that supports native Kotlin. We discussed the paradox of new frameworks in [*Chapter
    1*](B21737_01.xhtml#_idTextAnchor013), and on the specific topic of conversion
    from Java to Kotlin, there are a few things we should keep in mind:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换之旅中，不可避免地会有人提出讨论是否应该用支持原生 Kotlin 的库替换 Java 库。我们在 [*第 1 章*](B21737_01.xhtml#_idTextAnchor013)
    中讨论了新框架的悖论，在从 Java 到 Kotlin 的转换具体话题上，我们应该注意以下几点：
- en: Everything still works! It seems obvious but the team could choose not to replace
    any existing framework, due to the 100% Java interoperability.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切仍然正常工作！这似乎很明显，但团队可以选择不替换任何现有框架，因为 Java 兼容性达到 100%。
- en: This is likely a one-way trip. The new Kotlin library may not aim to support
    Java projects, except those libraries that already existed before Kotlin became
    popular. If the project still uses Java but needs to use the new Kotlin library
    with Java, the usage may be awkward.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能是一次单程之旅。新的 Kotlin 库可能并不旨在支持 Java 项目，除非这些库在 Kotlin 流行之前就已经存在。如果项目仍然使用 Java
    但需要使用新的 Kotlin 库与 Java 一起使用，使用可能会显得尴尬。
- en: There are multiple Kotlin libraries that the open source community has contributed
    to provide a Kotlin-first library experience. Some of them look similar in terms
    of approaches, activities, and number of contributors. The team may fall into
    the paralysis of analysis, not knowing which one to use. This is more of a general
    open source framework adoption concern, but it affects transitioning from Java
    to Kotlin.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源社区已经贡献了多个Kotlin库，以提供以Kotlin为主的库体验。其中一些在方法、活动和贡献者数量方面看起来很相似。团队可能会陷入分析瘫痪，不知道该使用哪一个。这更多的是一个普遍的开源框架采用问题，但它影响了从Java到Kotlin的过渡。
- en: It is not uncommon for contributors to stop some of the efforts for Kotlin-first
    newer frameworks. It is a natural evolution where some of the ideas have turned
    out to be not so viable or feasible. The team can always wait till the Kotlin-first
    library matures. Again, this is a concern for open source projects in general.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于贡献者来说，停止一些Kotlin为主的较新框架的努力并不罕见。这是一个自然的演变，其中一些想法最终证明并不可行或可行。团队可以始终等待Kotlin为主的库成熟。再次强调，这是一个普遍的开源项目关注的问题。
- en: Some of the existing Java frameworks have Kotlin support as an extra dependency
    to help engineers with the transition. The Kotlin module may just be enough and
    there is no need to phase out the framework altogether.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些现有的Java框架将Kotlin支持作为一个额外依赖项，以帮助工程师进行过渡。Kotlin模块可能就足够了，没有必要完全淘汰该框架。
- en: Kotlin-first frameworks developed by popular communities or reputable organizations
    supporting Kotlin are likely to have stronger support and continuity.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由受欢迎的社区或值得信赖的组织开发的以Kotlin为主的框架可能具有更强的支持和连续性。
- en: 'Despite the numerous factors for framework replacement, there are a few Kotlin-first
    frameworks that are worth a look:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有众多框架替换的因素，但有一些以Kotlin为主的框架值得关注：
- en: '**Client and** **server frameworks**:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端和** **服务器框架**:'
- en: 'Spring: [https://spring.io/](https://spring.io/)'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spring: [https://spring.io/](https://spring.io/)'
- en: 'Ktor: [https://ktor.io/](https://ktor.io/)'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ktor: [https://ktor.io/](https://ktor.io/)'
- en: 'Http4K: [https://www.http4k.org/](https://www.http4k.org/)'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Http4K: [https://www.http4k.org/](https://www.http4k.org/)'
- en: 'Micronaut: [https://micronaut.io/](https://micronaut.io/)'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Micronaut: [https://micronaut.io/](https://micronaut.io/)'
- en: 'Vert.x: [https://github.com/vert-x3/vertx-lang-kotlin](https://github.com/vert-x3/vertx-lang-kotlin)'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Vert.x: [https://github.com/vert-x3/vertx-lang-kotlin](https://github.com/vert-x3/vertx-lang-kotlin)'
- en: 'Retrofit: [https://square.github.io/retrofit/](https://square.github.io/retrofit/)'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Retrofit: [https://square.github.io/retrofit/](https://square.github.io/retrofit/)'
- en: '**Language** **enhancement frameworks**:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言增强框架**:'
- en: 'Arrow: [https://arrow-kt.io/](https://arrow-kt.io/)'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Arrow: [https://arrow-kt.io/](https://arrow-kt.io/)'
- en: 'Result4K: [https://github.com/npryce/result4k](https://github.com/npryce/result4k)'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Result4K: [https://github.com/npryce/result4k](https://github.com/npryce/result4k)'
- en: 'Coroutines: [https://github.com/Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Coroutines: [https://github.com/Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)'
- en: '**Dependency** **injection frameworks**:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入框架**:'
- en: 'Koin: [https://insert-koin.io/](https://insert-koin.io/)'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Koin: [https://insert-koin.io/](https://insert-koin.io/)'
- en: '**Persistence frameworks**:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化框架**:'
- en: 'Exposed: [https://github.com/JetBrains/Exposed](https://github.com/JetBrains/Exposed)'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Exposed: [https://github.com/JetBrains/Exposed](https://github.com/JetBrains/Exposed)'
- en: '**Testing frameworks**:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试框架**:'
- en: 'Kotest: [https://kotest.io/](https://kotest.io/)'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kotest: [https://kotest.io/](https://kotest.io/)'
- en: 'Spek: [https://www.spekframework.org/](https://www.spekframework.org/)'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spek: [https://www.spekframework.org/](https://www.spekframework.org/)'
- en: 'Mockk: [https://mockk.io/](https://mockk.io/)'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mockk: [https://mockk.io/](https://mockk.io/)'
- en: '**UI frameworks**:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI框架**:'
- en: 'Jetpack: [https://developer.android.com/jetpack](https://developer.android.com/jetpack)'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jetpack: [https://developer.android.com/jetpack](https://developer.android.com/jetpack)'
- en: 'Compose Multiplatform: [https://github.com/JetBrains/compose-multiplatform](https://github.com/JetBrains/compose-multiplatform)'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Compose Multiplatform: [https://github.com/JetBrains/compose-multiplatform](https://github.com/JetBrains/compose-multiplatform)'
- en: Continuous transition
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续过渡
- en: One of the challenges of transitioning to Kotlin is the combination with other
    changes, driven by business or technical stakeholders.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 转向Kotlin的一个挑战是与其他变化的结合，这些变化是由业务或技术利益相关者推动的。
- en: It is important that the transition to Kotlin takes place incrementally and
    continuously. For example, a new business feature can be written in Kotlin entirely,
    with some usage of existing Java classes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，转向Kotlin的过程应该是渐进的和持续的。例如，一个新业务功能可以完全用Kotlin编写，同时使用一些现有的Java类。
- en: Engineers can also phase in Kotlin converted code when there is sufficient time
    and space, even during the development of other changes. The team can adopt a
    policy that, if a Java class needs to be updated, it is also converted to Kotlin.
    This policy adds a small overhead to each change, but it keeps the transition
    going without the need to halt.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当有足够的时间和空间时，工程师们也可以逐步引入 Kotlin 转换后的代码，甚至在开发其他更改的过程中也是如此。团队可以采取一项政策，即如果需要更新 Java
    类，它也将被转换为 Kotlin。这项政策为每次更改添加了少量的开销，但可以保持过渡的连续性，而无需停止。
- en: Keeping risks manageable is the key to transitioning a Java project to Kotlin.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 保持风险可控是将 Java 项目迁移到 Kotlin 的关键。
- en: The future of Kotlin
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin 的未来
- en: Kotlin has grown out from being a better Java. Especially with Kotlin Multiplatform,
    Kotlin has become one of the most versatile programming languages in the market,
    as it can be used to write Android, iOS, desktop, web, data science, and backend
    applications. With the recent Kotlin V2 release, Kotlin continues to grow in popularity
    and usage. Engineers should keep an eye on Kotlin’s emerging trends (e.g., Kotlin
    Multiplatform, Kotlin Native, and cloud integration) and embrace its exciting
    upcoming progression.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 已经从仅仅是一个更好的 Java 语言发展而来。特别是随着 Kotlin Multiplatform 的推出，Kotlin 已经成为市场上最灵活的编程语言之一，因为它可以用来编写
    Android、iOS、桌面、Web、数据科学和后端应用程序。随着 Kotlin V2 的最新发布，Kotlin 的流行度和使用率仍在持续增长。工程师们应该关注
    Kotlin 的新兴趋势（例如 Kotlin Multiplatform、Kotlin Native 和云集成），并拥抱其令人兴奋的即将到来的进步。
- en: Next, we will discuss continuous integration and delivery.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论持续集成和交付。
- en: Continuous integration and delivery
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和交付
- en: '**Continuous integration** (**CI**) and **continuous delivery** (**CD**) play
    a crucial role in software development productivity. They are collectively named
    **CI/CD** in many discussions due to their close relationship.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）和**持续交付**（**CD**）在软件开发生产力中发挥着至关重要的作用。由于它们之间紧密的关系，在许多讨论中它们被统称为
    **CI/CD**。'
- en: When we discussed the cost of finding and fixing an issue with an application
    in [*Chapter 13*](B21737_13.xhtml#_idTextAnchor418), we mentioned that the cost
    to fix an issue is lower if it is found earlier in the development process. In
    a typical environment in which a team of engineers work collaboratively on a source
    repository, it is also less expensive to fix an issue that is caused by code conflicts
    from this collaboration.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第 13 章*](B21737_13.xhtml#_idTextAnchor418)中讨论了发现和修复应用程序问题的成本时，我们提到，如果在开发过程中早期发现问题，修复问题的成本会更低。在一个典型的环境中，工程师团队协作在源代码库上工作时，由于代码冲突而引起的问题修复成本也较低。
- en: 'CI is a software development practice in which engineers frequently integrate
    their changes into a shared source repository. The primary goal of CI is to detect
    integration issues early and reduce the time it takes to release new features
    or fixes. The practice of CI includes the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一种软件开发实践，工程师们频繁地将他们的更改集成到一个共享的源代码库中。CI 的主要目标是早期发现集成问题，并减少发布新功能或修复所需的时间。CI
    的实践包括以下内容：
- en: '**Frequent commits**: Changes are frequently committed by multiple engineers
    in a team. Each engineer also frequently updates their local source project to
    receive changes from other team members. The commits are as frequent as multiple
    times a day.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁提交**：团队成员频繁提交更改。每个工程师也频繁更新他们的本地源项目以接收其他团队成员的更改。提交的频率可能高达每天多次。'
- en: '**Automated project builds**: Each commit integrates with the source repository
    and triggers an automated build to compile all source code.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动项目构建**：每次提交都会与源代码库集成，并触发自动构建以编译所有源代码。'
- en: '**Automated testing and feedback**: Each commit also triggers an automated
    test suite that includes a diverse variety of tests and quality assurance metrics,
    as discussed in *Chapters 12*, *13*, and *14*:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试和反馈**：每次提交还会触发一个自动化测试套件，包括各种测试和质量保证指标，如在第 12、13 和 14 章中所述：'
- en: Unit tests
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Component tests
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件测试
- en: Integration tests
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Automated GUI testing
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化 GUI 测试
- en: End-to-end testing
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Performance testing
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Code vulnerability scanning
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码漏洞扫描
- en: Code style linting
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码风格检查
- en: Static code analysis
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Code coverage by tests
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: These test checks are part of the project build after code compilation. If any
    of the preceding checks fails the verification, the project build will fail and
    engineers will be notified. Engineers will then troubleshoot and fix the issue
    based on the feedback.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些测试检查是代码编译后项目构建的一部分。如果任何前面的检查失败，项目构建将失败，并且工程师将被通知。工程师将根据反馈进行故障排除并修复问题。
- en: '**Version control**: CI uses a version control system to manage the code base.
    It supports keeping a full history of commits with audit records. It allows engineers
    to branch from the main code repository and later merge the branch back to the
    main branch.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：CI使用版本控制系统来管理代码库。它支持保留提交的完整历史记录和审计记录。它允许工程师从主代码仓库分支，并在稍后将其合并回主分支。'
- en: '**Integration with deployment**: CI is the first gate of quality that certifies
    whether an application is good enough for deployment. Once all checks and tests
    have passed, then the build process can continue the preparation for deployment.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与部署的集成**：CI是质量的第一道门，它认证应用程序是否足够好以进行部署。一旦所有检查和测试都通过，构建过程就可以继续为部署做准备。'
- en: By shortening the feedback loop of *code-integrate-test-fix*, the team can deliver
    new features and fixes more frequently, reduce the time to market, and respond
    to user feedback quickly. It also improves the collaboration within the team and
    improves overall software quality through automated testing for each integration.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过缩短*代码集成-测试-修复*的反馈循环，团队可以更频繁地交付新特性和修复，缩短上市时间，并快速响应用户反馈。它还通过为每次集成进行自动化测试来提高团队内的协作，并提高整体软件质量。
- en: 'There is, however, another significant factor that would affect software development
    productivity. Most engineers who work in a team would have discussed the topic
    of branching strategies under a version control system. There are two popular
    strategies that keep on recurring in this never-ending debate: feature-based and
    trunk-based development.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个重要的因素会影响软件开发的生产力。大多数在团队中工作的工程师都会讨论在版本控制系统下的分支策略问题。在这个永无止境的辩论中，有两种流行的策略不断出现：基于特性的开发和主干开发。
- en: Feature-based development
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于特性的开发
- en: 'Feature-based development can be characterized by its higher number and longer
    life of branches. Engineers can work in on their own branch in isolation. Each
    branch contains a big chunk of cohesive work, such as a feature or a release,
    and therefore, it lasts for a long period to gather all the changes required.
    At the same time, there are other long-lived branches that represent other features.
    An example of feature-based development is shown in *Figure 15**.2*:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 基于特性的开发可以以其较高的分支数量和较长的生命周期为特征。工程师可以在自己的分支上独立工作。每个分支包含一大块连贯的工作，如特性或发布，因此它持续较长时间以收集所有必需的更改。同时，还有其他长期存在的分支代表其他特性。基于特性的开发的一个示例在*图15**.2*中展示：
- en: '![Figure 15.2 – An example of feature-based development](img/B21737_15_2.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 – 基于特性的开发示例](img/B21737_15_2.jpg)'
- en: Figure 15.2 – An example of feature-based development
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – 基于特性的开发示例
- en: In this example, **Trunk** is the main branch that absorbs all changes from
    other branches. **Feature 1** branches out from **Trunk** and development continues
    in this feature branch. At the same time, the team needs to prepare a new release,
    so the **Release 1** branch is created from **Trunk**. The release branch is deployed
    to the UAT environment for acceptance testing as a release candidate.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**主干**是吸收来自其他分支所有更改的主要分支。**特性1**从**主干**分支出来，并在该特性分支中继续开发。同时，团队需要准备一个新的发布，因此从**主干**创建了**发布1**分支。发布分支作为发布候选部署到UAT环境进行验收测试。
- en: After a few commits in the **Feature 1** branch, **Feature 2** needs to start
    development and it needs to make some changes from the **Feature 1** branch, so
    **Feature 2** branches out from the **Feature 1** branch, and the development
    of **Feature 2** continues in the new branch. **Feature 1** development is completed,
    so, a pull request is created for review, and subsequently, the branch is merged
    into **Trunk**.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在**特性1**分支中进行几次提交后，**特性2**需要开始开发，并且它需要从**特性1**分支中进行一些更改，因此**特性2**从**特性1**分支分支出来，并在新分支中继续**特性2**的开发。**特性1**开发完成后，因此，创建了一个拉取请求进行审查，随后该分支被合并到**主干**。
- en: Engineers working on **Feature 2** want to keep its branch up to date, so they
    rebase the **Feature 2** branch from the latest **Trunk**. The **Release 1** branch
    does not need to rebase because **Feature 1** is not included in the coming release.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **功能2** 上工作的工程师希望保持其分支是最新的，所以他们从最新的 **主干** 分支重新合并 **功能2** 分支。**发布1** 分支不需要重新合并，因为
    **功能1** 不包含在即将发布的版本中。
- en: The **Release 1** branch has been deployed to production. There are a couple
    of bugs found after the production release, and unfortunately, one of them is
    a critical bug. So the **Release 1** branch cannot be merged into **Trunk** yet.
    While some engineers work on the lower priority fixes in the **Release 1** branch,
    a few engineers need to work on a hotfix immediately and fix the critical bug
    in the production environment. So, a hotfix branch is created for the critical
    bug fix.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布1** 分支已经部署到生产环境中。在生产发布后发现了几个错误，不幸的是，其中之一是一个关键错误。因此，**发布1** 分支还不能合并到 **主干**
    分支。当一些工程师在 **发布1** 分支上处理低优先级的修复时，几位工程师需要立即进行热修复并立即在生产环境中修复关键错误。因此，为关键错误修复创建了一个热修复分支。'
- en: The critical bug fix has been completed, deployed, and verified in UAT. So,
    it is released to the production environment. The hotfix branch is then merged
    into the **Release 1** branch. Afterward, all production bug fixes are completed,
    deployed, and verified in UAT. So, there is another production release to wrap
    up this release. The **Release 1** branch is then merged into **Trunk**.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 关键错误修复已完成，已部署并在用户验收测试（UAT）中进行了验证。因此，它被发布到生产环境中。然后，热修复分支被合并到 **发布1** 分支。之后，所有生产错误修复都已完成，并在用户验收测试（UAT）中进行了部署和验证。因此，还有另一个生产发布来总结这个版本。然后，**发布1**
    分支被合并到 **主干** 分支。
- en: The **Feature 2** branch is not completed yet, so it needs to be rebased from
    **Trunk**. At the same time, engineers start to prepare a new release by creating
    a new release branch from **Trunk**.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能2** 分支尚未完成，因此需要从 **主干** 分支进行重新合并。同时，工程师们开始准备新的发布版本，通过从 **主干** 分支创建一个新的发布分支来开始。'
- en: Feature-based development isolates branches and keeps them focused on their
    purposes. The **Release 1** branch in the example has naturally prevented **Feature
    1** from affecting the release. Also, the hotfix branch gives engineers a stable
    and safe space to concentrate on fixing the critical production bug, knowing that
    the critical fix can be patched as a priority without needing to consider other
    unrelated changes. Feature-based development uses pull requests that encourage
    code review and collaboration among engineers.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 基于功能的开发将分支隔离开来，并使它们专注于其目的。示例中的 **发布1** 分支自然防止了 **功能1** 影响发布。此外，热修复分支为工程师提供了一个稳定和安全的空间，专注于修复关键生产错误，知道关键修复可以作为优先级进行修补，而无需考虑其他无关的更改。基于功能的开发使用拉取请求，鼓励工程师之间的代码审查和协作。
- en: However, numerous long-lived branches bring the overhead of branch management.
    It introduces a high complexity of conflicts when merging or rebasing branches.
    This is particularly bad when there is substantial refactoring such as moving
    a file to another folder in one branch while the file is updated in another branch.
    This type of tree conflict often results in complex, time-consuming, and error-prone
    code merges. The mitigation of this issue is to rebase long-living branches frequently.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多长期存在的分支带来了分支管理的开销。它在合并或重新合并分支时引入了高度复杂性的冲突。当在一个分支中将文件移动到另一个文件夹，而另一个分支中文件被更新时，这种类型的树冲突通常会导致复杂、耗时且容易出错的代码合并。缓解这种问题的方法是频繁地重新合并长期存在的分支。
- en: Trunk-based development
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: Trunk-based development encourages engineers to work on a single branch, which
    is *Trunk* (also known as **main**). However, each commit to the *Trunk* branch
    is done by merging from short-lived branches as pull requests.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发鼓励工程师在一个单一的分支上工作，这个分支是 *主干*（也称为 **main**）。然而，对 *主干* 分支的每次提交都是通过合并来自短期分支的拉取请求来完成的。
- en: 'It advocates small, frequent, and incremental changes to be committed to *Trunk*
    frequently. Each branch is short-lived and usually does not last more than a few
    days. There are frequent rebase or merge operations for each branch to get the
    latest changes from *Trunk*. An example of trunk-based development is illustrated
    in *Figure 15**.3*:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它提倡频繁提交小、频繁和增量更改到 *主干*。每个分支都是短期存在的，通常不会持续超过几天。每个分支都有频繁的重新合并或合并操作，以从 *主干* 获取最新更改。基于主干开发的示例在
    *图15**.3* 中展示：
- en: '![Figure 15.3 – An example of trunk-based development](img/B21737_15_3.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – 基于主干的开发示例](img/B21737_15_3.jpg)'
- en: Figure 15.3 – An example of trunk-based development
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 基于主干的开发示例
- en: In this example, the **Feature 1** branch is created from **Trunk** for development.
    The **Feature 2** branch is also created from **Trunk** for development.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**特性1**分支是从**主干**创建用于开发的。**特性2**分支也是从**主干**创建用于开发的。
- en: The **Feature 1** branch has developed the code to a milestone where it is tested,
    verified, and releasable, but the feature itself is not completed. So, a pull
    request for **Feature 1** is created for review, and subsequently, the branch
    is merged into **Trunk**.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**特性1**分支已经将代码开发到里程碑阶段，此时代码经过测试、验证和可发布，但特性本身尚未完成。因此，为**特性1**创建了一个拉取请求以供审查，随后该分支被合并到**主干**。'
- en: '**Feature 1** development needs to continue. So, a new branch is created from
    **Trunk** for the continuation of the **Feature** **1** development.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**特性1**的开发需要继续。因此，为**特性1**的继续开发从**主干**创建了一个新分支。'
- en: At the same time, the **Feature 2** branch has detected a commit made in **Trunk**,
    so the corresponding engineer rebases the branch from **Trunk** to get the latest
    code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，**特性2**分支检测到在**主干**中有一个提交，因此相应的工程师将分支从**主干**重新基座以获取最新代码。
- en: Afterward, the development of **Feature 2** is completed, tested, and verified
    in its branch. So, a pull request is created for **Feature 2** for review. The
    branch is then approved and merged into **Trunk**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，**特性2**的开发在其分支中完成、测试和验证。因此，为**特性2**创建了一个拉取请求以供审查。然后该分支被批准并合并到**主干**。
- en: The **Feature 1** branch has detected a commit made in **Trunk**, so the corresponding
    engineer rebases the branch from **Trunk** to get the latest code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**特性1**分支检测到在**主干**中有一个提交，因此相应的工程师将分支从**主干**重新基座以获取最新代码。'
- en: Trunk-based development emphasizes that the *Trunk* branch should also be good
    enough for a release at any time. There is no concept of a release branch. That
    is why all branches should be tested, verified, and reviewed by peers before merging.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发强调，*主干*分支在任何时候也应该足够好以供发布。没有发布分支的概念。这就是为什么所有分支都应该在合并前由同行进行测试、验证和审查。
- en: To extend this concept, each commit can trigger a software release to environments,
    even to production. This approach fits very well with the practice of CD, where
    software is frequently delivered to customers, vastly reducing the time to market.
    It also implies that automated tests should be more rigorous and thorough in the
    branch to assure software quality in the early stages of development.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个概念，每个提交都可以触发软件向环境发布，甚至到生产环境。这种方法非常适合CD实践，其中软件频繁地交付给客户，大大缩短了上市时间。这也意味着在开发的早期阶段，自动测试应该更加严格和彻底，以确保软件质量。
- en: Trunk-based development also fits well with rapid development and short iterations
    that are advocated in Agile development methodologies. The quick turnarounds and
    short feedback loop enable the team to evolve the software product faster.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发也与敏捷开发方法中提倡的快速开发和短迭代周期很好地结合。快速的迭代和短的反馈循环使团队能够更快地演进软件产品。
- en: The frequent commits and rebasing also reduce the complexity of merge conflict
    resolution. Any integration issue can be identified and fixed early, so the feedback
    loop for engineers is shorter. The branch management is simplified because the
    *Trunk* branch is the only focus.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁的提交和重新基座也减少了合并冲突解决的复杂性。任何集成问题都可以在早期识别和修复，因此工程师的反馈循环更短。分支管理简化了，因为*主干*分支是唯一关注的焦点。
- en: Having a long-living branch is an anti-pattern under trunk-based development.
    For larger feature development, the changes need to be split into multiple branches,
    and therefore, multiple commits to the *Trunk* branch.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在主干基于开发中，长期存在的分支是一个反模式。对于较大的特性开发，变更需要分割成多个分支，因此需要对*主干*分支进行多次提交。
- en: Engineers need to make judgment calls on splitting the changes sensibly. It
    requires more thought and discipline from engineers to make sure each commit to
    *Trunk* is safe and can be released. **Feature flagging** is a common technique
    in hiding features in development and still allows code to be released to production.
    Feature flagging will be covered in the next section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师需要在合理地分割变更时做出判断。这要求工程师有更多的思考和纪律，以确保每个提交到*主干*的变更都是安全的，并且可以被发布。**特性标志**是在开发中隐藏特性同时仍然允许代码发布到生产环境的常用技术。特性标志将在下一节中介绍。
- en: 'It is not uncommon for an engineer to have added changes that are not ready
    for production by mistake, despite the changes having been merged into *Trunk*.
    To make matters worse, there are other changes committed afterward. At this moment,
    *Trunk* is not ready for release. This situation leaves engineers with a few difficult
    choices:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师不小心添加了尚未准备好生产的更改，尽管这些更改已经合并到 *Trunk* 中，这种情况并不少见。更糟糕的是，之后还有其他更改被提交。此时，*Trunk*
    还未准备好发布。这种情况让工程师面临一些艰难的选择：
- en: '**Roll back**: Reverse all the commits to where *Trunk* is still safe for release.
    That would generate one more commit to *Trunk* for reversion. Re-apply the other
    required changes from new branches after the reversion.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Roll back**：撤销所有提交，使 *Trunk* 仍然安全发布。这将生成一个额外的提交用于回滚。在回滚后，重新应用来自新分支的其他所需更改。'
- en: '**Cherry-picking**: Create a new branch from the latest *Trunk* and carefully
    unpick the unwanted changes. Merges this branch back to *Trunk*.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** cherry-picking**：从最新的 *Trunk* 创建一个新分支，并仔细撤销不希望的变化。将此分支合并回 *Trunk*。'
- en: '**Roll forward**: Create a new branch from the latest *Trunk* and continue
    to work on the change with a focus on making *Trunk* ready for release again.
    Merge this branch back to *Trunk*.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Roll forward**：从最新的 *Trunk* 创建一个新分支，并继续对变化进行工作，重点是使 *Trunk* 再次准备好发布。将此分支合并回
    *Trunk*。'
- en: All the preceding choices require careful execution by engineers and none of
    them are easy. Many engineers would prefer rolling forward to keep the flow of
    development going at the cost of leaving some commits in *Trunk* unfit for release.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述选择都需要工程师谨慎执行，并且都不是容易的。许多工程师宁愿前进以保持开发流程的连续性，而牺牲在 *Trunk* 中留下一些不适合发布的提交。
- en: Comparison between feature-based and trunk-based development
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于功能和基于Trunk的开发比较
- en: The choice between feature-based and trunk-based is highly related to ways of
    working in the team and in the organization. This is an example of where **Conway’s
    Law** applies, as covered in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013),
    where organization structure affects the software development process.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于功能和基于Trunk之间的选择高度相关于团队和组织的工作方式。这是一个康威定律适用的例子，如在第[*第一章*](B21737_01.xhtml#_idTextAnchor013)中所述，组织结构影响软件开发过程。
- en: '| **Feature-based development** | **Trunk-based development** |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **基于功能的开发** | **基于Trunk的开发** |'
- en: '| Long-lived branches | Short-lived branches |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 长期分支 | 短期分支 |'
- en: '| Dedicated branches for release | *Trunk* is the branch for release |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 专门的发布分支 | *Trunk* 是发布分支 |'
- en: '| Large features developed in long-lived branches | Large features are split
    into multiple short-lived branches |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 在长期分支中开发大型功能 | 将大型功能拆分为多个短期分支 |'
- en: '| High complexity in merge and rebase operations | Low complexity in merge
    and rebase operations |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 合并和变基操作中的高复杂性 | 合并和变基操作中的低复杂性 |'
- en: '| Slower feedback for integration issues | Faster feedback for integration
    issues |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 集成问题的反馈较慢 | 集成问题的反馈较快 |'
- en: '| Development in isolation | Development with collaboration |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 独立开发 | 协作开发 |'
- en: '| Roll back is more common | Roll forward is more common |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 回滚更常见 | 前进更常见 |'
- en: '| A hotfix branch for urgent issues | No concept of hotfix branches |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 用于紧急问题的热修复分支 | 没有热修复分支的概念 |'
- en: '| The release branch is stable | Complex operations to fix unreleasable commits
    in the trunk |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 发布分支是稳定的 | 在主分支中修复不可发布提交的复杂操作 |'
- en: '| Release is less frequent | Release can be more frequent |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 发布频率较低 | 发布可以更频繁 |'
- en: Table 15.2 – Comparison between feature-based and trunk-based development
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.2 – 基于功能和基于Trunk的开发比较
- en: Both development approaches have their advantages and trade-offs. Ultimately,
    the choice depends on the team size, project complexity, and development practice.
    Some teams may adopt a hybrid approach to maximize the benefits of each approach
    and reduce the drawbacks.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种开发方法都有其优点和权衡。最终的选择取决于团队规模、项目复杂度和开发实践。一些团队可能会采用混合方法，以最大化每种方法的优势并减少其缺点。
- en: For example, a team may decide to have trunk-based development but a release
    branch is created to aim for each release. It reduces the need to unpick unwanted
    changes for release and keeps release preparation away from the development of
    other ongoing features.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个团队可能会决定采用基于Trunk的开发，但创建一个发布分支以针对每个发布。这减少了撤销不希望的变化以进行发布的需要，并将发布准备与其他正在开发的功能的开发隔离开来。
- en: The preceding example can be seen as a release strategy; nonetheless, there
    are more release strategies that we want to cover, and we are going to cover them
    in the next section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子可以被视为一种发布策略；然而，我们还想介绍更多发布策略，并将它们放在下一节中介绍。
- en: Release versus deployment versus launch
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布与部署与推出
- en: Once an application is ready for release, there is a new landscape of concerns
    and strategies on how it gets into the hands of customers and end users. At certain
    times in history, it was just a binary condition of whether it was out or not.
    Modern releases are more sophisticated and complicated.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序准备发布，就会面临如何将其交付给客户和最终用户的一系列新的关注点和策略。在历史上某些时期，这只是一个是否发布的二元条件。现代发布更加复杂和精细。
- en: 'Firstly, we need to make distinctions among three concepts: release, deployment,
    and launch. These concepts might be used interchangeably in some organizations;
    however, they have subtle differences that should be discussed.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要区分三个概念：发布、部署和推出。这些概念可能在某些组织中可以互换使用；然而，它们之间存在细微的差别，应该进行讨论。
- en: '**Deployment** is the least misunderstood concept. Deployment implies that
    the executable software artifact built from source code and configuration has
    been loaded to the target environment. This section focuses on the production
    environment. It is an operational and technical task that is often automated by
    scripts – optionally, with an approval process that involves human intervention.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署**是最不容易误解的概念。部署意味着从源代码和配置构建的可执行软件工件已加载到目标环境中。本节重点介绍生产环境。这是一个操作和技术任务，通常通过脚本自动化，可选地涉及人工干预的审批流程。'
- en: '**Release** means the application is now available to the users in the target
    environment. Sometimes, we might also say releasing a feature, which means the
    intent of making the feature available to users. Deployment is the prerequisite
    of release. A feature in an application, even if the application has been deployed,
    may still not be available to some users.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布**意味着应用程序现在在目标环境中可供用户使用。有时，我们可能还会说发布一个功能，这意味着使该功能可供用户使用的意图。部署是发布的先决条件。即使应用程序已经部署，应用程序中的某些功能可能仍然不可用给某些用户。'
- en: '**Launching** an application is the least technically involved out of all three
    concepts. The term *launch* does not mean starting up an application. Instead,
    it implies the software product is marketed, advertised, and, optionally, has
    a launch event such as a press conference or an exhibition. Launching a software
    product is not part of the CI/CD life cycle. Releasing is the prerequisite of
    launching as users need to access the application. Launching would involve a go-to-market
    plan, with a variety of non-technical stakeholders involved (e.g., marketing,
    sales, customer services, etc.).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**推出**是这三个概念中最不涉及技术的一个。术语*推出*并不意味着启动应用程序。相反，它意味着软件产品被营销、广告，并且可选地举办新闻发布会或展览等推出活动。推出软件产品不是CI/CD生命周期的组成部分。发布是推出的先决条件，因为用户需要访问应用程序。推出将涉及市场推广计划，涉及各种非技术利益相关者（例如，市场营销、销售、客户服务等）。'
- en: With these distinctions, release strategies of software products are where the
    complications are in relation to CD. We are going to cover a few common release
    strategies next.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些区分，软件产品的发布策略与CD相关的复杂性在于。接下来，我们将介绍一些常见的发布策略。
- en: Blue-green release
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝色-绿色发布
- en: '**Blue-green release** keeps the current version (*blue*) of an application
    in the production environment and has a new version (*green*) deployed to a replica
    of the production environment. This strategy allows the new version of the application
    to be deployed while keeping the current version available to users.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝色-绿色发布**保留应用程序在生产环境中的当前版本（*蓝色*），并将新版本（*绿色*）部署到生产环境的副本中。这种策略允许在保持当前版本对用户可用的情况下部署新版本的应用程序。'
- en: 'This strategy typically applies to server-side web-based applications and the
    **Domain Name System** (**DNS**) to route web requests to the new or current version
    of the application. The blue-green release strategy can be seen in *Figure 15**.4*:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略通常适用于服务器端基于Web的应用程序以及**域名系统**（**DNS**）将Web请求路由到应用程序的新版本或当前版本。蓝色-绿色发布策略可以在*图15.4*中看到：
- en: '![Figure 15.4 – An example of a blue-green release](img/B21737_15_4.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 – 蓝色-绿色发布的示例](img/B21737_15_4.jpg)'
- en: Figure 15.4 – An example of a blue-green release
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 蓝色-绿色发布的示例
- en: The DNS, by default, routes web requests to **Zone 1** (**Blue**) where the
    current versions of applications are running. The applications in the **Blue**
    zone communicate with each other only, by keeping them in the same **local area**
    **network** (**LAN**).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，DNS将Web请求路由到**Zone 1**（**蓝**），其中运行着当前版本的应用程序。**蓝**区的应用程序只与彼此通信，通过将它们保持在相同的**本地****网络**（**LAN**）中。
- en: While the `api.zone2.contract.system` in contrast to the general `api.contract.system`).
    Engineers can even troubleshoot and fix issues found in the new versions.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用的`api.contract.system`相比，`api.zone2.contract.system`）。工程师甚至可以排查和修复在新版本中发现的问题。
- en: 'Once the new versions are verified and ready to be used by users, the traffic
    can be switched in the DNS, so web requests are routed to **Zone 2**. **Zone 2**
    is now the new **Blue** zone in effect. There is no more **Green** zone, as illustrated
    in *Figure 15**.5*:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新版本经过验证并准备好供用户使用，可以在DNS中切换流量，因此Web请求被路由到**Zone 2**。**Zone 2**现在是有效的新的**蓝**区。没有更多的**绿**区，如*图15.5*所示。5*：
- en: '![Figure 15.5 – A blue-green release (after switching)](img/B21737_15_5.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 蓝绿发布（切换后）](img/B21737_15_5.jpg)'
- en: Figure 15.5 – A blue-green release (after switching)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 蓝绿发布（切换后）
- en: '**Zone 1** is now running older versions of applications that can be shut down
    till the next deployment, which turns this zone into the new **Green** zone. It
    is important to note that **Blue**/**Green** is the role of the zone that is going
    to flip from one another over time.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**Zone 1**现在运行着可以关闭到下一次部署的旧版本应用程序，这使得该区域成为新的**绿**区。重要的是要注意，**蓝**/**绿**是区域将随着时间的推移相互翻转的角色。'
- en: 'A blue-green release is not the same as a rolling deployment. Rolling deployment
    aims to keep the service available while deployment is in progress. Rolling deployment
    usually takes the following steps:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿发布不同于滚动部署。滚动部署旨在在部署进行时保持服务可用。滚动部署通常采取以下步骤：
- en: Scale down the current number of application instances to one.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前应用程序实例的数量缩减到一。
- en: Deploy the new version of the application to the target number as new instances.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序的新版本部署到目标数量的新实例。
- en: Start all instances of the new version.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动新版本的所有实例。
- en: Notify the load balancer of the existence of the new running instances, or let
    them be discovered.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知负载均衡器新运行实例的存在，或者让它们被发现。
- en: Once all instances of the new version are confirmed to be running by the probe
    endpoints, shut down the older application instance.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦探测端点确认新版本的实例正在运行，关闭旧的应用程序实例。
- en: Unlike the blue-green release, there is no time window in which engineers and
    QAs can test the newer version of the application without it being available to
    users. Additionally, this is a deployment technique only. It is not concerned
    with whether the application is available to users or not. It only cares whether
    the application has transitioned to the new version without outage or downtime.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 与蓝绿发布不同，工程师和QA没有时间窗口可以在用户无法访问的情况下测试应用程序的新版本。此外，这是一种部署技术。它不关心应用程序是否对用户可用。它只关心应用程序是否已过渡到新版本，而没有中断或停机。
- en: Dark release/feature flagging
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暗色发布/功能开关
- en: There are methods to verify new features without making them available to users.
    The new features can be deployed to the production environment normally but remain
    hidden from users, using **feature flagging** (also known as **dark release**).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以在不向用户开放的情况下验证新功能。新功能可以正常部署到生产环境，但仍然对用户隐藏，使用**功能开关**（也称为**暗色发布**）。
- en: 'The feature toggle can be managed in a few ways:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 特性开关可以通过几种方式管理：
- en: '**Central**: There is a central service or resource that dictates whether a
    feature is available to the given user'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式**：有一个中心服务或资源决定某个功能是否对特定用户可用。'
- en: '**Individual**: Each component or service manages its own feature flags'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人**：每个组件或服务管理自己的功能开关。'
- en: '**Per request**: A non-publicly known request parameter is used to enable the
    feature to serve this request'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按请求**：使用一个非公开的请求参数来启用功能以服务此请求。'
- en: Regardless of how feature flags are managed, this approach allows engineers
    and QAs to verify pre-released features before the features are available to users.
    The feature is only switched on when the team is happy with the verification results.
    In addition, the feature can be switched off even after it was made available
    to users, and thus it minimizes the impact of related issues.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何管理特性标志，这种方法都允许工程师和QA在特性对用户可用之前验证预发布特性。只有当团队对验证结果满意时，特性才会打开。此外，即使在特性对用户可用之后，也可以将其关闭，从而最大限度地减少相关问题的影响。
- en: Feature flagging works well with the practice of **trunk-based development**,
    as discussed in previous sections. With the feature flag switched off, engineers
    can continue to develop the feature and merge their changes to the trunk. However,
    all automated tests should pass to ensure that existing functions still work as
    intended with the unfinished and switched-off feature in the code base.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 特性标志与** trunk-based development**实践相结合效果良好，如前文所述。当特性标志关闭时，工程师可以继续开发特性并将他们的更改合并到主干。然而，所有自动化测试都必须通过，以确保现有功能在代码库中未完成和关闭的特性下仍然按预期工作。
- en: Feature flags mainly concern releases and making a feature available to users.
    Some organizations may extend feature flagging to support user segmentation and
    A/B testing, as mentioned in [*Chapter 13*](B21737_13.xhtml#_idTextAnchor418).
    This is not an anti-pattern, but only an enhancement of the system beyond feature
    flagging.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 特性标志主要关注发布和将特性提供给用户。一些组织可能会将特性标志扩展到支持用户细分和A/B测试，如[*第13章*](B21737_13.xhtml#_idTextAnchor418)中所述。这并不是反模式，而只是对特性标志系统的一种增强。
- en: Canary release
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: 'A **canary release** is a staged release strategy that makes the newly deployed
    software available to a small subset of users before rolling it out to all target
    users. It operates at the application level, not a feature in an application.
    It aims for incremental availability to users, and there are a lot of variations
    in this strategy in the initial selection of users and strategic increase of availability.
    There are a few factors that would affect this strategy:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**金丝雀发布**是一种分阶段发布策略，在向所有目标用户推出之前，先将新部署的软件提供给一小部分用户。它是在应用程序层面操作，而不是在应用程序中的某个特性。它旨在逐步向用户提供可用性，并且在用户初始选择和可用性战略增加方面有很多变化。有几个因素会影响这一策略：'
- en: The team might want to invite subject matter experts or domain experts to start
    using the application first, to gather feedback that might shape the product before
    the public uses it.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队可能希望邀请主题专家或领域专家首先使用该应用程序，以收集可能在公众使用之前塑造产品的反馈。
- en: The organization might want to initially release the software product to users
    in a selected geographic region. This could be due to the geographic context of
    the application, legal restrictions, or related marketing events. The organization
    might want to expand its geographic territory incrementally.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织可能希望最初将软件产品发布到选定的地理区域用户。这可能是由于应用程序的地理背景、法律限制或相关的营销活动。组织可能希望逐步扩大其地理领土。
- en: The team might want to initially release the application to certain types of
    devices or operating systems of devices. This could be due to compatibility concerns,
    especially in the Android application landscape, or due to the popularity of certain
    devices in the market.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队可能希望最初将应用程序发布到某些类型的设备或设备的操作系统。这可能是由于兼容性考虑，特别是在Android应用程序领域，或者由于市场上某些设备的流行。
- en: A canary release is sometimes mistaken for the concept of beta testing. After
    a software product is signed off by internal QAs, some organizations might want
    to invite expert users to internal testing. Testing internally, typically with
    **white-box testing** techniques, as discussed in [*Chapter 13*](B21737_13.xhtml#_idTextAnchor418),
    is called **alpha testing**. Testing by external users before public release is
    called **beta testing**.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布有时会被误认为是beta测试的概念。在软件产品被内部QA签批后，一些组织可能希望邀请专家用户进行内部测试。通常使用**白盒测试**技术进行内部测试，如[*第13章*](B21737_13.xhtml#_idTextAnchor418)中所述，这被称为**alpha测试**。在公开发布之前由外部用户进行的测试称为**beta测试**。
- en: However, beta testing is not considered a production release because the version
    of the software product being tested is usually not the final version. Beta testing
    is only for a limited period.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于正在测试的软件产品版本通常不是最终版本，因此beta测试不被视为生产发布。beta测试仅限于有限的时间。
- en: Feedback and suggestions from selected users are gathered to validate the product
    concepts, usability, and functionality. They are also used for further enhancement
    of the product. Releasing a non-final version of the software product for beta
    testing does not require a canary release strategy.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 从选定的用户那里收集反馈和建议，以验证产品概念、可用性和功能。它们也用于产品的进一步改进。发布软件产品的非最终版本进行beta测试不需要使用金丝雀发布策略。
- en: Choosing a release strategy
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择发布策略
- en: 'Choosing a release strategy is not easy or straightforward. However, it is
    certainly not recommended to do a Big Bang release with planned outages, as we
    discussed in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212). There are other
    factors involved in the decision, such as infrastructure readiness, marketing
    strategies, service uptime objectives, and so on. From a purely technical point
    of view, we can potentially use a decision tree to recommend a release strategy,
    as shown in *Figure* *15**.6*:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 选择发布策略并不容易或直接。然而，我们绝对不推荐像我们在[*第6章*](B21737_06.xhtml#_idTextAnchor212)中讨论的那样进行大爆炸发布并计划停机，因为决策中涉及其他因素，如基础设施准备情况、营销策略、服务正常运行时间目标等。从纯粹的技术角度来看，我们可以使用决策树来推荐发布策略，如图*15*.*6*所示：
- en: '![Figure 15.6 – An example of a technical decision tree of release strategies](img/B21737_15_6.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – 发布策略的技术决策树示例](img/B21737_15_6.jpg)'
- en: Figure 15.6 – An example of a technical decision tree of release strategies
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – 发布策略的技术决策树示例
- en: Releasing a feature in an application should consider feature flagging or dark
    release first because it is the least expensive choice compared to others. If
    it is about releasing an entire application and it is a server-side application,
    a blue-green release or canary release can be considered. If the application involves
    desktop, mobile, or web applications, then a canary release should be considered.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中发布一个新功能时，应首先考虑使用功能标志或暗色发布，因为这与其他选择相比成本最低。如果涉及到发布整个应用程序，并且是一个服务器端应用程序，可以考虑使用蓝绿发布或金丝雀发布。如果应用程序涉及桌面、移动或Web应用程序，那么应考虑使用金丝雀发布。
- en: Please note this is more about technical restrictions of which release strategies
    can be used, instead of considering which one provides the best outcome due to
    other non-technical factors involved.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这更多是关于哪些发布策略可以使用的技术限制，而不是考虑由于涉及的其他非技术因素而提供的最佳结果。
- en: We are at the end of the discussion on CI/CD. A well-automated CI/CD pipeline
    saves a lot of time for engineers in trying to integrate with other people’s work
    and deliver the application to multiple environments. In a sense, it improves
    the experience of engineers working on software products. We are going to cover
    a bit more on the topic of the developer experience in the next section.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了CI/CD的讨论。一个高度自动化的CI/CD管道可以为工程师节省大量时间，以便与其他人的工作集成并将应用程序交付到多个环境。从某种意义上说，它改善了软件产品工程师的工作体验。在下一节中，我们将进一步探讨开发者体验的主题。
- en: Developer experience
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者体验
- en: '**Developer experience** (**DX**) is what engineers experience while developing
    software. It includes everything from tools, processes, environments, teams, organizations,
    and the culture of development. We will bring up a few suggestions for improving
    DX in the following sections.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者体验**（**DX**）是工程师在开发软件时的体验。它包括从工具、流程、环境、团队、组织到开发文化的一切。在接下来的几节中，我们将提出一些改进DX的建议。'
- en: Why does DX matter?
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么DX很重要？
- en: 'DX might, at first glance, look like the general satisfaction of any person
    working on a project. However, a great DX brings a lot of benefits to not only
    the engineers themselves but also to the software product and to the organization:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，DX可能看起来是任何参与项目的人的一般满意度。然而，优秀的DX不仅给工程师本人带来很多好处，也给软件产品和组织带来很多好处：
- en: '**Productivity and efficiency**: Efficient tools, automated workflows, concise
    documentation, and smooth development processes remove the burden from engineers,
    so they can focus on coding and problem-solving.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产力和效率**：高效的工具、自动化的工作流程、简洁的文档和流畅的开发流程减轻了工程师的负担，使他们能够专注于编码和解决问题。'
- en: '**Product quality**: Stable environments and intuitive tools reduce friction
    in the everyday work of engineers, so they can focus on delivering high-quality
    code with attention to detail.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品质量**：稳定的环境和直观的工具减少了工程师日常工作的摩擦，使他们能够专注于以关注细节的方式交付高质量的代码。'
- en: '**Operation cost**: Automated tools and processes reduce the labor cost for
    engineers to support the system. Also, better tools lead to fewer mistakes and
    thus reduce the time and resources spent on fixing issues.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运营成本**：自动化的工具和流程降低了工程师支持系统的劳动力成本。更好的工具导致错误更少，从而减少了修复问题的时间和资源。'
- en: '**Learning curve**: Streamlined onboarding process, good documentation, and
    intuitive processes make it quicker for a new engineer to get up to speed and
    become productive.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：简化的入职流程、良好的文档和直观的过程使新工程师更快地熟悉并变得高效。'
- en: '**Collaboration**: Good DX encourages communication and collaboration within
    the team and improves team morale. It also improves the interactions between engineers
    and stakeholders, which leads to better outcomes.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：良好的DX鼓励团队内部的沟通和协作，提高团队士气。它还改善了工程师与利益相关者之间的互动，从而带来更好的结果。'
- en: '**Innovation**: A safe and supportive environment fosters a culture of innovation
    and experimentation. Engineers can be creative in their solutions without the
    fear of failure. High-quality tools allow for trying new ideas collaboratively
    and learning collectively.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创新**：一个安全和支持的环境培养了创新和实验的文化。工程师可以在不担心失败的情况下发挥创造力。高质量的工具有助于共同尝试新想法并集体学习。'
- en: '**Job satisfaction and retention**: A satisfactory working environment keeps
    engineers more engaged and motivated. When they enjoy the work they do, employee
    turnover can be lowered. In return, it saves time and resources on recruitment
    and training.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作满意度和留存率**：令人满意的工作环境使工程师更加投入和有动力。当他们享受自己的工作时，员工流失率可以降低。反过来，这可以节省招聘和培训的时间和资源。'
- en: '**Talent acquisition**: If an organization has a reputation for great DX among
    technology communities, it attracts top talent to join the team and improves the
    branding of the organization.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人才招聘**：如果一个组织在技术社区中享有卓越的DX声誉，它将吸引顶尖人才加入团队并提升组织的品牌形象。'
- en: DX has an influential role in delivering high-quality software products, ultimately
    leading to more healthy organizations and better business outcomes. We are going
    to cover a few areas that can improve DX next.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'DX在交付高质量软件产品中发挥着有影响力的作用，最终导致更健康的企业和更好的商业成果。我们将介绍一些可以改善DX的领域。 '
- en: Onboarding
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入职
- en: 'Apart from the general onboarding, there should be comprehensive documentation
    for engineering topics, such as the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一般的入职流程外，还应该为工程主题提供全面的文档，例如以下内容：
- en: Development processes (Kanban, Scrum, etc.)
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发流程（看板、敏捷等）。
- en: Tech stacks used in the organization
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织使用的技术栈。
- en: In-house libraries and frameworks
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部库和框架。
- en: '**Architecture decision records** (**ADRs**), as mentioned in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如[*第一章*](B21737_01.xhtml#_idTextAnchor013)中提到的**架构决策记录**（**ADRs**）。
- en: Engineering practices and conventions
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程实践和约定。
- en: Specialized engineering environments set up (e.g., backend, frontend, data,
    platform, etc.)
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置专门的工程环境（例如，后端、前端、数据、平台等）。
- en: These documents are best updated by each new engineer joining the organization,
    as it can keep the information up to date.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文档最好由加入组织的每位新工程师更新，因为这可以保持信息的时效性。
- en: Having a technical peer assigned as an onboarding partner is a helpful welcoming
    gesture for new engineers. The onboarding partner can pair with the new engineer
    in setting up environments for work, requesting appropriate permissions, adding
    the new engineer to the corresponding communication channel, and answering questions.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 指派一名技术同伴作为入职伙伴是一个有益的欢迎举动。入职伙伴可以帮助新工程师设置工作环境、请求适当的权限、将新工程师添加到相应的沟通渠道，并回答问题。
- en: Tools
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具
- en: 'Tools play a big part in an engineer’s productivity. Investing in good engineering
    tools brings not only great DX but also tangible productivity to the engineering
    teams. These tools include, but are not limited to, the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 工具在工程师的生产力中扮演着重要角色。投资于良好的工程工具不仅带来卓越的开发体验（DX），还为工程团队带来了实际的生产力。这些工具包括但不限于以下内容：
- en: A **single sign-on** (**SSO**) portal to access all other third-party tools.
    Instead of having everyone remember passwords for each third-party tool, logging
    in to these tools via a central portal saves a lot of time. This applies to all
    tools beyond engineering tools.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于访问所有其他第三方工具的**单点登录**（**SSO**）门户。通过中央门户登录这些工具，而不是让每个人记住每个第三方工具的密码，可以节省大量时间。这适用于所有超出工程工具的工具。
- en: Streamlined method to log in to any environment or infrastructure without compromising
    security and auditing. Historically, engineers need to access a server using means
    such as the **Secure Shell** (**SSH**) protocol with a terminal tool. In modern
    days, there are better ways to access a server in any environment. These tools
    (such as Teleport, JumpCloud, CyberArk, etc.) support a simple request-approval
    workflow for access, wrapping around the terminal tool, establishing tunneling,
    restricting certain access, and logging all the activities during access to secure
    the environment.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种简化的登录方法，在不影响安全和审计的情况下访问任何环境或基础设施。历史上，工程师需要使用终端工具等手段，如**安全外壳协议（SSH**）来访问服务器。在当今时代，有更好的方法在任何环境中访问服务器。这些工具（如Teleport、JumpCloud、CyberArk等）支持简单的请求-审批工作流程，围绕终端工具建立隧道，限制某些访问，并在访问过程中记录所有活动，以确保环境安全。
- en: Each engineer may have their own toolkit in their pocket, such as some scripts
    for certain tasks. It is recommended to have a source repository to host all these
    scripts and small toolkits accessible to all engineers. Not only can the organization
    absorb the secret powerful scripts from engineers but it also establishes a standard
    toolkit to help engineers perform their daily tasks.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每位工程师可能都有自己的工具包，例如某些任务的脚本。建议有一个源代码库来托管所有这些脚本和小型工具包，使所有工程师都能访问。这不仅可以让组织吸收工程师的秘密强大脚本，还可以建立一个标准工具包，帮助工程师完成日常任务。
- en: There are circumstances where engineers need to call an API endpoint to perform
    certain tasks, such as rehydrating an event topic by requesting the publisher
    to publish all messages again. It is recommended that the organization has a shared
    collection of operational endpoints to reduce the time for engineers to craft
    these steps themselves. In addition, it is likely that those API endpoints require
    getting an authorization token as a bearer token to invoke endpoints (see [*Chapter
    14*](B21737_14.xhtml#_idTextAnchor442) for a detailed flow); the orchestration
    of getting these tokens should be scripted and shared among engineers. An example
    of this tool is **Postman Collections**.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，工程师需要调用API端点来执行某些任务，例如通过请求发布者再次发布所有消息来重新激活事件主题。建议组织拥有一个共享的操作端点集合，以减少工程师自己构建这些步骤所需的时间。此外，这些API端点可能需要获取一个作为令牌的授权令牌来调用端点（参见[*第14章*](B21737_14.xhtml#_idTextAnchor442)以获取详细流程）；获取这些令牌的编排应被脚本化并在工程师之间共享。此类工具的例子是**Postman
    Collections**。
- en: The dependencies of a Kotlin project are silently out of date over time. Use
    automation tools such as **Dependabot** to automatically create pull requests
    that update dependencies.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin项目的依赖项随着时间的推移会默默过时。使用自动化工具如**Dependabot**自动创建更新依赖项的拉取请求。
- en: Use **artificial intelligence** (**AI**) applications in multiple areas of software
    development. Apart from the normal syntactic code completion features provided
    by the IDEs, there are also AI assistants that hint at semantic code completion
    by understanding the existing code base. There are also embedded **large language
    model** (**LLM**) chatbots that provide live technical advice with example code
    snippets. There are also pull request bots that understand the intent of pull
    requests and provide useful feedback.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在软件开发的多领域使用**人工智能（AI**）应用。除了IDE提供的正常语法代码补全功能外，还有通过理解现有代码库来提示语义代码补全的人工智能助手。还有嵌入的**大型语言模型（LLM**）聊天机器人，它们提供带有示例代码片段的实时技术建议。还有理解拉取请求意图并提供有用反馈的拉取请求机器人。
- en: Development processes
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发流程
- en: Organizations should invest in tools that support software development processes.
    Each team could have adopted slightly different methodologies such as Scrum or
    Kanban, and the team would need a dashboard to run the daily standup.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 组织应该投资于支持软件开发流程的工具。每个团队可能采用了略微不同的方法，如Scrum或Kanban，并且团队需要一个仪表板来运行每日站立会议。
- en: As remote working has become a trend, organizations should invest in tools such
    as issue-tracking systems, digital Kanban or Scrum boards, and online retrospective
    tools to enable the team to run any software development process.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 随着远程办公成为一种趋势，组织应该投资于诸如问题跟踪系统、数字看板或Scrum看板以及在线回顾工具等工具，以使团队能够运行任何软件开发流程。
- en: Communication and collaboration
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沟通与协作
- en: Modern organizations will already have invested in multiple communication tools
    for instant messaging, video conferencing, screen sharing and pairing, and emails.
    It is recommended that emails should only be used for external communication.
    Instant messaging should be the major way of communication.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现代组织已经投资了多个即时通讯、视频会议、屏幕共享和配对以及电子邮件的通信工具。建议仅将电子邮件用于外部沟通。即时通讯应该是主要的沟通方式。
- en: Moreover, it is recommended that each team has a channel where engineers can
    think out loud about their problem-solving. Members of the channel should form
    a habit of using threads to post messages about a specific problem. By concentrating
    discussion of a problem, it is possible to introduce AI bots to summarize the
    discussion for others to catch up.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，建议每个团队都有一个渠道，工程师可以在其中大声思考他们的问题解决方法。渠道的成员应养成使用线程发布特定问题消息的习惯。通过集中讨论问题，可以引入AI机器人来总结讨论，以便其他人跟上进度。
- en: The instant messaging system should integrate with other tools, so engineers
    have a one-stop shop to receive notifications and work reactively. This can include
    receiving notifications of a visual design change from design collaboration tools,
    a change of an issue in issue management tools, an alert from monitoring tools,
    approval in a pull request, or simply a daily meeting schedule summary.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 即时通讯系统应与其他工具集成，以便工程师能够一站式接收通知并反应性地工作。这可以包括从设计协作工具接收视觉设计变更的通知、问题管理工具中问题变更的通知、监控工具的警报、拉取请求的批准，或者简单的每日会议日程摘要。
- en: Engineers need to have tools to immediately jump on a remote pair-programming
    huddle with the capability to share screens and even take over control of input
    devices.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师需要拥有能够立即加入远程配对编程小组的工具，这些工具能够共享屏幕甚至接管输入设备的控制。
- en: Some IDEs, such as IntelliJ Ultimate, have the capability to run pair-programming
    sessions. These tools enhance the collaboration between engineers and encourage
    collective learning.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IDE，如IntelliJ Ultimate，具有运行配对编程会议的能力。这些工具增强了工程师之间的协作并鼓励集体学习。
- en: There are other tools that enhance collaboration between engineers and other
    disciplines in the team. For example, an online collaborative design tool such
    as Figma or Miro can be used as a sketchpad for engineers to work with designers
    and product managers to understand the requirements.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他工具可以增强工程师与其他团队学科的协作。例如，可以使用Figma或Miro等在线协作设计工具作为工程师与设计师和产品经理一起工作的草图板，以了解需求。
- en: Engineers in the same specialization (backend, frontend, data, testing, platform,
    etc.) can have their own forum as a *trade guild* in which engineers can share
    their learning and discuss topics that are closely related to their work.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 同一专业领域的工程师（后端、前端、数据、测试、平台等）可以拥有自己的论坛，作为*行会*，工程师可以在其中分享他们的学习和讨论与工作密切相关的话题。
- en: Feedback and continuous improvement
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反馈和持续改进
- en: It is important to periodically receive qualitative and quantitative feedback
    from engineers to discover any room for improvement. It is recommended to conduct
    regular surveys, feedback sessions, or retrospective sessions to gain insights
    into the satisfaction of engineers and to identify areas of improvement.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 定期从工程师那里获得定性和定量反馈以发现任何改进空间非常重要。建议定期进行问卷调查、反馈会议或回顾会议，以了解工程师的满意度并确定改进领域。
- en: As discussed in [*Chapter 11*](B21737_11.xhtml#_idTextAnchor358), the **SPACE**
    metrics provide a comprehensive and holistic assessment of the productivity and
    well-being of engineering teams.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第[*第11章*](B21737_11.xhtml#_idTextAnchor358)中讨论的，**SPACE**指标提供了一个全面和全面的工程团队生产力和福祉评估。
- en: Most importantly, the engineering management needs to acknowledge the feedback
    and implement corresponding changes to improve the DX. Being listened to and seeing
    feedback taken on board would vastly improve the satisfaction and morale of engineering
    teams.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，工程管理需要认可反馈并实施相应的变化以改善开发体验（DX）。被倾听并看到反馈被采纳将极大地提高工程团队的满意度和士气。
- en: Recognition and rewards
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认可和奖励
- en: Engineering teams and management should recognize and celebrate achievements
    by teams or individuals. This can be done by explicitly shouting out the team
    and its members for their accomplishments or giving actual rewards for successful
    releases, innovative ideas, and implemented improvements. Recognition and rewards
    can boost morale and motivation.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 工程团队和管理层应该认可和庆祝团队或个人的成就。这可以通过明确指出团队及其成员的成就，或者为成功的发布、创新想法和实施的改进提供实际奖励来实现。认可和奖励可以提升士气和动力。
- en: Final thoughts on software architecture
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于软件架构的最终思考
- en: As we are coming to the end of the book, I would like to share my final thoughts
    on software architecture. I am going to cover the current trends and how we could
    equip ourselves to surf on the never-ending waves of change.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的结束，我想分享我对软件架构的最终思考。我将涵盖当前趋势以及我们如何装备自己以驾驭不断变化的浪潮。
- en: Small, reactive, and independent services
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小型、响应式和独立的服务
- en: Although there are a few justifications for writing a monolithic application,
    as discussed in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212), software components
    are getting smaller and smaller. It is less common to see a new project written
    with the aim of becoming a monolith these days. Instead, engineers would aggressively
    split out small services that communicate over APIs or events.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正如在[*第6章*](B21737_06.xhtml#_idTextAnchor212)中讨论的那样，有一些理由可以写出一个单体应用，但软件组件正变得越来越小。如今，很少看到有新项目是以成为单体为目标而编写的。相反，工程师会积极地将小型服务分离出来，这些服务通过API或事件进行通信。
- en: Small services improve scalability, flexibility, and ease of deployment. Teams
    can develop, deploy, and scale services independently. Microservices and nanoservices
    are small enough to be owned by one team, and thus they encourage autonomy and
    empower the team to make its own decisions. Even if a wrong decision was made
    (e.g., choosing the wrong framework), it is comparatively easy to pivot and refactor
    the service without affecting other software components.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 小型服务提高可扩展性、灵活性和部署的简便性。团队可以独立地开发、部署和扩展服务。微服务和纳米服务足够小，可以由一个团队拥有，因此它们鼓励自主性，并赋予团队做出自己决策的能力。即使做出了错误的决定（例如，选择了错误的框架），相对而言，在不影响其他软件组件的情况下重新定位和重构服务也相对容易。
- en: Application logic has also shifted from imperative to reactive and from synchronous
    to asynchronous processing. Many new systems embrace event-driven architectures
    and reactive handling. Many business use cases do not require everything to be
    completed to receive a response. A lot of processing can be done in real-time
    asynchronously by reacting to events. We covered the combination of CQRS and event-sourcing
    in [*Chapter 9*](B21737_09.xhtml#_idTextAnchor307), which provides an example
    of responding to synchronous requests earlier and having the rest of the processes
    executed asynchronously.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 应用逻辑也从命令式转变为响应式，从同步处理转变为异步处理。许多新系统采用事件驱动架构和响应式处理。许多业务用例不需要完成所有操作才能收到响应。许多处理可以通过实时异步地响应事件来完成。我们在[*第9章*](B21737_09.xhtml#_idTextAnchor307)中探讨了CQRS和事件溯源的结合，它提供了一个在早期响应同步请求并异步执行其余过程的示例。
- en: Having a system split into small services brings the challenge of keeping overall
    system behaviors consistent. This leads to the discussion of idempotence, replication,
    and recovery, as discussed in [*Chapter 10*](B21737_10.xhtml#_idTextAnchor334).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统拆分为小型服务带来了保持整体系统行为一致性的挑战。这导致了对幂等性、复制和恢复的讨论，正如在[*第10章*](B21737_10.xhtml#_idTextAnchor334)中所述。
- en: This change in thinking has improved responsiveness and scalability, making
    it easier to integrate with numerous services and handle high-throughput scenarios.
    We covered performance and scalability in depth in [*Chapter 12*](B21737_12.xhtml#_idTextAnchor379).
    We also
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这种思维方式的改变提高了响应性和可扩展性，使得与众多服务集成以及处理高吞吐量场景变得更加容易。我们在[*第12章*](B21737_12.xhtml#_idTextAnchor379)中深入探讨了性能和可扩展性。我们还在
- en: The shift-left paradigms – API-first and security-first approaches
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 左移范式——API优先和安全性优先的方法
- en: Continuing with software component downsizing, APIs become more important. In
    fact, the API-first design approach has gained popularity these days. The API-first
    approach advocates that APIs should be developed before the actual implementation
    of the features.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行软件组件精简的过程中，API变得更为重要。事实上，API优先的设计方法在当今越来越受欢迎。API优先的方法倡导在功能实际实现之前先开发API。
- en: This approach facilitates communication and collaboration between teams. It
    unblocks the development of the consumer side (e.g., another service or a frontend
    application) earlier and allows for parallel development. Developing APIs first
    also gives engineers a perspective to discover corner use cases before implementing
    them. We provided an example of the use of OpenAPI specifications in [*Chapter
    4*](B21737_04.xhtml#_idTextAnchor102).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法促进了团队之间的沟通和协作。它提前解决了消费者端（例如，另一个服务或前端应用程序）的开发问题，并允许并行开发。首先开发API还让工程师在实施之前发现边缘用例的视角。我们在[*第4章*](B21737_04.xhtml#_idTextAnchor102)中提供了一个使用OpenAPI规范示例。
- en: The increasing popularity of DevSecOps, as discussed in [*Chapter 14*](B21737_14.xhtml#_idTextAnchor442),
    has brought security to the engineers’ attention. By integrating security practices
    into software development (e.g., threat modeling), teams can address security
    concerns and incorporate them into early technical design. This approach has enhanced
    the security posture and reduced vulnerabilities of an application.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第14章*](B21737_14.xhtml#_idTextAnchor442)中讨论的，DevSecOps的日益普及将安全问题带到了工程师的注意中。通过将安全实践集成到软件开发中（例如，威胁建模），团队可以解决安全问题并将它们纳入早期技术设计。这种方法提高了应用程序的安全态势并减少了漏洞。
- en: The influence of cloud and serverless architectures
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云和服务器端架构的影响
- en: Cloud computing and serverless architectures have changed the landscape of software
    development forever. Cloud providers manage the infrastructure and automatically
    scale resources. Engineers can focus on fulfilling business requirements in code
    rather than tackling infrastructure concerns. Moreover, serverless architectures
    are cost-effective and reduce operational overhead.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算和无服务器架构已经永远改变了软件开发的面貌。云提供商管理基础设施并自动扩展资源。工程师可以专注于用代码满足业务需求，而不是解决基础设施问题。此外，无服务器架构具有成本效益并降低运营成本。
- en: The numerous services and tooling for cloud environments, such as Kubernetes,
    allow applications to take advantage of cloud provider features to improve scalability
    and resilience.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 云环境中的众多服务和工具，如Kubernetes，允许应用程序利用云提供商的功能来提高可扩展性和弹性。
- en: Moreover, there is a wide range of PaaS and SaaS running on the cloud, which
    makes it easier to integrate these services with any application. These services
    include relational databases, messaging services, identity providers, email services,
    and even fully-fledged enterprise software systems. We discussed serverless architecture
    in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，云上运行着广泛的PaaS和SaaS服务，这使得将这些服务与任何应用程序集成变得更加容易。这些服务包括关系数据库、消息服务、身份提供者、电子邮件服务，甚至完整的企业级软件系统。我们在[*第6章*](B21737_06.xhtml#_idTextAnchor212)中讨论了无服务器架构。
- en: Composable architecture
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可组合架构
- en: The idea of small services extends to breaking down software into independent
    modules or components that can be easily assembled or replaced. This building
    block approach leads to composable architecture, where each block aims to address
    specific concerns. These modules are designed to be cohesive to integrate with
    any application.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 小服务的理念扩展到将软件分解成独立的模块或组件，这些模块或组件可以轻松组装或替换。这种构建块方法导致了可组合架构，其中每个块旨在解决特定问题。这些模块被设计成内聚的，以便与任何应用程序集成。
- en: This approach increases the agility and flexibility of the overall architecture.
    It enables applications to rapidly adapt to a technology and to experiment with
    multiple options at a lower cost.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法增加了整体架构的敏捷性和灵活性。它使应用程序能够快速适应技术，并以较低的成本进行多种选项的实验。
- en: For instance, the *household service* that was brought up in many chapters can
    be reused in business problems other than household exchanging services. The service
    can easily integrate with other systems (e.g., voting, recycling, etc.) due to
    its modularity and high cohesiveness. We discussed in length how to define bounded
    contexts that result in well-defined services in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289).
    We also discussed layered and modular architectures in [*Chapter 7*](B21737_07.xhtml#_idTextAnchor255).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在许多章节中提到的*家庭服务*可以用于除家庭交换服务以外的商业问题。由于其模块化和高度内聚性，该服务可以轻松地与其他系统（例如，投票、回收等）集成。我们在[*第8章*](B21737_08.xhtml#_idTextAnchor289)中详细讨论了如何定义边界上下文，从而产生定义良好的服务。我们还在[*第7章*](B21737_07.xhtml#_idTextAnchor255)中讨论了分层和模块化架构。
- en: Architecture patterns continue to grow and evolve. Having composable architecture
    enables each pattern to independently advance and improve.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式持续增长和演变。拥有可组合架构使得每个模式可以独立地进步和改进。
- en: Observability and monitoring
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察性和监控
- en: Observability and monitoring have become an integral part of software architectures
    these days. Not only do engineers want to gain an understanding of system behaviors
    through logging, tracing, and monitoring tools but engineers also want to identify
    issues quicker.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性和监控已成为当今软件架构的一个基本组成部分。工程师不仅希望通过日志、跟踪和监控工具了解系统行为，还希望更快地识别问题。
- en: Observability and monitoring tools run in the cloud and are easy to integrate,
    typically using the Sidecar pattern, as mentioned in [*Chapter 14*](B21737_14.xhtml#_idTextAnchor442),
    which is also an approach to composable architecture.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性和监控工具在云中运行，易于集成，通常使用如[*第14章*](B21737_14.xhtml#_idTextAnchor442)中提到的Sidecar模式，这也是一种可组合架构的方法。
- en: Auditing has also become an important aspect of software products. Having the
    ability to understand actions performed in the system provides insights into technical
    and business processes. This is particularly helpful for systems that need to
    comply with regulations.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 审计也已成为软件产品的一个重要方面。能够理解系统中执行的操作，可以深入了解技术和业务流程。这对于需要遵守规定的系统尤其有帮助。
- en: We covered the topic of auditing and monitoring models in [*Chapter 11*](B21737_11.xhtml#_idTextAnchor358).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第11章*](B21737_11.xhtml#_idTextAnchor358)中讨论了审计和监控模型。
- en: AI and machine learning
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI和机器学习
- en: AI and **machine learning** (**ML**) are significantly shaping the future of
    software architectures. ML is a subset of AI that focuses on learning from data
    to generate predictions and help decision-making.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: AI和**机器学习**（ML）正在显著塑造软件架构的未来。ML是AI的一个子集，专注于从数据中学习以生成预测并帮助决策。
- en: AI/ML consumes a lot of data to train its model, thus making software architectures
    increasingly data-centric. Systems that use AI/ML need to efficiently collect,
    store, and process large volumes of data.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: AI/ML需要消耗大量数据来训练其模型，这使得软件架构越来越以数据为中心。使用AI/ML的系统需要有效地收集、存储和处理大量数据。
- en: Cloud providers provide ready-to-use AI/ML services so engineers can run them
    without managing the infrastructure and automatically scale them on demand. These
    services (e.g., AWS Bedrock, Azure OpenAI, and GCP Vertex AI) include natural
    language processing, behavior analysis, predictive analytics, generating recommendations,
    summarizing data, and pattern recognition, and the list is still growing.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商提供现成的AI/ML服务，工程师可以无需管理基础设施即可运行它们，并可以根据需求自动扩展它们。这些服务（例如AWS Bedrock、Azure
    OpenAI和GCP Vertex AI）包括自然语言处理、行为分析、预测分析、生成推荐、数据摘要和模式识别，而且这个列表还在增长。
- en: Even better, these AI/ML APIs use the format and transport that engineers are
    already familiar with, such as JSON payload and HTTP requests. Engineers can leverage
    advanced AI capabilities without needing deep expertise in AI/ML. The ease of
    integration has sped up development cycles.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，这些AI/ML API使用工程师已经熟悉的格式和传输方式，例如JSON有效载荷和HTTP请求。工程师可以利用高级AI功能，而无需深入了解AI/ML。这种易于集成的特性加速了开发周期。
- en: Apart from using AI/ML in business applications, they are also used in monitoring,
    incident response, threat detection, semantic code completion, and chat box support
    for engineers. The ubiquitous features powered by AI/ML are driving a transformative
    shift in software architecture, promoting data-centric designs, modularity, and
    integration of advanced analytics into applications.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在商业应用中使用AI/ML之外，它们还用于监控、事件响应、威胁检测、语义代码补全和工程师的聊天框支持。由AI/ML驱动的无处不在的功能正在推动软件架构的转型性变革，促进以数据为中心的设计、模块化和将高级分析集成到应用程序中。
- en: AI and ML will shape not only how applications are built but also how they interact
    with data in real time. We are still witnessing the evolution of AI and ML, and
    we have not seen the full scale of them yet.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: AI和ML不仅将塑造应用程序的构建方式，还将塑造它们与实时数据的交互方式。我们仍在见证AI和ML的演变，我们还没有看到它们的全部规模。
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a few Kotlin language features that can assist engineers in achieving
    better architectures, including extension functions, infix functions, operator
    overriding, and scoping functions.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一些可以帮助工程师实现更好架构的Kotlin语言特性，包括扩展函数、中缀函数、操作符重载和作用域函数。
- en: Then, we covered the necessary steps to transition a Java project into a Kotlin
    project. We walked through the tools and manual correction required to convert
    a Java class into an idiomatic Kotlin class. We also mentioned a few opportunities
    to improve code quality during the conversion. We delved into the topic of transition
    strategies in terms of the sequence of conversion and framework transition. We
    emphasized the importance of continuous transition to Kotlin, and how the transition
    could incrementally progress in the everyday business feature coding works.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了将 Java 项目过渡到 Kotlin 项目的必要步骤。我们详细介绍了将 Java 类转换为惯用 Kotlin 类所需的工具和手动修正。我们还提到了在转换过程中提高代码质量的一些机会。我们深入探讨了转换策略，包括转换顺序和框架转换。我们强调了持续过渡到
    Kotlin 的重要性，以及过渡如何可以逐步在日常业务功能编码工作中进行。
- en: 'We moved to the topic of CI and CD and presented the two main integration approaches:
    feature-based and trunk-based development. We compared them in terms of their
    pros, cons, and suitability in the context of organizational structure.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们转向了 CI/CD 的话题，并介绍了两种主要的集成方法：基于功能的开发和基于主干线的开发。我们比较了它们在组织结构背景下的优缺点和适用性。
- en: 'We made distinctions between three concepts: the deployment, release, and launch
    of a software product. Then, we walked through three release strategies: blue-green,
    feature flagging, and canary release. We presented a sample decision tree to help
    engineers select which release strategy is suitable from a technical perspective.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们区分了三个概念：软件产品的部署、发布和上线。然后，我们介绍了三种发布策略：蓝绿部署、功能标志和金丝雀发布。我们展示了一个示例决策树，以帮助工程师从技术角度选择合适的发布策略。
- en: We also covered the topic of DX, explaining its importance and how it benefits
    the software product, the team, and the organization.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了 DX 的话题，解释了其重要性以及它如何使软件产品、团队和组织受益。
- en: We made numerous suggestions for improving DX, including onboarding, tools,
    development processes, communication, collaboration, feedback, continuous improvement,
    recognition, and rewards.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出了许多改进 DX 的建议，包括入职、工具、开发流程、沟通、协作、反馈、持续改进、认可和奖励。
- en: Lastly, we reflected on the software architecture that was discussed throughout
    the whole book, with a focus on current trends and future development.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了整本书中讨论的软件架构，重点关注当前趋势和未来发展方向。
