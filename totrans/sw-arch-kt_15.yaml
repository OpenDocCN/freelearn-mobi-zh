- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to go through a few topics that will help engineers
    build better software. Some of the topics may not be related to software architecture,
    but consideration of their usage will support and enhance better architectures.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, engineers should be equipped with a few tricks up
    their sleeves to boost their productivity and remove impediments when implementing
    software with a certain architecture style in mind. These tools are Kotlin-related
    if implemented in code; otherwise, some of them are general engineering utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the conceptual understanding of all the architectural topics in previous
    chapters can be translated into practical and pragmatic solutions, with the aid
    of the toolkit in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Powered by Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning from Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration and delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer experience matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final thoughts on software architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15)'
  prefs: []
  type: TYPE_NORMAL
- en: Powered by Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin as a programming language has provided a lot of syntactic support for
    engineers to concisely express the intent of their code. Moreover, some of the
    features allow engineers to separate concerns and organize the code to be more
    manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin extension functions allow adding extra functionalities to an existing
    class without modifying its source code. This feature is useful and even mandatory
    for the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add more functions to a class from an external library, or a final class. For
    example, we want to extract the first letter of each word and join them by a dot,
    so `Sam Payne` would become `S.P`. The Kotlin String does not provide a function
    for this, so we can write an extension function instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enhance a class to fit in certain Kotlin language features, such as operator
    override (`+`, `-`, `in`, etc.). The use of operator override will be discussed
    in detail in coming sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add null safety functions to handle situations such as trying to concatenate
    a nullable list of strings. Having a nullable receiver as `List<String>?` in the
    extension function ensures that a string will be created, whether the list is
    null or not. The implementation is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, there is also a use case that would support better architecture. Extension
    functions can be used to separate concerns of a class by isolating its functions
    in a different package with non-public visibility.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have the `Name` data class from the previous example. This data
    class is a domain entity that needs to be converted to different formats, depending
    on the operation’s context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that an object of the `Name` class needs to be converted to a JSON string,
    there are a few common function signature styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name` class has exposed the JSON representation of the object to all usages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, not all usages need this function. Business logic is unlikely to need
    the JSON representation of the object. This approach mixes up the concerns of
    business logic and external representation, and worse, this external representation
    does not apply to all situations either.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`toJson` is now public to all projects that have access to the `Name` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is functionally equivalent to the **non-local extension function** implementation;
    the difference is that the extension function moves the parameter to the function
    receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The vanilla function implementation creates noise when an engineer searches
    for functions whose names start with `to`, especially in an IDE and if all data
    classes have separate `toJson` functions. This phenomenon is called **scope pollution**
    as we expose functions more than necessary. A quick workaround to this is to have
    a class or a singleton Kotlin object with a member function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the JSON transformation is only required for external integration,
    then it may be possible to locate the transformation functions together with the
    external integration code, and the function can be private as a **local** **extension
    function**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This approach allows engineers to extend the functionality of a class while
    restricting the usage only under the context that is within the same file. In
    other words, different concerns around an entity can be separated by having local
    extension functions grouped by files in the source base.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is nothing new, as a private visibility modifier to a function does exactly
    that. Nonetheless, the ability to put the data class as the receiver of a function
    and extend its behaviors brings several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: One fewer parameter in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on the entity as it becomes the receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the function as if it were a member of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fluent call chaining with other functions that are either member functions or
    extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin extension functions enhance the flexibility and readability of your code,
    by allowing engineers to add new functionalities to existing classes in a modular
    way. Meanwhile, there is a way to restrict the usage to avoid scope pollution
    and to separate concerns. After all, Kotlin extension functions promote better
    coding practices and make code easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Infix modifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Kotlin infix modifier is another way to create more readable and expressive
    code. We discussed `When` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us define a `PreCondition` class and an `Action` class related to integer
    (`Int`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Type aliases** in Kotlin allow engineers to create a new name for an existing
    type. They also allow engineers to quickly map a name to a function type. The
    type alias for a function type is especially beneficial in declaring interfaces
    of a single function, which helps engineers implement code that conforms to the
    **single-responsibility principle** (**SRP**), as discussed in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may still seem puzzling how they can look like Gherkin language for the
    BDD test scenario at this point. When we add `infix` functions, the code will
    start to support natural language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`PreCondition` here is used as a return type and the receiver of another function.
    We need an implementation of `Action` and a function to verify the result to complete
    a simple test scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting them all together, we can produce a test scenario like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this line, it should throw an exception with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The exciting part of this example is that the infix feature from Kotlin lets
    us omit the dots for function invocation and the brackets for the single parameter
    for each infix function. So, the code becomes remarkably close to natural language
    and the Gherkin language syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it would take a long time to have a fully-fledged Gherkin-style code
    for BDD test scenarios from this point beyond. However, this example has demonstrated
    how Kotlin infix functions can make the code readable and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some ground rules for having an infix function in Kotlin to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: It is either a member function of a class or an extension function with a receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can only be one parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infix functions are usually used in building intuitive and readable **domain-specific
    languages** (**DSLs**). They are used a lot in chaining operations, such as the
    example we have just demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: Operator override
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operator override is another way to make your code readable and intuitive.
    It allows engineers to define custom behaviors for operators such as `+`, `-`,
    and so on. The syntax was already shown previously when we discussed extension
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `operator` modifier before the `fun` keyword indicates the intention to
    override a built-in operator. The return type needs to be the same as the receiver
    or the belonging class. All operators that can be overridden are listed in *Table
    15.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Function name** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15.1 – Kotlin operators that can be overridden
  prefs: []
  type: TYPE_NORMAL
- en: It is important that operators are overridden with compatible semantics. For
    example, the `+` operator should create a new instance of the type with the two
    objects of the same type combined. If the `plus` function has side effects such
    as updating the value of an existing object, then it is not appropriate to override
    the operator.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scoping functions in Kotlin execute a block of code within the context of an
    object. A scope starts with an opening curly bracket, `{`, and ends with a closing
    curly bracket, `}`, which is already natural to programming languages. We already
    have class scopes, function scopes, and lambda scopes, all of which use curly
    brackets to indicate the boundaries. Also, the inner scopes have visibility and
    access to the declared values and functions from the enclosing scopes. For example,
    a member function has access to other functions from its encompassing class.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in scoping functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scoping functions in Kotlin provide another means to have a confined scope
    that focuses on a context object. There are five scoping functions provided, as
    shown in *Figure 15**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Kotlin built-in scoping functions](img/B21737_15_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Kotlin built-in scoping functions
  prefs: []
  type: TYPE_NORMAL
- en: Each of the five scoping functions (`let`, `apply`, `run`, `with`, and `also`)
    has its own use case and behavior. There are two main differences among them.
    The first difference is whether the context object is `it` or `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three statements return the same result of `"35"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `let` function uses `it` as the context object, while `run` and `with` use
    `this` as the context object.
  prefs: []
  type: TYPE_NORMAL
- en: It is also noticeable that `run` and `with` are functionally equivalent, but
    the syntax is different. The `run` function is an extension function, while `with`
    is a top-level function. Engineers can make use of the difference to communicate
    the intent of the usage. Typically, the context object is the focus of the operation
    when using the `run` function. If another object is the focus of the operation,
    the `with` function can be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is whether the result of the lambda or the receiver is
    returned. This is like a peeking function where engineers want to insert an extra
    operation but do not want to alter the result. The following two statements return
    the same result of `"3"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Any output evaluated in the lambda expressions is not used as return values.
  prefs: []
  type: TYPE_NORMAL
- en: Custom scoping functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing your own scoping functions can bring powerful features to your system.
    It is particularly useful in building up a result within a predefined scope. It
    is often that a system is required to perform a full validation on an incoming
    request and report all validation failures in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a builder class that can accumulate validation errors, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ValidationBuilder` class uses a mutable list of String to collect all
    validation errors found in the process. Then, we can define a custom scoping function
    that defines the start and the end of the validation, and validation is performed
    within the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This scoping function is an extension function using a generic type as the receiver,
    so the `validate` function can be invoked on any object. It takes a lambda expression
    as a parameter, in which an instance of `ValidationBuilder` is passed as a context
    object identified by `this`. At the end of the `validate` function, all errors
    collected are returned as an immutable `List`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example usage can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple validation on a `String` object with two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Must be less than 20 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must not contain the percent sign, `%`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The validation starts with the `String` object with the `validate` extension
    function. Inside the lambda scope, the `evaluate` function is called twice with
    the evaluations and the error messages. `ValidationBuilder` collects error messages
    if the evaluation has failed. A list of validation errors is returned and printed
    to the console. The console should have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The output has shown how full validation can be performed on a string with the
    custom scoping function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom scoping functions are also popular with complex object building, such
    as a large domain object. In fact, it is used in the popular framework **Ktor**
    to build the server-side routing configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We have demonstrated the use of a custom scoping function to perform full validation
    and collect all validation errors. Custom scoping functions are particularly useful
    in collecting elements within the scope, with the builder passed in as a context
    object.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to cover the topic of transitioning from Java to Kotlin in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin as a programming language was developed by JetBrains, a software company
    known for software development tools such as IntelliJ IDEA. The project started
    in 2010 and it aimed to create a language that is compatible with Java but with
    improvements over some of the drawbacks of Java. The name *Kotlin* comes from
    Kotlin Island in the Baltic Sea near St. Petersburg, Russia.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin 1.0 was released in July 2011 with features such as null safety, static
    typing, and type inference. It started to gain popularity in 2016 when it introduced
    features such as 100% Java interoperability, extension functions, lambda expressions,
    and higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: In 2017, Google announced official support for Kotlin on Android. Google’s collaboration
    with JetBrains on Kotlin supporting Android has made Kotlin a popular choice for
    Android developers. In 2018, JetBrains introduced Kotlin Multiplatform, which
    enables Kotlin code to be translated and compiled to run in Android, iOS, and
    web applications. Around the same time, Kotlin for backend services gained more
    and more attention from backend engineers, especially those with a Java background.
  prefs: []
  type: TYPE_NORMAL
- en: The 100% Java interoperability has enabled many Java engineers to smoothly transition
    to writing Kotlin code for commercial applications. There are a few tools and
    tips that we are going to share with you.
  prefs: []
  type: TYPE_NORMAL
- en: The IntelliJ IDEs from JetBrains have provided a tool to convert a Java file
    code to a Kotlin file code. It might sound magical, but the reality is that there
    are still a couple more adjustments needed to be truly idiomatic Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Kotlin in a Java project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that there is a Java project already, we need to set up the project to
    compile Kotlin source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the project uses Gradle, adding a Kotlin plugin is sufficient, such as the
    following code with Gradle Kotlin DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the equivalent of the setting with Gradle Groovy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Projects using Maven would require the following changes in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration defines the Kotlin version as `2.0.20`. Also, it
    imports a plugin that enables the compilation of Kotlin source code.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Java files and moving them to Kotlin folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kotlin files can be located under the `src/main/java` and `src/test/java` folders,
    but it is recommended to have them stored under `src/main/kotlin` and `src/test/kotlin`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us convert the following Java class to Kotlin, using IntelliJ’s conversion
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This Java class is immutable, so all fields are private, and the list is not
    exposed in the getter for immutability. As you convert the Java file using the
    conversion tool, IntelliJ reminds you that some corrections still need to be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the Kotlin class after conversion by the tool (in IntelliJ, right-click
    the Java file and choose **Convert Java File to** **Kotlin File**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some immediate changes to be made to become an idiomatic Kotiln class:'
  prefs: []
  type: TYPE_NORMAL
- en: Update to a Kotlin data class since this class is intended to be an entity class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `init` block with a constructor as much as possible. Only true initialization
    logic should remain in the `init` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Kotlin’s immutable `List` interface as a member field. The same should apply
    to other `Collection` interfaces. Using Kotlin’s collection interfaces closes
    off the risks of the collection being mutated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `getMembers` getter function as there is no need to return a new
    copy of the list due to the immutable `List` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the nullable symbol (`?`) unless there is a reason to expect nullable
    values. This is an opportunity for engineers to eliminate null checks that become
    unnecessary after converting to Kotlin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the result of the conversion, which started with the tool and ended
    with some manual corrections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If the Java entity class was using an external library such as Lombok ([https://projectlombok.org/](https://projectlombok.org/))
    to auto-generate setter and getter functions, then we would need to remove the
    Lombok annotations, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 14 has introduced a new feature called **record classes** that work like
    Kotlin data classes. An example of a Java record class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting it to Kotlin is relatively straightforward, but there is a `JvmRecord`
    annotation that remains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The annotation is only there to preserve some of the function names such as
    `account.getNumber()` for backward compatibility reasons. If this is not a concern,
    we can remove this annotation and let users of this class use `account.number`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic expressions, code styling, and conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Converting a Java file to a Kotlin file is a great opportunity for engineers
    to start adopting Kotlin’s idiomatic expressions and conventions. It is highly
    recommended that the engineers pick a lint tool to unify the Kotlin style from
    the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: Ktlint ([https://github.com/pinterest/ktlint](https://github.com/pinterest/ktlint))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KtFmtFormat ([https://github.com/facebook/ktfmt](https://github.com/facebook/ktfmt))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detekt ([https://github.com/detekt/detekt](https://github.com/detekt/detekt))
    – also a static code analysis tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spotless ([https://github.com/diffplug/spotless](https://github.com/diffplug/spotless))
    – also supports other languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking the “best” code style is the least concern to engineering quality, but
    having a unified style is important for the team to focus on more important aspects
    such as correctness and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence of conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given an existing Java project, it is also recommended to convert Java classes
    in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Test classes as these represent the lowest risk. This is a safe space for engineers
    to learn Kotlin and make mistakes with a low impact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Top-level classes that no other classes depend on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the application uses layered architectures, as covered in [*Chapter 7*](B21737_07.xhtml#_idTextAnchor255),
    classes in the outer layers (i.e., adapters, imperative shells, frameworks, and
    drivers) should be converted first, then go inward until reaching the code. The
    Kotlin interoperability with Java is smoother when Kotlin code calls Java code
    than vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the conversion, engineers often start looking to replace frameworks in
    Java with equivalent libraries in Kotlin; we are going to discuss these in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Framework replacement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the conversion journey, it is inevitable that someone will bring up
    the discussion of whether a Java library should be replaced by another library
    that supports native Kotlin. We discussed the paradox of new frameworks in [*Chapter
    1*](B21737_01.xhtml#_idTextAnchor013), and on the specific topic of conversion
    from Java to Kotlin, there are a few things we should keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything still works! It seems obvious but the team could choose not to replace
    any existing framework, due to the 100% Java interoperability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is likely a one-way trip. The new Kotlin library may not aim to support
    Java projects, except those libraries that already existed before Kotlin became
    popular. If the project still uses Java but needs to use the new Kotlin library
    with Java, the usage may be awkward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple Kotlin libraries that the open source community has contributed
    to provide a Kotlin-first library experience. Some of them look similar in terms
    of approaches, activities, and number of contributors. The team may fall into
    the paralysis of analysis, not knowing which one to use. This is more of a general
    open source framework adoption concern, but it affects transitioning from Java
    to Kotlin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not uncommon for contributors to stop some of the efforts for Kotlin-first
    newer frameworks. It is a natural evolution where some of the ideas have turned
    out to be not so viable or feasible. The team can always wait till the Kotlin-first
    library matures. Again, this is a concern for open source projects in general.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the existing Java frameworks have Kotlin support as an extra dependency
    to help engineers with the transition. The Kotlin module may just be enough and
    there is no need to phase out the framework altogether.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin-first frameworks developed by popular communities or reputable organizations
    supporting Kotlin are likely to have stronger support and continuity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite the numerous factors for framework replacement, there are a few Kotlin-first
    frameworks that are worth a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client and** **server frameworks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring: [https://spring.io/](https://spring.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ktor: [https://ktor.io/](https://ktor.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Http4K: [https://www.http4k.org/](https://www.http4k.org/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Micronaut: [https://micronaut.io/](https://micronaut.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vert.x: [https://github.com/vert-x3/vertx-lang-kotlin](https://github.com/vert-x3/vertx-lang-kotlin)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Retrofit: [https://square.github.io/retrofit/](https://square.github.io/retrofit/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language** **enhancement frameworks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrow: [https://arrow-kt.io/](https://arrow-kt.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result4K: [https://github.com/npryce/result4k](https://github.com/npryce/result4k)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coroutines: [https://github.com/Kotlin/kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency** **injection frameworks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Koin: [https://insert-koin.io/](https://insert-koin.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence frameworks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exposed: [https://github.com/JetBrains/Exposed](https://github.com/JetBrains/Exposed)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing frameworks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kotest: [https://kotest.io/](https://kotest.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spek: [https://www.spekframework.org/](https://www.spekframework.org/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mockk: [https://mockk.io/](https://mockk.io/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI frameworks**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jetpack: [https://developer.android.com/jetpack](https://developer.android.com/jetpack)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compose Multiplatform: [https://github.com/JetBrains/compose-multiplatform](https://github.com/JetBrains/compose-multiplatform)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the challenges of transitioning to Kotlin is the combination with other
    changes, driven by business or technical stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that the transition to Kotlin takes place incrementally and
    continuously. For example, a new business feature can be written in Kotlin entirely,
    with some usage of existing Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers can also phase in Kotlin converted code when there is sufficient time
    and space, even during the development of other changes. The team can adopt a
    policy that, if a Java class needs to be updated, it is also converted to Kotlin.
    This policy adds a small overhead to each change, but it keeps the transition
    going without the need to halt.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping risks manageable is the key to transitioning a Java project to Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: The future of Kotlin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kotlin has grown out from being a better Java. Especially with Kotlin Multiplatform,
    Kotlin has become one of the most versatile programming languages in the market,
    as it can be used to write Android, iOS, desktop, web, data science, and backend
    applications. With the recent Kotlin V2 release, Kotlin continues to grow in popularity
    and usage. Engineers should keep an eye on Kotlin’s emerging trends (e.g., Kotlin
    Multiplatform, Kotlin Native, and cloud integration) and embrace its exciting
    upcoming progression.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss continuous integration and delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) and **continuous delivery** (**CD**) play
    a crucial role in software development productivity. They are collectively named
    **CI/CD** in many discussions due to their close relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: When we discussed the cost of finding and fixing an issue with an application
    in [*Chapter 13*](B21737_13.xhtml#_idTextAnchor418), we mentioned that the cost
    to fix an issue is lower if it is found earlier in the development process. In
    a typical environment in which a team of engineers work collaboratively on a source
    repository, it is also less expensive to fix an issue that is caused by code conflicts
    from this collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: 'CI is a software development practice in which engineers frequently integrate
    their changes into a shared source repository. The primary goal of CI is to detect
    integration issues early and reduce the time it takes to release new features
    or fixes. The practice of CI includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frequent commits**: Changes are frequently committed by multiple engineers
    in a team. Each engineer also frequently updates their local source project to
    receive changes from other team members. The commits are as frequent as multiple
    times a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated project builds**: Each commit integrates with the source repository
    and triggers an automated build to compile all source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated testing and feedback**: Each commit also triggers an automated
    test suite that includes a diverse variety of tests and quality assurance metrics,
    as discussed in *Chapters 12*, *13*, and *14*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Component tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated GUI testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Code vulnerability scanning
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Code style linting
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Static code analysis
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coverage by tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These test checks are part of the project build after code compilation. If any
    of the preceding checks fails the verification, the project build will fail and
    engineers will be notified. Engineers will then troubleshoot and fix the issue
    based on the feedback.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Version control**: CI uses a version control system to manage the code base.
    It supports keeping a full history of commits with audit records. It allows engineers
    to branch from the main code repository and later merge the branch back to the
    main branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with deployment**: CI is the first gate of quality that certifies
    whether an application is good enough for deployment. Once all checks and tests
    have passed, then the build process can continue the preparation for deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By shortening the feedback loop of *code-integrate-test-fix*, the team can deliver
    new features and fixes more frequently, reduce the time to market, and respond
    to user feedback quickly. It also improves the collaboration within the team and
    improves overall software quality through automated testing for each integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, another significant factor that would affect software development
    productivity. Most engineers who work in a team would have discussed the topic
    of branching strategies under a version control system. There are two popular
    strategies that keep on recurring in this never-ending debate: feature-based and
    trunk-based development.'
  prefs: []
  type: TYPE_NORMAL
- en: Feature-based development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Feature-based development can be characterized by its higher number and longer
    life of branches. Engineers can work in on their own branch in isolation. Each
    branch contains a big chunk of cohesive work, such as a feature or a release,
    and therefore, it lasts for a long period to gather all the changes required.
    At the same time, there are other long-lived branches that represent other features.
    An example of feature-based development is shown in *Figure 15**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – An example of feature-based development](img/B21737_15_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – An example of feature-based development
  prefs: []
  type: TYPE_NORMAL
- en: In this example, **Trunk** is the main branch that absorbs all changes from
    other branches. **Feature 1** branches out from **Trunk** and development continues
    in this feature branch. At the same time, the team needs to prepare a new release,
    so the **Release 1** branch is created from **Trunk**. The release branch is deployed
    to the UAT environment for acceptance testing as a release candidate.
  prefs: []
  type: TYPE_NORMAL
- en: After a few commits in the **Feature 1** branch, **Feature 2** needs to start
    development and it needs to make some changes from the **Feature 1** branch, so
    **Feature 2** branches out from the **Feature 1** branch, and the development
    of **Feature 2** continues in the new branch. **Feature 1** development is completed,
    so, a pull request is created for review, and subsequently, the branch is merged
    into **Trunk**.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers working on **Feature 2** want to keep its branch up to date, so they
    rebase the **Feature 2** branch from the latest **Trunk**. The **Release 1** branch
    does not need to rebase because **Feature 1** is not included in the coming release.
  prefs: []
  type: TYPE_NORMAL
- en: The **Release 1** branch has been deployed to production. There are a couple
    of bugs found after the production release, and unfortunately, one of them is
    a critical bug. So the **Release 1** branch cannot be merged into **Trunk** yet.
    While some engineers work on the lower priority fixes in the **Release 1** branch,
    a few engineers need to work on a hotfix immediately and fix the critical bug
    in the production environment. So, a hotfix branch is created for the critical
    bug fix.
  prefs: []
  type: TYPE_NORMAL
- en: The critical bug fix has been completed, deployed, and verified in UAT. So,
    it is released to the production environment. The hotfix branch is then merged
    into the **Release 1** branch. Afterward, all production bug fixes are completed,
    deployed, and verified in UAT. So, there is another production release to wrap
    up this release. The **Release 1** branch is then merged into **Trunk**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Feature 2** branch is not completed yet, so it needs to be rebased from
    **Trunk**. At the same time, engineers start to prepare a new release by creating
    a new release branch from **Trunk**.
  prefs: []
  type: TYPE_NORMAL
- en: Feature-based development isolates branches and keeps them focused on their
    purposes. The **Release 1** branch in the example has naturally prevented **Feature
    1** from affecting the release. Also, the hotfix branch gives engineers a stable
    and safe space to concentrate on fixing the critical production bug, knowing that
    the critical fix can be patched as a priority without needing to consider other
    unrelated changes. Feature-based development uses pull requests that encourage
    code review and collaboration among engineers.
  prefs: []
  type: TYPE_NORMAL
- en: However, numerous long-lived branches bring the overhead of branch management.
    It introduces a high complexity of conflicts when merging or rebasing branches.
    This is particularly bad when there is substantial refactoring such as moving
    a file to another folder in one branch while the file is updated in another branch.
    This type of tree conflict often results in complex, time-consuming, and error-prone
    code merges. The mitigation of this issue is to rebase long-living branches frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trunk-based development encourages engineers to work on a single branch, which
    is *Trunk* (also known as **main**). However, each commit to the *Trunk* branch
    is done by merging from short-lived branches as pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'It advocates small, frequent, and incremental changes to be committed to *Trunk*
    frequently. Each branch is short-lived and usually does not last more than a few
    days. There are frequent rebase or merge operations for each branch to get the
    latest changes from *Trunk*. An example of trunk-based development is illustrated
    in *Figure 15**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – An example of trunk-based development](img/B21737_15_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – An example of trunk-based development
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the **Feature 1** branch is created from **Trunk** for development.
    The **Feature 2** branch is also created from **Trunk** for development.
  prefs: []
  type: TYPE_NORMAL
- en: The **Feature 1** branch has developed the code to a milestone where it is tested,
    verified, and releasable, but the feature itself is not completed. So, a pull
    request for **Feature 1** is created for review, and subsequently, the branch
    is merged into **Trunk**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature 1** development needs to continue. So, a new branch is created from
    **Trunk** for the continuation of the **Feature** **1** development.'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the **Feature 2** branch has detected a commit made in **Trunk**,
    so the corresponding engineer rebases the branch from **Trunk** to get the latest
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, the development of **Feature 2** is completed, tested, and verified
    in its branch. So, a pull request is created for **Feature 2** for review. The
    branch is then approved and merged into **Trunk**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Feature 1** branch has detected a commit made in **Trunk**, so the corresponding
    engineer rebases the branch from **Trunk** to get the latest code.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development emphasizes that the *Trunk* branch should also be good
    enough for a release at any time. There is no concept of a release branch. That
    is why all branches should be tested, verified, and reviewed by peers before merging.
  prefs: []
  type: TYPE_NORMAL
- en: To extend this concept, each commit can trigger a software release to environments,
    even to production. This approach fits very well with the practice of CD, where
    software is frequently delivered to customers, vastly reducing the time to market.
    It also implies that automated tests should be more rigorous and thorough in the
    branch to assure software quality in the early stages of development.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development also fits well with rapid development and short iterations
    that are advocated in Agile development methodologies. The quick turnarounds and
    short feedback loop enable the team to evolve the software product faster.
  prefs: []
  type: TYPE_NORMAL
- en: The frequent commits and rebasing also reduce the complexity of merge conflict
    resolution. Any integration issue can be identified and fixed early, so the feedback
    loop for engineers is shorter. The branch management is simplified because the
    *Trunk* branch is the only focus.
  prefs: []
  type: TYPE_NORMAL
- en: Having a long-living branch is an anti-pattern under trunk-based development.
    For larger feature development, the changes need to be split into multiple branches,
    and therefore, multiple commits to the *Trunk* branch.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers need to make judgment calls on splitting the changes sensibly. It
    requires more thought and discipline from engineers to make sure each commit to
    *Trunk* is safe and can be released. **Feature flagging** is a common technique
    in hiding features in development and still allows code to be released to production.
    Feature flagging will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not uncommon for an engineer to have added changes that are not ready
    for production by mistake, despite the changes having been merged into *Trunk*.
    To make matters worse, there are other changes committed afterward. At this moment,
    *Trunk* is not ready for release. This situation leaves engineers with a few difficult
    choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Roll back**: Reverse all the commits to where *Trunk* is still safe for release.
    That would generate one more commit to *Trunk* for reversion. Re-apply the other
    required changes from new branches after the reversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cherry-picking**: Create a new branch from the latest *Trunk* and carefully
    unpick the unwanted changes. Merges this branch back to *Trunk*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roll forward**: Create a new branch from the latest *Trunk* and continue
    to work on the change with a focus on making *Trunk* ready for release again.
    Merge this branch back to *Trunk*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding choices require careful execution by engineers and none of
    them are easy. Many engineers would prefer rolling forward to keep the flow of
    development going at the cost of leaving some commits in *Trunk* unfit for release.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between feature-based and trunk-based development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The choice between feature-based and trunk-based is highly related to ways of
    working in the team and in the organization. This is an example of where **Conway’s
    Law** applies, as covered in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013),
    where organization structure affects the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature-based development** | **Trunk-based development** |'
  prefs: []
  type: TYPE_TB
- en: '| Long-lived branches | Short-lived branches |'
  prefs: []
  type: TYPE_TB
- en: '| Dedicated branches for release | *Trunk* is the branch for release |'
  prefs: []
  type: TYPE_TB
- en: '| Large features developed in long-lived branches | Large features are split
    into multiple short-lived branches |'
  prefs: []
  type: TYPE_TB
- en: '| High complexity in merge and rebase operations | Low complexity in merge
    and rebase operations |'
  prefs: []
  type: TYPE_TB
- en: '| Slower feedback for integration issues | Faster feedback for integration
    issues |'
  prefs: []
  type: TYPE_TB
- en: '| Development in isolation | Development with collaboration |'
  prefs: []
  type: TYPE_TB
- en: '| Roll back is more common | Roll forward is more common |'
  prefs: []
  type: TYPE_TB
- en: '| A hotfix branch for urgent issues | No concept of hotfix branches |'
  prefs: []
  type: TYPE_TB
- en: '| The release branch is stable | Complex operations to fix unreleasable commits
    in the trunk |'
  prefs: []
  type: TYPE_TB
- en: '| Release is less frequent | Release can be more frequent |'
  prefs: []
  type: TYPE_TB
- en: Table 15.2 – Comparison between feature-based and trunk-based development
  prefs: []
  type: TYPE_NORMAL
- en: Both development approaches have their advantages and trade-offs. Ultimately,
    the choice depends on the team size, project complexity, and development practice.
    Some teams may adopt a hybrid approach to maximize the benefits of each approach
    and reduce the drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a team may decide to have trunk-based development but a release
    branch is created to aim for each release. It reduces the need to unpick unwanted
    changes for release and keeps release preparation away from the development of
    other ongoing features.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example can be seen as a release strategy; nonetheless, there
    are more release strategies that we want to cover, and we are going to cover them
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Release versus deployment versus launch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an application is ready for release, there is a new landscape of concerns
    and strategies on how it gets into the hands of customers and end users. At certain
    times in history, it was just a binary condition of whether it was out or not.
    Modern releases are more sophisticated and complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to make distinctions among three concepts: release, deployment,
    and launch. These concepts might be used interchangeably in some organizations;
    however, they have subtle differences that should be discussed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment** is the least misunderstood concept. Deployment implies that
    the executable software artifact built from source code and configuration has
    been loaded to the target environment. This section focuses on the production
    environment. It is an operational and technical task that is often automated by
    scripts – optionally, with an approval process that involves human intervention.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Release** means the application is now available to the users in the target
    environment. Sometimes, we might also say releasing a feature, which means the
    intent of making the feature available to users. Deployment is the prerequisite
    of release. A feature in an application, even if the application has been deployed,
    may still not be available to some users.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Launching** an application is the least technically involved out of all three
    concepts. The term *launch* does not mean starting up an application. Instead,
    it implies the software product is marketed, advertised, and, optionally, has
    a launch event such as a press conference or an exhibition. Launching a software
    product is not part of the CI/CD life cycle. Releasing is the prerequisite of
    launching as users need to access the application. Launching would involve a go-to-market
    plan, with a variety of non-technical stakeholders involved (e.g., marketing,
    sales, customer services, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: With these distinctions, release strategies of software products are where the
    complications are in relation to CD. We are going to cover a few common release
    strategies next.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-green release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Blue-green release** keeps the current version (*blue*) of an application
    in the production environment and has a new version (*green*) deployed to a replica
    of the production environment. This strategy allows the new version of the application
    to be deployed while keeping the current version available to users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This strategy typically applies to server-side web-based applications and the
    **Domain Name System** (**DNS**) to route web requests to the new or current version
    of the application. The blue-green release strategy can be seen in *Figure 15**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – An example of a blue-green release](img/B21737_15_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – An example of a blue-green release
  prefs: []
  type: TYPE_NORMAL
- en: The DNS, by default, routes web requests to **Zone 1** (**Blue**) where the
    current versions of applications are running. The applications in the **Blue**
    zone communicate with each other only, by keeping them in the same **local area**
    **network** (**LAN**).
  prefs: []
  type: TYPE_NORMAL
- en: While the `api.zone2.contract.system` in contrast to the general `api.contract.system`).
    Engineers can even troubleshoot and fix issues found in the new versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new versions are verified and ready to be used by users, the traffic
    can be switched in the DNS, so web requests are routed to **Zone 2**. **Zone 2**
    is now the new **Blue** zone in effect. There is no more **Green** zone, as illustrated
    in *Figure 15**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – A blue-green release (after switching)](img/B21737_15_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – A blue-green release (after switching)
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone 1** is now running older versions of applications that can be shut down
    till the next deployment, which turns this zone into the new **Green** zone. It
    is important to note that **Blue**/**Green** is the role of the zone that is going
    to flip from one another over time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A blue-green release is not the same as a rolling deployment. Rolling deployment
    aims to keep the service available while deployment is in progress. Rolling deployment
    usually takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Scale down the current number of application instances to one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the new version of the application to the target number as new instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start all instances of the new version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notify the load balancer of the existence of the new running instances, or let
    them be discovered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all instances of the new version are confirmed to be running by the probe
    endpoints, shut down the older application instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike the blue-green release, there is no time window in which engineers and
    QAs can test the newer version of the application without it being available to
    users. Additionally, this is a deployment technique only. It is not concerned
    with whether the application is available to users or not. It only cares whether
    the application has transitioned to the new version without outage or downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Dark release/feature flagging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are methods to verify new features without making them available to users.
    The new features can be deployed to the production environment normally but remain
    hidden from users, using **feature flagging** (also known as **dark release**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature toggle can be managed in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central**: There is a central service or resource that dictates whether a
    feature is available to the given user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Individual**: Each component or service manages its own feature flags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per request**: A non-publicly known request parameter is used to enable the
    feature to serve this request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of how feature flags are managed, this approach allows engineers
    and QAs to verify pre-released features before the features are available to users.
    The feature is only switched on when the team is happy with the verification results.
    In addition, the feature can be switched off even after it was made available
    to users, and thus it minimizes the impact of related issues.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flagging works well with the practice of **trunk-based development**,
    as discussed in previous sections. With the feature flag switched off, engineers
    can continue to develop the feature and merge their changes to the trunk. However,
    all automated tests should pass to ensure that existing functions still work as
    intended with the unfinished and switched-off feature in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flags mainly concern releases and making a feature available to users.
    Some organizations may extend feature flagging to support user segmentation and
    A/B testing, as mentioned in [*Chapter 13*](B21737_13.xhtml#_idTextAnchor418).
    This is not an anti-pattern, but only an enhancement of the system beyond feature
    flagging.
  prefs: []
  type: TYPE_NORMAL
- en: Canary release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **canary release** is a staged release strategy that makes the newly deployed
    software available to a small subset of users before rolling it out to all target
    users. It operates at the application level, not a feature in an application.
    It aims for incremental availability to users, and there are a lot of variations
    in this strategy in the initial selection of users and strategic increase of availability.
    There are a few factors that would affect this strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: The team might want to invite subject matter experts or domain experts to start
    using the application first, to gather feedback that might shape the product before
    the public uses it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The organization might want to initially release the software product to users
    in a selected geographic region. This could be due to the geographic context of
    the application, legal restrictions, or related marketing events. The organization
    might want to expand its geographic territory incrementally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team might want to initially release the application to certain types of
    devices or operating systems of devices. This could be due to compatibility concerns,
    especially in the Android application landscape, or due to the popularity of certain
    devices in the market.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A canary release is sometimes mistaken for the concept of beta testing. After
    a software product is signed off by internal QAs, some organizations might want
    to invite expert users to internal testing. Testing internally, typically with
    **white-box testing** techniques, as discussed in [*Chapter 13*](B21737_13.xhtml#_idTextAnchor418),
    is called **alpha testing**. Testing by external users before public release is
    called **beta testing**.
  prefs: []
  type: TYPE_NORMAL
- en: However, beta testing is not considered a production release because the version
    of the software product being tested is usually not the final version. Beta testing
    is only for a limited period.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback and suggestions from selected users are gathered to validate the product
    concepts, usability, and functionality. They are also used for further enhancement
    of the product. Releasing a non-final version of the software product for beta
    testing does not require a canary release strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a release strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing a release strategy is not easy or straightforward. However, it is
    certainly not recommended to do a Big Bang release with planned outages, as we
    discussed in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212). There are other
    factors involved in the decision, such as infrastructure readiness, marketing
    strategies, service uptime objectives, and so on. From a purely technical point
    of view, we can potentially use a decision tree to recommend a release strategy,
    as shown in *Figure* *15**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – An example of a technical decision tree of release strategies](img/B21737_15_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – An example of a technical decision tree of release strategies
  prefs: []
  type: TYPE_NORMAL
- en: Releasing a feature in an application should consider feature flagging or dark
    release first because it is the least expensive choice compared to others. If
    it is about releasing an entire application and it is a server-side application,
    a blue-green release or canary release can be considered. If the application involves
    desktop, mobile, or web applications, then a canary release should be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Please note this is more about technical restrictions of which release strategies
    can be used, instead of considering which one provides the best outcome due to
    other non-technical factors involved.
  prefs: []
  type: TYPE_NORMAL
- en: We are at the end of the discussion on CI/CD. A well-automated CI/CD pipeline
    saves a lot of time for engineers in trying to integrate with other people’s work
    and deliver the application to multiple environments. In a sense, it improves
    the experience of engineers working on software products. We are going to cover
    a bit more on the topic of the developer experience in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developer experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Developer experience** (**DX**) is what engineers experience while developing
    software. It includes everything from tools, processes, environments, teams, organizations,
    and the culture of development. We will bring up a few suggestions for improving
    DX in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does DX matter?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DX might, at first glance, look like the general satisfaction of any person
    working on a project. However, a great DX brings a lot of benefits to not only
    the engineers themselves but also to the software product and to the organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Productivity and efficiency**: Efficient tools, automated workflows, concise
    documentation, and smooth development processes remove the burden from engineers,
    so they can focus on coding and problem-solving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product quality**: Stable environments and intuitive tools reduce friction
    in the everyday work of engineers, so they can focus on delivering high-quality
    code with attention to detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operation cost**: Automated tools and processes reduce the labor cost for
    engineers to support the system. Also, better tools lead to fewer mistakes and
    thus reduce the time and resources spent on fixing issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning curve**: Streamlined onboarding process, good documentation, and
    intuitive processes make it quicker for a new engineer to get up to speed and
    become productive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration**: Good DX encourages communication and collaboration within
    the team and improves team morale. It also improves the interactions between engineers
    and stakeholders, which leads to better outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Innovation**: A safe and supportive environment fosters a culture of innovation
    and experimentation. Engineers can be creative in their solutions without the
    fear of failure. High-quality tools allow for trying new ideas collaboratively
    and learning collectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job satisfaction and retention**: A satisfactory working environment keeps
    engineers more engaged and motivated. When they enjoy the work they do, employee
    turnover can be lowered. In return, it saves time and resources on recruitment
    and training.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Talent acquisition**: If an organization has a reputation for great DX among
    technology communities, it attracts top talent to join the team and improves the
    branding of the organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DX has an influential role in delivering high-quality software products, ultimately
    leading to more healthy organizations and better business outcomes. We are going
    to cover a few areas that can improve DX next.
  prefs: []
  type: TYPE_NORMAL
- en: Onboarding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the general onboarding, there should be comprehensive documentation
    for engineering topics, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Development processes (Kanban, Scrum, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tech stacks used in the organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-house libraries and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architecture decision records** (**ADRs**), as mentioned in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engineering practices and conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized engineering environments set up (e.g., backend, frontend, data,
    platform, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These documents are best updated by each new engineer joining the organization,
    as it can keep the information up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Having a technical peer assigned as an onboarding partner is a helpful welcoming
    gesture for new engineers. The onboarding partner can pair with the new engineer
    in setting up environments for work, requesting appropriate permissions, adding
    the new engineer to the corresponding communication channel, and answering questions.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tools play a big part in an engineer’s productivity. Investing in good engineering
    tools brings not only great DX but also tangible productivity to the engineering
    teams. These tools include, but are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **single sign-on** (**SSO**) portal to access all other third-party tools.
    Instead of having everyone remember passwords for each third-party tool, logging
    in to these tools via a central portal saves a lot of time. This applies to all
    tools beyond engineering tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlined method to log in to any environment or infrastructure without compromising
    security and auditing. Historically, engineers need to access a server using means
    such as the **Secure Shell** (**SSH**) protocol with a terminal tool. In modern
    days, there are better ways to access a server in any environment. These tools
    (such as Teleport, JumpCloud, CyberArk, etc.) support a simple request-approval
    workflow for access, wrapping around the terminal tool, establishing tunneling,
    restricting certain access, and logging all the activities during access to secure
    the environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each engineer may have their own toolkit in their pocket, such as some scripts
    for certain tasks. It is recommended to have a source repository to host all these
    scripts and small toolkits accessible to all engineers. Not only can the organization
    absorb the secret powerful scripts from engineers but it also establishes a standard
    toolkit to help engineers perform their daily tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are circumstances where engineers need to call an API endpoint to perform
    certain tasks, such as rehydrating an event topic by requesting the publisher
    to publish all messages again. It is recommended that the organization has a shared
    collection of operational endpoints to reduce the time for engineers to craft
    these steps themselves. In addition, it is likely that those API endpoints require
    getting an authorization token as a bearer token to invoke endpoints (see [*Chapter
    14*](B21737_14.xhtml#_idTextAnchor442) for a detailed flow); the orchestration
    of getting these tokens should be scripted and shared among engineers. An example
    of this tool is **Postman Collections**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependencies of a Kotlin project are silently out of date over time. Use
    automation tools such as **Dependabot** to automatically create pull requests
    that update dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **artificial intelligence** (**AI**) applications in multiple areas of software
    development. Apart from the normal syntactic code completion features provided
    by the IDEs, there are also AI assistants that hint at semantic code completion
    by understanding the existing code base. There are also embedded **large language
    model** (**LLM**) chatbots that provide live technical advice with example code
    snippets. There are also pull request bots that understand the intent of pull
    requests and provide useful feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Organizations should invest in tools that support software development processes.
    Each team could have adopted slightly different methodologies such as Scrum or
    Kanban, and the team would need a dashboard to run the daily standup.
  prefs: []
  type: TYPE_NORMAL
- en: As remote working has become a trend, organizations should invest in tools such
    as issue-tracking systems, digital Kanban or Scrum boards, and online retrospective
    tools to enable the team to run any software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Communication and collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern organizations will already have invested in multiple communication tools
    for instant messaging, video conferencing, screen sharing and pairing, and emails.
    It is recommended that emails should only be used for external communication.
    Instant messaging should be the major way of communication.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it is recommended that each team has a channel where engineers can
    think out loud about their problem-solving. Members of the channel should form
    a habit of using threads to post messages about a specific problem. By concentrating
    discussion of a problem, it is possible to introduce AI bots to summarize the
    discussion for others to catch up.
  prefs: []
  type: TYPE_NORMAL
- en: The instant messaging system should integrate with other tools, so engineers
    have a one-stop shop to receive notifications and work reactively. This can include
    receiving notifications of a visual design change from design collaboration tools,
    a change of an issue in issue management tools, an alert from monitoring tools,
    approval in a pull request, or simply a daily meeting schedule summary.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers need to have tools to immediately jump on a remote pair-programming
    huddle with the capability to share screens and even take over control of input
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Some IDEs, such as IntelliJ Ultimate, have the capability to run pair-programming
    sessions. These tools enhance the collaboration between engineers and encourage
    collective learning.
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools that enhance collaboration between engineers and other
    disciplines in the team. For example, an online collaborative design tool such
    as Figma or Miro can be used as a sketchpad for engineers to work with designers
    and product managers to understand the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers in the same specialization (backend, frontend, data, testing, platform,
    etc.) can have their own forum as a *trade guild* in which engineers can share
    their learning and discuss topics that are closely related to their work.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback and continuous improvement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to periodically receive qualitative and quantitative feedback
    from engineers to discover any room for improvement. It is recommended to conduct
    regular surveys, feedback sessions, or retrospective sessions to gain insights
    into the satisfaction of engineers and to identify areas of improvement.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 11*](B21737_11.xhtml#_idTextAnchor358), the **SPACE**
    metrics provide a comprehensive and holistic assessment of the productivity and
    well-being of engineering teams.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, the engineering management needs to acknowledge the feedback
    and implement corresponding changes to improve the DX. Being listened to and seeing
    feedback taken on board would vastly improve the satisfaction and morale of engineering
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: Recognition and rewards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Engineering teams and management should recognize and celebrate achievements
    by teams or individuals. This can be done by explicitly shouting out the team
    and its members for their accomplishments or giving actual rewards for successful
    releases, innovative ideas, and implemented improvements. Recognition and rewards
    can boost morale and motivation.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts on software architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are coming to the end of the book, I would like to share my final thoughts
    on software architecture. I am going to cover the current trends and how we could
    equip ourselves to surf on the never-ending waves of change.
  prefs: []
  type: TYPE_NORMAL
- en: Small, reactive, and independent services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there are a few justifications for writing a monolithic application,
    as discussed in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212), software components
    are getting smaller and smaller. It is less common to see a new project written
    with the aim of becoming a monolith these days. Instead, engineers would aggressively
    split out small services that communicate over APIs or events.
  prefs: []
  type: TYPE_NORMAL
- en: Small services improve scalability, flexibility, and ease of deployment. Teams
    can develop, deploy, and scale services independently. Microservices and nanoservices
    are small enough to be owned by one team, and thus they encourage autonomy and
    empower the team to make its own decisions. Even if a wrong decision was made
    (e.g., choosing the wrong framework), it is comparatively easy to pivot and refactor
    the service without affecting other software components.
  prefs: []
  type: TYPE_NORMAL
- en: Application logic has also shifted from imperative to reactive and from synchronous
    to asynchronous processing. Many new systems embrace event-driven architectures
    and reactive handling. Many business use cases do not require everything to be
    completed to receive a response. A lot of processing can be done in real-time
    asynchronously by reacting to events. We covered the combination of CQRS and event-sourcing
    in [*Chapter 9*](B21737_09.xhtml#_idTextAnchor307), which provides an example
    of responding to synchronous requests earlier and having the rest of the processes
    executed asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Having a system split into small services brings the challenge of keeping overall
    system behaviors consistent. This leads to the discussion of idempotence, replication,
    and recovery, as discussed in [*Chapter 10*](B21737_10.xhtml#_idTextAnchor334).
  prefs: []
  type: TYPE_NORMAL
- en: This change in thinking has improved responsiveness and scalability, making
    it easier to integrate with numerous services and handle high-throughput scenarios.
    We covered performance and scalability in depth in [*Chapter 12*](B21737_12.xhtml#_idTextAnchor379).
    We also
  prefs: []
  type: TYPE_NORMAL
- en: The shift-left paradigms – API-first and security-first approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing with software component downsizing, APIs become more important. In
    fact, the API-first design approach has gained popularity these days. The API-first
    approach advocates that APIs should be developed before the actual implementation
    of the features.
  prefs: []
  type: TYPE_NORMAL
- en: This approach facilitates communication and collaboration between teams. It
    unblocks the development of the consumer side (e.g., another service or a frontend
    application) earlier and allows for parallel development. Developing APIs first
    also gives engineers a perspective to discover corner use cases before implementing
    them. We provided an example of the use of OpenAPI specifications in [*Chapter
    4*](B21737_04.xhtml#_idTextAnchor102).
  prefs: []
  type: TYPE_NORMAL
- en: The increasing popularity of DevSecOps, as discussed in [*Chapter 14*](B21737_14.xhtml#_idTextAnchor442),
    has brought security to the engineers’ attention. By integrating security practices
    into software development (e.g., threat modeling), teams can address security
    concerns and incorporate them into early technical design. This approach has enhanced
    the security posture and reduced vulnerabilities of an application.
  prefs: []
  type: TYPE_NORMAL
- en: The influence of cloud and serverless architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud computing and serverless architectures have changed the landscape of software
    development forever. Cloud providers manage the infrastructure and automatically
    scale resources. Engineers can focus on fulfilling business requirements in code
    rather than tackling infrastructure concerns. Moreover, serverless architectures
    are cost-effective and reduce operational overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The numerous services and tooling for cloud environments, such as Kubernetes,
    allow applications to take advantage of cloud provider features to improve scalability
    and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, there is a wide range of PaaS and SaaS running on the cloud, which
    makes it easier to integrate these services with any application. These services
    include relational databases, messaging services, identity providers, email services,
    and even fully-fledged enterprise software systems. We discussed serverless architecture
    in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212).
  prefs: []
  type: TYPE_NORMAL
- en: Composable architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of small services extends to breaking down software into independent
    modules or components that can be easily assembled or replaced. This building
    block approach leads to composable architecture, where each block aims to address
    specific concerns. These modules are designed to be cohesive to integrate with
    any application.
  prefs: []
  type: TYPE_NORMAL
- en: This approach increases the agility and flexibility of the overall architecture.
    It enables applications to rapidly adapt to a technology and to experiment with
    multiple options at a lower cost.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the *household service* that was brought up in many chapters can
    be reused in business problems other than household exchanging services. The service
    can easily integrate with other systems (e.g., voting, recycling, etc.) due to
    its modularity and high cohesiveness. We discussed in length how to define bounded
    contexts that result in well-defined services in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289).
    We also discussed layered and modular architectures in [*Chapter 7*](B21737_07.xhtml#_idTextAnchor255).
  prefs: []
  type: TYPE_NORMAL
- en: Architecture patterns continue to grow and evolve. Having composable architecture
    enables each pattern to independently advance and improve.
  prefs: []
  type: TYPE_NORMAL
- en: Observability and monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Observability and monitoring have become an integral part of software architectures
    these days. Not only do engineers want to gain an understanding of system behaviors
    through logging, tracing, and monitoring tools but engineers also want to identify
    issues quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Observability and monitoring tools run in the cloud and are easy to integrate,
    typically using the Sidecar pattern, as mentioned in [*Chapter 14*](B21737_14.xhtml#_idTextAnchor442),
    which is also an approach to composable architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing has also become an important aspect of software products. Having the
    ability to understand actions performed in the system provides insights into technical
    and business processes. This is particularly helpful for systems that need to
    comply with regulations.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the topic of auditing and monitoring models in [*Chapter 11*](B21737_11.xhtml#_idTextAnchor358).
  prefs: []
  type: TYPE_NORMAL
- en: AI and machine learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI and **machine learning** (**ML**) are significantly shaping the future of
    software architectures. ML is a subset of AI that focuses on learning from data
    to generate predictions and help decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: AI/ML consumes a lot of data to train its model, thus making software architectures
    increasingly data-centric. Systems that use AI/ML need to efficiently collect,
    store, and process large volumes of data.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud providers provide ready-to-use AI/ML services so engineers can run them
    without managing the infrastructure and automatically scale them on demand. These
    services (e.g., AWS Bedrock, Azure OpenAI, and GCP Vertex AI) include natural
    language processing, behavior analysis, predictive analytics, generating recommendations,
    summarizing data, and pattern recognition, and the list is still growing.
  prefs: []
  type: TYPE_NORMAL
- en: Even better, these AI/ML APIs use the format and transport that engineers are
    already familiar with, such as JSON payload and HTTP requests. Engineers can leverage
    advanced AI capabilities without needing deep expertise in AI/ML. The ease of
    integration has sped up development cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from using AI/ML in business applications, they are also used in monitoring,
    incident response, threat detection, semantic code completion, and chat box support
    for engineers. The ubiquitous features powered by AI/ML are driving a transformative
    shift in software architecture, promoting data-centric designs, modularity, and
    integration of advanced analytics into applications.
  prefs: []
  type: TYPE_NORMAL
- en: AI and ML will shape not only how applications are built but also how they interact
    with data in real time. We are still witnessing the evolution of AI and ML, and
    we have not seen the full scale of them yet.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a few Kotlin language features that can assist engineers in achieving
    better architectures, including extension functions, infix functions, operator
    overriding, and scoping functions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we covered the necessary steps to transition a Java project into a Kotlin
    project. We walked through the tools and manual correction required to convert
    a Java class into an idiomatic Kotlin class. We also mentioned a few opportunities
    to improve code quality during the conversion. We delved into the topic of transition
    strategies in terms of the sequence of conversion and framework transition. We
    emphasized the importance of continuous transition to Kotlin, and how the transition
    could incrementally progress in the everyday business feature coding works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We moved to the topic of CI and CD and presented the two main integration approaches:
    feature-based and trunk-based development. We compared them in terms of their
    pros, cons, and suitability in the context of organizational structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We made distinctions between three concepts: the deployment, release, and launch
    of a software product. Then, we walked through three release strategies: blue-green,
    feature flagging, and canary release. We presented a sample decision tree to help
    engineers select which release strategy is suitable from a technical perspective.'
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the topic of DX, explaining its importance and how it benefits
    the software product, the team, and the organization.
  prefs: []
  type: TYPE_NORMAL
- en: We made numerous suggestions for improving DX, including onboarding, tools,
    development processes, communication, collaboration, feedback, continuous improvement,
    recognition, and rewards.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we reflected on the software architecture that was discussed throughout
    the whole book, with a focus on current trends and future development.
  prefs: []
  type: TYPE_NORMAL
