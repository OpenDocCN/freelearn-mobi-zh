<html><head></head><body>
		<div><h1 id="_idParaDest-67"><em class="italic"><a id="_idTextAnchor066"/>Chapter 3</em>: Using Lists and Tables</h1>
			<p>There's a good chance that you have built a simple app before, or maybe you have tried but didn't quite succeed. If this is the case, you have likely used <code>UITableView</code> or <code>UICollectionView</code>, as both are core components of many iOS applications. </p>
			<p>If an app shows a list of items, it was likely built using <code>UITableView</code>. This chapter will ensure that you are up to speed with the ins and outs of <code>UITableView</code> and <code>UICollectionView</code>. In addition to covering the basics, such as how we use the delegation pattern, you'll also learn how to access users' data – in this case, their contacts – which will be rendered in a <code>UITableView</code> and <code>UICollectionView</code> object.</p>
			<p>We'll finish this chapter by taking a look at lists in SwiftUI, Apple's new UI framework announced back in 2019. We'll touch on the fundamental differences between what SwiftUI and UIKit have to offer.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Working with <code>UITableView</code></li>
				<li>Exploring table views further</li>
				<li>Working with <code>UICollectionView</code></li>
				<li>Exploring collection views further</li>
				<li>Working with lists in SwiftUI</li>
			</ul>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Technical requirements </h1>
			<p>For this chapter, you'll need to download Xcode version 11.4 or above from Apple's App Store. </p>
			<p>You'll also need to be running the latest version of macOS (Catalina or above). Simply search for Xcode in the App Store, and select and download the latest version. Launch Xcode and follow any additional installation instructions that your system may prompt you with. Once Xcode has fully launched, you're ready to go.</p>
			<p>Download the sample code from the following GitHub link:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Working with UITableView</h1>
			<p>In this section, we'll<a id="_idIndexMarker118"/> start by taking a look at <code>UITableView</code>, one of the most – if not <em class="italic">the</em> most – common ways of displaying data in a list in iOS.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Setting up the project</h2>
			<p>Every time you start a <a id="_idIndexMarker119"/>new project in Xcode, you have the option to pick a template for your app. Every template contains a small amount of code or some boilerplate code to get you started. In most cases, a basic layout will even be set up for you. Throughout this book, you should default to using the <strong class="bold">Single View App</strong> template. Don't be fooled by its name; you can add as many views to your app as you would like. This template just provides you with one view to start with.</p>
			<p>In this chapter, you will create an app that is called My Contacts. This app displays your user's contacts list in a <code>UITableView</code> component that you will set up. Let's create a project for this app right now. </p>
			<p>In the menu bar, do the following:</p>
			<ol>
				<li>Select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong>. </li>
				<li>Select <strong class="bold">Single View App</strong>.</li>
				<li>Name your project <code>Contacts List</code> or anything you like.</li>
				<li>Make sure your programming language is set to <strong class="bold">Swift</strong> and the user interface is set to <strong class="bold">Storyboard</strong> – it should <a id="_idIndexMarker120"/>resemble something like the following:<div><img src="img/Figure_3.01_B14717.jpg" alt="Figure 3.1 – Xcode new project options&#13;&#10;"/></div><p class="figure-caption">Figure 3.1 – Xcode new project options</p></li>
				<li>From here, click <strong class="bold">Next</strong> and then <strong class="bold">Create</strong>.</li>
				<li>Once your project has loaded, open the file named <code>Main.storyboard</code> found in the navigation tree to the left-hand side. </li>
			</ol>
			<p>The storyboard file is used to lay out all of your application's views and to connect them to the code you write. The editor you use to manipulate your storyboard is called Interface Builder.</p>
			<p>If you have used <code>UITableView</code> in the past, you may have used <code>UITableViewController</code>. The <code>UITableViewController</code> class is a subclass of a regular <code>UIViewController</code> class.</p>
			<p>The difference is that <code>UITableViewController</code> contains a lot of setup that you would otherwise have to perform on your own, either in Interface Builder or programmatically. To fully understand how <code>UITableView</code> is configured and set up, we won't use <code>UITableViewController</code> in this example.</p>
			<p>Back in Xcode, you'll notice a button at the top right that has a plus symbol on it. Click on this to bring up the object explorer. Once opened, search for <code>Table View</code>. If you begin typing the name of a potential component, you should see a list of suggested options become <a id="_idIndexMarker121"/>available – just like in the following screenshot:</p>
			<div><div><img src="img/Figure_3.02_B14717.jpg" alt="Figure 3.2 – Adding an object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Adding an object</p>
			<p> Once you find <strong class="bold">Table View</strong>, drag it straight onto your canvas in Interface Builder. Don't worry about it being placed awkwardly, we're going to fix that now by using Auto Layout to add some constraints.</p>
			<p>Inside our canvas, highlight the <code>UITableView</code> object we just added and click on the icon highlighted in the following screenshot. Add in top, leading, trailing, and bottom constraints of <code>0</code>:</p>
			<div><div><img src="img/Figure_3.03_B14717.jpg" alt="Figure 3.3 – Setting constraints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Setting constraints</p>
			<p>Once done, click <code>UITableView</code> object is <a id="_idIndexMarker122"/>now pinned perfectly to each edge of your screen. Regardless of what size device this is displayed on, those constraints will also be adhered to.</p>
			<p>Auto Layout enables you to create layouts that automatically adapt to any screen size that exists. Your layout currently uses fixed coordinates and dimensions to lay out the table view. For instance, your table view is set up to be positioned at 0, with a size of (375, 667). This size is perfect for devices such as the iPhone 8 and SE, but it wouldn't fit nicely with the iPhone 11 or iPad Pro. This combination of a view's position and size is called the frame.</p>
			<p>Auto Layout uses constraints to define a layout instead of a frame. For instance, to make the table view fit the entire screen, you would add constraints that pin every edge of the table view to the corresponding edge of its superview. Doing so would make the table view match its superview's size at all times.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Fetching contacts data</h2>
			<p>In order for us to be <a id="_idIndexMarker123"/>able to fetch the user's contacts from our device, we first need to be granted access via the <code>Contacts</code> framework.</p>
			<p>Apple are really heavy on privacy, so in turn, they require the user to "allow" access whenever an app first tries to read from the Address Book. This doesn't just stop at the Address Book, too; this can be found for camera access, location services, photos, and more.</p>
			<p>As in our case, when you need to access privacy-sensitive information, you are required to specify a reason as to why you would like to access the information. Nothing too detailed – but enough to give the user peace of mind as to why you would like to access their data.</p>
			<p>This is done by adding an entry to the <code>Info.plist</code> file in your project. Whenever you need access to privacy-sensitive information, you are required to specify this in your app's <code>Info.plist</code> file.</p>
			<p>In order to add this information to <code>Info.plist</code>, take the following steps:</p>
			<ol>
				<li value="1">Open it from the list of files in the Project navigator on the left. </li>
				<li>Once opened, hover over the words <code>Information Property List</code> at the top of the file.</li>
				<li>A plus icon should appear. Clicking it adds a new empty item with a search field to the list.</li>
				<li>When you begin typing <code>Privacy – contacts</code>, Xcode will filter out options for you until there is only one left for you to pick.</li>
				<li>This option is called <strong class="bold">Privacy – Contacts Usage Description</strong> and is the key we are looking for.</li>
			</ol>
			<p>The value for this newly added key should describe the reason that you need access to the specified piece of information. In this case, "reads contacts and shows them in a list" should be a sufficient explanation. When the user is asked for permission to access their contacts, the reason you specified here will be shown, so make sure you add an informative message.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Make sure you do choose an informative message that is relevant to your app. If Apple review this and don't find it to be acceptable, they could question you, or even worse, reject the submission of your app.</p>
			<p>Now, let's get down to writing some code. Before you can read contacts, you must make sure that the user has given the appropriate permissions for you to access the contacts data. To do this, the code must first read the current permission status. Once done, the user must either be prompted for permission to access their contacts, or the contacts must be fetched. </p>
			<p>Add the following highlighted code to <code>ViewController.swift</code>; we'll cover the details a section at a time – but don't worry, it will all make sense in the end:</p>
			<pre>import UIKit
<strong class="bold">import Contacts</strong>
class ViewController: UIViewController {
    
    override func viewDidLoad() {
        <strong class="bold">requestContacts()</strong>
    }</pre>
			<p>To start, we've<a id="_idIndexMarker124"/> imported <code>Contacts</code> into our <code>ViewController</code> class; by doing this, we're allowing the <code>Contacts</code> framework API to not just be inside our project, but specifically in our <code>ViewController</code> class.</p>
			<p>Next, we've added a call to a function named <code>requestContacts</code> in <code>viewDidLoad()</code> – we'll now need to create this function:</p>
			<pre>private func requestContacts() {
        
    let store = CNContactStore()
    let authorizationStatus = CNContactStore.authorizationStatus(for: .contacts)
        
    if authorizationStatus == .notDetermined {
        store.requestAccess(for: .contacts) { [weak self] didAuthorize, error in
            if didAuthorize {
                self?.retrieveContacts(from: store)
            }
        }
    } else if authorizationStatus == .authorized {
        retrieveContacts(from: store)
    }
        
}</pre>
			<p>Basically, without going into too many details, this forces iOS (if not already) to request permission for your app to access the contacts data. If the current status is unknown (or <code>notDetermined</code>), then permission will be requested. If this is not the case and the framework responds with <code>didAuthorize == true</code>, then we can now attempt to access the contacts information. We've also added an extra condition in there too to check whether we have already previously been authorized. You'll notice that <code>store.requestAccess</code> looks a little different from a regular function call; this is because it uses a completion handler.</p>
			<p>In asynchronous programming, completion handlers are used often. They allow your app to perform some work in the background and then call the completion handler when the work is completed. You will find completion handlers throughout many frameworks. If you implement a very<a id="_idIndexMarker125"/> simple function of your own that takes a callback, it might look as follows: </p>
			<pre>func doSomething(completionHandler: (Int) -&gt; Void) {
    // perform some actions
    var result = theResultOfSomeAction 
    completionHandler(result)
}</pre>
			<p>Calling a completion-handler looks just like calling a function. The reason for this is that a completion handler is a block of code, called a closure. Closures are a lot like functions because they both contain a potentially reusable block of code that is expected to be executed when called. </p>
			<p>Now, let's add our final piece of the puzzle by adding in our function to retrieve the contacts:</p>
			<pre>func retrieveContacts(from store: CNContactStore) {
        
    let containerId = store.defaultContainerIdentifier()
    let predicate = CNContact.predicateForContactsInContainer(withIdentifier: containerId)
    let keysToFetch = [CNContactGivenNameKey as CNKeyDescriptor,
    CNContactFamilyNameKey as CNKeyDescriptor, CNContactImageDataAvailableKey as CNKeyDescriptor,
    CNContactImageDataKey as CNKeyDescriptor]
        
    let contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)
}</pre>
			<p>A brief explanation of the <a id="_idIndexMarker126"/>preceding code: we pass an instance of <code>CNContactStore</code> (which we've previously been given permission to access), and then we set up a request for specific information we would like with the array of <code>CNKeyDescriptor</code>. </p>
			<p>Finally, the call is made and will fetch this information, which is returned to us in a <code>CNContact</code> object.</p>
			<h2 id="_idParaDest-72">Pre<a id="_idTextAnchor071"/><a id="_idTextAnchor072"/>pping UITableView to display our contacts</h2>
			<p>With all that ready, let's <a id="_idIndexMarker127"/>head on back to Interface Builder and add in a table view cell:</p>
			<ol>
				<li value="1">Highlight the <code>UITableView</code> object we added to the canvas.</li>
				<li>Click on the <code>Table View Cell</code>.</li>
				<li>Now, drag this object onto <code>UITableView</code>. </li>
			</ol>
			<p>You'll notice something a little different this time: the <code>UITableViewCell</code> object that we dragged automatically snapped into position on our <code>UITableView</code> object – don't worry, that's fine, this is because <code>UITableViewCell</code>'s position is controlled by the configuration of its <code>UITableView</code> object. Next, we are going to create an <code>IBOutlet</code> for our code. In the same way that we did in <a href="B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Dark Mode</em>, create an outlet programmatically in your <code>ViewController.swift</code> file, and then connect these using Interface Builder.</p>
			<p>Here is an example of the outlet you are going to create:</p>
			<pre>@IBOutlet weak var tableView: UITableView!</pre>
			<p>Now, we need to create a class for <code>UITableViewCell</code> – by doing this, we can add custom properties to <code>UITableViewCell</code>, such as a name, contact information, or even an image.</p>
			<p>Back inside our <code>ViewController.swift</code> file (but outside of the <code>ViewController</code> class declaration), add the following code:</p>
			<pre>class ContactCell: UITableViewCell {
    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var contactImageView: UIImageView!
}</pre>
			<p>Here, we've created our custom cell, which is a subclass of <code>UITableViewCell</code> and will carry all the traits of a table view cell that we need. I've also added a couple of <code>IBOutlet</code> components for the data that we are going to display.</p>
			<p>Now, let's go hook this up. Head on back to Interface Builder and select the <code>UITableViewCell</code> object that we added.</p>
			<p>Once highlighted, click <a id="_idIndexMarker128"/>on the Identity inspector in the right-hand tool window and add <code>ContactCell</code> as the <strong class="bold">Class</strong> name:</p>
			<div><div><img src="img/Figure_3.04_B14717.jpg" alt="Figure 3.4 – Table view class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Table view class</p>
			<p>Then, click on the Attributes Inspector and type in <code>contactCell</code> for <strong class="bold">Identifier</strong>:</p>
			<div><div><img src="img/Figure_3.05_B14717.jpg" alt="Figure 3.5 – Table view cell identifier&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Table view cell identifier</p>
			<p>Overriding <code>UITableViewCell</code>'s class to our custom class will allow us to use Interface Builder to connect objects to the <code>IBOutlet</code> components that we just created. We'll touch on the identifier later on in this chapter, but it's always good to get these bits out of the way at the start.</p>
			<p>Now, let's add a couple of objects to <code>UITableViewCell</code>. We'll start with <code>UILabel</code>, and then <code>UIImageView</code> (add these in the same way you did the table view and cell – have the image to the left of the cell).</p>
			<p>Once added, have a play with the <code>Autolayout</code> constraints we learned about earlier. The best way to master Auto Layout is trial and error - if you get stuck, just refer to the sample project for this chapter to guide you along.</p>
			<p>Once you are done, your cell will look something like this:</p>
			<div><div><img src="img/Figure_3.06_B14717.jpg" alt="Figure 3.6 – Label with constraints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Label with constraints</p>
			<p>Now, let's hook each one of these up to the <code>IBOutlet</code> components we created – all going well, Interface Builder should pick up on the associated class (<code>ContactCell</code>) and will allow the outlets to be attached without any problems.</p>
			<p>Awesome, we're making <a id="_idIndexMarker129"/>great progress, and believe it or not, we're not a million miles away from displaying the data in our app – but first, we need to cover some important fundamentals of <code>UITableView</code> and, more importantly, the delegation pattern that iOS used so heavily.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Understanding protocols and delegation</h2>
			<p>Throughout <a id="_idIndexMarker130"/>the iOS SDK and the Foundation<a id="_idIndexMarker131"/> framework, a design pattern named delegation is used. Delegation allows an object to have another object to perform work on its behalf. </p>
			<p>When implemented correctly, it's a great way to separate concerns and decouple code within your app.</p>
			<p>The table view uses the help of two objects to function correctly. One is the delegate, and the other is the data source. Any time you use a table view, you must configure these two objects yourself. When the time comes for the table view to render its contents, it asks data source for information about the data to display. The delegate comes into play when a user interacts with the items in the table view.</p>
			<p>If you look at the documentation for <code>UITableView</code>, you can find the delegate property. The type for delegate is <code>UITableViewDelegate?</code>. This tells you two things about delegate. First of all, <code>UITableViewDelegate</code> is a protocol. This means that any object can act as a delegate for a table view, as long as it implements the <code>UITableViewDelegate</code> protocol. Second, the question mark at the end of the type name tells you that the delegate is an optional property. An optional property either has a value of the specified type, or it is nil. The table view's delegate property is optional because you do not have to set it to create a functioning table view.</p>
			<p>A protocol, such as <code>UITableViewDelegate</code>, defines a set of properties and methods that must be implemented by any type that wants to conform to the protocol. Not all methods must be explicitly implemented by conforming objects. Sometimes, a protocol extension provides a reasonable default implementation.</p>
			<p>In addition to delegate, <code>UITableView</code> has a data source property. data source's type is <code>UITableViewDataSource?</code>, and just like <code>UITableViewDelegate</code>, <code>UITableViewDataSource</code> is a protocol. However, <code>UITableViewDelegate</code> only has optional methods, meaning you don't need to implement any methods to conform to <code>UITableViewDelegate</code>. <code>UITableViewDataSource</code> does have required methods: the methods that need to be implemented are used to provide the table view with just enough information to be able to display the correct number of cells with the right content in them.</p>
			<p>If this is the first time you're learning about protocols and delegation, you might feel a little bit lost right now. That's OK; you'll get the hang of it soon. Throughout this book, your understanding of topics such as these will improve bit by bit. You will even learn about a concept <a id="_idIndexMarker132"/>called <a id="_idIndexMarker133"/>protocol-oriented programming! </p>
			<p>For now, you must understand that a table view asks for a different object for the data it needs to show and that it also uses a different object to handle certain user interactions.</p>
			<p>We can break the flow of displaying content in a table view down into a couple of steps; when the table view needs to reload the data, it does the following:</p>
			<ol>
				<li value="1">The table view checks whether <code>dataSource</code> is set, and asks it for the number of sections it should render.</li>
				<li>Once the number of sections is passed back to the table view, <code>dataSource</code> is asked for the number of items for each section.</li>
				<li>With knowledge about the number of sections and items that need to be shown, the table view asks <code>dataSource</code> for the cells it should display.</li>
				<li>After receiving all of the configured cells, the table view can finally render these cells to the screen.</li>
			</ol>
			<p>These steps should give you a little bit more insight into how a table view uses another object to figure out the contents it should render. This pattern is compelling because it makes the table view an extremely flexible component. Let's put some of this newfound knowledge to use!</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Conforming to the UITableView protocols</h2>
			<p>To make <code>ViewController</code> both the delegate and the data source for its table view, it will have to conform<a id="_idIndexMarker134"/> to both protocols. It is a best practice to create an extension whenever you make an object conform to a protocol. Ideally, you make one extension for each protocol you want to implement. Doing this helps to keep your code clean and maintainable.</p>
			<p>Add the following extension to <code>ViewController.swift</code>:</p>
			<pre>extension ViewController: UITableViewDelegate, UITableViewDataSource {  
}</pre>
			<p>After doing this, your code contains an error. That's because none of the required methods from <code>UITableViewDataSource</code> have been implemented yet. </p>
			<p>There are two methods you need to implement to conform to <code>UITableViewDataSource</code>. These methods are the following:</p>
			<ul>
				<li><code>tableView(_:numberOfRowsInSection:) </code></li>
				<li><code>tableV<a id="_idTextAnchor075"/><a id="_idTextAnchor076"/>iew(_:cellForRowAt:)</code></li>
			</ul>
			<p>Let's go ahead and fix the error Xcode is showing by adjusting the code a little bit. We'll also need to make a couple of small changes to display our contacts within our table view.</p>
			<p>We'll start by adding a global variable to our <code>ViewController</code> class. Add in the following just after the class declaration:</p>
			<pre>var contacts = [CNContact]()</pre>
			<p>Here, we've instantiated an array of <code>CNContact</code>, which is what we get back in our <code>retrie<a id="_idTextAnchor077"/><a id="_idTextAnchor078"/>veContacts</code> function when <code>store.unifiedContacts</code> is called.</p>
			<p>Now, make the following modification to our <code>retrieveContacts</code> function:</p>
			<pre>contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)</pre>
			<p>Perfect – now fill in the blanks with those delegates:</p>
			<pre>func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    <strong class="bold">return contacts.count</strong>
}</pre>
			<p>Our first delegate method, <code>tableView(_:numberOfRowsInSection:)</code>, requires us to return the number of cells we want to display. As we want to display all of our contacts, we simply pass back the number of contacts in our array, as highlighted in the preceding code.</p>
			<p>Next, let's implement the <code>tableV<a id="_idTextAnchor079"/><a id="_idTextAnchor080"/>iew(_:cellForRowAt:)</code> delegate. Copy in the following code and we'll go through it one step at a time:</p>
			<pre>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {    
    let contact = contacts[indexPath.row]
        
    let cell = UITableViewCell()
    cell.textLabel?.text = contact.familyName
        
    return cell
}</pre>
			<p>Basically, this delegate method is called for every cell that is going to be generated in our table view, so if <code>contacts.count == 5</code>, then this will be called 5 times. A way for us to identify which<a id="_idIndexMarker135"/> cell is currently being called is to inspect the <code>indexPath.row</code> value that is being passed in with each call. </p>
			<p>If you take a look at the first line of code with the preceding delegate, you'll see that we have accessed the specific contact by querying our array of <code>CNContact</code> with the <code>indexPath.row</code> value. From this, we simply just create an instance of <code>UITableViewCell</code>, assign a property of <code>CNContact</code> to <code>.textLabel</code>, and return the instance.</p>
			<p>We're almost ready to see our changes in action; just a couple more things to add in.</p>
			<p>Head on back to our <code>viewDidLoad()</code> function and add the following highlighted lines:</p>
			<pre>override func viewDidLoad() {
<strong class="bold">    tableView.delegate = self</strong>
<strong class="bold">    tableView.dataSource = self</strong>
      
    requestContacts()
}</pre>
			<p>Here, we are telling our <code>UITableView</code> instance that our current <code>ViewController</code> class is the delegate base for all <code>UITableView</code> protocol operations. In a nutshell – the delegates we just added will get called when we try to perform any actions on our table view.</p>
			<p>Finally, add the following highlighted code to the end of our <code>retrieveContacts</code> functions:</p>
			<pre>contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)
<strong class="bold">Dispat<a id="_idTextAnchor081"/><a id="_idTextAnchor082"/>chQueue.main.async {</strong>
<strong class="bold">self.tableView.reloadData()</strong>
<strong class="bold">}</strong></pre>
			<p>The reason we do this is again down to asynchronous programming. By design, our table view will try and display data as soon as <code>ViewController</code> is loaded. At this point, our contacts may not be available, we may have not been given suitable permission, or simply, the function's callback may not have returned all the data in time. </p>
			<p>So, if that's the case, once we <a id="_idIndexMarker136"/>know that all the data is ready to be displayed, we simply ask the table view to reload. Go ahead and run your app in the simulator – all going well, you will be prompted by the <code>Contacts</code> framework to allow permission to access your contacts, shortly followed by a list of contact details:</p>
			<div><div><img src="img/Figure_3.07_B14717.jpg" alt="Figure 3.7 – User consent and user list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – User consent and user list</p>
			<p>In this part, we learned about how important protocols and delegates are in iOS development, and by hooking up a couple of simple functions, we were able to easily yet effectively display <a id="_idIndexMarker137"/>data in <code>UITableView</code>. Now, let's take a look at how we can customize each cell some more, with the <code>UITableViewCell</code> override we created earlier.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor083"/>Understanding the custom UITableViewCell override and the reuse identifier</h2>
			<p>Back in a previous<a id="_idIndexMarker138"/> section, <em class="italic">Prepping UITableView to display our contacts</em>, you'll remember that we created our custom <code>UITableViewCell</code> override called <code>ContactCell</code>, but in the end we never really used it. </p>
			<p>We did this on purpose, firstly to introduce you to the fact that <code>UITableViewCell</code> does have a minimal default offering where <code>textLabel</code> is given for you to add your required text. This can come in handy as a really lightweight way of generating a <code>UITableView</code> object and displaying some simple data – a no-fuss approach for quick wins or a situation where one line is good enough. However, if you want to be creative with your cells, then this is where the custom option comes into play.</p>
			<p>Let's head back to <code>tableView(_:cellForRowAt:)</code> and see how we'd make the change:</p>
			<pre>let contact = contacts[indexPath.row]
        
guard let cell = tableView.dequeueReusableCell(withIdentifier: "contactCell", for: indexPath) as? ContactCell else {
            return UITableViewCell()
}
        
cell.nameLabel.text = contact.givenName
if let imageData = contact.imageData {
    cell.conatctImageView.image = UIImage(data: imageData)
} else {
    cell.conatctImageView.image = UIImage(systemName: "person.circle")
}</pre>
			<p>Now, to start with, let's take a look at the first part:</p>
			<pre>tableView.dequeueReusableCell(withIdentifier: "contactCell", for: indexPath) as? ContactCell</pre>
			<p>Here, we are instantiating the use of a reusable <code>UITableViewCell</code> with the identifier of <code>contactCell</code>, which is of the <code>ContactCell</code> class.<code> </code></p>
			<p>Sounds confusing? Maybe a little, but think of it this way – we created a custom cell class that we assigned to our <code>UITableViewCell</code> object back in Interface Builder. We then gave this an identifier of <code>contactCell</code> – here, we simply called upon that cell to be used so that we can access its properties (remember the <code>nameLabel</code> and <code>contactImageView</code> properties we added).</p>
			<p>Once we have access <a id="_idIndexMarker139"/>to an instance of that cell, we can then simply assign each property accordingly with data taken from our contact instance. Notice that we're doing a check against the image data in the contacts due to the possibility of no image yet being associated with a contact – here, we've added a little fallback to display a system image (using SF Symbols).</p>
			<p>If you want you add an image, simply fire up the Contacts app in the simulator and drag an image from your Mac over - You should now be able to select this and assign this from the Contacts app.</p>
			<p>Go ahead and make those changes, and then run the app again:</p>
			<div><div><img src="img/Figure_3.08_B14717.jpg" alt="Figure 3.8 – Contact list with image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Contact list with image</p>
			<p>Perfect, but what is this <code>dequeueReusableCell</code> all about? Don't worry, we'll cover that in a later section, <em class="italic">Advances in UITableView and UICollectionView</em>.</p>
			<p>In this section, we learned how to implement <code>UITableView</code> and a custom <code>UITableViewCell</code>, pulling data obtained by accessing our contacts via the <code>Contacts</code> framework and <a id="_idIndexMarker140"/>displaying it within our app. Now, let's spend some time digging a little deeper into the art of table views and how they work.</p>
			<h1 id="_idParaDest-76">Exploring<a id="_idTextAnchor084"/><a id="_idTextAnchor085"/><a id="_idTextAnchor086"/> UITableView further</h1>
			<p>In this section, we'll touch<a id="_idIndexMarker141"/> on some extra little bits that will allow you to make the most out of <code>UITableView</code>. We'll also cover in more detail some areas previously explored, such as the reuse identifier.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor087"/>Further understanding reuse identifiers</h2>
			<p>Earlier in this chapter, you<a id="_idIndexMarker142"/> learned about cell-reuse in table views. We assigned a reuse identifier to a table view cell so that the table view would know which cell it should use to display contacts in. Cell-reuse is a concept that is applied to a table view so that it can reuse cells that it has already created. </p>
			<p>This means that the only cells that are in memory are either on the screen or barely off the screen. The alternative would be to keep all cells in memory, which could potentially mean that hundreds of thousands of cells are held in memory at any given time. </p>
			<p>For a visualization of what cell reuse looks like, have a look at the following diagram:</p>
			<div><div><img src="img/Figure_3.09_B14717.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Table view cell layout</p>
			<p>As you can see, there are just a few cells in the diagram that are not on the visible screen. This roughly equals the number of cells that a table view might keep in memory. This means that regardless of the total amount of rows you want to show, the table view has roughly constant pressure on your app's memory usage.</p>
			<p>A cell is first created when <code>dequeueReusableCell(withIdentifier:)</code> is called on the table view and it does not have an unused cell available. Once the cell is either reused or created, <code>prepareForReuse()</code> is called on the cell. This is a great spot to reset your cells to their default state by removing any images or setting labels back to their default values. </p>
			<p>Next, <code>tableView(_:willDisplay:forRowAt:)</code> is called on the table view's delegate. This happens right before the cell is shown. You can perform some last-minute configuration here, but the majority of the work should already be done in <code>tableView(_:cellForRowAtIndexPath:)</code>.</p>
			<p>When the cell scrolls off screen, <code>tableView(_:didEndDisplaying:forRowAt:)</code> is called on the delegate. This signals that a <a id="_idIndexMarker143"/>previously visible cell has just scrolled out of the view's bounds.</p>
			<p>With all this cell life cycle information in mind, the best way to fix the image reuse bug is by implementing <code>prepareForReuse()</code> on <code>ContactCell</code>. Add the following implementation to remove any images that have previously been set:</p>
			<pre>override func prepareForReuse() { 
    super.prepareForReuse()
    conatctImageView.image = nil
}</pre>
			<p>Now, let's take a look at some other enhancements that we can make in our app by using prefetching.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor088"/>Prefetching in table views</h2>
			<p>In <a id="_idIndexMarker144"/>addition to <code>UITableViewDelegate</code> and <code>UITableViewDataSource</code>, a third protocol exists that you can implement to improve your table view's performance. </p>
			<p>It's called<a id="_idTextAnchor089"/><a id="_idTextAnchor090"/> <code>UITableViewDataSourcePrefetching</code>, and you can use it to enhance your data source. If your data source performs some complex task, such as retrieving and decoding an image, it could slow down the performance of your table view if this task is performed at the moment that the table view wants to retrieve a cell. Performing this operation a little bit sooner than that can positively impact your app, in those cases.</p>
			<p>So, how would we implement this? Simple, we first just conform <code>ViewController</code> to the new delegate:</p>
			<pre>extension ViewController: UITableViewDataSourcePrefetching {
    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {
        
    }
}</pre>
			<p>You'll notice that a fundamental difference here is within the <code>indexPath</code> parameter being passed in. This time, we have an array of <code>IndexPath</code>, as opposed to a single index, in turn, allowing us to perform batch processing on a set of cells that our table view would like us to display. </p>
			<p>This would be ideal if data from your cell has to be obtained asynchronously – such as an image or real-time data. You could really work hard here to perform and calculate the right way to display your data to get the optimum performance.<a id="_idTextAnchor091"/><a id="_idTextAnchor092"/></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor093"/>Cell selection in table views</h2>
			<p>Since a table view will <a id="_idIndexMarker145"/>call methods on its delegate whenever they are implemented, you don't need to tell the table view that you want to respond to cell selection. This automatically works if the table view has a delegate, and if the delegate implement<a id="_idTextAnchor094"/><a id="_idTextAnchor095"/>s <code>tableView(_:didSelectRowAt:)</code>.</p>
			<p>The implementation you'll add to our app, for now, is a very simple one. When the user taps a cell, the app displays an alert.</p>
			<p>Add the following code to the extension in <code>ViewController.swift</code>:</p>
			<pre>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
    let contact = contacts[indexPath.row]
    let alertController = UIAlertController(title: "Contact Details", message: "Hey \(contact.givenName)!!",
        preferredStyle: .alert)        
    let dismissAction = UIAlertAction(title: "Done", style: .default, handler: { action in
        tableView.deselectRow(at: indexPath, animated: true)
    })
        
    alertController.addAction(dismissAction);
    present(alertController, animated: true, completion: nil)
        
}</pre>
			<p>The <code>tableView(_:didSelectRowAt:)</code> method <a id="_idIndexMarker146"/>receives two arguments: the first is the table view that called this delegate method. The second argument is the index path at which the selection occurred. </p>
			<p>The implementation you wrote for this method uses the index path to retrieve the contact that corresponds with the tapped cell, so the contact name can be shown in an alert. </p>
			<p>You could also retrieve the contact's name from the tapped cell. However, this is not considered good practice because your cells and the underlying data should be as loosely coupled as possible. </p>
			<p>When the user taps the <strong class="bold">Done</strong> button in the alert, the table view is told to deselect the selected row. </p>
			<p>If you don't deselect the selected row, the last tapped cell will always remain highlighted. Note that the alert is displayed by calling <code>present(_:animated:completion:)</code> on the view controller. Any time you want to make a view controller display another view controller, such as an alert controller, you use this method.</p>
			<p>In this section, you learned a lot about what makes a table view tick, including a good understanding of how the <a id="_idIndexMarker147"/>reuse identifier works. Next, we'll take a look at <code>UICollectionView</code>, the <code>UITableView</code> class's bigger (or younger, really) brother, comparing similarities to each class and also key differences, too.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor096"/>Working with UICollectionView</h1>
			<p>In the previous section, we <a id="_idIndexMarker148"/>took on the mighty <code>UITableView</code> – learning all about the delegate pattern and how to build our unique lists with custom cells. In this section, we'll take a look at <code>UICollectionView</code>, mainly looking at how we are comparing one class to another.</p>
			<p>From the outset, when asked what the fundamental differences are between them both, most people will initially say the same thing: "Collection views allow horizontal scrolling" – which is very true, but what it's doing is harnessing the power of <code>UITableView</code> with the ability to manipulate and override a layout that would allow a grid layout, for example.</p>
			<p>If you need to go deeper into a complex custom layout, this again is where <code>UICollectionView</code> comes into play, with the support of the <code>UICollectionViewDelegateFlowLayout</code> protocol, allowing you as a developer to manipulate custom layouts.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor097"/>Setting up our collection view</h2>
			<p>Let's start by <a id="_idIndexMarker149"/>creating a new project in the exact same way as we did for a table view: </p>
			<ol>
				<li value="1">This time, search for <code>Collection View</code> in the object window (<em class="italic">you won't need to add in a </em><code>CollectionView</code><em class="italic"> cell as the collection view already does this for you</em>).</li>
				<li>Add in your constraints too so that it scales to the full size of the device.</li>
			</ol>
			<p>Back to <code>ViewController</code>, we'll need to create and hook up our <code>IBOutlet</code> components just like we did with the table view (but call your property something like <code>collectionView</code>).</p>
			<p>Once you've done that, we'll need to create another extension, but this time, our protocols will be slightly different:</p>
			<pre>extension ViewController: UICollectionViewDelegate, UICollectionViewDataSource {
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {
        contacts.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
        let contact = contacts[indexPath.item]
        
        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "contactCell", for: indexPath) as? ContactCell else {
            return UICollectionViewCell()
        }
        cell.setup(contact: contact)
        
        return cell
    }
    
}</pre>
			<p>Our two delegate methods in the preceding example are as follows:</p>
			<ul>
				<li><code>collectionV<a id="_idTextAnchor098"/><a id="_idTextAnchor099"/>iew(_:numberOfItemsInSection:)</code></li>
				<li><code>collectionView(_:cellForItemAt:)</code></li>
			</ul>
			<p>Both offer the same as their <code>UITableView</code> counterparts; only one difference you'll notice is the reference to the term <code>Item</code> rather than <code>Row</code>. This is because in <code>UITableView</code>, the layout is purely linear, so each cell is treated as a row. With <code>UICollectionView</code>, this is <a id="_idIndexMarker150"/>not the case – so, each cell is referred to as an item.</p>
			<p>Next, we want to create another custom cell. Copy and paste the one we made for our table view and make the following highlighted changes:</p>
			<pre>class ContactCell: <strong class="bold">UICollectionViewCell</strong> {
    
<strong class="bold">    @IBOutlet weak var familyNameLabel: UILabel!</strong>
<strong class="bold">    @IBOutlet weak var givenNameLabel: UILabel!</strong>
    @IBOutlet weak var contactImageView: UIImageView!
    
    
    func setup(contact: CNContact) {
        givenNameLabel.text = contact.givenName
        familyNameLabel.text = contact.familyName
        
        if let imageData = contact.imageData {
            conatctImageView.image = UIImage(data: imageData)
        } else {
            conatctImageView.image = UIImage(systemName: "person.circle")
        }
    }
    
}</pre>
			<p>The differences in the preceding code are subtle, but one of them is very important: our subclass is now of the <code>UICollectionViewCell</code> type (as opposed to <code>UITableViewCell</code>), and we've also added in a couple of extra outlets, as we'll be adding a touch more data.</p>
			<p>For something different, we are going to create a scrolling horizontal list of our contacts and a grid <a id="_idIndexMarker151"/>layout. Let's head on over back to the interface builder and modify our canvas a little.</p>
			<p>We'll start by adding another text field. Notice from the following figure how I can adjust the size of my cell too:</p>
			<div><div><img src="img/Figure_3.10_B14717.jpg" alt="Figure 3.10 – Collection view cell&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Collection view cell</p>
			<p>We can do this in a couple of places. If we highlight <strong class="bold">Collection View</strong> and select the Size Inspector, we can do it in there:</p>
			<div><div><img src="img/Figure_3.11_B14717.jpg" alt="Figure 3.11 – Collection View Size Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Collection View Size Inspector</p>
			<p>Alternatively, we can do this directly on the cell itself, as shown in the following screenshot, again by selecting the Size Inspector:</p>
			<div><div><img src="img/Figure_3.12_B14717.jpg" alt="Figure 3.12 – Collection View Cell Size Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Collection View Cell Size Inspector</p>
			<p>This is great for <a id="_idIndexMarker152"/>two reasons. First, you can set the size of your cell visually, which is always a nice and convenient way to do things. Secondly, even if you are going to override your cell size programmatically (due to you requiring a more dynamic approach), it allows you to visualize and set your constraints so that you know what you have to play with. I'm just going to set mine to 150 width x 230 height, for now, which should give us enough to play with.</p>
			<p>So, let's carry on with setting up our interface. Again, we'll need to override <strong class="bold">Class</strong> with our custom class:</p>
			<div><div><img src="img/Figure_3.13_B14717.jpg" alt="Figure 3.13 – Collection View class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">  </p>
			<p class="figure-caption">Figure 3.13 – Collection View class</p>
			<p>Then, we need to assign our cell identifier:</p>
			<div><div><img src="img/Figure_3.14_B14717.jpg" alt="Figure 3.14 – Collection View cell identifier&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Collection View cell identifier</p>
			<p>Then, we set <strong class="bold">Estimated Height</strong> to <strong class="bold">None</strong>. This stops our cell from dynamically resizing itself based on the size of the content within the cell (for example, a label with a really long name or address):</p>
			<div><div><img src="img/Figure_3.15_B14717.jpg" alt="Figure 3.15 – Collection View estimated cell size&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Collection View estimated cell size</p>
			<p>We're almost done – just a few more little things we need to add in. Notice anything missing from <a id="_idIndexMarker153"/>our <code>viewDidLoad()</code> function that we had in the <code>UITabelView</code> example?</p>
			<p>Yep, we've yet to set our delegate method to our <code>ViewController</code> object, but for this example, I'm going to show you another way that we can do that via Interface Build<a id="_idTextAnchor100"/><a id="_idTextAnchor101"/>er, as opposed to doing this programmatically.</p>
			<p>Highlight your <code>CollectionView</code> object, press and hold <em class="italic">Ctrl</em> on your keyboard, then primary click and hold your cursor – if you start to drag your cursor, you'll see a line (just like when we connect <code>IBOutlet</code>). Drag the line to the <code>ViewController</code> object and release. You'll then be presented with the following options:</p>
			<div><div><img src="img/Figure_3.16_B14717.jpg" alt="Figure 3.16 – Collection View delegate outlet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Collection View delegate outlet</p>
			<p>Select <strong class="bold">dataSource</strong>, and then repeat the process and select <strong class="bold">delegate</strong>.</p>
			<p>That's it – other than a <a id="_idIndexMarker154"/>few minor changes here and there, we've successfully set up <code>UICollectionView</code> in pretty much the same way as we did for our <code>UITableView</code>. Let's go ahead now and run the project to see how it all looks:</p>
			<p class="figure-caption"><img src="img/Figure_3.17_B14717.png" alt="Figure 3.17 – Collection View layout&#13;&#10;"/></p>
			<p class="figure-caption">Figure 3.17 – Collection View layout</p>
			<p>That looks great – I mean, apart from the cells looking a little out of place – but don't worry, we're going to take a look at our options on how we can change that in the next part, by being introduced to the <code>UICollectionViewDelegateFlowLayout</code> protocol.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor102"/>Implementing layout with UICollectionViewDelegateFlowLayout</h2>
			<p>In the last section, we created our very first <code>UICollectionView</code> project based on everything we had <a id="_idIndexMarker155"/>learned from creating a <code>UITableView</code> project previously. One thing we did learn that was fundamentally different from a table view was that our cells can be laid out differently.</p>
			<p>So, how do we go about manipulating our cells to get them to do exactly what we want them to do? For that, we need to implement the <code>UICollectionViewDelegateFlowLayout</code> protocol – but what does this have to offer? Let's start by taking a look at one of the most commonly used delegate methods in this protocol and how easily it can transform our app.</p>
			<p>Over in our extension, add in the following highlighted protocol alongside the existing ones:</p>
			<pre>extension ViewController: UICollectionViewDelegate, UICollectionViewDataSource, <strong class="bold">UICollectionViewDelegateFlowLayout</strong></pre>
			<p>Now, in good practice, you can separate each one of these protocols into its own extension – but as we are only dealing with a few delegates for each, we'll be fine to keep them in one place for now.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If your <code>ViewController</code> object starts to get a little large, you can move your extensions out into a separate file – this makes working on them easier and keeps your files nice and clean.</p>
			<p>Now, we're going to add in the following <code>delegate</code> method:</p>
			<pre>func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { }</pre>
			<p>The <code>sizeForItem</code> delegate simply allows us to programmatically set a size of our cell, so let's have a play with that and see what we can come up with. Add the following code to the preceding function:</p>
			<pre>let width = (collectionView.bounds.size.width / 2) – 10
return CGSize(width: width, height: 180)</pre>
			<p>So, here, we're performing a nice simple calculation: we're taking the width of the current <a id="_idIndexMarker156"/>screen, dividing it by 2, and then subtracting 10 (for a little padding), and having that as our cell width. Finally, we'll add a nice static value for our height. Go ahead and run your app and see what it gives us:</p>
			<div><div><img src="img/Figure_3.18_B14717.jpg" alt="Figure 3.18 – Collection View layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – Collection View layout</p>
			<p>Nice, let's look at what else we could do. How about simply returning the full size of the screen?</p>
			<pre>return collectionView.bounds.size</pre>
			<p>Next, let's change the direction of the scroll direction; we can do this via Interface Builder by selecting <strong class="bold">Collection View</strong>. Change the value to <strong class="bold">Horizontal</strong>:</p>
			<div><div><img src="img/Figure_3.19_B14717.jpg" alt="Figure 3.19 – Collection View Scroll Direction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – Collection View Scroll Direction</p>
			<p>Go <a id="_idIndexMarker157"/>ahead and run the app again – how does it look?</p>
			<div><div><img src="img/Figure_3.20_B14717.jpg" alt="Figure 3.20 – Collection View Scroll Direction layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – Collection View Scroll Direction layout</p>
			<p>Perfect – with only a small change, we've managed to make a massive difference to our app, clearly highlighting the power of <code>UICollectionView</code> compared to <code>UITableView</code>.</p>
			<p>Before <a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>we wrap up this section on <code>UICollectionView</code>, let's take a quick look at the other delegate methods offered to us <a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>by <code>UICollectionViewDelegateFlowLayout</code>.</p>
			<h3>Size of an item (cell)</h3>
			<p>When you <a id="_idIndexMarker158"/>need to manipulate the bounds or frame of an item, use<code> collectionView(_:layout:sizeForItemAt:</code>, which asks the delegate for the size of the specified item's cell.</p>
			<h3>Section and spacing</h3>
			<p>The following are <a id="_idIndexMarker159"/>options to programmatically adjust the spacing between cell items and sections (excluding headers and footers):</p>
			<ul>
				<li><code>collectionView(_:layout:insetForSectionAt:)</code>: Asks the delegate for the margins to apply to content in the specified section</li>
				<li><code>collectionView(_:layout:minimumLineSpacingForSectionAt:)</code>: Asks the delegate for the spacing between successive rows or columns of a section</li>
				<li><code>collectionView(_:layout:minimumInteritemSpacing ForSectionAt:)</code>: Asks the delegate for the spacing between successive items in the rows or columns of a section</li>
			</ul>
			<h3>Footer and header sizing</h3>
			<p>The following are <a id="_idIndexMarker160"/>options to programmatically adjust the spacing between cell items specifically for headers and footers:</p>
			<ul>
				<li><code>collectionView(_:layout:referenceSizeForHeaderInSection:)</code>: Asks the delegate for the size of the header view in the specified section</li>
				<li><code>collectionView(_:layout:referenceSizeForFooterInSection:)</code>: Asks the delegate for the size of the footer view in the specified section</li>
			</ul>
			<p>In this section, we learned all about <code>UICollectionView</code> components – how to set them up in Xcode and the differences between them and <code>UITableView</code> components – and were able to see the benefits they give us along with the <code>UICollectionViewDelegateFlowLayout</code> protocol in order customize our apps more visually. In <a id="_idIndexMarker161"/>the next section, we're going to take a look a little deeper into some of the advancements in <code>UITableView</code>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor107"/>Exploring UICollectionView further </h1>
			<p>In this section, we'll again touch on some extra little bits that, just like with our table views, will allow us to <a id="_idIndexMarker162"/>really harness the power of a collection view – specifically when it comes to calculating the size of your layout. We'll start by taking a look at some overrides that we can make use of to achieve this.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor108"/>Implementing a custom UICollectionViewLayout</h2>
			<p>Implementing a <a id="_idIndexMarker163"/>large and complex feature such as a custom collection view layout might seem like a huge challenge for most people. </p>
			<p>Creating your layout involves calculating the position for every cell that your collection view will display. You must ensure that these calculations are performed as quickly and as efficiently as possible because your layout calculations directly influence the performance of your collection view. A poor layout implementation will lead to slow scrolling and a lousy user experience eventually. </p>
			<p>Luckily, the documentation that has been provided for creating a collection view layout is pretty good as a reference to figure out whether you're on the right track.</p>
			<p>If you take a look at Apple's documentation on <code>UICollectionViewLayout</code>, you can read about its role in a collection view. The available information shows that a custom layout requires you to handle the layout for cells, supplementary views, and decoration views. Supplementary views are also known as headers and footers.</p>
			<p>Let's take a look at how we could begin to implement that. We'll start by creating our own class to do the job:</p>
			<pre>class ContactsCollectionViewLayout: UICollectionViewLayout {
    
    override var collectionViewContentSize: CGSize {
        return .zero
    }
    
    override func prepare() {
        
    }
    
    override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool {
        return false
    }
    
    override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {
        return nil
    }
    
    override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? {
        return nil
    }
    
}</pre>
			<p>As you can see from the preceding code, here we've implemented a subclass of <code>UICollectionViewLayout</code> and have a variety of overridden functions that we can use – let's go through these now.</p>
			<h3>Implementing collectionViewContentSize</h3>
			<p>A collection view <a id="_idTextAnchor109"/><a id="_idTextAnchor110"/>uses the <code>collectionViewContentSize</code> property from its layout to figure out <a id="_idIndexMarker164"/>the size of its contents. This property is especially important because it is used to configure and display the scrolling indicators for the collection view. </p>
			<p>It also provides the collection view with information about the direction in which scrolling should be enabled.</p>
			<p>Implementing this property uses the number of rows and columns in the collection view. It also takes the item size and item spacing into account to come up with the size of all of its contents together.</p>
			<h3>Implementing layoutAttributesForElements(in:)</h3>
			<p>More <a id="_idIndexMarker165"/>complex than <code>collectionViewContentSize</code> is <code>layoutAttributesForElements(in:)</code>. This method is responsible for providing a collection view with the layout attributes for several elements at once. </p>
			<p>The collection view always provides a rectangle, for which it needs layout attributes. The layout is responsible for providing these attributes to the collection view as fast as possible. The implementation of this method must be as efficient as you can get it to be. Your scroll performance depends on it.</p>
			<p>Even though there is only a small number of cells visible at a time, the collection view has a lot more content outside of its current viewport. Sometimes it is asked to jump to a particular cell, or the user scrolls extremely fast. </p>
			<p>There are many cases where the collection view will ask for all layout attributes for several cells at once. When this happens, the layout object can help the cell determine which cells should be visible for a particular rectangle. This is possible because the layout attributes not only contain the rectangle in which a cell should be rendered but they also know the <code>IndexPath</code> object that corresponds with that specific cell.</p>
			<p>This is a pretty complicated matter, and it's okay if you find this to be a little bit confusing. As long as you understand that a collection view can ask its layout which cells are present <a id="_idIndexMarker166"/>in a certain <code>CGRect</code> instance and how they should be rendered, you understand what <code>layoutAttributesForElements(in:)</code> does.</p>
			<h3>Implementing layoutAttributesForItem(at:)</h3>
			<p>Another way that a collection view can request layout attributes for its layout is by requesting the <a id="_idIndexMarker167"/>attributes for a single item. Because the collection view does so by supplying an index path, this method is quite simple to implement. </p>
			<p>The layout you implemented assumes that only a single section exists in the collection view and the layout attributes array is sorted by index path because that's the order in which all items were inserted into the array.</p>
			<h3>Implementing shouldInvalidateLayout(forBoundsChange:)</h3>
			<p>Getting the <a id="_idIndexMarker168"/>implementation for <code>shouldInvalidateLayout(forBoundsChange:)</code>  is crucial to having a great collection <a id="_idIndexMarker169"/>view layout that has amazing performance.  </p>
			<p>If you implement this method incorrectly, you could constantly be invalidating the layout, meaning you will need to recalculate all the time. </p>
			<p>It's also possible that the collection view will never update its layout at all, even when it should. The collection view will call this method any time its size changes. For instance, when the user rotates their device or when your app runs on an iPad, the user opens another app in multitasking mode.</p>
			<h3>Assigning a custom layout to your collection view</h3>
			<p>The final step to <a id="_idIndexMarker170"/>using your custom layout is telling your collection view to use your layout. You have already seen that you can assign a custom class to the layout for a collection view in Interface Builder. </p>
			<p>However, this only works when your layout inherits from <code>UICollectionViewFlowLayout</code>, which your layout does not inherit from. Luckily, you can also set your collection view's layout in code. Update your <code>viewDidLoad</code> method in <code>ViewController.swift</code> by adding the following line to it:</p>
			<pre>collectionView.collectionViewLayout = ContactsCollectionViewLayout()</pre>
			<p>This line sets your new layout as the current layout. You can now remove the <code>UICollectionViewDelegateFlowLayout</code> extension from <code>ViewC<a id="_idTextAnchor111"/>ontroller.swift</code> as it is not needed anymore.</p>
			<p>Now <a id="_idIndexMarker171"/>that we've looked at layouts in more detail, let's take a look at how we handle user interaction with cell selection.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor112"/>Cell selection in collection views</h2>
			<p>Although almost <a id="_idIndexMarker172"/>identical to its <code>UITableView</code> counterpart, I thought it was worth calling this function out:</p>
			<pre>func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</pre>
			<p>With again the only real difference being that <code>Row</code> is replaced with <code>Item</code>, this delegate method performs in the exact same way.</p>
			<p>We can make use of the reuse identifier and work with our cell directly should we need to manipulate it in any way (see <a href="B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 5</em></a>, <em class="italic">Immersing Your Users with Animation</em>, for some exciting things we can do here).</p>
			<p>In this section, we delved into the inner workings of the <code>UICollectionView</code> layout options and explored further how we can use <code>UICollectionViewLayout</code> to subclass our own layout, allowing us, the developer, to utilize specific and complex calculations should we need too. In our next and final section, we'll take a look at how Apple's new powerful UI framework, SwiftUI, handles lists.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor113"/>Working with lists in SwiftUI</h1>
			<p>Back at WWDC 2019, Apple unveiled to the world a brand-new UI framework called SwiftUI. Built <a id="_idIndexMarker173"/>from the ground up, SwiftUI is a powerful alternative to UIKit and AppKit, offering developers the ability to write code using declarative syntax.</p>
			<p>In this section, we are going to cover what SwiftUI has to offer in terms of generating lists and what we may need to do going forward should we require the use of anything that isn't available to use just yet.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor114"/>Creating our first SwiftUI project</h2>
			<p>For this, we're <a id="_idIndexMarker174"/>going to need to create a new single view app, the same as before, but only this time we'll need to select <strong class="bold">SwiftUI</strong> for our user interface, as highlighted in the following screenshot:</p>
			<div><div><img src="img/Figure_3.21_B14717.jpg" alt="Figure 3.21 – New SwiftUI project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – New SwiftUI project</p>
			<p>If you're unfamiliar with SwiftUI, you'll notice a couple of differences. You'll no longer have a <code>ViewController.swift</code> file – this has been replaced with <code>ContentView.swift</code>.</p>
			<p>Highlight the file to take a look at the contents; you should see the following boilerplate code:</p>
			<pre>import SwiftUI
struct ContentView: View {
    var body: so<a id="_idTextAnchor115"/><a id="_idTextAnchor116"/>me View {
        Text("Hello, World!")
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}</pre>
			<p>First, let's take a look at the <code>ContentView</code> struct – this is the first step of how SwiftUI builds up its declarative interface. Inside the <code>ContentView</code> struct is the body. Notice how these conform to either <code>View</code> or <code>some View</code> – that's because the concept of <code>ViewController</code> components in SwiftUI is no longer used; everything is a view being returned to the window.</p>
			<p>But without <a id="_idIndexMarker175"/>getting too involved in the workings of SwiftUI, all we care about now is the contents of the body declaration. So, in the case of the preceding example, all we care about is the following:</p>
			<pre>Text("Hello, World!")</pre>
			<p><code>Text</code> is SwiftUI's equivalent to <code>UILabel</code> – pretty neat, right, how a simple one line of code can construct, instantiate, and accept a value to display? Oh, and no need to add it to the view either – the fact that this line of code is present is enough. </p>
			<p>Another benefit to using SwiftUI is the ability to preview code changes on the fly. If you take a look in Xcode to the right of our opened <code>ContentView.swift</code> file, you'll see the preview assistant. Click <strong class="bold">Resume</strong> at the top left and we should see a preview of our app appear:</p>
			<div><div><img src="img/Figure_3.22_B14717.jpg" alt="Figure 3.22 – SwiftUI &quot;Hello, World!&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – SwiftUI "Hello, World!"</p>
			<p>Now, let's take a look at how we would add in a list of items.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor117"/>Building a list in SwiftUI</h2>
			<p>We'll start <a id="_idIndexMarker176"/>simple, by just adding our already-existing label to a list. Make the following highlighted code change, and if required, press resume in the preview assistant window:</p>
			<pre>var body: some View {
    List {
        Text("Hello, World!")
    }
}</pre>
			<p>That's right, it really is as simple as that. Go on and add a couple more <code>Text</code> views and see how it looks – even try running this in your simulator to see how it looks:</p>
			<div><div><img src="img/Figure_3.23_B14717.jpg" alt="Figure 3.23 – SwiftUI list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – SwiftUI list</p>
			<p>Nice and simple, but much like we did with our <code>UITableView</code> components and <code>UICollectionView</code> components, let's see how we could go about adding in some external data.</p>
			<p>Make the <a id="_idIndexMarker177"/>following highlighted change to our code in <code>ContentView.swift</code>:</p>
			<pre><strong class="bold">@State var contacts: [String] = [String]()</strong>
   
var body: some View {
    <strong class="bold">List {	</strong>
<strong class="bold">    ForEach(contacts, id: \.self) { contact in</strong>
<strong class="bold">        	Text(contact)</strong>
<strong class="bold">    	    }</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>Here, we've added in a <code>ForEach</code> function to our list; this is going to iterate around our array of contacts that we created just outside our body.</p>
			<p>But if we press resume, you'll see that we get no data…let's fix this. Take a look just below the <code>ContentView</code> struct and you'll see the following code:</p>
			<pre>struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}</pre>
			<p>This struct is how our preview assistance can display our app – our own little internal testing/playground while <a id="_idIndexMarker178"/>we develop our SwiftUI view – without even needing to run the simulator.</p>
			<p>Let's add some code in then to inject a little mock data into our preview. Make the following highlighted changes:</p>
			<pre>struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
<strong class="bold">        let mockData = ["Chris", "Andy", "Harry", "Nathan", "Sam"]</strong>
<strong class="bold">        return ContentView(contacts: mockData)</strong>
    }
}</pre>
			<p>We simply just create some mock data that we can inject straight into our view, if not already updated. Click <strong class="bold">Resume</strong> on the preview assistant and see your code in action – however, if you run this in the simulator, you won't see anything, as the preview is no longer in effect and the app you see is your actual app (which we haven't added any data to yet).</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor118"/>The equivalent to creating a custom cell in SwiftUI</h2>
			<p>It's hard trying not to <a id="_idIndexMarker179"/>make a direct comparison to UIKit objects when developing with SwiftUI – but we'll all do it and it's okay, because usually there is a way to perform a similar action or a new way to learn.</p>
			<p>Going back to the beginning of this section, I mentioned that SwiftUI is all about views, and that's no different when implementing a custom "cell" for a list in SwiftUI. We'll start by creating a new view (we'll do this inside of your <code>ContentView.swift</code> file, but outside of the initial class declaration):</p>
			<pre>struct RowView: View {
    
    @State var name: String
    
    var body: some View {
        Text(name)
    }
    
}</pre>
			<p>Just like <code>ContentView</code>, our new <code>RowView</code> is a simple view being created that can be used anywhere within SwiftUI. The structs can accept a <code>name: String</code> variable and will display this within a <code>Text</code> view – just like we did inside <code>ContentView</code>.</p>
			<p>Now, let's amend our code to make use of this. Make the following highlighted changes:</p>
			<pre>List {
    ForEach(contacts, id: \.self) { contact in
<strong class="bold">        RowView(name: contact)</strong>
    }
}</pre>
			<p>It really is a simple as that; we can now treat <code>RowView</code> as we did collection view or table view cells and decorate them or work on them independently to their parent lists. </p>
			<p>You can even create your own preview provider just for <code>RowView</code> so that you can again inject mock data whilst developing.</p>
			<p>In this section, we were introduced to SwiftUI as a framework and took a look at the basic building blocks <a id="_idIndexMarker180"/>needed to create a project. From this, we learned about how lists are used and how we can use the preview assistant to our advantage when developing Swift<a id="_idTextAnchor119"/>UI interfaces.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor120"/>Summary</h1>
			<p>In this chapter, we looked at everything to do with lists. We started by learning how to create a <code>UITableView</code> object – pulling in contacts from our device and displaying them in the way we want. We then moved on to <code>UICollectionView</code>, comparing it against our previous implementation and looking at some of the subtle and larger differences it had to offer – such as cell layout and manipulation.</p>
			<p>We then delved a little deeper into each of these, specifically looking at layouts with <code>UICollectionView</code> components, which is one of its most powerful features.</p>
			<p>We then finished off by taking a look at the SwiftUI framework and how Apple has made it so easy not only to develop but also to display data in different ways that we have been used to previously with the ease of the declarative syntax and the use of the preview assistant.</p>
			<p>In the next chapter, we'll be looking at taking our lists a step further and creating a details page for them to navigate to with the use of the cell interaction that we covered in this chapter.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor121"/>Further reading</h1>
			<ul>
				<li>Apple Developer documentation on table views:<p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/table_views">https://developer.apple.com/documentation/uikit/views_and_controls/table_views</a></p></li>
				<li>Apple Developer documentation on collection views:<p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/collection_views">https://developer.apple.com/documentation/uikit/views_and_controls/collection_views</a></p></li>
				<li><em class="italic">Learn SwiftUI</em> (Packt Publishing): <p><a href="https://www.packtpub.com/business-other/learn-swiftui">https://www.packtpub.com/business-other/learn-swiftui</a></p></li>
			</ul>
		</div>
	</body></html>