<html><head></head><body>
		<div id="_idContainer063">
			<h1 id="_idParaDest-67"><em class="italic"><a id="_idTextAnchor066"/>Chapter 3</em>: Using Lists and Tables</h1>
			<p>There's a good chance that you have built a simple app before, or maybe you have tried but didn't quite succeed. If this is the case, you have likely used <strong class="source-inline">UITableView</strong> or <strong class="source-inline">UICollectionView</strong>, as both are core components of many iOS applications. </p>
			<p>If an app shows a list of items, it was likely built using <strong class="source-inline">UITableView</strong>. This chapter will ensure that you are up to speed with the ins and outs of <strong class="source-inline">UITableView</strong> and <strong class="source-inline">UICollectionView</strong>. In addition to covering the basics, such as how we use the delegation pattern, you'll also learn how to access users' data – in this case, their contacts – which will be rendered in a <strong class="source-inline">UITableView</strong> and <strong class="source-inline">UICollectionView</strong> object.</p>
			<p>We'll finish this chapter by taking a look at lists in SwiftUI, Apple's new UI framework announced back in 2019. We'll touch on the fundamental differences between what SwiftUI and UIKit have to offer.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Working with <strong class="source-inline">UITableView</strong></li>
				<li>Exploring table views further</li>
				<li>Working with <strong class="source-inline">UICollectionView</strong></li>
				<li>Exploring collection views further</li>
				<li>Working with lists in SwiftUI</li>
			</ul>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Technical requirements </h1>
			<p>For this chapter, you'll need to download Xcode version 11.4 or above from Apple's App Store. </p>
			<p>You'll also need to be running the latest version of macOS (Catalina or above). Simply search for Xcode in the App Store, and select and download the latest version. Launch Xcode and follow any additional installation instructions that your system may prompt you with. Once Xcode has fully launched, you're ready to go.</p>
			<p>Download the sample code from the following GitHub link:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Working with UITableView</h1>
			<p>In this section, we'll<a id="_idIndexMarker118"/> start by taking a look at <strong class="source-inline">UITableView</strong>, one of the most – if not <em class="italic">the</em> most – common ways of displaying data in a list in iOS.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Setting up the project</h2>
			<p>Every time you start a <a id="_idIndexMarker119"/>new project in Xcode, you have the option to pick a template for your app. Every template contains a small amount of code or some boilerplate code to get you started. In most cases, a basic layout will even be set up for you. Throughout this book, you should default to using the <strong class="bold">Single View App</strong> template. Don't be fooled by its name; you can add as many views to your app as you would like. This template just provides you with one view to start with.</p>
			<p>In this chapter, you will create an app that is called My Contacts. This app displays your user's contacts list in a <strong class="source-inline">UITableView</strong> component that you will set up. Let's create a project for this app right now. </p>
			<p>In the menu bar, do the following:</p>
			<ol>
				<li>Select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong>. </li>
				<li>Select <strong class="bold">Single View App</strong>.</li>
				<li>Name your project <strong class="source-inline">Contacts List</strong> or anything you like.</li>
				<li>Make sure your programming language is set to <strong class="bold">Swift</strong> and the user interface is set to <strong class="bold">Storyboard</strong> – it should <a id="_idIndexMarker120"/>resemble something like the following:<div id="_idContainer040" class="IMG---Figure"><img src="image/Figure_3.01_B14717.jpg" alt="Figure 3.1 – Xcode new project options&#13;&#10;"/></div><p class="figure-caption">Figure 3.1 – Xcode new project options</p></li>
				<li>From here, click <strong class="bold">Next</strong> and then <strong class="bold">Create</strong>.</li>
				<li>Once your project has loaded, open the file named <strong class="source-inline">Main.storyboard</strong> found in the navigation tree to the left-hand side. </li>
			</ol>
			<p>The storyboard file is used to lay out all of your application's views and to connect them to the code you write. The editor you use to manipulate your storyboard is called Interface Builder.</p>
			<p>If you have used <strong class="source-inline">UITableView</strong> in the past, you may have used <strong class="source-inline">UITableViewController</strong>. The <strong class="source-inline">UITableViewController</strong> class is a subclass of a regular <strong class="source-inline">UIViewController</strong> class.</p>
			<p>The difference is that <strong class="source-inline">UITableViewController</strong> contains a lot of setup that you would otherwise have to perform on your own, either in Interface Builder or programmatically. To fully understand how <strong class="source-inline">UITableView</strong> is configured and set up, we won't use <strong class="source-inline">UITableViewController</strong> in this example.</p>
			<p>Back in Xcode, you'll notice a button at the top right that has a plus symbol on it. Click on this to bring up the object explorer. Once opened, search for <strong class="source-inline">Table View</strong>. If you begin typing the name of a potential component, you should see a list of suggested options become <a id="_idIndexMarker121"/>available – just like in the following screenshot:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_3.02_B14717.jpg" alt="Figure 3.2 – Adding an object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Adding an object</p>
			<p> Once you find <strong class="bold">Table View</strong>, drag it straight onto your canvas in Interface Builder. Don't worry about it being placed awkwardly, we're going to fix that now by using Auto Layout to add some constraints.</p>
			<p>Inside our canvas, highlight the <strong class="source-inline">UITableView</strong> object we just added and click on the icon highlighted in the following screenshot. Add in top, leading, trailing, and bottom constraints of <strong class="source-inline">0</strong>:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_3.03_B14717.jpg" alt="Figure 3.3 – Setting constraints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Setting constraints</p>
			<p>Once done, click <strong class="bold">Add 4 Constraints</strong> – you'll see straight away in the canvas that your <strong class="source-inline">UITableView</strong> object is <a id="_idIndexMarker122"/>now pinned perfectly to each edge of your screen. Regardless of what size device this is displayed on, those constraints will also be adhered to.</p>
			<p>Auto Layout enables you to create layouts that automatically adapt to any screen size that exists. Your layout currently uses fixed coordinates and dimensions to lay out the table view. For instance, your table view is set up to be positioned at 0, with a size of (375, 667). This size is perfect for devices such as the iPhone 8 and SE, but it wouldn't fit nicely with the iPhone 11 or iPad Pro. This combination of a view's position and size is called the frame.</p>
			<p>Auto Layout uses constraints to define a layout instead of a frame. For instance, to make the table view fit the entire screen, you would add constraints that pin every edge of the table view to the corresponding edge of its superview. Doing so would make the table view match its superview's size at all times.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Fetching contacts data</h2>
			<p>In order for us to be <a id="_idIndexMarker123"/>able to fetch the user's contacts from our device, we first need to be granted access via the <strong class="source-inline">Contacts</strong> framework.</p>
			<p>Apple are really heavy on privacy, so in turn, they require the user to "allow" access whenever an app first tries to read from the Address Book. This doesn't just stop at the Address Book, too; this can be found for camera access, location services, photos, and more.</p>
			<p>As in our case, when you need to access privacy-sensitive information, you are required to specify a reason as to why you would like to access the information. Nothing too detailed – but enough to give the user peace of mind as to why you would like to access their data.</p>
			<p>This is done by adding an entry to the <strong class="source-inline">Info.plist</strong> file in your project. Whenever you need access to privacy-sensitive information, you are required to specify this in your app's <strong class="source-inline">Info.plist</strong> file.</p>
			<p>In order to add this information to <strong class="source-inline">Info.plist</strong>, take the following steps:</p>
			<ol>
				<li value="1">Open it from the list of files in the Project navigator on the left. </li>
				<li>Once opened, hover over the words <strong class="source-inline">Information Property List</strong> at the top of the file.</li>
				<li>A plus icon should appear. Clicking it adds a new empty item with a search field to the list.</li>
				<li>When you begin typing <strong class="source-inline">Privacy – contacts</strong>, Xcode will filter out options for you until there is only one left for you to pick.</li>
				<li>This option is called <strong class="bold">Privacy – Contacts Usage Description</strong> and is the key we are looking for.</li>
			</ol>
			<p>The value for this newly added key should describe the reason that you need access to the specified piece of information. In this case, "reads contacts and shows them in a list" should be a sufficient explanation. When the user is asked for permission to access their contacts, the reason you specified here will be shown, so make sure you add an informative message.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Make sure you do choose an informative message that is relevant to your app. If Apple review this and don't find it to be acceptable, they could question you, or even worse, reject the submission of your app.</p>
			<p>Now, let's get down to writing some code. Before you can read contacts, you must make sure that the user has given the appropriate permissions for you to access the contacts data. To do this, the code must first read the current permission status. Once done, the user must either be prompted for permission to access their contacts, or the contacts must be fetched. </p>
			<p>Add the following highlighted code to <strong class="source-inline">ViewController.swift</strong>; we'll cover the details a section at a time – but don't worry, it will all make sense in the end:</p>
			<p class="source-code">import UIKit</p>
			<p class="source-code"><strong class="bold">import Contacts</strong></p>
			<p class="source-code">class ViewController: UIViewController {</p>
			<p class="source-code">    </p>
			<p class="source-code">    override func viewDidLoad() {</p>
			<p class="source-code">        <strong class="bold">requestContacts()</strong></p>
			<p class="source-code">    }</p>
			<p>To start, we've<a id="_idIndexMarker124"/> imported <strong class="source-inline">Contacts</strong> into our <strong class="source-inline">ViewController</strong> class; by doing this, we're allowing the <strong class="source-inline">Contacts</strong> framework API to not just be inside our project, but specifically in our <strong class="source-inline">ViewController</strong> class.</p>
			<p>Next, we've added a call to a function named <strong class="source-inline">requestContacts</strong> in <strong class="source-inline">viewDidLoad()</strong> – we'll now need to create this function:</p>
			<p class="source-code">private func requestContacts() {</p>
			<p class="source-code">        </p>
			<p class="source-code">    let store = CNContactStore()</p>
			<p class="source-code">    let authorizationStatus = CNContactStore.authorizationStatus(for: .contacts)</p>
			<p class="source-code">        </p>
			<p class="source-code">    if authorizationStatus == .notDetermined {</p>
			<p class="source-code">        store.requestAccess(for: .contacts) { [weak self] didAuthorize, error in</p>
			<p class="source-code">            if didAuthorize {</p>
			<p class="source-code">                self?.retrieveContacts(from: store)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    } else if authorizationStatus == .authorized {</p>
			<p class="source-code">        retrieveContacts(from: store)</p>
			<p class="source-code">    }</p>
			<p class="source-code">        </p>
			<p class="source-code">}</p>
			<p>Basically, without going into too many details, this forces iOS (if not already) to request permission for your app to access the contacts data. If the current status is unknown (or <strong class="source-inline">notDetermined</strong>), then permission will be requested. If this is not the case and the framework responds with <strong class="source-inline">didAuthorize == true</strong>, then we can now attempt to access the contacts information. We've also added an extra condition in there too to check whether we have already previously been authorized. You'll notice that <strong class="source-inline">store.requestAccess</strong> looks a little different from a regular function call; this is because it uses a completion handler.</p>
			<p>In asynchronous programming, completion handlers are used often. They allow your app to perform some work in the background and then call the completion handler when the work is completed. You will find completion handlers throughout many frameworks. If you implement a very<a id="_idIndexMarker125"/> simple function of your own that takes a callback, it might look as follows: </p>
			<p class="source-code">func doSomething(completionHandler: (Int) -&gt; Void) {</p>
			<p class="source-code">    // perform some actions</p>
			<p class="source-code">    var result = theResultOfSomeAction </p>
			<p class="source-code">    completionHandler(result)</p>
			<p class="source-code">}</p>
			<p>Calling a completion-handler looks just like calling a function. The reason for this is that a completion handler is a block of code, called a closure. Closures are a lot like functions because they both contain a potentially reusable block of code that is expected to be executed when called. </p>
			<p>Now, let's add our final piece of the puzzle by adding in our function to retrieve the contacts:</p>
			<p class="source-code">func retrieveContacts(from store: CNContactStore) {</p>
			<p class="source-code">        </p>
			<p class="source-code">    let containerId = store.defaultContainerIdentifier()</p>
			<p class="source-code">    let predicate = CNContact.predicateForContactsInContainer(withIdentifier: containerId)</p>
			<p class="source-code">    let keysToFetch = [CNContactGivenNameKey as CNKeyDescriptor,</p>
			<p class="source-code">    CNContactFamilyNameKey as CNKeyDescriptor, CNContactImageDataAvailableKey as CNKeyDescriptor,</p>
			<p class="source-code">    CNContactImageDataKey as CNKeyDescriptor]</p>
			<p class="source-code">        </p>
			<p class="source-code">    let contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)</p>
			<p class="source-code">}</p>
			<p>A brief explanation of the <a id="_idIndexMarker126"/>preceding code: we pass an instance of <strong class="source-inline">CNContactStore</strong> (which we've previously been given permission to access), and then we set up a request for specific information we would like with the array of <strong class="source-inline">CNKeyDescriptor</strong>. </p>
			<p>Finally, the call is made and will fetch this information, which is returned to us in a <strong class="source-inline">CNContact</strong> object.</p>
			<h2 id="_idParaDest-72">Pre<a id="_idTextAnchor071"/><a id="_idTextAnchor072"/>pping UITableView to display our contacts</h2>
			<p>With all that ready, let's <a id="_idIndexMarker127"/>head on back to Interface Builder and add in a table view cell:</p>
			<ol>
				<li value="1">Highlight the <strong class="source-inline">UITableView</strong> object we added to the canvas.</li>
				<li>Click on the <strong class="bold">+</strong> button to add another object. This time, search for <strong class="source-inline">Table View Cell</strong>.</li>
				<li>Now, drag this object onto <strong class="source-inline">UITableView</strong>. </li>
			</ol>
			<p>You'll notice something a little different this time: the <strong class="source-inline">UITableViewCell</strong> object that we dragged automatically snapped into position on our <strong class="source-inline">UITableView</strong> object – don't worry, that's fine, this is because <strong class="source-inline">UITableViewCell</strong>'s position is controlled by the configuration of its <strong class="source-inline">UITableView</strong> object. Next, we are going to create an <strong class="source-inline">IBOutlet</strong> for our code. In the same way that we did in <a href="B14717_02_Final_ASB_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Dark Mode</em>, create an outlet programmatically in your <strong class="source-inline">ViewController.swift</strong> file, and then connect these using Interface Builder.</p>
			<p>Here is an example of the outlet you are going to create:</p>
			<p class="source-code">@IBOutlet weak var tableView: UITableView!</p>
			<p>Now, we need to create a class for <strong class="source-inline">UITableViewCell</strong> – by doing this, we can add custom properties to <strong class="source-inline">UITableViewCell</strong>, such as a name, contact information, or even an image.</p>
			<p>Back inside our <strong class="source-inline">ViewController.swift</strong> file (but outside of the <strong class="source-inline">ViewController</strong> class declaration), add the following code:</p>
			<p class="source-code">class ContactCell: UITableViewCell {</p>
			<p class="source-code">    @IBOutlet weak var nameLabel: UILabel!</p>
			<p class="source-code">    @IBOutlet weak var contactImageView: UIImageView!</p>
			<p class="source-code">}</p>
			<p>Here, we've created our custom cell, which is a subclass of <strong class="source-inline">UITableViewCell</strong> and will carry all the traits of a table view cell that we need. I've also added a couple of <strong class="source-inline">IBOutlet</strong> components for the data that we are going to display.</p>
			<p>Now, let's go hook this up. Head on back to Interface Builder and select the <strong class="source-inline">UITableViewCell</strong> object that we added.</p>
			<p>Once highlighted, click <a id="_idIndexMarker128"/>on the Identity inspector in the right-hand tool window and add <strong class="source-inline">ContactCell</strong> as the <strong class="bold">Class</strong> name:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_3.04_B14717.jpg" alt="Figure 3.4 – Table view class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Table view class</p>
			<p>Then, click on the Attributes Inspector and type in <strong class="source-inline">contactCell</strong> for <strong class="bold">Identifier</strong>:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_3.05_B14717.jpg" alt="Figure 3.5 – Table view cell identifier&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Table view cell identifier</p>
			<p>Overriding <strong class="source-inline">UITableViewCell</strong>'s class to our custom class will allow us to use Interface Builder to connect objects to the <strong class="source-inline">IBOutlet</strong> components that we just created. We'll touch on the identifier later on in this chapter, but it's always good to get these bits out of the way at the start.</p>
			<p>Now, let's add a couple of objects to <strong class="source-inline">UITableViewCell</strong>. We'll start with <strong class="source-inline">UILabel</strong>, and then <strong class="source-inline">UIImageView</strong> (add these in the same way you did the table view and cell – have the image to the left of the cell).</p>
			<p>Once added, have a play with the <strong class="source-inline">Autolayout</strong> constraints we learned about earlier. The best way to master Auto Layout is trial and error - if you get stuck, just refer to the sample project for this chapter to guide you along.</p>
			<p>Once you are done, your cell will look something like this:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_3.06_B14717.jpg" alt="Figure 3.6 – Label with constraints&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Label with constraints</p>
			<p>Now, let's hook each one of these up to the <strong class="source-inline">IBOutlet</strong> components we created – all going well, Interface Builder should pick up on the associated class (<strong class="source-inline">ContactCell</strong>) and will allow the outlets to be attached without any problems.</p>
			<p>Awesome, we're making <a id="_idIndexMarker129"/>great progress, and believe it or not, we're not a million miles away from displaying the data in our app – but first, we need to cover some important fundamentals of <strong class="source-inline">UITableView</strong> and, more importantly, the delegation pattern that iOS used so heavily.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Understanding protocols and delegation</h2>
			<p>Throughout <a id="_idIndexMarker130"/>the iOS SDK and the Foundation<a id="_idIndexMarker131"/> framework, a design pattern named delegation is used. Delegation allows an object to have another object to perform work on its behalf. </p>
			<p>When implemented correctly, it's a great way to separate concerns and decouple code within your app.</p>
			<p>The table view uses the help of two objects to function correctly. One is the delegate, and the other is the data source. Any time you use a table view, you must configure these two objects yourself. When the time comes for the table view to render its contents, it asks data source for information about the data to display. The delegate comes into play when a user interacts with the items in the table view.</p>
			<p>If you look at the documentation for <strong class="source-inline">UITableView</strong>, you can find the delegate property. The type for delegate is <strong class="source-inline">UITableViewDelegate?</strong>. This tells you two things about delegate. First of all, <strong class="source-inline">UITableViewDelegate</strong> is a protocol. This means that any object can act as a delegate for a table view, as long as it implements the <strong class="source-inline">UITableViewDelegate</strong> protocol. Second, the question mark at the end of the type name tells you that the delegate is an optional property. An optional property either has a value of the specified type, or it is nil. The table view's delegate property is optional because you do not have to set it to create a functioning table view.</p>
			<p>A protocol, such as <strong class="source-inline">UITableViewDelegate</strong>, defines a set of properties and methods that must be implemented by any type that wants to conform to the protocol. Not all methods must be explicitly implemented by conforming objects. Sometimes, a protocol extension provides a reasonable default implementation.</p>
			<p>In addition to delegate, <strong class="source-inline">UITableView</strong> has a data source property. data source's type is <strong class="source-inline">UITableViewDataSource?</strong>, and just like <strong class="source-inline">UITableViewDelegate</strong>, <strong class="source-inline">UITableViewDataSource</strong> is a protocol. However, <strong class="source-inline">UITableViewDelegate</strong> only has optional methods, meaning you don't need to implement any methods to conform to <strong class="source-inline">UITableViewDelegate</strong>. <strong class="source-inline">UITableViewDataSource</strong> does have required methods: the methods that need to be implemented are used to provide the table view with just enough information to be able to display the correct number of cells with the right content in them.</p>
			<p>If this is the first time you're learning about protocols and delegation, you might feel a little bit lost right now. That's OK; you'll get the hang of it soon. Throughout this book, your understanding of topics such as these will improve bit by bit. You will even learn about a concept <a id="_idIndexMarker132"/>called <a id="_idIndexMarker133"/>protocol-oriented programming! </p>
			<p>For now, you must understand that a table view asks for a different object for the data it needs to show and that it also uses a different object to handle certain user interactions.</p>
			<p>We can break the flow of displaying content in a table view down into a couple of steps; when the table view needs to reload the data, it does the following:</p>
			<ol>
				<li value="1">The table view checks whether <strong class="source-inline">dataSource</strong> is set, and asks it for the number of sections it should render.</li>
				<li>Once the number of sections is passed back to the table view, <strong class="source-inline">dataSource</strong> is asked for the number of items for each section.</li>
				<li>With knowledge about the number of sections and items that need to be shown, the table view asks <strong class="source-inline">dataSource</strong> for the cells it should display.</li>
				<li>After receiving all of the configured cells, the table view can finally render these cells to the screen.</li>
			</ol>
			<p>These steps should give you a little bit more insight into how a table view uses another object to figure out the contents it should render. This pattern is compelling because it makes the table view an extremely flexible component. Let's put some of this newfound knowledge to use!</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Conforming to the UITableView protocols</h2>
			<p>To make <strong class="source-inline">ViewController</strong> both the delegate and the data source for its table view, it will have to conform<a id="_idIndexMarker134"/> to both protocols. It is a best practice to create an extension whenever you make an object conform to a protocol. Ideally, you make one extension for each protocol you want to implement. Doing this helps to keep your code clean and maintainable.</p>
			<p>Add the following extension to <strong class="source-inline">ViewController.swift</strong>:</p>
			<p class="source-code">extension ViewController: UITableViewDelegate, UITableViewDataSource {  </p>
			<p class="source-code">}</p>
			<p>After doing this, your code contains an error. That's because none of the required methods from <strong class="source-inline">UITableViewDataSource</strong> have been implemented yet. </p>
			<p>There are two methods you need to implement to conform to <strong class="source-inline">UITableViewDataSource</strong>. These methods are the following:</p>
			<ul>
				<li><strong class="source-inline">tableView(_:numberOfRowsInSection:) </strong></li>
				<li><strong class="source-inline">tableV<a id="_idTextAnchor075"/><a id="_idTextAnchor076"/>iew(_:cellForRowAt:)</strong></li>
			</ul>
			<p>Let's go ahead and fix the error Xcode is showing by adjusting the code a little bit. We'll also need to make a couple of small changes to display our contacts within our table view.</p>
			<p>We'll start by adding a global variable to our <strong class="source-inline">ViewController</strong> class. Add in the following just after the class declaration:</p>
			<p class="source-code">var contacts = [CNContact]()</p>
			<p>Here, we've instantiated an array of <strong class="source-inline">CNContact</strong>, which is what we get back in our <strong class="source-inline">retrie<a id="_idTextAnchor077"/><a id="_idTextAnchor078"/>veContacts</strong> function when <strong class="source-inline">store.unifiedContacts</strong> is called.</p>
			<p>Now, make the following modification to our <strong class="source-inline">retrieveContacts</strong> function:</p>
			<p class="source-code">contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)</p>
			<p>Perfect – now fill in the blanks with those delegates:</p>
			<p class="source-code">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {</p>
			<p class="source-code">    <strong class="bold">return contacts.count</strong></p>
			<p class="source-code">}</p>
			<p>Our first delegate method, <strong class="source-inline">tableView(_:numberOfRowsInSection:)</strong>, requires us to return the number of cells we want to display. As we want to display all of our contacts, we simply pass back the number of contacts in our array, as highlighted in the preceding code.</p>
			<p>Next, let's implement the <strong class="source-inline">tableV<a id="_idTextAnchor079"/><a id="_idTextAnchor080"/>iew(_:cellForRowAt:)</strong> delegate. Copy in the following code and we'll go through it one step at a time:</p>
			<p class="source-code">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {    </p>
			<p class="source-code">    let contact = contacts[indexPath.row]</p>
			<p class="source-code">        </p>
			<p class="source-code">    let cell = UITableViewCell()</p>
			<p class="source-code">    cell.textLabel?.text = contact.familyName</p>
			<p class="source-code">        </p>
			<p class="source-code">    return cell</p>
			<p class="source-code">}</p>
			<p>Basically, this delegate method is called for every cell that is going to be generated in our table view, so if <strong class="source-inline">contacts.count == 5</strong>, then this will be called 5 times. A way for us to identify which<a id="_idIndexMarker135"/> cell is currently being called is to inspect the <strong class="source-inline">indexPath.row</strong> value that is being passed in with each call. </p>
			<p>If you take a look at the first line of code with the preceding delegate, you'll see that we have accessed the specific contact by querying our array of <strong class="source-inline">CNContact</strong> with the <strong class="source-inline">indexPath.row</strong> value. From this, we simply just create an instance of <strong class="source-inline">UITableViewCell</strong>, assign a property of <strong class="source-inline">CNContact</strong> to <strong class="source-inline">.textLabel</strong>, and return the instance.</p>
			<p>We're almost ready to see our changes in action; just a couple more things to add in.</p>
			<p>Head on back to our <strong class="source-inline">viewDidLoad()</strong> function and add the following highlighted lines:</p>
			<p class="source-code">override func viewDidLoad() {</p>
			<p class="source-code"><strong class="bold">    tableView.delegate = self</strong></p>
			<p class="source-code"><strong class="bold">    tableView.dataSource = self</strong></p>
			<p class="source-code">      </p>
			<p class="source-code">    requestContacts()</p>
			<p class="source-code">}</p>
			<p>Here, we are telling our <strong class="source-inline">UITableView</strong> instance that our current <strong class="source-inline">ViewController</strong> class is the delegate base for all <strong class="source-inline">UITableView</strong> protocol operations. In a nutshell – the delegates we just added will get called when we try to perform any actions on our table view.</p>
			<p>Finally, add the following highlighted code to the end of our <strong class="source-inline">retrieveContacts</strong> functions:</p>
			<p class="source-code">contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)</p>
			<p class="source-code"><strong class="bold">Dispat<a id="_idTextAnchor081"/><a id="_idTextAnchor082"/>chQueue.main.async {</strong></p>
			<p class="source-code"><strong class="bold">self.tableView.reloadData()</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p>The reason we do this is again down to asynchronous programming. By design, our table view will try and display data as soon as <strong class="source-inline">ViewController</strong> is loaded. At this point, our contacts may not be available, we may have not been given suitable permission, or simply, the function's callback may not have returned all the data in time. </p>
			<p>So, if that's the case, once we <a id="_idIndexMarker136"/>know that all the data is ready to be displayed, we simply ask the table view to reload. Go ahead and run your app in the simulator – all going well, you will be prompted by the <strong class="source-inline">Contacts</strong> framework to allow permission to access your contacts, shortly followed by a list of contact details:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_3.07_B14717.jpg" alt="Figure 3.7 – User consent and user list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – User consent and user list</p>
			<p>In this part, we learned about how important protocols and delegates are in iOS development, and by hooking up a couple of simple functions, we were able to easily yet effectively display <a id="_idIndexMarker137"/>data in <strong class="source-inline">UITableView</strong>. Now, let's take a look at how we can customize each cell some more, with the <strong class="source-inline">UITableViewCell</strong> override we created earlier.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor083"/>Understanding the custom UITableViewCell override and the reuse identifier</h2>
			<p>Back in a previous<a id="_idIndexMarker138"/> section, <em class="italic">Prepping UITableView to display our contacts</em>, you'll remember that we created our custom <strong class="source-inline">UITableViewCell</strong> override called <strong class="source-inline">ContactCell</strong>, but in the end we never really used it. </p>
			<p>We did this on purpose, firstly to introduce you to the fact that <strong class="source-inline">UITableViewCell</strong> does have a minimal default offering where <strong class="source-inline">textLabel</strong> is given for you to add your required text. This can come in handy as a really lightweight way of generating a <strong class="source-inline">UITableView</strong> object and displaying some simple data – a no-fuss approach for quick wins or a situation where one line is good enough. However, if you want to be creative with your cells, then this is where the custom option comes into play.</p>
			<p>Let's head back to <strong class="source-inline">tableView(_:cellForRowAt:)</strong> and see how we'd make the change:</p>
			<p class="source-code">let contact = contacts[indexPath.row]</p>
			<p class="source-code">        </p>
			<p class="source-code">guard let cell = tableView.dequeueReusableCell(withIdentifier: "contactCell", for: indexPath) as? ContactCell else {</p>
			<p class="source-code">            return UITableViewCell()</p>
			<p class="source-code">}</p>
			<p class="source-code">        </p>
			<p class="source-code">cell.nameLabel.text = contact.givenName</p>
			<p class="source-code">if let imageData = contact.imageData {</p>
			<p class="source-code">    cell.conatctImageView.image = UIImage(data: imageData)</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    cell.conatctImageView.image = UIImage(systemName: "person.circle")</p>
			<p class="source-code">}</p>
			<p>Now, to start with, let's take a look at the first part:</p>
			<p class="source-code">tableView.dequeueReusableCell(withIdentifier: "contactCell", for: indexPath) as? ContactCell</p>
			<p>Here, we are instantiating the use of a reusable <strong class="source-inline">UITableViewCell</strong> with the identifier of <strong class="source-inline">contactCell</strong>, which is of the <strong class="source-inline">ContactCell</strong> class.<strong class="source-inline"> </strong></p>
			<p>Sounds confusing? Maybe a little, but think of it this way – we created a custom cell class that we assigned to our <strong class="source-inline">UITableViewCell</strong> object back in Interface Builder. We then gave this an identifier of <strong class="source-inline">contactCell</strong> – here, we simply called upon that cell to be used so that we can access its properties (remember the <strong class="source-inline">nameLabel</strong> and <strong class="source-inline">contactImageView</strong> properties we added).</p>
			<p>Once we have access <a id="_idIndexMarker139"/>to an instance of that cell, we can then simply assign each property accordingly with data taken from our contact instance. Notice that we're doing a check against the image data in the contacts due to the possibility of no image yet being associated with a contact – here, we've added a little fallback to display a system image (using SF Symbols).</p>
			<p>If you want you add an image, simply fire up the Contacts app in the simulator and drag an image from your Mac over - You should now be able to select this and assign this from the Contacts app.</p>
			<p>Go ahead and make those changes, and then run the app again:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_3.08_B14717.jpg" alt="Figure 3.8 – Contact list with image&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Contact list with image</p>
			<p>Perfect, but what is this <strong class="source-inline">dequeueReusableCell</strong> all about? Don't worry, we'll cover that in a later section, <em class="italic">Advances in UITableView and UICollectionView</em>.</p>
			<p>In this section, we learned how to implement <strong class="source-inline">UITableView</strong> and a custom <strong class="source-inline">UITableViewCell</strong>, pulling data obtained by accessing our contacts via the <strong class="source-inline">Contacts</strong> framework and <a id="_idIndexMarker140"/>displaying it within our app. Now, let's spend some time digging a little deeper into the art of table views and how they work.</p>
			<h1 id="_idParaDest-76">Exploring<a id="_idTextAnchor084"/><a id="_idTextAnchor085"/><a id="_idTextAnchor086"/> UITableView further</h1>
			<p>In this section, we'll touch<a id="_idIndexMarker141"/> on some extra little bits that will allow you to make the most out of <strong class="source-inline">UITableView</strong>. We'll also cover in more detail some areas previously explored, such as the reuse identifier.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor087"/>Further understanding reuse identifiers</h2>
			<p>Earlier in this chapter, you<a id="_idIndexMarker142"/> learned about cell-reuse in table views. We assigned a reuse identifier to a table view cell so that the table view would know which cell it should use to display contacts in. Cell-reuse is a concept that is applied to a table view so that it can reuse cells that it has already created. </p>
			<p>This means that the only cells that are in memory are either on the screen or barely off the screen. The alternative would be to keep all cells in memory, which could potentially mean that hundreds of thousands of cells are held in memory at any given time. </p>
			<p>For a visualization of what cell reuse looks like, have a look at the following diagram:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_3.09_B14717.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Table view cell layout</p>
			<p>As you can see, there are just a few cells in the diagram that are not on the visible screen. This roughly equals the number of cells that a table view might keep in memory. This means that regardless of the total amount of rows you want to show, the table view has roughly constant pressure on your app's memory usage.</p>
			<p>A cell is first created when <strong class="source-inline">dequeueReusableCell(withIdentifier:)</strong> is called on the table view and it does not have an unused cell available. Once the cell is either reused or created, <strong class="source-inline">prepareForReuse()</strong> is called on the cell. This is a great spot to reset your cells to their default state by removing any images or setting labels back to their default values. </p>
			<p>Next, <strong class="source-inline">tableView(_:willDisplay:forRowAt:)</strong> is called on the table view's delegate. This happens right before the cell is shown. You can perform some last-minute configuration here, but the majority of the work should already be done in <strong class="source-inline">tableView(_:cellForRowAtIndexPath:)</strong>.</p>
			<p>When the cell scrolls off screen, <strong class="source-inline">tableView(_:didEndDisplaying:forRowAt:)</strong> is called on the delegate. This signals that a <a id="_idIndexMarker143"/>previously visible cell has just scrolled out of the view's bounds.</p>
			<p>With all this cell life cycle information in mind, the best way to fix the image reuse bug is by implementing <strong class="source-inline">prepareForReuse()</strong> on <strong class="source-inline">ContactCell</strong>. Add the following implementation to remove any images that have previously been set:</p>
			<p class="source-code">override func prepareForReuse() { </p>
			<p class="source-code">    super.prepareForReuse()</p>
			<p class="source-code">    conatctImageView.image = nil</p>
			<p class="source-code">}</p>
			<p>Now, let's take a look at some other enhancements that we can make in our app by using prefetching.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor088"/>Prefetching in table views</h2>
			<p>In <a id="_idIndexMarker144"/>addition to <strong class="source-inline">UITableViewDelegate</strong> and <strong class="source-inline">UITableViewDataSource</strong>, a third protocol exists that you can implement to improve your table view's performance. </p>
			<p>It's called<a id="_idTextAnchor089"/><a id="_idTextAnchor090"/> <strong class="source-inline">UITableViewDataSourcePrefetching</strong>, and you can use it to enhance your data source. If your data source performs some complex task, such as retrieving and decoding an image, it could slow down the performance of your table view if this task is performed at the moment that the table view wants to retrieve a cell. Performing this operation a little bit sooner than that can positively impact your app, in those cases.</p>
			<p>So, how would we implement this? Simple, we first just conform <strong class="source-inline">ViewController</strong> to the new delegate:</p>
			<p class="source-code">extension ViewController: UITableViewDataSourcePrefetching {</p>
			<p class="source-code">    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {</p>
			<p class="source-code">        </p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>You'll notice that a fundamental difference here is within the <strong class="source-inline">indexPath</strong> parameter being passed in. This time, we have an array of <strong class="source-inline">IndexPath</strong>, as opposed to a single index, in turn, allowing us to perform batch processing on a set of cells that our table view would like us to display. </p>
			<p>This would be ideal if data from your cell has to be obtained asynchronously – such as an image or real-time data. You could really work hard here to perform and calculate the right way to display your data to get the optimum performance.<a id="_idTextAnchor091"/><a id="_idTextAnchor092"/></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor093"/>Cell selection in table views</h2>
			<p>Since a table view will <a id="_idIndexMarker145"/>call methods on its delegate whenever they are implemented, you don't need to tell the table view that you want to respond to cell selection. This automatically works if the table view has a delegate, and if the delegate implement<a id="_idTextAnchor094"/><a id="_idTextAnchor095"/>s <strong class="source-inline">tableView(_:didSelectRowAt:)</strong>.</p>
			<p>The implementation you'll add to our app, for now, is a very simple one. When the user taps a cell, the app displays an alert.</p>
			<p>Add the following code to the extension in <strong class="source-inline">ViewController.swift</strong>:</p>
			<p class="source-code">func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {</p>
			<p class="source-code">        </p>
			<p class="source-code">    let contact = contacts[indexPath.row]</p>
			<p class="source-code">    let alertController = UIAlertController(title: "Contact Details", message: "Hey \(contact.givenName)!!",</p>
			<p class="source-code">        preferredStyle: .alert)        </p>
			<p class="source-code">    let dismissAction = UIAlertAction(title: "Done", style: .default, handler: { action in</p>
			<p class="source-code">        tableView.deselectRow(at: indexPath, animated: true)</p>
			<p class="source-code">    })</p>
			<p class="source-code">        </p>
			<p class="source-code">    alertController.addAction(dismissAction);</p>
			<p class="source-code">    present(alertController, animated: true, completion: nil)</p>
			<p class="source-code">        </p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">tableView(_:didSelectRowAt:)</strong> method <a id="_idIndexMarker146"/>receives two arguments: the first is the table view that called this delegate method. The second argument is the index path at which the selection occurred. </p>
			<p>The implementation you wrote for this method uses the index path to retrieve the contact that corresponds with the tapped cell, so the contact name can be shown in an alert. </p>
			<p>You could also retrieve the contact's name from the tapped cell. However, this is not considered good practice because your cells and the underlying data should be as loosely coupled as possible. </p>
			<p>When the user taps the <strong class="bold">Done</strong> button in the alert, the table view is told to deselect the selected row. </p>
			<p>If you don't deselect the selected row, the last tapped cell will always remain highlighted. Note that the alert is displayed by calling <strong class="source-inline">present(_:animated:completion:)</strong> on the view controller. Any time you want to make a view controller display another view controller, such as an alert controller, you use this method.</p>
			<p>In this section, you learned a lot about what makes a table view tick, including a good understanding of how the <a id="_idIndexMarker147"/>reuse identifier works. Next, we'll take a look at <strong class="source-inline">UICollectionView</strong>, the <strong class="source-inline">UITableView</strong> class's bigger (or younger, really) brother, comparing similarities to each class and also key differences, too.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor096"/>Working with UICollectionView</h1>
			<p>In the previous section, we <a id="_idIndexMarker148"/>took on the mighty <strong class="source-inline">UITableView</strong> – learning all about the delegate pattern and how to build our unique lists with custom cells. In this section, we'll take a look at <strong class="source-inline">UICollectionView</strong>, mainly looking at how we are comparing one class to another.</p>
			<p>From the outset, when asked what the fundamental differences are between them both, most people will initially say the same thing: "Collection views allow horizontal scrolling" – which is very true, but what it's doing is harnessing the power of <strong class="source-inline">UITableView</strong> with the ability to manipulate and override a layout that would allow a grid layout, for example.</p>
			<p>If you need to go deeper into a complex custom layout, this again is where <strong class="source-inline">UICollectionView</strong> comes into play, with the support of the <strong class="source-inline">UICollectionViewDelegateFlowLayout</strong> protocol, allowing you as a developer to manipulate custom layouts.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor097"/>Setting up our collection view</h2>
			<p>Let's start by <a id="_idIndexMarker149"/>creating a new project in the exact same way as we did for a table view: </p>
			<ol>
				<li value="1">This time, search for <strong class="source-inline">Collection View</strong> in the object window (<em class="italic">you won't need to add in a </em><strong class="source-inline">CollectionView</strong><em class="italic"> cell as the collection view already does this for you</em>).</li>
				<li>Add in your constraints too so that it scales to the full size of the device.</li>
			</ol>
			<p>Back to <strong class="source-inline">ViewController</strong>, we'll need to create and hook up our <strong class="source-inline">IBOutlet</strong> components just like we did with the table view (but call your property something like <strong class="source-inline">collectionView</strong>).</p>
			<p>Once you've done that, we'll need to create another extension, but this time, our protocols will be slightly different:</p>
			<p class="source-code">extension ViewController: UICollectionViewDelegate, UICollectionViewDataSource {</p>
			<p class="source-code">    </p>
			<p class="source-code">    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {</p>
			<p class="source-code">        contacts.count</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {</p>
			<p class="source-code">        let contact = contacts[indexPath.item]</p>
			<p class="source-code">        </p>
			<p class="source-code">        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "contactCell", for: indexPath) as? ContactCell else {</p>
			<p class="source-code">            return UICollectionViewCell()</p>
			<p class="source-code">        }</p>
			<p class="source-code">        cell.setup(contact: contact)</p>
			<p class="source-code">        </p>
			<p class="source-code">        return cell</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">}</p>
			<p>Our two delegate methods in the preceding example are as follows:</p>
			<ul>
				<li><strong class="source-inline">collectionV<a id="_idTextAnchor098"/><a id="_idTextAnchor099"/>iew(_:numberOfItemsInSection:)</strong></li>
				<li><strong class="source-inline">collectionView(_:cellForItemAt:)</strong></li>
			</ul>
			<p>Both offer the same as their <strong class="source-inline">UITableView</strong> counterparts; only one difference you'll notice is the reference to the term <strong class="source-inline">Item</strong> rather than <strong class="source-inline">Row</strong>. This is because in <strong class="source-inline">UITableView</strong>, the layout is purely linear, so each cell is treated as a row. With <strong class="source-inline">UICollectionView</strong>, this is <a id="_idIndexMarker150"/>not the case – so, each cell is referred to as an item.</p>
			<p>Next, we want to create another custom cell. Copy and paste the one we made for our table view and make the following highlighted changes:</p>
			<p class="source-code">class ContactCell: <strong class="bold">UICollectionViewCell</strong> {</p>
			<p class="source-code">    </p>
			<p class="source-code"><strong class="bold">    @IBOutlet weak var familyNameLabel: UILabel!</strong></p>
			<p class="source-code"><strong class="bold">    @IBOutlet weak var givenNameLabel: UILabel!</strong></p>
			<p class="source-code">    @IBOutlet weak var contactImageView: UIImageView!</p>
			<p class="source-code">    </p>
			<p class="source-code">    </p>
			<p class="source-code">    func setup(contact: CNContact) {</p>
			<p class="source-code">        givenNameLabel.text = contact.givenName</p>
			<p class="source-code">        familyNameLabel.text = contact.familyName</p>
			<p class="source-code">        </p>
			<p class="source-code">        if let imageData = contact.imageData {</p>
			<p class="source-code">            conatctImageView.image = UIImage(data: imageData)</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            conatctImageView.image = UIImage(systemName: "person.circle")</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">}</p>
			<p>The differences in the preceding code are subtle, but one of them is very important: our subclass is now of the <strong class="source-inline">UICollectionViewCell</strong> type (as opposed to <strong class="source-inline">UITableViewCell</strong>), and we've also added in a couple of extra outlets, as we'll be adding a touch more data.</p>
			<p>For something different, we are going to create a scrolling horizontal list of our contacts and a grid <a id="_idIndexMarker151"/>layout. Let's head on over back to the interface builder and modify our canvas a little.</p>
			<p>We'll start by adding another text field. Notice from the following figure how I can adjust the size of my cell too:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_3.10_B14717.jpg" alt="Figure 3.10 – Collection view cell&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Collection view cell</p>
			<p>We can do this in a couple of places. If we highlight <strong class="bold">Collection View</strong> and select the Size Inspector, we can do it in there:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_3.11_B14717.jpg" alt="Figure 3.11 – Collection View Size Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Collection View Size Inspector</p>
			<p>Alternatively, we can do this directly on the cell itself, as shown in the following screenshot, again by selecting the Size Inspector:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_3.12_B14717.jpg" alt="Figure 3.12 – Collection View Cell Size Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Collection View Cell Size Inspector</p>
			<p>This is great for <a id="_idIndexMarker152"/>two reasons. First, you can set the size of your cell visually, which is always a nice and convenient way to do things. Secondly, even if you are going to override your cell size programmatically (due to you requiring a more dynamic approach), it allows you to visualize and set your constraints so that you know what you have to play with. I'm just going to set mine to 150 width x 230 height, for now, which should give us enough to play with.</p>
			<p>So, let's carry on with setting up our interface. Again, we'll need to override <strong class="bold">Class</strong> with our custom class:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_3.13_B14717.jpg" alt="Figure 3.13 – Collection View class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">  </p>
			<p class="figure-caption">Figure 3.13 – Collection View class</p>
			<p>Then, we need to assign our cell identifier:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_3.14_B14717.jpg" alt="Figure 3.14 – Collection View cell identifier&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Collection View cell identifier</p>
			<p>Then, we set <strong class="bold">Estimated Height</strong> to <strong class="bold">None</strong>. This stops our cell from dynamically resizing itself based on the size of the content within the cell (for example, a label with a really long name or address):</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_3.15_B14717.jpg" alt="Figure 3.15 – Collection View estimated cell size&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Collection View estimated cell size</p>
			<p>We're almost done – just a few more little things we need to add in. Notice anything missing from <a id="_idIndexMarker153"/>our <strong class="source-inline">viewDidLoad()</strong> function that we had in the <strong class="source-inline">UITabelView</strong> example?</p>
			<p>Yep, we've yet to set our delegate method to our <strong class="source-inline">ViewController</strong> object, but for this example, I'm going to show you another way that we can do that via Interface Build<a id="_idTextAnchor100"/><a id="_idTextAnchor101"/>er, as opposed to doing this programmatically.</p>
			<p>Highlight your <strong class="source-inline">CollectionView</strong> object, press and hold <em class="italic">Ctrl</em> on your keyboard, then primary click and hold your cursor – if you start to drag your cursor, you'll see a line (just like when we connect <strong class="source-inline">IBOutlet</strong>). Drag the line to the <strong class="source-inline">ViewController</strong> object and release. You'll then be presented with the following options:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_3.16_B14717.jpg" alt="Figure 3.16 – Collection View delegate outlet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Collection View delegate outlet</p>
			<p>Select <strong class="bold">dataSource</strong>, and then repeat the process and select <strong class="bold">delegate</strong>.</p>
			<p>That's it – other than a <a id="_idIndexMarker154"/>few minor changes here and there, we've successfully set up <strong class="source-inline">UICollectionView</strong> in pretty much the same way as we did for our <strong class="source-inline">UITableView</strong>. Let's go ahead now and run the project to see how it all looks:</p>
			<p class="figure-caption"><img src="image/Figure_3.17_B14717.png" alt="Figure 3.17 – Collection View layout&#13;&#10;"/></p>
			<p class="figure-caption">Figure 3.17 – Collection View layout</p>
			<p>That looks great – I mean, apart from the cells looking a little out of place – but don't worry, we're going to take a look at our options on how we can change that in the next part, by being introduced to the <strong class="source-inline">UICollectionViewDelegateFlowLayout</strong> protocol.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor102"/>Implementing layout with UICollectionViewDelegateFlowLayout</h2>
			<p>In the last section, we created our very first <strong class="source-inline">UICollectionView</strong> project based on everything we had <a id="_idIndexMarker155"/>learned from creating a <strong class="source-inline">UITableView</strong> project previously. One thing we did learn that was fundamentally different from a table view was that our cells can be laid out differently.</p>
			<p>So, how do we go about manipulating our cells to get them to do exactly what we want them to do? For that, we need to implement the <strong class="source-inline">UICollectionViewDelegateFlowLayout</strong> protocol – but what does this have to offer? Let's start by taking a look at one of the most commonly used delegate methods in this protocol and how easily it can transform our app.</p>
			<p>Over in our extension, add in the following highlighted protocol alongside the existing ones:</p>
			<p class="source-code">extension ViewController: UICollectionViewDelegate, UICollectionViewDataSource, <strong class="bold">UICollectionViewDelegateFlowLayout</strong></p>
			<p>Now, in good practice, you can separate each one of these protocols into its own extension – but as we are only dealing with a few delegates for each, we'll be fine to keep them in one place for now.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If your <strong class="source-inline">ViewController</strong> object starts to get a little large, you can move your extensions out into a separate file – this makes working on them easier and keeps your files nice and clean.</p>
			<p>Now, we're going to add in the following <strong class="source-inline">delegate</strong> method:</p>
			<p class="source-code">func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize { }</p>
			<p>The <strong class="source-inline">sizeForItem</strong> delegate simply allows us to programmatically set a size of our cell, so let's have a play with that and see what we can come up with. Add the following code to the preceding function:</p>
			<p class="source-code">let width = (collectionView.bounds.size.width / 2) – 10</p>
			<p class="source-code">return CGSize(width: width, height: 180)</p>
			<p>So, here, we're performing a nice simple calculation: we're taking the width of the current <a id="_idIndexMarker156"/>screen, dividing it by 2, and then subtracting 10 (for a little padding), and having that as our cell width. Finally, we'll add a nice static value for our height. Go ahead and run your app and see what it gives us:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_3.18_B14717.jpg" alt="Figure 3.18 – Collection View layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – Collection View layout</p>
			<p>Nice, let's look at what else we could do. How about simply returning the full size of the screen?</p>
			<p class="source-code">return collectionView.bounds.size</p>
			<p>Next, let's change the direction of the scroll direction; we can do this via Interface Builder by selecting <strong class="bold">Collection View</strong>. Change the value to <strong class="bold">Horizontal</strong>:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_3.19_B14717.jpg" alt="Figure 3.19 – Collection View Scroll Direction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – Collection View Scroll Direction</p>
			<p>Go <a id="_idIndexMarker157"/>ahead and run the app again – how does it look?</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_3.20_B14717.jpg" alt="Figure 3.20 – Collection View Scroll Direction layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – Collection View Scroll Direction layout</p>
			<p>Perfect – with only a small change, we've managed to make a massive difference to our app, clearly highlighting the power of <strong class="source-inline">UICollectionView</strong> compared to <strong class="source-inline">UITableView</strong>.</p>
			<p>Before <a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>we wrap up this section on <strong class="source-inline">UICollectionView</strong>, let's take a quick look at the other delegate methods offered to us <a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>by <strong class="source-inline">UICollectionViewDelegateFlowLayout</strong>.</p>
			<h3>Size of an item (cell)</h3>
			<p>When you <a id="_idIndexMarker158"/>need to manipulate the bounds or frame of an item, use<strong class="source-inline"> collectionView(_:layout:sizeForItemAt:</strong>, which asks the delegate for the size of the specified item's cell.</p>
			<h3>Section and spacing</h3>
			<p>The following are <a id="_idIndexMarker159"/>options to programmatically adjust the spacing between cell items and sections (excluding headers and footers):</p>
			<ul>
				<li><strong class="source-inline">collectionView(_:layout:insetForSectionAt:)</strong>: Asks the delegate for the margins to apply to content in the specified section</li>
				<li><strong class="source-inline">collectionView(_:layout:minimumLineSpacingForSectionAt:)</strong>: Asks the delegate for the spacing between successive rows or columns of a section</li>
				<li><strong class="source-inline">collectionView(_:layout:minimumInteritemSpacing ForSectionAt:)</strong>: Asks the delegate for the spacing between successive items in the rows or columns of a section</li>
			</ul>
			<h3>Footer and header sizing</h3>
			<p>The following are <a id="_idIndexMarker160"/>options to programmatically adjust the spacing between cell items specifically for headers and footers:</p>
			<ul>
				<li><strong class="source-inline">collectionView(_:layout:referenceSizeForHeaderInSection:)</strong>: Asks the delegate for the size of the header view in the specified section</li>
				<li><strong class="source-inline">collectionView(_:layout:referenceSizeForFooterInSection:)</strong>: Asks the delegate for the size of the footer view in the specified section</li>
			</ul>
			<p>In this section, we learned all about <strong class="source-inline">UICollectionView</strong> components – how to set them up in Xcode and the differences between them and <strong class="source-inline">UITableView</strong> components – and were able to see the benefits they give us along with the <strong class="source-inline">UICollectionViewDelegateFlowLayout</strong> protocol in order customize our apps more visually. In <a id="_idIndexMarker161"/>the next section, we're going to take a look a little deeper into some of the advancements in <strong class="source-inline">UITableView</strong>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor107"/>Exploring UICollectionView further </h1>
			<p>In this section, we'll again touch on some extra little bits that, just like with our table views, will allow us to <a id="_idIndexMarker162"/>really harness the power of a collection view – specifically when it comes to calculating the size of your layout. We'll start by taking a look at some overrides that we can make use of to achieve this.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor108"/>Implementing a custom UICollectionViewLayout</h2>
			<p>Implementing a <a id="_idIndexMarker163"/>large and complex feature such as a custom collection view layout might seem like a huge challenge for most people. </p>
			<p>Creating your layout involves calculating the position for every cell that your collection view will display. You must ensure that these calculations are performed as quickly and as efficiently as possible because your layout calculations directly influence the performance of your collection view. A poor layout implementation will lead to slow scrolling and a lousy user experience eventually. </p>
			<p>Luckily, the documentation that has been provided for creating a collection view layout is pretty good as a reference to figure out whether you're on the right track.</p>
			<p>If you take a look at Apple's documentation on <strong class="source-inline">UICollectionViewLayout</strong>, you can read about its role in a collection view. The available information shows that a custom layout requires you to handle the layout for cells, supplementary views, and decoration views. Supplementary views are also known as headers and footers.</p>
			<p>Let's take a look at how we could begin to implement that. We'll start by creating our own class to do the job:</p>
			<p class="source-code">class ContactsCollectionViewLayout: UICollectionViewLayout {</p>
			<p class="source-code">    </p>
			<p class="source-code">    override var collectionViewContentSize: CGSize {</p>
			<p class="source-code">        return .zero</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    override func prepare() {</p>
			<p class="source-code">        </p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool {</p>
			<p class="source-code">        return false</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {</p>
			<p class="source-code">        return nil</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? {</p>
			<p class="source-code">        return nil</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">}</p>
			<p>As you can see from the preceding code, here we've implemented a subclass of <strong class="source-inline">UICollectionViewLayout</strong> and have a variety of overridden functions that we can use – let's go through these now.</p>
			<h3>Implementing collectionViewContentSize</h3>
			<p>A collection view <a id="_idTextAnchor109"/><a id="_idTextAnchor110"/>uses the <strong class="source-inline">collectionViewContentSize</strong> property from its layout to figure out <a id="_idIndexMarker164"/>the size of its contents. This property is especially important because it is used to configure and display the scrolling indicators for the collection view. </p>
			<p>It also provides the collection view with information about the direction in which scrolling should be enabled.</p>
			<p>Implementing this property uses the number of rows and columns in the collection view. It also takes the item size and item spacing into account to come up with the size of all of its contents together.</p>
			<h3>Implementing layoutAttributesForElements(in:)</h3>
			<p>More <a id="_idIndexMarker165"/>complex than <strong class="source-inline">collectionViewContentSize</strong> is <strong class="source-inline">layoutAttributesForElements(in:)</strong>. This method is responsible for providing a collection view with the layout attributes for several elements at once. </p>
			<p>The collection view always provides a rectangle, for which it needs layout attributes. The layout is responsible for providing these attributes to the collection view as fast as possible. The implementation of this method must be as efficient as you can get it to be. Your scroll performance depends on it.</p>
			<p>Even though there is only a small number of cells visible at a time, the collection view has a lot more content outside of its current viewport. Sometimes it is asked to jump to a particular cell, or the user scrolls extremely fast. </p>
			<p>There are many cases where the collection view will ask for all layout attributes for several cells at once. When this happens, the layout object can help the cell determine which cells should be visible for a particular rectangle. This is possible because the layout attributes not only contain the rectangle in which a cell should be rendered but they also know the <strong class="source-inline">IndexPath</strong> object that corresponds with that specific cell.</p>
			<p>This is a pretty complicated matter, and it's okay if you find this to be a little bit confusing. As long as you understand that a collection view can ask its layout which cells are present <a id="_idIndexMarker166"/>in a certain <strong class="source-inline">CGRect</strong> instance and how they should be rendered, you understand what <strong class="source-inline">layoutAttributesForElements(in:)</strong> does.</p>
			<h3>Implementing layoutAttributesForItem(at:)</h3>
			<p>Another way that a collection view can request layout attributes for its layout is by requesting the <a id="_idIndexMarker167"/>attributes for a single item. Because the collection view does so by supplying an index path, this method is quite simple to implement. </p>
			<p>The layout you implemented assumes that only a single section exists in the collection view and the layout attributes array is sorted by index path because that's the order in which all items were inserted into the array.</p>
			<h3>Implementing shouldInvalidateLayout(forBoundsChange:)</h3>
			<p>Getting the <a id="_idIndexMarker168"/>implementation for <strong class="source-inline">shouldInvalidateLayout(forBoundsChange:)</strong>  is crucial to having a great collection <a id="_idIndexMarker169"/>view layout that has amazing performance.  </p>
			<p>If you implement this method incorrectly, you could constantly be invalidating the layout, meaning you will need to recalculate all the time. </p>
			<p>It's also possible that the collection view will never update its layout at all, even when it should. The collection view will call this method any time its size changes. For instance, when the user rotates their device or when your app runs on an iPad, the user opens another app in multitasking mode.</p>
			<h3>Assigning a custom layout to your collection view</h3>
			<p>The final step to <a id="_idIndexMarker170"/>using your custom layout is telling your collection view to use your layout. You have already seen that you can assign a custom class to the layout for a collection view in Interface Builder. </p>
			<p>However, this only works when your layout inherits from <strong class="source-inline">UICollectionViewFlowLayout</strong>, which your layout does not inherit from. Luckily, you can also set your collection view's layout in code. Update your <strong class="source-inline">viewDidLoad</strong> method in <strong class="source-inline">ViewController.swift</strong> by adding the following line to it:</p>
			<p class="source-code">collectionView.collectionViewLayout = ContactsCollectionViewLayout()</p>
			<p>This line sets your new layout as the current layout. You can now remove the <strong class="source-inline">UICollectionViewDelegateFlowLayout</strong> extension from <strong class="source-inline">ViewC<a id="_idTextAnchor111"/>ontroller.swift</strong> as it is not needed anymore.</p>
			<p>Now <a id="_idIndexMarker171"/>that we've looked at layouts in more detail, let's take a look at how we handle user interaction with cell selection.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor112"/>Cell selection in collection views</h2>
			<p>Although almost <a id="_idIndexMarker172"/>identical to its <strong class="source-inline">UITableView</strong> counterpart, I thought it was worth calling this function out:</p>
			<p class="source-code">func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)</p>
			<p>With again the only real difference being that <strong class="source-inline">Row</strong> is replaced with <strong class="source-inline">Item</strong>, this delegate method performs in the exact same way.</p>
			<p>We can make use of the reuse identifier and work with our cell directly should we need to manipulate it in any way (see <a href="B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 5</em></a>, <em class="italic">Immersing Your Users with Animation</em>, for some exciting things we can do here).</p>
			<p>In this section, we delved into the inner workings of the <strong class="source-inline">UICollectionView</strong> layout options and explored further how we can use <strong class="source-inline">UICollectionViewLayout</strong> to subclass our own layout, allowing us, the developer, to utilize specific and complex calculations should we need too. In our next and final section, we'll take a look at how Apple's new powerful UI framework, SwiftUI, handles lists.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor113"/>Working with lists in SwiftUI</h1>
			<p>Back at WWDC 2019, Apple unveiled to the world a brand-new UI framework called SwiftUI. Built <a id="_idIndexMarker173"/>from the ground up, SwiftUI is a powerful alternative to UIKit and AppKit, offering developers the ability to write code using declarative syntax.</p>
			<p>In this section, we are going to cover what SwiftUI has to offer in terms of generating lists and what we may need to do going forward should we require the use of anything that isn't available to use just yet.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor114"/>Creating our first SwiftUI project</h2>
			<p>For this, we're <a id="_idIndexMarker174"/>going to need to create a new single view app, the same as before, but only this time we'll need to select <strong class="bold">SwiftUI</strong> for our user interface, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_3.21_B14717.jpg" alt="Figure 3.21 – New SwiftUI project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – New SwiftUI project</p>
			<p>If you're unfamiliar with SwiftUI, you'll notice a couple of differences. You'll no longer have a <strong class="source-inline">ViewController.swift</strong> file – this has been replaced with <strong class="source-inline">ContentView.swift</strong>.</p>
			<p>Highlight the file to take a look at the contents; you should see the following boilerplate code:</p>
			<p class="source-code">import SwiftUI</p>
			<p class="source-code">struct ContentView: View {</p>
			<p class="source-code">    var body: so<a id="_idTextAnchor115"/><a id="_idTextAnchor116"/>me View {</p>
			<p class="source-code">        Text("Hello, World!")</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">struct ContentView_Previews: PreviewProvider {</p>
			<p class="source-code">    static var previews: some View {</p>
			<p class="source-code">        ContentView()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>First, let's take a look at the <strong class="source-inline">ContentView</strong> struct – this is the first step of how SwiftUI builds up its declarative interface. Inside the <strong class="source-inline">ContentView</strong> struct is the body. Notice how these conform to either <strong class="source-inline">View</strong> or <strong class="source-inline">some View</strong> – that's because the concept of <strong class="source-inline">ViewController</strong> components in SwiftUI is no longer used; everything is a view being returned to the window.</p>
			<p>But without <a id="_idIndexMarker175"/>getting too involved in the workings of SwiftUI, all we care about now is the contents of the body declaration. So, in the case of the preceding example, all we care about is the following:</p>
			<p class="source-code">Text("Hello, World!")</p>
			<p><strong class="source-inline">Text</strong> is SwiftUI's equivalent to <strong class="source-inline">UILabel</strong> – pretty neat, right, how a simple one line of code can construct, instantiate, and accept a value to display? Oh, and no need to add it to the view either – the fact that this line of code is present is enough. </p>
			<p>Another benefit to using SwiftUI is the ability to preview code changes on the fly. If you take a look in Xcode to the right of our opened <strong class="source-inline">ContentView.swift</strong> file, you'll see the preview assistant. Click <strong class="bold">Resume</strong> at the top left and we should see a preview of our app appear:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_3.22_B14717.jpg" alt="Figure 3.22 – SwiftUI &quot;Hello, World!&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – SwiftUI "Hello, World!"</p>
			<p>Now, let's take a look at how we would add in a list of items.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor117"/>Building a list in SwiftUI</h2>
			<p>We'll start <a id="_idIndexMarker176"/>simple, by just adding our already-existing label to a list. Make the following highlighted code change, and if required, press resume in the preview assistant window:</p>
			<p class="source-code">var body: some View {</p>
			<p class="source-code">    List {</p>
			<p class="source-code">        Text("Hello, World!")</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>That's right, it really is as simple as that. Go on and add a couple more <strong class="source-inline">Text</strong> views and see how it looks – even try running this in your simulator to see how it looks:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_3.23_B14717.jpg" alt="Figure 3.23 – SwiftUI list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – SwiftUI list</p>
			<p>Nice and simple, but much like we did with our <strong class="source-inline">UITableView</strong> components and <strong class="source-inline">UICollectionView</strong> components, let's see how we could go about adding in some external data.</p>
			<p>Make the <a id="_idIndexMarker177"/>following highlighted change to our code in <strong class="source-inline">ContentView.swift</strong>:</p>
			<p class="source-code"><strong class="bold">@State var contacts: [String] = [String]()</strong></p>
			<p class="source-code">   </p>
			<p class="source-code">var body: some View {</p>
			<p class="source-code">    <strong class="bold">List {	</strong></p>
			<p class="source-code"><strong class="bold">    ForEach(contacts, id: \.self) { contact in</strong></p>
			<p class="source-code"><strong class="bold">        	Text(contact)</strong></p>
			<p class="source-code"><strong class="bold">    	    }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>Here, we've added in a <strong class="source-inline">ForEach</strong> function to our list; this is going to iterate around our array of contacts that we created just outside our body.</p>
			<p>But if we press resume, you'll see that we get no data…let's fix this. Take a look just below the <strong class="source-inline">ContentView</strong> struct and you'll see the following code:</p>
			<p class="source-code">struct ContentView_Previews: PreviewProvider {</p>
			<p class="source-code">    static var previews: some View {</p>
			<p class="source-code">        ContentView()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This struct is how our preview assistance can display our app – our own little internal testing/playground while <a id="_idIndexMarker178"/>we develop our SwiftUI view – without even needing to run the simulator.</p>
			<p>Let's add some code in then to inject a little mock data into our preview. Make the following highlighted changes:</p>
			<p class="source-code">struct ContentView_Previews: PreviewProvider {</p>
			<p class="source-code">    static var previews: some View {</p>
			<p class="source-code"><strong class="bold">        let mockData = ["Chris", "Andy", "Harry", "Nathan", "Sam"]</strong></p>
			<p class="source-code"><strong class="bold">        return ContentView(contacts: mockData)</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We simply just create some mock data that we can inject straight into our view, if not already updated. Click <strong class="bold">Resume</strong> on the preview assistant and see your code in action – however, if you run this in the simulator, you won't see anything, as the preview is no longer in effect and the app you see is your actual app (which we haven't added any data to yet).</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor118"/>The equivalent to creating a custom cell in SwiftUI</h2>
			<p>It's hard trying not to <a id="_idIndexMarker179"/>make a direct comparison to UIKit objects when developing with SwiftUI – but we'll all do it and it's okay, because usually there is a way to perform a similar action or a new way to learn.</p>
			<p>Going back to the beginning of this section, I mentioned that SwiftUI is all about views, and that's no different when implementing a custom "cell" for a list in SwiftUI. We'll start by creating a new view (we'll do this inside of your <strong class="source-inline">ContentView.swift</strong> file, but outside of the initial class declaration):</p>
			<p class="source-code">struct RowView: View {</p>
			<p class="source-code">    </p>
			<p class="source-code">    @State var name: String</p>
			<p class="source-code">    </p>
			<p class="source-code">    var body: some View {</p>
			<p class="source-code">        Text(name)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">}</p>
			<p>Just like <strong class="source-inline">ContentView</strong>, our new <strong class="source-inline">RowView</strong> is a simple view being created that can be used anywhere within SwiftUI. The structs can accept a <strong class="source-inline">name: String</strong> variable and will display this within a <strong class="source-inline">Text</strong> view – just like we did inside <strong class="source-inline">ContentView</strong>.</p>
			<p>Now, let's amend our code to make use of this. Make the following highlighted changes:</p>
			<p class="source-code">List {</p>
			<p class="source-code">    ForEach(contacts, id: \.self) { contact in</p>
			<p class="source-code"><strong class="bold">        RowView(name: contact)</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>It really is a simple as that; we can now treat <strong class="source-inline">RowView</strong> as we did collection view or table view cells and decorate them or work on them independently to their parent lists. </p>
			<p>You can even create your own preview provider just for <strong class="source-inline">RowView</strong> so that you can again inject mock data whilst developing.</p>
			<p>In this section, we were introduced to SwiftUI as a framework and took a look at the basic building blocks <a id="_idIndexMarker180"/>needed to create a project. From this, we learned about how lists are used and how we can use the preview assistant to our advantage when developing Swift<a id="_idTextAnchor119"/>UI interfaces.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor120"/>Summary</h1>
			<p>In this chapter, we looked at everything to do with lists. We started by learning how to create a <strong class="source-inline">UITableView</strong> object – pulling in contacts from our device and displaying them in the way we want. We then moved on to <strong class="source-inline">UICollectionView</strong>, comparing it against our previous implementation and looking at some of the subtle and larger differences it had to offer – such as cell layout and manipulation.</p>
			<p>We then delved a little deeper into each of these, specifically looking at layouts with <strong class="source-inline">UICollectionView</strong> components, which is one of its most powerful features.</p>
			<p>We then finished off by taking a look at the SwiftUI framework and how Apple has made it so easy not only to develop but also to display data in different ways that we have been used to previously with the ease of the declarative syntax and the use of the preview assistant.</p>
			<p>In the next chapter, we'll be looking at taking our lists a step further and creating a details page for them to navigate to with the use of the cell interaction that we covered in this chapter.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor121"/>Further reading</h1>
			<ul>
				<li>Apple Developer documentation on table views:<p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/table_views">https://developer.apple.com/documentation/uikit/views_and_controls/table_views</a></p></li>
				<li>Apple Developer documentation on collection views:<p><a href="https://developer.apple.com/documentation/uikit/views_and_controls/collection_views">https://developer.apple.com/documentation/uikit/views_and_controls/collection_views</a></p></li>
				<li><em class="italic">Learn SwiftUI</em> (Packt Publishing): <p><a href="https://www.packtpub.com/business-other/learn-swiftui">https://www.packtpub.com/business-other/learn-swiftui</a></p></li>
			</ul>
		</div>
	</body></html>