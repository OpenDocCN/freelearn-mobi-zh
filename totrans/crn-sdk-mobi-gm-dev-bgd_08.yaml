- en: Chapter 8. Operation Storyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've taken our game Egg Drop and explored ways to create game physics to react
    with collision detection and tracking other useful data such as lives and a points
    system. We also worked with customizing physical bodies and creating names for
    our display objects that apply to the game score count.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we'll be adding a menu system that incorporates an introduction to the
    game and also applying a pause menu during gameplay and saving high scores when
    the game is over.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We're on our way to completing an application that has the necessary elements
    that will be ready for the App Store or Google Play Store.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving high scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a pause menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing scenes with Storyboard API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a loading screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a main menu and options menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's keep on going!
  prefs: []
  type: TYPE_NORMAL
- en: Continuation of Egg Drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finished the main game portion of Egg Drop as the base of our application.
    Now it's time for us to include how to pause action mid-game and also how to save
    high scores. We're also going to add some new scenes that will help us introduce
    and transition to the game in an easy and quick fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the Chapter 8 `Resources` folder, grab all the image and file assets inside
    and copy them to your current `Egg Drop` project folder. You can download the
    project files accompanying this book from the Packt website. We'll be using these
    files to add the final touches to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Data saving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving file information is used in many aspects of game development. We use
    it to save high scores, game settings such as sound on/off, locking/unlocking
    levels, and so on. They're not necessary to have, but good to have if you'd like
    to have those features included in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In Corona SDK, applications are sandboxed, meaning that your files (application
    images, data, and preferences) are stored in a location that no other application
    can access. Your files will reside in an app-specific directory for documents,
    resources, or temporary files. This restriction is related to the files on your
    device, not when you are coding on your Mac or PC.
  prefs: []
  type: TYPE_NORMAL
- en: BeebeGames Class for saving and loading values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be using BeebeGames Class, created by Jonathan Beebe. It provides many
    easy and useful functions to use for games. Some of the notable functions included
    incorporate a simple way of saving and loading data that we''ll be able add into
    our game. More information on BeebeGames Class can be found at: [http://developer.anscamobile.com/code/beebegames-class](http://developer.anscamobile.com/code/beebegames-class).
    You can download the file from the link and take a look at other methods relating
    to animation, transitions, timers, and so on, incase you would like to use them
    for future use. For now, we''ll be focusing on the methods for easy saving and
    loading values for our game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of saving and loading values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting paths to files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The paths to these files are unique to your application. To create file paths,
    you use the `system.pathForFile` function. The following generates an absolute
    path to the icon file for your application using the application's resource directory
    as the base directory for `Icon.png:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, your files must reside in one of three possible base directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system.DocumentsDirectory` should be used for files that need to persist between
    application sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system.TemporaryDirectory` is a temporary directory. Files written to this
    directory are not guaranteed to exist in subsequent application sessions. They
    may or may not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system.ResourceDirectory` is the directory where all application assets exist.
    Note that you should never create, modify, or add files to this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information on files can be found at: [http://developer.anscamobile.com/content/files](http://developer.anscamobile.com/content/files).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read files, the `io` library is used. This library allows you to open files
    given an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: Writing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write files, you follow many of the same steps as reading a file. Instead
    of using a read method, you write data (strings or numbers) to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—saving and loading the high score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the **Game Over** screen displays, we're going to save and load the values
    of our final score and highest score.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `main.lua` file that we created for Egg Drop. We'll continue using
    the same file and add in more code with the new alterations to the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add in two new variables, `local highScoreText` and `local highScore` where
    all the other initialised variables are located near the top of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Introduce the `saveValue()` function after the pre-loaded sound files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the `loadValue()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the end of the `callGameOver()` function, create an `if` statement to compare
    the `gameScore` and `highScore`. Save the highest score using the `saveValue()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add in the `highScoreText` display text in the same `callGameOver()` function
    to show the high score at the end of the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the end of the `gameStart()` function, have the high score loaded using the
    `loadValue()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—saving and loading the high score](img/1888_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After initializing the `saveValue()` and `loadValue()` functions in the game
    level, we created an `if` statement to compare the `gameScore`, which is the current
    score during gameplay and the `highScore`, which is the highest score accrued
    so far. When the outcome of `gameScore` is higher, then it replaces the `highScore`
    data saved.
  prefs: []
  type: TYPE_NORMAL
- en: In order to save the value, a data file needs to be created. We created a variable
    called `local highScoreFilename = "highscore.data"`. We called the `saveValue()`
    function using `highScoreFilename` as a parameter. `tostring(highScore)` will
    be converted to a string.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Game Over** screen is visible, `highScoreText` displays the value
    saved from `highScore` above the `gameScore` that is achieved. Adding a high score
    gives the player an incentive to top the highest score and to add the replay value
    to the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the `gameStart()` function, it's important to have the value of `highScore.data`
    loaded at the start of gameplay. By using the same data file we created to save
    `highScore`, we can also use it to load the value throughout the game. To load
    the value, `local highScore` calls `loadValue(highScoreFileName)`. This takes
    the information from `highScore.data`. To obtain the value, `tonumber(loadedHighScore)`
    converts it to an integer from a string and can be used to display the value of
    `highScore`.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever found yourself in the middle of playing a game and all of sudden
    you have to take a bathroom break or your hand cramps up? Obviously, any of those
    situations require you to avert your attention from your game progress and you
    need to stop the current action temporarily to attend to those needs. This is
    when a pause button comes in handy so you can stop the action in that moment in
    time and continue where you left off when you're ready to play again.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's more than just making a button, it's also pausing all the action onscreen,
    including physics and timers.
  prefs: []
  type: TYPE_NORMAL
- en: Add in the variables `local pauseBtn` and `local pauseBG` where all the other
    variables are initialized near the beginning of the code. Preload the `btnSound`
    audio after `gameOverSound` near the top of the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the `hud()` function and after the `scoreText` chunk, create another
    function that will run the event for the pause button. Call the function `onPauseTouch(event)`.
    Pause the physics in the game by setting `gameIsActive` to `false` and have the
    pause elements appear on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the game is unpaused, have the physics become active again and remove all
    pause display objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `pauseBtn` UI button and `pauseBG` display object after the `onPauseTouch()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order for `pauseBtn` to display during gameplay, make it visible and active
    in the `gameActivate()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the game is over, disable `pauseBtn` in the `callGameOver()` function.
    Place the code right after the `physics.pause()` line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—pausing the game](img/1888_08_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the `onPauseTouch(event)` function to control all pause events that
    occur within gameplay. To pause all the motion in game, we changed the boolean
    of `gameIsActive` to `false` and `physics.pause()` to stop all the eggs that are
    falling from moving. Next, the timer is paused for `startDrop` so any eggs falling
    from the sky won't accumulate over time as long as the pause function is still
    active.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly transparent overlay called `shade` is called to appear when the pause
    button is pressed. This will avert the attention of the user from the game scene
    and allow the user to differentiate when the gameplay is not active.
  prefs: []
  type: TYPE_NORMAL
- en: The **Game Paused** banner also displays on top of the screen by making it visible
    and active. `pauseBG` is pushed ahead of the display hierarchy by `pauseBG:toFront()`.
  prefs: []
  type: TYPE_NORMAL
- en: To unpause, we reversed the process of how the pause display items appear. When
    `pauseBtn` is pressed for the second time, `shade` is taken away by `display.remove(shade);
    shade = nil. pauseBG.isVisible` and `pauseBG.isActive` are both set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember when we set `gameIsActive` to `false?` Well, it's time to set it back
    to `true`. This also means resuming physics with `physics.start()`. The timer
    is resumed by local function `resumeGame()` and calls `timer.resume(startDrop)`
    within the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `pauseBtn` and `pauseBG` display objects are inserted at the end of the
    `if` statement block. `pauseBtn` is then shown as visible and active once the
    game is playable. It is invisible and inactive when the **Game Over** screen appears.
    This is because there are no other touch events that interfere when the game is
    over.
  prefs: []
  type: TYPE_NORMAL
- en: Storyboard API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Storyboard API provides an easy solution for developers to control scenes
    with or without transitions. This is a great scene-management library for displaying
    menu systems and even managing multiple levels in a game. Storyboard also comes
    with a variety of transition effects. A listing of them can be found on the `storyboard.gotoScene()`
    API reference page at: [http://developer.anscamobile.com/reference/index/storyboardgotoscene](http://developer.anscamobile.com/reference/index/storyboardgotoscene).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on the Storyboard API can be found on the *Anscamobile* website
    at: [http://developer.anscamobile.com/content/storyboard](http://developer.anscamobile.com/content/storyboard).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our scene management will look similar to the scene template displayed at:
    [http://developer.anscamobile.com/reference/index/scene-template](http://developer.anscamobile.com/reference/index/scene-template).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also download the *Storyboard Sample Code* from [https://github.com/ansca/Storyboard-Sample](http://https://github.com/ansca/Storyboard-Sample)
    and run the project file in the Corona simulator to get familiar with how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Game development with Storyboard API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder how we're going to apply Storyboard with Egg Drop. It's really
    simple actually. We'll have to alter some lines in our game code to make it compatible
    with Storyboard and create some new scenes for the menu system that is applied
    before gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—altering the game file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to rename our current `main.lua` file to `maingame.lua` and put
    some additional lines into our game code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to change the filename within your Egg Drop project folder.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the following lines near the top of the code. We'll hide the status bar
    in another scene that we'll create later on in this chapter. The `gameGroup` display
    group will be altered to fit within the Storyboard parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the very top of the code, implement Storyboard by adding `local storyboard
    = require( "storyboard" )` and `local scene = storyboard.newScene()` so we can
    call scene events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After `local loadValue = function( strFilename )`, add in the `createScene()`
    event. We will also add back in our `gameGroup` display group, but under the scene's
    view property. Also, add `in storyboard.removeScene( "loadgame" )`. The`"loadgame"`
    scene will be introduced later on in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `createScene()` event, create the `enterScene()` event and add it
    before the `gameActivate()` function. `enterScene()` will transition all our gameplay
    functions onscreen. Include `gameGroup` in the scene's view property as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `gameStart()` function, remove the `return gameGroup` line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, close `function scene: enterScene( event )` with `end`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `exitScene()` and `destroyScene()` events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, create event listeners for all the scene events and add `return scene`
    at the end of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Storyboard API will help us transition scenes a lot easily and quickly.
    Every time you want to load a new scene into view, `require("storyboard")` needs
    to be added. `local scene = storyboard.newScene()` will allow us to call the scene
    events: `createScene(), enterScene(), exitScene()`, and `destroyScene()`.'
  prefs: []
  type: TYPE_NORMAL
- en: At the very end of the game code, we added event listeners to all the scene
    events and `return scene`.
  prefs: []
  type: TYPE_NORMAL
- en: The format for how each scene is managed with Storyboard will look similar to
    the preceding code. Most of the game code will be dispatched during a scene is
    displayed by the `createScene()` and `enterScene()` events. When you want to clean
    or unload listeners, audio, assets, and so on, the `exitScene()` and `destroyScene()`
    events are used.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been used to having the `main.lua` as our main source file to show every
    detail of our game code. It's time to organize it efficiently with the help of
    Storyboard API.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding the new main.lua file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using Storyboard, our `main.lua` file is still vital since it is the first
    thing that Corona SDK looks at to launch an application in the simulator. We're
    going add some lines of code that will change scenes for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Create a brand new file called `main.lua` and let's add back in our status bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Import Storyboard and load the first scene called `loadmainmenu`. We will create
    this scene in the next couple of sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to incorporate Storyboard throughout the application, we called the
    `local storyboard = require ( "storyboard" )` module. The scene will be changed
    with `storyboard.gotoScene( "loadmainmenu" )`, which is a loading screen directing
    the user to the main menu screen.
  prefs: []
  type: TYPE_NORMAL
- en: New game transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have introduced Storyboard API, we can apply some long-awaited transitions
    that will be helpful to our game. One way to approach this is by transitioning
    out of the game once it is over.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—changing screens after the game is over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have renamed our game file, let's add in a scene transition so that
    our game is not stuck on the **Game Over** screen once gameplay is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `maingame.lua` file, add in a new variable called `local menuBtn` where
    all the other variables are initialized in the beginning of the code. Inside the
    `callGameOver()` function, add the following lines after the `highScoreText` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action—changing screens after the game is over](img/1888_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to transition out of the **Game Over** screen, a menu button was created
    to change scenes. Inside the `onMenuTouch()` function, upon`"release"` of the
    button, we called `storyboard.gotoScene( "mainmenu", "fade", 500 )`. This will
    allow the application to transition to the main menu, which we will create later
    on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—restarting the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you're well aware of how Storyboard API works with changing scenes
    and using UI buttons to transition between them, how about creating a button that
    restarts the game after the **Game Over** screen appears. So far, the application
    allows the user to go back to the menu screen once the game has reached an end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `callGameOver()` function, a new local function needs to be created
    that will run an event using the UI button system to change scenes with Storyboard.
    Hint: You can''t call the same scene over if you''re currently in it.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a loading screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading screens provide feedback that the program is in the process of loading.
    This is helpful by informing the user that the next screen is underway so they
    don't assume the application crashed, especially if the next screen is loading
    a large amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding the loading screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be placing loading screens when the application launches and before the
    game level starts. This tells the user that more content or information is on
    its way.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `loadmainmenu.lua` in your project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import Storyboard and add in the `storyboard.newScene()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create two local variables called `myTimer` and `loadingImage`. Add in the `createScene()`
    event and a `screenGroup` display group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `enterScene()` event and add in a `screenGroup` display group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Introduce the `loadingImage` display object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create another local function called `goToMenu()` and call `storyboard.gotoScene(
    "mainmenu", "zoomOutInFadeRotate", 500 )` to change the scene to`"mainmenu"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the timer function and have it call `goToMenu()` in 1000 milliseconds once.
    Define it with the timerID, `myTimer`. Close the `enterScene()` event with `end.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Call the `exitScene()` and the `destroyScene()` events. In the `exitScene()`
    event, cancel `myTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add event listeners for all the scene events and `return scene`. Save and close
    the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new file called `loadgame.lua` in your project folder. We'll be making
    another loading screen that occurs right before the game scene, `maingame.lua`.
    Use `storyboard.gotoScene( "maingame", "flipFadeOutIn", 500 )` to transition scenes.
    Save and close your file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—adding the loading screen](img/1888_08_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `loadmainmenu.lua` file, once `loadingImage` is added to the screen,
    we created the `goToMenu()` function to change scenes to`"mainmenu"` and use the
    transition`" zoomOutInFadeRotate"` that zooms out and rotates the loading screen
    image as it fades to the background. `myTimer = timer.performWithDelay( 1000,
    goToMenu, 1 )` performs the function in 1000 milliseconds (one second) and runs
    it once. This is long enough to view the image and have it fade out.
  prefs: []
  type: TYPE_NORMAL
- en: All display objects enter the scene by `function scene:enterScene( event ).
    loadingImage` is placed in `screenGroup`. To make sure we have no timers running
    after the scene change, `myTimer` stops running with the use of `timer.cancel(myTimer)`
    under `function scene:exitScene()`.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `loadgame.lua` is similar to `loadmainmenu.lua`. For this file,
    Storyboard transitions scenes to `maingame.lua`, the gameplay file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a main menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A main menu or title screen is one of the first impressions a player sees before
    playing the game. It usually shows small snippets of images or scenery that correlate
    with the actual game and also displays the title of the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are buttons such as **Start** or **Play** that urge the player to go into
    the game if they choose to and some secondary buttons such as **Options** to view
    settings and other information that may be included in relation to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding a main menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to create the frontend of our game by introducing the game title,
    **Play** button, and **Options** button that will transition throughout different
    scenes in the application with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `mainmenu.lua` and import Storyboard and UI modules,
    the `storyboard.newScene()` function, and the variables for timer and audio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `createScene()` event. Add in the line, `storyboard.removeScene(
    "maingame" )` and `storyboard.removeScene( "options" )`, which will remove the`"maingame"
    and "options"` scene. Removing`"maingame"` will occur after the player has transitioned
    from the main game screen and is sent to the main menu screen. Removing`"options"`
    will occur after the player has transitioned from the options screen and is sent
    to the main menu screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the `enterScene()` event and the `backgroundImage` display object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Introduce the `playBtn` display object and create a function called `onPlayTouch(event)`
    that uses `storyboard.gotoScene()` to change the scene to`"loadgame"`. Use the`"fade"`
    effect to change scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Transition the `playBtn` display object to `y = 260` in 500 milliseconds using
    the `easing.inOutExpo` transition. Have it initialized through `btnAnim`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Introduce the `optBtn` display object and create a function called `onOptionsTouch(event)`.
    Use `storyboard.gotoScene()` to transition the scene to`"options"` using the`"crossFade"`
    effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Transition the `optBtn` display object to `y = 280` in 500 milliseconds using
    the `easing.inOutExpo` transition. Have it initialized through `btnAnim`. Close
    the `scene:enterScene( event )` function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `exitScene()` event and cancel the `btnAnim` transition. Also, create
    the `destroyScene()` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the event listeners for all the scene events and `return scene`. Save and
    close your file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—adding a main menu](img/1888_08_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the main menu screen, we added an image that displays the game title, a **Play**
    button, and an **Options** button. The **Options** button is still not functional
    at this time. The `onPlayTouch()` function transitions the scene to`"loadgame"`.
    This will change scenes to `loadgame.lua`. The **Play** button is placed at x
    = 240; y = 440, (middle and offscreen). When the scene loads, `playBtn` transitions
    to y = 260 so it pops up from the bottom of the screen in 500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The **Options** button does a similar thing. `optBtn` is placed towards the
    right side of the stage and pops up at y = 280 in 500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `btnAnim` transition is cancelled by `transition.cancel( btnAnim )` through
    the `scene:exitScene()` function. Cleaning timers, transitions, and event listeners
    is important to do every time you change scenes so potential memory leaks do not
    occur while in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an options menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An options menu allows users to change various settings in the game or include
    other information that can't be displayed in the main menu. Games can vary from
    having many options to only having a few. Sometimes an options menu can be called
    a settings menu, which offers the same type of customization to the player's experience.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding an options menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be adding an options menu that can be accessed through the main menu.
    We're going to add a new UI button called **Credits**, which will direct the user
    to the credits screen once it is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `options.lua` and import Storyboard and UI modules,
    the `storyboard.newScene()` function, and the variables for timer and audio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `createScene()` event. Add in, `storyboard.removeScene ( "mainmenu"
    )`, which will remove the`"mainmenu"` scene. This will occur after the player
    has transitioned from the main menu screen and is sent to the options screen.
    Next, add in `storyboard.removeScene( "creditsScreen" )`. This will remove the`"creditsScreen"`
    after the player has transitioned from the credits screen back to the options
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the `enterScene()` event and the `backgroundImage` display object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a button for the credits screen. Transition the `creditsBtn` display
    object to y = 260 in 500 milliseconds using the `easing.inOutExpo` transition.
    Have it initialized through `btnAnim`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the **Close** button that loads the main menu. Close the `scene:enterScene
    ( event )` with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `exitScene()` event and cancel the `btnAnim` transition. Also, create
    the `destroyScene()` event. Add the event listeners to all the scene events and
    `return scene`. Save and close your file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—adding an options menu](img/1888_08_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scene, `creditsBtn` will operate in a similar fashion like how our main
    menu was created. The **Credits** button is still not functional at this time.
    In the `onCreditsTouch()` function, the scene is transitioned to`"creditsScreen"`
    and uses`"crossFade"` as the effect. From the offscreen position, `creditsBtn`
    transitions to y=260 in 500 milliseconds when the scene is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: A **Close** button is created for this scene so the user will have a way to
    go back to the previous screen. With the `onCloseTouch()` function, Storyboard
    changes the scene to`"mainmenu"` upon`"release"` of `closeBtn`. The main menu
    screen will display upon pressing the **Close** button. The `btnAnim` transition
    is cancelled through the `scene:exitScene()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a credits screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A credits screen usually shows and lists all the people involved in the production
    of the game. It can include other information in the form of thanking certain
    individuals and programs used to create the final project.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding a credits screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The credits screen we'll be creating will be based on a touch event that transitions
    to the previous screen from which it was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file call `creditsScreen.lua` and import Storyboard, the `storyboard.newScene()`
    function, and the `backgroundImage` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `createScene()` event. Add in the line, `storyboard.removeScene (
    "options" )`, which will remove the`"options"` scene. This will occur after the
    player has transitioned from the options screen and is sent to the credits screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the `enterScene()` event and `backgroundImage` display object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a local function called `changeToOptions()` with an event parameter.
    Have the function change the scene with Storyboard back to the options screen
    using a touch event on `backgroundImage`. Close the `scene:enterScene( event )`
    function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `exitScene()` and `destroyScene()` events. Add the event listeners
    to all the scene events and `return scene`. Save and close your file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action—adding a credits screen](img/1888_08_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The credits screen works with an event listener. The `changeToOptions(event)`
    function will tell Storyboard to change the scene to`"options"` using `storyboard.gotoScene
    ( "options", "crossFade", 500 )`. At the end of the function, `backgroundImage`
    will activate the event listener when the screen is touched. `backgroundImage`
    is inserted into the `screenGroup` under the `scene:enterScene( event )` function.
    Egg Drop is now fully operable using Storyboard. Run the game in the simulator.
    You'll be able to transition to all the scenes we have created in this chapter
    as well as play the game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—adding more levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that Egg Drop is completed and has a working menu system, challenge yourself
    by creating more levels. Minor alterations will have to be added to incorporate
    some placement for additional levels. Remember to apply Storyboard when changing
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try creating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Level select screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level number buttons to add additional levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating new levels, refer to the format as shown in `maingame.lua`. New
    levels can be altered by changing the interval of how fast the egg falls from
    the sky or maybe adding other game assets that fall but have to be avoided so
    there is no penalty during gameplay. There are so many possibilities on adding
    your own spin with this game framework. Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz—game transitions and scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which function do you call to change scenes with Storyboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `storyboard()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `storyboard.gotoScene()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `storyboard(changeScene)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Which function converts any argument into a number?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `tonumber()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `print()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `tostring()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. nil
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you pause a timer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `timer.cancel()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `physics.pause()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `timer.pause( timerID )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you resume a timer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `resume()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `timer.resume( timerID )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `timer.performWithDelay()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We have a game that is complete enough to go into the App Store
    or Google Play Store. Of course not using this exact game, but we have learned
    enough material to create one. It's a great accomplishment to have completed game
    framework, especially in the short amount of time it took to create something
    so simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some skills you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving high scores using `saveValue()` and `loadValue()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to pause physics/timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the pause menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing scenes with the Storyboard API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transitions between scenes using loading screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a main menu to introduce the game title and submenus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter was an important milestone to achieve. Everything that we have
    gone over in the previous chapters was applied to this sample game. The great
    thing about it is that it took only less than a day's worth of development to
    code. The art assets on the other hand are a different story.
  prefs: []
  type: TYPE_NORMAL
- en: We still have quite a few more things to learn of what Corona SDK is capable
    of. In the next chapter, we'll go over more in detail on how to optimize our game
    assets for high-resolution devices. We're also going to go over how to post messages
    on Facebook and Twitter and sync our applications with Openfeint!
  prefs: []
  type: TYPE_NORMAL
