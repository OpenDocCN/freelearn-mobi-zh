<html><head></head><body>
		    <div class="readerChapterContent">
		      <div>
  <h1 class="Title-1"><span>Chapter 1. Understanding the Architecture</span></h1>

  <p><span>In this chapter, the user will learn about Android hardware and software architecture. We will provide an overview on the </span><span class="emphasis"><em><span>Android Compatibility Definition Document</span></em></span><span> to properly understand what we need in order to create a fully compliant and certified device.</span></p>

  <p><span>The user will learn about the </span><span class="strong"><strong><span>Android Application Framework</span></strong></span><span> (</span><span class="strong"><strong><span>AAF</span></strong></span><span>), the two different Android runtime systems—Dalvik, and ART, and a collection on Google-provided system libraries.</span></p>

  <p><span>The user will have a first hands-on moment, setting up and running Android Compatibility Test Suite. We will test together an existing certified device and we will take the first step on the path towards the creation of a certified device.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>An overview of the Android system</span></h2>

  <p><span>Android, as with every other operating system, has a layer-based structure. The next image shows a properly abstracted overview of the whole system architecture:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_3.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_3" style="max-width:577px;max-height:875px"/></div>

  <p><span>We can divide the system into the following main layers:</span></p>

  <ul>
    <li><span>Linux kernel</span></li>

    <li><span>Hardware abstraction layer</span></li>

    <li><span>Core libraries and runtime environment</span></li>

    <li><span>Application framework</span></li>

    <li><span>Binder IPC</span></li>

    <li><span>Applications</span></li>
  </ul>

  <p><span>The software layer closest to the hardware architecture is the </span><span class="emphasis"><em><span>Linux kernel</span></em></span><span>. This layer is in charge of communicating with the hardware components and provides an easy-to-use interface for the layer above.</span></p>

  <p><span>Moving up on the architecture path, we have Android runtime and core libraries. This layer provides the basics tools for the application framework. The application framework is a collection of </span><span class="strong"><strong><span>ready-to-use</span></strong></span><span> components that the system provides to the Applications layer via the Android SDK. The top layer contains all those applications we use everyday—games, productivity apps, multimedia, and so on.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Linux kernel</span></h3>

  <p><span>Android is based on the Linux kernel, but it's not a classic Linux-based desktop system: it's not Ubuntu. However, Android architecture designers and developers rely on the Linux kernel, because it's open source, it's extensively tested worldwide, and it can be easily tailored to fit Android-specific hardware needs, on any kind of device.</span></p>

  <p><span>From a very pragmatic point of view, choosing to base the system on an open source heart reinforced the Android philosophy of being an open system, supported by its community and trusted by enterprise companies, thanks to its transparency. Besides, this approach saved a lot of development time—they didn't have to start from scratch and they could focus on the rest of the architecture, taking advantage of a popular and well-documented core.</span></p>

  <p><span>The vanilla Linux kernel needed some love to properly fit all the Android requirements. Most of the contributions by Google were focused on:</span></p>

  <ul>
    <li><span>Fixing bugs</span></li>

    <li><span>Enabling new hardware</span></li>

    <li><span>Improving power management</span></li>

    <li><span>Improving error reporting</span></li>

    <li><span>Improving performance</span></li>

    <li><span>Improving security</span></li>
  </ul>

  <p><span>From a hardware point of view, the Android team made a great effort to add new goodies to the Linux kernel. Lots of fixes and hacks were released to improve Bluetooth support and management, lots of </span><span class="strong"><strong><span>General Purpose Input/Output</span></strong></span><span> (</span><span class="strong"><strong><span>GPIO</span></strong></span><span>) drivers were added, ARM compatibility was enhanced, as ARM was the primary Android-supported architecture and also MMC management received lots of contributions. The new ADB gadget driver was added to help developers to communicate via USB with external devices.</span></p>

  <p><span>From a memory point of view, the Android team introduced PMEM, the process memory allocator. This gave the ability to manage large physically contiguous memory regions between user space and kernel space. Working in a specific low-resource hardware domain, the Android team released Ashmem, Android Shared Memory, which targeted low-memory devices and provided an easy-to-use file-based API to manage shared memory, especially under memory pressure.</span></p>

  <p><span>From a power management point of view, the Android team introduced an improved suspend system, wakelocks, and Android Alarm Timers, the kernel implementation to support Android Alarm Manager.</span></p>

  <p><span>The other interesting contributions were the kernel support for Android logcat command, that provides logs of system messages, application debug messages, and exceptions, and Android Binder, an Android-specific interprocess communication system, used for remote method invocation too.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Hardware abstraction layer – HAL</span></h3>

  <p><span>To overcome the increasing hardware fragmentation, Android engineers created an abstraction layer that allows the system to interact with the hardware just being aware of a specific intercommunication interface. The system completely ignores the low-level implementation of hardware and drivers. This approach enforces the idea of developing software </span><span class="emphasis"><em><span>against an interface</span></em></span><span> instead of </span><span class="emphasis"><em><span>against an implementation</span></em></span><span>. With this approach, the Android system does not know and does not need to know how hardware is accessed or managed.</span></p>

  <p><span>As a mid-level layer between the hardware and the system, Android HAL is commonly developed using native technology—C/C++ and shared libraries. There is no constraint from Google about how we need to implement our HAL and our device drivers: it's up to us to design it as we think best for our scenario. There is only one simple rule:</span></p>

  <div class="blockquote">
    <blockquote class="blockquote">
      <p><span class="emphasis"><em><span>Our implementation must provide the same interface that the system is expecting.</span></em></span></p>
    </blockquote>

    <h3 class="Title-2 sigil_not_in_toc"><span>Libraries and the application framework</span></h3>

    <p><span>Going up on the architecture ladder, we find the two most important software layers. The Android application framework and Android system libraries are the middleware between the bare hardware, managed by the Linux kernel, and all those fancy, shiny apps we have on our smartphones.</span></p>

    <h4 class="Title-3 sigil_not_in_toc"><span>Libraries</span></h4>

    <p><span>Android system libraries are a set of libraries, specifically created to work on Android, to allow and help with system components and app development. The most important are:</span></p>

    <ul>
      <li><span class="strong"><strong><span>SQLite</span></strong></span><span>: SQLite is the entry point to the SQL world. It's a tiny SQL implementation for embedded systems and it provides a standard way to access data published by content providers or SQL DB created by the user.</span></li>

      <li><span class="strong"><strong><span>SSL</span></strong></span><span>: SSL provides the standard security environment for network communication.</span></li>

      <li><span class="strong"><strong><span>OpenGL</span></strong></span><span>: OpenGL libraries are the link between the Java (and C/C++ JNI) world and the OpenGL/ES 3D graphics rendering API.</span></li>

      <li><span class="strong"><strong><span>SGL</span></strong></span><span>: SGL provides a way to access 2D rendering engine.</span></li>

      <li><span class="strong"><strong><span>Media framework</span></strong></span><span>: Media framework provides codecs for rendering, recording, and playback for the most common media formats.</span></li>

      <li><span class="strong"><strong><span>WebKit</span></strong></span><span>: WebKit is the popular HTML rendering engine.</span></li>

      <li><span class="strong"><strong><span>libc</span></strong></span><span>: The libc library is a BSD-derived implementation of the standard C library, specifically tuned to best perform on embedded Linux-based devices.</span></li>

      <li><span class="strong"><strong><span>Surface manager</span></strong></span><span>: Surface manager manages access to the display subsystem.</span></li>
    </ul>

    <h3 class="Title-2 sigil_not_in_toc"><span>The application framework</span></h3>

    <p><span>This is the core of the Android software ecosystem. It provides a plethora of managers that facilitate the most common tasks of Android developers and the Android system itself. The most important components of the Application Framework are:</span></p>

    <ul>
      <li><span class="strong"><strong><span>Activity manager</span></strong></span><span>: This provides the </span><span class="emphasis"><em><span>navigation backstack</span></em></span><span> and manages the Android activity lifecycle</span></li>

      <li><span class="strong"><strong><span>Resource manager</span></strong></span><span>: This provides access to noncode resources contained in the apps: graphics, localized string, styles, and colors</span></li>

      <li><span class="strong"><strong><span>Location manager:</span></strong></span><span> This is in charge of providing the most accurate position information, using data collected by the GPS sensor, from cell towers and Wi-Fi networks nearby</span></li>

      <li><span class="strong"><strong><span>Notification manager</span></strong></span><span>: This enables apps to display notification alerts in the status bar, according to Google Design Guidelines, to provide a common and familiar user experience</span></li>

      <li><span class="strong"><strong><span>Content providers</span></strong></span><span>: This provides a common approach to share data between different apps, for instance, accessing contacts data or sharing a common data set between two apps</span></li>

      <li><span class="strong"><strong><span>Views and widgets</span></strong></span><span>: These comprise the UI core of the Android experience. Buttons, text fields, and layouts are the building blocks of every Android system component and user app</span></li>
    </ul>

    <p><span>Everything on Android is achieved using the official Android SDK that provides a consistent and documented way to use all these system managers, views, and logic components to let you create the next big hit of the Google Play Store.</span></p>

    <h3 class="Title-2 sigil_not_in_toc"><span>Binder IPC</span></h3>

    <p><span>From an Application Framework point of view, the Binder Inter-Process Communication (IPC) is a hidden layer. It takes care of creating a transparent communication channel between the high-level Android API, accessible via the Android SDK, and the actual Android system.</span></p>

    <h3 class="Title-2 sigil_not_in_toc"><span>The application layer</span></h3>

    <p><span>All the applications created by third-party entities, such as smartphone manufacturers or Android programmers will be installed on the application layer.</span></p>

    <p><span>Usually, this relies on a read/write area of the handset solid memory, but for software provided by manufacturers, typically, it uses a read-only memory area to be sure that these applications will always be installed no matter what. Apps such as Google Maps, YouTube, Samsung TouchWiz Nature, and HTC Sense are examples of apps in this very group: they are shipped with the device's operating system, they are installed on a read-only memory area of the device, and they are meant to be uninstallable as a core component of the system.</span></p>

    <p><span>As we will see, this is not 100% true—once you have the proper skill set, you will be able to manipulate the whole system. In the following chapters, you will acquire these skills and you will learn how to heavily modify an already existing Android version and get rid of those apps, if necessary.</span></p>
  </div>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Android compatibility</span></h2>

  <p><span>Every successful Android device on the market, before being launched, has been certified. Manufacturers have designed, developed, and tested their device according to precise guidelines, rules, and constraints.</span></p>

  <p><span>To make the task as easy as possible, Google has created the Android Compatibility Program that defines details and tools that help OEMs to create a device that will properly support the OS, the SDK, and the developers' expectations:</span></p>

  <div class="blockquote">
    <blockquote class="blockquote">
      <p><span class="emphasis"><em><span>"To run Android apps on a variety of Android devices."</span></em></span></p>
    </blockquote>

    <p><span>As a manufacturer, creating and distributing a certified device has critical importance. Our goal is to create a device with a unique, but at the same time familiar, user experience: we have to be cool, but not weird! Users want to customize their Android device and they want to be sure that their favorite apps will run smoothly, without problems of any sort. Developers want to be sure that they won't waste time fixing bugs on every different smartphone, tablet, or TV—they want a common ecosystem on which they can rely.</span></p>

    <p><span>A well-defined and well-supported ecosystem brings more certified devices that bring more and more developers that bring more and more happy users. The following diagram shows exactly how the Android ecosystem lives thanks to the constant creation of well-designed, well-produced, certified devices:</span></p>

    <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_4.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_4" style="max-width:437px;max-height:334px"/></div>

    <h3 class="Title-2 sigil_not_in_toc"><span>The Android Compatibility Definition Document</span></h3>

    <p><span>The </span><span class="strong"><strong><span>Android Compatibility Definition Document</span></strong></span><span> (</span><span class="strong"><strong><span>CDD</span></strong></span><span>) is Google's way to specify guidelines, rules, and constraints to be considered for an Android-compatible device. Every device designer and manufacturer has to refer to the CDD to be able to easily port Android onto its own hardware platform.</span></p>

    <p><span>For each release of the Android platform, Google provides a detailed CDD. The CDD represents the </span><span class="emphasis"><em><span>policy</span></em></span><span> aspect of Android compatibility and its role is to codify and clarify all the requirements and eliminate any ambiguity. The main goal is to provide rules for manufacturers to let them create complex hardware devices, compatible with Android SDK and Android apps.</span></p>

    <p><span>Designing and developing a new device is no easy task. Even the smallest detail matters. Think about OpenGL support. There is no possible way to be sure that the graphical experience will be great for the user. The only thing that's possible is working according to the guidelines and then "test, test, and test". That's why providing as many details and guidelines as possible is the only way to help the manufactures to achieve their goal.</span></p>

    <p><span>However, the CDD does not attempt to be comprehensive—it couldn't be. It just serves as guidance to approach as easily as possible the final goal—a compatible device. Further help comes from the source code itself and from the Android SDK API that can be considered a compatibility-proof test bench. Think about CDD as an overview of the minimum set of constraints to be compliant with: it's the very first step of the journey.</span></p>

    <h4 class="Title-3 sigil_not_in_toc"><span>Device types</span></h4>

    <p><span>In the beginning, Android was born to run on digital cameras. Luckily for us, a lot has happened since then: smartphones invaded our world! Then we had tablets and mp3 players. Nowadays, we have TVs, watches, media centers, glasses, and even cars, running Android and Android apps. Every device on the market will probably land in one specific category, according to its features. CDD gives a few pointers about which category your new device would be placed in:</span></p>

    <ul>
      <li><span>Every device with an embedded touchscreen, a power source that allows mobility, and that can be held in hand can be considered an </span><span class="strong"><strong><span>Android Handset</span></strong></span><span>.</span></li>

      <li><span>An </span><span class="strong"><strong><span>Android Television device</span></strong></span><span> is a device designed for media content: video, music, TV, games, with users sitting about three meters or ten feet away. This kind of device must have an embedded screen or an output video interface—HDMI, VGA, DVI, or a wireless display port.</span></li>

      <li><span>A device designed to be worn on a wrist, with a touchscreen display with a diagonal between 2.79 cm and 6.35 cm is considered an </span><span class="strong"><strong><span>Android Watch</span></strong></span><span>.</span></li>

      <li><span>Having a car with an infotainment system, based on Android, gives us an </span><span class="strong"><strong><span>Android Automotive implementation</span></strong></span><span>.</span></li>
    </ul>

    <h4 class="Title-3 sigil_not_in_toc"><span>Software compatibility</span></h4>

    <p><span>From a software execution point of view, the basic requirement is being capable of executing the Android Dalvik bytecode. Our device must support the </span><span class="emphasis"><em><span>Android Application Programming Interface</span></em></span><span> and must provide complete implementations of any documented behaviors of any documented API exposed by the Android SDK or annotated with the </span><code class="literal"><span>@SystemAp</span></code><span> annotation.</span></p>

    <p><span>Hardware compatibility is a tricky task, because even if our device is lacking some specific hardware, for instance GPS or accelerometers, our implementation must contain GPS-related code and should be capable of handling inappropriate requests in a reasonable way to avoid crashes or misbehaviors.</span></p>

    <p><span>One of the main players of software compatibility is the ability of our device to support intents. Every device properly implementing Android API must support Android loose-coupling intent system. Intents allow Android apps to easily request functionality from other Android components and avoid the effort to implement everything from scratch. The Android system has a set of core applications that implement the intent pattern:</span></p>

    <ul>
      <li><span>Desk clock</span></li>

      <li><span>Browser</span></li>

      <li><span>Calendar</span></li>

      <li><span>Contacts</span></li>

      <li><span>Gallery</span></li>

      <li><span>Global Search</span></li>

      <li><span>Launcher</span></li>

      <li><span>Music</span></li>

      <li><span>Settings</span></li>
    </ul>

    <p><span>As a vendor, we could integrate the default Android components or implement our own component, according to the public API. Those components will have special system permissions to act as system apps and they will be the first proposed choice for the matching intent filter.</span></p>

    <p><span>For instance, when a developer ask to open a web page, the system will suggest "our browser component" as the first chosen app to perform the task. Of course, being a good citizen means that we must provide a proper settings menu to give the user the possibility to override our default choice and let the final user pick a different app for the task.</span></p>
  </div>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Beyond Java</span></h2>

  <p><span>Android applications development is mostly based on Java programming. The SDK is based on Java, the runtime system is fully compliant with Java6, partially with Java7, and Google is already experimenting with Java8. Most developers will easily approach the platform if they already know Java programming language. However, Android offers a lot more to those developers that are dealing with heavy-duty, performance-oriented scenarios: Android Native API.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Native API</span></h3>

  <p><span>Native API gives the developers the opportunity to call native </span><span class="emphasis"><em><span>C</span></em></span><span>, and partially </span><span class="emphasis"><em><span>C++</span></em></span><span>, code from an Android Java application. Native code is compiled as standard ELF </span><code class="literal"><span>.so</span></code><span> files and stored in the app APK file. Being native code, it has to be compiled for every architecture we are going to support, because, contrary to the bytecode, it can't be built once and run on every architecture.</span></p>

  <p><span>As integrators, we must embrace one or more </span><span class="strong"><strong><span>Android Application Binary Interfaces</span></strong></span><span> (</span><span class="strong"><strong><span>ABIs</span></strong></span><span>) and aim for having full compatibility with the Android NDK. Of course, Google provides guidelines and constraints to easily reach this goal. These are the basic rules for proper compatibility:</span></p>

  <ul>
    <li><span>Our implementation must include support for code running in the managed environment, that is Java code, to call into native code, using the standard </span><span class="strong"><strong><span>Java Native Interface</span></strong></span><span> (</span><span class="strong"><strong><span>JNI</span></strong></span><span>) semantics</span></li>

    <li><span>If our implementation supports the 64-bit ABI, we must support its relative 32-bit version, too, because we must provide compatibility to non-64 bit potential devices</span></li>

    <li><span>Google suggests that we build our implementation using the source code and header files available in the Android Open Source Project—just don't reinvent the wheel</span></li>
  </ul>

  <p><span>From a libraries point of view, our implementation must be source-compatible (that is, header compatible) and binary-compatible (for the ABI) with all the following libraries:</span></p>

  <ul>
    <li><span>libc (C library)</span></li>

    <li><span>libm (math library)</span></li>

    <li><span>liblog (Android logging)</span></li>

    <li><span>libz (Zlib compression)</span></li>

    <li><span>libdl (dynamic linker)</span></li>

    <li><span>libGLESv1_CM.so (OpenGL ES 1.x)</span></li>

    <li><span>libGLESv2.so (OpenGL ES 2.0)</span></li>

    <li><span>libGLESv3.so (OpenGL ES 3.x)</span></li>

    <li><span>libEGL.so (native OpenGL surface management)</span></li>

    <li><span>libjnigraphics.so, libOpenSLES.so (OpenSL ES 1.0.1 audio support)</span></li>

    <li><span>libOpenMAXAL.so (OpenMAX AL 1.0.1 support)</span></li>

    <li><span>libandroid.so (native Android activity support)</span></li>

    <li><span>libmediandk.so (native media APIs support)</span></li>
  </ul>

  <p><span>These libraries also provide minimal support for the C++ JNI interface as well as support for OpenGL.</span></p>

  <p><span>An implementation of each one of these libraries must be present in our system to be compatible with Android NDK. This is a dynamic list and we cannot treat it as a definitive set of libraries: future versions of Android could add new libraries and increase development possibilities and scenarios. That's why native code compatibility is challenging. For this reason, Google strongly suggests to use the implementations of the libraries listed earlier from the Android Open Source Project, taking advantage of the Open Source philosophy of Android and to enjoy well-supported and well-tested source code.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Maintaining 32-bit support</span></h3>

  <p><span>Nowadays, all major manufactures are switching to 64-bit architecture and new ARMv8 architecture deprecates lots of old CPU operations. Unfortunately, the market is still full of 32-bit compatible software and even on 64-bit architecture we must still support these deprecated operations, to avoid scaring developers and losing precious market share. Fortunately, we can choose to make them available via real hardware support or software emulation, at the expense of performance.</span></p>

  <p><span>Supporting 32-bit architecture can be very tricky. We can just think about one simple scenario, for example, accessing the </span><code class="literal"><span>/proc/cpuinfo</span></code><span> file. Legacy versions of the Android NDK used </span><code class="literal"><span>/proc/cpuinfo</span></code><span> to discover CPU features. For compatibility with applications built using 32-bit NDK, we must specifically include the following things in </span><code class="literal"><span>/proc/cpuinfo</span></code><span> when it is read by 32-bit ARM applications:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Features</span></strong></span><span>: This is followed by a list of any optional ARMv7 CPU features supported by the device</span></li>

    <li><span class="strong"><strong><span>CPU architecture</span></strong></span><span>: This is followed by an integer describing the device's highest supported ARM architecture (for example, 8 for ARMv8 devices)</span></li>
  </ul>

  <p><span>The tricky part is that these requirements only apply when </span><code class="literal"><span>/proc/cpuinfo</span></code><span> is read by 32-bit ARM applications. The file must be not altered when read by 64-bit ARM or non-ARM applications.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>From Dalvik to ART runtime</span></h2>

  <p><span>The original Android runtime implementation was Dalvik. Dalvik was a virtual machine, specifically created for Android, due to the necessity to target low-memory devices. It was an integral part of the system until Android KitKat.</span></p>

  <p><span>As we already said, Android applications are mostly written in Java. When Dalvik was the in-use runtime system, the Java code was compiled into bytecode. This bytecode was then translated to Dalvik bytecode and finally stored into a </span><code class="literal"><span>.dex</span></code><span> (Dalvik Executable). After this procedure, Dalvik was able to run the Android app.</span></p>

  <p><span>Although Dalvik had been designed for slow devices, with low memory, its performance has never been astonishing, not even when the </span><span class="strong"><strong><span>Just-In-Time</span></strong></span><span> compilation was introduced, back with Android 2.2 Froyo. Dalvik JIT was supposed to bring a huge performance boost to Android apps and, from some points of view, it did, but with limitations, such as the infamous </span><span class="emphasis"><em><span>maximum methods number</span></em></span><span>, and the pressure from alternative solutions forced Google to look forward to a new runtime:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_5.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_5" style="max-width:831px;max-height:758px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>The Android runtime</span></h3>

  <p><span>When Android 4.4 </span><span class="emphasis"><em><span>KitKat</span></em></span><span> was released, users could select a new experimental runtime environment in the </span><span class="strong"><strong><span>Settings</span></strong></span><span> menu: ART. Android RunTime or, shortened, ART, is the current default runtime solution that replaced Dalvik from Android 5 </span><span class="emphasis"><em><span>Lollipop</span></em></span><span>. The previous diagram shows a comparison between Dalvik and ART architecture.</span></p>

  <p><span>The idea behind Dalvik's JIT (just-in-time) execution was to profile the applications while they were being executed and dynamically compile the most-used segments of the bytecode into native machine code. Native execution of these most-used segments called </span><span class="strong"><strong><span>traces</span></strong></span><span> would then greatly speed-up the execution of the application even though most of the code would still be interpreted.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>A new old approach – AOT compilation</span></h4>

  <p><span>Art re-introduces the concept of AOT (ahead-of-time) compilation. It works as most compilers do, that is, it compiles the whole application code into the native machine code, without interpreting bytecode at all. This takes some time, but it is done only once when the user downloads the app, so considering the time and amount of resources needed for JIT profiling and optimization that are needed on every application start, it is an acceptable trade-off. Also, since the whole application is now compiled, it is quicker overall and the power consumption is reduced, which improves the device autonomy.</span></p>

  <p><span>ART is the default runtime since Android 5, but Android needs to ensure compatibility with all those apps that are already on the market and all those devices that are running a previous version of Android and won't receive any operating system updates.</span></p>

  <p><span>For backward compatibility reasons, the input bytecode is the same for ART and Dalvik. The application APK file still contains standard </span><code class="literal"><span>.dex</span></code><span> files, but replaces the </span><code class="literal"><span>.odex</span></code><span> files (Optimized Dalvik Executables) with the standard Unix ELF files (Executable and Linkable Format). During the installation, ART uses </span><code class="literal"><span>dex2oat</span></code><span> utility to compile the bytecode into native code stored in the ELF file. As already mentioned, this step is performed only once and requires fewer resources and less overhead than Dalvik's JIT compilation. The downside is that the APK files are larger because they effectively contain double the code (uncompiled bytecode and compiled executable). After this compilation, the system will run just the ELF executable.</span></p>

  <p><span>The bottom line is faster apps, but a bit less free space on your smartphone memory.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Garbage collection and other improvements</span></h4>

  <p><span>AOT compilation is not the only improvement that ART brought in. One of the most important features is the improved garbage collection. </span><span class="strong"><strong><span>Garbage Collection</span></strong></span><span> (</span><span class="strong"><strong><span>GC</span></strong></span><span>) is a form of automatic memory management, completely different from the old idea where the developer was the one in charge of allocating memory when needed and freeing it when it was not needed anymore.</span></p>

  <p><span>The whole philosophy is based on the concept of </span><span class="strong"><strong><span>Garbage Collector</span></strong></span><span>, an entity that tries to reclaim memory occupied by objects that are not used anymore in the program. It's a well-known tool in the Java world and Android has always suffered from its downside—GC is very slow and blocking.</span></p>

  <p><span>Android 2.3 introduced the concurrent garbage collector—GC is not blocking the app anymore when it occurs, but there will always be an overall slowdown when it occurs. Finally, ART introduced a few more performance improvements:</span></p>

  <ul>
    <li><span>Just one pause for garbage collection instead of Dalvik's two pauses</span></li>

    <li><span>GC processing is now parallelized, reducing the duration of the GC pause</span></li>

    <li><span>New Rosalloc memory allocator that uses thread-local region allocations for smaller objects and separate locks for bigger objects, instead of a single global lock</span></li>

    <li><span>Full garbage collection is run only when the phone is locked so that the user doesn't notice when the GC is run</span></li>

    <li><span>There is a compacting GC that reduces memory fragmentation and so diminishes the need to kill other applications just because bigger contiguous memory chunks are needed</span></li>
  </ul>

  <p><span>From a development and debugging point of view, ART brought in the support for sampling profiler, support for more debugging features, and improved diagnostic details in exceptions and crash reports.</span></p>

  <h4 class="Title-3 sigil_not_in_toc"><span>Waiting for Android Nougat</span></h4>

  <p><span>The upcoming version of Android will bring some enhancement to the current ART runtime. Google will introduce a so-called Profile-guided JIT/AOT compilation. JIT stands for Just In Time and looks similar to the old Dalvik approach: a compiler with code profiling capabilities. This JIT compiler will work together with ART and will provide constant performance improvement as it will continuously be profiling code and resource usage.</span></p>

  <p><span>To improve performance during the installation phase, ART won't pre-compile Ahead-Of-Time the whole app. Instead, thanks to the profiling approach, it will detect hot methods in the app and will only pre-compile them, leaving unused parts of the app uncompiled. This precompilation process is smartly performed when the device is idle and charging, to have the smallest negative impact on the user experience and allow the user to install in instants apps that in Android 6 would take several seconds to be installed.</span></p>

  <p><span>This whole new approach aims to improve applications and system performance on low end devices, reducing RAM memory footprint, battery draining and increasing runtime performance, for a satisfying Android experience on a wide range of devices.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Meeting the Compatibility Test Suite</span></h2>

  <p><span>We are aware of the CDD and we did our best to create a compatible device. A lot of aspects could still have glitches and we surely want to get rid of them. To make sure that everything works as expected, our Android implementation must be tested with Android Compatibility Test Suite. Android CTS will accompany us throughout the journey to our certified device. We will constantly use it to keep an eye on what is working and what is not working yet.</span></p>

  <p><span>Every new version of Android platform comes with a new </span><span class="strong"><strong><span>Compatibility Test Suite</span></strong></span><span> (</span><span class="strong"><strong><span>CTS</span></strong></span><span>). This automated testing suite has two main components:</span></p>

  <ul>
    <li><span>Tradefed, that manages text execution from the desktop.</span></li>

    <li><span>Test cases executed on the </span><span class="strong"><strong><span>Device Under Test</span></strong></span><span> (</span><span class="strong"><strong><span>DUT</span></strong></span><span>). These cases are regular JUnit tests written in Java and packaged as Android </span><code class="literal"><span>.apk</span></code><span> files so that they can be executed on the target device.</span></li>
  </ul>

  <p><span>There is also the CTS Verifier, a tool for manual testing that consists of the verifier app that is executed on the device and collects the test results; and other executables or scripts that are executed on the desktop machine in order to provide further data or control for some test cases in the Verifier app.</span></p>

  <p><span>The following diagram shows the CTS workflow:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_6.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_6" style="max-width:612px;max-height:493px"/></div>

  <p><span>The test suite on your computer will install the test on the device and will launch it. The device will test that particular subset of features and will give the results back to the test suite on your computer. The test suite will store these results, install the next test, and will start the cycle again, until every test is executed.</span></p>

  <p><span>Currently, the CTS provides two main types of test cases:</span></p>

  <ul>
    <li><span>Unit tests</span></li>

    <li><span>Functional tests</span></li>
  </ul>

  <p><span>Unit tests test the smallest logical units of code within the Android platform, for example, a single class, such as </span><code class="literal"><span>java.util.HashMap</span></code><span>.</span></p>

  <p><span>Functional tests are used to test a specific function that can consist of numerous API method calls.</span></p>

  <p><span>Google is planning to provide more tests in the future versions of the test case. A couple of ideas are:</span></p>

  <ul>
    <li><span class="strong"><strong><span>Robustness tests</span></strong></span><span>: This tests the system's durability under stress conditions</span></li>

    <li><span class="strong"><strong><span>Performance tests</span></strong></span><span>: This tests the system's performance, such as frames per second</span></li>
  </ul>

  <p><span>The following table shows the areas covered by the Compatibility Test Suite:</span></p>

  <div class="qrbodyPic"><img class="width60" src="imgs/epub_36702041_7.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_7" style="max-width:524px;max-height:815px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>CTS setup</span></h3>

  <p><span>Our journey will be very practical and hands-on, that's why in this section we are going to set up Android Compatibility Test Suite to test an existing device. We can't start working on our own Android implementation without knowing what we are going to support and test. To be able to run Android CTS, we will need:</span></p>

  <ul>
    <li><span>A computer running Linux or OS X</span></li>

    <li><span class="emphasis"><em><span>Android SDK</span></em></span><span>:</span><span> </span><a class="ulink" href="http://developer.android.com/sdk/installing/index.html"><span>http://developer.android.com/sdk/installing/index.html</span></a></li>

    <li><span class="emphasis"><em><span>Java SDK 6 or 7</span></em></span><span>:</span><span> </span><a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html"><span>http://www.oracle.com/technetwork/java/javase/downloads/index.html</span></a></li>

    <li><span class="emphasis"><em><span>Android CTS</span></em></span><span>:</span><span> </span><a class="ulink" href="http://source.android.com/compatibility/downloads.html"><span>http://source.android.com/compatibility/downloads.html</span></a></li>

    <li><span class="emphasis"><em><span>Android CTS Media</span></em></span><span>:</span><span> </span><a class="ulink" href="https://dl.google.com/dl/android/cts/android-cts-media-1.1.zip"><span>https://dl.google.com/dl/android/cts/android-cts-media-1.1.zip</span></a></li>
  </ul>

  <p><span>There are a lot of files to download. In the meantime, we will set up our device.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Device setup</span></h3>

  <p><span>We are testing an existing device, a smartphone, so we are already satisfying needs such as having a screen and we can move to device software configuration.</span></p>

  <p><span>Tests should be executed on a </span><span class="emphasis"><em><span>clean</span></em></span><span> device, so we should run a </span><span class="strong"><strong><span>Factory Restore</span></strong></span><span> to erase all the data on the smartphone. Be sure of having a backup of your data if you are not using a development device. On Android 4.4 KitKat, you can reach the specific menu by navigating to </span><span class="strong"><strong><span>Settings</span></strong></span><span> | </span><span class="strong"><strong><span>Backup &amp; reset</span></strong></span><span> | </span><span class="strong"><strong><span>Factory data reset</span></strong></span><span>.</span></p>

  <p><span>This will take a while—the device will shut down and the erasing process will start. The procedure will remove every single byte that is not part of the original Android system provided with your device, restoring all the settings and bringing the device to its original setup.</span></p>

  <p><span>When the device restarts, we need to select </span><code class="literal"><span>English US</span></code><span> language by navigating to </span><span class="strong"><strong><span>Settings</span></strong></span><span> | </span><span class="strong"><strong><span>Language &amp; input</span></strong></span><span> | </span><span class="strong"><strong><span>Language</span></strong></span><span>.</span></p>

  <p><span>Now we need to turn on the </span><span class="strong"><strong><span>Location</span></strong></span><span>: We need Wi-Fi and GPS and we need to provide some Internet connectivity. We need to disable any </span><span class="strong"><strong><span>Screen Lock</span></strong></span><span> by navigating to </span><span class="strong"><strong><span>Settings</span></strong></span><span> | </span><span class="strong"><strong><span>Security</span></strong></span><span> | </span><span class="strong"><strong><span>Screen Lock = 'None'</span></strong></span><span>.</span></p>

  <p><span>We need a few settings from the </span><span class="strong"><strong><span>Developer options</span></strong></span><span> menu. On a brand new installation of a vanilla Android system this menu is hidden. We can enable using the following steps:</span></p>

  <ol>
    <li><span>N</span><span>a</span><span>v</span><span>i</span><span>g</span><span>a</span><span>t</span><span>e</span><span> </span><span>t</span><span>o</span><span> </span><span class="strong"><strong><span>Settings</span></strong></span><span> </span><span>|</span><span> </span><span class="strong"><strong><span>About phone</span></strong></span><span>.</span></li>

    <li><span>Scroll to the bottom.</span></li>

    <li><span>Tap continuously on build number item.</span></li>

    <li><span>You are now a developer!</span></li>
  </ol>

  <h4 class="Title-3 sigil_not_in_toc"><span>Note</span></h4>

  <p><span>If you are working with an HTC, Samsung, or Sony device and its custom version of Android, the previous steps could be a bit different. We leave it as an exercise to find the right navigation path for your non-vanilla Android version.</span></p>

  <p><span>Once the </span><span class="strong"><strong><span>Developer options</span></strong></span><span> menu has been enabled, navigate back to the </span><span class="strong"><strong><span>Settings</span></strong></span><span> screen. In the </span><span class="strong"><strong><span>Developer options</span></strong></span><span> menu, we need to enable the following:</span></p>

  <ul>
    <li><span>USB debugging</span></li>

    <li><span>Stay awake</span></li>

    <li><span>Allow mock locations</span></li>
  </ul>

  <p><span>Before running any tests, it's important that the device is on a steady support to avoid triggering accelerometers and the gyroscope. The camera should be pointing to a focusable object. Don't press any buttons or keys during the tests—this could invalidate test results.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Media files setup</span></h3>

  <p><span>To properly run all the tests, we will need a few multimedia files on the device—Android CTS media files. First of all, let's connect the device to the USB. If this is the first time that you connect this device to this host PC, the device will display a dialog to authorize the connection—allow the connection:</span></p>

  <p><span>Any Android device can communicate with a host PC using Android </span><code class="literal"><span>ADB</span></code><span>. This key tool is covered in great detail in the next chapters, so, for now, we can start downloading the latest Android SDK from </span><a class="ulink" href="https://developer.android.com/studio/index.html#downloads"><span>https://developer.android.com/studio/index.html#downloads</span></a><span>, according to your platform. Once the download is completed, decompress the file and you will be provided with an </span><code class="literal"><span>android-sdk</span></code><span> folder, containing a </span><code class="literal"><span>platform-tools</span></code><span> folder, containing adb executable.</span></p>

  <p><span>Back to our media files setup now:</span></p>

  <ol>
    <li><span>Open a terminal.</span></li>

    <li><span>Navigate to the downloaded file, for instance:

      </span><pre><span class="strong"><strong>$ cd ~/Downloads</strong></span>
</pre>
    </li>

    <li><span>Unzip the file:

      </span><pre><span class="strong"><strong>$ unzip android-cts-media-1.1.zip</strong></span>
</pre>
    </li>

    <li><span>Enter the brand new </span><code class="literal"><span>android-cts-media</span></code><span> folder with:

      </span><pre><span class="strong"><strong>$ cd android-cts-media</strong></span>
</pre>
    </li>

    <li><span>This folder contains a file that we must make executable:

      </span><pre><span class="strong"><strong>$ chmod u+x copy_media.sh</strong></span>
</pre>
    </li>

    <li><span>Now we are ready to copy all the media files we need onto the device:

      </span><pre><span class="strong"><strong>$ ./copy_media.sh all</strong></span>
</pre>
    </li>
  </ol>

  <p><span>The next screenshot shows the output of the whole procedure:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_8.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_8" style="max-width:1000px;max-height:949px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Run!</span></h3>

  <p><span>Everything is in place now and we can use </span><code class="literal"><span>cts-tradefed</span></code><span> to run some test plans. Move to the Android CTS folder and run the following command to enter the </span><code class="literal"><span>cts</span></code><span> console:</span></p>
  <pre><span class="strong"><strong>$ ./tools/cts-tradefed</strong></span>
</pre>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_9.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_9" style="max-width:481px;max-height:96px"/></div>

  <p><span>The previous screenshot shows how </span><code class="literal"><span>cts-tradefed</span></code><span> automatically identifies our connected device and gets ready to test.</span></p>

  <p><span>CTS console provides a few useful commands:</span></p>

  <ul>
    <li><code class="literal"><span>list plans</span></code><span>: This will list all the available test plans in the repository</span></li>

    <li><code class="literal"><span>list packages</span></code><span>: This will list all the available test packages in the repository</span></li>

    <li><code class="literal"><span>run</span></code><span>: This will allow us to run all the tests we want</span></li>
  </ul>

  <p><span>Typically, the following test plans are available:</span></p>

  <ul>
    <li><span>All CTS tests required for compatibility</span></li>

    <li><span>Signature tests the signature verification of all public APIs</span></li>

    <li><span>Android tests for the Android APIs</span></li>

    <li><span>Java tests for the Java core library</span></li>

    <li><span>VM tests for ART or Dalvik</span></li>

    <li><span>Performance tests for your implementation</span></li>
  </ul>

  <p><span>As our first approach to CTS, we are going to run </span><span class="emphasis"><em><span>CTS</span></em></span><span> plan:</span></p>
  <pre><span class="strong"><strong>cts-tf &gt; run cts --plan CTS --disable-reboot</strong></span>
</pre>

  <p><span>The testing will start immediately and the console will be full of log messages in the blink of an eye, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_10.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_10" style="max-width:758px;max-height:323px"/></div>

  <p><span>Now, grab some coffee or make some good tea: this will take a while. </span><code class="literal"><span>cts-tradefed</span></code><span> will test everything that is possible to test with an automatic test. Luckily for us, there is a lot that can be tested in this way.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Analyzing the test results</span></h3>

  <p><span>Time has passed, the tea has gone, and the tests are over. On a quad-core smartphone, such as a Motorola Moto G or Nexus 4, this could take up to 10 hours. Eventually, we have got some nice results to check out. According to the folder's path we are working in, we will have results in a </span><code class="literal"><span>.zip</span></code><span> file in the </span><code class="literal"><span>cts</span></code><span> folder:</span></p>
  <pre><span class="strong"><strong>$ unzip ~/bin/android-cts/repository/results/START_TIME.zip</strong></span>
</pre>

  <p><span>Unzipping the file, we will find a </span><code class="literal"><span>testResult.xml</span></code><span> file. Opening this file with a recent web browser (Firefox is working fine here) will show plenty of meaningful tables, with all kind of test and results. The next screenshot shows the initial Test Summary. We have information about the test duration, how many tests were executed, how many tests passed, and how many tests failed:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_11.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_11" style="max-width:456px;max-height:354px"/></div>

  <p><span>As you can see, even testing a certified smartphone, currently on the market, will produce some failed tests. This gives you an idea about the complexity of producing the perfect Android device.</span></p>

  <p><span>The next screenshot shows Test Summary by Package, specifying the test results one test after the other. For brevity, we are showing just a subset of the results:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_12.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_12" style="max-width:830px;max-height:471px"/></div>

  <p><span>The previous Test Summary screenshot shows that 29 tests have failed. If we dig into the test result file, we see that detailed reports are also available. This further information is hugely useful to precisely spot the failed test, like the one in the following screenshot, and investigate the issue:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_13.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_13" style="max-width:829px;max-height:126px"/></div>

  <p><span>The test result file tries to play polite and, for brevity, does not show the full stacktrace of the failed test. To reach the stack trace of the failure, we must inspect the source code of </span><code class="literal"><span>testResult.xml</span></code><span>. For every executed test, there is a corresponding </span><code class="literal"><span>&lt;Test&gt;</span></code><span> tag. For those tests that failed, we will have a </span><code class="literal"><span>&lt;StackTrace&gt;</span></code><span> tag too. That's what we are looking for!</span></p>

  <p><span>As a final note, </span><code class="literal"><span>testResult.xml</span></code><span> contains a huge section with all the information about the device it has been able to retrieve. It's a very large amount of data that, for brevity, we are not reporting here, not even as an example.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Diving deeper with CTS Verifier</span></h2>

  <p><span>We already know that there are lots of APIs and functions that we can automatically test with </span><code class="literal"><span>cts-tradefed</span></code><span>, but what about all the other APIs and functions that cannot be tested within an automated environment?</span></p>

  <p><span>CTS Verifier comes in every time an API or a function cannot be tested on a device without manual input. These are scenarios involving audio quality, touchscreen effectiveness, accelerometer precision and reactivity, camera quality, and features that are meant so specifically for human interaction that they are impossible to test without human interaction.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Setup</span></h3>

  <p><span>All we need to run CTS Verifier is an Android certified device and the appropriate CTS Verifier APK file. As we are testing an Android 4.4 device, we need to pay attention to downloading the proper CTS Verifier version. You can download the APK for your Android version and device architecture here: </span><a class="ulink" href="http://source.android.com/compatibility/downloads.html"><span>http://source.android.com/compatibility/downloads.html</span></a><span>.</span></p>

  <p><span>You just need to unzip the downloaded file and you will find a folder hierarchy and two </span><code class="literal"><span>.apk</span></code><span> files. You can install </span><code class="literal"><span>CtsVerifier.apk</span></code><span> using ADB:</span></p>
  <pre><span class="strong"><strong>$ adb install –r CtsVerifier.apk</strong></span>
</pre>

  <p><span>The following screenshot shows the properly installed CTS Verified app and the initial screen:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_14.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_14" style="max-width:566px;max-height:466px"/></div>

  <h3 class="Title-2 sigil_not_in_toc"><span>Manual testing</span></h3>

  <p><span>As we know, CTS Verifier contains tests that need manual input to execute, evaluate, pass, or fail. Every test has its own </span><span class="strong"><strong><span>Info</span></strong></span><span> screen that helps the tester to perform the test. As an example, we will run the </span><span class="strong"><strong><span>Accelerometer Test</span></strong></span><span>, in the </span><span class="strong"><strong><span>Sensors</span></strong></span><span> section.</span></p>

  <p><span>Launching the test, we are welcomed by the info screen, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_15.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_15" style="max-width:300px;max-height:456px"/></div>

  <p><span>The </span><span class="strong"><strong><span>Info</span></strong></span><span> button explains how to perform the test and what to evaluate. As we move into the testing, we can evaluate if the accelerometer is working as expected. The following screenshot shows three different moments of the test:</span></p>

  <ul>
    <li><span>The smartphone lays on the desk</span></li>

    <li><span>The smartphone is held in hand, in portrait mode</span></li>

    <li><span>The smartphone is held in hand, in landscape mode



      </span><div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_16.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_16" style="max-width:832px;max-height:509px"/></div>
    </li>
  </ul>

  <p><span>As specified in the </span><span class="strong"><strong><span>Info</span></strong></span><span> button, the arrow is always pointing in the same direction as the gravity: the sensor is working properly. We can consider that we have passed the test and click on the </span><span class="strong"><strong><span>Pass</span></strong></span><span> button.</span></p>

  <p><span>We have passed our first test. CTS Verifier provides dozens of tests and, one by one, we are going to run, verify, and pass them, in the long journey towards our first Android Certified Device.</span></p>

  <h3 class="Title-2 sigil_not_in_toc"><span>Retrieving the results</span></h3>

  <p><span>When every test has been executed, we can save the result using the Save icon in the top-right corner of the initial screen, as shown in previous screenshot. The results will be saved on the device and a dialog box will show the precise path, as shown in the following screenshot:</span></p>

  <div class="qrbodyPic"><img class="width50" src="imgs/epub_36702041_17.jpeg" data-src="https://res.weread.qq.com/wrepub/epub_36702041_17" style="max-width:300px;max-height:456px"/></div>

  <p><span>Now, let's open a terminal and copy all the results from the phone to our computer:</span></p>
  <pre><span class="strong"><strong>$ adb pull /mnt/sdcard/ctsVerifierReports/ .</strong></span>
<span class="strong"><strong>$ unzip *.zip</strong></span>
</pre>

  <p><span>At this point, we have a </span><code class="literal"><span>ctsVerifierReport-[…].xml</span></code><span> with all the info about our manually executed tests.</span></p>

  <p><span>Congratulations! You have fully tested an Android device. Step 0 of our journey is complete.</span></p>
</div>
		    </div>
		  

		    <div class="readerChapterContent">
		      <div>
  <h2 class="Title-1"><span>Summary</span></h2>

  <p><span>In this chapter, we learned what we are going to need to create a certified Android device. We saw the Android Compatibility Definition Document and we learned how to design a system to match the Android architecture. We had an overview of the two different runtime systems: Dalvik and ART and their main differences.</span></p>

  <p><span>We had a full immersion into Android device testing, we learned how to run CTS automated tests and CTS manual tests on a already certified device.</span></p>

  <p><span>The next chapter will be very </span><span class="emphasis"><em><span>hands-on</span></em></span><span>. We will learn how to retrieve Android source code and we will understand the code structure and organization.</span></p>
</div>
		    </div>
		  </body></html>